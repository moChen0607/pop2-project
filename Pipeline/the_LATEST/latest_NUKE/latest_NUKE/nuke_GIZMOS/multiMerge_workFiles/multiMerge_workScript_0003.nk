#! /usr/local/Nuke9.0v6/libnuke-9.0.6.so -nx
version 9.0 v6
define_window_layout_xml {<?xml version="1.0" encoding="UTF-8"?>
<layout version="1.0">
    <window x="0" y="25" w="1920" h="1150" screen="0">
        <splitter orientation="1">
            <split size="40"/>
            <dock id="" hideTitles="1" activePageId="Toolbar.1">
                <page id="Toolbar.1"/>
            </dock>
            <split size="925" stretch="1"/>
            <splitter orientation="2">
                <split size="641"/>
                <dock id="" activePageId="Viewer.1">
                    <page id="Viewer.1"/>
                </dock>
                <split size="451"/>
                <dock id="" activePageId="DAG.1">
                    <page id="DAG.1"/>
                    <page id="Curve Editor.1"/>
                    <page id="DopeSheet.1"/>
                    <page id="DAG.2"/>
                    <page id="DAG.3"/>
                </dock>
            </splitter>
            <split size="943"/>
            <splitter orientation="2">
                <split size="363"/>
                <dock id="" activePageId="Properties.1">
                    <page id="Properties.1"/>
                </dock>
                <split size="729"/>
                <dock id="" activePageId="uk.co.thefoundry.scripteditor.1">
                    <page id="uk.co.thefoundry.scripteditor.1"/>
                </dock>
            </splitter>
        </splitter>
    </window>
</layout>
}
Root {
 inputs 0
 name /home/ckenne24/mount/collaborative/portal-origins-part-2/Pipeline/the_LATEST/latest_NUKE/nuke_GIZMOS/multiMerge_workScript_0003.nk
 frame 7
 last_frame 7
 lock_range true
 format "2048 1556 0 0 2048 1556 1 2K_Super_35(full-ap)"
 proxy_type scale
 proxy_format "1024 778 0 0 1024 778 1 1K_Super_35(full-ap)"
}
Viewer {
 inputs 0
 frame 7
 frame_range 1-7
 colour_sample_bbox {-0.6999999881 0.431250006 -0.6984375119 0.4328125119}
 name Viewer1
 xpos -20
 ypos 92
}
Group {
 inputs 0
 name TX_Fog
 help "TX_Fog\nby Tomas Lefebvre\n\n/// v2.0"
 tile_color 0xccccccff
 xpos -358
 ypos -26
 addUserKnob {20 Settings}
 addUserKnob {26 noiseSetupDiv l "<b>noise basic settings</b>"}
 addUserKnob {20 noiseTabBegin l "" +STARTLINE n -2}
 addUserKnob {20 Noise}
 addUserKnob {41 size l x/ysize T Noise0.size}
 addUserKnob {41 zoffset l z T Noise0.zoffset}
 addUserKnob {41 octaves T Noise0.octaves}
 addUserKnob {41 nyquist l "clip at Nyquist limit" -STARTLINE T Noise0.nyquist}
 addUserKnob {41 lacunarity T Noise0.lacunarity}
 addUserKnob {41 gain T Noise0.gain}
 addUserKnob {41 gamma T Noise0.gamma}
 addUserKnob {20 "" l Transform}
 addUserKnob {41 transform T Noise0.transform}
 addUserKnob {41 translate T Noise0.translate}
 addUserKnob {41 rotate T Noise0.rotate}
 addUserKnob {41 scale T Noise0.scale}
 addUserKnob {41 skew +INVISIBLE T Noise0.skew}
 addUserKnob {41 center T Noise0.center}
 addUserKnob {41 xrotate T Noise0.xrotate}
 addUserKnob {41 yrotate T Noise0.yrotate}
 addUserKnob {20 "" l Color}
 addUserKnob {41 color T Noise0.color}
 addUserKnob {6 color_rampBT l ramp +STARTLINE}
 addUserKnob {12 color_p0 l p0}
 color_p0 {100 500}
 addUserKnob {18 color_color2 l color}
 color_color2 {1 0 0}
 addUserKnob {6 color_color2_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {12 color_p1 l p1}
 color_p1 {2000 1500}
 addUserKnob {20 noiseTabEnd l "" +STARTLINE n -3}
 addUserKnob {26 deadSpace1 l "" +STARTLINE T "  "}
 addUserKnob {3 subdivisions}
 subdivisions 10
 addUserKnob {22 update -STARTLINE T "from __future__ import with_statement\nthisNode = nuke.thisNode()\nsubdivs = int(thisNode\['subdivisions'].value())\nresolution = int(thisNode\['resolution'].value())\n\nwith thisNode :\n\n\tnAll = nuke.allNodes()\n\tprint nAll\n\n\tfor n in nAll:\n    \t\tif n.name().split('_')\[0] == 'sub' :\n        \t\t\tnuke.delete(n)\n\tfor j in range(subdivs):\n    \t\ti = j + 1\n\n    \t\t##Noise\n    \t\tnoiseKnobs = \['octaves', 'nyquist', 'lacunarity', 'gain', 'gamma', 'translate', 'rotate', 'skew', 'center', 'ramp', 'color', 'xrotate', 'yrotate']\n    \t\tnoise = nuke.nodes.Noise(xpos = nuke.toNode('Noise0').xpos()+i*150,\n                    \t                          \typos =nuke.toNode('Noise0').ypos())\n    \t\tnoise.setName('sub_' + str(i) + '_Noise')\n    \t\tnoise\['color'].setValue(\[0,0,0,0])\n    \t\tfor k in noiseKnobs :\n        \t\t\tnoise\[k].setExpression('parent.Noise0.' + str(k))\n    \t\tnoise\['size'].setValue(\[0,0])\n    \t\tnoise\['size'].setExpression('parent.Noise0.size.0',0)\n    \t\tnoise\['size'].setExpression('parent.Noise0.size.1',1)\n    \t\tnoise\['scale'].setValue(\[0,0])\n    \t\tnoise\['scale'].setExpression('parent.Noise0.scale.w',0)\n    \t\tnoise\['scale'].setExpression('parent.Noise0.scale.h',1)\n    \t\tnoise\['zoffset'].setExpression('parent.Noise0.zoffset+' + str(i) + '*parent.variancy')\n    \t\tnoise\['xrotate'].setExpression('parent.Noise0.xrotate')\n    \t\tnoise\['yrotate'].setExpression('parent.Noise0.yrotate')\n    \t\tnoise.setInput(0,nuke.toNode('Base'))\n\t\n    \t\t##Ramp\n    \t\tunpRamp = nuke.nodes.Unpremult(xpos = nuke.toNode('Noise0').xpos()+i*150,\n                    \t                                         \typos =nuke.toNode('Unpremult0').ypos())\n    \t\tunpRamp.setName('sub_' + str(i) + '_Unpremult')\n    \t\tunpRamp\['disable'].setExpression('!parent.color_rampBT')\n    \t\tunpRamp.setInput(0,noise)\n\t\n    \t\tramp = nuke.nodes.Ramp(xpos = nuke.toNode('Noise0').xpos()+i*150,\n                    \t                          \typos = nuke.toNode('Ramp0').ypos())\n    \t\tramp.setName('sub_' + str(i) + '_Ramp')\n    \t\tramp\['disable'].setExpression('!parent.color_rampBT')\n    \t\tramp\['p0'].setExpression('parent.color_p0')\n    \t\tramp\['output'].setValue('rgb')\n    \t\tramp\['color'].setValue(\[0,0,0,0])\n    \t\tramp\['color'].setExpression('parent.color_color2.r',0)\n    \t\tramp\['color'].setExpression('parent.color_color2.g',1)\n    \t\tramp\['color'].setExpression('parent.color_color2.b',2)\n    \t\tramp\['p1'].setExpression('parent.color_p1')\n    \t\tramp.setInput(0,unpRamp)\n\t\n\t    \tpreRamp = nuke.nodes.Premult(xpos = nuke.toNode('Noise0').xpos()+i*150,\n                    \t                                        \typos =nuke.toNode('Premult0').ypos())\n    \t\tpreRamp.setName('sub_' + str(i) + '_premult')\n    \t\tpreRamp\['disable'].setExpression('!parent.color_rampBT')\n    \t\tpreRamp.setInput(0,ramp)\n\t\n\n    \t\t##Blur\n    \t\tblur = nuke.nodes.Blur(xpos = nuke.toNode('Noise0').xpos()+i*150,\n                    \t                     \typos = nuke.toNode('Blur0').ypos())\n    \t\tblur.setName('sub_' + str(i) + '_Blur')\n    \t\tblur\['channel'].setValue('rgba')\n    \t\tblur\['size'].setValue(\[10,20])\n    \t\tblur\['size'].setExpression('parent.Blur0.size.w',0)\n    \t\tblur\['size'].setExpression('parent.Blur0.size.h',1)\n    \t\tblur.setInput(0,preRamp)\n\t\n\n    \t\t##Edge smooth\n    \t\tsmoothEdge = nuke.nodes.Multiply(xpos = nuke.toNode('Noise0').xpos()+i*150,\n                  \t\t\t                      \typos =nuke.toNode('Multiply0').ypos())\n    \t\tsmoothEdge.setName('sub_' + str(i) + '_Multiply_SEdges')\n    \t\tsmoothEdge\['channel'].setValue('rgba')\n    \t\tsmoothEdge\['value'].setValue(0)\n    \t\tsmoothEdge\['invert_mask'].setValue(True)\n    \t\tsmoothEdge\['disable'].setExpression('!parent.softEdges')\n    \t\tsmoothEdge.setInput(0,blur)\n    \t\tsmoothEdge.setInput(1, nuke.toNode('GradeEdge'))\n    \t\n    \t\t##All the ramps\n    \t\tdecay_x = nuke.nodes.Ramp(xpos = nuke.toNode('Noise0').xpos()+i*150,\n                    \t                               \typos =nuke.toNode('Ramp_X0').ypos())\n    \t\tdecay_x.setName('sub_' + str(i) + '_Ramp_x')\n    \t\tdecay_x\['type'].setValue('smooth')\n    \t\tdecay_x\['color'].setValue(0)\n    \t\tdecay_x\['disable'].setExpression('!parent.decay_XBT')\n    \t\tdecay_x\['p0'].setValue(\[100,100])\n    \t\tdecay_x\['p0'].setExpression('(parent.decay_Xmax==0?1:parent.decay_Xmax)*20.48',0)\n    \t\tdecay_x\['p1'].setValue(\[100,100])\n    \t\tdecay_x\['p1'].setExpression('(parent.decay_Xmin>=parent.decay_Xmax?parent.decay_Xmax-1:parent.decay_Xmin)*20.48',0)\n    \t\tdecay_x.setInput(0,smoothEdge)\n\t\t\n    \t\tdecayx = nuke.nodes.Ramp(xpos = nuke.toNode('Noise0').xpos()+i*150,\n                                        \t           \typos =nuke.toNode('RampX0').ypos())\n    \t\tdecayx.setName('sub_' + str(i) + '_Rampx')\n    \t\tdecayx\['type'].setValue('smooth')\n    \t\tdecayx\['color'].setValue(0)\n    \t\tdecayx\['disable'].setExpression('!parent.decayXBT')\n    \t\tdecayx\['p0'].setValue(\[100,100])\n    \t\tdecayx\['p0'].setExpression('2048-(parent.decayXmax==0?1:parent.decayXmax)*20.48',0)\n    \t\tdecayx\['p1'].setValue(\[100,100])\n    \t\tdecayx\['p1'].setExpression('2048-(parent.decayXmin>=parent.decayXmax?parent.decayXmax-1:parent.decayXmin)*20.48',0)\n    \t\tdecayx.setInput(0,decay_x)\n\t\t\n    \t\tdecay_y = nuke.nodes.Ramp(xpos = nuke.toNode('Noise0').xpos()+i*150,\n                    \t                               \typos =nuke.toNode('Ramp_Y0').ypos())\n    \t\tdecay_y.setName('sub_' + str(i) + '_Ramp_y')\n    \t\tdecay_y\['type'].setValue('smooth')\n    \t\tdecay_y\['color'].setValue(0)\n    \t\tdecay_y\['disable'].setExpression('!parent.decay_YBT')\n    \t\tdecay_y\['p0'].setExpression('(parent.decay_Ymax==0?1:parent.decay_Ymax)*20.48',1)\n    \t\tdecay_y\['p1'].setExpression('(parent.decay_Ymin>=parent.decay_Ymax?parent.decay_Ymax-1:parent.decay_Ymin)*20.48',1)    \t\t\t\t\t\t\t\n\t\tdecay_y.setInput(0,decayx)\n\n\n\t    \tdecayy = nuke.nodes.Ramp(xpos = nuke.toNode('Noise0').xpos()+i*150,\n\t\t\t\typos =nuke.toNode('RampY0').ypos())\n\t    \tdecayy.setName('sub_' + str(i) + '_Rampy')\n\t    \tdecayy\['type'].setValue('smooth')\n\t    \tdecayy\['color'].setValue(0)\n\t    \tdecayy\['disable'].setExpression('!parent.decayYBT')\n\t    \tdecayy\['p0'].setExpression('2048-(parent.decayYmax==0?1:parent.decayYmax)*20.48',1)\n\t    \tdecayy\['p1'].setExpression('2048-(parent.decayYmin>=parent.decayYmax?parent.decayYmax-1:parent.decayYmin)*20.48',1)\n\t    \tdecayy.setInput(0,decay_y)\n\t\n\t    \tdecay_z = nuke.nodes.Dissolve(xpos = nuke.toNode('Noise0').xpos()+i*150,\n\t                                                       \typos =nuke.toNode('Dissolve_Z0').ypos())\n\t    \tdecay_z.setName('sub_' + str(i) + '_Dissolve_z')\n\t    \tdecay_z\['channel'].setValue('rgba')\n\t    \tdecay_z\['disable'].setExpression('!parent.decay_ZBT')\n\t    \tdecay_z\['which'].setExpression('parent.decay_Zmin>='+str(i)+'*100/'+str(subdivs)+'?1:parent.decay_Zmax<='+str(i)+'*100/'+str(subdivs)+'?0:1-('+str(i)+'*100/'+str(subdivs)+'-(parent.decay_Zmin>=parent.decay_Zmax?parent.decay_Zmax-0.01:parent.decay_Zmin))/(parent.decay_Zmax-(parent.decay_Zmin>=parent.decay_Zmax?parent.decay_Zmax-0.01:parent.decay_Zmin))')\n\t    \tdecay_z\['disable'].setExpression('!parent.decay_ZBT')\n    \t\tdecay_z.setInput(1,nuke.toNode('Base'))\n    \t\tdecay_z.setInput(0,decayy)\n\t\n\n\n \t   \t##Opacity\n    \t\tdissolve = nuke.nodes.Dissolve(xpos = nuke.toNode('Noise0').xpos()+i*150,\n                                        \t               \typos =nuke.toNode('Dissolve0').ypos())\n    \t\tdissolve.setName('sub_' + str(i) + '_Dissolve')\n    \t\tdissolve\['channel'].setValue('rgba')\n    \t\tdissolve\['which'].setExpression('parent.Dissolve0.which')\n    \t\tdissolve.setInput(1,decay_z)\n    \t\tdissolve.setInput(0,nuke.toNode('Base'))\n\t\t\n\n\t    \t##Card\n\t    \tcard = nuke.nodes.Card2(xpos = nuke.toNode('Noise0').xpos()+i*150,\n\t                                              \typos =nuke.toNode('Card0').ypos())\n\t    \tcard.setName('sub_' + str(i) + '_Card')\n\t    \tcard\['rows'].setExpression('parent.resolution')\n\t    \tcard\['columns'].setExpression('parent.resolution')\n\t    \tcard\['translate'].setValue(\[0,0,0.5-i*1/subdivs])\n\t    \tcard.setInput(0,dissolve)\n\n\n\n    \t\t##ProcGeo\n\t    \tproc = nuke.nodes.ProcGeo(xpos = nuke.toNode('Noise0').xpos()+i*150,\n                     \t                         \typos =nuke.toNode('ProcGeo0').ypos())\n    \t\tproc.setName('sub_' + str(i) + '_ProcGeo')\n    \t\tproc\['x_size'].setExpression('parent.dNoiseX')\n    \t\tproc\['x_offset'].setExpression('parent.dNoiseXoffset+' + str(i) + '*parent.dNoiseVariancy')\n    \t\tproc\['y_size'].setExpression('parent.dNoiseY')\n    \t\tproc\['y_offset'].setExpression('parent.dNoiseYoffset+' + str(i) + '*parent.dNoiseVariancy')\n    \t\tproc\['Octaves'].setExpression('parent.dNoiseOctaves')\n    \t\tproc\['Lacunarity'].setExpression('parent.dNoiseLacunarity')\n    \t\tproc\['Gain'].setExpression('parent.dNoiseGain')\n    \t\tproc\['Speed'].setExpression('parent.dNoiseSpeed')\n    \t\tproc\['disable'].setExpression('!parent.dNoise')\n    \t\tproc.setInput(0,card)\n    \t\tnuke.toNode('Scene_layers').setInput(i,proc)"}
 addUserKnob {3 resolution l "   resolution" -STARTLINE}
 resolution 10
 addUserKnob {26 noiseAdvSetupDiv l "<b>noise advance settings</b>"}
 addUserKnob {14 blurSize l "blur size" R 0 100}
 addUserKnob {6 softEdges l "soft edges" +STARTLINE}
 softEdges true
 addUserKnob {7 softEdgesSize l "  size" -STARTLINE R 0 300}
 softEdgesSize 200
 addUserKnob {7 opacity}
 opacity 0.25
 addUserKnob {7 variancy R 0 200}
 variancy 100
 addUserKnob {20 decayGroup l decay n 1}
 decayGroup 0
 addUserKnob {6 decay_XBT l -x +STARTLINE}
 addUserKnob {7 decay_Xmin l "  min" -STARTLINE R 0 100}
 addUserKnob {7 decay_Xmax l "  max" -STARTLINE R 0 100}
 decay_Xmax 25
 addUserKnob {6 decayXBT l " x" +STARTLINE}
 addUserKnob {7 decayXmin l "  min" -STARTLINE R 0 100}
 addUserKnob {7 decayXmax l "  max" -STARTLINE R 0 100}
 decayXmax 25
 addUserKnob {6 decay_YBT l -y +STARTLINE}
 addUserKnob {7 decay_Ymin l "  min" -STARTLINE R 0 100}
 addUserKnob {7 decay_Ymax l "  max" -STARTLINE R 0 100}
 decay_Ymax 25
 addUserKnob {6 decayYBT l " y" +STARTLINE}
 addUserKnob {7 decayYmin l "  min" -STARTLINE R 0 100}
 addUserKnob {7 decayYmax l "  max" -STARTLINE R 0 100}
 decayYmax 25
 addUserKnob {6 decay_ZBT l -z +STARTLINE}
 addUserKnob {7 decay_Zmin l "  min" -STARTLINE R 0 100}
 addUserKnob {7 decay_Zmax l "  max" -STARTLINE R 0 100}
 decay_Zmax 25
 addUserKnob {6 decayZBT l INVISIBLE +INVISIBLE +STARTLINE}
 addUserKnob {20 endGroup l decayEndGroup n -1}
 addUserKnob {20 cage n 1}
 cage 0
 addUserKnob {41 cube l cage T Cube1.cube}
 addUserKnob {13 cage_position l translate}
 addUserKnob {13 cage_rotation l rotate}
 addUserKnob {7 cage_scale l scale R 0 50}
 cage_scale 1
 addUserKnob {20 endGroup_1 l endGroup n -1}
 addUserKnob {20 displace n 1}
 displace 0
 addUserKnob {6 bend +STARTLINE}
 addUserKnob {7 bendX l x R -1 1}
 addUserKnob {7 bendY l y R -1 1}
 addUserKnob {26 noisetxt l "" +STARTLINE T " "}
 addUserKnob {6 dNoise l noise +STARTLINE}
 addUserKnob {7 dNoiseX l "x size" R 0 20}
 dNoiseX 2
 addUserKnob {7 dNoiseXoffset l "x offset" R 0 100}
 addUserKnob {7 dNoiseY l "y size" R 0 20}
 dNoiseY 2
 addUserKnob {7 dNoiseYoffset l "y offset" R 0 100}
 addUserKnob {7 dNoiseVariancy l variancy R 0 10}
 dNoiseVariancy 1
 addUserKnob {3 dNoiseOctaves l octaves}
 dNoiseOctaves 5
 addUserKnob {7 dNoiseLacunarity l lacunarity R 0 5}
 dNoiseLacunarity 5
 addUserKnob {7 dNoiseGain l gain R -1 1}
 addUserKnob {7 dNoiseSpeed l speed R 0 10}
 addUserKnob {20 endGroup_2 l endGroup n -1}
 addUserKnob {26 dummy1 l " " T " "}
 addUserKnob {26 credit l "v2.1 -  Tomas Lefebvre"}
}
end_group
NoOp {
 inputs 0
 name MultiMerge1
 onCreate "\nnuke.thisNode()\['merge_num'].setFlag(0x0000000000000002)\n\n"
 xpos -167
 ypos -93
 addUserKnob {20 User}
 addUserKnob {22 update l Update t "Press this button to re-create the node anew with the number of merges required to link up multiple nodes. If nodes are selected, they will be automatically added as inputs in the order that they were selected" -STARTLINE}
 addUserKnob {6 getFromSelection l "Get Number of Merges From Selection" t "When enabled, the current nodes that are selected will be merged together in the order that they were selected when the user presses \"Update\"" -STARTLINE}
 getFromSelection true
 addUserKnob {3 merge_num l "Merge Number" t "If Get Number Of Merges From Selection\" is off, you can state the number of merges you want and then press the \"Update\" button to re-create the node.\n\nWhen \"Get Number Of Merges From Selection\" is on, this slider has no effect" R 1 10}
 merge_num 1
 addUserKnob {26 "" +STARTLINE}
 addUserKnob {4 type l Type t "Select the merge type for all of the merge nodes" M {Over Multiply}}
}
Merge2 {
 inputs 0
 name Merge1
 xpos 51
 ypos -3
}
Group {
 inputs 0
 name Group2
 xpos -32
 ypos -56
}
end_group
Merge {
 inputs 0
 name MasterMerge
 xpos 523
 ypos 41
}
Constant {
 inputs 0
 channels rgb
 name Constant1
 xpos 131
 ypos -136
}
Constant {
 inputs 0
 channels rgb
 name Constant2
 xpos 223
 ypos -129
}
Constant {
 inputs 0
 channels rgb
 name Constant3
 xpos 332
 ypos -131
}
Constant {
 inputs 0
 channels rgb
 name Constant4
 xpos 438
 ypos -132
}
Group {
 inputs 4
 name MultiMerge
 selected true
 xpos 310
 ypos 35
 addUserKnob {20 User -STARTLINE}
 addUserKnob {22 update l Update t "Press this button to re-create the node anew with the number of merges required to link up multiple nodes. If nodes are selected, they will be automatically added as inputs in the order that they were selected" -STARTLINE T "from __future__ import with_statement\n\nif nuke.selectedNodes() <= 1:\n    sys.exit(\"Not enough inputs selected\")\n\nthisNode = nuke.toNode('Group1')\nselectedNodes = nuke.selectedNodes()\nnumOfInputs = thisNode.inputs()\n\nwith thisNode:\n    # RESET\n    nAll = nuke.allNodes()\n    \n    for i in xrange(numOfInputs):\n        thisNode.setInput(i, None)\n    \n    \[nuke.delete(n) for n in nAll if n.name() != \"MasterMerge\"]\n\n    # REINITIALIZE AND CONNECT\n    getFromSelection = int(thisNode.knob('getFromSelection').getValue())\n    if getFromSelection:\n        mergeNum = len(nuke.root().selectedNodes())\n    else:\n        mergeNum = int(thisNode.knob('merge_num').getValue()) - 1\n    \n    count = 0\n    previous = None\n    for i in xrange(mergeNum):  \n        if i+1 != mergeNum:\n            input_h = nuke.createNode(\"Input\")\n            merge_h = nuke.createNode(\"Merge\")\n        \n        if previous is not None:\n            merge_h.connectInput(0, previous)\n        else:\n            input2_h = nuke.createNode(\"Input\")\n            merge_h.setInput(0, None)  # disconnect the auto-connected node input\n            merge_h.setInput(1, None)  # disconnect the auto-connected node input\n            merge_h.connectInput(0, input_h)\n            merge_h.connectInput(1, input2_h)\n            count += 1\n            \n        previous = merge_h\n        if getFromSelection:\n            selectedNodes = nuke.root().selectedNodes()\n            thisNode.connectInput(count-1, selectedNodes\[count-1])\n               \n        count += 1"}
 addUserKnob {6 getFromSelection l "Get Merge Number From Selection" t "When enabled, the current nodes that are selected will be merged together in the order that they were selected when the user presses \"Update\"" -STARTLINE}
 getFromSelection true
 addUserKnob {3 merge_num l "Number of Merges" t "If Get Number Of Merges From Selection\" is off, you can state the number of merges you want and then press the \"Update\" button to re-create the node.\n\nWhen \"Get Number Of Merges From Selection\" is on, this slider has no effect"}
 merge_num 10
 addUserKnob {26 "" +STARTLINE}
 addUserKnob {41 operation T MasterMerge.operation}
}
 Merge {
  inputs 0
  name MasterMerge
  xpos -390
  ypos -193
 }
 Input {
  inputs 0
  name Input4
  xpos 125
  number 3
 }
 Input {
  inputs 0
  name Input3
  xpos 125
  ypos -16
  number 2
 }
 Input {
  inputs 0
  name Input2
  xpos 125
  ypos -32
  number 1
 }
 Input {
  inputs 0
  name Input1
  xpos 125
  ypos -48
 }
 Merge {
  inputs 2
  operation scrn
  name Merge1
 }
 Merge {
  inputs 2
  operation scrn
  name Merge2
 }
 Merge {
  inputs 2
  operation scrn
  name Merge3
  selected true
 }
end_group
