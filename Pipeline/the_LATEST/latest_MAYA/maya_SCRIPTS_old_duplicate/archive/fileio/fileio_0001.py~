#!/usr/bin/env python

"""\
..Project::
 Portal Origins: Part Two
..Description::
 FileIO contains general methods for reading and writing to files using
 globally defined variables from the root project directory
..Author::
 Colin Kennedy

..Improvements::
 - Add named regex groups, instead of querying values as [0]. [1], [2], etc
"""

# IMPORT STANDARD LIBRARIES
import os
import re

# IMPORT THIRD PARTY LIBRARIES
import maya.cmds as cmds

# IMPORT LOCAL LIBRARIES
import constants.constants as consts

class FileCheckoutMaya(FileCheckout):
    def __init__(self, fileName, filePath):
        super(FileCheckoutMaya, __init__).__init__(self)
    # end __init__
    def open():
        """
        Custom Maya-based open command
        """
        pass
    # end open
    def save():
        """
        Custom Maya-based save command
        """
        pass
    # end save
# end FileCheckoutMaya

class FileCheckoutNuke(FileCheckout):
    def __init__(self, fileName, filePath):
        super(FileCheckoutNuke, __init__).__init__(self)
    # end __init__
    def open():
        """
        Custom Maya-based open command
        """
        pass
    # end open
    def save():
        """
        Custom Maya-based save command
        """
        pass
    # end save
# end FileCheckoutNuke

class FileCheckoutHoudini(FileCheckout):
    def __init__(self, fileName, filePath):
        super(FileCheckoutHoudini, __init__).__init__(self)
    # end __init__
    def open():
        """
        Custom Maya-based open command
        """
        pass
    # end open
    def save():
        """
        Custom Maya-based save command
        """
        pass
    # end save
# end FileCheckoutHoudini

class FileCheckout(FileIO):
    def __init__(self, fileName, filePath):
        super(FileCheckout, __init__).__init__(self)
        self.extension = self.check_filename[5]
        self.shot = self.check_filename[0]
        self.user = self.check_filename[1]
        self.version = self.check_filename[2]
        self.description = self.check_filename[3]
        self.increment = self.check_filename[4]
    # end __init__
    def check_naming_convention(self, regex):
        """
        Checks the given filename for a proper naming convention

        :key fileName: The name of the file, excluding its absolute file-path
        :key regex: The pre-compiled Reg-Ex pattern that match against fileName
        :type fileName: str
        :type regex: <type '_sre.SRE_Pattern'>
        :returns: A Tuple including the shot, user, version, description,
                  increment, and file-type of the given fileName input
        :rtype: tuple

        ..AUTHOR NOTE::
         Not done
        """
        match = re.match(self.fileName, regex)
        return match.groups()
    # end check_naming_convention
    def is_locked(self, filePath):
        """
        Looks to see if the file being queried is currently being accessed
        over the network

        :key filePath: The full, absolute path to the file being checked
        :type filePath: str
        :returns: True/False or None
        :rtype: bool or NoneType
        """
        if not os.path.isFile(filePath):
            message = '"{f}", does not exist. Please check the '\
                      'name'.format(f=filePath)
            print(message)
            return None

        if os.path.isFile(filePath + consts.LOCKED_NOTIFIER):
            return True

        return False
    # end is_locked
    def request_access(self):
        """
        Looks at file's name to get the username of the person.
        Sends that person an e-mail, requesting access to the file

        ..TODO::
         Possibly integrate this with slack - so that people can get a message
         instead of an e-mail
        """
        pass
    # end request_access
    def set_contact_info():
        """
        Sets the contact information on the locked file being queried

        :returns: Whether or not the set was successful, True/False
        :rtype: bool
        """
        pass
    def get_contact_info():
        """
        Gets the contact information on the locked file being queried

        :returns: Contact info about the user who currently locked the file
        :rtype: dict
        """
        pass
    # end get_contact_info
    def set_locked(self):
        """
        Locks the current file with a consts.LOCKED_NOTIFIER with
        information about the current user inside of the locked file
        """
    # end set_locked
    def save():
        """
        The contents of a generic file save command
        """
        pass
    # end save
    def save_file(self):
        """
        Attempts to save a generic file but checks if the file is locked first
        """
        if not self.is_locked():
            self.save()
            return True
        elif self.is_locked() and self.get_contact_info()['USER'] == \
                                                            consts.USER:
            self.save()
            return True

        return False
    # end save_file
    def open(self):
        """
        The contents of a generic file open command
        """
        pass
    # end open
    def open_file(self):
        """
        Attempts to open a generic file but checks if the file is locked first
        """
        if not self.is_locked():
            self.open()
            return True
        elif self.is_locked() and self.get_contact_info()['USER'] == \
                                                            consts.USER:
            self.open()
            return True

        return False
    # end open_file
# end FileCheckout

class FileIO(object):
    def __init__(self, fileName, filePath):
        super(FileIO, __init__).__init__(self)
        self.fileName = fileName
        self.filePath = filePath
        self.fullPath = fileName + os.sep + filePath
        self.extension = os.path.splitext(fileName)
    # end __init__
    def save_file(self):
        pass
    # end save_file
    def open_file(self):
        pass
    # end open_file
    def is_empty(self):
        path = self.filePath + os.sep + self.fileName
        try:
            if os.stat(path).st_size > 0:
               print "All good"
            else:
               print "empty file"
        except OSError:
            print "No file"
    # end is_empty
    def __repr__(self):
        """
        An unambiguous print of class FileIO, used for logging/debugging
        """
        return "FileIO(this=%r,that=%r)" % (self.fileName,self.filePath)
    # end __repr__
    def __str__(self):
        """
        Prints out a string method for
        """
        return fileName + os.sep + filePath
    # end __str__
    def is_character_limit(self):
        if platform.system == "Windows":
            maxLength = 260
        elif platform.system == "Unix" or "Mac":
            maxLength = 255
        else:
            print "unknown system platform, {os}".format(os=platform.system)
        if len(self.fullPath) > maxLength:
            return True

        return False
    # end is_character_limit
# end FileIO

def open_file_maya(fileName, filePath):
    """
    --- Get file name - check for file
    --- Check for lock
     --- if locked and the person who locked it is them, let them in and return
     -/ if locked, give them a message screen, showing person's contact info
     -/ ask if they want to request access from them - if yes, email/slack
    -/ if not locked, open maya and create a locked version of the file
     -/ add the person's contact info in the locked file

    :returns: The status of the opened file - True, False, or None
    :rtype: bool or NoneType
    """
    file = FileCheckoutMaya(fileName, filePath)

    if not os.isfile(file.fullPath):
        print "Is not a file"
        return None

    if file.is_locked():
        if file.get_contact_info()['USER'] == consts.USER:
            break

        lockedFileData = file.get_contact_info()
        # TODO: open Qt object to display message - add lockedFileData contents
    else:
        # TODO:
        # open Maya file
        try:
            pass
        except someMayaSpecificError:
            pass
        file.open_file()
        file.set_contact_info()
# end open_file_maya

def open_maya_file():
    """
    The standard method of opening a file in Maya
    """
def main():
    exampleFileName1 = "s001_ckenne24_007_uving.0001.ma"
    match = re.match(FILENAME_CONV, exampleFileName1)
    if match is None:
        print("Something went wrong")
    else:
        print match.groups()
# end main

if __name__ == "__main__":
    main()
