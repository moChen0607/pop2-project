"""
Utility to read and analyze dependency graph dirty state information.
Allows you to produce a comparision of two sets of state information.

	from dirtyState import *

	# Get the current scene's dirty data state information
	stateBefore = dirtyState( checkData=True )

	# Perform some operation that may change the dirty state
	doMyOperation()

	# Get the new dirty data state information
	stateAfter = dirtyState( checkData=True )

	# Compare them to see if they are the same
	stateBefore.compare(stateAfter)
"""

__all__ = ['dirtyState']

import re
import sys

#======================================================================
#
# State analysis of offline files will work without Maya running so use
# the maya import to dynamically detect what can and can't be done here.
#
try:
	import maya.cmds as cmds
	_mayaIsAvailable = True
except:
	_mayaIsAvailable = False
def checkMaya():
	if _mayaIsAvailable:
		return True
	print 'ERROR: Cannot perform this operation unless Maya is available'
	return False

#######################################################################

class dirtyState:
	"""
	Provides access and manipulation of dirty state data that has been
	produced by various invocations of the 'dgdirty' command.
	"""

	# Keywords used for commands and output formatting
	plugType = 'plug'
	dataType = 'data'
	connectionType = 'connection'
	cleanType = 'clean'
	dirtyType = 'dirty'

	#======================================================================
	def __init__(self, stateFileName=None, longNames=False, checkPlugs=True, checkData=True, checkConnections=True):
		"""
		Create a dirty state object from a file or the current scene.

		The dirty data is read in and stored internally in a format that makes
		formatting and comparison easy.

			stateFileName	: If None then the current scene will be used,
							  otherwise the file will be read.
			longNames		: If True then don't attempt to shorten the node
							  names by removing namespaces and DAG path elements.
			checkPlugs		: If True then check for plugs that are dirty
			checkData		: If True then check for plug data that is dirty
			checkConnections: If True then check for connections that are dirty
		"""
		self.useLongNames = longNames
		self.checkPlugs = checkPlugs
		self.checkData = checkData
		self.checkConnections = checkConnections

		if stateFileName == None:
			self._initFromScene()
		else:
			self._initFromFile(stateFileName)

	def _initFromScene(self):
		"""
		Create a dirty state object from the current Maya scene.
		"""
		if not checkMaya():
			return
		self._name = '__SCENE__'
		self._plugs = []
		self._data = []
		self._connections = []

		if self.checkPlugs:
			plugList = cmds.dgdirty( list=dirtyState.plugType )
			if plugList:
				self._plugs = plugList

		if self.checkData:
			dataList = cmds.dgdirty( list='data' )
			if dataList:
				self._data = dataList

		if self.checkConnections:
			connectionList = cmds.dgdirty( list='connection' )
			if connectionList:
				for c in range(0,len(connectionList),2):
					self._connections.append( (connectionList[c], connectionList[c+1]) )

	#======================================================================
	def _initFromFile(self, stateFileName):
		"""
		Create a dirty state object from contents of the given file.
		Data in the file will be lines showing what is dirty:

			connection<tab>X<tab>Y	: The connection from X to Y is dirty
			plug<tab>X				: Networked plug X is dirty
			data<tab>X				: Plug X has dirty data in the datablock
		"""
		self._name = stateFileName
		self._plugs = []
		self._data = []
		self._connections = []

		# Precompile the line expressions for faster matching
		reConnection = re.compile('\s*connection\s*([^\t]+)\t([^\s]+)\s*$')
		rePlug = re.compile('\s*plug\s*([^\s]+)\s*$')
		reData = re.compile('\s*data\s*([^\s]+)\s*$')

		stateFile = open(stateFileName, 'r')
		for line in stateFile:
			match = reConnection.match( line )
			if match:
				self._connections.append( (match.group(1), match.group(2)) )
				continue

			match = rePlug.match( line )
			if match:
				self._plugs.append( match.group(1) )
				continue

			match = reData.match( line )
			if match:
				self._data.append( match.group(1) )
				continue

			if len(line.rstrip().lstrip()) > 0: # Allow blank lines
					print 'WARN: Line not recognized: %s' % line,

	#======================================================================
	def name(self):
		"""
		Return an identifying name for this collection of dirty states
		"""
		return self._name

	#======================================================================
	def write(self, fileName=None):
		"""
		Dump the states in the .dirty format it uses for reading. Useful for
		creating a dump file from the current scene, or just viewing the
		dirty state generated from the current scene. If the fileName is
		specified then the output is sent to that file, otherwise it goes
		to stdout.
		"""
		out = sys.stdout
		if fileName:
			out = open(fileName, 'w')

		for data in self._data:
			out.write( '%s\t%s\n' % (dirtyState.dataType, data) )

		for plug in self._plugs:
			out.write( '%s\t%s\n' % (dirtyState.plugType, plug) )

		for (src,dst) in self._connections:
			out.write( '%s\t%s\t%s\n' % (dirtyState.connectionType, src, dst) )

	#======================================================================
	def _getPlugDifferences(self, other, madeDirty):
		"""
		Compare this dirty state against another one and generate a
		summary of plugs whose dirty state changed:

			madeDirty	: If true return plugs dirty in other but not in self
						  If false return plugs dirty in self but not in other
		"""
		differences = []

		if madeDirty:
			for plug in other._plugs:
				if plug in self._plugs:
					continue
				differences.append( plug )
		else:
			for plug in self._plugs:
				if plug in other._plugs:
					continue
				differences.append( plug )

		return differences

	#======================================================================
	def _getDataDifferences(self, other, madeDirty):
		"""
		Compare this dirty state against another one and generate a
		summary of data whose dirty state changed:

			madeDirty	: If true return data dirty in other but not in self
						  If false return data dirty in self but not in other
		"""
		differences = []

		if madeDirty:
			for data in other._data:
				if data in self._data:
					continue
				differences.append( data )
		else:
			for data in self._data:
				if data in other._data:
					continue
				differences.append( data )

		return differences

	#======================================================================
	def _getConnectionDifferences(self, other, madeDirty):
		"""
		Compare this dirty state against another one and generate a
		summary of connections whose dirty state changed:

			madeDirty	: If true return connections dirty in other but not in self
						  If false return connections dirty in self but not in other
		"""
		differences = []

		if madeDirty:
			for connection in other._connections:
				if connection in self._connections:
					continue
				differences.append( connection )
		else:
			for connection in self._connections:
				if connection in other._connections:
					continue
				differences.append( connection )

		return differences

	#======================================================================
	def compare(self, other):
		"""
		Compare this dirty state against another one and generate a
		summary of how the two sets differ. Differences will be returned
		as a string list consisting of difference descriptions. That way
		when testing, an empty return means the graphs are the same.

		The difference type formats are:
		
			plug dirty N			Plug was dirty in other but not in self
			plug clean N			Plug was dirty in self but not in other
			data dirty N			Data was dirty in other but not in self
			data clean N			Data was dirty in self but not in other
			connection dirty S D	Connection was dirty in other but not in self
			connection clean S D	Connection was dirty in self but not in other
		"""
		differences = []

		differences += ['%s %s %s' % (dirtyState.plugType, dirtyState.dirtyType, plug) for plug in self._getPlugDifferences(other, True)]
		differences += ['%s %s %s' % (dirtyState.plugType, dirtyState.cleanType, plug) for plug in self._getPlugDifferences(other, False)]

		differences += ['%s %s %s' % (dirtyState.dataType, dirtyState.dirtyType, data) for data in self._getDataDifferences(other, True)]
		differences += ['%s %s %s' % (dirtyState.dataType, dirtyState.cleanType, data) for data in self._getDataDifferences(other, False)]

		differences += ['%s %s %s %s' % (dirtyState.connectionType, dirtyState.dirtyType, connection[0], connection[1]) for connection in self._getConnectionDifferences(other, True)]
		differences += ['%s %s %s %s' % (dirtyState.connectionType, dirtyState.cleanType, connection[0], connection[1]) for connection in self._getConnectionDifferences(other, False)]

		return differences

	#======================================================================
	def compareOneType(self, other, requestType, madeDirty):
		"""
		Compare this dirty state against another one and return the values
		that differ in the way proscribed by the parameters:

			requestType	: Type of dirty state to check [plug/data/connection]
			madeDirty	: If true return things that became dirty, otherwise
						  return things that became clean

		Nothing is returned for items that did not change.
		"""
		differences = []

		if requestType == dirtyState.plugType:
			differences = self._getPlugDifferences( other, madeDirty )

		#----------------------------------------

		elif requestType == dirtyState.dataType:
			differences = self._getDataDifferences( other, madeDirty )

		#----------------------------------------

		elif requestType == dirtyState.connectionType:
			differences = self._getConnectionDifferences( other, madeDirty )

		return differences

# Copyright (C) 1997-2014 Autodesk, Inc., and/or its licensors.
# All rights reserved.
#
# The coded instructions, statements, computer programs, and/or related
# material (collectively the "Data") in these files contain unpublished
# information proprietary to Autodesk, Inc. ("Autodesk") and/or its licensors,
# which is protected by U.S. and Canadian federal copyright law and by
# international treaties.
#
# The Data is provided for use exclusively by You. You have the right to use,
# modify, and incorporate this Data into other products for purposes authorized 
# by the Autodesk software license agreement, without fee.
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND. AUTODESK
# DOES NOT MAKE AND HEREBY DISCLAIMS ANY EXPRESS OR IMPLIED WARRANTIES
# INCLUDING, BUT NOT LIMITED TO, THE WARRANTIES OF NON-INFRINGEMENT,
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE, OR ARISING FROM A COURSE 
# OF DEALING, USAGE, OR TRADE PRACTICE. IN NO EVENT WILL AUTODESK AND/OR ITS
# LICENSORS BE LIABLE FOR ANY LOST REVENUES, DATA, OR PROFITS, OR SPECIAL,
# DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES, EVEN IF AUTODESK AND/OR ITS
# LICENSORS HAS BEEN ADVISED OF THE POSSIBILITY OR PROBABILITY OF SUCH DAMAGES.

