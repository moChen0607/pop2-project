"""
Helper class that maintains the EM mode information. Given a string
to specifies an EM mode combination (type +/- evaluators) it will
handle the details regarding translating the mode description into
actions and turning the mode on and off.

String syntax is an abbreviated evaluation mode followed by zero or
more evaluator directives. Regex is MODE{[+-]EVALUTOR}*. Examples:
	dg			 : Turn the EM off and go back to DG mode
	ems			 : Turn the EM on and put it into serial mode
	emp			 : Turn the EM on and put it into parallel mode
	emp+null	 : Turn the EM on and enable the 'null' evaluator
	emp-dynamics : Turn the EM on and disable the 'dynamics' evaluator
	emp-dynamics+deformer
				 : Turn the EM on, disable the 'dynamics' evaluator, and
				   enable the 'deformer' evaluator

Calling the setMode() method will put the EM into the named mode.
Calling it again will exit that mode and put it into the new mode,
including unloading any plugins that had to be loaded. Destruction
or reassignment of the manager will restore the EM to the state it
had just before the first time the mode was set.

The plugin loading is not magic, it's a hardcoded list in this file.
Update it if you want to handle any new plugins.

The object is set up to use the Python "with" syntax as follows:

	with emModeManager() as mgr:
		mgr.setMode( someMode )

That will ensure the original states are all restored. There's no other
reliable way to do it in Python. If you need different syntax you can
manually call the method to complete the sequence:

	mgr = emModeManager()
	mgr.setMode( someMode )
	mgr.restore()
"""
import re, os
import maya.cmds as cmds

__all__ = ['emModeManager']

# Set this to true if you wish to see detailed information on exactly what the
# manager is enabling and disabling.
inDebugMode = False

#======================================================================
def _dbg(message):
	if inDebugMode:
		print message

#======================================================================

def _hasEvaluationManager():
	'''Check to see if the evaluation manager is available'''
	return 'evaluationManager' in dir(cmds)

#======================================================================
reMode = re.compile( '^\s*([^+-]+)(.*)$' )
reEvaluators = re.compile( '([+-][^-+]+)' )
# Some evaluators require plugins, catch the ones we know of
evaluatorPlugins = { 'deformer'	: 'deformerEvaluator',
					'cache'		: 'cacheEvaluator',
					'null'		: 'nullEvaluator' }
class emModeManager(object):
	#----------------------------------------------------------------------
	def __enter__(self):
		_dbg( '*** emModeManager::__enter__' )
		return self
	#----------------------------------------------------------------------
	def __init__(self):
		'''Defining both __enter__ and __init__ so that either one can be used'''
		_dbg( '*** emModeManager::__init__' )
		self.evaluatorsTurnedOn = []
		self.evaluatorsTurnedOff = []
		self.evaluatorsToTurnOn = []
		self.evaluatorsToTurnOff = []
		self.pluginsToUnload = []
		self.restoreMode = None
		self.emMode = None
		self.enabled = False

	#----------------------------------------------------------------------
	def __exit__(self,type,value,traceback):
		'''Ensure the state is restored if this object goes out of scope'''
		_dbg( '*** emModeManager::__exit__' )
		_dbg( '    Type = %s' % str(type) )
		_dbg( '    Value = %s' % str(value) )
		_dbg( '    Traceback = %s' % str(traceback) )
		self.restore()

	#----------------------------------------------------------------------
	def setMode(self, modeName):
		'''
		Put the EM into a named mode. See class docs for details on mode names.

		raises SyntaxError if the mode name is not legal
		'''
		# Make sure the state is restored before changing it again
		_dbg( '*** Setting mode to %s' % modeName )
		if self.enabled:
			_dbg( '--- Disabling previous modes' )
			self.restore()
			_dbg( '--- Done Disabling previous modes' )

		self.evaluatorsTurnedOn = []
		self.evaluatorsTurnedOff = []
		self.evaluatorsToTurnOn = []
		self.evaluatorsToTurnOff = []
		self.pluginsToUnload = []
		self.restoreMode = None
		self.emMode = None

		match = reMode.match( modeName )
		if match:
			if match.group(1) == 'ems':
				self.emMode = 'serial'
			elif match.group(1) == 'emp':
				self.emMode = 'parallel'
			elif match.group(1) == 'dg':
				self.emMode = 'off'
			else:
				raise ( SyntaxError( '%s is not a recognized EM mode' % match.group(1) ) )

			evalMatches = reEvaluators.findall( match.group(2) )
			for evalMatch in evalMatches:
				_dbg( '    +++ Processing action %s' % evalMatch )
				action = evalMatch[0]
				evaluator = evalMatch[1:]
				# Don't allow both '+' and '-', or even two the same
				if evaluator in self.evaluatorsToTurnOn or evaluator in self.evaluatorsToTurnOff:
					raise( SyntaxError('Evaluator %s was specified twice' % evaluator) )
				if action == '+':
					_dbg( '       Will turn on %s' % evaluator )
					self.evaluatorsToTurnOn.append( evaluator )
				elif action == '-':
					_dbg( '       Will turn off %s' % evaluator )
					self.evaluatorsToTurnOff.append( evaluator )
				else:
					raise( SyntaxError('%s is not a recognized EM evaluator command (+XX or -XX)' % evalMatch) )
		else:
			raise( SyntaxError('%s is not a recognized EM command "ems|emp|dg{[+-]XX}*"' % modeName) )

		# Now that the state is prepared switch to the new mode
		self._enable()
	
	#----------------------------------------------------------------------
	def _enable(self):
		'''
		Put the evaluation manager into this mode
		'''
		_dbg( '*** emModeManager::_enable' )
		# Prevent multiple calls
		if self.enabled:
			_dbg( '    Oops, tried to enable without a disable' )
			return

		self.evaluatorsTurnedOn = []
		self.evaluatorsTurnedOff = []
		self.pluginsToUnload = []
		self.restoreMode = None

		# Doing this the hard way thanks to MAYA-44444
		alreadyEnabled = []
		alreadyDisabled = []
		for evaluator in cmds.evaluator( query=True ):
			if cmds.evaluator( query=True, name=evaluator ):
				alreadyEnabled.append( evaluator )
			else:
				alreadyDisabled.append( evaluator )
		_dbg( '   already enabled = %s' % str(alreadyEnabled) )
		_dbg( '   already disabled = %s' % str(alreadyDisabled) )

		# Modify the mode if necessary, remember where it came from.
		self.restoreMode = None
		originalMode = cmds.evaluationManager( mode=True, query=True )[0]
		if originalMode != self.emMode:
			cmds.evaluationManager( mode=self.emMode )
			self.restoreMode = originalMode

		# Check to see which evaluators had to be turned on and remember them.
		for turnOn in self.evaluatorsToTurnOn:
			# If it was already on don't do anything.
			if turnOn in alreadyEnabled:
				_dbg( '      No need to enable %s, it is already enabled' % turnOn )
				continue
			if turnOn in evaluatorPlugins:
				_dbg( '    Loading plugin %s' % evaluatorPlugins[turnOn] )
				loaded = cmds.loadPlugin( evaluatorPlugins[turnOn] )
				# We like to avoid perturbing state so if we loaded the
				# plug-in we'll unload it when done
				if loaded != None:
					self.pluginsToUnload += loaded
			self.evaluatorsTurnedOn.append( turnOn )
			cmds.evaluator( enable=True, name=turnOn )
			_dbg( '     Enable %s' % turnOn )

		# Check to see which evaluators had to be turned off and remember them.
		for turnOff in self.evaluatorsToTurnOff:
			# If it was already off don't do anything. Checking the enabled
			# list accounts for the possibility of a plugin not being loaded.
			if turnOff not in alreadyEnabled:
				_dbg( '      No need to disable %s, it is not enabled' % turnOff )
				continue
			self.evaluatorsTurnedOff.append( turnOff )
			cmds.evaluator( enable=False, name=turnOff )
			_dbg( '     Disable %s' % turnOff )

		self.enabled = True

	#----------------------------------------------------------------------
	def restore(self):
		'''
		Restore the evaluation manager to its original mode prior to enabling
		this one.  Not necessary to call this when using the "with emModeManager()"
		syntax. Only needed when you explicitly instantiate the mode manager.
		Then you have to call this if you want your original state restored.
		'''
		_dbg( '*** emModeManager::restore' )
		# Prevent multiple calls
		if not self.enabled:
			_dbg( '    Oops, nothing to restore' )
			return

		# Evaluation mode
		if self.restoreMode:
			_dbg( '     Restore mode to %s' % self.restoreMode )
			cmds.evaluationManager( mode=self.restoreMode )

		# Evaluators turned on
		for evaluator in self.evaluatorsTurnedOn:
			_dbg( '     Re-disable %s' % evaluator )
			cmds.evaluator( enable=False, name=evaluator )

		# Evaluators turned off
		for evaluator in self.evaluatorsTurnedOff:
			_dbg( '     Restore %s' % evaluator )
			cmds.evaluator( enable=True, name=evaluator )

		# Plugins we loaded
		for plugin in self.pluginsToUnload:
			try:
				_dbg( '     Unload %s' % plugin )
				cmds.unloadPlugin( plugin )
			except:
				# Just in case someone else already unloaded it
				pass

		self.enabled = False

# Copyright (C) 1997-2014 Autodesk, Inc., and/or its licensors.
# All rights reserved.
#
# The coded instructions, statements, computer programs, and/or related
# material (collectively the "Data") in these files contain unpublished
# information proprietary to Autodesk, Inc. ("Autodesk") and/or its licensors,
# which is protected by U.S. and Canadian federal copyright law and by
# international treaties.
#
# The Data is provided for use exclusively by You. You have the right to use,
# modify, and incorporate this Data into other products for purposes authorized 
# by the Autodesk software license agreement, without fee.
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND. AUTODESK
# DOES NOT MAKE AND HEREBY DISCLAIMS ANY EXPRESS OR IMPLIED WARRANTIES
# INCLUDING, BUT NOT LIMITED TO, THE WARRANTIES OF NON-INFRINGEMENT,
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE, OR ARISING FROM A COURSE 
# OF DEALING, USAGE, OR TRADE PRACTICE. IN NO EVENT WILL AUTODESK AND/OR ITS
# LICENSORS BE LIABLE FOR ANY LOST REVENUES, DATA, OR PROFITS, OR SPECIAL,
# DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES, EVEN IF AUTODESK AND/OR ITS
# LICENSORS HAS BEEN ADVISED OF THE POSSIBILITY OR PROBABILITY OF SUCH DAMAGES.

