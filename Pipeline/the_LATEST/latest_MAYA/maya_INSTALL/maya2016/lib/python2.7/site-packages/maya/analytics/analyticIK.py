import maya.cmds
from .BaseAnalytic import BaseAnalytic
from .decorators import addMethodDocs,addHelp,makeAnalytic

@addMethodDocs
@addHelp
@makeAnalytic
class analyticIK(BaseAnalytic):
	"""
	Analyze structure and usage of standard IK system.
	"""

	def _followChainUp( self, joint ):
		"""
		Follow the IK chain recursively up the parent hierarchy. The recursion
		ends when either the root is hit or a node belonging to 'startJoints'
		is hit.

		Presumes that self.startJoints, self.handleName, and self.jointCount
		are set before being called. These were made into transient class
		members to avoid the messiness of passing a lot of parameters in.

		joint	: Joint being visited
		returns number of joints found in the chain above 'joint', including it
		"""
		chainCount = 0
		if joint not in self.startJoints:
			chainCount += 1
			try:
				# This gives a count of nodes in the chain which includes all
				# potential instance branches. That's okay, though it doesn't
				# give the "longest chain" if that is important.
				for link in maya.cmds.listRelatives( joint, allParents=True ):
					self.jointsReported[link] = True
					if self.showDetails and link not in self.startJoints:
						self._outputCSV( [ self.handleName, 'Chain Link', self._sanitizedNodeName( link, self.showDetails, self.jointCount ) ] )
					chainCount += self._followChainUp( link )
			except TypeError, ex:
				# No relatives existed, end of the line
				pass
		return chainCount

	def run(self, showDetails=False):
		"""
		Scan all of the standard IK connections to pull out usage statistics.
		"standard" means "not HIK". See analyticHIK() for specific details on
		that IK subsystem.

		The CSV output provides columns for the name of the statistic
		collected and the count of occurences of that statistic with the
		headings 'Handle', 'Parameter', 'Value'. When 'showDetails' is off any
		node names in the output are replaced by their generic form
		'NODETYPEXXX' where 'NODETYPE' is the type of node and 'XXX' is a
		unique ID per node type. The following are collected:
			- IK Handle Name, 'Solver', Name of the solver the handle uses
			- IK Handle Name, 'Chain Start', Starting node of chain
			- IK Handle Name, 'Chain End', Ending node of chain
			- IK Handle Name, 'Chain Length', Number of nodes in the chain
			- IK Handle Name, 'End Effector', Name of chain's end effector
			- "", 'Solver', Name/Type of solver with no associated handles
			- "", 'Chain Link', Number of Joint nodes with no associated Handle
				(Not reported if 'showDetails' is True.)

		if 'showDetails' is turned extra lines of this form are also output:
			- IK Handle Name, 'Chain Link', Node in the middle of a chain
			- "", 'Chain Link', Joint node with no associated Handle
		"""
		try:
			if not self._open():
				return

			self.showDetails = showDetails

			# First find all of the IK types present
			allSolvers = maya.cmds.ls( type='ikSolver' )
			try: solverCount = len(allSolvers)
			except: solverCount = 0
			allHandles = maya.cmds.ls( type='ikHandle' )
			try: handleCount = len(allHandles)
			except: handleCount = 0
			allEffectors = maya.cmds.ls( type='ikEffector' )
			try: effectorCount = len(allEffectors)
			except: effectorCount = 0
			allJoints = maya.cmds.ls( type='joint' )
			try: self.jointCount = len( allJoints )
			except: self.jointCount = 0
			self.jointsReported = {}

			self._outputCSV( [	'Handle'
							 ,	'Parameter'
							 ,	'Value'
							 ] )

			if solverCount + handleCount + effectorCount + self.jointCount == 0:
				print 'Warning: No IK to report'
				return

			# Loop through the handles, dumping all relevant information
			solversUsed = {}
			for handle in allHandles:
				self.handleName = self._sanitizedNodeName( handle, self.showDetails, handleCount )

				#----------------------------------------
				# IK Solver
				solvers = maya.cmds.listConnections( '%s.ikSolver' % handle )
				for solver in solvers:
					self._outputCSV( [ self.handleName, 'Solver', self._sanitizedNodeName( solver, self.showDetails, solverCount ) ] )
					solversUsed[solver] = True

				#----------------------------------------
				# Start joints
				self.startJoints = maya.cmds.listConnections( '%s.startJoint' % handle )
				for startJoint in self.startJoints:
					self.jointsReported[startJoint] = True
					self._outputCSV( [ self.handleName, 'Chain Start', self._sanitizedNodeName( startJoint, self.showDetails, self.jointCount ) ] )

				#----------------------------------------
				# End Effector
				endEffectors = maya.cmds.listConnections( '%s.endEffector' % handle )
				for endEffector in endEffectors:
					self._outputCSV( [ self.handleName, 'End Effector', self._sanitizedNodeName( endEffector, self.showDetails, effectorCount ) ] )

				#----------------------------------------
				# Ending joints
				#
				# End effectors have a bunch of different connections. Make
				# sure only unique joints are collected by using the list(set())
				# trick to uniquify the returned values and the list comprehension
				# to restrict it to joints.
				try:
					self.endJoints = list(set([j for j in maya.cmds.listConnections( endEffectors[0] ) if maya.cmds.nodeType(j) == 'joint']))
					for endJoint in self.endJoints:
						if maya.cmds.nodeType( endJoint ) != 'joint':
							continue
						self.jointsReported[endJoint] = True
						self._outputCSV( [ self.handleName, 'Chain End', self._sanitizedNodeName( endJoint, self.showDetails, self.jointCount ) ] )
				except:
					self.endJoints = []

				#----------------------------------------
				# Chain lengths
				for endJoint in self.endJoints:
					chainCount = self._followChainUp( endJoint )
					# Leaving in the degenerate chains (chainCount = 0) since
					# they may be of interest.
					self._outputCSV( [ self.handleName, 'Chain Length', str(chainCount) ] )

			#----------------------------------------
			# Unused solvers
			for solver in allSolvers:
				if solver in solversUsed:
					continue
				self._outputCSV( [ '', 'Solver', self._sanitizedNodeName( solver, self.showDetails, solverCount ) ] )

			#----------------------------------------
			# Joints without handle controls
			try:
				unreportedJoints = [j for j in allJoints if not j in self.jointsReported]
			except:
				unreportedJoints = []
			if self.showDetails:
				for joint in unreportedJoints:
					self._outputCSV( [ '', 'Chain Link', self._sanitizedNodeName( joint, self.showDetails, self.jointCount ) ] )
			else:
				self._outputCSV( [ '', 'Chain Link', len(unreportedJoints) ] )

		except Exception, ex:
			print 'Analytic failed: "%s"' % str(ex)
		finally:
			self._close()

# Copyright (C) 1997-2014 Autodesk, Inc., and/or its licensors.
# All rights reserved.
#
# The coded instructions, statements, computer programs, and/or related
# material (collectively the "Data") in these files contain unpublished
# information proprietary to Autodesk, Inc. ("Autodesk") and/or its licensors,
# which is protected by U.S. and Canadian federal copyright law and by
# international treaties.
#
# The Data is provided for use exclusively by You. You have the right to use,
# modify, and incorporate this Data into other products for purposes authorized 
# by the Autodesk software license agreement, without fee.
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND. AUTODESK
# DOES NOT MAKE AND HEREBY DISCLAIMS ANY EXPRESS OR IMPLIED WARRANTIES
# INCLUDING, BUT NOT LIMITED TO, THE WARRANTIES OF NON-INFRINGEMENT,
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE, OR ARISING FROM A COURSE 
# OF DEALING, USAGE, OR TRADE PRACTICE. IN NO EVENT WILL AUTODESK AND/OR ITS
# LICENSORS BE LIABLE FOR ANY LOST REVENUES, DATA, OR PROFITS, OR SPECIAL,
# DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES, EVEN IF AUTODESK AND/OR ITS
# LICENSORS HAS BEEN ADVISED OF THE POSSIBILITY OR PROBABILITY OF SUCH DAMAGES.

