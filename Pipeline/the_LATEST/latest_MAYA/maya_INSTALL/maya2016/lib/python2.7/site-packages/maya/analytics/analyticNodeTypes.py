import operator
import maya.cmds
from .BaseAnalytic import BaseAnalytic
from .decorators import addMethodDocs,addHelp,makeAnalytic

@addMethodDocs
@addHelp
@makeAnalytic
class analyticNodeTypes(BaseAnalytic):
	"""
	This class provides scene stats collection on node types.
	"""
	def __getInheritanceList(self, leaf):
		"""
		Returns the list of all node types inherited from "leaf", not
		including the root "TdependNode". Uses the member variable
		inheritance{} to allow recursive construction of the list while
		avoiding O(N^2) duplication of work.
		"""
		if leaf == 'TdependNode':
			return []

		# Unfortunately the inherited=True flag only provides the
		# immediate parent so we have to do some work to get the
		# entire hierarchy.
		parent = maya.cmds.nodeType( leaf, inherited=True, isTypeName=True )
		if parent == None:
			return []
		parent.reverse()
		return parent

	def __calculateNodeTypeHierarchy(self):
		"""
		It's hard to do basic aggregation on node type information unless you
		also know the node hierarchy, which isn't apparent from the names.
		This method dumps out a CSV file consisting of "NodeType","Depth","Path"
		where "NodeType" is the simple node type name, e.g. "transform",
		"Depth" is how deep in the hierarchy the type appears, and "Path" is a
		vertical-bar separated list of every node type in its hierarchy,
		starting from its parent and ending at the root (TdependNode).
		"""
		try:
			#----------------------------------------------------------------------
			#
			# First step is to construct the hiearchy information based on the
			# limited amount of data available from the 'nodeType' command
			#
			self.nodeTypeDepth = {}
			self.nodeTypeHierarchy = {}
			# The derived=True flag dumps every node in the inheritance tree
			# so this is a good starting point to get all types.
			allNodeTypes = maya.cmds.nodeType( 'TdependNode', derived=True, isTypeName=True )
			for nodeType in allNodeTypes:
				inheritanceList = self.__getInheritanceList( nodeType )

				# Reformat the inheritance information into CSV column data
				#
				self.nodeTypeDepth[nodeType] = len(inheritanceList)+1
				# Since everything is rooted at TdependNode, and it doesn't
				# show up in the inheritance output, add it manually. It's a
				# bit redundant but harmless.
				self.nodeTypeHierarchy[nodeType] = '|'.join( inheritanceList + ['TdependNode'] )
		except Exception,ex:
			print 'Node type hierarchy calculation failed: %s' % str(ex)

	def run(self, showDetails=False):
		"""
		Generates the number of nodes of each type in a scene in the
		CSV form "NodeType","Count", ordered from most frequent to least
		frequent.

		If 'showDetails' is set to True then insert two extra columns,
		"Depth" containing the number of parents the given node type has,
		and "Hierarchy" containing a "|"-separated string with all of the
		node types above that one in the hierarchy, starting with it and
		working upwards. It will also include lines for all of the node
		types that have no corresponding nodes in the scene, signified by
		a "Count" of 0.
		"""
		try:
			if not self._open():
				return

			nodeTypeCounts = {}
			# Generates alternating name,type pairs in a flat list.
			# Ignore the undeletable nodes since they are the same in
			# every scene.
			lsList = maya.cmds.ls( showType=True, undeletable=False )
			name = None
			for value in lsList:
				if name == None:
					name = value
				else:
					if value in nodeTypeCounts:
						nodeTypeCounts[value] += 1
					else:
						nodeTypeCounts[value] = 1
					name = None
	
			if showDetails:
				self._outputCSV( ['Node Type', 'Depth', 'Hierarchy', 'Count'] )
				self.__calculateNodeTypeHierarchy()
			else:
				self._outputCSV( ['Node Type', 'Count'] )
			for (type,count) in sorted(nodeTypeCounts.iteritems(), key=operator.itemgetter(1), reverse=True):
				if showDetails:
					try:
						self._outputCSV( [type, self.nodeTypeDepth[type], self.nodeTypeHierarchy[type], count] )
					except Exception, ex:
						# The node type hierarchy information was not
						# available so output with blanks for it.
						self._outputCSV( [type, 0, '', count] )
				else:
					self._outputCSV( [type, count] )

			if showDetails:
				for (type,hierarchy) in sorted(self.nodeTypeHierarchy.iteritems(), key=operator.itemgetter(0)):
					self._outputCSV( [type, self.nodeTypeDepth[type], hierarchy, 0] )

		except Exception, ex:
			print 'Analytic failed: "%s"' % str(ex)
		finally:
			self._close()

# Copyright (C) 1997-2014 Autodesk, Inc., and/or its licensors.
# All rights reserved.
#
# The coded instructions, statements, computer programs, and/or related
# material (collectively the "Data") in these files contain unpublished
# information proprietary to Autodesk, Inc. ("Autodesk") and/or its licensors,
# which is protected by U.S. and Canadian federal copyright law and by
# international treaties.
#
# The Data is provided for use exclusively by You. You have the right to use,
# modify, and incorporate this Data into other products for purposes authorized 
# by the Autodesk software license agreement, without fee.
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND. AUTODESK
# DOES NOT MAKE AND HEREBY DISCLAIMS ANY EXPRESS OR IMPLIED WARRANTIES
# INCLUDING, BUT NOT LIMITED TO, THE WARRANTIES OF NON-INFRINGEMENT,
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE, OR ARISING FROM A COURSE 
# OF DEALING, USAGE, OR TRADE PRACTICE. IN NO EVENT WILL AUTODESK AND/OR ITS
# LICENSORS BE LIABLE FOR ANY LOST REVENUES, DATA, OR PROFITS, OR SPECIAL,
# DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES, EVEN IF AUTODESK AND/OR ITS
# LICENSORS HAS BEEN ADVISED OF THE POSSIBILITY OR PROBABILITY OF SUCH DAMAGES.

