from operator import itemgetter
import maya.cmds
from .BaseAnalytic import BaseAnalytic
from .decorators import addMethodDocs,addHelp,makeAnalytic

@addMethodDocs
@addHelp
@makeAnalytic
class analyticAnimation(BaseAnalytic):
	"""
	Analyze the volume and distribution of animation data.
	"""
	def run(self, showDetails=False):
		"""
		Examine the animation in the system and gather some basic statistics
		about it. There are two types of animation to find:

			1) Anim curves, which animate in the usual manner
			   Care is taken to make sure either time is either an explicit or
			   implicit input since anim curves could be used for reasons
			   other than animation (e.g. setDrivenKey)
			2) Any other node which has the time node as input
			   Since these are pretty generic we can only take note of how
			   many of these there are, and how many output connections they
			   have.
		
		When 'showDetails' is True then the CSV columns are:

			AnimationNode		: Name of node providing animation (e.g. animCurve)
			AnimationNodeType	: Type of node providing animation (e.g. animCurveTL)
			DrivenNode			: Name of node it animates (e.g. transform1)
			DrivenNodeType		: Type of node being animated (e.g. transform)
			Keyframes			: Number of keyframes in the AnimationNode
								  Count is 0 if the AnimationNode is not an anim curve.
			ReallyAnimated		: 1 if there is an anim curve and it is not flat, else 0

		One row is output for every AnimationNode -> DrivenNode connection.
		This can be an M -> N correspondence so this can be spread out over
		multiple rows.

		The above rows are skipped when 'showDetails' is False and then in
		either case some summary rows are printed, one per animation node type:

			AnimationNode		: # of nodes of type 'AnimationNodeType'
			AnimationNodeType	: Type of node providing animation (e.g. animCurveTL)
			DrivenNode			: ''
			DrivenNodeType		: ''
			Keyframes			: Sum of number of keyframes in all nodes of
								  that type. Keyframe count is 0 for non-param
								  curve nodes.
			ReallyAnimated		: Number of non-flat curves on nodes of the given type

		Return True if the analysis succeeded, else False
		"""
		success = True
		try:
			if not self._open():
				return False

			self._outputCSV( [ 'AnimationNode'
							 , 'AnimationNodeType'
							 , 'DrivenNode'
							 , 'DrivenNodeType'
							 , 'Keyframes'
							 , 'ReallyAnimated'
							 ] )

			nodesOfType = {}
			keysOfNodeType = {}
			reallyAnimatedOfNodeType = {}

			# First pass, get all interesting animation curves
			animCurves = maya.cmds.ls( type='animCurve' )
			for animCurve in animCurves:
				# If time isn't in this curve's immediate history then it's
				# not animation so skip it. (Time warps will be reported as
				# animating the animCurve(s) they drive.)
				timeInput = maya.cmds.listConnections( animCurve + '.input', destination=False, source=True )
				if timeInput and ('time' != maya.cmds.nodeType(timeInput[0])):
					continue

				animCurveNodeType = maya.cmds.nodeType( animCurve )
				keyframes = maya.cmds.keyframe(animCurve,query=True,keyframeCount=True)
				# Use an int instead of native boolean to make spreadsheet
				# manipulation easier.
				reallyAnimated = int(self.__isReallyAnimated(animCurve))
	
				# Track the totals as we go
				nodesOfType[animCurveNodeType] = nodesOfType.get(animCurveNodeType,0) + 1
				keysOfNodeType[animCurveNodeType] = keysOfNodeType.get(animCurveNodeType,0) + keyframes
				if reallyAnimated:
					reallyAnimatedOfNodeType[animCurveNodeType] = reallyAnimatedOfNodeType.get(animCurveNodeType,0) + 1

				if showDetails:
					drivenNodeList = maya.cmds.listConnections( animCurve, skipConversionNodes=True )
					if drivenNodeList:
						for drivenNode in drivenNodeList:
							drivenNodeType = maya.cmds.nodeType( drivenNode )
							self._outputCSV( [ animCurve
											 , animCurveNodeType
											 , drivenNode
											 , drivenNodeType
											 , str(keyframes)
											 , str(reallyAnimated)
											 ] )
					else:
						self._outputCSV( [ animCurve
										 , animCurveNodeType
										 , ''
										 , ''
										 , str(keyframes)
										 , str(reallyAnimated)
										 ] )

			# Now grab everything connected to the time node output that's not
			# already handled above. Only the direct connections (modulo unit
			# conversion nodes) are considered since the rest is animated but
			# not animation, a subtle but important difference.
			timeNode = maya.cmds.ls( type='time' )[0]
			timedNodes = maya.cmds.listConnections( '%s.outTime' % timeNode, skipConversionNodes=True, destination=True, source=False )
			if timedNodes:
				for node in timedNodes:
					if node in animCurves:
						continue
					nodeType = maya.cmds.nodeType( node )
					keysOfNodeType[nodeType] = 0
					nodesOfType[nodeType] = nodesOfType.get(nodeType,0) + 1
					if showDetails:
						sanitizedNodeName = self._sanitizedNodeName(node, showDetails)
						allOutputs = maya.cmds.listConnections( node, skipConversionNodes=True, destination=True, source=False )
						if allOutputs:
							for drivenNode in allOutputs:
								drivenNodeType = maya.cmds.nodeType( drivenNode )
								sanitizedDrivenNodeName = self._sanitizedNodeName(drivenNode, showDetails)
								self._outputCSV( [ sanitizedNodeName
												 , nodeType
												 , sanitizedDrivenNodeName
												 , drivenNodeType
												 , '0'
												 , '0'
												 ] )
						else:
							self._outputCSV( [ sanitizedNodeName
											 , nodeType
											 , ''
											 , ''
											 , '0'
											 , '0'
											 ] )

			# Finally output the summary lines (which will be the only outputs
			# in showDetails=False mode.
			for animCurveData in sorted( nodesOfType.iteritems(), key=itemgetter(1), reverse=True ):
				self._outputCSV( [ animCurveData[1]
								 , animCurveData[0]
								 , ''
								 , ''
								 , str(keysOfNodeType.get(animCurveData[0],0))
								 , str(reallyAnimatedOfNodeType.get(animCurveData[0],0))
								 ] )
		except Exception, ex:
			print 'analyticAnimation failed: "%s"' % str(ex)
			success = False
		finally:
			self._close()

		return success

	#======================================================================
	@classmethod
	def __isZero(cls,potentialZero):
		"""
		Simple near-zero check for floats
		"""
		return abs(potentialZero) <= 0.001

	#======================================================================
	@classmethod
	def __isReallyAnimated(cls,theCurve):
		"""
		Check to see if the animation curve takes on more than one value over time.
		theCurve : Anim curve to check
		Returns True if the curve does vary
		"""
		animationFlat = True

		if len(maya.cmds.ls( theCurve, type='animCurve' )) == 0:
			# It's too difficult to figure out if non-animCurves are really
			# animated so we'll err on the side of caution.
			return False

		# Tangents with angles below this value will be considered flat
		angleTol = 0.001
		# Neighboring values that fall within this tolerance will be considered matching
		valueTol = 0.001
		
		# Go through the keyframes on the current animation-curve and get inAngle and outAngle
		inAngle = maya.cmds.keyTangent( theCurve, query=True, inAngle=True )
		outAngle = maya.cmds.keyTangent( theCurve, query=True, outAngle=True )
		outTanType = maya.cmds.keyTangent( theCurve, query=True, outTangentType=True )

		# Make inAngle and outAngle absolute values, for less work on the comparison
		inAngle = [abs(x) for x in inAngle]
		outAngle = [abs(x) for x in outAngle]
			
		# Get each keyed frame, and get the value of each keyed frame
		keyedFrames = maya.cmds.keyframe( theCurve, query=True, timeChange=True )
		keyedValues = maya.cmds.keyframe( theCurve, query=True, valueChange=True )

		# For each keyframe on the animation curve check for non-flat keys
		keyNum = -1
		for (frame,value) in zip(keyedFrames,keyedValues):
			keyNum += 1

			# Get the outTangentType of the previuos frame, the current frame,
			# and the next frame. Keyframes past the endpoints are considered
			# stepped if the endpoints themselves are.
			#
			stepped = (outTanType[keyNum] == "step")
			stepped = stepped and ((keyNum==0) or (outTanType[keyNum-1] == "step"))
			stepped = stepped and ((keyNum+1 >= len(keyedFrames)) or (outTanType[keyNum+1] == "step"))

			# If stepped or the angles are flat check the values
			if (stepped
				or (    ((keyNum == 0) or cls.__isZero(outAngle[keyNum-1]))
					and  (inAngle[keyNum] < angleTol)
					and  (outAngle[keyNum] < angleTol)
					and  ((keyNum+1 >= len(keyedFrames)) or cls.__isZero(inAngle[keyNum+1])) ) ):
				# Get the difference of the value of the current attribute between
				# the previous frame and the current frame
				if keyNum > 0:
					prevValDif = abs(keyedValues[keyNum-1] - keyedValues[keyNum])
				else:
					prevValDif = 0
				# Get the difference of the value of the current attribute between
				# the current frame and the next frame
				if keyNum+1 < len(keyedValues):
					nextValDif = abs(keyedValues[keyNum+1] - keyedValues[keyNum])
				else:
					nextValDif = 0

				# If there is a flat step tangent or the values before and after
				# the keyframe are the same as at the keyframe then this is a
				# flat area of the curve.
				if (  not cls.__isZero(prevValDif)
				   or (not stepped and not cls.__isZero(nextValDif)) ):
					return True

		return False

# Copyright (C) 1997-2014 Autodesk, Inc., and/or its licensors.
# All rights reserved.
#
# The coded instructions, statements, computer programs, and/or related
# material (collectively the "Data") in these files contain unpublished
# information proprietary to Autodesk, Inc. ("Autodesk") and/or its licensors,
# which is protected by U.S. and Canadian federal copyright law and by
# international treaties.
#
# The Data is provided for use exclusively by You. You have the right to use,
# modify, and incorporate this Data into other products for purposes authorized 
# by the Autodesk software license agreement, without fee.
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND. AUTODESK
# DOES NOT MAKE AND HEREBY DISCLAIMS ANY EXPRESS OR IMPLIED WARRANTIES
# INCLUDING, BUT NOT LIMITED TO, THE WARRANTIES OF NON-INFRINGEMENT,
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE, OR ARISING FROM A COURSE 
# OF DEALING, USAGE, OR TRADE PRACTICE. IN NO EVENT WILL AUTODESK AND/OR ITS
# LICENSORS BE LIABLE FOR ANY LOST REVENUES, DATA, OR PROFITS, OR SPECIAL,
# DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES, EVEN IF AUTODESK AND/OR ITS
# LICENSORS HAS BEEN ADVISED OF THE POSSIBILITY OR PROBABILITY OF SUCH DAMAGES.

