#======================================================================
import os
import sys
import tempfile
from .ObjectNamer import *

__all__ = ['BaseAnalytic']

class BaseAnalytic(object):
	"""
	Base class for output for analytics.

	The default location for the anlaytic output is in a subdirectory
	called 'MayaAnalytics' in your temp directory. You can change that
	at any time by calling setOutputDirectory().

	Class static member:
		 ANALYTIC_NAME	: Name of the analytic

	Class members:
		 director		: Directory the output will go to
		 fileName		: Name of the file for this analytic
		 fileState		: Is the output stream currently opened?
						  If FILE_DEFAULT then it isn't openable
		 outputFile		: Output File object for writing the results
	"""

	FILE_DEFAULT = 0	# File is not openable (stdout or stderr)
	FILE_OPENED = 1		# File is currently opened
	FILE_CLOSED = 2		# File is currently closed

	ANALYTIC_NAME = 'Unknown'

	def __init__(self):
		self.directory = None
		self.outputFile = sys.stdout
		self.fileName = 'stdout'
		self.fileState = self.FILE_DEFAULT
		self.plugNamer = ObjectNamer( ObjectNamer.MODE_PLUG, anonymous=True )
		self.nodeNamer = ObjectNamer( ObjectNamer.MODE_NODE, anonymous=True )

	#----------------------------------------------------------------------
	def setOutputDirectory(self, directory):
		"""
		Call this method to set a specific directory as the output location.
		The special names 'stdout' and 'stderr' are recognized as the
		output and error streams respectively rather than a directory.
		"""
		self._close()   # Just in case something was open
		self.directory = directory

		# Setting a new location will as a side-effect close the current
		# stream if it happens to be set already.
		if self.directory == 'stdout' or self.directory == 'cout' or self.directory == None:
			self.outputFile = sys.stdout
			self.fileName = self.directory
			self.directory = None
			self.fileState = self.FILE_DEFAULT
		elif self.directory == 'stderr' or self.directory == 'cerr':
			self.outputFile = sys.stderr
			self.fileName = self.directory
			self.directory = None
			self.fileState = self.FILE_DEFAULT
		else:
			try:
				try:
					os.makedirs( directory, 0777 )
				except OSError,err:
					# This is the "directory already exists" error; harmless here
					if err.errno!=17:
						raise

				self.fileName = os.path.join(directory, '%s.csv' % self.ANALYTIC_NAME)
				self.outputFile = None
				self.fileState = self.FILE_CLOSED

				if not os.access( directory, os.W_OK):
					raise Exception( 'No permission to add files to %s' % directory )

				# Touch the file if it doesn't already exist
				if not os.path.exists(self.fileName):
					open(self.fileName, 'w').close()

				# Just to be a paranoid parrot
				if not os.access( self.fileName, os.W_OK):
					raise Exception( 'No permission to write to %s' % self.fileName )

			except Exception, ex:
				print 'Error creating new output directory, defaulting to stdout. "%s"' % str(ex)
				self.outputFile = sys.stdout
				self.fileName = 'stdout'
				self.fileState = self.FILE_DEFAULT

	#----------------------------------------------------------------------
	def outputExists(self):
		"""
		Checks to see if this analytic already has existing output at
		the current directory location. If stdout/stderr this is always
		false, otherwise it checks for the existence of a non-zero sized
		output file. (All legal output will at least have a header line,
		and we may have touched the file to create it in the call to
		setOutputDirectory().
		"""
		if self.fileName == None:
			return False
		if self.fileState == self.FILE_DEFAULT:
			return False
		if os.path.exists( self.fileName ):
			statinfo = os.stat( self.fileName )
			return statinfo.st_size > 0
		return False

	#----------------------------------------------------------------------
	def _open(self):
		"""
		Open the currently set output location for writing. Opens it in
		'w' mode so any existing file contents will be removed.
		"""
		if self.fileState == self.FILE_DEFAULT:
			# stdout and stderr don't need opening
			return True

		success = True
		if self.fileState == self.FILE_CLOSED:
			try:
				self.outputFile = open( self.fileName, 'w' )
				print 'Analytic "%s" outputs to %s' % (self.ANALYTIC_NAME, self.fileName)
			except Exception, ex:
				print 'Failed to set output location "%s": using stdout' % str(ex)
				self.outputFile = sys.stdout
				success = False
			finally:
				self.fileState = self.FILE_OPENED
		return success

	#----------------------------------------------------------------------
	def _close(self):
		"""
		Open the currently set output location for writing. Opens it in
		'w' mode so any existing file contents will be removed.
		"""
		if self.fileState == self.FILE_DEFAULT:
			# stdout and stderr don't need closed
			return

		# Prevent multiple closes
		if self.fileState == self.FILE_OPENED:
			try:
				self.outputFile.close()
			except Exception, ex:
				print 'Failed closing output location "%s". Data may be missing.' % str(ex)
			finally:
				self.fileState = self.FILE_CLOSED

	#----------------------------------------------------------------------
	def _setToDefaultLocation(self):
		"""
		Sets the output file to a default location. A temporary file is first
		constructed name of the analytic under the subdirectory "MayaAnalytics/".
		The directory is created if it doesn't exist and checked to make sure
		it can be written to. If not a warning is issued and sys.stdout is used,
		though the name of the file is preserved.
		"""
		self.setOutputDirectory( os.path.join(tempfile.gettempdir(), 'MayaAnalytics') )

	#----------------------------------------------------------------------
	def _output(self, data):
		"""
		Simple dump of the given data. It is assumed that the data is already
		formatted correctly so the information is just dumped as-is.
		"""
		try:
			self.outputFile.write( data )
			self.outputFile.flush()
		except Exception, ex:
			print 'Failed to output data: "%s"' % str(ex)

	#----------------------------------------------------------------------
	def _outputCSV(self, data):
		"""
		CSV dump of the given data. The data must be a list of values which
		will be dumped in a correct CSV line format.
		"""
		try:
			if type(data) != type([]):
				raise TypeError('_outputCSV requires a list input')

			csvList = []
			for element in ['"%s"' % str(column) for column in data]:
				csvList.append( element )
			self.outputFile.write( ','.join(csvList) + '\n' )
			self.outputFile.flush()
		except Exception, ex:
			print 'Failed to output CSV data: "%s"' % str(ex)

	#----------------------------------------------------------------------
	def _sanitizedNodeName(self, originalName, showDetails=False, maxSize=0):
		"""
		Return a sanitized version of the node name for output. If the details
		are being shown the result is just the name itself. Otherwise the
		result is a combination of the node type and a unique ID per type.

		originalName: Real name of the node in the scene
		showDetails	: True means use the original name, no mapping required
		maxSize		: Maximum number of this type of node. If 0 it's not known.
					  This is used to align formatting with leading 0's.
		"""
		if showDetails:
			return originalName

		self.nodeNamer.setMaxObjects( maxSize )

		return self.nodeNamer.name( originalName )

	#----------------------------------------------------------------------
	def _sanitizedPlugName(self, originalName, showDetails=False, maxSize=0):
		"""
		Return a sanitized version of the plug name for output. If the details
		are being shown the result is just the name itself. Otherwise the
		result is a combination of the node type and a unique ID per type
		followed by the plug path.

		At the moment the plug path is preserved but that part of the name
		could also by sanitized if desired in the future.

		originalName: Real name of the plug in the scene
		showDetails	: True means use the original name, no mapping required
		maxSize		: Maximum number of this type of node. If 0 it's not known.
					  This is used to align formatting with leading 0's.
		"""
		if showDetails:
			return originalName

		self.plugNamer.setMaxObjects( maxSize )

		return self.plugNamer.name( originalName )

# Copyright (C) 1997-2014 Autodesk, Inc., and/or its licensors.
# All rights reserved.
#
# The coded instructions, statements, computer programs, and/or related
# material (collectively the "Data") in these files contain unpublished
# information proprietary to Autodesk, Inc. ("Autodesk") and/or its licensors,
# which is protected by U.S. and Canadian federal copyright law and by
# international treaties.
#
# The Data is provided for use exclusively by You. You have the right to use,
# modify, and incorporate this Data into other products for purposes authorized 
# by the Autodesk software license agreement, without fee.
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND. AUTODESK
# DOES NOT MAKE AND HEREBY DISCLAIMS ANY EXPRESS OR IMPLIED WARRANTIES
# INCLUDING, BUT NOT LIMITED TO, THE WARRANTIES OF NON-INFRINGEMENT,
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE, OR ARISING FROM A COURSE 
# OF DEALING, USAGE, OR TRADE PRACTICE. IN NO EVENT WILL AUTODESK AND/OR ITS
# LICENSORS BE LIABLE FOR ANY LOST REVENUES, DATA, OR PROFITS, OR SPECIAL,
# DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES, EVEN IF AUTODESK AND/OR ITS
# LICENSORS HAS BEEN ADVISED OF THE POSSIBILITY OR PROBABILITY OF SUCH DAMAGES.

