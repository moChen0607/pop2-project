import os
import maya.cmds
from .BaseAnalytic import BaseAnalytic
from .decorators import addMethodDocs,addHelp,makeAnalytic

# Maximum number of frames to play (to avoid eternal tests)
ANALYTIC_EM_MAX_FRAMECOUNT = 200

# Enum to track how the values differ
EM_IDENTICAL = 0
EM_EMS_DIFFERS = 1
EM_EMP_DIFFERS = 2
EM_BOTH_DIFFER = 3
stateNames = [ 'Identical', 'EMS Differs', 'EMP Differs', 'EMS + EMP Differ' ]

#======================================================================

class DGState:
	def __init__(self, resultsFile=None, imageFile=None, eval=False):
		"""
		Create a new state object, potentially saving results offline if
		requested.

		resultsFile : Name of file in which to save the results.
					  Do not save anything if None.
		imageFile   : Name of file in which to save the current viewport screenshot.
					  Do not save anything if None.
		eval		: True means force evaluation of the plugs before checking
					  state. Used in DG mode since not all outputs used for
					  (e.g.) drawing will be in the datablock after evaluation.
		"""
		self.plugValues = {}	# (node,plug) = (clean,value)
		self.resultsFile = resultsFile
		self.imageFile = imageFile
		args = ['csv']
		if eval: args += ['eval']
		self.state = maya.cmds.dbpeek( op='data', a=args, all=True )

		if resultsFile != None:
			rf = open(resultsFile, 'w')
			rf.write( self.state )
			rf.close()

		if imageFile != None:
			maya.cmds.refresh( currentView=True, fileExtension='jpg', filename=imageFile )

	def extractDetails(self):
		"""
		Pull the details of the results string out into lists for easier
		processing.
		"""
		if len(self.plugValues) == 0:
			# Use [1:] to skip the title row.
			# Format for csv data is NODE,PLUG,CLEAN,VALUE
			for detail in self.state.strip().split('\n')[1:]:
				(node, plug, clean, value) = detail.split(',',3)
				self.plugValues[(node,plug)] = (clean,value)

	def allPlugs(self):
		"""
		Return a list of all plugs in the results.
		"""
		self.extractDetails()
		return self.plugValues.keys()

	def compare(self, other):
		"""
		Compare two state information collections to see if they are the same
		or not. Return False if they differ in any way. This is a quick check;
		other methods should be used for more details
		"""
		return self.state.strip() == other.state.strip()

#======================================================================

@addMethodDocs
@addHelp
@makeAnalytic
class analyticEvalManager(BaseAnalytic):
	"""
	Analyze the DG connectivity.
	"""
	def __playback(self,maxFrames=ANALYTIC_EM_MAX_FRAMECOUNT):
		"""
		Run a playback sequence, starting at the first frame and going to
		the maxFrame requested.

		The only reason this is a separate method is so that the number of
		frames being played can be capped.
		"""
		startFrame = maya.cmds.playbackOptions( query=True, minTime=True )
		oldEndFrame = maya.cmds.playbackOptions( query=True, maxTime=True )
		endFrame = oldEndFrame

		# If you have a scene with hugely long playback you don't want to be
		# waiting forever for the runs so limit the frame length to something
		# reasonable. (Or this could be recoded to make this an option.)
		if ANALYTIC_EM_MAX_FRAMECOUNT > 0 and oldEndFrame - startFrame >= ANALYTIC_EM_MAX_FRAMECOUNT:
			endFrame = startFrame + ANALYTIC_EM_MAX_FRAMECOUNT - 1

		maya.cmds.playbackOptions( maxTime=endFrame )
		maya.cmds.currentTime( maya.cmds.playbackOptions(query=True, minTime=True) )
		maya.cmds.play( wait=True )
		maya.cmds.playbackOptions( maxTime=oldEndFrame )

	#======================================================================

	def _hasEvaluationManager(self):
		"""
		Check to see if the evaluation manager is available
		"""
		return 'evaluationManager' in dir(maya.cmds)

	#======================================================================

	def run(self, showDetails=False):
		"""
		Run the playback in the scene in DG mode, EM serial mode, and EM
		parallel mode and check to see that the values for all nodes at the
		end of the playback are the same in all three cases.

		Values dumped to the analytic CSV file will be anything that is
		different between the three runs in the columns 'Name', 'DG',
		'EMS', 'EMP'.

		When 'showDetails' is True then one row per plug inspected is reported
		where:
			Name = Name of the node being reported
			Diff = 0 if all three values are identical,
				   1 if EMS and DG differ but DG and EMP are the same
				   2 if EMP and DG differ but DG and EMS are the same
				   3 if EMS and DG differ and DG and EMP differ
			EMS  = Plug value after EM Serial evaluation
			EMP  = Plug value after EM Parallel evaluation
			DG   = Plug value after DG evaluation

		At the end of the rows a summary row is inserted with the totals of
		all nodes in the file, even when 'showDetails' is False:
			Name = ''
			Diff = Total number of plugs different from DG values in both EM modes
			EMS  = Total number of plugs different from DG values in EM serial mode
			EMP  = Total number of plugs different from DG values in EM parallel mode
			DG   = Total number of plugs evaluated in the DG

		Return True if the evaluations succeeded and all EMS and EMP evaluations were
		the same as the DG evaluations.
		"""
		success = True
		try:
			if not self._open():
				return False

			# Configuration parameters
			doSerial = True
			doParallel = True
			maxFrames = ANALYTIC_EM_MAX_FRAMECOUNT

			self._outputCSV( [ 'Name', 'Diff', 'EMS', 'EMP', 'DG' ] )

			# Totals over the entire file
			totalPlugs = 0
			totalEMSdiffs = 0
			totalEMPdiffs = 0
			totalEMdiffs = 0

			# Output file locations for detailed output
			dgResults = None
			emsResults = None
			empResults = None
			dgResultsImage = None
			emsResultsImage = None
			empResultsImage = None

			# If there is a file name then there is a location in which to
			# store results. Use that location for the node state data.
			if self.fileName:
				rootName = os.path.join(self.directory,self.ANALYTIC_NAME)
				dgResults = '%s.dg.txt' % rootName
				emsResults = '%s.ems.txt' % rootName
				empResults = '%s.emp.txt' % rootName
				dgResultsImage = '%s.dg.jpg' % rootName
				emsResultsImage = '%s.ems.jpg' % rootName
				empResultsImage = '%s.emp.jpg' % rootName

			# Fail if evaluation manager is requested but not available
			if not self._hasEvaluationManager():
				return [  'ERROR: Evaluation manager is not available.' ]

			# Find out where the evaluaton manager stands now and shut it off
			oldEmMode = maya.cmds.evaluationManager( query=True, mode=True )[0]
			if oldEmMode != 'off':	# Avoids the warning that the mode is unchanged
				maya.cmds.evaluationManager( mode='off' )

			# Step 1: Record the DG evaluation version of the results
			self.__playback(maxFrames)
			mDG = DGState(dgResults, dgResultsImage, True)

			# Step 2: If requested record the EMS evaluation version of the results
			if doSerial:
				maya.cmds.evaluationManager( mode='serial' )
				self.__playback(maxFrames)
				mEMS = DGState(emsResults, emsResultsImage, False)
			else:
				mEMS = None

			# Step 2: If requested record the EMP evaluation version of the results
			if doParallel:
				maya.cmds.evaluationManager( mode='parallel' )
				self.__playback(maxFrames)
				mEMP = DGState(emsResults, emsResultsImage, False)
			else:
				mEMP = None
			
			# Restore the evaluation manager state
			maya.cmds.evaluationManager( mode=oldEmMode )

			# Have to initialize these to empty lists even when not evaluating
			# their modes so that it's possible to differentiate between
			# failures in only EMS, only EMP, and both.
			emsPlugsTheSame = []
			emsPlugsTheSame = []
			empPlugsThatDiffer = []
			empPlugsThatDiffer = []

			# For EMS and EMP modes find the list of plugs that are the same
			# and that are different so that the information can be reported
			mDG.extractDetails()
			if mEMS:
				mEMS.extractDetails()
			if mEMP:
				mEMP.extractDetails()
			for plug in mDG.allPlugs():
				state = EM_IDENTICAL

				# Break down the cases:
				#	EM_EMS_DIFFERS
				#		Plug is not in the EMP or is in the EMP with the same value as the DG
				#		+ Plug is in the EMS and has a different value than the DG
				#	EM_EMP_DIFFERS
				#		Plug is not in the EMS or is in the EMS with the same value as the DG
				#		+ Plug is in the EMP and has a different value than the DG
				#	EM_BOTH_DIFFER
				#		Plug is not in the EMS or is in the EMS with the same value as the DG
				#		+ Plug is not in the EMP or is in the EMP with the same value as the DG
				#	EM_IDENTICAL
				#		Plug is in both the EMS and EMP with the same value as the DG

				emsValid = mEMS and plug in mEMS.plugValues and mDG.plugValues[plug] == mEMS.plugValues[plug]
				empValid = mEMP and plug in mEMP.plugValues and mDG.plugValues[plug] == mEMP.plugValues[plug]

				if emsValid:
					if not empValid:
						state = EM_EMP_DIFFERS
						totalEMPdiffs += 1
					else:
						state = EM_IDENTICAL
						totalPlugs += 1
				else:
					if empValid:
						state = EM_EMS_DIFFERS
						totalEMSdiffs += 1
					else:
						state = EM_BOTH_DIFFER
						totalEMdiffs += 1
				if showDetails:
					cleanName = '%s.%s' % (self._sanitizedNodeName( plug[0], showDetails ), plug[1] )
					dgValue = mDG.plugValues[plug][1]
					emsValue = ''
					if mEMS and plug in mEMS.plugValues:
						emsValue = mEMS.plugValues[plug][1]
					empValue = ''
					if mEMP and plug in mEMP.plugValues:
						empValue = mEMP.plugValues[plug][1]
					self._outputCSV( [ cleanName, stateNames[state], emsValue, empValue, dgValue ] )

			# Now process any remaining plugs that are in the EMS/EMP but not
			# in the DG. They are by definition different.
			totalPlugs = len(mDG.allPlugs())
			for plug in mEMS.allPlugs():
				if plug in mDG.plugValues:
					continue
				totalPlugs += 1
				state = EM_IDENTICAL
				if plug in mEMP.plugValues:
					state = EM_BOTH_DIFFER
					totalEMdiffs += 1
					if showDetails:
						cleanName = '%s.%s' % (self._sanitizedNodeName( plug[0], showDetails ), plug[1] )
						self._outputCSV( [ cleanName, stateNames[state], mEMS.plugValues[plug][1], mEMP.plugValues[plug][1], '' ] )
				else:
					state = EM_EMS_DIFFERS
					totalEMSdiffs += 1
					if showDetails:
						cleanName = '%s.%s' % (self._sanitizedNodeName( plug[0], showDetails ), plug[1] )
						self._outputCSV( [ cleanName, stateNames[state], mEMS.plugValues[plug][1], '', '' ] )

			for plug in mEMP.allPlugs():
				if plug in mDG.plugValues:
					continue
				if plug not in mEMS.plugValues:
					totalPlugs += 1
					state = EM_EMP_DIFFERS
					totalEMPdiffs += 1
					if showDetails:
						cleanName = '%s.%s' % (self._sanitizedNodeName( plug[0], showDetails ), plug[1] )
						self._outputCSV( [ cleanName, stateNames[state], '', mEMP.plugValues[plug][1], '' ] )

			self._outputCSV( [ '', str(totalEMdiffs), str(totalEMSdiffs), str(totalEMPdiffs), str(totalPlugs) ] )

			success = (totalEMdiffs + totalEMPdiffs + totalEMSdiffs == 0)

		except Exception, ex:
			print 'Analytic failed: "%s"' % str(ex)
			success = False

		finally:
			self._close()

		return success

# Copyright (C) 1997-2014 Autodesk, Inc., and/or its licensors.
# All rights reserved.
#
# The coded instructions, statements, computer programs, and/or related
# material (collectively the "Data") in these files contain unpublished
# information proprietary to Autodesk, Inc. ("Autodesk") and/or its licensors,
# which is protected by U.S. and Canadian federal copyright law and by
# international treaties.
#
# The Data is provided for use exclusively by You. You have the right to use,
# modify, and incorporate this Data into other products for purposes authorized 
# by the Autodesk software license agreement, without fee.
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND. AUTODESK
# DOES NOT MAKE AND HEREBY DISCLAIMS ANY EXPRESS OR IMPLIED WARRANTIES
# INCLUDING, BUT NOT LIMITED TO, THE WARRANTIES OF NON-INFRINGEMENT,
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE, OR ARISING FROM A COURSE 
# OF DEALING, USAGE, OR TRADE PRACTICE. IN NO EVENT WILL AUTODESK AND/OR ITS
# LICENSORS BE LIABLE FOR ANY LOST REVENUES, DATA, OR PROFITS, OR SPECIAL,
# DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES, EVEN IF AUTODESK AND/OR ITS
# LICENSORS HAS BEEN ADVISED OF THE POSSIBILITY OR PROBABILITY OF SUCH DAMAGES.

