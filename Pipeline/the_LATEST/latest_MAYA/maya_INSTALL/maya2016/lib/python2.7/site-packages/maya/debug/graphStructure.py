"""
Utility to read and analyze dependency graph or evaluation graph structure
information. Allows you to produce a visualization of a single graph, a
text comparision of two graphs, or a merged comparison of two graphs.

	import maya.debug.graphStructure.graphStructure as graphStructure

	# Store the current scene's graph structure in a file
	cmds.dbpeek( op='graph', all=True, argument=['nodes','connections'], outputFile='FileForGraph.dg' )
	# or
	#	g = graphStructure()
	#   g.write( 'FileForGraph.dg' )

	# Get a new scene and get its structure directly
	cmds.file( 'MyTestFile.ma', force=True, open=True )
	graph1 = graphStructure()

	# Retrieve the stored graph structure
	graph2 = graphStructure( fileName='FileForGraph.dg' )

	# Compare them to see if they are the same
	if len(graph1.compare(graph2)) > 0:
		print 'Oh noooes, the graph structure has changed!'
		# Now visualize the differences
		graph1.compareAsDot(graph2, fileName='GraphCompare.dot', showOnlyDifferences=True)
"""

__all__ = ['dotFormatting', 'graphStructure']

import re
import sys

# Tags to delineate plug types in the evaluation graph dump format
PLUG_OUT_TAG   = '->'
PLUG_WORLD_TAG = '-W>'
PLUG_IN_TAG    = '<-'

#======================================================================
#
# Structure analysis of offline files will work without Maya running so
# use the maya import to dynamically detect what can and can't be done here.
#
try:
	import maya.cmds as cmds
	_mayaIsAvailable = True
except:
	_mayaIsAvailable = False
def checkMaya():
	if _mayaIsAvailable:
		return True
	print 'ERROR: Cannot perform this operation unless Maya is available'
	return False

#======================================================================
#
def splitConnection(connection):
	"""
	Extract the name of a node and its attribute specification from
	one side of a connection.
	"""
	parts = connection.split('.', 1)
	if len(parts) == 2:
		return (parts[0], parts[1])
	return (parts[0], '')

#######################################################################

class dotFormatting:
	"""
	Encapsulation of all of the .dot formatting decisions made for this
	type of graph output.
	"""
	# Dotted and Red for elements only in graph 1
	aNotbStyle = 'penwidth="1.0", style="dotted", color="#CC0000", fontcolor="#CC0000"'

	# Bold and Green for elements only in graph 2
	bNotaStyle = 'penwidth="4.0", style="solid", color="#127F12", fontcolor="#127F12"'

	# Thin and black for elements in both graphs
	aAndbStyle = 'penwidth="1.0", style="solid", color="#000000", fontcolor="#000000"'

	# Thin and grey for elements unchanged but required for context
	contextStyle = 'penwidth="1.0", style="solid", color="#CCCCCC", fontcolor="#CCCCCC"'

	# Legend is only needed for comparison, and one line is only required for
	# context when only the differences are being shown
	legendFmt = """	{
		rank = sink ;
		node [shape=box] ;
		__bothGraphs [label="In both graphs", %s] ;
		__aButNotb [label="In graph 1 but not graph 2", %s] ;
		__bButNota [label="In graph 2 but not graph 1", %s] ;
		%%s
	}""" % (aAndbStyle, aNotbStyle, bNotaStyle)
	legendCompare = legendFmt % ''
	legendCompareOnlyDifferences = legendFmt % ('__context [label="In both graphs, shown for context", %s] ;' % contextStyle)

	#======================================================================
	#
	def __init__(self, longNames=False):
		"""
		If longNames is True then don't attempt to shorten the node names by
		removing namespaces and DAG path elements.
		"""
		self.useLongNames = longNames

	#======================================================================
	#
	def nodeLabel(self, node):
		"""
		Provide a label for a node. Uses the basename if useLongNames is not
		turned on, otherwise the full name.

		e.g.  Original:   grandparent|parent:ns1|:child
			  Label:      child
		"""
		if self.useLongNames:
			return node
		nameList = node.split(':')
		return nameList[-1]

	#======================================================================
	def header(self):
		"""
		Print this only once, at the beginning of the .dot file
		"""
		return 'digraph G\n{\n\tnslimit = 1.0 ;\n\tsize = "7.5,10" ;\n'

	#======================================================================
	def legend(self, file):
		"""
		Print out a legend node. In the case of a graph dump this is only
		the title, containing the name of the file analyzed.
		"""
		return '\n\tlabelloc="b" ;\n\tlabel="%s" ;\n' % file

	#======================================================================
	def legendForCompare(self, file1, file2, showOnlyDifferences):
		"""
		Print out a legend node showing the formatting information for a
		comparison of two graphs.
		"""
		subTitle = ''
		if showOnlyDifferences:
			subTitle = '\\n(showing changes only)'

		legend = dotFormatting.legendCompare
		if showOnlyDifferences:
			legend = dotFormatting.legendCompareOnlyDifferences
		return '\n%s\n\tlabelloc="b" ;\n\tlabel="Graph 1 = %s\\nGraph 2 = %s%s" ;\n' % (legend, file1, file2, subTitle)

	#======================================================================
	def footer(self):
		"""
		Print this only once, at the end of the .dot file
		"""
		return '}\n'

	#======================================================================
	def simpleNodeFormat(self):
		"""
		Print out the formatting instruction to make nodes the default format.
		"""
		return '\n\tnode [shape="ellipse", %s] ;\n' % dotFormatting.aAndbStyle

	#======================================================================
	def contextNodeFormat(self):
		"""
		Print out the formatting instruction to make nodes visible in the
		comparison graph but faded to indicate that they are actually the
		same and only present for context.
		"""
		return '\n\tnode [shape="ellipse", %s] ;\n' % dotFormatting.contextStyle

	#======================================================================
	def node(self, node):
		"""
		Print out a graph node with a simplified label.
		"""
		node = node.replace( '"', '\\"' )
		return '\t"%s" [label="%s"] ;\n' % (node, self.nodeLabel(node) )

	#======================================================================
	def alteredNodeFormat(self, inOriginal):
		"""
		Print out formatting instruction for nodes that were in one graph
		but not the other. If inOriginal is True the nodes were in the
		original graph but not the secondary one, otherwise vice versa.
		"""
		if inOriginal:
			format = dotFormatting.aNotbStyle
		else:
			format = dotFormatting.bNotaStyle
		return '\n\tnode [%s] ;\n' % format

	#======================================================================
	def simpleConnection(self, src, dst):
		"""
		Print out a simple connection
		"""
		src = src.replace( '"', '\\"' )
		dst = dst.replace( '"', '\\"' )

		# Only use the node names for the connection for now since
		# creating graph nodes for every attribute doesn't give a
		# realistic view of connectivity (internal attribute dependencies
		# are not accounted for)
		try:
			(srcNode,srcPlug) = splitConnection( src )
			(dstNode,dstPlug) = splitConnection( dst )
		except Exception, ex:
			print 'WARN: Could not connect %s to %s : "%s"' % (src, dst, str(ex))
			return ''

		format = ''
		if len(srcPlug) > 0 or len(dstPlug) > 0:
			format = '[ label="%s" ]' % ("%s -> %s" % (srcPlug, dstPlug))
		return '\t"%s" -> "%s" %s;\n' % (srcNode, dstNode, format)

	#======================================================================
	def alteredConnection(self, src, dst, inOriginal):
		"""
		Print out code for a connection that was in one graph but not the other.
		If inOriginal is True the connection was in the original graph but not
		the secondary one, otherwise vice versa.
		"""
		src = src.replace( '"', '\\"' )
		dst = dst.replace( '"', '\\"' )
		if inOriginal:
			format = dotFormatting.aNotbStyle
		else:
			format = dotFormatting.bNotaStyle

		# Only use the node names for the connection for now since
		# creating graph nodes for every attribute doesn't give a
		# realistic view of connectivity (internal attribute dependencies
		# are not accounted for)
		try:
			(srcNode,srcPlug) = splitConnection( src )
			(dstNode,dstPlug) = splitConnection( dst )
		except Exception, ex:
			print 'WARN: Could not connect %s to %s : "%s"' % (src, dst, str(ex))
			return ''

		if len(srcPlug) > 0 or len(dstPlug) > 0:
			format = 'label="%s", %s' % ("%s -> %s" % (srcPlug, dstPlug), format)
		return '\t"%s" -> "%s" [ %s ];\n' % (srcNode, dstNode, format)

#######################################################################

class graphStructure:
	"""
	Provides access and manipulation on graph structure data that has been
	produced by the 'dbpeek -op graph' or 'dbpeek -op evaluationGraph' commands.
	"""
	#======================================================================
	def __init__(self, structureFileName=None, longNames=False, evaluationGraph=False):
		"""
		Create a graph structure object from a file or the current scene.
		If the structureFileName is None then the current scene will be used,
		otherwise the file will be read.

		The graph data is read in and stored internally in a format that makes
		formatting and comparison easy.

		If longNames is True then don't attempt to shorten the node names by
		removing namespaces and DAG path elements.

		If evaluationGraph is True then get the structure of the evaluation
		manager graph, not the DG. This requires that the graph has already
		been created of course, e.g. by playing back a frame or two in EM
		serial or EM parallel mode.
		"""
		self.useLongNames = longNames
		self.evaluationGraph = evaluationGraph

		if structureFileName == None:
			self._initFromScene()
		else:
			self._initFromFile(structureFileName)

	def _initFromScene(self):
		"""
		Create a graph structure object from the current Maya scene.
		"""
		if not checkMaya():
			return
		self._name = '__SCENE__'
		self._nodes = []
		self._plugsOut = []
		self._plugsIn = []
		self._plugsWorld = []
		self._connections = []
		nodeTypes = ['nodes']
		connectionTypes = ['connections']
		plugTypes = None
		if self.evaluationGraph:
			nodeTypes.append( 'evaluationGraph' )
			plugTypes = ['plugs', 'evaluationGraph']
			connectionTypes.append( 'evaluationGraph' )

		for node in [node.rstrip() for node in cmds.dbpeek( op='graph', all=True, argument=nodeTypes ).split('\n')]:
			# Skip blank lines
			if len(node) == 0:
				continue
			self._nodes.append( node )

		if plugTypes != None:
			for plugInfo in cmds.dbpeek( op='graph', all=True, argument=plugTypes).split('\n'):
				if len(plugInfo.strip()) == 0:
					continue
				try:
					(plugType, plugName) = plugInfo.split('\t')
					if plugType == PLUG_OUT_TAG:
						self._plugsOut.append( plugName )
					elif plugType == PLUG_WORLD_TAG:
						self._plugsWorld.append( plugName )
					elif plugType == PLUG_IN_TAG:
						self._plugsIn.append( plugName )
					else:
						raise Exception
				except Exception, ex:
					print 'WARN: Could not parse plug "%s"' % plugInfo

		connection = cmds.dbpeek( op='graph', all=True, argument=connectionTypes )
		for connectionLine in connection.split('\n'):
			# Skip blank lines
			if len(connectionLine) == 0:
				continue
			connectionList = connectionLine.split('\t')
			if len(connectionList) == 2:
				self._connections.append( (connectionList[0],connectionList[1]) )
			else:
				print 'WARN: Could not parse connection %s' % connection

	#======================================================================
	def _initFromFile(self, structureFileName):
		"""
		Create a graph structure object from contents of the given file.
		Data in the file will be lines in two different formats:

			X		: Node X is in the graph
			X<tab>Y	: A connection from X to Y is in the graph
		"""
		self._name = structureFileName
		self._nodes = []
		self._plugsIn = []
		self._plugsOut = []
		self._plugsWorld = []
		self._connections = []

		# Precompile the line expressions for faster matching
		reConnection = re.compile('\s*([^\t]+)\t([^\s]+)\s*$')
		reNode = re.compile('\s*([^\s]+)\s*$')
		rePlugOut = re.compile('\s*%s\t([^\s]+)\s*$' % PLUG_OUT_TAG)
		rePlugWorld = re.compile('\s*%s\t([^\s]+)\s*$' % PLUG_WORLD_TAG)
		rePlugIn = re.compile('\s*%s\t([^\s]+)\s*$' % PLUG_IN_TAG)

		structureFile = open(structureFileName, 'r')
		for line in structureFile:
			match = reConnection.match( line )
			if match:
				self._connections.append( (match.group(1), match.group(2)) )
				continue
			match = reNode.match( line )
			if match:
				self._nodes.append( match.group(1) )
				continue
			match = rePlugOut.match( line )
			if match:
				self._plugsOut.append( match.group(1) )
				continue
			match = rePlugWorld.match( line )
			if match:
				self._plugsWorld.append( match.group(1) )
				continue
			match = rePlugIn.match( line )
			if match:
				self._plugsIn.append( match.group(1) )
				continue
			if len(line.rstrip().lstrip()) > 0: # Allow blank lines
				print 'WARN: Line not recognized: %s' % line,

	#======================================================================
	def name(self):
		"""
		Return an identifying name for this graph structure.
		"""
		return self._name

	#======================================================================
	def write(self, fileName=None):
		"""
		Dump the graph in the .dg format it uses for reading. Useful for
		creating a dump file from the current scene, or just viewing the
		graph generated from the current scene. If the fileName is specified
		then the output is sent to that file, otherwise it goes to stdout.
		"""
		out = sys.stdout
		if fileName:
			out = open(fileName, 'w')

		for node in self._nodes:
			out.write( '%s\n' % node )

		for plug in self._plugsOut:
			out.write( '%s\t%s\n' % (PLUG_OUT_TAG, plug) )

		for plug in self._plugsWorld:
			out.write( '%s\t%s\n' % (PLUG_WORLD_TAG, plug) )

		for plug in self._plugsIn:
			out.write( '%s\t%s\n' % (PLUG_IN_TAG, plug) )

		for (src,dst) in self._connections:
			out.write( '%s\t%s\n' % (src, dst) )

	#======================================================================
	def writeAsDot(self, fileName=None):
		"""
		Dump the graph in .dot format for visualization in an application
		such as graphViz. If the fileName is specified then the output is
		sent to that file, otherwise it is printed to stdout.

		Plugs have no dot format as yet.
		"""
		out = sys.stdout
		if fileName:
			out = open(fileName, 'w')
		dot = dotFormatting(self.useLongNames);

		out.write( dot.header() )
		out.write( dot.legend(self.name()) )

		out.write( dot.simpleNodeFormat() )
		for node in self._nodes:
			out.write( dot.node(node) )

		# Plugs have no output method as yet

		for (src,dst) in self._connections:
			out.write( dot.simpleConnection(src, dst) )

		out.write( dot.footer() )

	#======================================================================
	def compareAsDot(self, other, fileName=None, showOnlyDifferences=False):
		"""
		Compare this graph structure against another one and print out a
		.dot format for visualization in an application such as graphViz.

		The two graphs are overlayed so that the union of the graphs is
		present. Colors for nodes and connetions are:

			Black      : They are present in both graphs
			Red/Dotted : They are present in this graph but not the alternate graph
			Green/Bold : They are present in the alternate graph but not this graph

		If the fileName is specified then the output is sent
		to that file, otherwise it is printed to stdout.

		If showOnlyDifferences is set to True then the output will omit all of
		the nodes and connections the two graphs have in common. Some common
		nodes may be output anyway if there is a new connection between them.

		Plugs have no dot format as yet.
		"""
		out = sys.stdout
		if fileName:
			out = open(fileName, 'w')

		dot = dotFormatting(self.useLongNames);

		out.write( dot.header() )
		out.write( dot.legendForCompare(self.name(), other.name(), showOnlyDifferences) )

		# Node are written out in multiple passes so that a single formatting
		# line can provide drawing instructions for the entire group of nodes.
		# This makes the file a lot smaller.

		# When showing only differences some connected nodes may not be
		# explicitly output. Although .dot can handle the formatting correctly
		# it cannot handle the name shortening for the label so remember which
		# ones were shown so that we can do it explicitly.
		nodesShown = {}

		# Pass 1: Write out nodes in both graphs
		if not showOnlyDifferences:
			out.write( dot.simpleNodeFormat() )
			for node in self._nodes:
				if node in other._nodes:
					nodesShown[node] = True
					out.write( dot.node(node) )
		
		# Pass 2: Write out nodes in graph 1 but not graph 2
		out.write( dot.alteredNodeFormat(True) )
		for node in self._nodes:
			if node not in other._nodes:
				nodesShown[node] = True
				out.write( dot.node(node) )

		# Pass 3: Write out nodes in graph 2 but not graph 1
		out.write( dot.alteredNodeFormat(False) )
		for node in other._nodes:
			if node not in self._nodes:
				nodesShown[node] = True
				out.write( dot.node(node) )

		# Set up node formatting for context since it's possible that new
		# connections will have been made on nodes in both graphs. In that
		# case the nodes have to be output as well to visualize the connection
		# so we can let .dot handle the correct formatting for those.
		out.write( dot.contextNodeFormat() )

		# Pass 4: Write out connections in both graphs
		if not showOnlyDifferences:
			for (src,dst) in self._connections:
				if (src,dst) in other._connections:
					out.write( dot.simpleConnection(src,dst) )

		# Pass 5: Write out connections in graph 1 but not graph 2
		for (src,dst) in self._connections:
			if (src,dst) not in other._connections:
				(srcNode,srcPlug) = splitConnection( src )
				if srcNode not in nodesShown:
					out.write( dot.node(srcNode) )
				(dstNode,dstPlug) = splitConnection( dst )
				if dstNode not in nodesShown:
					out.write( dot.node(dstNode) )
				out.write( dot.alteredConnection(src,dst,True) )

		# Pass 6: Write out connections in graph 2 but not graph 1
		for (src,dst) in other._connections:
			if (src,dst) not in self._connections:
				(srcNode,srcPlug) = splitConnection( src )
				if srcNode not in nodesShown:
					out.write( dot.node(srcNode) )
				(dstNode,dstPlug) = splitConnection( dst )
				if dstNode not in nodesShown:
					out.write( dot.node(dstNode) )
				out.write( dot.alteredConnection(src,dst,False) )

		out.write( dot.footer() )

	#======================================================================
	def _compareLists(self, list1, list2, addedLabel, removedLabel):
		"""
		Compare two lists and output two sets of lines, one indicating an item
		in the first list but not the second (using addedLabel as a marker)
		and the second indicating an item in the second list but not the
		first (using removedLabel as a marker).

		Return the list of differences found.
		"""
		differences = []
		for entry in list1:
			if entry in list2:
				continue
			differences.append( '%s: %s\n' % (addedLabel, entry) )

		for entry in list2:
			if entry in list1:
				continue
			differences.append( '%s: %s\n' % (removedLabel, entry) )

		return differences

	#======================================================================
	def compare(self, other):
		"""
		Compare this graph structure against another one and generate a
		summary of how the two graphs differ. Differences will be returned
		as a string list consisting of difference descriptions. That way
		when testing, an empty return means the graphs are the same.

		The different argument formats are:
		
			NodeAdded: N			Nodes in self but not in other
			NodeRemoved: N			Nodes in other but not in self
			PlugOutAdded: P			Output plugs in self but not in other
			PlugOutRemoved: P		Output plugs in other but not in self
			PlugWorldAdded: P		Worldspace output plugs in self but not in other
			PlugWorldRemoved: P		Worldspace output plugs in other but not in self
			PlugInAdded: P			Input plugs in self but not in other
			PlugInRemoved: P		Input plugs in other but not in self
			ConnectionAdded: S D	Connections in self but not in other
			ConnectionRemoved: S D	Connections in other but not in self
		"""
		differences = []

		differences += self._compareLists( self._nodes, other._nodes, 'NodeAdded', 'NodeRemoved' )
		differences += self._compareLists( self._plugsOut, other._plugsOut, 'PlugOutAdded', 'PlugOutRemoved' )
		differences += self._compareLists( self._plugsWorld, other._plugsWorld, 'PlugWorldAdded', 'PlugWorldRemoved' )
		differences += self._compareLists( self._plugsIn, other._plugsIn, 'PlugInAdded', 'PlugInRemoved' )

		for connection in self._connections:
			if connection in other._connections:
				continue
			differences.append( 'ConnectionAdded: %s\t%s\n' % (connection[0], connection[1]) )

		for connection in other._connections:
			if connection in self._connections:
				continue
			differences.append( 'ConnectionRemoved: %s\t%s\n' % (connection[0], connection[1]) )

		return differences

# Copyright (C) 1997-2014 Autodesk, Inc., and/or its licensors.
# All rights reserved.
#
# The coded instructions, statements, computer programs, and/or related
# material (collectively the "Data") in these files contain unpublished
# information proprietary to Autodesk, Inc. ("Autodesk") and/or its licensors,
# which is protected by U.S. and Canadian federal copyright law and by
# international treaties.
#
# The Data is provided for use exclusively by You. You have the right to use,
# modify, and incorporate this Data into other products for purposes authorized 
# by the Autodesk software license agreement, without fee.
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND. AUTODESK
# DOES NOT MAKE AND HEREBY DISCLAIMS ANY EXPRESS OR IMPLIED WARRANTIES
# INCLUDING, BUT NOT LIMITED TO, THE WARRANTIES OF NON-INFRINGEMENT,
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE, OR ARISING FROM A COURSE 
# OF DEALING, USAGE, OR TRADE PRACTICE. IN NO EVENT WILL AUTODESK AND/OR ITS
# LICENSORS BE LIABLE FOR ANY LOST REVENUES, DATA, OR PROFITS, OR SPECIAL,
# DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES, EVEN IF AUTODESK AND/OR ITS
# LICENSORS HAS BEEN ADVISED OF THE POSSIBILITY OR PROBABILITY OF SUCH DAMAGES.

