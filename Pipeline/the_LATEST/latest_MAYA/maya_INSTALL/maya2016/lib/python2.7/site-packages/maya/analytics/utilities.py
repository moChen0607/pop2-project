"""
Collection of general utilities for use with Maya analytics. See the help
string for each method for more details.

	listAnalytics				: List all of the available analytics
	runAllAnalytics				: Run all of the analytics on the current scene
	runAnalytics				: Run a ist of analytics on the current scene
	runAllAnalyticsOnDirectory	: Run all analytics on all files in the directory
	runAnalyticsOnDirectory		: Run a list of analytics on all files in the directory
"""
#======================================================================
import os
import sys
import math
import pkgutil
import importlib
import maya.cmds
from .MayaFileIterator import MayaFileIterator, getMayaFilesByDirectory
from os.path import isfile, join

__all__ = [ 'addAnalytic'
		  , 'bootstrapAnalytics'
		  , 'listAnalytics'
		  , 'runAllAnalytics'
		  , 'runAllAnalyticsOnDirectory'
		  , 'runAnalytics'
		  , 'runAnalyticsOnDirectory'
		  ]
_allAnalytics = {}

#======================================================================

def addAnalytic(name, cls):
	"""
	Add a new analytic to the global list. Used by the decorator
	'makeAnalytic' to mark a class as being an analytic.
	"""
	global _allAnalytics
	_allAnalytics[name] = cls

#======================================================================

def bootstrapAnalytics():
	"""
	Bootstrap loading of the analytics in the same directory as this script.
	It only looks for files with the prefix "analytic" but you can add any
	analytics at other locations by using the @makeAnalytic decorator and
	importing them before calling listAnalytics.
	"""
	package = sys.modules[globals()['__package__']]
	for importer, modname, ispkg in pkgutil.walk_packages(path=package.__path__
                                                             ,prefix=package.__name__+'.'
                                                             ,onerror=lambda x: None):

		if modname[-4:] == '_res':
			# These are internationalization resources, not classes
			continue

		if modname[-9:] == 'utilities':
			# This is a utility file to bring common features to the analytics
			continue

		if modname.split('.')[-1][:8] == 'analytic':
			# The act of importing will make the @makeAnalytic decorator
			# register the analytic properly.
			importlib.import_module( modname, package )

#======================================================================

def listAnalytics():
	"""
	List all of the objects in this packages that perform analysis of the
	Maya scene for output. They were gleaned from the list collected by
	the use of the @makeAnalytic decorator.

	The actual module names are returned. If you imported the module with a
	shorter alias use that instead.
	"""
	return _allAnalytics.keys()

#======================================================================

def __analyticByName(analyticName):
	"""
	Get an analytic class object by name. If no anaytic of that name exists
	then a KeyError exception is raised.
	"""
	if analyticName not in _allAnalytics:
		raise KeyError( 'Analytic "%s" not registered' % analyticName )
	return _allAnalytics[analyticName]

#======================================================================

def runAllAnalytics(details=False, outputDir=None):
	"""
	This method will run all of the available analytics in their default configurations.

	details = Instruct the analytics to dump all of their details. This
			  will contain specific information about the scene such as
			  node names so only use if you wish to expose those details.
			  See the help() for each analytic to see exactly what they
			  will expose when the details are turned on.
	outputDir = Destination directory for the output files. If not specified
				then all output will go to your 'temporary' directory.
	"""
	return runAnalytics( listAnalytics(), details, outputDir )

#======================================================================

def runAnalytics(analyticNames, details=False, outputDir=None):
	"""
	This method will run the listed analytics in their default configurations.

	analyticNames = List of analytics to be run
	details = Instruct the analytics to dump all of their details. This
			  will contain specific information about the scene such as
			  node names so only use if you wish to expose those details.
			  See the help() for each analytic to see exactly what they
			  will expose when the details are turned on.
	outputDir = Destination directory for the output files. If not specified
				then all output will go to your 'temporary' directory.
	"""
	results = []
	for name in analyticNames:
		try:
			analyticObject = __analyticByName(name)()
			analyticObject.setOutputDirectory( outputDir )
			results.append( analyticObject.run(showDetails=details) )
		except KeyError, ex:
			print 'ERROR: "%s"' % str(ex)
	return results

#======================================================================

def runAllAnalyticsOnDirectory(
		srcDir=None
	,	dstDir=None
	,	doSubdirectories=True
	,	skipReferences=True
	,	details=False
	,	force=False
	,	listOnly=False
	,	skipList=None
	):
	"""
	Run all of the currently available Animation Analytics on every file in a
	directory. See runAnalyticsOnDirectory for a detailed description of what
	is to be run.
	"""
	return runAnalyticsOnDirectory(listAnalytics(), srcDir, dstDir, doSubdirectories, skipReferences, details, force, listOnly, skipList)

#======================================================================

def runAnalyticsOnDirectory(
		analyticNames
	,	srcDir=None
	,	dstDir=None
	,	doSubdirectories=True
	,	skipReferences=True
	,	details=False
	,	force=False
	,	listOnly=False
	,	skipList=None
	):
	"""
	Run all of the currently available Animation Analytics on every file in a
	directory.

	analyticNames = List of analytics to be run
	srcDir  = Directory in which the test files (.ma/.mb) can be found
	dstDir  = Root directory where the results are to be stored. Every file's
			  results will be stored in a subdirectory of this main directory
			  whose name is the same as the file (including the .ma/.mb).
			  If not specified it will default to srcDir/MayaAnalytics.
	doSubdirectories = Recurse down into the subdirectories of srcDir. If
			  dstDir is specified then all results go into that directory,
			  otherwise they will be relative to the directory being processed
			  (i.e. subdirectory's results go into the subdirectory).
	skipReferences = If any subdirectory has the name "references" then do not
			  descend into it. (Ignored when doSubdirectories is False.)
	details = Instruct the analytics to dump all of their details. This
			  will contain specific information about the scene such as
			  node names so only use if you wish to expose those details.
			  See the help() for each analytic to see exactly what they
			  will expose when the details are turned on.
	force   = If False then do not run analytics on files for which they
			  already exist. Only the default location (MayaAnalytics/FILE/)
			  is checked to determine if this is true.
	listOnly= If True then don't run the analytics, just list the files that
			  would be otherwise run.
	skipList= List of files to omit from the analytic run. Just the filename
			  is expected, not the full path.

	Returns a tuple (Done,Skipped,Failed,Results) with files analyzed, or that
	would have been analyzed if the listOnly flag was False, where:
		Done		= the list of files actually analyzed
		Skipped		= the list of files skipped because they were already analyzed
					  or they appeared on the skipList
		Failed	= the list of files skipped due to earlier failed analysis
		Results	= the list of file return results for each analytic. This return
				  value allows an analysis to produce results and also define
				  a return state for the success of the analytic's test. The
				  list is a tuple of (FILE, ANALYTIC, str(RESULT)). The result
				  is always converted to a string and it's up to the caller to
				  interpret it.
	"""
	filesAnalyzed	= []
	filesSkipped	= []
	filesFailed		= []
	results			= []

	# Translate the list of analytic names into analytic class objects
	analytics		= []
	for name in analyticNames:
		try:
			analytics.append( __analyticByName(name) )
		except KeyError, ex:
			print 'ERROR: "%s"' % str(ex)

	if srcDir == None:
		print 'ERROR: You must specify a directory where the test files can be found'
		return
	print 'Reading the test files from %s' % srcDir

	if dstDir == None:
		print 'Sending analytic results to the MayaAnalytics/ subdirectory below the files being analyzed'
	else:
		print 'Sending analytic results to %s' % dstDir

	# It's a crude approximation to assume all referenced files are in a
	# subdirectory called 'references' but it will do for our purposes
	directoriesToSkip = []
	if skipReferences:
		directoriesToSkip.append( 'references' )
	iterator = MayaFileIterator( srcDir, descend=doSubdirectories, skipDirectories=directoriesToSkip )
	dirList = getMayaFilesByDirectory( iterator )

	for (theDir, theFiles) in dirList:
		if dstDir == None:
			analyticRootDir = join(theDir, 'MayaAnalytics')
		else:
			analyticRootDir = dstDir

		if len(theFiles) == 0:
			continue

		# Prepare formatting if the file name is to be hidden
		fileFmt = 'analytics%%0%dd' % (int(math.log10(len(theFiles)))+1)
		fileCount = 1

		# Walk all of the files in the specified directory
		for theFile in theFiles:
			# Point the analytics output to a unique subdirectory
			if details:
				# Name it after the Maya file if details are visible
				analyticDir = join(analyticRootDir, theFile)
			else:
				# Give it a generic name if details are not visible
				analyticDir = join(analyticRootDir, fileFmt % fileCount)
				fileCount += 1
			filePath = os.path.join(theDir,theFile)

			# Check to see which analytics should be run. If force is False
			# then only those analytics without existing results are run,
			# otherwise all of them are run.
			if force:
				analyticList = analytics
			else:
				analyticList = []
				for cls in analytics:
					analytic = cls()
					analytic.setOutputDirectory( analyticDir )
					if not analytic.outputExists():
						analyticList.append( cls )

			# If no analytics remain to be run then this file can be skipped
			if len(analyticList) == 0:
				filesSkipped.append( filePath )
				print '--- Skipping file %s with existing analytics' % filePath
				continue

			# Tag the current file in progress so that failures can be
			# found later and the file can be checked individually or
			# added to the skip list
			markerFilePath = '%s.ANALYZING' % filePath
			if not force and isfile( markerFilePath ):
				print '### Skipping file %s with failed analytics' % filePath
				filesFailed.append( filePath )
				continue

			print '--- Analyzing %s' % filePath
			print '    (output to %s)' % analyticDir
			filesAnalyzed.append( filePath )

			# If only listing the files then there is nothing else to do
			if listOnly:
				continue

			try:
				marker = open(markerFilePath, 'w')
				marker.write( 'In Progress' )
				marker.close()
			except IOError, ex:
				pass

			try:
				maya.cmds.file( filePath, open=True, force=True, prompt=False )
			except Exception, ex:
				print 'Problems reading test file "%s" : %s' % (filePath, str(ex))

			# Run the filtered analytics
			for cls in analyticList:
				try:
					analytic = cls()
					analytic.setOutputDirectory( analyticDir )
					results.append( (filePath, cls.__name__, str(analytic.run(showDetails=details))) )
				except Exception, ex:
					print 'Failed to run analytic "%s" : %s' % (cls.__name__, str(ex))

			# Remove the marker file that shows the analysis as in-progress
			try:
				os.remove( markerFilePath )
			except IOError, ex:
				pass

	return (filesAnalyzed, filesSkipped, filesFailed, results)

# Copyright (C) 1997-2014 Autodesk, Inc., and/or its licensors.
# All rights reserved.
#
# The coded instructions, statements, computer programs, and/or related
# material (collectively the "Data") in these files contain unpublished
# information proprietary to Autodesk, Inc. ("Autodesk") and/or its licensors,
# which is protected by U.S. and Canadian federal copyright law and by
# international treaties.
#
# The Data is provided for use exclusively by You. You have the right to use,
# modify, and incorporate this Data into other products for purposes authorized 
# by the Autodesk software license agreement, without fee.
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND. AUTODESK
# DOES NOT MAKE AND HEREBY DISCLAIMS ANY EXPRESS OR IMPLIED WARRANTIES
# INCLUDING, BUT NOT LIMITED TO, THE WARRANTIES OF NON-INFRINGEMENT,
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE, OR ARISING FROM A COURSE 
# OF DEALING, USAGE, OR TRADE PRACTICE. IN NO EVENT WILL AUTODESK AND/OR ITS
# LICENSORS BE LIABLE FOR ANY LOST REVENUES, DATA, OR PROFITS, OR SPECIAL,
# DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES, EVEN IF AUTODESK AND/OR ITS
# LICENSORS HAS BEEN ADVISED OF THE POSSIBILITY OR PROBABILITY OF SUCH DAMAGES.

