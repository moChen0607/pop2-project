"""
Utility to verify that the evaluation manager is yielding the same results
as the Maya DG evaluation.

If resultsPath is set then the graph output and differences are dumped to
files using that path as the base name.  For example:

    resultsPath           = MyDirectory/emCorrecteness_animCone
    DG results dump       = MyDirectory/emCorrecteness_animCone.dg.txt
    DG results image      = MyDirectory/emCorrecteness_animCone.dg.png
    ${mode} results dump  = MyDirectory/emCorrecteness_animCone.${mode}.txt
    ${mode} results image = MyDirectory/emCorrecteness_animCone.${mode}.png

If resultsPath is not set then no output is stored, everything is live.

The return value is a list of value pairs indicating number of differences
between the DG evaluation and the EM mode. e.g. if you requested 'ems'
mode then you would get back {'ems' : 0} from a successful comparison.

Legal values for modes are 'ems' and 'emp' with an optional '+XXX' to
indicate that evaluator XXX should be turned on during the test or an
optional '-XXX' to indicate that it should be turned off. Evaluator
states will be returned to their original value afte the test is run.
If an evaluator is not explicitly listed the current state of it will
be used for the test.

e.g. modes=['ems','emp+deformer']  means run the comparison twice, first
against EM Serial mode, the second time against EM Parallel mode with
the 'deformer' evaluator turned on. You can use multiple evaluators if
you wish: modes=['ems+deformer-dynamics'].

For now the images are not compared, only the attribute values.

If fileName is not set then the current scene is analyzed.

Sample usage to run the tests on a single file:

    from maya.debug.emCorrectnessTest import emCorrectnessTest
    serialErrors = emCorrectnessTest(fileName='MyDir/MyFile.ma', resultsPath='MyDir/emCorrectness', modes=['ems'])[1]

Sample usage to run the tests on the current scene in parallel mode with the deformer evaluator and ignore output:

    from maya.debug.emCorrectnessTest import emCorrectnessTest
    parallelErrors = emCorrectnessTest(modes=['emp+deformer'])
"""

import os
import re
import sys
import math
import hashlib
import subprocess
import tempfile
import maya.cmds as cmds
from maya.debug.TODO import TODO as TODO
from maya.debug.emModeManager import emModeManager as emModeManager

__all__ = [ 'emCorrectnessTest'
        ,   'DGState'
        ,   'SCREENSHOT_NODE'
        ,   'SCREENSHOT_PLUG_MD5'
        ,   'SCREENSHOT_PLUG_MAG'
        ,   'SCREENSHOT_PLUG_IMF'
        ,   'EMCORRECTNESS_NO_SETUP'
        ,   'EMCORRECTNESS_DOUBLE_PLAYBACK'
        ,   'EMCORRECTNESS_INVALIDATE'
        ]

# Maximum number of frames to play (to avoid eternal tests)
EMCORRECTNESS_MAX_FRAMECOUNT = 200

# Expression that extracts the root attribute out of a full plug name.
RE_ROOT_ATTRIBUTE = re.compile( r'([^\.^\[]+)' )

# Expression that extracts image compare data from the imfDiff output
RE_IMF_IDENTICAL = re.compile( r'.*are identical', re.MULTILINE|re.DOTALL )
RE_IMF_COMPARE = re.compile( r'differing pixels:\s+([0-9\.]+)[^\(]+\(([0-9]+)[^0-9]+([0-9]+)' )

# Expression that extracts image compare data from the ImageMagick output
RE_IMG_COMPARE = re.compile( r'([e0-9\.-]+)\s+\(([e0-9\.-]+)\)' )

# The MD5 block size, optimized for the file system block size (8 * 4k).
MD5_BLOCKSIZE = 33024

# Default value if the MD5 could not be calculated. Any default is good,
# this one is at least informative in the human-readable text diffs.
MD5_DEFAULT = 'MD5'

# Image compare tolerance, in absolute values. It should be high enough to pass
# tolerance for subtle changes like vertex positions being 0.01% different, or
# lights positioned slightly higher or lower within tolerance, but low enough
# for small but important position or colour changes to register.
#
# This number was heuristically determined by examining the differences
# between existing images that were deemed close enough. For comparison
# the FUZZ metric has a value of 65535 when comparing an all-black against
# an all-white image.
IMAGEMAGICK_MATCH_TOLERANCE = 500
IMAGEMAGICK_METRIC = 'FUZZ'

# Image compare tolerance for percentage of differing pixels in imf_diff.
# This is a cruder measurement than ImageMagick, which is why the former is
# given preference if available. The comparison is looking at the percentage
# of differing pixels that are at least the MIN_DIFFERENCE apart in colour.
# The MIN_DIFFERENCE tolerance handles small differences in shading, the
# MATCH_TOLERANCE will help detect shifts in object position or orientation.
IMF_DIFF_MATCH_TOLERANCE = 1.0
IMF_DIFF_MIN_DIFFERENCE = '5'

# Special placeholder names for plugs when reporting image differences
SCREENSHOT_NODE     = '__screenShot__'
# This plug reports the two differing MD5 values
SCREENSHOT_PLUG_MD5 = '%s.md5' % SCREENSHOT_NODE
# This plug reports the two (MD5,ImageMagick comparison) values separated by a vertical bar '|'
SCREENSHOT_PLUG_MAG = '%s.mag' % SCREENSHOT_NODE
# This plug reports the two (MD5,imf_diff comparison) values separated by a vertical bar '|'
SCREENSHOT_PLUG_IMF = '%s.imf' % SCREENSHOT_NODE

# Setup modes when analyzing scenes in EM modes
EMCORRECTNESS_NO_SETUP        = 0 # Do nothing, just run playback
EMCORRECTNESS_DOUBLE_PLAYBACK = 1 # Run playback twice to ensure graph is valid
EMCORRECTNESS_INVALIDATE      = 2 # Invalidate the graph to force rebuild

# Constant indicating that values are completely equal
ALL_SIGNIFICANT_DIGITS_MATCH = 999
# Constant indicating that values are completely unequal
NO_SIGNIFICANT_DIGITS_MATCH = 0
# Number of significant digits to match for regular values
SIGNIFICANT_DIGITS = 1.9
# Number of significant digits to match for inverse matrix values (they are less accurate)
SIGNIFICANT_DIGITS_INVERSE = 0.9

#======================================================================

def __hasEvaluationManager():
    """
    Check to see if the evaluation manager is available
    """
    return 'evaluationManager' in dir(cmds)

#======================================================================

def __isMayaFile(path):
    """
    Check to see if the given path is a Maya file. Only looks for native Maya
    files ".ma" and ".mb", not other importable formats such as ".obj" or ".dxf"
    """
    return os.path.isfile(path) and ((path[-3:] == '.ma') or (path[-3:] == '.mb'))

#======================================================================

def _playback(maxFrames=EMCORRECTNESS_MAX_FRAMECOUNT):
    """
    Run a playback sequence, starting at the first frame and going to
    the maxFrame requested.

    The only reason this is a separate method is so that the number of
    frames being played can be capped.
    """
    startFrame = cmds.playbackOptions( query=True, minTime=True )
    oldEndFrame = cmds.playbackOptions( query=True, maxTime=True )
    oldLoopType = cmds.playbackOptions( query=True, loop=True )
    oldFps = cmds.playbackOptions( query=True, fps=True )
    cmds.playbackOptions( loop='once' )
    cmds.playbackOptions( fps=0 )
    endFrame = oldEndFrame

    # If you have a scene with hugely long playback you don't want to be
    # waiting forever for the runs so limit the frame length to something
    # reasonable. (Or this could be recoded to make this an option.)
    if maxFrames > 0 and oldEndFrame - startFrame >= maxFrames:
        endFrame = startFrame + maxFrames - 1

    cmds.playbackOptions( maxTime=endFrame )
    cmds.currentTime( cmds.playbackOptions(query=True, minTime=True) )
    cmds.play( wait=True )
    cmds.playbackOptions( maxTime=oldEndFrame )
    cmds.playbackOptions( loop=oldLoopType )
    cmds.playbackOptions( fps=oldFps )

#======================================================================
def __findEmPlugs( emPlugs ):
    """
    Find all of the root level plugs that the EM will be marking
    dirty. The passed-in dictionary will be populated by a list of
    dictionaries.

    emPlugs[NODE] = {DIRTY_PLUG_IN_NODE:True}
    """
    for nodeLine in cmds.dbpeek( op='graph', all=True, a=['evaluationGraph','plugs'] ).split('\n'):
        try:
            (_, plug) = nodeLine.split('\t')
            (node, attribute) = plug.split('.')
            if node in emPlugs:
                emPlugs[node][attribute] = True
            else:
                emPlugs[node] = {attribute:True}
        except Exception:
            # Skip lines that cannot be processed
            pass

#======================================================================
class DGState(object):
    """
    State object containing all data values that come out of the dbpeek
    command using the 'data' operation for simple data values and the
    dbpeek 'mesh' operation for mesh geometry.

    resultsFiles:    Where the intermediate results are stored. None means don't store them.
    imageFile:        Where the screenshot is stored. None means don't store it.
    state:            Data state information from the scene.
    """
    RE_INVERSE_MATRIX = 'InverseMatrix'

    def __init__(self, resultsFile=None, imageFile=None, doEval=False, dataTypes=None):
        """
        Create a new state object, potentially saving results offline if
        requested.

        resultsFile : Name of file in which to save the results.
                      Do not save anything if None.
        imageFile   : Name of file in which to save the current viewport screenshot.
                      Do not save anything if None.
        doEval      : True means force evaluation of the plugs before checking
                      state. Used in DG mode since not all outputs used for
                      (e.g.) drawing will be in the datablock after evaluation.
        dataTypes   : Type of data to look for - {mesh, vertex, number, screen}
                      If screen is in the list the 'imageFile' argument must also be specified.
        """
        self.md5Value = MD5_DEFAULT
        self.resultsFile = resultsFile
        self.imageFile = imageFile
        dataArgs = []
        meshArgs = ['vertex','verbose']
        if doEval:
            dataArgs += ['eval']
            meshArgs += ['eval']
        if 'number' in dataTypes:
            dataArgs += ['number']
        if 'matrix' in dataTypes:
            dataArgs += ['matrix']

        # The two dbpeek operations both generate CSV data with similar
        # formatting (PLUG,#,#,#...) so a simple join is good enough.
        #
        # More complex data might warrant a more complex algorithm
        # such as splitting the state data into separate objects and
        # comparing them that way.
        #
        # The "[1:]" is to skip the title lines since those are irrelevant.
        #
        self.state = [line for line in cmds.dbpeek( op='data', a=dataArgs, all=True).strip().split('\n')
                        if line != '\n'][1:]
        if 'mesh' in dataTypes:
            self.state += [line for line in cmds.dbpeek( op='mesh', a=meshArgs, all=True).strip().split('\n')
                            if line != '\n'][1:]

        if resultsFile != None:
            try:
                rfHandle = open(resultsFile, 'w')
                for line in sorted(self.state):
                    if line != '\n':
                        rfHandle.write( '%s\n' % line )
                rfHandle.close()
            except Exception, ex:
                print 'ERROR: Could not write to results file %s: "%s"' % (resultsFile, str(ex))

        if imageFile != None:
            # Turn off all HUDS for the snapshot since we're only concerned
            # with correct evaluation here
            isViewcubeVisible = cmds.viewManip( query=True, visible=True )
            visibleHUD = [hud for hud in cmds.headsUpDisplay( listHeadsUpDisplays=True )
                if cmds.headsUpDisplay( hud, query=True, vis=True )]
            for hud in visibleHUD:
                cmds.headsUpDisplay( hud, edit=True, vis=False )
            cmds.viewManip( visible=False )

            cmds.refresh( currentView=True, fileExtension='png', filename=imageFile )

            # Restore the HUDs that were turned off
            for hud in visibleHUD:
                cmds.headsUpDisplay( hud, edit=True, vis=True )
            if isViewcubeVisible:
                cmds.viewManip( visible=True )

    #----------------------------------------------------------------------
    @staticmethod
    def __executable(programName):
        """
        Returns the name of an executable given the program name.
        Mostly done to add the .exe for Windows programs.
        """
        if sys.platform.startswith('win32') or sys.platform.startswith('cygwin'):
            return '%s.exe' % programName

        return programName

    #----------------------------------------------------------------------
    @staticmethod
    def __closeness(firstNum, secondNum):
        """
        Returns measure of equality (for two floats), in unit
        of decimal significant figures.
        """
        # Identical results are obviously equal
        if firstNum == secondNum:
            return float('infinity')

        # Arbitrarily pick two near-zero values for rounding.
        # This avoids the instability of the log10 method when near zero.
        if abs(firstNum) < 1e-4 and abs(secondNum) < 1e-4:
            return float('infinity')

        # Standard numerical closeness check, the logarithmic
        # difference of the average divided by the difference gives
        # the number of significant digits they have in common.
        difference = abs(firstNum - secondNum)
        avg = abs(firstNum + secondNum)/2
        return math.log10( avg / difference )

    #----------------------------------------------------------------------
    def __compareListOfFloats(self, floatList1, floatList2):
        """
        Compare two space-separated lists of floating point numbers.
        Return True if they are the same, False if they differ.

        floatList1:        First list of floats
        floatList1:        Second list of floats

        Returns the worst match, in significant digits (0 means no match at all).
        """
        if floatList1 == floatList2:
            return ALL_SIGNIFICANT_DIGITS_MATCH

        worstMatch = ALL_SIGNIFICANT_DIGITS_MATCH

        # Values are not trivially equal so compare numerically.
        floatList1Values = floatList1.split(' ')
        floatList2Values = floatList2.split(' ')

        # Obviously if the float Lists have different lengths they are different
        if len(floatList1Values) != len(floatList2Values):
            return NO_SIGNIFICANT_DIGITS_MATCH

        for floatEl in range(len(floatList1Values)):
            try:
                tolerance = self.__closeness(float(floatList1Values[floatEl])
                                           , float(floatList2Values[floatEl]))
                if tolerance < worstMatch:
                    worstMatch = tolerance
            except ValueError:
                # This indicates non-numerical values in the float list. Since
                # they are undefined they can be assumed to be different.
                return NO_SIGNIFICANT_DIGITS_MATCH

        return worstMatch

    #----------------------------------------------------------------------
    def filterState(self, plugFilter):
        """
        Take the current state information and filter out all of the plugs
        not on the plugFilter list. This is used to restrict the output to
        the set of plugs the EM is evaluating.

        plugFilter: Dictionary of nodes whose values are dictionaries of
                    root level attributes that are to be used for the
                    purpose of the comparison.

                    None means no filter, i.e. accept all plugs.
        """
        newState = []
        for line in self.state:
            try:
                columnValues = line.split(',')
                node = columnValues[0]
                attribute = columnValues[1]
                if plugFilter:
                    try:
                        if node not in plugFilter:
                            continue
                        attribute = RE_ROOT_ATTRIBUTE.match(attribute).group(1)
                        if attribute not in plugFilter[node]:
                            continue
                    except KeyError:
                        # If members aren't in the dictionaries then they are acceptable.
                        pass
                newState.append( line )
            except IndexError:
                print 'ERROR: dbpeek line not could not be parsed: "%s"' % line
        self.state = newState

    #----------------------------------------------------------------------
    def getMD5(self):
        """
        Get the MD5 checksum from the image file, if it exists.
        Return '' if the image file wasn't generated for an easy match.
        """
        try:
            if self.imageFile:
                md5Generator = hashlib.md5()
                checksumFd = open(self.imageFile,'rb')
                for chunk in iter(lambda: checksumFd.read(MD5_BLOCKSIZE), b''):
                    md5Generator.update(chunk)
                checksumFd.close()
                self.md5Value = md5Generator.hexdigest()
        except Exception:
            # If the file could not be read then it may not have been written.
            # Give it the default MD5 value
            self.md5Value = MD5_DEFAULT

        return self.md5Value

    #----------------------------------------------------------------------
    def __compareWithImageMagick( self, other ):
        """
        Compare the images generated as screenshots using the ImageMagick
        'compare' utility.

        Returns either None if a comparison was not made or the images matched,
        or this CSV difference string if the images were different:

              __screenShot__.mag,ORIG_MD5|ABSOLUTE_DIFF,OTHER_MD5|NORMALIZED_DIFF

        Both absolute and normalized differences are dumped even though only
        the normalized difference is used for the match.
        """
        try:
            compare = self.__executable( 'compare' )
            imageCompareOutput = subprocess.Popen(
                                    [ compare
                                    , '-metric', IMAGEMAGICK_METRIC
                                    , self.imageFile
                                    , other.imageFile
                                    , 'null:'
                                    ]
                                    , stdin=subprocess.PIPE
                                    , stderr=subprocess.PIPE
                                    , stdout=subprocess.PIPE).communicate()

            # Return value, if successfully run, will be in this format:
            #
            #     ABS_ERROR (NORMALIZED_ERROR)
            #
            # Experimental comparisons have determined that the normalized
            # error is the best to compare and IMAGEMAGICK_MATCH_TOLERANCE
            # is used as a tolerance value for it.

            compareMatch = RE_IMG_COMPARE.match( imageCompareOutput[1] )
            if compareMatch:
                # If the images are not within the given tolerance then return them as failures.
                if float(compareMatch.group(1)) > IMAGEMAGICK_MATCH_TOLERANCE:
                    return '%s,%s|%s,%s|%s,%d' % ( SCREENSHOT_PLUG_MAG
                                                 , self.md5Value,  compareMatch.group(1)
                                                 , other.md5Value, compareMatch.group(2)
                                                 , NO_SIGNIFICANT_DIGITS_MATCH )
                else:
                    # Mark success by returning an empty string
                    return ''
            else:
                # If stderr had a message then there is some problem
                # with the comparison so print it out for examination and
                # try another comparison method.
                print 'ERROR: ImageMagick generated the error %s' % imageCompareOutput[1]
        except Exception, ex:
            print 'WARNING: ImageMagick compare could not be run : "%s"' % str(ex)

        # Mark failure to run by returning None
        return None

    #----------------------------------------------------------------------
    def __compareWithImfDiff( self, other ):
        """
        Compare the images generated as screenshots using the Maya MentalRay
        'imf_diff' utility.

        Returns either None if a comparison was not made or the images matched,
        or this CSV difference string if the images were different:

              __screenShot__.imf,ORIG_MD5|PERCENT_DIFF,OTHER_MD5|TOTAL_DIFF/TOTAL_PIXELS
        """
        try:
            imfDiff = self.__executable( os.path.join( os.getenv('MENTALRAY_BIN_LOCATION'), 'imf_diff' ) )
            imageCompareOutput = subprocess.Popen(
                                      [ imfDiff
                                      , '-m', IMF_DIFF_MIN_DIFFERENCE
                                      , self.imageFile
                                      , other.imageFile
                                      ]
                                      , stdin=subprocess.PIPE
                                      , stderr=subprocess.PIPE
                                      , stdout=subprocess.PIPE).communicate()

            # The output if the images are identical, which only happens when
            # all pixels are within IMF_DIFF_MIN_DIFFERENCE, looks like this:
            #
            #   Image1.png Image1.png: no differences.
            #   == "Image1.png" and "Image1.png" are identical
            #
            if RE_IMF_IDENTICAL.match( ''.join(imageCompareOutput) ):
                return ''

            # If the images are different the output looks like this:
            #
            #   differing pixels:	  2.755% (30075 of 1091574)
            #   average difference:	 33.546%
            #   maximum difference:	 54.112%
            #   Summary: Some pixels differ strongly.
            #   == "Image1.png" and "Image2.png" are different
            #
            # The words "strongly" and "are different" may vary based on
            # tolerance values found but only the numbers are processed
            # anyway. The differing pixels percentage is the one being
            # compared - values above 1% are considered bad. Average and
            # maximum differences don't mean that much in this context so
            # they are ignored.
            #
            compareMatch = RE_IMF_COMPARE.match( ''.join(imageCompareOutput) )
            if compareMatch:
                if float(compareMatch.group(1)) > IMF_DIFF_MATCH_TOLERANCE:
                    return '%s,%s|%s,%s|%s/%s,%d' % ( SCREENSHOT_PLUG_IMF
                                                    , self.md5Value,  compareMatch.group(1)
                                                    , other.md5Value, compareMatch.group(2), compareMatch.group(3)
                                                    , NO_SIGNIFICANT_DIGITS_MATCH )
                else:
                    # Mark success by returning an empty string
                    return ''
        except Exception, ex:
            print 'WARNING: imf_diff could not be run : "%s"' % str(ex)

        # Mark failure to run by returning None
        return None

    #----------------------------------------------------------------------
    def __compareImages(self, other):
        """
        Compare the images generated as screenshots for the two evaluation
        methods. The exact comparison method will depend on what is available
        on the system running this test.

        The cascading levels of comparison are:
            1. Generate MD5 values for both files. If equal the images are identical.
            2. Try the ImageMagick 'compare' utility and check for a tolerance:
                  compare -metric MAW IMAGE1 IMAGE2 null:
            3. If ImageMagick was not present try the imf_diff utility that ships with Maya:

        If the ImageMagick library is not present then the imf_diff utility
        shipped with Maya will be used to generate  a comparison. If that
        utility cannot be accessed then the MD5 output below will be returned
        as a difference must be assumed since false positives are better than
        false negatives.

              __screenShot__.md5,ORIG_MD5,OTHER_MD5

        If the files were identical or a comparison could not be made return None.
        If one of the image comparisons returned a difference return that.
        Otherwise return the MD5 difference string.
        """
        if not self.imageFile or not other.imageFile:
            return None

        try:
            selfMD5 = self.getMD5()
            otherMD5  = other.getMD5()

            # Quick success, the files are identical
            if selfMD5 == otherMD5:
                return None

        except Exception, ex:
            print 'WARNING: Could not generate MD5 values for image comparison : "%s"' % str(ex)
            selfMD5 = MD5_DEFAULT
            otherMD5 = MD5_DEFAULT

        # MD5 differs but the files may be "close enough". Run the image
        # comparison utilities to find out how close they are.
        #
        # The return value "None" indicates the comparitor failed, the
        # empty string indicates the images were the same and any other
        # string contains the difference information.
        #
        # First try ImageMagick
        imageDiff = self.__compareWithImageMagick( other )
        if imageDiff != None:
            return imageDiff if len(imageDiff)>0 else None

        # Next try the imf_diff utility
        imageDiff = self.__compareWithImfDiff( other )
        if imageDiff != None:
            return imageDiff if len(imageDiff)>0 else None

        # If none of the image comparators generated a useful result then
        # default back to the MD5 value as comparison.
        return '%s,%s,%s,%g' % (SCREENSHOT_PLUG_MD5, selfMD5, otherMD5, NO_SIGNIFICANT_DIGITS_MATCH)

    #----------------------------------------------------------------------
    def compare(self, other, verbose):
        """
        Compare two state information collections and return a count of the
        number of differences. The first two fields (node,plug) are used to
        uniquely identify the line so that we are sure we are comparing the
        same two things.

        The 'clean' flag in column 2 is omitted from the comparison since
        the DG does funny things with the flag to maintain the holder/writer
        states of the data.

        other:      Other DGstate to compare against
        verbose:    If True then print the differences as they are found

        If verbose is False return the 3-tuple of integers (additionCount, changeCount, removalCount)
        If verbose is True return the 3-tuple of lists (additions, changes, removals)
        """
        selfValues = {}
        otherValues = {}
        for line in self.state:
            try:
                columnValues = line.split(',')
                selfValues['%s.%s' % (columnValues[0],columnValues[1])] = ' '.join(columnValues[3:])
            except IndexError:
                print 'ERROR: dbpeek line not could not be parsed: "%s"' % line
        for line in other.state:
            try:
                columnValues = line.split(',')
                otherValues['%s.%s' % (columnValues[0],columnValues[1])] = ' '.join(columnValues[3:])
            except IndexError:
                print 'ERROR: dbpeek line could not be parsed: "%s"' % line
        changedValues = []

        worstMatch = ALL_SIGNIFICANT_DIGITS_MATCH

        # Find changed values and values in the original version but not in the new one
        for (name,value) in selfValues.iteritems():
            if name in otherValues:
                # The inverse matrix attribute calculations are less accurate
                # so be more lenient with them.
                if name.find(DGState.RE_INVERSE_MATRIX) >= 0:
                    significantDigits = SIGNIFICANT_DIGITS_INVERSE
                else:
                    significantDigits = SIGNIFICANT_DIGITS
                matchDigits = self.__compareListOfFloats(value, otherValues[name])
                if matchDigits < significantDigits:
                    changedValues.append( '%s,%s,%s,%s' % (name, value, otherValues[name], matchDigits) )
                if matchDigits < worstMatch:
                    worstMatch = matchDigits

        # If image files are present run a comparison on them too
        #
        imageCompare = self.__compareImages( other )
        if imageCompare:
            changedValues.append( imageCompare )

        if verbose:
            return changedValues
        else:
            return len(changedValues)

#======================================================================

def emCorrectnessTest( fileName=None
                     , resultsPath=None
                     , verbose=False
                     , modes=['ems']
                     , maxFrames=EMCORRECTNESS_MAX_FRAMECOUNT
                     , dataTypes=['matrix','vertex','screen']
                     , emSetup=EMCORRECTNESS_NO_SETUP ):
    """
    Evaluate the file in multiple modes and compare the results.

    fileName:    Name of file to load for comparison. None means use the current scene
    resultsPath: Where to store the results. None means don't store anything
    verbose:     If True then dump the differing values when they are encountered
    modes:       List of modes to run the tests in. 'ems' and 'emp' are the
                 only valid ones. A mode can optionally enable or disable an
                 evaluator as follows:
                     'ems+deformer': Run in EM Serial mode with the deformer evalutor turned on
                     'emp-dynamics': Run in EM Parallel mode with the dynamics evalutor turned off
                     'ems+deformer-dynamics': Run in EM Serial mode with the dynamics evalutor
                                              turned off and the deformer evaluator turned on
    maxFrames:   Maximum number of frames in the playback, to avoid long tests.
    dataTypes:   List of data types to include in the analysis. These are the possibilities:
                 matrix: Any attribute that returns a matrix
                 vertex: Attributes on the mesh shape that hold vertex positions
                 number: Any attribute that returns a number
                 screen: Screenshot after the animation runs
    emSetup:     What to do before running an EM mode test
                 EMCORRECTNESS_NO_SETUP        Do nothing, just run playback
                 EMCORRECTNESS_DOUBLE_PLAYBACK Run playback twice to ensure graph is valid
                 EMCORRECTNESS_INVALIDATE      Invalidate the graph to force rebuild

    Returns a list of value tuples indicating the run mode and the number of
    (additions,changes,removals) encountered in that mode. e.g. ['ems', (0,0,0)]

    If verbose is true then instead of counts return a list of actual changes.
    e.g. ['ems', ([], ["plug1,oldValue,newValue"], [])]

    Changed values are a CSV 3-tuple with "plug name", "value in DG mode", "value in the named EM mode"
    in most cases.

    In the special case of an image difference the plug name will be one
    of the special ones below and the values will be those generated by the
    comparison method used:
        SCREENSHOT_PLUG_MD5 : MD5 values when the image compare could not be done
        SCREENSHOT_PLUG_MAG : MD5 and image difference values from ImageMagick
        SCREENSHOT_PLUG_IMF : MD5 and image difference values from imf_diff
    """
    # Fail if the fileName is not a valid Maya file.
    if fileName != None and not __isMayaFile(fileName):
        print 'ERROR: %s is not a Maya file' % fileName
        return []

    # Load the fileName if it was specified, otherwise the current scene will be tested
    if fileName != None:
        cmds.file( fileName, force=True, open=True )

    dgResults = None
    dgResultsImage = None

    # Using lists allows me to do a comparison of two identical modes.
    # If resultsPath is given then the second and successive uses of the
    # same type will go into files with an incrementing suffix (X.dg.txt,
    # X.dg1.txt, X.dg2.txt...)
    modeResultsFiles = []
    modeResultsImageFiles = []
    results = []
    emPlugFileName = None

    # Create a list of unique mode suffixes, appending a count number whenever
    # the same mode appears more than once on the modes list.
    modeCounts = {}
    uniqueModes = []
    modeCounts['dg'] = 1
    for mode in modes:
        modeCounts[mode] = modeCounts.get(mode,0) + 1
        suffix = ''
        if modeCounts[mode] > 1:
            suffix = str(modeCounts[mode])
        uniqueModes.append( '%s%s' % (mode, suffix) )

    if resultsPath != None:
        # Make sure the path exists
        if not os.path.isdir(resultsPath):
            os.makedirs( resultsPath )

        emPlugFileName = os.path.join(resultsPath, 'EMPlugs.txt')

        # Build the rest of the paths to the results files.
        # If no file was given default the results file prefix to "SCENE".
        if fileName != None:
            # Absolute paths cannot be appended to the results path. Assume
            # that in those cases just using the base name is sufficient.
            if os.path.isabs(fileName):
                resultsPath = os.path.join(resultsPath, os.path.basename(fileName))
            else:
                resultsPath = os.path.join(resultsPath, fileName)
        else:
            resultsPath = os.path.join(resultsPath, 'SCENE')

        dgResults = '%s.dg.txt' % resultsPath
        modeCounts['dg'] = 1

        for mode in uniqueModes:
            modeResultsFiles.append( '%s.%s.txt' % (resultsPath, mode) )
    else:
        # Still need the file args to pass in to DGState. None = don't output.
        for mode in modes:
            modeResultsFiles.append( None )

    # If the image comparison was requested figure out where to store the
    # file. Done separately because even if the files won't be saved the image
    # comparison needs to dump a file out for comparison.
    if 'screen' in dataTypes:
        if resultsPath == None:
            imageDir = tempfile.gettempdir()
            if fileName != None:
                # Absolute paths cannot be appended to the results path. Assume
                # that in those cases just using the base name is sufficient.
                if os.path.isabs(fileName):
                    imageDir = os.path.join(imageDir, os.path.basename(fileName))
                else:
                    imageDir = os.path.join(imageDir, fileName)
            else:
                imageDir = os.path.join(imageDir, 'SCENE')
        else:
            imageDir = resultsPath

        dgResultsImage = '%s.dg.png' % imageDir
        for mode in uniqueModes:
            modeResultsImageFiles.append( '%s.%s.png' % (imageDir, mode) )
    else:
        dgResultsImage = None
        for mode in uniqueModes:
            modeResultsImageFiles.append( None )

    # Fail if evaluation manager is not available. Should never happen.
    if not __hasEvaluationManager():
        print 'ERROR: Evaluation manager is not available.'
        return None

    emPlugs = None
    comparisons = {}
    # Record the DG evaluation version of the results
    with emModeManager() as modeMgr:
        modeMgr.setMode('dg')
        _playback(maxFrames)
        mDG = DGState(dgResults, dgResultsImage, doEval=True, dataTypes=dataTypes)

        # Walk all of the modes requested and run the tests for them
        for modeNum in range(len(modes)):
            modeMgr.setMode(modes[modeNum])
            if emSetup == EMCORRECTNESS_DOUBLE_PLAYBACK:
                _playback(maxFrames)
            elif emSetup == EMCORRECTNESS_INVALIDATE:
                cmds.evaluationManager( invalidate=True )
            _playback(maxFrames)
            if emPlugs == None:
                emPlugs = {}
                __findEmPlugs( emPlugs )
                mDG.filterState( emPlugs )
                if emPlugFileName:
                    try:
                        emHandle = open(emPlugFileName, 'w')
                        for (node,plugList) in emPlugs.iteritems():
                            emHandle.write( '%s\n' % node )
                            for plug in plugList.keys():
                                emHandle.write( '\t%s\n' % plug )
                        emHandle.close()
                    except Exception, ex:
                        print 'ERROR: Could not write to EM plug file %s: "%s"' % (emPlugFileName, str(ex))
            results.append( DGState( modeResultsFiles[modeNum], modeResultsImageFiles[modeNum]
                                   , doEval=False, dataTypes=dataTypes) )
            results[modeNum].filterState( emPlugs )
            comparisons[modes[modeNum]] = mDG.compare( results[modeNum], verbose=verbose )

            TODO( 'REFACTOR', 'Remove the unused first and third values once QATA is modified to accept it', 'MAYA-45714' )
            if verbose:
                comparisons[modes[modeNum]] = ([],comparisons[modes[modeNum]],[])
            else:
                comparisons[modes[modeNum]] = (0,comparisons[modes[modeNum]],0)

    # Force restoration of EM state by leaving scope

    return comparisons

# Copyright (C) 1997-2014 Autodesk, Inc., and/or its licensors.
# All rights reserved.
#
# The coded instructions, statements, computer programs, and/or related
# material (collectively the "Data") in these files contain unpublished
# information proprietary to Autodesk, Inc. ("Autodesk") and/or its licensors,
# which is protected by U.S. and Canadian federal copyright law and by
# international treaties.
#
# The Data is provided for use exclusively by You. You have the right to use,
# modify, and incorporate this Data into other products for purposes authorized 
# by the Autodesk software license agreement, without fee.
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND. AUTODESK
# DOES NOT MAKE AND HEREBY DISCLAIMS ANY EXPRESS OR IMPLIED WARRANTIES
# INCLUDING, BUT NOT LIMITED TO, THE WARRANTIES OF NON-INFRINGEMENT,
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE, OR ARISING FROM A COURSE 
# OF DEALING, USAGE, OR TRADE PRACTICE. IN NO EVENT WILL AUTODESK AND/OR ITS
# LICENSORS BE LIABLE FOR ANY LOST REVENUES, DATA, OR PROFITS, OR SPECIAL,
# DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES, EVEN IF AUTODESK AND/OR ITS
# LICENSORS HAS BEEN ADVISED OF THE POSSIBILITY OR PROBABILITY OF SUCH DAMAGES.

