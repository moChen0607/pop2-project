import re
import math
import maya.cmds
from .BaseAnalytic import BaseAnalytic
from .decorators import addMethodDocs,addHelp,makeAnalytic

reMultiGeometryOutput = re.compile('\[([0-9]+)\]')

@addMethodDocs
@addHelp
@makeAnalytic
class analyticMesh(BaseAnalytic):
	"""
	Analyze the volume and distribution of mesh data.
	"""
        @classmethod
	def __traceMeshOrigin(cls, meshNode, cameFromOutput):
		"""
		The listHistory command doesn't differentiate between geometry history
		and other history, such as matrix data. This method recursively looks
		backwards through a mesh history using knowledge of the types of nodes
		that can generate or influence meshes (mesh operators, deformers, mesh
		creation, etc.)

		Recursion stops when either no further relevant inputs are found to
		the current node being checked or if the node type is not one of the
		recognized ones.
		"""
		nodeTypes = maya.cmds.nodeType(meshNode, inherited=True)
		inputAttribute = None
		if 'mesh' in nodeTypes:
			# This is a mesh shape, inputs come through .inMesh
			inputAttribute = 'inMesh'
		elif 'geometryFilter' in nodeTypes:
			# This is a deformer inputs come from .input[x].inputGeometry
			# Use the output attribute to find the matching index "x"
			match = reMultiGeometryOutput.search( cameFromOutput )
			if match:
				inputAttribute = 'input[%s].inputGeometry' % match.group(1)
			else:
				# Unrecognized output, we have to bail
				return meshNode
		elif 'polyModifier' in nodeTypes:
			# This is a polyOperation, inputs come from .inputPolymesh
			inputAttribute = 'inputPolymesh'
		elif 'groupParts' in nodeTypes:
			# This is a groupParts node, inputs come from .inputGeometry
			inputAttribute = 'inputGeometry'
		elif 'inputGeometry' in maya.cmds.listAttributes(meshNode):
			# Some other type of geometry history that's not part of the
			# polyModifier hierarchy, e.g. deleteComponents
			inputAttribute = 'inputGeometry'
		else:
			# Don't recognize this type
			print 'Warning: Stopping at unrecognized node type %s' % meshNode
			return meshNode

		try:
			stepBack = maya.cmds.listConnections( '%s.%s' % (meshNode, inputAttribute), plugs=True, source=True )[0].split('.')
			origin = cls.__traceMeshOrigin( stepBack[0], stepBack[1] )
			return origin
		except Exception, e:
			# No connection means no source, we're at the end
			return meshNode

	def run(self, showDetails=False):
		"""
		Scan all of the Mesh shapes in the scene and provide a column for
		each node with the following statistics in it:
			- Number of vertices in the mesh
			- Number of faces in the mesh
			- Number of edges in the mesh
			- Number of triangles in the mesh
			- Number of UV coordinates in the mesh
			- Number of vertices "tweaked"
			- Is it using user normals?
			- What is the source node for the mesh? For meshes with no
			  construction history it will be the mesh itself. For others
			  it could be a polySphere or other creation operation, or some
			  other mesh at the beginning of a deformation chain. When
			  'showDetails' is off the nodeType is shown for non-meshes and
			  the generated name proxy is show for meshes.

		If you set the 'showDetails' argument to True then the names of the
		actual nodes in the scene will be used in the output. Otherwise the
		node names will be replaced by a generic name 'NODETYPEXXX' where
		'NODETYPE' is the type of node being reported (e.g. 'mesh') and 'XXX'
		is a unique index per node type.  (An appropriate number of leading
		'0's will be added so that all names are of the same length
		for easier reading.)
		"""
		try:
			if not self._open():
				return

			self._outputCSV( ['Node',
							  'Vertices',
							  'Edges',
							  'Faces',
							  'Triangles',
							  'UV Coordinates',
							  'Tweaks',
							  'User Normals',
							  'Source'] )

			meshList = maya.cmds.ls( type='mesh' )
			if len(meshList) == 0:
				print 'Warning: No meshes, no mesh data to collect'
				return

			for mesh in meshList:
				meshName = self._sanitizedNodeName( mesh, showDetails )

				vertexCount = maya.cmds.polyEvaluate( mesh, vertex=True )
				edgeCount = maya.cmds.polyEvaluate( mesh, edge=True )
				faceCount = maya.cmds.polyEvaluate( mesh, face=True )
				triangleCount = maya.cmds.polyEvaluate( mesh, triangle=True )
				uvCount = maya.cmds.polyEvaluate( mesh, uvcoord=True )
				tweakCount = maya.cmds.getAttr( '%s.pnts' % mesh, size=True )
				meshSource = self._sanitizedNodeName( analyticMesh.__traceMeshOrigin( mesh, None ), showDetails )

				if maya.cmds.getAttr( '%s.normals' % mesh, size=True ) > 0:
					userNormals = True
				else:
					userNormals = False

				self._outputCSV( [ meshName
								 , vertexCount
								 , edgeCount
								 , faceCount
								 , triangleCount
								 , uvCount
								 , tweakCount
								 , userNormals
								 , meshSource
								  ] )

		except Exception, ex:
			print 'Analytic failed: "%s"' % str(ex)
		finally:
			self._close()

# Copyright (C) 1997-2014 Autodesk, Inc., and/or its licensors.
# All rights reserved.
#
# The coded instructions, statements, computer programs, and/or related
# material (collectively the "Data") in these files contain unpublished
# information proprietary to Autodesk, Inc. ("Autodesk") and/or its licensors,
# which is protected by U.S. and Canadian federal copyright law and by
# international treaties.
#
# The Data is provided for use exclusively by You. You have the right to use,
# modify, and incorporate this Data into other products for purposes authorized 
# by the Autodesk software license agreement, without fee.
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND. AUTODESK
# DOES NOT MAKE AND HEREBY DISCLAIMS ANY EXPRESS OR IMPLIED WARRANTIES
# INCLUDING, BUT NOT LIMITED TO, THE WARRANTIES OF NON-INFRINGEMENT,
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE, OR ARISING FROM A COURSE 
# OF DEALING, USAGE, OR TRADE PRACTICE. IN NO EVENT WILL AUTODESK AND/OR ITS
# LICENSORS BE LIABLE FOR ANY LOST REVENUES, DATA, OR PROFITS, OR SPECIAL,
# DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES, EVEN IF AUTODESK AND/OR ITS
# LICENSORS HAS BEEN ADVISED OF THE POSSIBILITY OR PROBABILITY OF SUCH DAMAGES.

