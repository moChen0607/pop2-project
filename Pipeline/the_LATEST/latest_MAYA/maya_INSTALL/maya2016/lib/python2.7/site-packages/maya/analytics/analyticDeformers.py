import re
import maya.cmds
from .BaseAnalytic import BaseAnalytic
from .decorators import addMethodDocs,addHelp,makeAnalytic

vtxPattern = re.compile( 'vtx\[([0-9]+)\]' )
vtxPairPattern = re.compile( 'vtx\[([0-9]+):([0-9]+)\]' )
vtxAllPattern = re.compile( 'vtx\[\*\]' )

@addMethodDocs
@addHelp
@makeAnalytic
class analyticDeformers(BaseAnalytic):
	"""
	Analyze type and usage of single deformers and deformer chains.
	"""
	def run(self, showDetails=False):
		"""
		Examine the meshes in the scene for deformation. There will be two
		types of data in the output file under the column headings
		'Deformer','Member','Value':
			- Deformer Name, Member Object, Membership Information, Member Count
				One line per object being affected by the deformer
			- Deformer Name, '', Name of next deformer in the chain, Deformer Chain length
				Only if more than one deformer is being applied to the same object

		If 'showDetails' is False then the Member Information is omitted,
		otherwise it will be a selection-list format of all members on that
		object subject to deformation by the given deformer.
		"""
		try:
			if not self._open():
				return

			self._outputCSV( [ 'Deformer'
							 , 'Member'
							 , 'Value'
							 , 'Count'
							 ] )

			meshList = maya.cmds.ls( type='mesh' )
			try:
				if len(meshList) == 0:
					print 'Warning: No meshes to check'
					return
			except Exception, ex:
				# If the 'ls' command returns None this is the easiest
				# way to trap that case.
				print 'Warning: No meshes to check'
				return

			# Tweak nodes are not considered deformations by themselves,
			# though in the node type hierarchy they are siblings to all other
			# deformers. This filters them out while collecting all deformers.
			try:
				deformers = [n for n in maya.cmds.ls( type='geometryFilter' ) if maya.cmds.nodeType(n) != 'tweak']
			except Exception, ex:
				print 'Warning: No deformers to check'
				return

			for mesh in meshList:
				history = maya.cmds.listHistory( mesh )
				deformerChain = []
				for historyNode in history:
					if historyNode in deformers:
						deformerChain.append( historyNode )

				if len(deformerChain) == 0:
					continue

				for deformer in deformerChain:

					# Default to the entire mesh being deformed
					componentCount = maya.cmds.polyEvaluate( mesh, vertex=True )
					componentList = ['vtx[*]']

					# Check for group parts selecting a portion of the surface
					groupPartList = []
					gpConnections = maya.cmds.listConnections( '%s.input' % deformer )
					if gpConnections != None:
						groupPartList = [gp for gp in gpConnections if maya.cmds.nodeType(gp) == 'groupParts']

					for groupParts in groupPartList:
						# Match up the group parts found with the mesh being checked.
						groupId = [gi for gi in maya.cmds.listConnections( '%s.groupId' % groupParts ) if maya.cmds.nodeType(gi) == 'groupId']
						if groupId != None:
							grouping = maya.cmds.listConnections( '%s.groupId' % groupId[0] )
							if mesh not in grouping:
								continue

						componentCount = 0
						componentList = maya.cmds.getAttr('%s.inputComponents' % groupParts)
						for component in componentList:
							# vtx[N]  single vertex N
							vtxMatch = vtxPattern.match( component )
							if vtxMatch:
								componentCount += 1
								continue
							# vtx[N:M]  range of vertices from N to M
							vtxPairMatch = vtxPattern.match( component )
							if vtxPairMatch:
								componentCount += (int(vtxPairMatch.group(2)) - int(vtxPairMatch.group(1)) + 1)
								continue
							# vtx[*]  all vertices in the object
							if vtxAllPattern.match( component ):
								componentCount = maya.cmds.polyEvaluate( mesh, vertex=True )
								continue
							print 'Warning: Unrecognized group parts component pattern %s' % component

					if showDetails:
						components = ' '.join( componentList )
					else:
						components = ''

					self._outputCSV( [ self._sanitizedNodeName(deformer, showDetails), self._sanitizedNodeName(mesh, showDetails, len(meshList)), components, componentCount ] )

				for i in range(0, len(deformerChain)-1):
					self._outputCSV( [ self._sanitizedNodeName(deformerChain[i], showDetails)
									 , ''
									 , self._sanitizedNodeName(deformerChain[i+1], showDetails)
									 , str(len(deformerChain))
									 ] )

		except Exception, ex:
			print 'Analytic failed: "%s"' % str(ex)
		finally:
			self._close()


# Copyright (C) 1997-2014 Autodesk, Inc., and/or its licensors.
# All rights reserved.
#
# The coded instructions, statements, computer programs, and/or related
# material (collectively the "Data") in these files contain unpublished
# information proprietary to Autodesk, Inc. ("Autodesk") and/or its licensors,
# which is protected by U.S. and Canadian federal copyright law and by
# international treaties.
#
# The Data is provided for use exclusively by You. You have the right to use,
# modify, and incorporate this Data into other products for purposes authorized 
# by the Autodesk software license agreement, without fee.
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND. AUTODESK
# DOES NOT MAKE AND HEREBY DISCLAIMS ANY EXPRESS OR IMPLIED WARRANTIES
# INCLUDING, BUT NOT LIMITED TO, THE WARRANTIES OF NON-INFRINGEMENT,
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE, OR ARISING FROM A COURSE 
# OF DEALING, USAGE, OR TRADE PRACTICE. IN NO EVENT WILL AUTODESK AND/OR ITS
# LICENSORS BE LIABLE FOR ANY LOST REVENUES, DATA, OR PROFITS, OR SPECIAL,
# DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES, EVEN IF AUTODESK AND/OR ITS
# LICENSORS HAS BEEN ADVISED OF THE POSSIBILITY OR PROBABILITY OF SUCH DAMAGES.

