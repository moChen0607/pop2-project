import os
import re
import math

__all__ = [ 'ObjectNamer' ]

class ObjectNamer(object):
	"""
	Utility object to remap object names onto something appropriate.
	The simplest mapping is to return the name itself. If that's all
	you are ever going to do then don't use this class.

	The main use for this class is to anonymize names that might be
	considered sensitive. The anonymizing mode will ensure that the
	real name always matches the same generated name, and will give
	some minimal information within the name itself. (e.g. a file
	name will be called file_001, a directory name might be called
	dir_031, and a Maya transform node could be called transform_042.

	If you know how many objects you will be naming you can call
	ObjectNamer.setMaxObjects(). This will guarantee that the formatting
	of the anonymized names can be lexically sorted correctly by using
	a zero-padded integer numbering system. This is useful because
	"file02" comes before "file10" but "file2" comes after it.

	The following anonymizer modes are supported:

		ObjectNamer( ObjectNamer.MODE_NAME )
			Names have no specific type. The are anonymized generically
				MySecretObject -> name01
		ObjectNamer( ObjectNamer.MODE_PLUG )
			Names are assumed to be Maya plug names. The node name part is
			anonymized but the attribute name is left as-is.
				MySecretNode.translateX -> node001.translateX
		ObjectNamer( ObjectNamer.MODE_NODE )
			Names are assumed to be Maya node names. The node name part is
			anonymized using the node type as a root if this module is
			executed inside of Maya, otherwise the generic 'node' is used.
				In Maya:	MySecretTransform -> transform001
				Standalone: MySecretTransform -> node001
		ObjectNamer( ObjectNamer.MODE_PATH )
			Names are assumed to be file paths. The first sections of the path
			are anonymized as directories, the final one is anonymized as a
			file. Paths with trailing separators (e.g. "/") are assumed to be
			directories. Paths are made into canonical form so all backslashes
			are replaced by forward slashes on Windows.
				root/parent/child/MySecretFile.ma -> dir1/dir2/dir3/file1.ma
				root/parent/child/MySecretDir/	-> dir1/dir2/dir3/dir4/

	Class members:
		nameType		: Naming method to use (MODE_NAME, MODE_PLUG, MODE_NODE, MODE_PATH)
		anonymous		: If True all names will be anonnymized, else used as-is
		hasMaya			: Is this running from inside the Maya command engine?
		nameFmt			: Formatting string for anonymous names - includes the proper
						  number of expected leading zeroes based on max object count
		anonymizedNames	: Directory of already assigned anonymous names (ORIGINAL : ANONYMOUS_NAME)
		uniqueID		: Directory of unique IDs to use for anonymizing.
						  Key is the type of object, value is the next unique ID for it.

		Usage:
			import ObjectNamer
			oNamer = ObjectNamer.ObjectNamer( ObjectNamer.MODE_NAME, anonymous=True )
			oNamer.setMaxObjects( 100 )
			print oNamer.name( "My Funky Thing" )
			# Result = "name_01"
			print oNamer.name( "Some Other Stuff" )
			# Result = "name_02"
			print oNamer.name( "My Funky Thing" )
			# Result = "name_01"
			noNamer = ObjectNamer.ObjectNamer( ObjectNamer.MODE_NAME, anonymous=False )
			print oNamer.name( "My Funky Thing" )
			# Result = "My Funky Thing"
	"""
	MODE_NAME = 0	# Rename simple strings. Everything is called "name_#"
	MODE_PLUG = 1	# Rename Maya plugs. The node name is anonymous, the attribute is not
	MODE_NODE = 2	# Rename Maya nodes. If Maya is present then it is used to
					#	get node type names as the unique prefix such as
					#	"transform_#" and "mesh_#". Otherwise the generic
					#	names "node_#" are generated.
	MODE_PATH = 3	# Rename file paths. Directories and file names are
					#	anonymized separately to something like "dir_1/dir_2/file_1"

	SEP_DRIVE		= ':'	# Separator between drive name and path on Windows
	SEP_NAMESPACE	= ':'	# Separator between namespace and the rest of the node
	SEP_NODE		= '\|'	# Separator between nodes at each level of the DAG
	SEP_UNDERWORLD	= '->'	# Separator between shape node and underworld
	SEP_ATTRIBUTE	= '\.'	# Separator between node name and attribute name in plug
	SEP_PATH		= '/'	# Separator between path directory elements

	#======================================================================
	def __init__(self, nameType, anonymous):
		"""
		Create a namer.
			nameType:  NODE_{NAME,PLUG,NODE,PATH}
			anonymous: True means don't use the original names, anonymize them
		"""
		self.nameType = nameType
		self.anonymous = anonymous
		self.hasMaya = True
		self.nameFmt = None
		self.anonymizedNames = {}
		self.uniqueID = {}
		self.hasMaya = 'maya.cmds' in globals()

		self.clear()

	#======================================================================
	def clear(self):
		"""
		Erase all of the currently remembered names. Resets the unique IDs
		back to the original. Names generated after a clear() may not be
		unique compared to names generated before the clear().
		"""
		self.nameFmt = '%s_%d'
		self.anonymizedNames = {}

		# Why use a dictionary here you ask? To make names more friendly.
		# When naming anonymous node types in Maya we want to increment
		# separate counters for each type. That way instead of this:
		#
		#	someTransform		=> transform_1
		#	someOtherTransform	=> transform_2
		#	someCamera			=> camera_3
		#
		# we get this:
		#
		#	someTransform		=> transform_1
		#	someOtherTransform	=> transform_2
		#	someCamera			=> camera_1
		#
		self.uniqueID = {}

	#======================================================================
	def setMaxObjects(self, maxObjects):
		"""
		Set the maximum number of objects expected to be named with this
		namer. This allows creation of a consistent number of leading
		zeroes on anonymized ID values for easy sorting.

		If maxObjects is 0 then use the %d format with no leading zeroes.
		"""
		if maxObjects <= 10:
			self.nameFmt = '%s_%d'
		else:
			self.nameFmt = '%%s_%%0%dd' % int(math.log(maxObjects-1,10)+1)

	#======================================================================
	def name(self, originalName):
		"""
		Get the name which corresponds to "originalName". In the case of
		non-anonymized names that will just be the original name.
		"""
		mappedName = originalName
		# Only alter the name if the anonymizer is enabled
		if self.anonymous:
			# If the name has already been anonymized used the same altered version
			if originalName in self.anonymizedNames:
				return self.anonymizedNames[originalName]

			if self.nameType == ObjectNamer.MODE_NAME:
				return self.__anonymizedName( originalName )

			if self.nameType == ObjectNamer.MODE_PLUG:
				return self.__anonymizedPlug( originalName )

			if self.nameType == ObjectNamer.MODE_NODE:
				return self.__anonymizedNode( originalName )

			if self.nameType == ObjectNamer.MODE_PATH:
				return self.__anonymizedPath( originalName )

			raise NameError('Unrecognized naming type: %d' % self.nameType)

		return mappedName

	#======================================================================
	def __nextUniqueID(self, forThisType):
		"""
		Get the next available unique ID for the given type of object.
		"""
		self.uniqueID[forThisType] = self.uniqueID.get(forThisType, -1) + 1
		return self.uniqueID[forThisType]

	#======================================================================
	def __anonymizedName(self, originalName):
		"""
		Return an anonymized version of the given name. Uses a base
		name of "name" and a unique ID with the appropriate number of
		digits.
		"""
		mappedName = self.nameFmt % ('name', self.__nextUniqueID('name'))
		self.anonymizedNames[originalName] = mappedName
		return mappedName

	#======================================================================
	def __anonymizedPlug(self, originalName):
		"""
		Return an anonymized version of the given plug name. When Maya is
		present the node portion of the name is anonymized with the type
		of node, otherwise the generic string "node" is used. The attribute
		portion is not anonymized.

		No attempt is made to ensure that the plug string itself is valid.
		"""
		if originalName in self.anonymizedNames:
			return self.anonymizedNames[originalName]

		try:
			(node,attribute) = re.split(ObjectNamer.SEP_ATTRIBUTE, originalName, 1)
		except ValueError:
			node = originalName
			attribute = None

		# I can use this as well since plug names and node names won't overlap
		# so the namespaces will not corrupt each other
		mappedName = self.__anonymizedNode( node )

		if attribute:
			# Avoid the '\' escape character for the prefix of SEP_ATTRIBUTE
			mappedName = '%s%s%s' % (mappedName, ObjectNamer.SEP_ATTRIBUTE[1], attribute)

		self.anonymizedNames[originalName] = mappedName

		return mappedName

	#======================================================================
	def __anonymizedNode(self, originalName):
		"""
		Return an anonymized version of the given node name. When Maya is
		present the node portion of the name is anonymized with the type
		of node, otherwise the generic string "node" is used.

		No attempt is made to ensure that the node string is valid.

		Like file paths the node paths could have partial matches so they
		are all checked along the way. (e.g. the two instances a|b|c1
		and a|b|c2 should both map their a|b portion to the same thing)

		Node format broken out is:
			[NAMESPACE:]*					Optional
				NODENAME					Mandatory
					[|NODENAME]*			Optional
						{->[UNDERWORLD]}	Optional
		"""
		if originalName in self.anonymizedNames:
			return self.anonymizedNames[originalName]

		#	[NAMESPACE:]*					Optional
		namespaces = re.split(ObjectNamer.SEP_NAMESPACE, originalName)
		if len(namespaces) == 1:
			namespaces = []
			nodepath = originalName
		else:
			nodepath = namespaces[-1]
			namespaces = namespaces[:-1]

		#	[|NODENAME]*			Optional
		instances = re.split(ObjectNamer.SEP_NODE, nodepath)
		if len(instances) == 1:
			instances = []
		else:
			nodepath = instances[-1]
			instances = instances[:-1]

		#	{->[UNDERWORLD]}	Optional
		underworlds = re.split(ObjectNamer.SEP_UNDERWORLD, nodepath)
		if len(underworlds) == 1:
			underworld = None
		else:
			# Treat the underworld as atomic, otherwise we could get into a big
			# mess of recursive checking
			nodepath = underworlds[0]
			underworld = ObjectNamer.SEP_UNDERWORLD.join(underworlds[1:])

		# Now that we've torn the name apart we can build it back up again,
		# piece by piece.
		mappedName = ''
		unmappedName = ''
		for namespace in namespaces:
			unmappedName += '%s%s' % (namespace, ObjectNamer.SEP_NAMESPACE)
			if unmappedName in self.anonymizedNames:
				mappedName = self.anonymizedNames[unmappedName]
			else:
				mappedName = mappedName + self.nameFmt % ('namespace', self.__nextUniqueID('namespace')) + ObjectNamer.SEP_NAMESPACE
				self.anonymizedNames[unmappedName] = mappedName

		# Add any instances or full path elements along the way
		prefix = ''
		for instance in instances:
			unmappedName += prefix + instance
			if unmappedName in self.anonymizedNames:
				mappedName = self.anonymizedNames[unmappedName]
			else:
				if self.hasMaya:
					nodeType = maya.cmds.nodeType(unmappedName)
				else:
					nodeType = 'node'
				mappedName = mappedName + prefix + self.nameFmt % (nodeType, self.__nextUniqueID(nodeType))
				self.anonymizedNames[unmappedName] = mappedName
			prefix = ObjectNamer.SEP_NODE[1]	# Avoid the '\' escape character for the prefix

		# Now the leaf node name
		unmappedName += prefix + nodepath
		if unmappedName in self.anonymizedNames:
			mappedName = self.anonymizedNames[unmappedName]
		else:
			if self.hasMaya:
				nodeType = maya.cmds.nodeType(unmappedName)
			else:
				nodeType = 'node'
			mappedName = mappedName + prefix + self.nameFmt % (nodeType, self.__nextUniqueID(nodeType))
			self.anonymizedNames[unmappedName] = mappedName

		# And finally the underworld, if it exists
		if underworld:
			unmappedName += ObjectNamer.SEP_UNDERWORLD + underworld
			if unmappedName in self.anonymizedNames:
				mappedName = self.anonymizedNames[unmappedName]
			else:
				mappedName = mappedName + ObjectNamer.SEP_UNDERWORLD + self.nameFmt % ('underworld', self.__nextUniqueID('underworld'))
				self.anonymizedNames[unmappedName] = mappedName

		return mappedName

	#======================================================================
	def __anonymizedPath(self, originalName):
		"""
		Return an anonymized version of the given file path. If the last
		element of the path ends in a '/' or '\' then the path is assumed
		to be a directory, otherwise it is assumed to be a path.

		The following replacements are made to the original name:
			'\' are all replaced by '/', for consistency
			Leading Windows disk names "X:" are replaced by the absolute
				path beginning "/X"
			Directories in the path are replaced with 'dir_#'
				# is taken from the unique directory ID
			The file in the path, if any, is replaced with 'file_#'
				# is taken from the unique file ID

		The directory anonymizer is tricky because it has to check for
		mapped directories from the top down. i.e. "/a/b/c" should remap
		all of "/a", "/a/b", and "/a/b/c".
		"""
		originalName.replace( os.sep, ObjectNamer.SEP_PATH )
		(path,theFile) = os.path.split( originalName )
		# Catch the special case of terminating "/", e.g. ".../path/"
		if theFile == '':
			path += ObjectNamer.SEP_PATH
			theFile = None
		parts = re.split(ObjectNamer.SEP_DRIVE, path)
		builtPath = ''
		if len(parts) > 1:
			builtPath = '%s%s' % (parts[0], ObjectNamer.SEP_DRIVE)
			dirs = re.split(ObjectNamer.SEP_PATH, parts[1])
		else:
			dirs = re.split(ObjectNamer.SEP_PATH, parts[0])
			if dirs[0] == '':
				if len(dirs) > 1:
					builtPath = ObjectNamer.SEP_PATH
					dirs = dirs[1:]
				else:
					dirs = []
			elif len(dirs) == 0:
				builtPath = ''
				dirs = []

		# Build up the directory a level at a time so that any subdirectory
		# that is already mapped will be used.
		for theDir in range(0,len(dirs)):
			dirElement = dirs[theDir]
			if theDir > 0:
				builtPath += ObjectNamer.SEP_PATH
			# This catches a directory with a trailing '/'
			if dirElement == '':
				continue
			tempPath = builtPath + dirElement
			# If the partial path exists then switch over to its
			# anonymized name
			if tempPath in self.anonymizedNames:
				builtPath = self.anonymizedNames[tempPath]
			else:
				anonDir = self.nameFmt % ('dir', self.__nextUniqueID('dir'))
				builtPath += anonDir
				self.anonymizedNames[tempPath] = builtPath

		# Lastly if there is a file component append that onto the end
		if theFile:
			if builtPath != '':
				builtPath += ObjectNamer.SEP_PATH
			tempPath = builtPath + theFile
			if tempPath in self.anonymizedNames:
				builtPath = self.anonymizedNames[tempPath]
			else:
				anonFile = self.nameFmt % ('file', self.__nextUniqueID('theFile'))
				builtPath  += anonFile

		self.anonymizedNames[originalName] = builtPath

		return builtPath

# Copyright (C) 1997-2014 Autodesk, Inc., and/or its licensors.
# All rights reserved.
#
# The coded instructions, statements, computer programs, and/or related
# material (collectively the "Data") in these files contain unpublished
# information proprietary to Autodesk, Inc. ("Autodesk") and/or its licensors,
# which is protected by U.S. and Canadian federal copyright law and by
# international treaties.
#
# The Data is provided for use exclusively by You. You have the right to use,
# modify, and incorporate this Data into other products for purposes authorized 
# by the Autodesk software license agreement, without fee.
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND. AUTODESK
# DOES NOT MAKE AND HEREBY DISCLAIMS ANY EXPRESS OR IMPLIED WARRANTIES
# INCLUDING, BUT NOT LIMITED TO, THE WARRANTIES OF NON-INFRINGEMENT,
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE, OR ARISING FROM A COURSE 
# OF DEALING, USAGE, OR TRADE PRACTICE. IN NO EVENT WILL AUTODESK AND/OR ITS
# LICENSORS BE LIABLE FOR ANY LOST REVENUES, DATA, OR PROFITS, OR SPECIAL,
# DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES, EVEN IF AUTODESK AND/OR ITS
# LICENSORS HAS BEEN ADVISED OF THE POSSIBILITY OR PROBABILITY OF SUCH DAMAGES.

