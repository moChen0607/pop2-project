import maya.mel
import maya.cmds
from .BaseAnalytic import BaseAnalytic
from .decorators import addMethodDocs,addHelp,makeAnalytic

@addMethodDocs
@addHelp
@makeAnalytic
class analyticGPUDeformers(BaseAnalytic):
	"""
	Checks if the geometry is supported by deformer evaluator.
	"""
	@staticmethod
	def _isSupportedGeometry( geometry ):
		"""
		For it to be supported, it must:
		1) Be a mesh
		2) Not have a connected output
		3) Have at least k vertices, where k=2000 on NVidia hardware (hard-coded value)
		"""
		# Check if the deformed geometry is a mesh.
		geometryType = maya.cmds.nodeType( geometry )
		if geometryType != 'mesh':
			return False
		
		# Check if output is connected.
		worldMeshDestinations = maya.cmds.listConnections( geometry + '.worldMesh' , source=False , destination=True , plugs=True )
		if worldMeshDestinations != None and len( worldMeshDestinations ) > 0:
			return False
		
		# Check the number of vertices.
		nbVertices = maya.cmds.polyEvaluate( geometry , vertex=True )
		if nbVertices < 2000:
			return False
		
		return True
	
	"""
	Return the list of deformer types.
	"""
	@staticmethod
	def __getDeformerTypes( ):
		deformerTypes = [
			"baseLattice" ,
			"blendShape" ,
			"boneLattice" ,
			"cluster" ,
			"deformBend" ,
			"deformFlare" ,
			"deformSine" ,
			"deformSquash" ,
			"deformTwist" ,
			"deformWave" ,
			"ffd" ,
			"flexorShape" ,
			"historySwitch" ,
			"jiggle" ,
			"jointCluster" ,
			"jointFfd" ,
			"jointLattice" ,
			"lattice" ,
			"nonLinear" ,
			"revealGeometry" ,
			"sculpt" ,
			"shrinkWrap" ,
			"skinCluster" ,
			"softMod" ,
			"surfaceFit" ,
			"textureDeformer" ,
			"transferAttributes" ,
			"tweak" ,
			"wire" ,
			"wrap" ,
		]
		
		return deformerTypes
	
	"""
	Analyze the usage mode of deformer nodes.
	"""
	def run(self, showDetails=False):
		"""
		Examine animated deformers nodes and check how they are used.
		
		When 'showDetails' is False, the default, then the CSV columns are:

			DeformerMode		: Description of the usage for the animated deformer node
			Type				: Deformer type
			SupportedGeometry	: True if the geometry processed by animated deformer nodes is supported by deformer evaluator
			Count				: Number of animated deformer nodes in this mode

			See _isSupportedGeometry() for what criteria a geometry must meet to be supported.

		When 'showDetails' is True, then the CSV columns are:

			DeformerNode			: Name of the animated deformer node
			Type					: Type for this node
			SupportedGeometry		: True if the geometry processed by animated deformer node is supported by deformer evaluator

		One row is output for every animated deformer node.

		Return True if the analysis succeeded, else False
		"""
		success = True
		try:
			if not self._open():
				return False

			# Trigger evaluation to make sure graph gets built properly.
			maya.mel.eval( 'currentTime `currentTime -q`;' )
			
			# Get all animated nodes.
			maya.mel.eval( 'setEvaluationManagerModeSerial;' )
			evaluationGraph = maya.cmds.dbpeek( op='graph', a=['evaluationGraph','nodes'] )
			maya.mel.eval( 'setEvaluationManagerModeDefaultDG;' )
			animatedNodes = set( evaluationGraph.split() )
			
			# deformer node types.
			deformerNodeTypes = analyticGPUDeformers.__getDeformerTypes()
			
			# Loop and process only deformer nodes of the right type.
			deformerNodes = []
			for node in animatedNodes:
				# Get the type.
				nodeType = maya.cmds.nodeType( node )
				
				if nodeType in deformerNodeTypes:
					# Now loop over each output geometry as separate usage of this node.
					geometries      = maya.cmds.deformer( node , query=True , geometry=True )
					geometryIndices = maya.cmds.deformer( node , query=True , geometryIndices=True )
					if geometries == None or geometryIndices == None:
						continue
					
					deformerGeometry = dict( zip( geometryIndices , geometries ) )
					for index , geometry in deformerGeometry.items():
						# Check if the deformed geometry is supported.
						supportedGeometry = analyticGPUDeformers._isSupportedGeometry( geometry )
						
						# Append the info.
						nodeName = '%s[%d]' % ( node , index )
						deformerNodes.append( ( nodeName , nodeType , supportedGeometry ) )
			
			# Output to CSV.
			if showDetails:
				self._outputCSV( [ 'DeformerNode'
								 , 'Type'
								 , 'SupportedGeometry'
								 ] )
				outputRows = deformerNodes
			else:
				self._outputCSV( [ 'DeformerMode'
								 , 'Type'
								 , 'SupportedGeometry'
								 , 'Count'
								 ] )
				
				# Build the summary using different categories.
				categories = []
				for nodeType in deformerNodeTypes:
					categories.append( ( "%s_NotSupported" % nodeType , ( nodeType , False ) ) )
					categories.append( ( "%s_Supported"    % nodeType , ( nodeType , True  ) ) )
				
				# Loop over each "category" and count the number of collected nodes (in deformerNodes)
				# meeting the criteria for each category.
				#
				# Here, the criteria to know whether or not a node belongs to a category is:
				# - The node type
				# - Whether or not the deformer node drives a supported mesh (vs another type of geometry)
				summary = []
				for category in categories:
					name = category[ 0 ]
					criteria = category[ 1 ]
					tester = lambda x : x[1:] == criteria
					count = len( [node for node in deformerNodes if tester( node ) ] )
					
					summary.append( ( name , criteria[0] , criteria[1] , count ) )
				
				outputRows = summary
			
			for row in outputRows:
				self._outputCSV( list( row ) )
			
		except Exception, ex:
			print 'analyticGPUDeformers failed: "%s"' % str(ex)
			success = False
		finally:
			self._close()

		return success
# Copyright (C) 1997-2014 Autodesk, Inc., and/or its licensors.
# All rights reserved.
#
# The coded instructions, statements, computer programs, and/or related
# material (collectively the "Data") in these files contain unpublished
# information proprietary to Autodesk, Inc. ("Autodesk") and/or its licensors,
# which is protected by U.S. and Canadian federal copyright law and by
# international treaties.
#
# The Data is provided for use exclusively by You. You have the right to use,
# modify, and incorporate this Data into other products for purposes authorized 
# by the Autodesk software license agreement, without fee.
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND. AUTODESK
# DOES NOT MAKE AND HEREBY DISCLAIMS ANY EXPRESS OR IMPLIED WARRANTIES
# INCLUDING, BUT NOT LIMITED TO, THE WARRANTIES OF NON-INFRINGEMENT,
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE, OR ARISING FROM A COURSE 
# OF DEALING, USAGE, OR TRADE PRACTICE. IN NO EVENT WILL AUTODESK AND/OR ITS
# LICENSORS BE LIABLE FOR ANY LOST REVENUES, DATA, OR PROFITS, OR SPECIAL,
# DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES, EVEN IF AUTODESK AND/OR ITS
# LICENSORS HAS BEEN ADVISED OF THE POSSIBILITY OR PROBABILITY OF SUCH DAMAGES.

