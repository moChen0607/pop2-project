import maya.mel
import maya.cmds
from .BaseAnalytic import BaseAnalytic
from .decorators import addMethodDocs,addHelp,makeAnalytic
from .analyticGPUDeformers import analyticGPUDeformers

@addMethodDocs
@addHelp
@makeAnalytic
class analyticGPUClusters(BaseAnalytic):
	"""
	Analyze the usage mode of cluster node.
	"""
	def run(self, showDetails=False):
		"""
		Examine animated cluster nodes and check how they are used.  It checks
		whether they are used for fixed rigid transform, weighted rigid transform
		or per-vertex-weighted transform.
		
		When 'showDetails' is False, the default, then the CSV columns are:

			ClusterMode			: Description of the usage for the animated cluster node
			Mode				: Mode for animated cluster nodes meeting this criteria
			SupportedGeometry	: True if the geometry processed by animated cluster nodes meeting this criteria is supported by deformer evaluator
			Count				: Number of animated cluster nodes in this mode

			See _isSupportedGeometry() for what criteria a geometry must meet to be supported.

		When 'showDetails' is True, then the CSV columns are:

			ClusterNode				: Name of the animated cluster node
			EnvelopeIsStaticOne		: True if the envelope is not animated and its value is 1
			UsesWeights				: True if weights are used in the node
			UsesSameWeight			: True if weight is the same for all vertices
			Mode					: Mode for this node
			SupportedGeometry		: True if the geometry processed by animated cluster node is supported by deformer evaluator

		One row is output for every animated cluster node.

		The "Mode" is an integer value with the following meaning:
		- 1 => Rigid transform			: cluster node only performs a rigid transform
		- 2 => Weighted rigid transform	: cluster node performs a rigid transform, but it is weighted down by a factor
		- 3 => Per-vertex transform		: cluster node computes a different transform for each individually-weighted vertex

		Return True if the analysis succeeded, else False
		"""
		success = True
		try:
			if not self._open():
				return False

			# Get all animated nodes.
			maya.mel.eval( 'setEvaluationManagerModeSerial;' )
			evaluationGraph = maya.cmds.dbpeek( op='graph', a=['evaluationGraph','nodes'] )
			maya.mel.eval( 'setEvaluationManagerModeDefaultDG;' )
			animatedNodes = set( evaluationGraph.split() )
			
			# Loop and process only cluster nodes.
			clusterNodes = []
			for node in animatedNodes:
				if maya.cmds.nodeType( node ) == 'cluster':
					# Check the envelope attribute.
					envelopeSource = maya.cmds.listConnections( node + '.envelope' , source=True , destination=False )
					if envelopeSource and len( envelopeSource ) > 0:
						envelopeIsStaticOne = False
					else:
						envelope = maya.cmds.getAttr( node + '.envelope' )
						if envelope == 1:
							envelopeIsStaticOne = True
						else:
							envelopeIsStaticOne = False

					# Now loop over each output geometry as separate usage of this node.
					geometries      = maya.cmds.cluster( node , query=True , geometry=True )
					geometryIndices = maya.cmds.cluster( node , query=True , geometryIndices=True )
					if geometries == None or geometryIndices == None:
						continue
					
					clusterGeometry = dict( zip( geometryIndices , geometries ) )
					for index , geometry in clusterGeometry.items():
						# Check if the deformed geometry is supported.
						supportedGeometry = analyticGPUDeformers._isSupportedGeometry( geometry )
						
						# Check if weights are used.
						usesWeights = False
						weightPlug = '%s.weightList[%d]' % ( node , index )
						weightsSource = maya.cmds.listConnections( weightPlug , source=True , destination=False )
						if weightsSource and len( weightsSource ) > 0:
							# If they are animated, we consider they don't have default value.
							usesWeights = True
						
						usesSameWeight = False
						commonValue = None
						if not usesWeights:
							usesSameWeight = True
							
							# Check if the weights have non default value.
							weights = maya.cmds.percent( node , geometry , query=True , value=True )
							for weight in weights:
								if commonValue == None:
									commonValue = weight
								else:
									if commonValue != weight:
										usesSameWeight = False
										break
						
						if ( not usesSameWeight ) or ( commonValue != 1 ):
							usesWeights = True
						
						# Determine the mode.
						if usesWeights:
							mode = 3
						else:
							if envelopeIsStaticOne:
								mode = 1
							else:
								mode = 2
						
						# Append the info.
						nodeName = '%s[%d]' % ( node , index )
						clusterNodes.append( ( nodeName , envelopeIsStaticOne , usesWeights , usesSameWeight , mode , supportedGeometry ) )
			
			# Output to CSV.
			if showDetails:
				self._outputCSV( [ 'ClusterNode'
								 , 'EnvelopeIsStaticOne'
								 , 'UsesWeights'
								 , 'UsesSameWeight'
								 , 'Mode'
								 , 'SupportedGeometry'
								 ] )
				outputRows = clusterNodes
			else:
				self._outputCSV( [ 'ClusterType'
								 , 'Mode'
								 , 'SupportedGeometry'
								 , 'Count'
								 ] )
				
				# Build the summary using different categories.
				categories = [
					( 'Rigid_Supported'        , ( 1 , True  ) ) ,
					( 'Weighted_Supported'     , ( 2 , True  ) ) ,
					( 'PerVertex_Supported'    , ( 3 , True  ) ) ,
					( 'Rigid_NotSupported'     , ( 1 , False ) ) ,
					( 'Weighted_NotSupported'  , ( 2 , False ) ) ,
					( 'PerVertex_NotSupported' , ( 3 , False ) ) ,
					]
				
				# Loop over each "category" and count the number of collected nodes (in clusterNodes)
				# meeting the criteria for each category.
				#
				# Here, the criteria to know whether or not a node belongs to a category is:
				# - The "mode" (see help above for description of the modes)
				# - Whether or not the cluster node drives a supported mesh (vs another type of geometry)
				summary = []
				for category in categories:
					name = category[ 0 ]
					criteria = category[ 1 ]
					tester = lambda x : x[4:] == criteria
					count = len( [node for node in clusterNodes if tester( node ) ] )
					
					summary.append( ( name , criteria[0] , criteria[1] , count ) )
				
				outputRows = summary
			
			for row in outputRows:
				self._outputCSV( list( row ) )
			
		except Exception, ex:
			print 'analyticGPUClusters failed: "%s"' % str(ex)
			success = False
		finally:
			self._close()

		return success
# Copyright (C) 1997-2014 Autodesk, Inc., and/or its licensors.
# All rights reserved.
#
# The coded instructions, statements, computer programs, and/or related
# material (collectively the "Data") in these files contain unpublished
# information proprietary to Autodesk, Inc. ("Autodesk") and/or its licensors,
# which is protected by U.S. and Canadian federal copyright law and by
# international treaties.
#
# The Data is provided for use exclusively by You. You have the right to use,
# modify, and incorporate this Data into other products for purposes authorized 
# by the Autodesk software license agreement, without fee.
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND. AUTODESK
# DOES NOT MAKE AND HEREBY DISCLAIMS ANY EXPRESS OR IMPLIED WARRANTIES
# INCLUDING, BUT NOT LIMITED TO, THE WARRANTIES OF NON-INFRINGEMENT,
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE, OR ARISING FROM A COURSE 
# OF DEALING, USAGE, OR TRADE PRACTICE. IN NO EVENT WILL AUTODESK AND/OR ITS
# LICENSORS BE LIABLE FOR ANY LOST REVENUES, DATA, OR PROFITS, OR SPECIAL,
# DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES, EVEN IF AUTODESK AND/OR ITS
# LICENSORS HAS BEEN ADVISED OF THE POSSIBILITY OR PROBABILITY OF SUCH DAMAGES.

