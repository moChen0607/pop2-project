import math
import maya.cmds
from .BaseAnalytic import BaseAnalytic
from .decorators import addMethodDocs,addHelp,makeAnalytic

@addMethodDocs
@addHelp
@makeAnalytic
class analyticValues(BaseAnalytic):
	"""
	Analyze use of plug values that make some simple algorithms complex.
	"""
	def run(self, showDetails=False):
		"""
		Here is a complete list of what will be counted and reported:
			- transforms using each of the non-standard rotation orders
			- transforms using scale limits, min and/or max
			- transforms using rotate limits, min and/or max
			- transforms using translation limits, min and/or max
			- joints with incoming connections on their scale attribute(s)
			- joints with incoming connections on their shear attribute(s)
			- joints with incoming connections on their translate attribute(s)
			- joints with non-uniform scale values (and no incoming connection)
			- joints with non-default shear values (and no incoming connection)

		If you enable the showDetails flag then instead of showing one line
		per type of match with the number of matches found there will be a line
		for every match showing the node name matched.
		"""
		try:
			if not self._open():
				return

			if showDetails:
				self._outputCSV( ["Node Type", "Value Type", "Node Name"] )
			else:
				self._outputCSV( ["Node Type", "Value Type", "Count"] )

			#------------------------------------------------------------------
			#{
			#  Check transforms for the following conditions:
			#
			#		Altered rotation order
			#		Limits turned on
			#
			rotateOrderNames = ['xyz', 'yzx', 'zxy', 'xzy', 'yxz', 'zyx', 'Unknown']
			transformNodes = maya.cmds.ls( type='transform' )
			rotateOrders ={}
			limitTypes = {}
			for node in transformNodes:
				rotateOrder = maya.cmds.getAttr( '%s.ro' % node )
				# Cap the rotation type value in case of future changes
				if rotateOrder > 6:
					rotateOrder = 6
				if rotateOrder != 0:
					rotateOrders[rotateOrder] = rotateOrders.get(rotateOrder,0) + 1
					if showDetails:
						self._outputCSV( ['transform', 'Rotate Order %s' % rotateOrderNames[rotateOrder], node] )
				for type in ['minTransLimitEnable', 'maxTransLimitEnable',
							 'minRotLimitEnable',   'maxRotLimitEnable',
							 'minScaleLimitEnable', 'maxScaleLimitEnable' ]:
					limitsOn= maya.cmds.getAttr( '%s.%s' % (node, type) )
					if limitsOn != [(False, False, False)]:
						limitTypes[type] = limitTypes.get(type,0) + 1
						if showDetails:
							self._outputCSV( ['transform', 'Used Limit %s' % type, node] )
			# Only report the summary if the details were not supplied.
			# The summary information can easily be calculated after-the-fact
			# if necessary.
			if not showDetails:
				for order,count in rotateOrders.iteritems():
					self._outputCSV( ['transform', 'Rotate Order %s' % rotateOrderNames[order], count] )
				for limitType,count in limitTypes.iteritems():
					self._outputCSV( ['transform', 'Used Limit %s' % limitType, count] )
			#}
			#-----------------------------------------------------------------

			#-----------------------------------------------------------------
			#{
			#  Check joints for the following conditions:
			#
			#		Scale with incoming connection(s)
			#		Translate with incoming connection(s)
			#		Shear with incoming connection(s)
			#		Non-Uniform scale (no incoming connection)
			#		Shear values at non-default values (no incoming connection)
			#
			jointNodes = maya.cmds.ls( type='joint' )
			incomingCounts = {}
			nonUniformScaleCount = 0
			nonDefaultShearCount = 0
			children = {}
			children['scale'] = ['', 'X','Y','Z']
			children['translate'] = ['', 'X','Y','Z']
			children['shear'] = ['', 'XY','XZ','YZ']
			for node in jointNodes:
				for attr in ['scale', 'translate', 'shear']:
					aName = '%s.%s' % (node, attr)
					hasConnection = False
					for subAttr in children[attr]:
						conn = maya.cmds.listConnections( '%s%s' % (aName,subAttr), destination=False, source=True )
						if conn != None:
							hasConnection =True
							incomingCounts[attr] = incomingCounts.get(attr,0) + 1
							if showDetails:
								self._outputCSV( ['joint', 'Incoming Connection %s' % attr, node] )
					if not hasConnection and attr == 'scale':
						scaling = maya.cmds.getAttr( aName )[0]
						if not analyticValues.__eq(scaling[0], scaling[1]) or not analyticValues.__eq(scaling[1], scaling[2]):
							nonUniformScaleCount += 1
							if showDetails:
								self._outputCSV( ['joint', 'Non-Uniform Scale', node] )
					elif not hasConnection and attr == 'shear':
						shearValue = maya.cmds.getAttr( aName )[0]
						if not analyticValues.__eq3(shearValue, (0.0, 0.0, 0.0)):
							nonDefaultShearCount += 1
							if showDetails:
								self._outputCSV( ['joint', 'Non-Default Shear', node] )
			# Only print the summary if the details were not supplied.
			# The summary information can easily be calculated after-the-fact
			# if necessary.
			if not showDetails:
				for attr,count in incomingCounts.iteritems():
					self._outputCSV( ['joint', 'Incoming Connection %s' % attr, count] )
				self._outputCSV( ['joint', 'Non-Uniform Scale', nonUniformScaleCount] )
				self._outputCSV( ['joint', 'Non-Default Shear', nonDefaultShearCount] )
			#}
			#-----------------------------------------------------------------

			#-----------------------------------------------------------------
			#{
			#  Check point constraints for the following conditions:
			#
			#		Non-default offset
			#
			pointConstraintNodes = maya.cmds.ls( type='pointConstraint' )
			nonDefaultOffsetCount = 0
			for node in pointConstraintNodes:
				offsetValue = maya.cmds.getAttr( '%s.offset' % node )[0]
				if not analyticValues.__eq3(offsetValue, (0.0, 0.0, 0.0)):
					nonDefaultOffsetCount += 1
					if showDetails:
						self._outputCSV( ['pointConstraint', 'Non-Default Offset', node] )

			# Only print the summary if the details were not supplied. The summary
			# information can easily be calculated after-the-fact if necessary.
			if not showDetails:
				self._outputCSV( ['pointConstraint', 'Non-Default Offset', nonDefaultOffsetCount] )
			#}
			#-----------------------------------------------------------------

		except Exception, ex:
			print 'Analytic failed: "%s"' % str(ex)
		finally:
			self._close()

	#======================================================================
	@classmethod
	def __eq( cls, a, b, eps=0.0001 ):
		"""Simple implementation of a floating point 'equality'"""
		# Catch the 0 cases first since they mess up the adaptive log() trick
		if abs(a) <= eps and abs(b) > eps:
			return False
		if abs(b) <= eps and abs(a) > eps:
			return False
		if abs(b) <= eps and abs(a) <= eps:
			return True
		return (abs(math.log( a ) - math.log(b)) <=  eps)

	#======================================================================
	@classmethod
	def __eq3( cls, aVec, bVec, eps=0.0001 ):
		"""Simple implementation of a floating point vector 'equality'"""
		for a,b in zip(aVec,bVec):
			if not cls.__eq(a, b, eps):
				return False
		return True

# Copyright (C) 1997-2014 Autodesk, Inc., and/or its licensors.
# All rights reserved.
#
# The coded instructions, statements, computer programs, and/or related
# material (collectively the "Data") in these files contain unpublished
# information proprietary to Autodesk, Inc. ("Autodesk") and/or its licensors,
# which is protected by U.S. and Canadian federal copyright law and by
# international treaties.
#
# The Data is provided for use exclusively by You. You have the right to use,
# modify, and incorporate this Data into other products for purposes authorized 
# by the Autodesk software license agreement, without fee.
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND. AUTODESK
# DOES NOT MAKE AND HEREBY DISCLAIMS ANY EXPRESS OR IMPLIED WARRANTIES
# INCLUDING, BUT NOT LIMITED TO, THE WARRANTIES OF NON-INFRINGEMENT,
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE, OR ARISING FROM A COURSE 
# OF DEALING, USAGE, OR TRADE PRACTICE. IN NO EVENT WILL AUTODESK AND/OR ITS
# LICENSORS BE LIABLE FOR ANY LOST REVENUES, DATA, OR PROFITS, OR SPECIAL,
# DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES, EVEN IF AUTODESK AND/OR ITS
# LICENSORS HAS BEEN ADVISED OF THE POSSIBILITY OR PROBABILITY OF SUCH DAMAGES.

