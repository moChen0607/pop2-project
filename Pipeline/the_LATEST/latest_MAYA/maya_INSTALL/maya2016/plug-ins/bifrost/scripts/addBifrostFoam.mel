// Copyright (C) 1997-2014 Autodesk, Inc., and/or its licensors.
// All rights reserved.
//
// The coded instructions, statements, computer programs, and/or related
// material (collectively the "Data") in these files contain unpublished
// information proprietary to Autodesk, Inc. ("Autodesk") and/or its licensors,
// which is protected by U.S. and Canadian federal copyright law and by
// international treaties.
//
// The Data is provided for use exclusively by You. You have the right to use,
// modify, and incorporate this Data into other products for purposes authorized 
// by the Autodesk software license agreement, without fee.
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND. AUTODESK
// DOES NOT MAKE AND HEREBY DISCLAIMS ANY EXPRESS OR IMPLIED WARRANTIES
// INCLUDING, BUT NOT LIMITED TO, THE WARRANTIES OF NON-INFRINGEMENT,
// MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE, OR ARISING FROM A COURSE 
// OF DEALING, USAGE, OR TRADE PRACTICE. IN NO EVENT WILL AUTODESK AND/OR ITS
// LICENSORS BE LIABLE FOR ANY LOST REVENUES, DATA, OR PROFITS, OR SPECIAL,
// DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES, EVEN IF AUTODESK AND/OR ITS
// LICENSORS HAS BEEN ADVISED OF THE POSSIBILITY OR PROBABILITY OF SUCH DAMAGES.

global proc string[] addBifrostFoam(){

if(!`exists addBifrostCollider`) {
	// shared bifrost input  scripts here
	source "addBifrostCollider.mel";
}
string $result[];


undoInfo -cn "Foam" -ock ;

// Save selection
string $sel[] = `ls -sl`;

string $msg = (uiRes("m_addBifrostFoam.kWarnIfNoContainer"));

if(size($sel) == 0) {
	// need to have a Liquid container selected to add foam to
	warning( $msg );
	return $result;
}
string $liquid = filterBifrostInput( $sel[0], "bifrostContainer");
if(size($liquid) == 0) {
	// need to have a Liquid container selected to add foam to
	warning( $msg );
	return $result;
}

string $c, $connections[] = `listConnections -p true -type "bifrostContainer" $liquid`;
for ( $c in $connections ) {
	if ( attributeExists( "Foam", plugNode( $c ) ) ) {
		warning( (uiRes("m_addBifrostFoam.kWarnIfFoamConnected")) );
		return $result;
	}
}

// Create Container node
string $cont = `bifrost -c -g  "Foam"`;
setAttr ($cont+".perFrameCaching") 1;
if( `optionVar -exists bifrostScratchCacheVar`) {
	if( !`optionVar -query bifrostScratchCacheVar` ) {
		setAttr ($cont+".perFrameCaching") 0;
	}
}

setAttr ($cont+".emissionRate") 1000;
setAttr ($cont+".minLiquidSpeed") 0.2;
setAttr ($cont+".minLiquidChurn") 1.0;
setAttr ($cont+".minLiquidCurvature") 0.5;
setAttr ($cont+".minLiquidDepth") 0.0;
setAttr ($cont+".maxLiquidDepth") 3.0;
setAttr ($cont+".maxSolidDepth") 0.3;
setAttr ($cont+".inheritLiquidVelocity") 1.0;
setAttr ($cont+".emitFlatnessToSurface") 0.0;
setAttr ($cont+".dissipationRate") 5.0;
setAttr ($cont+".killDensityThreshold") 0.05;
setAttr ($cont+".gravity") 9.8;
setAttr ($cont+".buoyancy") 1.0;
setAttr ($cont+".randomizeMotion") 0.0;
setAttr ($cont+".surfaceOffset") 0.0;
setAttr ($cont+".snapToSurface") false;
setAttr ($cont+".particleRadius") 0.3;
setAttr ($cont+".preserveVolume") 1.0;
setAttr ($cont+".cameraAdaptivity") 0.0;
setAttr ($cont+".clipToCameraFrustum") false;
setAttr ($cont+".cameraFov") 110.0;
setAttr ($cont+".cameraAspect") 1.0;
setAttr ($cont+".cameraBuffer") 1.0;

// Create Shape connect it to the container
string $shape = `createNode "bifrostShape"`;
setAttr ($shape+".bifrostRenderType") 3;
setAttr ($shape+".particles") 1;
setAttr ($shape+".particleType") 0; // Point particles
setAttr ($shape+".particleChannel") -type "string" "position";
setAttr ($shape+".particleColorChannel") -type "string" "density";
setAttr ($shape+".particleColorRemap[0].particleColorRemap_Color") -type double3 0.9 0.9 0.9;
setAttr ($shape+".particleVectorChannel") -type "string" "velocity";
setAttr ($shape+".particleNumericChannel") -type "string" "velocity";
setAttr ($shape+".particleColorRemapMin") 0.0;
setAttr ($shape+".particleColorRemapMax") 1.0;
setAttr ($shape+".voxels") 0;
setAttr ($shape+".voxelType") 2; // No Voxels
setAttr ($shape+".voxelChannel") -type "string" "distance";
setAttr ($shape+".voxelColorChannel") -type "string" "velocity";
setAttr ($shape+".voxelColorRemapMin") 0.0;
setAttr ($shape+".voxelColorRemapMax") 20.0;
connectAttr -force ($cont+".Foam") ($shape+".object");

connectAttr -force ($liquid+".Liquid") ($cont+".Liquid");
connectAttr -force ($liquid+".Solid") ($cont+".Solid");

string $perspCameras[] = `listCameras -p`;
if( size( $perspCameras ) > 0 ){
	if( getAttr($perspCameras[0] + ".renderable") ){
		connectAttr -f ($perspCameras[0] + ".worldMatrix[0]") ($cont+".cameraMatrixList[0]");
	}
}

// Get transform
string $parents[] = `listRelatives -fullPath -parent $shape`;
string $transform = $parents[0];

// Create the bifrost material shader
string $shader = `shadingNode -asShader bifrostFoamMaterial`;
string $shaderStrs[];
int $numStrs = `tokenize $shader ":" $shaderStrs`;
string $shaderBase = $shaderStrs[$numStrs - 1];

// Create Shading Group and connect shader to it
string $SG = `createNode -n ($shaderBase+"SG") "shadingEngine"`;
setAttr ".ihi" 0;
setAttr -s 3 ".dsm";
setAttr ".ro" true;
relationship "link" ":lightLinker1" ($SG+".message") ":defaultLightSet.message";
relationship "shadowLink" ":lightLinker1" ($SG+".message") ":defaultLightSet.message";
connectAttr -na ($SG+".pa") ":renderPartition.st";
connectAttr -f ($shader+".outColor") ($SG+".surfaceShader");

// Apply the Shading Group on the transform
select -r $transform;
sets -e -forceElement $SG;

// Set default meshing settings
// Note: the bifrostShape node initialization also sets the defaults
setAttr ($shape + ".meshingEnable") false  ;
setAttr ($shape + ".meshingDropletRevealFactor") 3 ;
setAttr ($shape + ".meshingSurfaceRadius") 1.4 ;
setAttr ($shape + ".meshingDropletRadius") 1.2 ;
setAttr ($shape + ".meshingKernelFactor")  2.0;
setAttr ($shape + ".meshingSmoothing")  2;
setAttr ($shape + ".meshingResolutionFactor")  1.0;
setAttr ($shape + ".meshingFlipFaceNormals")  false;

// create bifrost mesh shape for meshing output
string $meshShape = `createNode "mesh" -n "bifrostMeshShape#"`;
string $parents[] = `listRelatives -fullPath -parent $meshShape`;
string $meshTransform = $parents[0];

// Set the motion vector of a bifrostMeshShape to its  bifrost velocity CPV.
setAttr -type "string" ($meshShape + ".motionVectorColorSet") "bifrostVelocity";

// Connect bifrostShape output to bifrostMeshShape input
connectAttr -force ($shape + ".meshingOutput") ($meshShape + ".inMesh");

// Assign the shading group to the birostMeshShape
select $meshShape;
sets -e -forceElement $SG;

// Add mental ray user data to the mesh
if (`pluginInfo -q -l "Mayatomr"`)
{
	// Force Export of Vertex Colors for Bifrost Liquid Material to render properly on meshes
	catchQuiet( `miCreateGlobalsNode` );
	catchQuiet( `setAttr "mentalrayGlobals.exportVertexColors" 1` );
	catchQuiet( `setAttr "miDefaultOptions.autoVolume" 1` );
	catchQuiet( `setAttr "miDefaultOptions.shadowMethod" 3` );

	// Add mental ray user data to the mesh
	bifrostMRMeshUserData $meshTransform ($cont+".Foam");
}



// Restore selection
select -r $transform;
$result[0] = $cont;

undoInfo -cck ;
return $result;
}

