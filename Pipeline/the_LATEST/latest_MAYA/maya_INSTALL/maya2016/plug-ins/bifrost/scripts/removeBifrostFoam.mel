// Copyright (C) 1997-2014 Autodesk, Inc., and/or its licensors.
// All rights reserved.
//
// The coded instructions, statements, computer programs, and/or related
// material (collectively the "Data") in these files contain unpublished
// information proprietary to Autodesk, Inc. ("Autodesk") and/or its licensors,
// which is protected by U.S. and Canadian federal copyright law and by
// international treaties.
//
// The Data is provided for use exclusively by You. You have the right to use,
// modify, and incorporate this Data into other products for purposes authorized 
// by the Autodesk software license agreement, without fee.
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND. AUTODESK
// DOES NOT MAKE AND HEREBY DISCLAIMS ANY EXPRESS OR IMPLIED WARRANTIES
// INCLUDING, BUT NOT LIMITED TO, THE WARRANTIES OF NON-INFRINGEMENT,
// MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE, OR ARISING FROM A COURSE 
// OF DEALING, USAGE, OR TRADE PRACTICE. IN NO EVENT WILL AUTODESK AND/OR ITS
// LICENSORS BE LIABLE FOR ANY LOST REVENUES, DATA, OR PROFITS, OR SPECIAL,
// DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES, EVEN IF AUTODESK AND/OR ITS
// LICENSORS HAS BEEN ADVISED OF THE POSSIBILITY OR PROBABILITY OF SUCH DAMAGES.

global proc removeBifrostFoam() 
{
	string $error_msg = (uiRes("m_removeBifrostFoam.kRemoveFoamNoContainer"));

	string $sel[] = `ls -sl`;
	if ( size( $sel ) == 0 )
	{
		warning( $error_msg );
		return;
	}

	// Get Liquid container
	string $liquid = filterBifrostInput( $sel[0], "bifrostContainer" );
	string $foam_attribute;
	
	if ( size( $liquid ) == 0 )
	{
		warning( $error_msg );
		return;
	}

	if ( attributeExists( "Foam", $liquid ) )
	{
		$foam_attribute = ".Foam";
	}
	else
	{
		warning( $error_msg );
		return;
	}
	
	// Get Foam shape
	string $shape = "";
	string $destinations[]; 
	$destinations = `connectionInfo -destinationFromSource ($liquid + $foam_attribute)`;
	string $dest;
	for ( $dest in $destinations ) {
		/* this is the identifying trait of the shape node */
		if ( plugAttr( $dest ) == "object" ) {
			$shape = plugNode( $dest );	
			break;
		}
	}
	// Get shape transform node
	string $parents[] = `listRelatives -fullPath -parent $shape`;
	string $shape_transform = $parents[0];

	// Get mesh shape and sets of which it is an element
	string $meshshape = "";
	$destinations = `connectionInfo -destinationFromSource ($shape + ".meshingOutput")`;

	for ( $dest in $destinations ) {
		if ( plugAttr( $dest ) == "inMesh" ) {
			$meshshape = plugNode( $dest );	
			break;
		}
	}

	if( $meshshape != "" ){ // has a mesh
		string $meshshape_sets[] = `listSets -object $meshshape`;
		// Remove shading groups
		string $set;
		string $nodes[];
		string $shader;
		for ( $node in $meshshape_sets ) {
			/* this is the identifying trait of a shading group */
			if ( attributeExists( "surfaceShader", $node ) )
			{
				$shader = `connectionInfo -sourceFromDestination ($node + ".surfaceShader")`;
				if ( $shader != "" ) {
					delete `plugNode( $shader )`; // note: we may wish to not delete this if something else is using it
				}
				delete $node;
			}
		}

		// Remove mesh shape and transform
		$parents = `listRelatives -fullPath -parent $meshshape`;
		delete $parents[0];

	}
	// Remove Foam shape and transform
	delete $shape_transform;

    setAttr ($liquid+".enableFoam") 0.0;
}
