// Copyright (C) 1997-2014 Autodesk, Inc., and/or its licensors.
// All rights reserved.
//
// The coded instructions, statements, computer programs, and/or related
// material (collectively the "Data") in these files contain unpublished
// information proprietary to Autodesk, Inc. ("Autodesk") and/or its licensors,
// which is protected by U.S. and Canadian federal copyright law and by
// international treaties.
//
// The Data is provided for use exclusively by You. You have the right to use,
// modify, and incorporate this Data into other products for purposes authorized 
// by the Autodesk software license agreement, without fee.
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND. AUTODESK
// DOES NOT MAKE AND HEREBY DISCLAIMS ANY EXPRESS OR IMPLIED WARRANTIES
// INCLUDING, BUT NOT LIMITED TO, THE WARRANTIES OF NON-INFRINGEMENT,
// MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE, OR ARISING FROM A COURSE 
// OF DEALING, USAGE, OR TRADE PRACTICE. IN NO EVENT WILL AUTODESK AND/OR ITS
// LICENSORS BE LIABLE FOR ANY LOST REVENUES, DATA, OR PROFITS, OR SPECIAL,
// DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES, EVEN IF AUTODESK AND/OR ITS
// LICENSORS HAS BEEN ADVISED OF THE POSSIBILITY OR PROBABILITY OF SUCH DAMAGES.

//
//
//  Creation Date:  2013
//
//  Description:
//      Create Bifrost Disk Cache
//		
//


proc string getFileDirFlag( string $cacheFile,
							string $cacheDirectory )
{
	string $fileDirFlag = ("-fileName \"" + $cacheFile+"\"" );
	if ($cacheDirectory != "") {
		$fileDirFlag += (" -directory \""+$cacheDirectory+"\" ");
	}
	return $fileDirFlag;
}

proc string getBifrostCacheDirectory(	string $directory, string $filerule, string $fileNames[])
{
	string $origDirectory = $directory;
	if ($directory == "") {
		// expand name after getting the file rule, so we get the full path
		// whether the rule was absolute or relative
		$directory = (`workspace -q -fre $filerule`);
		$directory = `workspace -en $directory`;
		$directory += "/";
		$origDirectory = $directory;
		$subDir = getNameForCacheSubDir(0,$directory, "");
		$directory += $subDir;
	}	
	if( !endsWith($directory, "/") ) { $directory += "/"; }
	$cacheDirectory = $directory;

	string $fn;
	int $cacheExists = 0;
	if (`file -q -exists $cacheDirectory`) {
		for ($fn in $fileNames) {
			string $cachePrefix = $cacheDirectory + $fn + "*";
			string $existingFiles[] = `getFileList -filespec $cachePrefix `;
			if(size($existingFiles) > 0) {
				$cacheExists = 1;
				break;
			}
		}
	}
	if ($cacheExists) {
	   	string $subDir;
		string $replace = (uiRes("m_doCreateBifrostCache.kReplace"));
		string $rename = (uiRes("m_doCreateBifrostCache.kRename"));
		string $noReplace = (uiRes("m_doCreateBifrostCache.kDoNotReplace"));
		string $cancel = (uiRes("m_doCreateBifrostCache.kCancel"));
		string $format = (uiRes("m_doCreateBifrostCache.kReplaceExistingFmt"));
		string $msg = `format -stringArg $cacheDirectory $format`;
		string $userChoice = `confirmDialog 
			-title (uiRes("m_doCreateBifrostCache.kCreateCacheWarning"))
			-message $msg
			-messageAlign "left"
			-button $noReplace
			-button $cancel
			-button $replace
			-defaultButton $replace
			-cancelButton $cancel -dismissString $cancel`;
		if ($userChoice == $cancel) {
			return "";
		} else if ($userChoice == $noReplace) {
			$subDir = getNameForCacheSubDir(1,$origDirectory, $subDir);
			$cacheDirectory = ($origDirectory + $subDir);
		}
	}

	return $cacheDirectory;
}


global proc string[] doCreateBifrostCache( int $version, string $args[] )
//
// Description:
//	Create cache files on disk for the select bifrost object(s) according
//  to the specified flags described below.
//
// $version == 1:
//	$args[0] = time range mode:
//		time range mode = 0 : use $args[1] and $args[2] as start-end
//		time range mode = 1 : use render globals
//		time range mode = 2 : use timeline
//	$args[1] = start frame (if time range mode == 0)
//	$args[2] = end frame (if time range mode == 0)
//	$args[3] = name of cache directory.
//	$args[4]= name of cache file. An empty string can be used to specify that an auto-generated name is acceptable.
// $version == 2:
//	$args[5] = name of cache format
//	$args[6] = index of cache compression format
// $version == 3:
// 	$args[7] = write mode :
//		write mode = 2 : overwrite entire time range, set to read afterwards
//		write mode = 3 : read if exists, write missing frames only, leave in this mode afterwards
//
{	
	string $cacheFiles[];
	if(( $version > 3 ) || ( size($args) > 8)) {
		error( (uiRes("m_doCreateBifrostCache.kBadArgsError")));
		return $cacheFiles;
	}

	int 	$rangeMode 			= $args[0];
	float  	$diskCacheStartTime = $args[1];
	float  	$diskCacheEndTime   = $args[2];

	string $cacheDirectory = $args[3];
	string $fileName = $args[4];

	string $cacheFormat = "bif"; // default value
	int $compressionFormat = 0; // default value
	if ( $version >= 2 )
	{
		$cacheFormat = $args[5];
		$compressionFormat = $args[6];
	}
	int $writeMode = 2;
	if ( $version >= 3 )
	{
		$writeMode = $args[7];
	}


	float  $startTime = $diskCacheStartTime;
	float  $endTime = $diskCacheEndTime;

	if( $rangeMode == 1 ) {
        $startTime = `getAttr defaultRenderGlobals.startFrame`; 
        $endTime = `getAttr defaultRenderGlobals.endFrame`; 
	} else if( $rangeMode == 2 ) {
		$startTime = `playbackOptions -q -min`;
		$endTime = `playbackOptions -q -max`;
	}

	string $objsToCache[] = getBifrostObjectsToCache(1);

	string $obj;

	verifyWorkspaceFileRule( "bifrostCache", "cache/bifrost" );
	// Check if directory has caches that might be overwritten
	//

	// set cache names
	if( size($objsToCache) > 1 ) {
	    // if multiple objects to cache, just use the container name even if the option was explicitly set
	     $filename = "";
	}

	string $newFileName;
	string $fileNames[];
	for( $obj in $objsToCache ) {
		$newFileName = $fileName;
		if($fileName == "") 
			$newFileName = getAutomaticBifrostCacheName($obj); 

		if(`attributeExists "enableLiquidCache" $obj`) {
			setAttr -type "string" ($obj + ".liquidCacheFileName") ($newFileName +"_liquid");
		}
		if(`attributeExists "enableSolidCache" $obj`) {
			setAttr -type "string" ($obj + ".solidCacheFileName") ($newFileName +"_solids");
		}
		if(`attributeExists "enableFoamCache" $obj`) {
			setAttr -type "string" ($obj + ".foamCacheFileName") ($newFileName +"_foam");
		}
		if(`attributeExists "enableAeroCache" $obj`) {
			setAttr -type "string" ($obj + ".aeroCacheFileName") ($newFileName +"_aero");
		}

		$fileNames[size($fileNames)] = $newFileName;
	}
	
	string $cacheDirectory = getBifrostCacheDirectory($cacheDirectory, "bifrostCache", $fileNames);
	if ($cacheDirectory == "") {
		return $cacheFiles;
	}

	if( !`sysFile -makeDir $cacheDirectory` ) {
		return $cacheFiles;
	}


	// set directory
	for( $obj in $objsToCache ) {
		if(`attributeExists "enableLiquidCache" $obj`) {
			setAttr -type "string" ($obj + ".liquidCachePath") $cacheDirectory;
		}
		if(`attributeExists "enableSolidCache" $obj`) {
			setAttr -type "string" ($obj + ".solidCachePath") $cacheDirectory;
		}
		if(`attributeExists "enableFoamCache" $obj`) {
			setAttr -type "string" ($obj + ".foamCachePath") $cacheDirectory;
		}
		if(`attributeExists "enableAeroCache" $obj`) {
			setAttr -type "string" ($obj + ".aeroCachePath") $cacheDirectory;
		}
		
	}

	// don't enable cache write until we get to the start cache frame
	//int $startFrame;
	//for( $obj in $objsToCache ) {
		//$startFrame = `getAttr ($obj + ".startFrame")`;
		//if ($startTime > $startFrame) {
		//	$startTime = $startFrame;
		//}
	//}
	for( $obj in $objsToCache ) {
		$startFrame = `getAttr ($obj + ".startFrame")`;
		setAttr ($obj + ".enableDiskCache") 1;

		if(`attributeExists "enableLiquidCache" $obj`) {
			setAttr ($obj + ".enableLiquidCache") 1;
			// want to read the cache at the pre-start-frame if exists
			setAttr ($obj + ".liquidCacheControl") $writeMode;
			setAttr ($obj + ".liquidCompressionQuality") $compressionFormat;
		}
		if(`attributeExists "enableSolidCache" $obj`) {
			setAttr ($obj + ".enableSolidCache") 1;
			// want to read the cache at the pre-start-frame if exists
			setAttr ($obj + ".solidCacheControl") $writeMode;
			setAttr ($obj + ".solidCompressionQuality") $compressionFormat;
		}
		if(`attributeExists "enableFoamCache" $obj`) {
			if(`getAttr ($obj + ".enableFoam")` == 1) {
				setAttr ($obj + ".enableFoamCache") 1;
				setAttr ($obj + ".foamCacheControl") $writeMode;
			}
			// want to read the cache at the pre-start-frame if exists
			setAttr ($obj + ".foamCompressionQuality") $compressionFormat;
		}
		if(`attributeExists "enableAeroCache" $obj`) {
			setAttr ($obj + ".enableAeroCache") 1;
			// want to read the cache at the pre-start-frame if exists
			setAttr ($obj + ".aeroCacheControl") $writeMode;
			setAttr ($obj + ".aeroCompressionQuality") $compressionFormat;
		}
	}

	// ARFTODO:  Should not be necessary since setAttr does not imply compute of the
	// bifrost container.  It is just "record" and "apply on startFrame"
	int $preStart = $startTime -1;

	currentTime $preStart;
	for( $obj in $objsToCache ) {
		// ARFTODO: we can change going to write to flush the scratch cache
		// then the following loop that flushes caches would not be necessary
		// setAttr ($obj + ".cachingControl") 2;
		if(`attributeExists "enableLiquidCache" $obj`) {
			setAttr ($obj + ".liquidCacheControl") $writeMode;
		}
		if(`attributeExists "enableSolidCache" $obj`) {
			setAttr ($obj + ".solidCacheControl") $writeMode;
		}
		if(`attributeExists "enableFoamCache" $obj`) {
			if(`getAttr ($obj + ".enableFoam")` == 1) {
				setAttr ($obj + ".foamCacheControl") $writeMode;
			}
		}
		if(`attributeExists "enableAeroCache" $obj`) {
			setAttr ($obj + ".aeroCacheControl") $writeMode;
		}

		
	}
	for( $obj in $objsToCache ) {
		$startFrame = `getAttr ($obj + ".startFrame")`;
		if($startTime <= $startFrame) {
		    select -r $obj;
			bifrost -edit -flushScratchCache;
		}
	}

	// TEMP PATCH UNTIL RUNUP IS FIXED
	// Forcing an evaluation will make sure that if the startTime
	// for runup == one of a bifrost container then the container
	// will be evaluated and not skipped by runup

	//float $firstStartTime = $endTime;
	//float $aStartTime;
	//for( $obj in $objsToCache ) {
	//$aStartTime = `getAttr ($obj + ".startTime")`;
	//	if( $aStartTime < $firstStartTime ) {
	//		$firstStartTime = $aStartTime;
	//	}
	//}
	currentTime $startTime;
	for( $obj in $objsToCache ) {
		setAttr ($obj + ".forceCompute") 1;
		getAttr ($obj + ".doCompute");
	}

	// runup command only runs up after sim start frame, need to exactly hit the start frame to make it cache
	// without append, we start at the earliest start frame of any selected container.
	// If we appending, we would want read the last cached frame, then switch to the write, and runup from previous.
			
	// Because flushScratchCache was done on bifrostContainers
	// then runup from previous is safe because all bifrost sims
	// have been cleared and will need to restart
	// runup -fsf -mxf $endTime;
	runup -fpf -mxf $endTime;

	// set attrs to read the cache
	for( $obj in $objsToCache ) {
		// setAttr ($obj + ".cachingControl") 1;
		if(`attributeExists "enableLiquidCache" $obj`) {
			setAttr ($obj + ".liquidCacheControl") 1;
		}
		if(`attributeExists "enableSolidCache" $obj`) {
			setAttr ($obj + ".solidCacheControl") 1;
		}
		if(`attributeExists "enableFoamCache" $obj`) {
			if(`getAttr ($obj + ".enableFoam")` == 1) {
				setAttr ($obj + ".foamCacheControl") 1;
			}
		}
		if(`attributeExists "enableAeroCache" $obj`) {
			setAttr ($obj + ".aeroCacheControl") 1;
		}

	}		

	select -r $objsToCache;
	return $cacheFiles;
}
