// Copyright (C) 1997-2014 Autodesk, Inc., and/or its licensors.
// All rights reserved.
//
// The coded instructions, statements, computer programs, and/or related
// material (collectively the "Data") in these files contain unpublished
// information proprietary to Autodesk, Inc. ("Autodesk") and/or its licensors,
// which is protected by U.S. and Canadian federal copyright law and by
// international treaties.
//
// The Data is provided for use exclusively by You. You have the right to use,
// modify, and incorporate this Data into other products for purposes authorized 
// by the Autodesk software license agreement, without fee.
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND. AUTODESK
// DOES NOT MAKE AND HEREBY DISCLAIMS ANY EXPRESS OR IMPLIED WARRANTIES
// INCLUDING, BUT NOT LIMITED TO, THE WARRANTIES OF NON-INFRINGEMENT,
// MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE, OR ARISING FROM A COURSE 
// OF DEALING, USAGE, OR TRADE PRACTICE. IN NO EVENT WILL AUTODESK AND/OR ITS
// LICENSORS BE LIABLE FOR ANY LOST REVENUES, DATA, OR PROFITS, OR SPECIAL,
// DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES, EVEN IF AUTODESK AND/OR ITS
// LICENSORS HAS BEEN ADVISED OF THE POSSIBILITY OR PROBABILITY OF SUCH DAMAGES.

global proc string[] addBifrostFoamAV3(){

    string $result[];
	int $createOutputMesh = false; // set true at which point we support meshing of foam
    undoInfo -cn "foam" -ock ;

    // Save selection
    string $sel[] = `ls -sl`;

    string $msg = (uiRes("m_addBifrostFoamAV3.kWarnIfNoContainerForFoamAV3"));

    if(size($sel) == 0) {
	    // need to have a Liquid container selected to add foam to
	    warning( $msg );
	    return $result;
    }
    string $liquid = filterBifrostInput( $sel[0], "bifrostContainer");
    if(size($liquid) == 0) {
	    // need to have a Liquid container selected to add foam to
	    warning( $msg );
	    return $result;
    }
	string $liquidParents[] = `listRelatives -fullPath -parent $liquid`;
	string $liquidTform = $liquidParents[0];
	string $liquidTformBase[] = `ls $liquidTform`;
	string $baseName = $liquidTformBase[0];

	// remove namespace if exists from base name because rename adds the current namespace
	string $buffer[];
	int $nTokens = tokenize ($baseName, ":",  $buffer);
	if( $nTokens > 1 ){
		$baseName = $buffer[size($buffer)-1];
	}

    setAttr ($liquid+".enableFoam") 1.0;

    string $connections[] = `listConnections -type "bifrostShape" ($liquid+".Foam")`;

	if( size($connections) > 0 ){
		warning( (uiRes("m_addBifrostFoamAV3.kWarnIfFoamConnected")) );
		return $result;
    }
    
    // Create Shape connect it to the container
    string $shape = `createNode "bifrostShape"`;
    setAttr ($shape+".bifrostRenderType") 3;
    setAttr ($shape+".particles") 1;
    setAttr ($shape+".particleType") 0; // Point particles
    setAttr ($shape+".particleChannel") -type "string" "position";
    setAttr ($shape+".particleColorChannel") -type "string" "density";
    setAttr ($shape+".particleColorRemap[0].particleColorRemap_Color") -type double3 0.9 0.9 0.9;
    setAttr ($shape+".particleVectorChannel") -type "string" "velocity";
    setAttr ($shape+".particleNumericChannel") -type "string" "velocity";
    setAttr ($shape+".particleColorRemapMin") 0.0;
    setAttr ($shape+".particleColorRemapMax") 1.0;
    setAttr ($shape+".voxels") 0;
	setAttr ($shape+".voxelType") 2; // No Voxels
    setAttr ($shape+".voxelChannel") -type "string" "distance";
    setAttr ($shape+".voxelColorChannel") -type "string" "velocity";
    setAttr ($shape+".voxelColorRemapMin") 0.0;
    setAttr ($shape+".voxelColorRemapMax") 20.0;

    connectAttr -force ($liquid+".Foam") ($shape+".object");

    // Get transform
    string $parents[] = `listRelatives -fullPath -parent $shape`;
    string $transform = $parents[0];

    // Create the bifrost material shader
    $shader = `shadingNode -asShader bifrostFoamMaterial`;

    // Create Shading Group and connect shader to it
    string $SG = `createNode -n ($shader+"SG") "shadingEngine"`;
    setAttr ".ihi" 0;
    setAttr -s 3 ".dsm";
    setAttr ".ro" true;
    relationship "link" ":lightLinker1" ($SG+".message") ":defaultLightSet.message";
    relationship "shadowLink" ":lightLinker1" ($SG+".message") ":defaultLightSet.message";
    connectAttr -na ($SG+".pa") ":renderPartition.st";
    connectAttr -f ($shader+".outColor") ($SG+".surfaceShader");

    // Apply the Shading Group on the transform
    select -r $transform;
    sets -e -forceElement $SG;

    // Set default meshing settings
    // Note: the bifrostShape node initialization also sets the defaults
    setAttr ($shape + ".meshingEnable") false  ;
    setAttr ($shape + ".meshingDropletRevealFactor") 3 ;
    setAttr ($shape + ".meshingSurfaceRadius") 1.4 ;
    setAttr ($shape + ".meshingDropletRadius") 1.2 ;
    setAttr ($shape + ".meshingKernelFactor")  2.0;
    setAttr ($shape + ".meshingSmoothing")  2;
    setAttr ($shape + ".meshingResolutionFactor")  1.0;
    setAttr ($shape + ".meshingFlipFaceNormals")  false;

	if( $createOutputMesh ){
		// create bifrost mesh shape for meshing output
		string $meshShape = `createNode "mesh" -n "bifrostMeshShape#"`;
		string $parents[] = `listRelatives -fullPath -parent $meshShape`;
		string $meshTransform = $parents[0];

		// Set the motion vector of a bifrostMeshShape to its  bifrost velocity CPV.
		setAttr -type "string" ($meshShape + ".motionVectorColorSet") "bifrostVelocity";

		// Connect bifrostShape output to bifrostMeshShape input
		connectAttr -force ($shape + ".meshingOutput") ($meshShape + ".inMesh");

		// Assign the shading group to the birostMeshShape
		select $meshShape;
		sets -e -forceElement $SG;

		// Add mental ray user data to the mesh
		if (`pluginInfo -q -l "Mayatomr"`)
		{
			// Force Export of Vertex Colors for Bifrost Liquid Material to render properly on meshes
			catchQuiet( `miCreateGlobalsNode` );
			catchQuiet( `setAttr "mentalrayGlobals.exportVertexColors" 1` );
			catchQuiet( `setAttr "miDefaultOptions.autoVolume" 1` );
			catchQuiet( `setAttr "miDefaultOptions.shadowMethod" 3` );

			// Add mental ray user data to the mesh
			bifrostMRMeshUserData $meshTransform ($liquid+".Foam");
		}

		rename $meshTransform ($baseName + "FoamMesh");
	}

    // Restore selection
    select -r $transform;
    $result[0] = $liquid;

	// get the numeric extension by subtracting the base name
	string $numericExtension = `substitute "bifrostLiquid" $baseName ""`;

	$transform = `rename $transform ("foam"+$numericExtension)`;
	parent $transform $liquidTform;

    undoInfo -cck ;
    return $result;
}

