<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.9.1"/>
<title>Bifrost Object Model: FAQ</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Bifrost Object Model
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.9.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('faq.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">FAQ </div>  </div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#faq_stateserver">How data is organized in Bifrost ?</a></li>
<li class="level1"><a href="#faq_tile">What is a tile?</a></li>
<li class="level1"><a href="#faq_tile_tree">What is a tile tree ?</a></li>
<li class="level1"><a href="#faq_layout">What is a layout ?</a></li>
<li class="level1"><a href="#faq_particle_tiles">How does Bifrost store particle tiles ?</a></li>
<li class="level1"><a href="#faq_bkg_value">What is a layout voxel scale factor ?</a></li>
<li class="level1"><a href="#faq_similarity">What is a similarity ?</a></li>
<li class="level1"><a href="#faq_bif">How Bifrost is storing data ?</a></li>
<li class="level1"><a href="#faq_is_multithreaded">Is the Bifrost API multi-threaded ?</a></li>
<li class="level1"><a href="#automatic_memory_management">How does Bifrost manage objects memory ?</a></li>
<li class="level1"><a href="#backward_compatibility">Is the Bifrost API backward compatible ?</a></li>
<li class="level1"><a href="#error_handling">How does the Bifrost API handle errors ?</a></li>
</ul>
</div>
<div class="textblock"><h1><a class="anchor" id="faq_stateserver"></a>
How data is organized in Bifrost ?</h1>
<p>A state server maintains data in a hierarchy. At the top are named Objects which can combine a diverse set of things like voxels and particles. An Object contains named Components, each of which describes how some of the data can be organized. For example, a Point Component describes a set of particles, with data stored for each particle; a Voxel Component describes a set of voxels in space, with data stored in each voxel. Finally, each Component may contain named Channels, each of which stores one type of data in the component.</p>
<h1><a class="anchor" id="faq_tile"></a>
What is a tile?</h1>
<p>A tile represents a node in a tile tree.</p>
<h1><a class="anchor" id="faq_tile_tree"></a>
What is a tile tree ?</h1>
<p>Tiles are arranged into a Tile tree, which is similar to an octree but with a 5x5x5 branching factor instead of just 2x2x2.</p>
<p>Each node (<a class="el" href="class_bifrost_1_1_a_p_i_1_1_tile.html" title="The Tile class represents an item of a tile tree. It stores meta data and link information to other t...">Bifrost::API::Tile</a>) in the Tile tree can provide a 5x5x5 voxel tile for a Voxel Layout, according to which Voxel Channels can store data. Each node, up to a maximum depth of 7, can further have up to 125 children nodes of 1/5th the size along each side, arranged in a 5x5x5 grid, exactly like a Voxel Tile. In other words, a single voxel can be refined into 5x5x5 children voxels occupying the same volume of space.</p>
<h1><a class="anchor" id="faq_layout"></a>
What is a layout ?</h1>
<p>All the Channels in a Component have the same Layout. A Layout (<a class="el" href="class_bifrost_1_1_a_p_i_1_1_layout.html" title="The Layout class. All the Channels in a Component have the same Layout. A Layout indicates exactly ho...">Bifrost::API::Layout</a>) indicates exactly how many elements there are in every channel (how many voxels, how many particles, etc.), and for the currently implemented Components, it also defines essentially how they are mapped into 3D space.</p>
<h1><a class="anchor" id="faq_particle_tiles"></a>
How does Bifrost store particle tiles ?</h1>
<p>The location of particles in the tile tree is linked to the type of simulation performed. For non-adaptive simulation, Bifrost stores liquid particles at depth 7 and droplets at depth 6. For adaptive flip (aero and liquid), particles are stored at all depths.</p>
<h1><a class="anchor" id="faq_bkg_value"></a>
What is a layout voxel scale factor ?</h1>
<p>A voxel scale value (or dx) is a float parameter giving the actual width of a single voxel or how wide 1 unit of tile space should be.</p>
<h1><a class="anchor" id="faq_similarity"></a>
What is a similarity ?</h1>
<p>A similarity transform is bound to a component and includes a translation, rotation, and scaling matrices for mapping tiles into world space.</p>
<h1><a class="anchor" id="faq_bif"></a>
How Bifrost is storing data ?</h1>
<p>Bifrost uses <a class="el" href="namespace_b_i_f.html" title="The BIF namespace defines a region where all types, functions and classes related to BIF file operati...">BIF</a> files for storing values. A BIF file stores the Bifrost meta information and data related to Bifrost objects such as components and channels. <a class="el" href="class_bifrost_1_1_a_p_i_1_1_file_i_o.html" title="The FileIO class provides methods for saving and loading BIF files. Instances of FileIO are created w...">Bifrost::API::FileIO</a> is used in the Object Model for accessing BIF files. The API supports synchronous and asynchronous file operations to maximize client responsiveness when handling long-running IO tasks.</p>
<h1><a class="anchor" id="faq_is_multithreaded"></a>
Is the Bifrost API multi-threaded ?</h1>
<p>The Bifrost API can safely be used in a multi-threaded application, such as a Bifrost operator, for accessing and inserting channel tile data with the Visitor class for instance. However, the Bifrost API is not thread-safe in general. Operations like creating and accessing Bifrost objects in a multi-threading application is not guaranteed to work. One will need to use thread programming techniques like mutex, thread synchronization, etc... to make these operations thread-safe.</p>
<h1><a class="anchor" id="automatic_memory_management"></a>
How does Bifrost manage objects memory ?</h1>
<p>The BOM API is designed to automatically take care of object lifetime. Classes that reference objects in the Bifrost data model (for example, <a class="el" href="class_bifrost_1_1_a_p_i_1_1_ref.html" title="The Ref class is used for encapsulating Bifrost core objects. Ref instances are attached to Bifrost A...">Bifrost::API::Ref</a> and the <a class="el" href="namespace_a_p_i.html" title="The API namespace defines a region where all API classes are declared in Bifrost. ...">API</a> classes) are lightweight and should be created on the stack as shown in the various Bifrost code examples. The constructor of these objects automatically increments a reference count, and the destructor automatically decrements this count. This is much easier than regular C++ development where object lifetime needs to be explicitly controlled with the new and delete operators.</p>
<h1><a class="anchor" id="backward_compatibility"></a>
Is the Bifrost API backward compatible ?</h1>
<p>API classes are wrapper classes with no virtual methods that call internal object methods. Because the polymorphism happens inside the API, these classes act like a basic API function set. This extra layer ensures that backward compatibility is preserved between versions.</p>
<h1><a class="anchor" id="error_handling"></a>
How does the Bifrost API handle errors ?</h1>
<p>The BOM API uses the <a class="el" href="class_bifrost_1_1_a_p_i_1_1_status.html" title="Encapsulates status types for error handling purpose. The class also exposes methods to query and set...">Bifrost::API::Status</a>, <a class="el" href="class_bifrost_1_1_a_p_i_1_1_base.html" title="Base is a base class used for accessing Bifrost core objects through generic Ref objects. Base supports a runtime type information sytem (RTTI) and Ref attachment support for API classes. The RTTI is a mechanism that allows API classes to determine the type of reference objects during program execution. ">Bifrost::API::Base</a> and <a class="el" href="class_bifrost_1_1_a_p_i_1_1_ref.html" title="The Ref class is used for encapsulating Bifrost core objects. Ref instances are attached to Bifrost A...">Bifrost::API::Ref</a> classes for error handling. The Status class encapsulates simple status types (Success and Failure) which can be used to query the results of an operation performed by Bifrost class methods. Not all Bifrost class methods return a Status object however, most of them return Bifrost objects either as a <a class="el" href="class_bifrost_1_1_a_p_i_1_1_ref.html" title="The Ref class is used for encapsulating Bifrost core objects. Ref instances are attached to Bifrost A...">Bifrost::API::Ref</a> object or as an object deriving from <a class="el" href="class_bifrost_1_1_a_p_i_1_1_base.html" title="Base is a base class used for accessing Bifrost core objects through generic Ref objects. Base supports a runtime type information sytem (RTTI) and Ref attachment support for API classes. The RTTI is a mechanism that allows API classes to determine the type of reference objects during program execution. ">Bifrost::API::Base</a>. These objects can be used to query the state of the operation that created them. Trapping C++ exceptions is not required when using the Bifrost <a class="el" href="namespace_a_p_i.html" title="The API namespace defines a region where all API classes are declared in Bifrost. ...">API</a> since all exceptions are carefully handled internally. </p>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Thu Feb 26 2015 17:01:49 for Bifrost Object Model by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.9.1 </li>
  </ul>
</div>
</body>
</html>
