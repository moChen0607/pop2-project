<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.9.1"/>
<title>Bifrost Object Model: Bifrost Overview</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Bifrost Object Model
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.9.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('overview.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title"><a class="el" href="namespace_bifrost.html" title="The Bifrost namespace defines a region where all classes, types, functions and other identifiers are ...">Bifrost</a> Overview </div>  </div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#bifrost_intro">Introduction</a></li>
<li class="level1"><a href="#overview_organization">Data Organization</a></li>
<li class="level1"><a href="#overview_tiletrees">Voxel Layouts and Tile trees</a></li>
<li class="level1"><a href="#overview_pointlayouts">Point Layouts</a></li>
</ul>
</div>
<div class="textblock"><h1><a class="anchor" id="bifrost_intro"></a>
Introduction</h1>
<p>This page gives an overview of the Bifrost system and discusses how data and objects are managed by a Bifrost State Server.</p>
<h1><a class="anchor" id="overview_organization"></a>
Data Organization</h1>
<p>A state server maintains data in a hierarchy. At the top are named Objects which can combine a diverse set of things like voxels and particles. An Object (<a class="el" href="class_bifrost_1_1_a_p_i_1_1_object.html" title="The Object class represents the top object in the Bifrost object hierarchy. The Object class is a con...">Bifrost::API::Object</a>) contains named Components (<a class="el" href="class_bifrost_1_1_a_p_i_1_1_component.html" title="The Component class. A component defines the tile tree topology itself, the tile parameter scale...">Bifrost::API::Component</a>), each of which describes how some of the data can be organized. For example, a Point Component describes a set of particles, with data stored for each particle; a Voxel Component describes a set of voxels in space, with data stored in each voxel. Finally, each Component may contain named Channels (<a class="el" href="class_bifrost_1_1_a_p_i_1_1_channel.html" title="The Channel class represents a channel associated with 3D tree data structures that can be indexed by...">Bifrost::API::Channel</a>), each of which stores one type of data in the component.</p>
<p>As a concrete example, consider a simulated liquid at one point in time (e.g. one frame of a longer animation). This could be represented with an Object containing both a Point Component (describing the set of particles which carry the state of the liquid) and a Voxel Component (describing the set of voxels where we define helpful data such as a signed distance field to describe the geometry of the liquid surface). The Point Component in turn will have Channels such as velocity (3D vectors of floats, one per particle) and particle ID (64-bit integers assigned uniquely to each particle), and the Voxel Component will have Channels such as distance (a single float) and a voxel-sampled version of velocity (maybe encoded as three separate float channels for the three cartesian components of velocity, or maybe just as 3D float vectors).</p>
<h1><a class="anchor" id="overview_tiletrees"></a>
Voxel Layouts and Tile trees</h1>
<p>All the Channels in a Component have the same Layout (<a class="el" href="class_bifrost_1_1_a_p_i_1_1_layout.html" title="The Layout class. All the Channels in a Component have the same Layout. A Layout indicates exactly ho...">Bifrost::API::Layout</a>). A Layout indicates exactly how many elements there are in every channel (how many voxels, how many particles, etc.), and for the currently implemented Components, it also defines essentially how they are mapped into 3D space.</p>
<p>Let's look at Voxel Components first. Like other modern voxel data structures (OpenVDB, Naiad, etc.) voxels come packaged in small tiles. For Bifrost the tile size is defined by <a class="el" href="struct_bifrost_1_1_a_p_i_1_1_tile_dim_info.html#a7c53784f8abf4fc37c79c28325b2f820">Bifrost::API::TileDimInfo::tileWidth</a>, which is equal to 5. Every Voxel Channel stores its data as a collection of 5x5x5 tiles, each of which is stored as a small contiguous array of 125 elements in the usual (lexicographic, Fortran-style) order. Also like other modern voxel data structures, Voxel Layouts can specify a sparse set of tiles: loosely speaking, voxel tiles only need to be allocated where you want to define voxel data in 3D space, instead of having to fill a potentially enormous bounding box.</p>
<p>Where Bifrost differs from most other voxel structures is that it supports spatial adaptivity. Not all voxel tiles have to use the same size voxels: where you need lots of detail, voxels are small, and where you need less detail voxels can be much bigger (thus requiring fewer tiles, less storage, and less processing time). To make this work, tiles are arranged into a Tile tree, which is similar to an octree but with a 5x5x5 branching factor instead of just 2x2x2.</p>
<p>Each node (<a class="el" href="class_bifrost_1_1_a_p_i_1_1_tile.html" title="The Tile class represents an item of a tile tree. It stores meta data and link information to other t...">Bifrost::API::Tile</a>) in the Tile tree can provide a 5x5x5 voxel tile for a Voxel Layout, according to which Voxel Channels can store data. Each node, up to a maximum depth of 7, can further have up to 125 children nodes of 1/5th the size along each side, arranged in a 5x5x5 grid, exactly like a Voxel Tile. In other words, a single voxel can be refined into 5x5x5 children voxels occupying the same volume of space.</p>
<p>A Tile tree node either has a larger parent node or is a root; there can be multiple roots for efficiency, making it more technically a forest. However, any two roots will not overlap in space.</p>
<p>Tiles exist on levels zero to seven, with level zero being the biggest and seven the smallest. There is only one possible level zero tile, and it must be a root if it is present. The level zero tile, when present, covers the maximum volume of 390625 x 390625 x 390625 indices in tile space, centred on zero (ranging from -195312 to +195313 along each axis). There are up to 125 level one tiles, each of size 78125 x 78125 x 78125, and so forth. Level seven tiles are just 5x5x5.</p>
<p>While tile space uses integer index coordinates to determine where each tile exists, the Layout also provides a mapping into world space. This includes a float parameter dx giving the actual width of a single voxel (or how wide 1 unit of tile space should be), as well as a similarity transform that can include additional translation, rotation, and scaling.</p>
<h1><a class="anchor" id="overview_pointlayouts"></a>
Point Layouts</h1>
<p>Point Components also have a Layout to determine how points or particles are laid out. The exact same Tiletree structure is used here too, only instead of each node or tile of the tree representing 125 voxels, they represent an arbitrary number of particles stored 'in' that tile. Typically there will be a 'position' channel storing 3D vectors of floats which actually gives the position of each particle with more precision, with the general idea being that a particle should be stored in a tile in which its position vector lies.</p>
<p>It is important to realize that point data is not flat, stored in one long list of particles, but rather spatially partitioned according to a tile tree. This slight complication can make for much more efficient queries, more efficient computations involving other data (like voxel channels in the same space), better parallelism, etc. </p>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Thu Feb 26 2015 17:01:49 for Bifrost Object Model by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.9.1 </li>
  </ul>
</div>
</body>
</html>
