<!--
Copyright 2013 Autodesk, Inc. All rights reserved. 

Use of this software is subject to the terms of the Autodesk 
license agreement provided at the time of installation or download, 
or which otherwise accompanies this software in either electronic 
or hard copy form.
-->
<fragment  uiName="xgenVSWidthVec" name="xgenVSWidthVec" type="plumbing" class="ShadeFragment" version="1.0" feature_level="0" >
  <description>
    <![CDATA[
Compute vertex width vectors for xgen splines.]]>
  </description>
  <properties>
    <float3  name="Pm" semantic="Pm" flags="varyingInputParam" />
    <float   name="width" semantic="TEXCOORD0" flags="varyingInputParam" />
    <float3  name="curveVec" semantic="TEXCOORD1" flags="varyingInputParam" />
    <float4x4  name="world" semantic="world" />
    <float3  name="viewDirection" semantic="viewdirection" />
    <float3  name="worldCameraPosition" semantic="worldcameraposition" />
    <bool name="camIsOrtho" semantic="isorthographic" />
  </properties>
  <values>
  </values>
  <outputs>
    <float3  name="widthVecFinal" />
  </outputs>
  <implementation>
    <implementation  render="OGSRenderer" language="Cg" lang_version="2.100000" >
      <function_name val="xgenVSWidthVec" />
      <source>
        <![CDATA[
float3 xgenVSWidthVec(float3 Pm, float width, float3 curveVec, float4x4 world, float3 viewDirection, float3 worldCameraPosition, bool camIsOrtho)
{
    float3 viewVec = viewDirection;
    if (!camIsOrtho) {
    float3 pw = mul(world, float4(Pm, 1.0f)).xyz;
        viewVec = pw - worldCameraPosition;
    }

    return normalize(cross(viewVec, curveVec)) * width;
}
            ]]>
      </source>
    </implementation>
	<implementation  render="OGSRenderer" language="GLSL" lang_version="3.000000" >
      <function_name val="xgenVSWidthVec" />
      <source>
        <![CDATA[
vec3 xgenVSWidthVec(vec3 Pm, float width, vec3 curveVec, mat4 world, vec3 viewDirection, vec3 worldCameraPosition, bool camIsOrtho)
{
    vec3 viewVec = viewDirection;
    if (!camIsOrtho) {
    vec3 pw = mul(world, vec4(Pm, 1.0f)).xyz;
        viewVec = pw - worldCameraPosition;
    }

    return normalize(cross(viewVec, curveVec)) * width;
}
            ]]>
      </source>
    </implementation>
    <implementation  render="OGSRenderer" language="HLSL" lang_version="11.000000" >
      <function_name val="xgenVSWidthVec" />
      <source>
        <![CDATA[
float3 xgenVSWidthVec(float3 Pm, float width, float3 curveVec, float4x4 world, float3 viewDirection, float3 worldCameraPosition, bool camIsOrtho)
{
    float3 viewVec = viewDirection;
    if (!camIsOrtho) {
    float3 pw = mul(float4(Pm, 1.0f), world).xyz;
        viewVec = pw - worldCameraPosition;
    }

    return normalize(cross(viewVec, curveVec)) * width;
}
            ]]>
      </source>
    </implementation>
    <implementation  render="OGSRenderer" language="HLSL" lang_version="10.000000" >
      <function_name val="xgenVSWidthVec" />
      <source>
        <![CDATA[
float3 xgenVSWidthVec(float3 Pm, float width, float3 curveVec, float4x4 world, float3 viewDirection, float3 worldCameraPosition, bool camIsOrtho)
{
    float3 viewVec = viewDirection;
    if (!camIsOrtho) {
    float3 pw = mul(float4(Pm, 1.0f), world).xyz;
        viewVec = pw - worldCameraPosition;
    }

    return normalize(cross(viewVec, curveVec)) * width;
}
            ]]>
      </source>
    </implementation>
  </implementation>
</fragment>