// Copyright (C) 1997-2014 Autodesk, Inc., and/or its licensors.
// All rights reserved.
//
// The coded instructions, statements, computer programs, and/or related
// material (collectively the "Data") in these files contain unpublished
// information proprietary to Autodesk, Inc. ("Autodesk") and/or its licensors,
// which is protected by U.S. and Canadian federal copyright law and by
// international treaties.
//
// The Data is provided for use exclusively by You. You have the right to use,
// modify, and incorporate this Data into other products for purposes authorized 
// by the Autodesk software license agreement, without fee.
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND. AUTODESK
// DOES NOT MAKE AND HEREBY DISCLAIMS ANY EXPRESS OR IMPLIED WARRANTIES
// INCLUDING, BUT NOT LIMITED TO, THE WARRANTIES OF NON-INFRINGEMENT,
// MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE, OR ARISING FROM A COURSE 
// OF DEALING, USAGE, OR TRADE PRACTICE. IN NO EVENT WILL AUTODESK AND/OR ITS
// LICENSORS BE LIABLE FOR ANY LOST REVENUES, DATA, OR PROFITS, OR SPECIAL,
// DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES, EVEN IF AUTODESK AND/OR ITS
// LICENSORS HAS BEEN ADVISED OF THE POSSIBILITY OR PROBABILITY OF SUCH DAMAGES.

//
//  Description:
//	  Create the preference tab for XGen plugin
//

global proc prefsUpdateXGen()
{
	global string $gPreferenceWindow;
	setParent $gPreferenceWindow;
	string $parent = "xgenPref";
	
	if (`columnLayout -q -numberOfChildren $parent` == 0) {
		return;
	}

	setParent $parent;
	intFieldGrp -e -value1 `optionVar -q xgenXPDCacheSize` xpdCacheSizeCtrl;
	intFieldGrp -e -value1 `optionVar -q xgenPtexCacheSize` ptexCacheSizeCtrl;

	optionMenuGrp -e -select `optionVar -query xgenVP2DrawMethod` vp2DrawMethodMenu;

    checkBoxGrp -e -value1 `optionVar -query xgenThreadingGen` threadingGenCbg;
}

global proc xgenIntFieldsChanged()
{
	int $value;
	if (`intFieldGrp -exists xpdCacheSizeCtrl`) {
		$value = `intFieldGrp -q -value1 xpdCacheSizeCtrl`;
		if ($value > 0) {
			optionVar -iv xgenXPDCacheSize $value;
		}
		else {
			optionVar -iv xgenXPDCacheSize 0;
		}
	}

	if (`intFieldGrp -exists ptexCacheSizeCtrl`) {
		$value = `intFieldGrp -q -value1 ptexCacheSizeCtrl`;
		if ($value > 0) {
			optionVar -iv xgenPtexCacheSize $value;
		}
		else {
			optionVar -iv xgenPtexCacheSize 0;
		}
	}
}

global proc xgenUpdateVP2DrawMethod()
{
	int $oldMethod = 1; // default
	if(`optionVar -exists xgenVP2DrawMethod`)
	{
		 $oldMethod = `optionVar -q xgenVP2DrawMethod`;
	}

	int $newMethod = $oldMethod;
	if ( `optionMenuGrp -exists vp2DrawMethodMenu` )
	{
		$newMethod = `optionMenuGrp -query -select vp2DrawMethodMenu`;
	}

	if($newMethod != $oldMethod)
	{
		confirmDialog -title (uiRes("m_xgenPrefUI.kVPTwoMethodChangeTitle"))
			-messageAlign "left"
			-message (uiRes("m_xgenPrefUI.kVPTwoMethodChangeMessage"))
			-button (uiRes("m_xgenPrefUI.kOKitem"));
	}

	optionVar -iv xgenVP2DrawMethod $newMethod;
}

global proc xgenThreadingGenChanged()
{
    if (`checkBoxGrp -exists threadingGenCbg`)
    {
        int $state = `checkBoxGrp -q -value1 threadingGenCbg`;
        if ($state)
            python("xg.setAttr('Multithreading', '1', 'pal')");
        else
            python("xg.setAttr('Multithreading', '0', 'pal')");
        optionVar -iv xgenThreadingGen $state;
    }
}

global proc prefsHoldCurrentStateXGen(string $mode)
{
	xgenIntFieldsChanged();
	xgenUpdateVP2DrawMethod();
    xgenThreadingGenChanged();

	if ($mode == "save") {
		optionVar -iv "xgenXPDCacheSizeHold" `optionVar -q xgenXPDCacheSize`;
		optionVar -iv "xgenPtexCacheSizeHold" `optionVar -q xgenPtexCacheSize`;

		optionVar -iv "xgenVP2DrawMethodHold" `optionVar -q xgenVP2DrawMethod`;
        
        optionVar -iv "xgenThreadingGenHold" `optionVar -q xgenThreadingGen`;
	} else if ($mode == "restore") {
		optionVar -iv "xgenXPDCacheSize" `optionVar -q xgenXPDCacheSizeHold`;
		optionVar -iv "xgenPtexCacheSize" `optionVar -q xgenPtexCacheSizeHold`;

		optionVar -iv "xgenVP2DrawMethod" `optionVar -q xgenVP2DrawMethodHold`;

        optionVar -iv "xgenThreadingGen" `optionVar -q xgenThreadingGenHold`;
	} else {//	 "remove"
		// Remove the temporary option vars so they don't get saved out
		optionVar -remove "xgenXPDCacheSizeHold";
		optionVar -remove "xgenPtexCacheSizeHold";

		// Finalize preference changes into XGen
		xgmCache -xpd `optionVar -q xgenXPDCacheSize` -ptx `optionVar -q xgenPtexCacheSize`;

		optionVar -remove "xgenVP2DrawMethodHold";

        optionVar -remove "xgenThreadingGenHold";
	}

	global string $gPreferenceWindow;
	if (`window -exists $gPreferenceWindow`) {
		setParent xgenPref;
		if (`intFieldGrp -exists xpdCacheSizeCtrl`) {
			intFieldGrp -e -value1 `optionVar -q xgenXPDCacheSize` xpdCacheSizeCtrl;
			intFieldGrp -e -value1 `optionVar -q xgenPtexCacheSize` ptexCacheSizeCtrl;
		}

		if (`optionMenuGrp -exists vp2DrawMethodMenu`) {
			optionMenuGrp -e -select `optionVar -query xgenVP2DrawMethod` vp2DrawMethodMenu;
		}

        if (`checkBoxGrp -exists threadingGenCbg`) {
			checkBoxGrp -e -value1 `optionVar -query xgenThreadingGen` threadingGenCbg;
		}
	}
}

global proc prefsSetOptVarToDefault()
{
	// cache sizes in MB
	optionVar -iv xgenXPDCacheSize 100;
	optionVar -iv xgenPtexCacheSize 500;
	xgmCache -ptx 100 -xpd 500;

	optionVar -iv xgenVP2DrawMethod 1;

    optionVar -iv "xgenThreadingGen" 1;
}

global proc prefsCreateXGen()
{
	global string $gPreferenceWindow;
	setParent $gPreferenceWindow;
	string $parent = "xgenPref";

	//	 Check to see if this has been created already.
	//	
	if (`columnLayout -q -numberOfChildren $parent` > 0) {
		return;
	}
	//	  Create the UI
	//
	setParent $parent;
	setUITemplate -pushTemplate prefsTemplate;

	//	 This is used to force the width to fill the window
	separator -style "none" -h 1;

	frameLayout -label (uiRes("m_xgenPrefUI.kXGenCacheOptions"));
		columnLayout -adj true;
		intFieldGrp
			-label (uiRes("m_xgenPrefUI.kXGenXPDLable"))
			-extraLabel (uiRes("m_xgenPrefUI.kXGenMegaBytes1"))
			-changeCommand xgenIntFieldsChanged
			xpdCacheSizeCtrl;
		intFieldGrp
			-label (uiRes("m_xgenPrefUI.kXGenPtexLabel"))
			-extraLabel (uiRes("m_xgenPrefUI.kXGenMegaBytes2"))
			-changeCommand xgenIntFieldsChanged
			ptexCacheSizeCtrl;
		text -align "left" (uiRes("m_xgenPrefUI.kXGenCacheNotice"));

    setParent $parent;
	frameLayout -label (uiRes("m_xgenPrefUI.kXGenVPTwoOptions"));
		columnLayout -adj true;
		optionMenuGrp
			-columnWidth 1 138
			-label (uiRes("m_xgenPrefUI.kVPTwoDrawMethod"))
			-annotation (uiRes("m_xgenPrefUI.kVPTwoDrawMethodAnnot"))
			-changeCommand xgenUpdateVP2DrawMethod
			vp2DrawMethodMenu;

			menuItem -label (uiRes("m_xgenPrefUI.kVPTwoDrawHWInstance"));
			menuItem -label (uiRes("m_xgenPrefUI.kVPTwoDrawLegacy"));

	setParent $parent;
    frameLayout -label (uiRes("m_xgenPrefUI.kXGenThreadingOptions"));
		columnLayout -adj true;
		checkBoxGrp -ncb 1
			-label ""
			-label1 (uiRes("m_xgenPrefUI.kMultithreading"))
			threadingGenCbg;

    setParent $parent;
	setUITemplate -popTemplate;

	prefsUpdateXGen();
}

global proc prefsFrameLayoutCreateXGen()
{
	frameLayout -labelVisible false -borderVisible false -marginWidth 10 -marginHeight 10;
		columnLayout -adj true xgenPref;
}

global proc registerXGenPrefTab()
{
	// register the preference tab
	addCustomPrefsTab("prefsCreateXGen",
		"prefsFrameLayoutCreateXGen",
		"prefsUpdateXGen",
		"prefsHoldCurrentStateXGen",
		"prefsSetOptVarToDefault",
		(uiRes("m_xgenPrefUI.kXGenPrefTitle")),
		(uiRes("m_xgenPrefUI.kXGenPrefTab")));

	if (!`optionVar -exists xgenXPDCacheSize`) {
		prefsSetOptVarToDefault();
	}
	else {
		xgmCache -xpd `optionVar -q xgenXPDCacheSize` -ptx `optionVar -q xgenPtexCacheSize`;
		if (`optionVar -query xgenThreadingGen`)
			python("xg.setAttr('Multithreading', '1' , 'pal')");
		else
			python("xg.setAttr('Multithreading', '0' , 'pal')");
	}
}

global proc unregisterXGenPrefTab()
{
	// unregister the preference tab
	deleteCustomPrefsTab("prefsCreateXGen");
}
