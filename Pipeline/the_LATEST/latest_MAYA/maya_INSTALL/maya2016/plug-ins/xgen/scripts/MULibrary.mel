// Copyright (C) 1997-2013 Autodesk, Inc., and/or its licensors.
// All rights reserved.
//
// The coded instructions, statements, computer programs, and/or related
// material (collectively the "Data") in these files contain unpublished
// information proprietary to Autodesk, Inc. ("Autodesk") and/or its licensors,
// which is protected by U.S. and Canadian federal copyright law and by
// international treaties.
//
// The Data is provided for use exclusively by You. You have the right to use,
// modify, and incorporate this Data into other products for purposes authorized 
// by the Autodesk software license agreement, without fee.
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND. AUTODESK
// DOES NOT MAKE AND HEREBY DISCLAIMS ANY EXPRESS OR IMPLIED WARRANTIES
// INCLUDING, BUT NOT LIMITED TO, THE WARRANTIES OF NON-INFRINGEMENT,
// MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE, OR ARISING FROM A COURSE 
// OF DEALING, USAGE, OR TRADE PRACTICE. IN NO EVENT WILL AUTODESK AND/OR ITS
// LICENSORS BE LIABLE FOR ANY LOST REVENUES, DATA, OR PROFITS, OR SPECIAL,
// DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES, EVEN IF AUTODESK AND/OR ITS
// LICENSORS HAS BEEN ADVISED OF THE POSSIBILITY OR PROBABILITY OF SUCH DAMAGES.

/**
 * @file MULibrary.mel
 * @brief MEL procedures for the Maya Utilities Library plug-in.
 *
 * CONFIDENTIAL INFORMATION: This software is the confidential and proprietary
 * information of Walt Disney Animation Studios ("WDAS"). This software may not
 * be used, disclosed, reproduced or distributed for any purpose without prior
 * written authorization and license from WDAS. Reproduction of any section of
 * this software must include this legend and all copyright notices.
 *
 * Copyright 2006-2011 Disney Enterprises, Inc. All rights reserved.
 *
 * @author Mark A. McLaughlin
 *
 * @version markm    2006.04.20  Initial version.
 * @version kgambrel 2006.11.15  Added muDeformerOutputConnection
 *
 */


/**
 * This procedure returns the input (local space) attribute of the given shape.
 * NOTE: This is similar to the MPxSurfaceShape::localShapeInAttr API function.
 */
global proc string localShapeInAttr( string $shape )
{
    if ( objectType("-isType", "transform", $shape) ) {
        string $shapes[] = `listRelatives -s -path $shape`;
        if ( size($shapes) == 0 ) {
			string $fmt = (uiRes("m_MULibrary.kNoShapeKids"));
            error `format -s $shape $fmt`;
		}
        $shape = $shapes[0];
    }
    if ( objectType("-isType", "mesh", $shape) )
        return "inMesh";
    else if ( objectType("-isType", "nurbsCurve", $shape) )
        return "create";
    else if ( objectType("-isType", "nurbsSurface", $shape) )
        return "create";
    else if ( objectType("-isType", "lattice", $shape) )
        return "latticeInput";
    else if ( objectType("-isType", "subdiv", $shape) )
        return "create";
    else {
		string $fmt = "Object \"^1s\" is not a valid shape object.";
		error `format -s $shape $fmt`;
	}
} // localShapeInAttr


/**
 * This procedure returns the output (local space) attribute of the given shape.
 * NOTE: This is similar to the MPxSurfaceShape::localShapeOutAttr API function.
 */
global proc string localShapeOutAttr( string $shape )
{
    if ( objectType("-isType", "transform", $shape) ) {
        string $shapes[] = `listRelatives -s -path $shape`;
        if ( size($shapes) == 0 ) {
			string $fmt = (uiRes("m_MULibrary.kNoShapeKids2"));
            error `format -s $shape $fmt`;
		}
        $shape = $shapes[0];
    }
    if ( objectType("-isType", "mesh", $shape) )
        return "outMesh";
    else if ( objectType("-isType", "nurbsCurve", $shape) )
        return "local";
    else if ( objectType("-isType", "nurbsSurface", $shape) )
        return "local";
    else if ( objectType("-isType", "lattice", $shape) )
        return "latticeOutput";
    else if ( objectType("-isType", "subdiv", $shape) )
        return "outSubdiv";
    else {
		string $fmt = "Object \"^1s\" is not a valid shape object.";
		error `format -s $shape $fmt`;
	}
} // localShapeOutAttr


/**
 * This procedure returns the output (world space) attribute of the given shape.
 * NOTE: This is similar to the MPxSurfaceShape::worldShapeOutAttr API function.
 */
global proc string worldShapeOutAttr( string $shape )
{
    if ( objectType("-isType", "transform", $shape) ) {
        string $shapes[] = `listRelatives -s -path $shape`;
        if ( size($shapes) == 0 ) {
			string $fmt = (uiRes("m_MULibrary.kNoShapeKids3"));
            error `format -s $shape $fmt`;
		}
        $shape = $shapes[0];
    }
    if ( objectType("-isType", "mesh", $shape) )
        return "worldMesh";
    else if ( objectType("-isType", "nurbsCurve", $shape) )
        return "worldSpace";
    else if ( objectType("-isType", "nurbsSurface", $shape) )
        return "worldSpace";
    else if ( objectType("-isType", "lattice", $shape) )
        return "worldLattice";
    else if ( objectType("-isType", "subdiv", $shape) )
        return "worldSubdiv";
    else {
		string $fmt = "Object \"^1s\" is not a valid shape object.";
		error `format -s $shape $fmt`;
	}
} // worldShapeOutAttr


/**
 * Given a string of the form "*[#]*", this procedure returns the number
 * within the nth set of square brackets. If the format of the given string
 * is incorrect (does not contain n sets of square brackets), then a value
 * of -1 is returned.
 */
global proc int stringIndex( string $s, int $n )
{
    if ( $n <= 0 ) return -1;
    int $i1 = 0;
    for ( $i = 1; $i <= size($s); $i++ )
        if ( substring($s, $i, $i) == "[" ) { $i1 = $i+1; break; }
    if ( $i1 == 0 ) return -1;
    int $i2 = 0;
    for ( $i = $i1; $i <= size($s); $i++ )
        if ( substring($s, $i, $i) == "]" ) { $i2 = $i-1; break; }
    if ( $i2 < $i1 ) return -1;
    if ( $n == 1 ) return int( substring($s, $i1, $i2) );
    else if ( $i2+2 > size($s) ) return -1;
    else return stringIndex( substring($s, $i2+2, size($s)), $n-1 );
} // stringIndex


/**
 * This function gets the long name of a shape node given either the shape
 * node itself or the shape's transform node.
 */
global proc string muGetShape( string $node, int $fullPath )
{
    if ( !objExists($node) )
        return "";
    if ( nodeType($node) == "transform" ) {
        if ( $fullPath ) {
            string $sl[] = `listRelatives -s -f -ni $node`;
            return $sl[0];
        } else {
            string $sl[] = `listRelatives -s -ni $node`;
            return $sl[0];
        }
    } else {
        if ( $fullPath ) {
            string $sl[] = `ls -s -l -ni $node`;
            return $sl[0];
        } else {
            string $sl[] = `ls -s -ni $node`;
            return $sl[0];
        }
    }
} // muGetShape


/**
 * This function gets the long name of a transform node given either the
 * transform node itself or a child of the transform node.
 */
global proc string muGetTransform( string $node, int $fullPath )
{
    if ( !objExists($node) )
        return "";
    if ( nodeType($node) == "transform" ) {
        if ( $fullPath ) {
            string $sl[] = `ls -l $node`;
            return $sl[0];
        } else {
            string $sl[] = `ls $node`;
            return $sl[0];
        }
    } else {
        if ( $fullPath ) {
            string $sl[] = `listRelatives -p -f $node`;
            return $sl[0];
        } else {
            string $sl[] = `listRelatives -p $node`;
            return $sl[0];
        }
    }
} // muGetTransform


/**
 * This procedure duplicates the given shape nodes and returns the duplicate
 * shapes. It is necessary because using the MEL "duplicate" command breaks
 * the Disney Skin System.
 */
global proc string[] muDuplicateShapeNodes( string $shapes[],
                                            int $copyShadingGroup )
{
    string $dupTransforms[];
    int $shapeCnt = 0;

    string $shape;
    for ( $shape in $shapes ) {
        $shape = muGetShape( $shape, true );

        // Create a transform node for the new shape.
        string $dupTransform = `createNode transform`;

        // Copy over the transform matrix.
        string $trsName = muGetTransform( $shape, true );
        float $mat[] = `xform -q -ws -matrix $trsName`;
        xform -ws -matrix $mat[0] $mat[1] $mat[2] $mat[3] $mat[4] $mat[5]
                          $mat[6] $mat[7] $mat[8] $mat[9] $mat[10] $mat[11]
                          $mat[12] $mat[13] $mat[14] $mat[15] $dupTransform;

        // Create the shape node.
        string $type = nodeType( $shape );
        string $dupShape = `createNode -parent $dupTransform $type`;

        // Connect to original shape to access geometry attribute.
        connectAttr ( $shape + "." + worldShapeOutAttr($shape) )
                    ( $dupShape + "." + localShapeInAttr($shape) );

        // Delete history: disconnecting from original, effectively a copy of
        // the shape. We don't do a simple duplicate, because that duplicates
        // the set membership of the shape, putting the base muscle in the
        // muscle set, which is undesirable.
        //delete -ch $dupShape; // with some shape types this deletes too much
        dgeval ( $dupShape + "." + worldShapeOutAttr($shape) );
        disconnectAttr ( $shape + "." + worldShapeOutAttr($shape) )
                       ( $dupShape + "." + localShapeInAttr($shape) );

        // Set the shading group of the duplicate shape.
        if ( $copyShadingGroup ) {
            // Copy the shading group from the original shape.
            // NOTE: The following only handles a single shading group.
            string $sets[] = `listSets -type 1 -o $shape`;
            if ( size($sets) > 0 )
                sets -e -forceElement $sets[0] $dupShape;
            else
                sets -e -forceElement initialShadingGroup $dupShape;
        } else {
            // Use the default shading group.
            sets -e -forceElement initialShadingGroup $dupShape;
        }

        $dupTransforms[ $shapeCnt++ ] = $dupTransform;
    }

    // Delete unnecessary transforms and joints.
    string $children[] = `listRelatives -ni -children -type "transform"
                                        -type "joint" $dupTransforms`;
    if ( size($children) > 0 )
        delete $children;

    return $dupTransforms;
} // muDuplicateShapeNodes

/**
 *  Returns the plug $deformer.outputGeometry[#] and its destination connection
 *  in the construction history of $shape.
 *  If $deformer is not in the construction history of $shape,
 *  returns empty string array.
 */
global proc string [] muDeformerOutputConnection( string $shape,
                                                         string $deformer ) {
    string $connections[];
    string $history[];
    string $tokens[];
    int $i;
    int $guard;
    int $srcIndex = -1;
    int $destIndex = -1;
    int $lastSrcIndex = -1;
    string $node = $shape;
    for ( $guard = 0; $guard < 100; ++$guard ) {
        $connections = `listConnections -p 1 -c 1 -s 1 -d 0 $node`;
        if ( size($connections) == 0 ) break;
        $node = "";
        for ( $i = 0; $i < size($connections); $i += 2 ) {
            tokenize $connections[$i] "." $tokens;
            if ( $tokens[1] == "inMesh" ||
                 $tokens[1] == "create" ||
                 $tokens[1] == "inputGeometry" ||
                 $tokens[2] == "inputGeometry" ||
                 $tokens[1] == "inputPolymesh" ||
                 $tokens[1] == "inputSurface" ||
                 $tokens[1] == "inputCurve" ||
                 $tokens[1] == "inSubdiv" ) {
                if ( $tokens[2] == "inputGeometry" ) {
                    $destIndex = stringIndex( $tokens[1], 1 );
                } else {
                    $destIndex = -1;
                }
                tokenize $connections[$i+1] "." $tokens;
                $node = $tokens[0];
                $srcIndex = stringIndex( $tokens[1], 1 );
                if ( $lastSrcIndex == -1 || $lastSrcIndex == $destIndex ) {
                    $lastSrcIndex = $srcIndex;
                    if ( $node == $deformer ) {
                        return { $connections[$i+1], $connections[$i] };
                    }
                    break;
                }
            }
        }
        if ( $node == "" ) break;
    }
    return {};
}

/**
 *  Given a shape and deformer, returns the logical index
 *  of deformer's outputGeometry linked to the shape.
 *  in the construction history of $shape.
 *  If $deformer is not in the construction history of $shape,
 *  returns empty string array.
 */
global proc int muDeformerLogicalIndex( string $shape, string $deformer )
{
    string $connections[] = muDeformerOutputConnection( $shape, $deformer );
    if( size( $connections ) != 2 ) return -1;
    return `stringIndex $connections[0] 1`;
}

