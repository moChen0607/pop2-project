// Copyright (C) 1997-2014 Autodesk, Inc., and/or its licensors.
// All rights reserved.
//
// The coded instructions, statements, computer programs, and/or related
// material (collectively the "Data") in these files contain unpublished
// information proprietary to Autodesk, Inc. ("Autodesk") and/or its licensors,
// which is protected by U.S. and Canadian federal copyright law and by
// international treaties.
//
// The Data is provided for use exclusively by You. You have the right to use,
// modify, and incorporate this Data into other products for purposes authorized 
// by the Autodesk software license agreement, without fee.
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND. AUTODESK
// DOES NOT MAKE AND HEREBY DISCLAIMS ANY EXPRESS OR IMPLIED WARRANTIES
// INCLUDING, BUT NOT LIMITED TO, THE WARRANTIES OF NON-INFRINGEMENT,
// MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE, OR ARISING FROM A COURSE 
// OF DEALING, USAGE, OR TRADE PRACTICE. IN NO EVENT WILL AUTODESK AND/OR ITS
// LICENSORS BE LIABLE FOR ANY LOST REVENUES, DATA, OR PROFITS, OR SPECIAL,
// DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES, EVEN IF AUTODESK AND/OR ITS
// LICENSORS HAS BEEN ADVISED OF THE POSSIBILITY OR PROBABILITY OF SUCH DAMAGES.

// ---------------------------------------------------------------------------
//
//  evalGeoUtils
//
//  Sample context to test the geoUtils command
//
//  Carlos Gonzalez-Ochoa
//
//  (c) Walt Disney Feature Animation
//
// ---------------------------------------------------------------------------
//
//
// Usage:
//
// To use create some Nurbs, meshes and tile subdivision
//
// Load the objects into the context using the mel command
//
// mel> evalGeoUtilsLoadSelection
//
// This takes the annoying flickering
//
// Enter the context
//
// mel> setToolTo evalGeoUtilsCtx
//
// Start clicking
//
// To change some attributes, set the global variables:
// 
// $GUObjectRadius  = <val>   radius of the cone
//
// $MdGUUseLocator = <bool>   display a locator
//
//

// Set tool to 
// setToolTo evalGeoUtilsCtx;

global proc evalGeoUtilsLoadSelection()
{
    global string $MdGUOrigSelection[];
    global string $MdGUSelection[];
    global int    $MdGUUseLocator = 0;
    global string $MdGULocator;
    global int    $MdGUCLoadSelection;  // should we load selection

    $MdGUCLoadSelection = 0;// no need to load selection again

    string $sl[] = `ls -sl`;
    $MdGUOrigSelection = $sl;

    clear $MdGUSelection;

    int $n=0;
    for ($obj in $sl) {

	if (nodeType($obj) == "transform") {
	    string $rel[] = `listRelatives -s $obj`;
	    $obj = $rel[0];
	} 
	//print ("object: " + $obj + "\n");
	if (nodeType($obj) == "nurbsSurface") {

	    //print ("We have a nurbs\n");
	    $MdGUSelection[$n] = $obj;
	    $n++;
		
	} else if (nodeType($obj) == "mesh") {

	    //print ("We have a mesh " + $obj + "\n");
	    // check for subdivs
	    // If so, then add the tiles
	    string $struct[] = MdGetSubdDAGStructure($obj);
	    
	    if (size($struct) == 0) {
		// only a mesh
		$MdGUSelection[$n] = $obj;
		$n++;
	    } else {
		// Tiles
		// Get the name of the tiles
		string $tiles[] = `listRelatives $struct[2]`;
		int $nn = size($tiles);
		appendStringArray($MdGUSelection, $tiles, $nn);
		// correct counter
		$n = size($MdGUSelection);
	    }
	}
    }
    select -cl;
}

global proc evalGeoUtilsCtxPress()
{
    global string $MdGUOrigSelection[];
    global string $MdGUSelection[];
    global int    $MdGUUseLocator = 0;
    global string $MdGULocator;
    global int    $MdGUCLoadSelection;  // should we load selection

    //    print ("Size of selection: " + size($MdGUSelection) + "\n");

    if ($MdGUCLoadSelection == true || size($MdGUSelection) == 0) {
		print (uiRes("m_evalGeoUtilsContext.kLoadingSelection"));
		evalGeoUtilsLoadSelection();
    }
	
    if (size($MdGUSelection) == 0) {
		warning (uiRes("m_evalGeoUtilsContext.kNoObjectsSelected"));
		setToolTo selectSuperContext;	
    }
	
    // Create a locator
    if ($MdGUUseLocator) {
		if (objExists($MdGULocator) == false) {
			$MdGULocator = `createNode locator`;
		}
    }
	
    // callback function
    // 0 - setup
    global string $MdGeoUtilsContextCB;



    if ($MdGeoUtilsContextCB != "") {
		string $cmd = ($MdGeoUtilsContextCB + "( 0, 0, 0, 0, 0, 0, 0)");
		catch(eval($cmd));
    }

    //print "Context was correctly set\n";

    select -cl;
}

global proc evalGeoUtilsCtxDrag()
{
    //    print "evalTileContexDrag\n"; 
    global string $MdGUSelection[];
    global int    $MdGUUseLocator;
    global string $MdGULocator;

    draggerContext -e -sp screen evalGeoUtilsCtx;
    draggerContext -e -pr sketchPlane evalGeoUtilsCtx;
    float $ws[] = `draggerContext -query -dragPoint evalGeoUtilsCtx`;
    
    //print ("View plane:   " + $ws[0] + " " + $ws[1] + " " + $ws[2] + "\n");
    
//     print ("Selection\n");
//     print $MdGUSelection;
//     print ("----\n");

    float $wp[]=  `geoUtils -co -p -n -oi -sp $ws[0] $ws[1] $MdGUSelection`;

    if (size($wp) > 0) {


	if ($MdGUUseLocator) {
	    if (objExists($MdGULocator)) {
		move -a $wp[0] $wp[1] $wp[2] $MdGULocator;
	    }
	}

	// callback function
	// 1 - setup
	
	global string $MdGeoUtilsContextCB;

	if ($MdGeoUtilsContextCB != "") {
	    string $cmd = ($MdGeoUtilsContextCB + "( 1, " 
			   + $wp[0] + "," + $wp[1] + "," + $wp[2] + ","   
			   + $wp[3] + "," + $wp[4] + "," + $wp[5] 
			   + ")");
	    catch(eval($cmd));
	}
	refresh();
    }
}

global proc evalGeoUtilsCtxRelease()
{
    global string $MdGUOrigSelection[];
    global string $MdGeoUtilsContextCB;

    global int    $MdGUUseLocator;
    global string $MdGULocator;

    if ($MdGUUseLocator) {
	if (objExists($MdGULocator)) {
	    string $pr[] = `listRelatives -p $MdGULocator`;
	    delete $pr;
	    $MdGULocator = "";
	}
    }

    //    select -r $MdGUOrigSelection;

    if ($MdGeoUtilsContextCB != "") {
	string $cmd = ($MdGeoUtilsContextCB + "( 2, 0, 0, 0, 0, 0, 0)");
	catch(eval($cmd));
    }
    refresh();
}

//
//
//
global string $MdGeoUtilsContextCB = "ETCCreateTestCurve2";

global proc ETCCreateTestCurve2(int $what, 
			      float $p0, float $p1, float $p2, 
			      float $n0, float $n1, float $n2)
{
    global string $GUObject;
    global string $GUAngleBetween;

    global float $GUObjectRadius=.1;

    switch ($what) {
    case 0:
	string $objs[] = `cone -p 0 0 0 -ax 0 1 0 -ssw 0 -esw 360 
	    -r $GUObjectRadius -hr 6 -d 3 -ut 0 -tol 0.01 -s 8 -nsp 1 -ch 0`;
	$GUObject = $objs[0];
	//	$GUObject = `curve -d 3 -p 0 0 0 -p -0.0978641 0.631212 0 -p -0.125825 1.414126 0 -p 0.0978642 1.74966 0 -k 0 -k 0 -k 0 -k 1 -k 1 -k 1`;

	$GUAngleBetween = `createNode angleBetween`;
	setAttr ($GUAngleBetween + ".vector1") 0 1 0;
	setAttr ($GUAngleBetween + ".vector2") 0 1 0;
	connectAttr -f ($GUAngleBetween + ".euler") ($GUObject + ".rotate");
	break;
    case 1:
	if ($GUObject != "" && $GUAngleBetween != "") {
	    move -a $p0 $p1 $p2 $GUObject;
	    setAttr ($GUAngleBetween + ".vector2") $n0 $n1 $n2;
	}
	break;
    case 2:
	$GUObject = "";
	$GUAngleBetween = "";
	break;
    }
}

global proc evalGeoUtilsContext()
{
    if (`draggerContext -q -ex evalGeoUtilsCtx`) {
	deleteUI evalGeoUtilsCtx;
    }
    global string $MdGUSelection[];
    clear $MdGUSelection;

    eval("draggerContext " +
	"-pressCommand    \"evalGeoUtilsCtxPress\"    " + 
	"-dragCommand     \"evalGeoUtilsCtxDrag\"     " +
	"-releaseCommand  \"evalGeoUtilsCtxRelease\"  " +
	"-cursor          \"crossHair\"		      " +
	"-image1          \"evalGeoUtilsContext.xpm\" " +
	 "evalGeoUtilsCtx");

    setToolTo evalGeoUtilsCtx;
}

global proc evalGeoUtilsSetCtx()
{
    setToolTo evalGeoUtilsCtx;
}
