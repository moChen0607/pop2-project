// Copyright (C) 1997-2013 Autodesk, Inc., and/or its licensors.
// All rights reserved.
//
// The coded instructions, statements, computer programs, and/or related
// material (collectively the "Data") in these files contain unpublished
// information proprietary to Autodesk, Inc. ("Autodesk") and/or its licensors,
// which is protected by U.S. and Canadian federal copyright law and by
// international treaties.
//
// The Data is provided for use exclusively by You. You have the right to use,
// modify, and incorporate this Data into other products for purposes authorized 
// by the Autodesk software license agreement, without fee.
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND. AUTODESK
// DOES NOT MAKE AND HEREBY DISCLAIMS ANY EXPRESS OR IMPLIED WARRANTIES
// INCLUDING, BUT NOT LIMITED TO, THE WARRANTIES OF NON-INFRINGEMENT,
// MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE, OR ARISING FROM A COURSE 
// OF DEALING, USAGE, OR TRADE PRACTICE. IN NO EVENT WILL AUTODESK AND/OR ITS
// LICENSORS BE LIABLE FOR ANY LOST REVENUES, DATA, OR PROFITS, OR SPECIAL,
// DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES, EVEN IF AUTODESK AND/OR ITS
// LICENSORS HAS BEEN ADVISED OF THE POSSIBILITY OR PROBABILITY OF SUCH DAMAGES.

/**
 * @file xgmMakeCurvesDynamicHairs.mel
 * @brief Based on the Maya command, this version adds a return type
 *
 * <b>CONFIDENTIAL INFORMATION: This software is the confidential and
 * proprietary information of Walt Disney Animation Studios ("WDAS").
 * This software may not be used, disclosed, reproduced or distributed
 * for any purpose without prior written authorization and license
 * from WDAS. Reproduction of any section of this software must include
 * this legend and all copyright notices.
 * Copyright Disney Enterprises, Inc. All rights reserved.</b>
 *
 * @author Alias
 * @author Patrick Witting
 * @author Stephen D. Bowline
 *
 * @version Created 12/30/04  (Originally sourced from Maya)
 */

//
// This function comes directly form Maya's function makeCurvesDynamicHairs
// and as such any changes should be clearly denoted. Also, to make comparing
// this file against the Maya official file...
//
//      DO NOT CHANGE THE FORMATTING OF THIS MEL SCRIPT
//
// This file matches the original in every way, including spacing, so using
// xdiff can be used to easily spot upgrades should this file stop working.
//

global proc string[] xgmMakeCurvesDynamicHairs()
{
        // XGEN: Adding return information to Maya's makeCurvesDynamicHairs.
        string $result[] = { "", "", "" };

	string $hsystems[] = `getSelectedHairSystems`;	
	string $hsys = "" ;
	if( size( $hsystems ) > 0 ){
		$hsys = $hsystems[0];
	} 
	int $i, $j, $k, $l;
	string $curves[] = `ls -sl -dag -type nurbsCurve`;

	if( size( $curves ) < 1 ){
                warning (uiRes("m_xgmMakeCurvesDynamicHairs.kNoCurvesSelectedToMakeDynamic"));
		// XGEN: Change to return result
                return $result; 
	}
	string $parent = "";
	int   $lastIndex[] = {0};
	int $madeHairCurve = false;
	string $hsysGroup = "";
	string $hsysOutputHairGroup = "";
	for( $i = 0; $i < size( $curves ); $i++ ){
		string $curve = $curves[$i];
		string $con[] = `listConnections -sh 1 ($curve + ".worldSpace[0]")`;
		int $j;
		int $attachedToHairCurve = false;
		for( $j = 0; $j < size( $con ); $j++ ){
			string $type = nodeType( $con[ $j ] );
			if( $type == "follicle" ){
				$attachedToHairCurve = true;
				continue;
			}
		}
		if( $attachedToHairCurve ){
			continue;
		}
		int $intermediateObject = `getAttr ($curve + ".io")`;
		if( 0 != $intermediateObject ){
			continue;
		}
		


		$madeHairCurve = true;
		if( $hsys == "" ){
			// create the first time we hit a valid curve
			$hsys	 = `createNode hairSystem`;
			// we want uniform stiffness because the curves
			// are initially point locked to both ends 
			removeMultiInstance -break true ($hsys + ".stiffnessScale[1]");
			setAttr ($hsys + ".clumpWidth") 0.00001;
			setAttr ($hsys + ".hairsPerClump") 1;
			connectAttr time1.outTime ($hsys + ".currentTime");
		}
		string $hsysParent[] = `listTransforms $hsys`;
		if( size($hsysParent) > 0  ){
			if( $hsysGroup == "" ){
				$hsysGroup = ($hsysParent[0] + "Follicles");
				if( !objExists($hsysGroup ) ){
					$hsysGroup = `group -em -name $hsysGroup`;
				}
			}
			if( $hsysOutputHairGroup == "" ){
				$hsysOutputHairGroup = ($hsysParent[0] + "OutputCurves");
				if( !objExists($hsysOutputHairGroup ) ){
					$hsysOutputHairGroup = `group -em -name $hsysOutputHairGroup`;
				}
			}
		}

		// Determine if the curve is a COS or just a regular curve.
		// This is cloned from "convertCurvesToStrokes.mel"
		int $COS = 0;
		string $relatives[] = `listRelatives -ap -p $curve`;
		for ($j = 0; $j < size( $relatives ); $j++) {
			string $testMe = $relatives[$j];
			if (`nodeType $testMe` == "transform") {
				string $testList[] = `listRelatives -ap -p $testMe`;
				for ($k = 0; $k < size( $testList ); $k++) {
					string $subTest = $testList[$k];
					if (`nodeType $subTest` == "curveVarGroup") {
						string $testList2[] = `listRelatives -ap -p $subTest`;
						for ($l = 0; $l < size( $testList2 ); $l++) {
							if (`nodeType $testList2[$l]` == "nurbsSurface") {
								$COS = 1;
								$parent = $testList2[$l];
								$j = size( $relatives );
								$k = size( $testList  );
								$l = size( $testList2 );
							}
						}
					}
					else {
						if (`nodeType $testList[$k]` == "nurbsSurface") {
							$COS = 1;
							$parent = $testList[$k];
							$j = size( $relatives);
							$k = size( $testList );
						}
					}
				}
			}
			else if (`nodeType $testMe` == "nurbsSurface") {
				$parent = $testMe;
				$COS = 1;
				$j = size( $relatives);
			}
		}
		if ( $COS == 1 ) {
			// the name in $curves is something like nurbsPlane->curve1: this
			// has illegal characters for a name so we use the default naming
			// string $cFS = `createNode "curveFromSurfaceCoS" -name ($curves[$i] + "cFS")`;
			string $cFS = `createNode "curveFromSurfaceCoS"`;
			// Do we need to check the index of the WS connections?
			connectAttr ($curve + ".ws[0]") ($cFS + ".curveOnSurface");
			connectAttr ($parent + ".ws[0]") ($cFS + ".inputSurface");
			$curve = $cFS;
		}


		string $surf = ""; // no surface to attach to
		int $doRest = false;
		string $hname = createHairCurveNode($hsys, $surf,
							0.0, 0.0, 0, true, true, 
							$doRest, false, $curve, 1.0, $lastIndex,
							$hsysGroup, $hsysOutputHairGroup, 1);
		if( size( $hname ) > 0 ){
                        // XGEN: pointLock set to 1 (base) instead of 3 (both)
			setAttr ( $hname + ".pointLock" ) 1;
			setAttr ( $hname + ".restPose" ) 1;
		}
	}
	// delete the follicle groups if we did not add any hairs to them
	if( objExists($hsysGroup ) ){
		string $shapes[] = `ls -s -dag $hsysGroup`;
		if( 0 == size($shapes) ){
			delete $hsysGroup;
		}
	}
	if( objExists($hsysOutputHairGroup ) ){
		string $shapes[] = `ls -s -dag $hsysOutputHairGroup`;
		if( 0 == size($shapes) ){
			delete $hsysOutputHairGroup;
		}
	}
	if( $madeHairCurve ){
		select $hsys;
	} else {
		warning (uiRes("m_xgmMakeCurvesDynamicHairs.kAlreadyDynamic"));
	}

        // XGEN: Add the following to the return values for the hairsystem
        //       and the output hair group
        if ( objExists($hsys ) )
                $result[0] = $hsys;

        if ( objExists($hsysOutputHairGroup ) )
                $result[1] = $hsysOutputHairGroup;


    return $result;
}
