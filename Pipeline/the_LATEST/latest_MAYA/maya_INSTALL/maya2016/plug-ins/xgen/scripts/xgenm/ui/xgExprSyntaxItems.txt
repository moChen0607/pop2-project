abs<br>float abs(float x)<br>absolute value of x
acos<br>float acos(float angle)<br>arc cosine in radians
acosd<br>float acosd(float angle)<br>arc cosine in degrees
angle<br>float angle(vector a,vector b)<br>angle between two vectors (in radians)
asin<br>float asin(float angle)<br>arc sine in radians
asind<br>float asind(float angle)<br>arc sine in degrees
atan<br>float atan(float angle)<br>arc tangent in radians
atan2<br>float atan2(float y,float x)<br>arc tangent in radians of y/x between -PI and PI
atan2d<br>float atan2d(float y,float x)<br>arc tangent in degrees of y/x between -180 and 180
atand<br>float atand(float angle)<br>arc tangent in degrees
bias<br>float bias(float x, float g)<br>Variation of gamma where values less than 0.5 pull the curve down<br>and values greater than 0.5 pull the curve up<br>pow(x,log(b)/log(0.5))
boxstep<br>float boxstep(float x,float a)<br> if x &lt; a then 0 otherwise 1
ccellnoise<br>color cellnoise(vector v)<br>cellnoise generates a field of constant colored cubes based on the integer location.<br>This is the same as the prman cellnoise function.
ccurve<br>color curve(float param,float pos0,color val0,int interp0,float pos1,color val1,int interp1,[...])<br><br>Interpolates color ramp given by control points at 'param'. Control points are specified <br>by triples of parameters pos_i, val_i, and interp_i. Interpolation codes are <br>0 - none, 1 - linear, 2 - smooth, 3 - spline, <br>4 - monotone (non oscillating spline)
ceil<br>float ceil(float a)<br>next higher integer
cellnoise<br>float cellnoise(vector v)<br>cellnoise generates a field of constant colored cubes based on the integer location.<br>This is the same as the prman cellnoise function.
cfbm<br>color cfbm(vector vint octaves=6,float lacunarity=2,float gain=.5)
cfbm4<br>color cfbm4(vector v,float time,int octaves=6,float lacunarity=2,float gain=.5)
choose<br>float choose(float index,float choice1, float choice2, [...])<br>Chooses one of the supplied choices based on the index (assumed to be in range [0..1]).
clamp<br>float clamp(float x,float lo,float hi)<br>constrain x to range [lo,hi]
cnoise<br>color cnoise ( vector v)<br>color noise formed with original perlin noise at location (C2 interpolant)
cnoise4<br>color cnoise4 ( vector v,float t)<br>4D color noise formed with original perlin noise at location (C2 interpolant)
compress<br>float compress(float x,float lo,float hi)<br>Remaps x in [0,1] to [lo,hi]
contrast<br>float contrast(float x,float x)<br>Adjust the contrast.&nbsp; For c from 0 to 0.5, the contrast is decreased.&nbsp; For c &gt; 0.5, the contrast is increased.
cos<br>float cos(float angle)<br>cosine in radians
cosd<br>float cosd(float angle)<br>cosine in degrees
cosh<br>float cosh(float angle)<br>hyperbolic cosine in radians
cross<br>vector cross(vector a,vector b)<br>vector cross product
cturbulence<br>color cturbulence(vector v,int octaves=6,float lacunarity=2,float gain=.5)<br>Absolute value of each noise term is taken. This gives billowy appearance
curve<br>float curve(float param,float pos0,float val0,int interp0,float pos1,float val1,int interp1,[...])<br><br>Interpolates a 1D ramp defined by control points at 'param'. Control points are specified <br>by triples of parameters pos_i, val_i, and interp_i. Interpolation codes are <br>0 - none, 1 - linear, 2 - smooth, 3 - spline, <br>4-monotone (non oscillating spline)
cvoronoi<br>color cvoronoi(vector v, int type=1,float jitter=0.5, float fbmScale=0, int fbmOctaves=4,float fbmLacunarity=2, float fbmGain=.5)<br>returns color in cellular pattern. It is a jittered variant of cellnoise.
cycle<br>int cycle(int index, int loRange, int hiRange )<br>Cycles through values between loRange and hiRange based on supplied index.<br>This is an offset "mod" function. The result is rotates v such that the<br>Y axis points in the given up direction
deg<br>float deg(float angle)<br>radians to degrees
dist<br>float dist(vector a, vector b)<br>distance between two points
dot<br>float dot(vector a,vector b)<br>vector dot product
exp<br>float exp(float x)<br>E raised to the x power
expand<br>float expand(float x,float lo,float hi)<br>Remaps x in [lo,hi] to [0,1]
fbm<br>float fbm(vector v,int octaves=6,float lacunarity=2,float gain=.5)<br>fbm (Fractal Brownian Motion) is a multi-frequency noise function. <br>The base frequency is the same as the "noise" function. The total <br>number of frequencies is controlled by octaves. The lacunarity is the <br>spacing between the frequencies - a value of 2 means each octave is <br>twice the previous frequency. The gain< controls how much each <br>frequency is scaled relative to the previous frequency.
fbm4<br>float fbm4(vector v,float time,int octaves=6,float lacunarity=2,float gain=.5)<br>fbm (Fractal Brownian Motion) is a multi-frequency noise function. <br>The base frequency is the same as the "noise" function. The total <br>number of frequencies is controlled by octaves. The lacunarity is the <br>spacing between the frequencies - a value of 2 means each octave is <br>twice the previous frequency. The gain< controls how much each <br>frequency is scaled relative to the previous frequency.
fit<br>float fit(float x,float a1,float b1,float a2,float b2)<br>Linearly remaps x from the range [a1,b1] to the range [a2,b2]<br><br>Note: This extrapolates if x is outside [a1,b1]<br>To clamp the result, use fit(x,a1,b1,a2,b2)->clamp(a2,b2)
floor<br>float floor(float a)<br>next lower integer
fmod<br>float fmod(float x,float y)<br>remainder of x/y (also available as % operator)
gamma<br>float gamma(float x, float g)<br>Gamma correction of x with gamma factor g
gaussstep<br>float gasussstep(float x,float a,float b)<br> if x &lt; a then 0, if x &gt; b then 1, and<br>x transitions smoothly (exponentially) when &lt; x &lt; b
hash<br>float hash(float seed1,[float seed2, ...])<br>Like rand, but with no internal seeds. Any number of seeds may be given<br>and the result will be a random function based on all the seeds.
hsi<br>color  hsi(color x, float h, float s, float i, float map=1)<br>The hsi function shifts the hue by h<br>(in degrees) and scales the saturation and intensity by s and i<br>respectively.&nbsp; An map may be supplied which will control the shift<br>- the full shift will happen when the map is one and no shift will<br>happen when the map is zero.&nbsp; The shift will be scaled back for<br>values between zero and one.
hsltorgb<br>color hsltorgb(color hsl)<br>RGB to HSL color space conversion.<br>HSL is Hue, Saturation, Lightness (all in range [0..1] )<br>These functions have also been extended to support rgb and hsl values<br>outside of the range [0..1] in a reasonable way.&nbsp; For any rgb or<br>hsl value (except for negative s values), the conversion is<br>well-defined and reversible.
hypot<br>float hypot(vector v)<br>length of 2d vector [x,y]
invert<br>float invert(float a)<br>Defined as 1-x
length<br>float length(vector v)<br>length of vector
linearstep<br>float linearstep(float x,float a,float b)<br> if x &lt; a then 0, if x &gt; b then 1, and<br>x transitions linearly when &lt; x &lt; b 
log<br>float log(float x)<br>Natural logarithm
log10<br>float log10(float x)<br>Base 10 logarithm
max<br>float max(float a,float b)<br>greater of a and b
midhsi<br>color midhsi(color x, float h, float s, float i, float map, float falloff=1, int interp=0)<br>The midhsi function is just like the hsi function except that<br>the control map is centered around the mid point (value of 0.5)<br>and can scale the shift in both directions.
min<br>float min(float a,float b)<br>lesser of a and b
mix<br>mix(float a,float b,float alpha)<br>Blend of a and b according to alpha.
noise<br>float noise ( vector v ) <br><br>float noise ( float x, float y )<br>float noise ( float x, float y, float z )<br>float noise ( float x, float y, float z, float w )<br>Original perlin noise at location (C2 interpolant)
norm<br>vector norm(vector v)<br>vector scaled to unit length
ortho<br>vector angle(vector a,vector b)<br>normalized vector orthogonal to a and b scaled to unit length
pick<br>int pick(float index, int loRange, int hiRange, [float weights, ...] )<br>Picks values randomly between loRange and hiRange based on supplied index (which is<br>automatically hashed).&nbsp; The values will be distributed according<br>to the supplied weights.&nbsp; Any weights not supplied are assumed to<br>be 1.0.
pnoise<br>float pnoise ( vector v, vector period )<br>periodic noise
pow<br>float pow(float x)<br>x to the y power, also available as ^
printf<br>printf(string format,[vec0, vec1,  ...])<br>Prints out a string to STDOUT, Format parameter allowed is %v
pvoronoi<br>color pvoronoi(vector v, int type=1,float jitter=0.5, float fbmScale=0, int fbmOctaves=4,float fbmLacunarity=2, float fbmGain=.5)<br>returns center of voronoi cell.
rad<br>float rad(float deg)<br>degrees to radians
remap<br>remap(float x, float<br>source, float range, float falloff, int interp)<br>General remapping function.<br>When x is within +/- <i>range</i> of source, the result is one.<br>The result falls to zero beyond that range over <i>falloff</i> distance.<br>The falloff shape is controlled by <i>interp</i>. Numeric values<br>or named constants may be used:<br>&nbsp;&nbsp;&nbsp;&nbsp;int <b>linear</b><br>= 0<br>&nbsp;&nbsp;&nbsp;&nbsp;int <b>smooth</b> = 1<br>&nbsp;&nbsp;&nbsp;&nbsp;int <b>gaussian</b> = 2<br>
rgbtohsl<br>color rgbtohsl(color rgb)<br>RGB to HSL color space conversion.<br>HSL is Hue, Saturation, Lightness (all in range [0..1] )<br>These functions have also been extended to support rgb and hsl values<br>outside of the range [0..1] in a reasonable way.&nbsp; For any rgb or<br>hsl value (except for negative s values), the conversion is<br>well-defined and reversible.
rotate<br>vector rotate(vector v,vector axis,float angle)<br>rotates v around axis by given angle (in radians)
round<br>float round(float x)<br>constrain x to range [lo,hi]
saturate<br>color saturate(color val, float amt)<br>Scale saturation of color by amt.<br>The color is scaled around the rec709 luminance value,<br>and negative results are clamped at zero.<br>
sin<br>float sin(float angle)<br>sine in radians
sind<br>float sind(float angle)<br>sine in degrees
sinh<br>float sinh(float angle)<br>hyperbolic sine in radians
smoothstep<br>float smoothstep(float x,float a,float b)<br> if x &lt; a then 0, if x &gt; b then 1, and<br>x transitions smoothly (cubic) when &lt; x &lt; b
snoise<br>float snoise ( vector v)<br>signed noise w/ range -1 to 1 formed with original perlin noise at location (C2 interpolant)
snoise4<br>float snoise4 ( vector v,float t)<br>4D signed noise w/ range -1 to 1 formed with original perlin noise at location (C2 interpolant)
spline<br>float spline(float param,float y1,float y2,float y3,float y4,[...])<br><br>Interpolates a set of values to the parameter specified where y1, ..., yn are<br>distributed evenly from [0...1]
sqrt<br>float sqrt(float x)<br>square root
tan<br>float tan(float angle)<br>tangent in radians
tand<br>float tand(float angle)<br>tangent in degrees
tanh<br>float tanh(float angle)<br>hyperbolic tangent in radians
turbulence<br>float turbulence(vector v,int octaves=6,float lacunarity=2,float gain=.5)<br>Absolute value of each noise term is taken. This gives billowy appearance
up<br>vector up(vector P,vector upvec)<br>rotates v such that the Y axis points in the given up direction
vfbm<br>vector vfbm(vector vint octaves=6,float lacunarity=2,float gain=.5)
vfbm4<br>vector vfbm4(vector v,float time,int octaves=6,float lacunarity=2,float gain=.5)
vnoise<br>vector vnoise ( vector v)<br>vector noise formed with original perlin noise at location (C2 interpolant)
vnoise4<br>vector vnoise4 ( vector v,float t)<br>4D vector noise formed with original perlin noise at location (C2 interpolant)
voronoi<br>float voronoi(vector v, int type=1,float jitter=0.5, float fbmScale=0, int fbmOctaves=4,float fbmLacunarity=2, float fbmGain=.5)<br>voronoi is a cellular noise pattern. It is a jittered variant of cellnoise.
vturbulence<br>vector vturbulence(vector v,int octaves=6,float lacunarity=2,float gain=.5)<br>Absolute value of each noise term is taken. This gives billowy appearance
wchoose<br>float wchoose(float index,float choice1, float weight1, float choice2, float weight2, [...] )<br>Chooses one of the supplied choices based on the index (assumed to be in range[0..1]).<br>The values will be distributed according to the supplied weights.
rand<br>float rand([float min, float max] [,float seed])<br>Generates a random number.  With no parameters, the number generated is between<br>0 and 1.  Optionally, two parameters can be passed in to give a range for the<br>random number. In either case a seed value can be given that will ensure that<br>the number returned is random, but predictable (always "x" when passed "y").
shadow<br>shadow( string x)<br>Evaluates the passed in expression only during the shadow pass of a render.<br>Useful for changing length, width, density, etc. between the color and shadow<br>passes of a render. When not in the shadow pass this function evaluates to 1.0,<br>so it should be used as a multiplier.
map<br>map( string mapname [, float s, float t] [, int channel] )<br>Evaluates the mapname at the current (u,v) or the provided (s,t).
alignU<br>alignU( [X] )<br>Align the primitive with a given vector.<br>If no parameter is passed then a default of [0,1,0] will be used<br>with the result being "grow up". When a parameter is passed it makes<br>most sense to pass the same parameter to all three expressions.<br>The parameter can be an expression and need not be normalized.
alignV<br>alignV( [X] )<br>Align the primitive with a given vector.<br>If no parameter is passed then a default of [0,1,0] will be used<br>with the result being "grow up". When a parameter is passed it makes<br>most sense to pass the same parameter to all three expressions.<br>The parameter can be an expression and need not be normalized.
alignN<br>alignN( [X] )<br>Align the primitive with a given vector.<br>If no parameter is passed then a default of [0,1,0] will be used<br>with the result being "grow up". When a parameter is passed it makes<br>most sense to pass the same parameter to all three expressions.<br>The parameter can be an expression and need not be normalized.
$u<br>The u parameters of the underlying surface.
$v<br>The v parameters of the underlying surface.
$cLength<br>The final, computed length of the current primitive
$cWidth<br>The final, computed width of the current primitive
$cDepth<br>The final, computed depth of the current primitive without displacement.
$Cs<br>Color surface for the current primitive.
$cam<br>The current camera id.
$aCount<br>The number of archive used by the current archive primitive.
$faceId<br>The current face id.
$frame<br>The current frame being evaluated.
$id<br>The current primitive's ID (useful for fx modules).
$P<br>The surface point at which the primitive is being evaluated.
$Pg<br>The surface point without displacement.
$Pref<br>The reference surface point at which the primitive is being evaluated.
$Prefg<br>The reference surface point without displacement.
$Pw<br>The surface point at which the primitive is being evaluated.
$Pgw<br>The surface point without displacement. World space.
$Prefw<br>The reference surface point at which the primitive is being evaluated. 
$Prefgw<br>The reference surface point without displacement. World space.
$N<br>The surface normal at which the primitive is being evaluated.
$Ng<br>The surface normal without displacement.
$Nref<br>The reference surface normal at which the primitive is being evaluated.
$Nrefg<br>The reference surface normal without displacement.
$dPdu<br>The surface dPdu at which the primitive is being evaluated.
$dPdug<br>The surface dPdu without displacement.
$dPduref<br>The reference surface dPdu at which the primitive is being evaluated.
$dPdurefg<br>The reference surface dPdu without displacement.
$dPdv<br>The surface dPdv at which the primitive is being evaluated.
$dPdvg<br>The surface dPdv without displacement.
$dPdvref<br>The reference surface dPdv at which the primitive is being evaluated.
$dPdvrefg<br>The reference surface dPdv
$patchId<br>The current patch's ID.
$descId<br>The current description's ID.
$objectId<br>alias for $patchId.
PI<br>The ratio of the circumference of a circle to its diameter (3.14159265358979323846).
E<br>The base of natural logarithms (2.7182818284590452354).