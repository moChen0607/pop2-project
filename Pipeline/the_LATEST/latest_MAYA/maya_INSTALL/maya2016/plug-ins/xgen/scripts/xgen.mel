// Copyright (C) 1997-2014 Autodesk, Inc., and/or its licensors.
// All rights reserved.
//
// The coded instructions, statements, computer programs, and/or related
// material (collectively the "Data") in these files contain unpublished
// information proprietary to Autodesk, Inc. ("Autodesk") and/or its licensors,
// which is protected by U.S. and Canadian federal copyright law and by
// international treaties.
//
// The Data is provided for use exclusively by You. You have the right to use,
// modify, and incorporate this Data into other products for purposes authorized 
// by the Autodesk software license agreement, without fee.
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND. AUTODESK
// DOES NOT MAKE AND HEREBY DISCLAIMS ANY EXPRESS OR IMPLIED WARRANTIES
// INCLUDING, BUT NOT LIMITED TO, THE WARRANTIES OF NON-INFRINGEMENT,
// MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE, OR ARISING FROM A COURSE 
// OF DEALING, USAGE, OR TRADE PRACTICE. IN NO EVENT WILL AUTODESK AND/OR ITS
// LICENSORS BE LIABLE FOR ANY LOST REVENUES, DATA, OR PROFITS, OR SPECIAL,
// DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES, EVEN IF AUTODESK AND/OR ITS
// LICENSORS HAS BEEN ADVISED OF THE POSSIBILITY OR PROBABILITY OF SUCH DAMAGES.

/**
 * @file xgen.mel
 * @brief Contains the xgen MEL procedure.
 *
 * <b>CONFIDENTIAL INFORMATION: This software is the confidential and
 * proprietary information of Walt Disney Animation Studios ("WDAS").
 * This software may not be used, disclosed, reproduced or distributed
 * for any purpose without prior written authorization and license
 * from WDAS. Reproduction of any section of this software must include
 * this legend and all copyright notices.
 * Copyright Disney Enterprises, Inc. All rights reserved.</b>
 *
 * @author Ernie Petti
 * @author Thomas V Thompson II
 * @author Stephen D. Bowline
 * @author Ying Liu
 *
 * @version Created 05/17/02
 */

/** 
 * This procedure sets up 3d paint context presets for use with xgen
 */
proc xgenInit3dPaintCtx()
{
	string $regionMapCtx = "xgRegionMap3dPaintContext";
	if( !`art3dPaintCtx -exists $regionMapCtx` ) {

		// The following line saves the settings of the brush to a string,
		// so that they are remembered between Maya sessions. Unfortunately, 
		// restoring the "dragSlider" setting (i.e. calling art3dPaintCtx -e -dragSlider "none" )
		// changes the current mouse cursor icon momentarily. To avoid this, we will 
		// simply not remember brush settings inbetween sessions. see MAYA-27958.
		//rememberCtxSettings `art3dPaintCtx -i1 "art3dPaint.png" $regionMapCtx`;
		
		art3dPaintCtx -i1 "art3dPaint.png" $regionMapCtx;
		art3dPaintCtx -e  -opacity 1.0  -alphablendmode "Constant" -mappressure "Radius" $regionMapCtx;
	}
}

global proc xgenInitFilters() 
{
    if (`itemFilter -exists renderableObjectShapeFilter`)
    {
        itemFilter -e
                -byType "xgmNurbsPatch"
                -byType "xgmSubdPatch"
                -classification "builtIn"
                renderableObjectShapeFilter;

        //  Need to delete and recreate these guys as they have copies
        //  of the old filter.
        //
        if (`itemFilter -exists renderableObjectsAndSetsFilter`) {
            itemFilter -e -cls "user" renderableObjectsAndSetsFilter;
            delete renderableObjectsAndSetsFilter;
        }
        if (`itemFilter -exists lightLinkingObjectFilter`) {
            itemFilter -e -cls "user" lightLinkingObjectFilter;
            delete lightLinkingObjectFilter;
        }
        itemFilter 
                -union "renderableObjectShapeFilter" "renderableObjectSetFilter"
                -text (uiRes("m_xgen.kRenderableObj"))
                -category "Multilister"
                -classification "builtIn"
                renderableObjectsAndSetsFilter;

        itemFilter 
                -union "renderableObjectsAndSetsFilter" "DefaultShadingGroupsFilter"
                -classification "builtIn"
                lightLinkingObjectFilter;
    }
}


/**
 * This procedure does all the setup needed to load everything related to
 * xgen, including all the plug-ins, setting up menus and shelves, and
 * setting up all global variables and preferences.
 */
global proc xgen()
{
    global int $xgmUseHandler = 0;

    // Bring in the XGen python api
    eval( "python( \"import xgenm as xg\" )" );
    eval( "python( \"import xgenm as xgen\" )" );
    eval( "python( \"import xgenm.xgGlobal as xgg\" )" );
    eval( "python( \"import xgenm.ui as xgui\" )" );
    eval( "python( \"import xgenm.ui.dialogs.xgExportPreset as xgpreset\" )" );

    // initialize xgen global info
    python("xgg.initXGen()");    

    // Import the xgen pipline stuff (if the SceneNavigator is present)
    // NOTE: the xgenHandler isn't imported by default with xgpipe, since
    // the user may not want to load xgen in some instances.  When running
    // in maya, we always import the handler, so that we can save/load xgen.
    global int $dlUseSceneNavigator;
    if ( $dlUseSceneNavigator ) {
        $xgmUseHandler = 1;
        eval( "python( \"import xgenm.xgpipe\" )" );
        eval( "python( \"import xgenm.xgpipe.xgenHandler\" )" );
    }

    // Define and initialize XGen global variables here...
    // Note:  UI related vars should be declared in xgenUI.mel
    //
    global string $xgmGuideAttrList[];
    if ( size( $xgmGuideAttrList ) == 0 ) {
        $xgmGuideAttrList = { "width", "taper", "blend" };
    }
    global string $xgmFXProxyGroup = "xgFXProxy";

    xgenInitFilters();

    // Source all of the xgen mel scripts to get any mpxCommands hooked
    // up properly. In general this isnt required, but in order to safely
    // reload a plugin you must either resource or always use eval() when
    // calling an mpxCommand. This is a bit safer.
    string $root = python("xg.rootDir()");
    string $folder = $root+"scripts/";
    string $scripts[] = `getFileList -folder $folder -filespec "*.mel"`;
    for ( $script in $scripts ) {
        if ( $script == "xgen.mel" ) continue;
        // ------------------
        // Check to see if its a .res.mel file. If so, do not source it
        // otherwise all strings in mel files will be localized to english
        // last and then stay that way, making it unable to be localized to 
        // other languages.
        if ( endsWith($script, ".res.mel") ) continue;
        // ----------------- 
        if ( catch(`eval( "source "+$script )`) ) {
			string $fmt = (uiRes("m_xgen.kCouldNotSource"));
            warning `format -s $script $fmt`;
        }
    }

	eval( "xgmRegisterRuntimeCmd" ); 
    
    // Setup any file related callbacks.
    eval( "muMessageAdd AfterNew xgmAfterNewCB" );
    eval( "muMessageAdd BeforeOpen xgmBeforeOpenCB" );    
    eval( "muMessageAdd AfterOpen xgmAfterOpenCB" );
    eval( "muMessageAdd BeforeSave xgmBeforeSaveCB" );
    eval( "muMessageAdd AfterSave xgmAfterSaveCB" );
    eval( "muMessageAdd BeforeImport xgmBeforeImportCB" );
    eval( "muMessageAdd AfterImport xgmAfterImportCB" );
    eval( "muMessageAdd BeforeCreateReference xgmBeforeCreateReferenceCB" );
    eval( "muMessageAdd AfterCreateReference xgmAfterCreateReferenceCB" );
    eval( "muMessageAdd BeforeLoadReference xgmBeforeLoadReferenceCB" );
    eval( "muMessageAdd AfterLoadReference xgmAfterLoadReferenceCB" );
    eval( "muMessageAdd MayaExiting xgmMayaExitingCB" );

    // Opening Maya starts a new scene, so get the initial expressions set.
    // evalDeferred( "xgmAddExpressions" );

	xgenInit3dPaintCtx();
}

global proc xgmExpressionEditor(){}
global proc xgmRegisterRuntimeCmd()
{

	if (!`runTimeCommand -exists XgCreateDescriptionEditor`) {
        runTimeCommand -default true
                -category "Menu items.Modeling.Generate"
                -command  "python(\"xgui.createDescriptionEditor()\");"
                XgCreateDescriptionEditor;
    }

	if (!`runTimeCommand -exists XgCreateDescription`) {
        runTimeCommand -default true
                -category "Menu items.Modeling.Generate"
                -command  "python(\"if xgui.createDescription(): xgui.createDescriptionEditor()\");"
                XgCreateDescription;
    }

    if (!`runTimeCommand -exists XgPreview`) {
        runTimeCommand -default true
                -category "Other items.Xgen Tool Shelf"
                -command  "python(\"xgui.createDescriptionEditor(False).preview(False)\");"
                XgPreview;
    }

    if (!`runTimeCommand -exists XgGuideTool`) {
        runTimeCommand -default true
                -category "Other items.Xgen Tool Shelf"
                -command  "xgmGuideContextSelect"
                XgGuideTool;
    }

	if (!`runTimeCommand -exists XgGroomingVis`) {
        runTimeCommand -default true
                -category "Other items.Xgen Tool Shelf"
                -command  "igToggleVisibility"
                XgGroomingVis;
    }

	if (!`runTimeCommand -exists XgExpressionEditor`) {
        runTimeCommand -default true
                -category "Other items.Xgen Tool Shelf"
                -command  "xgmExpressionEditor"
                XgExpressionEditor;
    }

	if (!`runTimeCommand -exists XgExportArchive`) {
        runTimeCommand -default true
                -category "Other items.Xgen Tool Shelf"
                -command  "python(\"xgui.createDescriptionEditor(False).exportArchives()\");"
                XgExportArchive;
    }

	if (!`runTimeCommand -exists XgBatchExportArchive`) {
        runTimeCommand -default true
                -category "Other items.Xgen Tool Shelf"
                -command  "python(\"xgui.createDescriptionEditor(False).batchExportArchives()\");"
                XgBatchExportArchive;
    }

	if (!`runTimeCommand -exists XgPreRendering`) {
        runTimeCommand -default true
                -category "Other items.Xgen Tool Shelf"
                -command  "xgmPreRendering"
                XgPreRendering;
    }
}

/**
 * Procedure to import the palettes that reside as maya objects but
 * have yet to be brought in as c-side objects. 
 */
proc xgmPostLoadImportPalettes( string $palettes[] )
{

    if( `about -batch` )
    {
        // initialize xgen global info
        python("xgg.initXGen()");
    }

	string $currentScene = `file -q -sceneName`;
	string $currentSceneName = `basenameEx $currentScene`;
    	string $currentSceneDir = `dirname $currentScene`;

    print (uiRes("m_xgen.kImportingXgenCollections"));
    for ( $palette in $palettes ) {

        // Get the namespace from the palette
        string $ns = python("xg.objNameSpace(\""+$palette+"\")");
        
        // Determine if we will load work from palette or delta file
        int $importDelta = 0;
        if ( `attributeExists "xgExportAsDelta" $palette` ) {
            $importDelta = `getAttr ( $palette + ".xgExportAsDelta" )`;
			$importDelta = substituteAllString($importDelta, "\\", "\\\\");
		}

        // Get the file to import from. Can be a .xgen or .xgd file
        string $fileName = `getAttr ( $palette + ".xgFileName" )`;
	$fileName = substituteAllString($fileName, "\\", "\\\\");
	    
    	// The XG file may be loaded when a scene is imported or referenced
   	// However, the directory of the imported/referenced file may be different
	// from the directory of the current scene. To make the current scene file
	// load the XG file like other files, we need to copy the XG file into 
	// the directory of the current scene file and rename it following the
	// naming rule.
	// For example, if we reference "//dir1/file1" to "//dir2/scene" the new XG
	// file should be "//dir2/scene_file1_collections.xgen"
	global string $sourceFile;
	string $sourceFileDir = `dirname $sourceFile`;
	if( $sourceFile != "" )
	{
		string $basePaletteName = python("xg.stripNameSpace(\""+$palette+"\")");
		string $copyCmd = "xg.copyFileToNewDir(\"" + $fileName 			+ "\", \"" 
		                                            + $currentSceneName + "\", \"" 
													+ $sourceFileDir 	+ "\", \"" 
													+ $currentSceneDir 	+ "\", \"" 
													+ $basePaletteName	+ "\", \"" 
													+ $ns 				+ "\")";
		$fileName = python($copyCmd);
	}
	// If source file is empty, it means we are loading the file
	// no need to copy the file
	else
	{
		$notfound = !`filetest -r $fileName`;
		if( $notfound == 1 && $currentSceneDir != "" ){
			$fileName = $currentSceneDir + "/" + $fileName;
		}
	}

        if ( $importDelta ) {
            // Import using a base palette, collection of previous deltas,
            // and a work in progress delta file.
            
            // Get the base palette to compare against
            string $baseFile = `getAttr ( $palette + ".xgBaseFile" )`;
			$baseFile = substituteAllString($baseFile, "\\", "\\\\");
            $notfound = !`filetest -r $baseFile`;
			if( $notfound == 1 ){
				string $tmp = $currentSceneDir + "/" + $baseFile;
				$baseFile = $tmp;
			}

            // Get the list of delta files to apply to the base 
            string $deltas = `getAttr ( $palette + ".xgDeltaFiles" )`;
            $deltas = substituteAllString($deltas, "\\", "\\\\");
            string $deltaFiles[] = stringToStringArray( $deltas, "," );
            for ( $i=0; $i<size($deltaFiles); $i++ ) {
                $notfound = !`filetest -r $deltaFiles[$i]`;
                if( $notfound == 1 ){
                    $deltaFiles[$i] = $currentSceneDir + "/" + $deltaFiles[$i];
                }
            }
            $deltas = stringArrayToString( $deltaFiles, "," );
            $deltas = xgmStringToStringList( $deltas, "," );

            // Import base palette while applying deltas and wrapping everything
            string $pal = python( "xg.importPalette(\"" + $baseFile + "\","+
                                  $deltas + ", \""+$ns+"\" )" );
            if ( $pal == "" ) continue;
            
            // Apply the latest delta
            if ( $fileName != "" ) {
                python( "xg.applyDelta(\"" + $palette + "\", \"" 
                                           + $fileName + "\")" );
            }

        } else {
            // Import the palette file and wrap everything except the guides.
            python("xg.importPalette(\""+$fileName+"\", [], "+
                                    "\""+$ns+"\" )");
        }
    }
    print (uiRes("m_xgen.kDoneImporting"));
}

proc string getPaletteFileName(string $baseSceneName, string $palette)
{
    string $ns = python("xg.objNameSpace(\""+$palette+"\")");
    string $paletteName = python("xg.stripNameSpace(\""+$palette+"\")");
    string $baseFilename = python("xg.buildFileName(\"" + $paletteName + "\", \"" +
                                    $baseSceneName + "\", \"" +
                                    $ns +"\")");
    
    return $baseFilename;
}

/**
 * Procedure to set the file name of the exported palettes.
 */
proc xgmSetPalettesFileName()
{
    string $palettes[];
    catchQuiet ( $palettes = python("xg.palettes()") );
    
    if ( !`size($palettes)` ) return;
    
    string $file = `file -q -sceneName`;
    string $baseSceneName = `basenameEx $file`;
    
    for ( $palette in $palettes ) {
        if( `objExists $palette` ) {
            int $exportDelta = 0;
            if ( `attributeExists "xgExportAsDelta" $palette` ) {
                $exportDelta = `getAttr ( $palette + ".xgExportAsDelta" )`;
            }

            string $orgXgFileName = `getAttr ( $palette + ".xgFileName" )`;
            string $orgXgBaseName = `getAttr ( $palette + ".xgBaseFile" )`;
            
            if ( $exportDelta ) {
                if ( strip($orgXgBaseName) == "" ) {
                    setAttr -type "string" ( $palette + ".xgBaseFile" ) $orgXgFileName;
                }
                if ( strip($orgXgFileName) == "" || !endsWith(strip($orgXgFileName), ".xgd") ) {
                    string $baseName = getPaletteFileName($baseSceneName, $palette);
                    $baseName += ".xgd";
                    setAttr -type "string" ( $palette + ".xgFileName" ) $baseName;
                }
            }
            else {
                string $baseName;
                string $xgFileName;
                if ( strip($orgXgFileName) == "" ) {
                    $baseName = getPaletteFileName($baseSceneName, $palette);
                    $xgFileName = $baseName + ".xgen";
                    setAttr -type "string" ( $palette + ".xgFileName" ) $xgFileName;
                }
                else {
                    $baseName = getPaletteFileName($baseSceneName, $palette);
                    $xgFileName = $baseName + ".xgen";
                    setAttr -type "string" ( $palette + ".xgFileName" ) $xgFileName;
                }
                setAttr -type "string" ( $palette + ".xgBaseFile" ) "";
            }
        }
    }
}

/**
 * Procedure to export the palettes into separate files and save the
 * file location into an attribute on the palette.
 * Make sure to call xgmSetPalettesFileName() before call this method.
 */
proc xgmExportPalettes()
{
    string $file = `file -q -sceneName`;
    string $dir = `dirname $file`;
    $dir = python("xg.fixPath(\""+$dir+"\")");
    
    string $palettes[];
    clear $palettes;
    catchQuiet ( $palettes = python("xg.palettes()") );

    if ( !`size($palettes)` ) return;
    
    print (uiRes("m_xgen.kExportingXgenCollections"));
    for ( $palette in $palettes ) {
        if( `objExists $palette` ) {
            // Check if delta should be exported
            int $exportDelta = 0;
            if ( `attributeExists "xgExportAsDelta" $palette` ) {
                $exportDelta = `getAttr ( $palette + ".xgExportAsDelta" )`;
            }

            string $xgFileName = `getAttr ( $palette + ".xgFileName" )`;
            string $filename = $dir + "/" + $xgFileName;
            if ( $exportDelta ) {
                // Export the palette as delta diffed original snapshot
                
                int $result = python( "xg.createDelta(\"" + $palette +
                                      "\", \"" + $filename + "\")");
                if ( $result == -1 ) {
                    string $fmt = (uiRes("m_xgen.kDeltaError"));
                    error `format -s $palette $fmt`;
                } else if ( $result == 0 ) {
                    setAttr -type "string" ( $palette + ".xgFileName" ) "";
                }
            }
            else {
                python("xg.exportPalette(\""+$palette+"\",\""+$filename+"\")");
                
                // create a snapshot when first save the palette, then delta file can be created
                // if a snapshot exists, do nothing
                python("xg.initSnapshot(\""+$palette+"\")");
            }
        }
    }
    print (uiRes("m_xgen.kDoneExporting"));
}

proc updateMRShaderByGlobalMotionBlurSettings(string $shaderNode)
{
    if (!`objExists miDefaultOptions` || !`objExists mentalrayGlobals`)
        return;

    int $mb = `getAttr "miDefaultOptions.motionBlur"`;
    string $attr = $shaderNode + ".motion_blur";
    if ($mb > 0)
        setAttr $attr 1;
    else
        setAttr $attr 0;
    
    int $mb_steps = `getAttr "miDefaultOptions.motionSteps"`;
    $attr = $shaderNode + ".motion_blur_steps";
    setAttr $attr $mb_steps;

    // for "motion_blur_multiplier", always set it to 1 
    $attr = $shaderNode + ".motion_blur_multiplier";
    setAttr $attr 1;

    float $mb_offset = `getAttr "mentalrayGlobals.exportMotionOffset"`;
    $attr = $shaderNode + ".motion_blur_mode";
    if ( $mb_offset == 0.0 )
        setAttr $attr 0;
    else if ( $mb_offset == 0.5 )
        setAttr $attr 1;
    else
        setAttr $attr 2;
    
    // for "motion_blur_factor", always set it to 1 
    // as mayaMotionLength has been used when rendering
    $attr = $shaderNode + ".motion_blur_factor";
    setAttr $attr 1;
}

global proc xgmInitPlayblast()
{
    // Need a better way to load the UI infomation
    if( !`about -batch` ) {
        python("xgui.createDescriptionEditor(False).loadGlobals()");
    }
}

/**
 * Callback for just after a new scene command.
 */
global proc xgmAfterNewCB( string $args[] )
{
	// A new scene is started so add the expressions, even though we
    // have no xgen objects. This gets the expressions up for any
    // newly created objects.
    xgmInitPlayblast;
	if( !`about -batch` ) {
        if ( python("xgpreset.hasExportPresetDialog()") )
            python("xgpreset.exportPresetDialog.close()");
		python("if xgg.DescriptionEditor is not None:\n\txgg.DescriptionEditor.update()");
	}

    // delete pending folders
    python("xgg.FolderTracker.desc().deleteAll()");
}


/**
 * Reset scene dirty flag 
 */
global proc xgmSetSceneNotDirty()
{
    file -modified false;
}


/**
 * Callback for just after a file is opened.
 */
global proc xgmAfterOpenCB( string $args[] )
{
   	global int $xgmUseHandler;
    if ( !$xgmUseHandler ) {
        string $palettes[] = `ls -type xgmPalette`;
        if ( `size($palettes)` ) {
            xgmPostLoadImportPalettes($palettes);
        }
    }
    xgmInitPlayblast;	
	// Add the expresion in the old scene (backward compatibility)
    string $palettes[];
    catchQuiet ( $palettes = python("xg.palettes()") );
	if ( `size($palettes)` && !`objExists xgmRefreshPreview` && !`objExists xgmPreviewWarning`)
		xgmAddExpressions;

	if( !`about -batch` ) {
        if ( python("xgpreset.hasExportPresetDialog()") )
            python("xgpreset.exportPresetDialog.close()");
		python("if xgg.DescriptionEditor is not None:\n\txgg.DescriptionEditor.update()");
	}

    // start tracker after a scene load
    python("xgg.FolderTracker.desc().tracking = True");

    // delete pending folders
    python("xgg.FolderTracker.desc().deleteAll()");
	
	
	// Please read the description in xgmBeforeOpenCB about this variable
	// Reset open opeartion state flag
	global int $isOpeningScene;
	$isOpeningScene = 0;
    
    // Reset scene dirty flag after save/open a file
    // to make sure the scene is clean and no need to 
    // re-save again if user open/new another scene
    //
    xgmSetSceneNotDirty();

    // We have to use evalDeferred to do clean dirty flag again, 
    // because xgen call some scriptJob which may modify the scene.
    // These modification cannot be cleared by file IO 
    // since scriptJob is called when maya idle.
    // In other words, these modification will be left in the 
    // scene and make scene dirty.
    // 
    // "evalDeferred -lowPriority" could append the script method 
    // at the end of the idle queue. So we call xgmSetSceneNotDirty
    // by evalDeferred to reset dirty flag after other 
    // modification done.
    evalDeferred -lowPriority "xgmSetSceneNotDirty";
}

/**
 * Callback for just before a file is opened.
 */
global proc xgmBeforeOpenCB( string $args[] )
{
    // put tracker on hold during a scene load. We don't want to track newly added description when loading a scene.
    python("xgg.FolderTracker.desc().tracking = False");
	
    // Set sourceFile to empty in open callback
    // because this variable is used during importing or referencing
    global string $sourceFile;
    $sourceFile = "";
	
	// When a scene file is opened, it may run reference callback if it has some
	// reference node, because it needs to create reference node and load referenced objects
	// from the file. However in this case, we do not want the callback load 
	// xgen data immediately, because the data will be loaded in open callback after
	// all nodes in the scene is referenced or loaded.
	// So we need to check if the callback is called from UI or from open operation
	// If it is from open operation, skip it.
	// Here, mark the operation state flag. 
	global int $isOpeningScene;
	$isOpeningScene = 1;
}

proc int isShaderRegistered( string $type )
{
    if (`pluginInfo -q -loaded "Mayatomr"`)
    {
        string $nodes[] = `pluginInfo -q -dependNode "Mayatomr"`;
        int $i;
        for ($i=0; $i<size($nodes); $i++)
        {
            if ($nodes[$i] == $type)
               return 1;
        }
    }
    
    return 0;
}

/**
 * Callback for just before a file is saved.
 */
global proc xgmBeforeSaveCB( string $args[] )
{
    global int $xgmUseHandler;
    
    xgmSetVersion;
    if ( !$xgmUseHandler ) {
        // set the palette file name before save 
        // because the file name is written in Maya scene file
        xgmSetPalettesFileName;
    }

    // bake all guides
    // if no guide exists, command "xgmBakeGuideVertices" returns failure,
    // need to catch it
    catch(`xgmBakeGuideVertices -useOrigin`);

    // clean up visualizers
    string $allViz[] = `ls -type xgmConnectivity`;
    for ( $viz in $allViz ) {
        $xform = `listRelatives -parent $viz`;
        delete $xform;
    }

    // Need a better way to save the UI infomation
    if( !`about -batch` ){
        python( "xgui.createDescriptionEditor(False).saveGlobals()" );
    }
    
    if ( isShaderRegistered("xgen_geo") )
    {
        $xgenGeo = `ls -type xgen_geo`;
        for( $i = 0; $i < size($xgenGeo); $i++ ) 
        {
            updateMRShaderByGlobalMotionBlurSettings($xgenGeo[$i]);
        }
    }
    
    // update xgen_geo nodes for batch render
    if (`exists xgmr`)
        xgmr -ugs;
}


/**
 * Callback for just after a file is saveed.
 */
global proc xgmAfterSaveCB( string $args[] )
{
    global int $xgmUseHandler;

    if ( !$xgmUseHandler ) {
        eval( "python( \"import xgenm.ui.xgSetMapAttr as xgsma\" )" );
        python( "xgsma.setMapAttr()" );

        xgmExportPalettes;
    }
    
    // remove all pending entries in the tracker
    python("xgg.FolderTracker.desc().removeAll()");
	
    // Reset scene dirty flag after save/open a file
    // to make sure the scene is clean and no need to 
    // re-save again if user open/new another scene
    //
    xgmSetSceneNotDirty();

    // We have to use evalDeferred to do clean dirty flag again, 
    // because xgen call some scriptJob which may modify the scene.
    // These modification cannot be cleared by file IO 
    // since scriptJob is called when maya idle.
    // In other words, these modification will be left in the 
    // scene and make scene dirty.
    // 
    // "evalDeferred -lowPriority" could append the script method 
    // at the end of the idle queue. So we call xgmSetSceneNotDirty
    // by evalDeferred to reset dirty flag after other 
    // modification done.
    evalDeferred -lowPriority "xgmSetSceneNotDirty";
}


/**
 * Callback for just before a file is imported.
 */
global proc xgmBeforeImportCB( string $args[] )
{
    global string $xgmPreImportPalettes[];
    $xgmPreImportPalettes = `ls -type xgmPalette`;
    
    // The XG file may be loaded when a scene is imported
    // Since the xgen file should be in the same directory of the scene
    // and the attribute "xgFileName" only has the file base name,
    // we need to save the file path to check if the imported file and
    // the current scene are in the same directory. If the imported file
    // is not in the same directory of the current scene, we need to
    // copy the xgen file into the directory of the current scene to make the
    // current scene use it later.
    global string $sourceFile;
    $sourceFile = python("import maya.OpenMaya;maya.OpenMaya.MFileIO().beforeImportFilename()");
}


/**
 * Callback for just after a file is imported.
 */
global proc xgmAfterImportCB( string $args[] )
{
    global string $xgmPreImportPalettes[];
    global int $xgmUseHandler;
    if ( !$xgmUseHandler ) {
        string $allPals[] = `ls -type xgmPalette`;
        string $palettes[]=`stringArrayRemove $xgmPreImportPalettes $allPals`;
        if ( `size($palettes)` ) {
			if( !`about -batch` ) {
				python("if xgg.DescriptionEditor is None:\n\txg.ui.createDescriptionEditor(False)");
			}
            xgmPostLoadImportPalettes($palettes);
        }

		// Add the expresion in the old scene (backward compatibility)
		string $palettes[];
		catchQuiet ( $palettes = python("xg.palettes()") );
		if ( `size($palettes)` && !`objExists xgmRefreshPreview` && !`objExists xgmPreviewWarning`)
			xgmAddExpressions;
    }

	if( !`about -batch` ) {
        if ( python("xgpreset.hasExportPresetDialog()") )
            python("xgpreset.exportPresetDialog.close()");
		python("if xgg.DescriptionEditor is not None:\n\txgg.DescriptionEditor.update()");
	}

	// update xgen_geo nodes for batch render
    if (`exists xgmr`)
        xgmr -ugs;
}


/**
 * Callback for just before a reference is created.
 */
global proc xgmBeforeCreateReferenceCB( string $args[] )
{
	// Please read the description in xgmBeforeOpenCB about this variable
	// Check if the callback should be skipped
	global int $isOpeningScene;
	if(!$isOpeningScene)
	{
		global string $xgmPreImportPalettes[];
		$xgmPreImportPalettes = `ls -type xgmPalette`;
		
		// The xgen file may be loaded when a scene is referenced
		// Since the xgen file should be in the same directory of the scene
		// and the attribute "xgFileName" only has the file base name,
		// we need to save the file path to check if the referenced file and
		// the current scene are in the same directory. If the refereced file
		// is not in the same directory of the current scene, we need to
		// copy the xgen file into the directory of the current scene to make the
		// the referenced objects and the related xgen objects in the current scene 
		// be opened correctly later.
		global string $sourceFile;
		$sourceFile = python("import maya.OpenMaya;maya.OpenMaya.MFileIO().beforeReferenceFilename()");
	}
}


/**
 * Callback for just after a reference is created.
 */
global proc xgmAfterCreateReferenceCB( string $args[] )
{
	// Please read the description in xgmBeforeOpenCB about this variable
	// Check if the callback should be skipped
	global int $isOpeningScene;
	if(!$isOpeningScene)
	{
		// Currently, the workflow of loding xgen file after importing or referencing
		// the description or collection nodes are same. So we can use the same
		// method which import callback is using.
		xgmAfterImportCB($args);
	}

	// update xgen_geo nodes for batch render
    if (`exists xgmr`)
        xgmr -ugs;
}


/**
 * Callback for just before a reference is loaded.
 */
global proc xgmBeforeLoadReferenceCB( string $args[] )
{
	// Currently, LoadReferenceCB do same work as CreateReferenceCB
	xgmBeforeCreateReferenceCB($args);
}


/**
 * Callback for just after a reference is loaded.
 */
global proc xgmAfterLoadReferenceCB( string $args[] )
{
	// Currently, LoadReferenceCB do same work as CreateReferenceCB
	xgmAfterCreateReferenceCB($args);
}


/**
 * Callback when exiting Maya
 */
global proc xgmMayaExitingCB( string $args[] )
{
    // delete pending folders
    python("xgg.FolderTracker.desc().deleteAll()");
}

global proc xgmPreRendering()
{
    // Only works from within Maya. In batch this is going to crash.
    if( !`about -batch` )
    {
        // Before doing a render, export the palettes.
        // This is done to ensure renderesr that are using a different process get the updated values without having to save the scene manually.
        xgmSetPalettesFileName();
        xgmExportPalettes();

        if ( isShaderRegistered("xgen_geo") )
        {
            $xgenGeo = `ls -type xgen_geo`;
            for( $i = 0; $i < size($xgenGeo); $i++ ) 
            {
                string $data = `getAttr ($xgenGeo[$i] + ".data")`;
                string $dataList[]; 
                tokenizeList($data, $dataList);
                for( $j = 0; $j < size($dataList); $j++ ) 
                {
                    if( $dataList[$j] == "-description" )
                    {
                        string $descName = $dataList[$j+1];
                        int $objTest = `objExists $descName`;
                        if($objTest == 1)
                        {
                            xgmPushOver -d $descName;
                        }
                        break;
                    }
                }

                updateMRShaderByGlobalMotionBlurSettings($xgenGeo[$i]);
            }
        }
    }
    else
    {
        // initialize xgen global info
        python("xgg.initXGen()");
    }
}
