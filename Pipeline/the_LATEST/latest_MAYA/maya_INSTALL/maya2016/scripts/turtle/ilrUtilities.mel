// Copyright (C) 1997-2014 Autodesk, Inc., and/or its licensors.
// All rights reserved.
//
// The coded instructions, statements, computer programs, and/or related
// material (collectively the "Data") in these files contain unpublished
// information proprietary to Autodesk, Inc. ("Autodesk") and/or its licensors,
// which is protected by U.S. and Canadian federal copyright law and by
// international treaties.
//
// The Data is provided for use exclusively by You. You have the right to use,
// modify, and incorporate this Data into other products for purposes authorized 
// by the Autodesk software license agreement, without fee.
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND. AUTODESK
// DOES NOT MAKE AND HEREBY DISCLAIMS ANY EXPRESS OR IMPLIED WARRANTIES
// INCLUDING, BUT NOT LIMITED TO, THE WARRANTIES OF NON-INFRINGEMENT,
// MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE, OR ARISING FROM A COURSE 
// OF DEALING, USAGE, OR TRADE PRACTICE. IN NO EVENT WILL AUTODESK AND/OR ITS
// LICENSORS BE LIABLE FOR ANY LOST REVENUES, DATA, OR PROFITS, OR SPECIAL,
// DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES, EVEN IF AUTODESK AND/OR ITS
// LICENSORS HAS BEEN ADVISED OF THE POSSIBILITY OR PROBABILITY OF SUCH DAMAGES.

//
// provided at the time of installation or download, or which otherwise accompanies 

//
// Various utility scripts
//

global proc ilrVisualizePointCloud(string $file, string $name) {
	string $shape = $name + "Shape";
	if (!`objExists $shape`) {
		string $trans = `createNode "transform" -shared -name $name`;
		$shape = `createNode "ilrPointCloudShape" -shared -parent $trans -name $shape`;
	}
	setAttr -type "string" ($shape + ".inputFile") $file;
	ilrPointCloudCmd -rebuild -inputShape $shape;
	select $shape;
}

// Procedure for toggling referenced bake layers on/off
// (renderable / non-renderable)
//
global proc ilrToggleReferencedBakeLayers(int $enable)
{
	string $layers[] = `ls -type ilrBakeLayer`;
	for ($l in $layers) 
	{
		if (`referenceQuery -isNodeReferenced $l`)
		{
			setAttr ($l + ".renderable") $enable;
		}
	};
}

// Procedure for deleting Turtle nodes. All nodes
// named "Turtle..." and "ilr..." will be deleted.
//
global proc ilrDeleteTurtleNodes()
{
	string $nodes[];
	$nodes = `ls "Turtle*"`;
	for ($n in $nodes) {
		if (`objExists $n`) {
			lockNode -lock 0 $n;
			delete $n;
		}
	}
	$nodes = `ls "ilr*"`;
	for ($n in $nodes) {
		if (`objExists $n`) {
			lockNode -lock 0 $n;
			delete $n;
		}
	}
}

// Procedure for rendering an animation sequence. The render command is specified through an argument flag,
// so both rendering, baking and surface transfer can be started with this procedure
//
global proc ilrRenderAnimationSequence(string $renderCmd, float $startFrame, float $endFrame, float $frameStep)
{
	float $frame = $startFrame;
	while ($frame <= $endFrame)
	{
		currentTime $frame;
		eval $renderCmd;		
		$frame += $frameStep;
	}
}

// Procedure for texture baking an animation sequence.
//
global proc ilrTextureBakeAnimationSequence(float $startFrame, float $endFrame, float $frameStep)
{
	string $cmd = "ilrTextureBakeBatchCallback(\"-layer defaultRenderLayer\")";
	ilrRenderAnimationSequence($cmd, $startFrame, $endFrame, $frameStep);
}

// Searches down the DAG for a non-transform object
//
global proc string ilrExtendToShape(string $node)
{
	if (`nodeType $node` == "transform") {
		string $children[] = `listRelatives -children -noIntermediate -path $node`;
		if(size($children) > 0) {
			string $extended = $node + "|" + $children[0];
			if (!`objExists $extended`) {  // Sometimes listRelatives includes the parent in the returned child path
				$extended = $children[0];  // so make sure to check for this here and adjust accordingly
			}
			$node = ilrExtendToShape($extended);
		}
	}
	// We have found a non-transform, so return it
	return $node;
}
