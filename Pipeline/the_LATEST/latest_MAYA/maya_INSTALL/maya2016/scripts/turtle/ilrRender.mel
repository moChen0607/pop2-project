// Copyright (C) 1997-2014 Autodesk, Inc., and/or its licensors.
// All rights reserved.
//
// The coded instructions, statements, computer programs, and/or related
// material (collectively the "Data") in these files contain unpublished
// information proprietary to Autodesk, Inc. ("Autodesk") and/or its licensors,
// which is protected by U.S. and Canadian federal copyright law and by
// international treaties.
//
// The Data is provided for use exclusively by You. You have the right to use,
// modify, and incorporate this Data into other products for purposes authorized 
// by the Autodesk software license agreement, without fee.
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND. AUTODESK
// DOES NOT MAKE AND HEREBY DISCLAIMS ANY EXPRESS OR IMPLIED WARRANTIES
// INCLUDING, BUT NOT LIMITED TO, THE WARRANTIES OF NON-INFRINGEMENT,
// MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE, OR ARISING FROM A COURSE 
// OF DEALING, USAGE, OR TRADE PRACTICE. IN NO EVENT WILL AUTODESK AND/OR ITS
// LICENSORS BE LIABLE FOR ANY LOST REVENUES, DATA, OR PROFITS, OR SPECIAL,
// DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES, EVEN IF AUTODESK AND/OR ITS
// LICENSORS HAS BEEN ADVISED OF THE POSSIBILITY OR PROBABILITY OF SUCH DAMAGES.

//
// provided at the time of installation or download, or which otherwise accompanies 

source "showEditor.mel";

global string $g_ilrCurrentSelection[];
global int $g_ilrAutoUpdateAttrEdFlag = 0;
global int $g_ilrRenderRegionFlag = 0;

global proc ilrTakeMayaRenderOptions()
{	
	int $erl  = `getAttr defaultRenderGlobals.renderLayerEnable`;
	setAttr TurtleRenderOptions.renderLayers $erl;
}

global proc ilrShowBatchRender() 
{
	global int $g_ilrIsSystemNT;
	global int $g_ilrIsSystemLinux;
	global int $g_ilrIsSystemMac;

	string $filename = (ilrGetTempDir() + "batch.tmp");

	$fileId = `fopen ($filename) "r"`;
	if (!$fileId)
	{
		error("No batch render exists!");
	}
	string $s = `fread $fileId $s`;
	fclose $fileId;

	if ($g_ilrIsSystemNT == 1)
	{
		system("start cmd /c fcheck.exe \"" + $s + "\"");
	}
	else if ($g_ilrIsSystemLinux)
	{
		$cmd1 = "fcheck " + $s + " >/dev/null 2>&1";
		string $cmd = `substitute "\n" $cmd1 ""`;
		ilrDebugPrint($cmd);
		system($cmd);
	}
	else if ($g_ilrIsSystemMac)
	{
		string $f = "\"" + $s + "\"";
		string $cmd = "open -a " + `getenv MAYA_LOCATION` + "/Fcheck.app " + $f;
		$cmd = `substitute "\n" $cmd ""`;
		$cmd = `substitute "/Maya.app/Contents" $cmd ""`;
		system($cmd);
	}
	else
	{
		error("Unsupported architecture, cannot show batch render!");
	}
}

proc ilrFixMultiTextureShader()
{
	string $allTexures[];
	$allTexures = `ls -tex`;
	int $s = size($allTexures);
	
	int $i = 0;
	for ($i=0; $i< $s; $i++) {
		if (attributeExists("shaderFlag", $allTexures[$i])) {
			setAttr ($allTexures[$i]+".shaderFlag") 0;
		}
	}
};

proc ilrResetMultiTextureShader()
{
	string $allTexures[];
	$allTexures = `ls -tex`;
	int $s = size($allTexures);
	
	int $i = 0;
	for ($i=0; $i< $s; $i++) {
		if (attributeExists("shaderFlag", $allTexures[$i])) {
			setAttr ($allTexures[$i]+".shaderFlag") -1;
		}
	}
};

proc ilrRemoveHDRILights()
{
	string $list[];
	string $lightList[];
	string $lightObj;
	$list = `ls -l`;

	for ($item in $list)
	{
		$lightObj = `match "HDRIlight[0-9]+$" $item`;
		if (size($lightObj))
		{
			delete $lightObj;
		}
	}
}

global proc ilrInitRender(string $camera)
{
	// Make sure the rendering options node exist
	ilrDefaultNodes(1);

	// Take all neccessary Maya options
	ilrTakeMayaRenderOptions();

	ilrFixMultiTextureShader();
}

global proc ilrExitRender()
{
	ilrRemoveHDRILights();
}

//
// Setup the renderer to render only the specified layers and passes.
// Empty strings means to ignore this option.
//
global proc ilrSetRenderLayersAndPasses(string $layers, string $passes)
{
	int $i;
	int $j;
	int $state;
	string $allLayers[] = `listConnections renderLayerManager.renderLayerId`;
	
	// Handle the layers first
	if ($layers != "") {

		if ($layers == "off" || $layers == "false" || $layers == "0") {
			//
			// Set the default layer to renderable, and all others to
			// non-renderable.
			// The subdirectory "defaultRenderLayer" will automatically
			// be created if any render layers (other than the default) exist.
			//
			for( $i=0 ; $i<size($allLayers) ; $i++ ){
				if( $allLayers[$i] == "defaultRenderLayer" ){
					removeRenderLayerAdjustmentAndUnlock ($allLayers[$i]+".renderable");
					catch(`setAttr ($allLayers[$i]+".renderable") true`);
				}else{
					removeRenderLayerAdjustmentAndUnlock ($allLayers[$i]+".renderable");
					catch(`setAttr ($allLayers[$i]+".renderable") false`);
				}
			}
		} else if( !($layers == "on" || $layers == "true" || $layers == "1") ){
			//
			// Assume a list of layers.
			// Turn all layers off, except the ones explicitely named.
			//
			string $selectedLayers[];
			tokenizeList($layers, $selectedLayers);
			for ($i = 0 ; $i<size($allLayers) ; $i++) 
			{
				removeRenderLayerAdjustmentAndUnlock ($allLayers[$i]+".renderable");
				
				$state = 0;
				for ($j =  0 ; $j<size($selectedLayers) ; $j++) {
					if ($allLayers[$i] == $selectedLayers[$j]) {
						$state = 1; break;
					}
				}
				catch(`setAttr ($allLayers[$i]+".renderable") $state`);
			}
		}
	}

	// Handle the passes
	if ($passes != "") {

		// These will filter down into the last if loop
		if ($passes == "off" || $passes == "false" || $passes == "0") {
			$passes = "beauty";
		}else if( $passes == "all" ){
			// All maya passes
 			$passes = "beauty color ambient diffuse specular shadow";
			// All turtle passes
			$passes += " tpIllumination tpIndirectIllumination tpAlbedo tpDiffuse tpSpecular tpAmbient tpIncandescence tpSss tpReflections tpRefractions";
		}
		if (!($passes == "on" || $passes == "true" || $passes == "1")) {

			// Assume a list of passes.
			// Turn all passes off, except the ones explicitely named.

			string $selectedPasses[];
			tokenizeList($passes, $selectedPasses);
			
            string $pass[] = {"beauty", "color", "ambient", "diffuse", "specular", "shadow", 
                           "tpIllumination", "tpIndirectIllumination", "tpAlbedo", "tpDiffuse", "tpSpecular", "tpAmbient", 
                           "tpIncandescence", "tpSss", "tpReflections", "tpRefractions"};
 
            string $attr[] = {"beauty", "color", "ambient", "diffuse", "specular", "shadow", 
                           "ilrIllumination", "ilrIndirectIllumination", "ilrAlbedo", "ilrDiffuse", "ilrSpecular", "ilrAmbient", 
                           "ilrIncandescence", "ilrSss", "ilrReflections", "ilrRefractions"};
			
			for ($i = 0 ; $i<size($pass) ; $i++) {
				$state = 0;
				for ($j =  0 ; $j<size($selectedPasses) ; $j++) {
					if ($pass[$i] == $selectedPasses[$j]) {
						$state = 1; break;
					}
				}
				for ($j =  0 ; $j<size($allLayers) ; $j++) {
				
					// Make sure the render layer attributes exists
					ilrRenderPassAttributes(1, $allLayers[$j]);
				
					removeRenderLayerAdjustmentAndUnlock ($allLayers[$j]+"."+$attr[$i]);
					catch(`setAttr ($allLayers[$j]+"."+$attr[$i]) $state`);
				}
			}
		}
	}
}

//
// Render procedure for plug-in render
// 
global proc ilrRenderCallback(int $width, int $height, int $doShadow, int $doGlow, string $camera, string $options)
{
	global int $g_ilrRenderRegionFlag;

	ilrDefaultNodes(1);

	// This must be done since Maya sometimes sends in the 
	// camera shape and not the transform
	//
	$camera = ilrGetCameraTransform($camera);

	// Create the render command string
	//
	string $cmd = "ilrRenderCmd";
	$cmd += " -camera \"" + $camera + "\"";
	$cmd += " -resolution " + $width + " " + $height;
	$cmd += " -frame " + `currentTime -query`;
	$cmd += $options;
	if ($g_ilrRenderRegionFlag) {
		int $r[] = `ilrRenderWindowCmd -region`;
		if (size($r) >= 4) {
			$cmd += " -region " + $r[0] + " " + $r[1] + " " + $r[2] + " " + $r[3];
		}
	}

	print($cmd + "\n");

	// Set the camera to be used next time
	//
	string	$panel = `ilrGetRenderWindowPanel`;
	renderWindowEditor -edit -currentCamera $camera $panel;

	string $axis = `upAxis -q -axis`;
	int $axisUp = strcmp("z", $axis);
	setAttr TurtleRenderOptions.yAxis $axisUp;

	// Display render view window
	//
	ilrRenderWindow;

	// Execute the render command
	//
	string $items[] = `selectedNodes`;	
	if ( catch(eval($cmd)) )
	{
		ilrProgressEnd();
		select -replace $items;
		error("Unexpected error during rendering!");
	}
	select -replace $items;	
}

// Render region procedure for plug-in render
// We use Maya's render region procedure, but make sure
// Turtle gets the -doRegion flag
// 
global proc ilrRenderRegionCallback(string $editor)
{
	global int $g_ilrRenderRegionFlag;
	$g_ilrRenderRegionFlag = 1;
	eval("mayaRenderRegion " + $editor);
	$g_ilrRenderRegionFlag = 0;
}

//
// Render procedure for batch rendering
//
global proc ilrRenderBatchCallback(string $options)
{
	ilrDefaultNodes(1);
	
	// determine scene name
	string $sceneName = `file -q -ns`;

	// interactive batch appends pid to scene name, remove to get original
	string $temp = $sceneName;
	if (`match "__[0-9]+$" $temp` != "")
	{
		$temp = `match ".+[^0-9]+" $temp`;
		$temp = substring($temp, 1, size($temp)-2);
	}
	if (size($temp) > 0)
	{
		$sceneName = $temp;
	}

	$options += " -sceneName " + $sceneName;
	
	string $cmd = "ilrBatchRenderCmd" + $options;
	
	print("\n\n" + $cmd + "\n\n");

	eval $cmd;
}

// Procedure handling interactive rendering for all render types.
// Starts the right render procedure depending on the selected
// render type.
//
global proc ilrRender(int $width, int $height, int $doShadow, int $doGlow, string $camera, string $options)
{
	string $cmd = "";

	int $renderType = `getAttr TurtleRenderOptions.renderer`;
	switch ($renderType)
	{
		case 0: // Render
			$cmd = "ilrRenderCallback";
			break;
		case 1: // Baking
			$cmd = "ilrBakeCallback";
			break;
	}
	
	if (size($cmd) == 0)
	{
		error("Current render type doesn't support interactive rendering!");
		return;
	}
	
	$cmd += "(" + $width + ", " + $height + ", " + $doShadow + ", " + $doGlow + ", \"" + $camera + "\", \"" + $options + "\")";
	
	print("Interactive render command : " + $cmd + "\n");

	eval $cmd;
}

// Procedure handling region rendering for all render types.
// Starts the right render procedure depending on the selected
// render type.
//
global proc ilrRegionRender(string $editor)
{
	string $cmd = "";

	int $renderType = `getAttr TurtleRenderOptions.renderer`;
	switch ($renderType)
	{
		case 0: // Render
			$cmd = "ilrRenderRegionCallback";
			break;
		case 1: // Baking
			$cmd = "ilrBakeRegionCallback";
			break;
	}
	
	if (size($cmd) == 0)
	{
		error("Current render type doesn't support region rendering!");
		return;
	}
	
	$cmd += "(\"" + $editor + "\")";
	
	print("Region render command : " + $cmd + "\n");

	eval $cmd;
}

// Procedure handling batch rendering for all render types.
// Starts the right render procedure depending on the selected
// render type.
//
global proc ilrBatchRender(string $options)
{
	string $cmd = "";

	int $renderType = `getAttr TurtleRenderOptions.renderer`;
	switch ($renderType)
	{
		case 0: // Render
			$cmd = "ilrRenderBatchCallback";
			break;
		case 1: // Baking
			$cmd = "ilrBakeBatchCallback";
			break;
	}
	
	if (size($cmd) == 0)
	{
		error("Current render type doesn't support batch rendering!");
		return;
	}
	
	$cmd += "(\"" + $options + "\")";
	
	print("Batch render command : " + $cmd + "\n");

	eval $cmd;
}
