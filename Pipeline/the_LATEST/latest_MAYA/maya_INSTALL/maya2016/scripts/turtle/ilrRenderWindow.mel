// Copyright (C) 1997-2014 Autodesk, Inc., and/or its licensors.
// All rights reserved.
//
// The coded instructions, statements, computer programs, and/or related
// material (collectively the "Data") in these files contain unpublished
// information proprietary to Autodesk, Inc. ("Autodesk") and/or its licensors,
// which is protected by U.S. and Canadian federal copyright law and by
// international treaties.
//
// The Data is provided for use exclusively by You. You have the right to use,
// modify, and incorporate this Data into other products for purposes authorized 
// by the Autodesk software license agreement, without fee.
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND. AUTODESK
// DOES NOT MAKE AND HEREBY DISCLAIMS ANY EXPRESS OR IMPLIED WARRANTIES
// INCLUDING, BUT NOT LIMITED TO, THE WARRANTIES OF NON-INFRINGEMENT,
// MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE, OR ARISING FROM A COURSE 
// OF DEALING, USAGE, OR TRADE PRACTICE. IN NO EVENT WILL AUTODESK AND/OR ITS
// LICENSORS BE LIABLE FOR ANY LOST REVENUES, DATA, OR PROFITS, OR SPECIAL,
// DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES, EVEN IF AUTODESK AND/OR ITS
// LICENSORS HAS BEEN ADVISED OF THE POSSIBILITY OR PROBABILITY OF SUCH DAMAGES.

//
// provided at the time of installation or download, or which otherwise accompanies 

//
// Derived from Maya global script to raise the render view window.
//

// Returns the render window editor, creates it if needed.
//
global proc string ilrGetRenderWindowPanel()
{
	string $renderPanel;
	string $renderPanels[] = `getPanel -scriptType "renderWindowPanel"`;

	if(size($renderPanels) == 0)
	{
		$renderPanel = `scriptedPanel -type "renderWindowPanel" -unParent`;
		scriptedPanel -e -label `interToUI $renderPanel` $renderPanel;
	}
	else
	{
		$renderPanel = $renderPanels[0];
	}

	return $renderPanel;
}

// Raise the render view window if exists, then return 1.
// Return 0 otherwise.
//
proc int raiseRenderViewWindow()
{
	// Look for the renderViewWindow and pop it up if it exists.
	for( $i in `lsUI -windows` )
		if( $i == "renderViewWindow" ) {
			showWindow $i;
			return 1;
		}

	return 0;
}

// Ensures that the Render View is displayed.
// If the Render View is currently torn-off in a window, the window is
// brought forward. If the Render View does not exist in a torn-off
// window nor in a panel, it is created in a torn-off window.
// Returns the name of the render view.
//
proc string showRenderView()
{
	string $editor = `ilrGetRenderWindowPanel`;

	if( `raiseRenderViewWindow` == 1 )
	{
		// The Render View exists and is in a torn-off window.
		// It has been brought to the front.
		return $editor;
	}

	// If we get to here, the Render View is not in a torn-off window
	for( $i in `getPanel -vis` )
	{
		if( $i == $editor )
			// The Render View exists and is in a panel. 
			return $editor;
	}

	// If we get to here, the Render View is not currently in a panel
	// nor is it in a torn-off window.
	scriptedPanel -edit -tearOff $editor;
	
	return $editor;
}

global proc string ilrGetPreviousCamera()
{
	string	$panel = `ilrGetRenderWindowPanel`;
	string	$camera = `renderWindowEditor -q -currentCamera $panel`;

	if (!size($camera)) 
	{
		$camera = ilrGetCurrentCamera();
	}

	return $camera;
}

global proc string ilrGetCurrentCamera()
{
	string	$camera;

	// get the current modelling view
	string $currentPanel = `getPanel -wf`;

	if (`modelPanel -exists $currentPanel`)
	{
		$camera = `modelPanel -q -cam $currentPanel`;
	}
	else 
	{
		// Since we have to make a guess at what camera to use,
		// we'll first guess that it's something typical
		// (namely: persp). If that's not a good guess,
		// we'll just guess that it's the first perspective
		// camera in the scene. We return the camera transform.
		//
		int $useFirstCamera = true;

		string $defCameras[] = `ls persp`;
		if (size($defCameras)) 
		{
			string $defCamera = $defCameras[0];

			// check for transform node above camera
			string $defShape[] = listRelatives($defCamera);

			if (size($defShape) && nodeType($defShape[0]) == "camera") 
			{
				$camera = $defCamera;
				$useFirstCamera = false;
			}
		}
		
		// No "persp" camera transform found, use first
		// perspective camera in the scene
		if ($useFirstCamera) 
		{
			string	$cameras[] = `listCameras -p`;
			if (size($cameras))
			{
				$camera = $cameras[0];
			}
		}
	}

	// Set the camera to be used next time
	string	$panel = `ilrGetRenderWindowPanel`;
	renderWindowEditor -edit -currentCamera $camera $panel;

	return $camera;
}

global proc string ilrGetBatchRenderCamera()
{
	string $camera;

	if (`optionMenuGrp -exists ilrCameraMenu`)
	{
		string $allCameras[] = `listCameras`;
		int $camIndex = `optionMenuGrp -query -select ilrCameraMenu` - 1;
		$camera = $allCameras[$camIndex];
	}

	if (!size($camera))
	{
		$camera = ilrGetCurrentCamera();
	}

	ilrDebugPrint($camera);

	return $camera;
}

global proc string ilrGetCameraTransform(string $camera)
{
	if (`nodeType $camera` == "camera")
	{
		string $parents[] = `listRelatives -parent $camera`;
		if (size($parents))
		{
			$camera = $parents[0];
		}
	}

	if (`nodeType $camera` != "transform")
	{
		error($camera + "is not a valid camera");
	}

	return $camera;
}

global proc ilrKeepImageInRenderView()
{
	string $editor = `showRenderView`;
	renderWindowMenuCommand keepImageInRenderView $editor;
}

global proc ilrRenderWindow()
{
	showRenderView;
}
