// Copyright (C) 1997-2014 Autodesk, Inc., and/or its licensors.
// All rights reserved.
//
// The coded instructions, statements, computer programs, and/or related
// material (collectively the "Data") in these files contain unpublished
// information proprietary to Autodesk, Inc. ("Autodesk") and/or its licensors,
// which is protected by U.S. and Canadian federal copyright law and by
// international treaties.
//
// The Data is provided for use exclusively by You. You have the right to use,
// modify, and incorporate this Data into other products for purposes authorized 
// by the Autodesk software license agreement, without fee.
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND. AUTODESK
// DOES NOT MAKE AND HEREBY DISCLAIMS ANY EXPRESS OR IMPLIED WARRANTIES
// INCLUDING, BUT NOT LIMITED TO, THE WARRANTIES OF NON-INFRINGEMENT,
// MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE, OR ARISING FROM A COURSE 
// OF DEALING, USAGE, OR TRADE PRACTICE. IN NO EVENT WILL AUTODESK AND/OR ITS
// LICENSORS BE LIABLE FOR ANY LOST REVENUES, DATA, OR PROFITS, OR SPECIAL,
// DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES, EVEN IF AUTODESK AND/OR ITS
// LICENSORS HAS BEEN ADVISED OF THE POSSIBILITY OR PROBABILITY OF SUCH DAMAGES.

//
// provided at the time of installation or download, or which otherwise accompanies 

//
// Image plane procedures
//

// global names : ipTextureFile , ipPlaceTexture

global proc float ilrCreateImageTexture(string $imagePlaneName, string $imagePath, 
										float $coverU, float $coverV, 
										float $covOrigX, float $covOrigY,
										float $colGainR, float $colGainG, float $colGainB,
										float $colOffR, float $colOffG, float $colOffB,
										float $alphaGain)
{
	source "AEfileTemplate.mel";

	// Create file texture...
	string $fileTexture  = `shadingNode -asTexture -name ($imagePlaneName) file`;
	AEassignTextureCB ($fileTexture+".fileTextureName") $imagePath "image";
	
	//...and place it correctly
	string $placeTexture = `shadingNode -n ($imagePlaneName+"ilrTexPlace2D") -asUtility place2dTexture`;

	connectAttr -f ($placeTexture+".coverage")        ($fileTexture+".coverage");
	connectAttr -f ($placeTexture+".translateFrame")  ($fileTexture+".translateFrame");
	connectAttr -f ($placeTexture+".rotateFrame")     ($fileTexture+".rotateFrame");
	connectAttr -f ($placeTexture+".mirrorU")         ($fileTexture+".mirrorU");
	connectAttr -f ($placeTexture+".mirrorV")         ($fileTexture+".mirrorV");
	connectAttr -f ($placeTexture+".stagger")         ($fileTexture+".stagger");
	connectAttr -f ($placeTexture+".wrapU")           ($fileTexture+".wrapU");
	connectAttr -f ($placeTexture+".wrapV")           ($fileTexture+".wrapV");
	connectAttr -f ($placeTexture+".repeatUV")        ($fileTexture+".repeatUV");
	connectAttr -f ($placeTexture+".offset")          ($fileTexture+".offset");
	connectAttr -f ($placeTexture+".rotateUV")        ($fileTexture+".rotateUV");
	connectAttr -f ($placeTexture+".noiseUV")         ($fileTexture+".noiseUV");
	connectAttr -f ($placeTexture+".vertexUvOne")     ($fileTexture+".vertexUvOne");
	connectAttr -f ($placeTexture+".vertexUvTwo")     ($fileTexture+".vertexUvTwo");
	connectAttr -f ($placeTexture+".vertexUvThree")   ($fileTexture+".vertexUvThree");
	connectAttr -f ($placeTexture+".vertexCameraOne") ($fileTexture+".vertexCameraOne");
	connectAttr    ($placeTexture+".outUV")           ($fileTexture+".uv");
	connectAttr    ($placeTexture+".outUvFilterSize") ($fileTexture+".uvFilterSize");
	
	
	setAttr ($placeTexture+".wrapU") false;
	setAttr ($placeTexture+".wrapV") false;

	// set color gain & col offset values
	setAttr ($fileTexture+".colorGainR") $colGainR;
	setAttr ($fileTexture+".colorGainG") $colGainG;
	setAttr ($fileTexture+".colorGainB") $colGainB;

	setAttr ($fileTexture+".colorOffsetR") $colOffR;
	setAttr ($fileTexture+".colorOffsetG") $colOffG;
	setAttr ($fileTexture+".colorOffsetB") $colOffB;

	setAttr ($fileTexture+".alphaGain") $alphaGain;

	//  experiment with filters
	setAttr ($fileTexture+".filterType") 5;

	// configure the placement options

	float $sizeX = `getAttr ($fileTexture+".outSizeX")`; 
	float $sizeY = `getAttr ($fileTexture+".outSizeY")`;
	if ($sizeX == 0.0 || $sizeY == 0) {
		return 1.0;
	}

	if ($covOrigX > 0 ) {
		setAttr ($placeTexture+".offsetU") (-$covOrigX/$sizeX);
		setAttr ($placeTexture+".coverageU") ($sizeX/($sizeX-$covOrigX));

		if (($sizeX/($sizeX-$covOrigX)) < ($sizeX/$coverU))
			setAttr ($placeTexture+".coverageU") ($sizeX/$coverU);
		
	} else {
		setAttr ($placeTexture+".coverageU") ($sizeX/($sizeX+$covOrigX));

		if (($sizeX/($sizeX+$covOrigX)) < ($sizeX/$coverU))
			setAttr ($placeTexture+".coverageU") ($sizeX/$coverU);
	}

	if ($covOrigY > 0 ) {
		setAttr (($placeTexture+".offsetV")) (-$covOrigY/$sizeY);
		setAttr ($placeTexture+".coverageV") ($sizeY/($sizeY-$covOrigY));
		if (($sizeY/($sizeY-$covOrigY)) < ($sizeY/$coverV))
			setAttr ($placeTexture+".coverageV") ($sizeY/$coverV);

	} else {
		setAttr ($placeTexture+".coverageV") ($sizeY/($sizeY-$covOrigY));
		if (($sizeY/($sizeY-$covOrigY)) < ($sizeY/$coverV))
			setAttr ($placeTexture+".coverageV") ($sizeY/$coverV);
	}
	setAttr ($placeTexture+".wrapV") 0;
	setAttr ($placeTexture+".wrapU") 0;

	float $aspect = 1.0;
	if ($sizeY>0) {
		$aspect = $sizeX/$sizeY;
	}

	//setAttr ($imagePlaneName+".type") 1;
	//connectAttr -force ($fileTexture+".outColor") ($imagePlaneName + ".sourceTexture");


	return $aspect;
}

global proc float ilrUpdateImageTexture(string $imagePlaneName, string $imagePath, 
										float $coverU, float $coverV, 
										float $covOrigX, float $covOrigY,
										float $colGainR, float $colGainG, float $colGainB,
										float $colOffR, float $colOffG, float $colOffB,
										float $alphaGain)
{
	source "AEfileTemplate.mel";

	string $fileTexture  = ($imagePlaneName+"ilrTexFile");
	string $placeTexture = ($imagePlaneName+"ilrTexPlace2D");

	AEassignTextureCB ($fileTexture+".fileTextureName") $imagePath "image";

	// set color gain & col offset values
	setAttr ($fileTexture+".colorGainR") $colGainR;
	setAttr ($fileTexture+".colorGainG") $colGainG;
	setAttr ($fileTexture+".colorGainB") $colGainB;

	setAttr ($fileTexture+".colorOffsetR") $colOffR;
	setAttr ($fileTexture+".colorOffsetG") $colOffG;
	setAttr ($fileTexture+".colorOffsetB") $colOffB;

	setAttr ($fileTexture+".alphaGain") $alphaGain;


	// configure the placement options

	float $sizeX = `getAttr ($fileTexture+".outSizeX")`; 
	float $sizeY = `getAttr ($fileTexture+".outSizeY")`;

	if ($covOrigX > 0 ) {
		setAttr ($placeTexture+".offsetU") (-$covOrigX/$sizeX);
		setAttr ($placeTexture+".coverageU") ($sizeX/($sizeX-$covOrigX));

		if (($sizeX/($sizeX-$covOrigX)) < ($sizeX/$coverU))
			setAttr ($placeTexture+".coverageU") ($sizeX/$coverU);
		
	} else {
		setAttr ($placeTexture+".coverageU") ($sizeX/($sizeX+$covOrigX));

		if (($sizeX/($sizeX+$covOrigX)) < ($sizeX/$coverU))
			setAttr ($placeTexture+".coverageU") ($sizeX/$coverU);
	}

	if ($covOrigY > 0 ) {
		setAttr (($placeTexture+".offsetV")) (-$covOrigY/$sizeY);
		setAttr ($placeTexture+".coverageV") ($sizeY/($sizeY-$covOrigY));
		if (($sizeY/($sizeY-$covOrigY)) < ($sizeY/$coverV))
			setAttr ($placeTexture+".coverageV") ($sizeY/$coverV);

	} else {
		setAttr ($placeTexture+".coverageV") ($sizeY/($sizeY-$covOrigY));
		if (($sizeY/($sizeY-$covOrigY)) < ($sizeY/$coverV))
			setAttr ($placeTexture+".coverageV") ($sizeY/$coverV);
	}

	float $aspect = $sizeX/$sizeY;

	return $aspect;
}

global proc ilrRemoveTexNodes()
{
	string $list[];
	string $planeList[];

	$list = `ls -cameras`;
	for ($item in $list)
	{
		$planeList= `listConnections $item`;
		
		for($it in $planeList) 
		{
			if (size($it))
			{
				string $texFile = ($it+"ilrTexFile");
				string $texPlace2D = ($it+"ilrTexPlace2D");

				if (`objExists $texFile`) {
					delete $texFile;
				}
				
				if (`objExists $texPlace2D`) {
					delete $texPlace2D;
				}

			}
				
		}
	}
}

proc int is_a_number(string $x)
{
   return (size($x) == size(`match "[0-9]+" $x`));
}


global proc string AEilrGetFileWithFrameExtension(string $filename, int $ext)
{
   string $tokens[];
   int $numTokens = `tokenize $filename "." $tokens`;

   string $file = $filename + "." + $ext; 

   switch ($numTokens)
   {
       case 2 :
           if ( is_a_number($tokens[1]) ) {									//  name.#
               // fix padding
               int $pad = size($tokens[1]);
               string $extString = $ext;
                              while (size($extString) < $pad)
               {
                   $extString = "0"+$extString;
               }
               $file = $tokens[0] + "." + $extString;
           } else {

				int $pad = 0;											//name#.ext name_#.ext
				int $nameSize = size($tokens[0]);
				string $tempString = `substring $tokens[0] ($nameSize) $nameSize`;
				print("Initial string: " + $tempString + "\n");
				while (is_a_number($tempString)) {
					$pad++;
					$tempString = `substring $tokens[0] ($nameSize-$pad) $nameSize`;
					print("While string: " + $tempString + "\n");
				}
				if ($pad == 0) {
					print("Cannot find valid numbering in file name, defaulting to name.ext.#");
					break;
				} 
				int $tempCount = $nameSize-$pad;
				string $fileName = `substring $tokens[0] 1 $tempCount`;
				
				//pad the ext if necessary..
				string $extString = $ext;
				while (size($extString) < $pad) {
					$extString = "0"+$extString;
				}
				
				$file = $fileName + $extString + "." + $tokens[1];
           }
		           
           break;
       case 3 :
           if ( is_a_number($tokens[1]) ) {
               // pad
               int $pad = size($tokens[1]);
               string $extString = $ext;
                              while (size($extString) < $pad)
               {
                   $extString = "0"+$extString;
               }
               $file = $tokens[0] + "." + $extString + "." + $tokens[2];
           }
           else if ( is_a_number($tokens[2]) ) {
               // pad
               int $pad = size($tokens[2]);
               string $extString = $ext;
                              while (size($extString) < $pad)
               {
                   $extString = "0"+$extString;
               }
               $file = $tokens[0] + "." + $tokens[1] + "." + $extString;
           }
           break;
       default :
           // ...
   }

   return $file;
} 
