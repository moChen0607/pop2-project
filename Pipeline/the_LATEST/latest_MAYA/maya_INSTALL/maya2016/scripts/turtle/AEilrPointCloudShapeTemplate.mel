// Copyright (C) 1997-2014 Autodesk, Inc., and/or its licensors.
// All rights reserved.
//
// The coded instructions, statements, computer programs, and/or related
// material (collectively the "Data") in these files contain unpublished
// information proprietary to Autodesk, Inc. ("Autodesk") and/or its licensors,
// which is protected by U.S. and Canadian federal copyright law and by
// international treaties.
//
// The Data is provided for use exclusively by You. You have the right to use,
// modify, and incorporate this Data into other products for purposes authorized 
// by the Autodesk software license agreement, without fee.
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND. AUTODESK
// DOES NOT MAKE AND HEREBY DISCLAIMS ANY EXPRESS OR IMPLIED WARRANTIES
// INCLUDING, BUT NOT LIMITED TO, THE WARRANTIES OF NON-INFRINGEMENT,
// MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE, OR ARISING FROM A COURSE 
// OF DEALING, USAGE, OR TRADE PRACTICE. IN NO EVENT WILL AUTODESK AND/OR ITS
// LICENSORS BE LIABLE FOR ANY LOST REVENUES, DATA, OR PROFITS, OR SPECIAL,
// DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES, EVEN IF AUTODESK AND/OR ITS
// LICENSORS HAS BEEN ADVISED OF THE POSSIBILITY OR PROBABILITY OF SUCH DAMAGES.

//
// provided at the time of installation or download, or which otherwise accompanies 

//
// Procedures specifying the UI layout for ilrPointCloudShape
// in Maya's Attribute Editor
//

global proc string ilrCreatePointCloudShape(string $name, string $file)
{
	string $node = `createNode "ilrPointCloudShape" -name $name -skipSelect`;
	setAttr -type "string" ($node + ".inputFile") $file;
	ilrRebuildPointCloudShape($node);
	return $node;
}

global proc AEilrPointCloudUpdateDimming(string $node)
{
	int $pointCloudType = `getAttr ($node + ".pointCloudType")`;
	
	int $dimSH = true;

	// Update Float Array PointCloud	
	if ($pointCloudType == 7) {
		int $faInter = `getAttr ($node + ".faInterpretation")`;
		
		if ($faInter == 4 || $faInter == 5 || $faInter == 6) {
		
			// SH selected
			$dimSH=false;
			
		}
	}
	
	int $dimFG=true;

	// Should Final Gather Options be dimmed?
	if ($pointCloudType == 2 || $pointCloudType==10) {
		$dimFG=false;
	}

	// Disable/enable controls based on choice
	editorTemplate -dimControl $node "coordSys" $dimSH;
	editorTemplate -dimControl $node "shVisualizeAsSpheres" $dimSH;
	editorTemplate -dimControl $node "depth" $dimFG;

	// These should always be disabled
	editorTemplate -dimControl $node faArraySize true;
	editorTemplate -dimControl $node pointCloudType true;
}

// Based on pointCloudType and faArraySize, this function fills the interpretion dropdown (that sets faInterpretation when changed)
// If previous choice (faIntepretation) still is valid, it is set as the new value.
proc AEilrPointCloudInterpretationPopulateMenu(string $node)
{
	global string $g_ilrFloatArrayInterpretationOptionMenu;
	
	string $menu = $g_ilrFloatArrayInterpretationOptionMenu;
	string $menuName = $menu+"|OptionMenu";	

	string $oldParent = `setParent -q`;

	int $guiCreated = 0;

	// Check if the rollout is created yet.	
	if (size($menu) != 0) {
		$guiCreated = 1;
		
		setParent -menu $menuName;
		
		// Find list of all old attributes
		string $itemArray[] = `optionMenuGrp -query -itemListLong $menu`;
		
		// Remove all old attributes	
		string $item;
		for ($item in $itemArray)	{
			deleteUI -menuItem $item;
		}
	}
	
	// Add all interpretations that apply to the current type
	int $pointCloudType = `getAttr ($node + ".pointCloudType")`;
	
	int $oldChoice = `getAttr ($node + ".faInterpretation")`;
	int $oldChoiceFound = 0;
	int $firstChoice = -1;
	string $firstChoiceName = "";
	
	if ($pointCloudType == 7) {
	
		// Get number of float components per point
		int $n = `getAttr ($node + ".faArraySize")`;
		
		int    $channelNumArray []={1,             3,     4    };
		string $channelNameArray[]={"Monochrome", "RGB", "RGBA"};
		
		int $gotAny = 0;
		
		int $chan;		
		for ($chan in {0,1,2}) {
			int $nc = $channelNumArray[$chan];
			string $chanName = $channelNameArray[$chan];

			int $coeff = (int)($n/$nc);
			
			// Make sure n is divisble by nc
			if (($coeff * $nc) != $n) {
				continue;
			}
			
			// Detect color
			if ($n == $nc) {
				$name = "Color - " + $channelNameArray[$chan];
				if ($guiCreated==1) {
					menuItem -label $name;
				}
				$gotAny = 1;
				
				int $typeIndex = 0;
				int $choice = 1 + $typeIndex * 3 + $chan;
				if ($choice == $oldChoice) {
					if ($guiCreated==1) {
						optionMenuGrp -edit -value $name $menu;
					}
					$oldChoiceFound=1;
				}
				
				if ($firstChoice==-1) {
					$firstChoice = $choice;
					$firstChoiceName = $name;
				}
			}

			// Detect SH
			int $shBands = (int)sqrt($coeff);
			
			if ($shBands * $shBands == $coeff) {
				$name = "SH - " + $chanName + " ("+$shBands+" bands)";
				if ($guiCreated==1) {
					menuItem -label $name;
				}
				$gotAny = 1;
				
				int $typeIndex = 1;
				int $choice = 1 + $typeIndex * 3 + $chan;
				if ($choice == $oldChoice) {
					if ($guiCreated==1) {
						optionMenuGrp -edit -value $name $menu;
					}
					$oldChoiceFound=1;
				}
				
				if ($firstChoice==-1) {
					$firstChoice = $choice;
					$firstChoiceName = $name;
				}
			}
		}		

		if ($gotAny==0) {
			if ($guiCreated==1) {
				menuItem -label "None";
				optionMenuGrp -edit -value "None" $menu;
				optionMenuGrp -edit -enable false $menu;
			}
		} else {	

			// Old choice not found, select the first item in the interpretation dropdown
			if (!$oldChoiceFound) {
				setAttr ($node+".faInterpretation") $firstChoice;				
				if ($guiCreated==1) {
					optionMenuGrp -edit -value $firstChoiceName $menu;
				}
			}
		
			if ($guiCreated==1) {
				optionMenuGrp -edit -enable true $menu;
			}
		}
		
		if ($guiCreated==1) {
			optionMenuGrp -edit -changeCommand ("AEilrPointCloudIntepretationChange(\"" + $node + "\")") $menu;
		}
		
	} else {
	
		if ($guiCreated==1) {
			menuItem -label "None";
			optionMenuGrp -edit -value "None" $menu;
			optionMenuGrp -edit -enable false $menu;
		}
	}

	if ($guiCreated==1) {
		setParent $oldParent;
	}
}

global proc ilrRebuildPointCloudShape(string $shape)
{
	$cmd = "ilrPointCloudCmd -rebuild -inputShape " + $shape;
	print ($cmd + "\n");
	eval($cmd);
	
	string $buffer[];
	tokenize($shape, ".", $buffer);
	string $node = $buffer[0];
	
	// Update float array options (interpretation)
	AEilrPointCloudInterpretationPopulateMenu($node);
	
	// Update dimming based on type of new point cloud
	AEilrPointCloudUpdateDimming($node);
}

global proc AEilrPointCloudFileAssignCB(string $fileAttribute, string $filename, string $fileType)
{
	setAttr $fileAttribute -type "string" $filename;

	string $buffer[];
	tokenize($fileAttribute, ".", $buffer);
	string $node = $buffer[0];

	ilrRebuildPointCloudShape($node);	
}

// Whenever the selected item in the Interpretation optionMenu is changed, this function is called
// It updates the real attribute faInterpretation and then updates dimming based on the new interpretation
global proc AEilrPointCloudIntepretationChange(string $node)
{
	global string $g_ilrFloatArrayInterpretationOptionMenu;
	
	if (size($g_ilrFloatArrayInterpretationOptionMenu)==0) {
		return;
	}
	
	// Get choice and parse
	string $choice = `optionMenuGrp -query -value $g_ilrFloatArrayInterpretationOptionMenu`;

	string $tokens[];
	$numTokens = `tokenize $choice "- " $tokens`;
	
	// Detect float array type
	int $typeIndex = -1;
	
	if ($tokens[0]=="None") {
		$typeIndex = -1;
	} else if ($tokens[0]=="Color") {
		$typeIndex=0;
	} else if ($tokens[0]=="SH") {
		$typeIndex=1;
	}
	
	string $faInterpretAttrib = $node+".faInterpretation";
	
	if ($typeIndex != -1) {

		// Detect channels
		int $channelIndex = -1;
		
		string $channelNameArray[]={"Monochrome", "RGB", "RGBA"};
		
		for ($ci in {0,1,2}) {
			if ($tokens[1]==$channelNameArray[$ci]) {
				$channelIndex=$ci;
			}
		}
		
		// Set hidden faInterpretation attribute
		int $faIntValue = 1 + $typeIndex * 3 + $channelIndex;
		setAttr $faInterpretAttrib $faIntValue;
		
	} else {
		// None
		setAttr $faInterpretAttrib 0;
	}
	
	// Update dimming based on the change of faInterpretation
	AEilrPointCloudUpdateDimming($node);
}

global proc AEilrPointCloudInterpretationReplace(string $attribute)
{
	string	$node;
	string	$buffer[];	
	tokenize($attribute, ".", $buffer);
	$node = $buffer[0];
	
	// Populate intepretation based on pointCloudType, faArraySize and old faInterpretation (to provide default value)
	AEilrPointCloudInterpretationPopulateMenu($node);
	
	// Update dimming
	AEilrPointCloudUpdateDimming($node);
}

global proc AEilrPointCloudInterpretationNew(string $attribute)
{
	global string $g_ilrFloatArrayInterpretationOptionMenu;
	
	setUITemplate -pst attributeEditorTemplate;
	
	$g_ilrFloatArrayInterpretationOptionMenu = `optionMenuGrp -label "Interpretation"`;

	setUITemplate -ppt;
	
	AEilrPointCloudInterpretationReplace($attribute);
}

global proc AEilrPointCloudFileBrowser(string $cmd)
{
	string  $workspace = `workspace -q -fn`;
	setWorkingDirectory $workspace "image" "sourceImages";
	fileBrowser ($cmd, "Open", "", 0);
}

global proc AEilrPointCloudFileNew(string $fileAttribute)
{
	setUITemplate -pst attributeEditorTemplate;
	rowLayout -nc 3 ilrPointCloudFileLayout;
		text -l "Input File";
		textField ilrPointCloudFileField;
			symbolButton -image "navButtonBrowse.xpm" ilrPointCloudFileBrowserBtn;
	setParent ..;
	setUITemplate -ppt;
	
    AEilrPointCloudFileReplace $fileAttribute;
}

global proc AEilrPointCloudFileReplace(string $fileAttribute)
{
	connectControl -fileName ilrPointCloudFileField $fileAttribute;
    string $command = "AEilrPointCloudFileAssignCB "+" "+$fileAttribute;
    button -e -c ("AEilrPointCloudFileBrowser \"" + $command + "\"" ) ilrPointCloudFileBrowserBtn;

	string $buffer[];
	tokenize($fileAttribute, ".", $buffer);
	string $node = $buffer[0];

	textField -e -cc ("ilrRebuildPointCloudShape " + $node) ilrPointCloudFileField;
}

global proc AEilrPointCloudRebuildNew(string $attr)
{
	setUITemplate -pst attributeEditorTemplate;
	columnLayout -columnAttach "right" 0 -columnWidth 226;
		button -label "Reload" -width 80 -align "center" ilrPointCloudCmdBtn;
	setParent ..;
	setUITemplate -ppt;
	AEilrPointCloudRebuild($attr);
}

global proc AEilrPointCloudRebuild(string $attr)
{
	string	$node;
	string	$buffer[];
	tokenize($attr, ".", $buffer);
	$node = $buffer[0];
	button -edit -command ("ilrRebuildPointCloudShape " + $node) ilrPointCloudCmdBtn;
}

// This methods is called after all editor controls have been created. It gives the chance to disable some of them.
// Used in collapsed groups that are created later and thus aren't disabled. When they are first expanded this function is executed.
global proc AEilrPointCloudRefresh(string $attr)
{
	string	$node;
	string	$buffer[];
	tokenize($attr, ".", $buffer);
	$node = $buffer[0];
	
	AEilrPointCloudUpdateDimming($node);
}

global proc AEilrPointCloudShapeTemplate(string $node)
{
	editorTemplate -beginScrollLayout;

		editorTemplate -beginLayout "Point Cloud Attributes" -collapse false;

			editorTemplate -callCustom "AEilrPointCloudFileNew" "AEilrPointCloudFileReplace" "inputFile";
			editorTemplate -s "inputFile";

			editorTemplate -l "Point Cloud Type" -ac "pointCloudType";
			
			editorTemplate -callCustom "AEilrPointCloudRebuildNew" "AEilrPointCloudRebuild" "message";
			
		editorTemplate -endLayout;
		
		editorTemplate -beginLayout "Common Display Options" -collapse false;
		
			editorTemplate -l "Color" -ac "color";
			editorTemplate -l "Use Point Colors" -ac "usePointColors";
			editorTemplate -l "Display Gamma" -ac "displayGamma";
			
			editorTemplate -addSeparator;
			
			editorTemplate -l "Point Size" -ac "pointSize";
			editorTemplate -l "Displace Along Normal" -ac "displaceAlongNormal";
			editorTemplate -l "Normal Length" -ac "normalLength";
			editorTemplate -l "Direction Length" -ac "directionLength";

		editorTemplate -endLayout;

		editorTemplate -beginLayout "Final Gather Options" -collapse true;

			editorTemplate -l "Depth" -ac "depth";
			
			editorTemplate -callCustom "AEilrPointCloudRefresh" "AEilrPointCloudRefresh" "message";

		editorTemplate -endLayout;
		
		editorTemplate -beginLayout "Float Array Options" -collapse true;

			editorTemplate -l "Num Elements" -ac "faArraySize";
			
			editorTemplate -callCustom "AEilrPointCloudInterpretationNew" "AEilrPointCloudInterpretationReplace" "message";
			editorTemplate -s "faInterpretation";

			editorTemplate -beginLayout "Spherical Harmonics Options" -collapse true;

				editorTemplate -l "Coordinate System" -ac "coordSys";
				editorTemplate -l "Visualize as Spheres" -ac "shVisualizeAsSpheres";
				
				editorTemplate -callCustom "AEilrPointCloudRefresh" "AEilrPointCloudRefresh" "message";

			editorTemplate -endLayout;

		editorTemplate -endLayout;

		// include/call base class/node attributes
		AEshapeTemplate $node;

		// include/call base class/node attributes
//		AEdependNodeTemplate $node;

		// suppressed attributes
		editorTemplate -s "version";
		editorTemplate -s "rebuild";
		editorTemplate -s "forceCompute";
		
		editorTemplate -addExtraControls;
		
		editorTemplate -callCustom "AEilrPointCloudRefresh" "AEilrPointCloudRefresh" "message";
				
	editorTemplate -endScrollLayout;	
}
