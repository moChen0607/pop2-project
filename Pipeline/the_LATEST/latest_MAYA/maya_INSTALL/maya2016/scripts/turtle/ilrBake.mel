// Copyright (C) 1997-2014 Autodesk, Inc., and/or its licensors.
// All rights reserved.
//
// The coded instructions, statements, computer programs, and/or related
// material (collectively the "Data") in these files contain unpublished
// information proprietary to Autodesk, Inc. ("Autodesk") and/or its licensors,
// which is protected by U.S. and Canadian federal copyright law and by
// international treaties.
//
// The Data is provided for use exclusively by You. You have the right to use,
// modify, and incorporate this Data into other products for purposes authorized 
// by the Autodesk software license agreement, without fee.
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND. AUTODESK
// DOES NOT MAKE AND HEREBY DISCLAIMS ANY EXPRESS OR IMPLIED WARRANTIES
// INCLUDING, BUT NOT LIMITED TO, THE WARRANTIES OF NON-INFRINGEMENT,
// MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE, OR ARISING FROM A COURSE 
// OF DEALING, USAGE, OR TRADE PRACTICE. IN NO EVENT WILL AUTODESK AND/OR ITS
// LICENSORS BE LIABLE FOR ANY LOST REVENUES, DATA, OR PROFITS, OR SPECIAL,
// DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES, EVEN IF AUTODESK AND/OR ITS
// LICENSORS HAS BEEN ADVISED OF THE POSSIBILITY OR PROBABILITY OF SUCH DAMAGES.

//
// provided at the time of installation or download, or which otherwise accompanies 

//
// Baking procedures
//

global string $g_ilrHwBakeVisualizerMappings[];

proc ilrCreateHwBakeVisualizerMappings()
{
	global string $g_ilrHwBakeVisualizerMappings[];

	// Sets the default mappings for assigning baked textures
	// to the ilrHwBakeVisualizer shader.
	//
	// Feel free to change these mapping in whatever way you need.
	//
	$g_ilrHwBakeVisualizerMappings[0]  = "color";				// Full Shading
	$g_ilrHwBakeVisualizerMappings[1]  = "lightMap";			// Illumination
	$g_ilrHwBakeVisualizerMappings[2]  = "lightMap";			// Indirect Illumination
	$g_ilrHwBakeVisualizerMappings[3]  = "color";				// Diffuse
	$g_ilrHwBakeVisualizerMappings[4]  = "color";				// Specular
	$g_ilrHwBakeVisualizerMappings[5]  = "ambientColor";		// Ambient
	$g_ilrHwBakeVisualizerMappings[6]  = "incandescence";		// Incandescence
	$g_ilrHwBakeVisualizerMappings[7]  = "color";				// SSS
	$g_ilrHwBakeVisualizerMappings[8]  = "color";				// Reflections
	$g_ilrHwBakeVisualizerMappings[9]  = "color";				// Refractions
	$g_ilrHwBakeVisualizerMappings[10] = "color";				// Custom
	$g_ilrHwBakeVisualizerMappings[11] = "normalMap";			// Normals
	$g_ilrHwBakeVisualizerMappings[12] = "heightMap";			// Displacement
	$g_ilrHwBakeVisualizerMappings[13] = "dirOccScaleValues";	// Directional Occlusion
	$g_ilrHwBakeVisualizerMappings[14] = "color";				// Lua (only automap when output color)
	$g_ilrHwBakeVisualizerMappings[15] = "lightABC";			// PTM ABC (Red)
	$g_ilrHwBakeVisualizerMappings[16] = "lightDEF";			// PTM DEF (Red)
	$g_ilrHwBakeVisualizerMappings[17] = "glightABC";			// PTM ABC Green
	$g_ilrHwBakeVisualizerMappings[18] = "glightDEF";			// PTM DEF Green
	$g_ilrHwBakeVisualizerMappings[19] = "blightABC";			// PTM ABC Blue
	$g_ilrHwBakeVisualizerMappings[20] = "blightDEF";			// PTM DEF Blue
	$g_ilrHwBakeVisualizerMappings[21] = "rnm1";				// Radiosity Normal Map 1
	$g_ilrHwBakeVisualizerMappings[22] = "rnm2";				// Radiosity Normal Map 2
	$g_ilrHwBakeVisualizerMappings[23] = "rnm3";				// Radiosity Normal Map 3
	$g_ilrHwBakeVisualizerMappings[24] = "ambientColor";		// Occlusion (via custom)
}

proc ilrSetHwBakeVisualizerFeatures(string $hwShader, int $passId)
{
	global string $g_ilrHwBakeVisualizerMappings[];
	if ($passId >= size($g_ilrHwBakeVisualizerMappings)) {
		error("Invalid passId in ilrVisualizeBakedTexture!");
		return;	
	}

	string $input = $g_ilrHwBakeVisualizerMappings[$passId];
	switch ($input) {
		case "color" :
			break;
		case "ambientColor" :
			setAttr ($hwShader + ".ambientColorEnabled") 1;
			break;
		case "incandescence" :
			setAttr ($hwShader + ".incandescenceEnabled") 1;
			break;
		case "lightMap" :
			setAttr ($hwShader + ".lightMapEnabled") 1;
			break;
		case "normalMap" :
			setAttr ($hwShader + ".normalMapEnabled") 1;
			break;
		case "heightMap" :
			setAttr ($hwShader + ".heightMapEnabled") 1;
			break;
		case "lightABC" :
		case "lightDEF" :
		case "glightDEF" :
		case "glightDEF" :
		case "blightDEF" :
		case "blightDEF" :
			setAttr ($hwShader + ".ptmEnabled") 1;
			setAttr ($hwShader + ".extractNormalEnabled") 1;
			break;
		case "dirOccScaleValues":
			setAttr ($hwShader + ".directionalOcclusionEnabled") 1;
			break;
		case "rnm1":
		case "rnm2":
		case "rnm3":
			setAttr ($hwShader + ".rnmEnabled") 1;
			break;
		default :
			// Do nothing ...
	}
}

proc ilrSetUvChooser(string $placeTextureNodes[], string $shapes[], string $uvSet)
{
	if($uvSet == "") {
	
		// Disconnect any uvChoosers
		//
		for($placeTextureNode in $placeTextureNodes) {
			$uvChooserNodes = `listConnections -p true -type uvChooser ($placeTextureNode + ".uvCoord")`;
			for($uvChooserNode in $uvChooserNodes) {
				disconnectAttr $uvChooserNode ($placeTextureNode + ".uvCoord");
			}
		}
		return;
	}
	
	// Find existing uvChooser
	//
	string $uvChooser = "";
	for($shape in $shapes) {
	
		// Find the actual index of the UV-set
		//
		int $uvSetIndex = 0;
		string $uvSets[] = `polyUVSet -q -allUVSets $shape`;
		for($i  = 0; $i < size($uvSets); $i++) {
			if($uvSets[$i] == $uvSet) {
				$uvSetIndex = $i;
			}
		}
	
		string $uvChoosers[] = `listConnections -type uvChooser ($shape+".uvSet["+$uvSetIndex+"].uvSetName")`;
		
		if(size($uvChoosers) > 0) {
			// Reuse an old uvChooser node, we will effectively not change existing use, just hook in more shapes
			//
			$uvChooser = $uvChoosers[0];
			break;
		} 
	}
	
	if($uvChooser == "") {
		// Create a new uvChooser node
		//
		$uvChooser = `createNode uvChooser`;
	}
	
	// Connect the uvChooser node to the placeTexture nodes
	//
	for($placeTexture in $placeTextureNodes) {
		if(!isConnected($uvChooser+".uvCoord", $placeTexture+".uvCoord")) {
			connectAttr -f ($uvChooser+".uvCoord") ($placeTexture+".uvCoord");
		}
	}
	
	for($shape in $shapes) {
	
		// Find the actual index of the UV-set
		//
		int $uvSetIndex = 0;
		string $uvSets[] = `polyUVSet -q -allUVSets $shape`;
		for($i  = 0; $i < size($uvSets); $i++) {
			if($uvSets[$i] == $uvSet) {
				$uvSetIndex = $i;
			}
		}
		
		string $uvChooserInputs[] = `listConnections -shapes true ($uvChooser+".uvSets")`;

		// Find existing entry in the uvChooser
		//
		for($i = 0; $i < size($uvChooserInputs); $i++) {
			if($uvChooserInputs[$i] == $shape) {
				break;
			} 
		}
		int $uvChooserIndex = $i;

		// Connect the shape uvSetName to the next free slot or an existing entry in the uvChooser
		//
		if(!isConnected($shape+".uvSet["+$uvSetIndex+"].uvSetName", $uvChooser+".uvSets["+$uvChooserIndex+"]")) {
			connectAttr -f ($shape+".uvSet["+$uvSetIndex+"].uvSetName") ($uvChooser+".uvSets["+$uvChooserIndex+"]");
		}
	}
	
}

global proc string ilrCreateBakedTexture(string $file, float $originU, float $originV, float $coverU, float $coverV, string $shapes[], string $uvSet)
{
	// Get name of texture
	string $tokarray[];
	int $numTokens = `tokenize $file "\\/" $tokarray`;
	string $tok = $tokarray[$numTokens-1];
	$numTokens = `tokenize $tok "." $tokarray`;
	string $texname = $tokarray[0];

	// Create file texture...
	string $fileTexture  = `shadingNode -asTexture -name $texname file`;
	AEassignTextureCB ($fileTexture+".fileTextureName") $file "image";

	//...and place it correctly
	string $placeTexture = `shadingNode -asUtility place2dTexture`;
	setAttr ($placeTexture+".translateFrameU") $originU;
	setAttr ($placeTexture+".translateFrameV") $originV;
	setAttr ($placeTexture+".coverageU") $coverU;
	setAttr ($placeTexture+".coverageV") $coverV;
	connectAttr -f ($placeTexture+".coverage")        ($fileTexture+".coverage");
	connectAttr -f ($placeTexture+".translateFrame")  ($fileTexture+".translateFrame");
	connectAttr -f ($placeTexture+".rotateFrame")     ($fileTexture+".rotateFrame");
	connectAttr -f ($placeTexture+".mirrorU")         ($fileTexture+".mirrorU");
	connectAttr -f ($placeTexture+".mirrorV")         ($fileTexture+".mirrorV");
	connectAttr -f ($placeTexture+".stagger")         ($fileTexture+".stagger");
	connectAttr -f ($placeTexture+".wrapU")           ($fileTexture+".wrapU");
	connectAttr -f ($placeTexture+".wrapV")           ($fileTexture+".wrapV");
	connectAttr -f ($placeTexture+".repeatUV")        ($fileTexture+".repeatUV");
	connectAttr -f ($placeTexture+".offset")          ($fileTexture+".offset");
	connectAttr -f ($placeTexture+".rotateUV")        ($fileTexture+".rotateUV");
	connectAttr -f ($placeTexture+".noiseUV")         ($fileTexture+".noiseUV");
	connectAttr -f ($placeTexture+".vertexUvOne")     ($fileTexture+".vertexUvOne");
	connectAttr -f ($placeTexture+".vertexUvTwo")     ($fileTexture+".vertexUvTwo");
	connectAttr -f ($placeTexture+".vertexUvThree")   ($fileTexture+".vertexUvThree");
	connectAttr -f ($placeTexture+".vertexCameraOne") ($fileTexture+".vertexCameraOne");
	connectAttr    ($placeTexture+".outUV")           ($fileTexture+".uv");
	connectAttr    ($placeTexture+".outUvFilterSize") ($fileTexture+".uvFilterSize");
	
	// Connect a uvChooser if necessary
	//
	ilrSetUvChooser {$placeTexture} $shapes $uvSet;
	
	return $fileTexture;
}

global proc ilrVisualizeBakedTexture(string $sg, string $file, string $shapes[], string $uvSet, int $colorPassId, int $alphaPassId, float $originU, float $originV, float $coverU, float $coverV, string $texLayerR, string $texLayerG, string $texLayerB, string $texLayerA)
{
	global string $g_ilrHwBakeVisualizerMappings[];
	if (size($g_ilrHwBakeVisualizerMappings) == 0) {
		ilrCreateHwBakeVisualizerMappings();
	}
	if ($colorPassId >= size($g_ilrHwBakeVisualizerMappings)) {
		error("Invalid colorPassId in ilrVisualizeBakedTexture!");
		return;	
	}
	
	// Find connected shader and make sure it has an hardwareShader input
	//
	string $items[] = `listConnections ($sg + ".surfaceShader")`;
	if (size($items) == 0) {
		return;
	}
	string $shader = $items[0];
	if (!`attributeQuery -exists -node $shader "hardwareShader"`) {
		return;
	}
	
	// Find connected shapes to the shading group
	//
	string $sgShapes[] = `listConnections -shapes true ($sg + ".dagSetMembers")`;
	
	// Check if shading group and shapes list is the same
	//
	int $shapeMatch = 0;
	
	// Use switches to manage the shading group if there are objects in the shading group that aren't using this texture
	int $switchedShadingGroup = size($shapes) != size($sgShapes);
	
	string $shaderAttr = $shader + ".hardwareShader";
	string $hwShader = "";
	
	// Use old HwBakeVisualizer if it exists,
	// otherwise create and assign a new one
	//
	$items = `listConnections $shaderAttr`;
	if (size($items) > 0) {
		if (`nodeType $items[0]` == "ilrHwBakeVisualizer") {
			$hwShader = $items[0];
		}
	}
	if ($hwShader == "") {
		$hwShader = `shadingNode -asShader ilrHwBakeVisualizer`;
		connectAttr -f ($hwShader + ".outColor") $shaderAttr;
	}
	
	string $hwShaderColorAttr = $hwShader + "." + $g_ilrHwBakeVisualizerMappings[$colorPassId];
	string $colorAttrs[];
	string $createFileTexture = false;
	string $fileTexture = "";
	string $placeTextureNodes[];

	// See if an old file texture can be used
	//
	$items = `listConnections $hwShaderColorAttr`;
	if (size($items) > 0) {
		if (`nodeType $items[0]` == "file") {
			$fileTexture = $items[0];
			
			// If we are using switches to manage the shader, connect the old input to the default input of a switch node
			//
			if($switchedShadingGroup) {
				string $switchNode = `shadingNode -asUtility tripleShadingSwitch`;
				connectAttr ($fileTexture+".outColor") ($switchNode+".default");
				connectAttr -force ($switchNode+".output") $hwShaderColorAttr;
				int $i;
				for($i = 0; $i < size($shapes); $i++) {
					connectAttr ($shapes[$i]+".instObjGroups[0]") ($switchNode+".input["+$i+"].inShape");
					$colorAttrs[size($colorAttrs)] = ($switchNode+".input["+$i+"].inTriple");
				}
				$createFileTexture = true;
			} else {
				$items = `listConnections ($fileTexture + ".uvCoord")`;
				if (size($items) > 0) {
					string $placeTexture = $items[0];
					setAttr ($placeTexture+".translateFrameU") $originU;
					setAttr ($placeTexture+".translateFrameV") $originV;
					setAttr ($placeTexture+".coverageU") $coverU;
					setAttr ($placeTexture+".coverageV") $coverV;
					AEassignTextureCB ($fileTexture+".fileTextureName") $file "image";
					$placeTextureNodes[size($placeTextureNodes)] = $placeTexture;
				} else {
					// If no place texture node is connected to this texture,
					// it's better to create a new texture node instead
					$colorAttrs[size($colorAttrs)] = $hwShaderColorAttr;
					$createFileTexture = true;
				}
			}
		} else if(`nodeType $items[0]` == "tripleShadingSwitch") {
			string $switchNode = $items[0];
			
			for($shape in $shapes) {

				// Try to find an entry for the shape
				// 
				int $i = 0;
				int $numInputs = size(`listConnections ($switchNode+".input")`) / 2;
				for($i = 0; $i < $numInputs; $i++) {
					string $inputShape[] = `listConnections -shapes true ($switchNode+".input["+$i+"].inShape")`;
					//string $inputTransform[] = `listConnections -shapes false ($switchNode+".input["+$i+"].inShape")`;
					
					string $cmd = "ls -l " + $inputShape[0];
					string $completeName[] = eval($cmd);
					
					//string $s = "Shape: " + $shape + "\n";
					//print $s;
					//string $s = "compelteanme: " + $completeName[0] + "\n";
					//print $s;
					
					if($shape == $completeName[0]) {
					//	print("found matching shapes\n");
						break;
					}
				}

				string $switchColorAttr = ($switchNode+".input["+$i+"].inTriple");
				
				// Create a new input if no entry was found, otherwise reuse the existing one
				//
				int $foundValidEntry = false;
				if($i < $numInputs) {

					// Reuse an existing file input
					//
					$items = `listConnections $switchColorAttr`;
					if (size($items) > 0 && `nodeType $items[0]` == "file") {
						$fileTexture = $items[0];
						
						$items = `listConnections ($fileTexture + ".uvCoord")`;
						$outputs = `listConnections ($fileTexture + ".outColor")`;
						if (size($items) > 0 && size($outputs) == 1) {
							string $placeTexture = $items[0];
							setAttr ($placeTexture+".translateFrameU") $originU;
							setAttr ($placeTexture+".translateFrameV") $originV;
							setAttr ($placeTexture+".coverageU") $coverU;
							setAttr ($placeTexture+".coverageV") $coverV;
							AEassignTextureCB ($fileTexture+".fileTextureName") $file "image";
							$placeTextureNodes[size($placeTextureNodes)] = $placeTexture;
							$foundValidEntry = true;
						} 
					}	
				} 
				if(!$foundValidEntry) {
					// If no file texture node was found that had a valid Place Texture node, create a new one
					//
					if(!isConnected($shape+".instObjGroups[0]", $switchNode+".input["+$i+"].inShape")) {
						connectAttr -force ($shape+".instObjGroups[0]") ($switchNode+".input["+$i+"].inShape");
					}
					$colorAttrs[size($colorAttrs)] = $switchColorAttr;
					$createFileTexture = true;
				}
			}
		}
	} else {
	
		// No existing input was found, create a switch if using switchedShadingGroup
		//
		if($switchedShadingGroup) {
			string $switchNode = `shadingNode -asUtility tripleShadingSwitch`;
			connectAttr -force ($switchNode+".output") $hwShaderColorAttr;
			int $i;
			for($i = 0; $i < size($shapes); $i++) {
				connectAttr ($shapes[$i]+".instObjGroups[0]") ($switchNode+".input["+$i+"].inShape");
				string $colorAttr = ($switchNode+".input["+$i+"].inTriple");
				$colorAttrs[size($colorAttrs)] = $colorAttr;				
			}
			$createFileTexture = true;
		} else {
			// Just connect the file directly to the hardware shader
			$colorAttrs[size($colorAttrs)] = $hwShaderColorAttr;
			$createFileTexture = true;
		}
	}
	
	// If no texture file was found create and assign a new one.
	// Also create a new texture node if it's a layered texture
	// (OpenEXR Multilayer).
	//	
	if ($createFileTexture == true) {
		$fileTexture = ilrCreateBakedTexture($file, $originU, $originV, $coverU, $coverV, $shapes, $uvSet);
		if ($colorPassId == 12) {
			for($colorAttr in $colorAttrs) {
				connectAttr -f ($fileTexture + ".outAlpha") $colorAttr; // Heightmap
			}
		} else {
			for($colorAttr in $colorAttrs) {
				$alreadyConnected = isConnected($fileTexture + ".outColor", $colorAttr);
				if ($alreadyConnected == 0) {
					connectAttr -f ($fileTexture + ".outColor") $colorAttr;
				} else {
					disconnectAttr ($fileTexture + ".outColor") $colorAttr;
					connectAttr -f ($fileTexture + ".outColor") $colorAttr;			
				}
			}
		}
	} else {
		// connect uvChooser node
		ilrSetUvChooser $placeTextureNodes $shapes $uvSet;
	}

	// If an alpha pass is used, connect the alpha to the corresponding input
	// and enable the hw shader feature corresponding to the alpha pass
	//
	if ($alphaPassId > 0) {
		if ($alphaPassId >= size($g_ilrHwBakeVisualizerMappings)) {
			error("Invalid alphaPassId in ilrVisualizeBakedTexture!");
			// TODO: should this return error?
			return;
		}
		string $alphaAttr = $hwShader + "." + $g_ilrHwBakeVisualizerMappings[$alphaPassId];
		if (!`isConnected ($fileTexture + ".outAlpha") $alphaAttr`) {
			connectAttr -f ($fileTexture + ".outAlpha") $alphaAttr;
		}
		ilrSetHwBakeVisualizerFeatures($hwShader, $alphaPassId);
	}
	
	// If it's a layered texture, select which layer should be used
	//
	if (size($texLayerR) > 0) {
		ilrTextureAttributes(1, $fileTexture);
		setAttr -type "string" ($fileTexture + ".ilrLayerR") $texLayerR;
		setAttr -type "string" ($fileTexture + ".ilrLayerG") $texLayerG;
		setAttr -type "string" ($fileTexture + ".ilrLayerB") $texLayerB;
		setAttr -type "string" ($fileTexture + ".ilrLayerA") $texLayerA;
	}
	
	// Enable the hw shader feature corresponding to the color pass
	//
	ilrSetHwBakeVisualizerFeatures($hwShader, $colorPassId);
	
	// Update the assigned textures in the hardware texture cache
	//
	ilrHwTextureCacheUpdate($hwShader);
	
	// Force update of the uv-sets in the hardware shader
	for($shape in $shapes) {
		$curUvSet = `polyUVSet -q -currentUVSet $shape`;
		polyUVSet -currentUVSet -uvSet $curUvSet $shape;
	}
	
}

global proc string ilrGetCommonBakeCmdString(string $layer, string $layerOptionsOverride)
{
	string $cmd = "";
	
	int $renderSelection = `getAttr ($layer + ".renderSelection")`;

	if ($renderSelection)
	{
		string $tmplayer = `createNode "ilrBakeLayer" -skipSelect`;
		string $items[] = `ls -selection`;
		for ($item in $items) {
			ilrAddSurfaceToBakeLayer($item, $tmplayer);
		}
		string $members[] = `sets -query $tmplayer`;
		for ($member in $members)
		{
			// Unable to set vertex colors when this is locked
			setAttr -l off ($member + ".displayColors");

			$cmd += " -target \"" + $member + "\""; 
		}
		delete $tmplayer;
	}
	else
	{
		// Add all member surfaces to the command, with it's 
		// corresponding source and envelope surfaces
		//
		string $members[] = `sets -query $layer`;
		for ($member in $members)
		{
			// Unable to set vertex colors when this is locked
			setAttr -l off ($member + ".displayColors");

			$cmd += " -target \"" + $member + "\""; 
		
			string $sources[] = ilrGetBakeLayerSourceSurfaces($layer, $member);
			for ($source in $sources) {
				$cmd += " -source \"" + $source + "\""; 
			}
			
			string $envelopes[] = ilrGetBakeLayerEnvelopeSurfaces($layer, $member);
			for ($envelope in $envelopes) {
				$cmd += " -envelope \"" + $envelope + "\""; 
			}
		}
	}
	
	// Check is an overriding layer's options should be used
	//
	if (size($layerOptionsOverride)) {
		$layer = $layerOptionsOverride;
	}
	
	$cmd += " -frontRange " + `getAttr ($layer + ".frontRange")`;
	$cmd += " -backRange " + `getAttr ($layer + ".backRange")`;
	$cmd += " -frontBias " + `getAttr ($layer + ".frontBias")`;
	$cmd += " -backBias " + `getAttr ($layer + ".backBias")`;
	$cmd += " -transferSpace " + `getAttr ($layer + ".transferSpace")`;
	$cmd += " -selectionMode " + `getAttr ($layer + ".selectionMode")`;
	$cmd += " -mismatchMode " + `getAttr ($layer + ".mismatchMode")`;
	$cmd += " -envelopeMode " + `getAttr ($layer + ".envelopeMode")`;
	$cmd += " -ignoreInconsistentNormals " + `getAttr ($layer + ".ignoreInconsistentNormals")`;
	$cmd += " -considerTransparency " + `getAttr ($layer + ".considerTransparency")`;
	$cmd += " -transparencyThreshold " + `getAttr ($layer + ".transparencyThreshold")`;
	
	$cmd += " -camera " + "\"" + `getAttr ($layer + ".camera")` + "\"";
	$cmd += " -normalDirection " + `getAttr ($layer + ".normalDirection")`;
	$cmd += " -shadows " + `getAttr ($layer + ".shadows")`;
	$cmd += " -alpha " + `getAttr ($layer + ".alpha")`;
	$cmd += " -viewDependent " + `getAttr ($layer + ".viewDependent")`;
	$cmd += " -orthoRefl " + `getAttr ($layer + ".orthoRefl")`;
	$cmd += " -backgroundColor " + `getAttr ($layer + ".backgroundColorR")` + " " + `getAttr ($layer + ".backgroundColorG")` + " " + `getAttr ($layer + ".backgroundColorB")`;
	$cmd += " -frame " + `currentTime -query`;
	$cmd += " -bakeLayer " + $layer;

	return $cmd;
}

global proc string ilrGetTextureBakeCmdString(string $layer, string $layerOptionsOverride)
{
	// Create the surface transfer command string 
	// from the given bake layer and options
	//
	string $cmd = "ilrTextureBakeCmd";

	// Add common flags
	//
	$cmd += ilrGetCommonBakeCmdString($layer, $layerOptionsOverride);
	
	// Check is an overriding layer's options should be used
	//
	if (size($layerOptionsOverride)) {
		$layer = $layerOptionsOverride;
	}
		
	//
	// Add texure bake specific flags
	//
	$cmd += " -width " + `getAttr ($layer + ".tbResX")`;
	$cmd += " -height " + `getAttr ($layer + ".tbResY")`;
	$cmd += " -saveToRenderView " +  `getAttr ($layer + ".tbSaveToRenderView")`;
	$cmd += " -saveToFile " +  `getAttr ($layer + ".tbSaveToFile")`;
	if (`getAttr ($layer + ".tbSaveToFile")`) {
		string $d = `getAttr ($layer + ".tbDirectory")`;
		if (size($d) == 0) {
			$d = ilrGetBakedTextureDir();
		}
		$d = `workspace -expandName $d`; //Relative path fix.
		string $f = `getAttr ($layer + ".tbFileName")`;
		if (size($f) == 0) {
			$f = "baked_$p_$s.$e";
		}
		$cmd += " -directory " + "\"" + $d + "\"";
		$cmd += " -fileName "  + "\"" + $f + "\"";
		$cmd += " -fileFormat " + `getAttr ($layer + ".tbImageFormat")`;
		$cmd += " -visualize " +  `getAttr ($layer + ".tbVisualize")`;
	}
	$cmd += " -uvRange " + `getAttr ($layer + ".tbUvRange")`;
	$cmd += " -uMin " + `getAttr ($layer + ".tbUMin")`;
	$cmd += " -uMax " + `getAttr ($layer + ".tbUMax")`;
	$cmd += " -vMin " + `getAttr ($layer + ".tbVMin")`;
	$cmd += " -vMax " + `getAttr ($layer + ".tbVMax")`;
	$cmd += " -uvSet " + "\"" +`getAttr ($layer + ".tbUvSet")` + "\"";
	$cmd += " -tangentUvSet " + "\"" +`getAttr ($layer + ".tbTangentUvSet")` + "\"";
	$cmd += " -edgeDilation " + `getAttr ($layer + ".tbEdgeDilation")`;
	$cmd += " -bilinearFilter " + `getAttr ($layer + ".tbBilinearFilter")`;
	$cmd += " -merge " + `getAttr ($layer + ".tbMerge")`;
	$cmd += " -conservative " + `getAttr ($layer + ".tbConservative")`; 
	$cmd += " -windingOrder " + `getAttr ($layer + ".tbWindingOrder")`;

	//
	// Add output pass flags
	//
	if (`getAttr ($layer + ".fullShading")`)
		$cmd += " -fullShading 1";
	if (`getAttr ($layer + ".illumination")`)
		$cmd += " -illumination 1";
	if (`getAttr ($layer + ".indirectIllumination")`)
		$cmd += " -indirectIllumination 1";
	if (`getAttr ($layer + ".albedo")`)
		$cmd += " -albedo 1";
	if (`getAttr ($layer + ".diffuse")`)
		$cmd += " -diffuse 1";
	if (`getAttr ($layer + ".specular")`)
		$cmd += " -specular 1";
	if (`getAttr ($layer + ".ambient")`)
		$cmd += " -ambient 1";
	if (`getAttr ($layer + ".incandescence")`)
		$cmd += " -incandescence 1";
	if (`getAttr ($layer + ".sss")`)
		$cmd += " -sss 1";
	if (`getAttr ($layer + ".reflections")`)
		$cmd += " -reflections 1";
	if (`getAttr ($layer + ".refractions")`)
		$cmd += " -refractions 1";
	if (`getAttr ($layer + ".custom")`) {
		string $connections[] = `listConnections ($layer + ".customShader")`;
		if (size($connections)) {
			$cmd += " -custom 1";
			$cmd += " -customShader \"" + $connections[0] + "\"";
		}
	}
	if (`getAttr ($layer + ".normals")`)	{
		$cmd += " -normals 1";
		$cmd += " -normalsCoordSys " + `getAttr ($layer + ".normalsCoordSys")`;
		$cmd += " -normalsFlipChannel " + `getAttr ($layer + ".normalsFlipChannel")`;
		$cmd += " -normalsFaceTangents " + `getAttr ($layer + ".normalsFaceTangents")`;
		$cmd += " -normalsUseBump " + `getAttr ($layer + ".normalsUseBump")`;
		$cmd += " -stencilBake " + `getAttr ($layer + ".stencilBake")`;
		if (`getAttr ($layer + ".displacementAlpha")`) {
			$cmd += " -displacementAlpha " + `getAttr ($layer + ".displacementAlpha")`;
			$cmd += " -displacementRemap " + `getAttr ($layer + ".displacementRemap")`;
			$cmd += " -displacementScale " + `getAttr ($layer + ".displacementScale")`;
			$cmd += " -displacementOffset " + `getAttr ($layer + ".displacementOffset")`;
		}
	}
	if (`getAttr ($layer + ".displacement")`) {
		$cmd += " -displacement 1";
		$cmd += " -displacementRemap " + `getAttr ($layer + ".displacementRemap")`;
		$cmd += " -displacementScale " + `getAttr ($layer + ".displacementScale")`;
		$cmd += " -displacementOffset " + `getAttr ($layer + ".displacementOffset")`;
	}
	if (`getAttr ($layer + ".lua")`) {
		$cmd += " -lua 1";
		if (`getAttr ($layer + ".luaFile")`) {
			$shortLuaFile = `getAttr ($layer + ".luaFile")`;
			$longLuaFile = `file -q -expandName $shortLuaFile`;
			$cmd += " -luaFile " + "\"" + $longLuaFile + "\"";
		}
	}
	if (`getAttr ($layer + ".dirOcc")`) {
		$cmd += " -dirOcc 1";
		$cmd += " -dirOccSamples " + `getAttr ($layer + ".dirOccSamples")`;
		$cmd += " -dirOccExponent " + `getAttr ($layer + ".dirOccExponent")`;
		$cmd += " -dirOccVector1 " + `getAttr ($layer + ".dirOccVector1X")` + " " + `getAttr ($layer + ".dirOccVector1Y")` + " " + `getAttr ($layer + ".dirOccVector1Z")`;
		$cmd += " -dirOccVector2 " + `getAttr ($layer + ".dirOccVector2X")` + " " + `getAttr ($layer + ".dirOccVector2Y")` + " " + `getAttr ($layer + ".dirOccVector2Z")`;
		$cmd += " -dirOccVector3 " + `getAttr ($layer + ".dirOccVector3X")` + " " + `getAttr ($layer + ".dirOccVector3Y")` + " " + `getAttr ($layer + ".dirOccVector3Z")`;
		$cmd += " -dirOccVector4 " + `getAttr ($layer + ".dirOccVector4X")` + " " + `getAttr ($layer + ".dirOccVector4Y")` + " " + `getAttr ($layer + ".dirOccVector4Z")`;
	}
	if (`getAttr ($layer + ".rnm")`) {
		$cmd += " -rnm 1";
		$cmd += " -rnmSampleType " + `getAttr ($layer + ".rnmSampleType")`;
		$cmd += " -rnmAdjustIntensity " + `getAttr ($layer + ".rnmAdjustIntensity")`;
		$cmd += " -rnmSamples " + `getAttr ($layer + ".rnmSamples")`;
	}
	if (`getAttr ($layer + ".ptm")`) {
		$cmd += " -ptm 1";
		$cmd += " -ptmSampleType " + `getAttr ($layer + ".ptmSampleType")`;
		$cmd += " -ptmOutput " + `getAttr ($layer + ".ptmOutput")`;
		$cmd += " -ptmSamples " + `getAttr ($layer + ".ptmSamples")`;
	}
	if (`getAttr ($layer + ".sph")`) {
		$cmd += " -sph 1";
		$cmd += " -sphSampleType " + `getAttr ($layer + ".sphSampleType")`;
		$cmd += " -sphSpaceType " + `getAttr ($layer + ".sphSpaceType")`;
		//$cmd += " -sphSignLess " + `getAttr ($layer + ".sphSignLess")`;
		$cmd += " -sphOutput " + `getAttr ($layer + ".sphOutput")`;
		$cmd += " -sphSamples " + `getAttr ($layer + ".sphSamples")`;
		$cmd += " -sphBands " + `getAttr ($layer + ".sphBands")`;
		$cmd += " -sphConeAngle " + `getAttr ($layer + ".sphConeAngle")`;
	}

	return $cmd;
}

global proc string ilrGetVertexBakeCmdString(string $layer, string $layerOptionsOverride)
{
	// Create the vertex bake command string 
	// from the given bake layer and options
	//
	string $cmd = "ilrVertexBakeCmd";

	// Add common flags
	//
	$cmd += ilrGetCommonBakeCmdString($layer, $layerOptionsOverride);
	
	// Check is an overriding layer's options should be used
	//
	if (size($layerOptionsOverride)) {
		$layer = $layerOptionsOverride;
	}

	//
	// Add vertex bake specific flags
	//
	$cmd += " -samplingMode " + `getAttr ($layer + ".vbSamplingMode")`;
	if (`getAttr ($layer + ".vbSamplingMode")` > 0) {
		$cmd += " -minSamples " + `getAttr ($layer + ".vbMinSamples")`;
		$cmd += " -maxSamples " + `getAttr ($layer + ".vbMaxSamples")`;
	}
	$cmd += " -vertexBias " + `getAttr ($layer + ".vbVertexBias")`;
	$cmd += " -camera " + "\"" + `getAttr ($layer + ".camera")` + "\"";
	$cmd += " -frame " + `currentTime -query`;
	$cmd += " -shadows " + `getAttr ($layer + ".shadows")`;
	$cmd += " -orthoRefl " + `getAttr ($layer + ".orthoRefl")`;
	$cmd += " -alpha " + `getAttr ($layer + ".alpha")`;
	$cmd += " -normalDirection " + `getAttr ($layer + ".normalDirection")`;
	$cmd += " -viewDependent " + `getAttr ($layer + ".viewDependent")`;
	$cmd += " -useBlending " + `getAttr ($layer + ".vbUseBlending")`;
	$cmd += " -rgbBlend " + `getAttr ($layer + ".vbRgbBlend")`;
	$cmd += " -alphaBlend " + `getAttr ($layer + ".vbAlphaBlend")`;
	$cmd += " -rgbScale " + `getAttr ($layer + ".vbRgbScale")`;
	$cmd += " -alphaScale " + `getAttr ($layer + ".vbAlphaScale")`;
	$cmd += " -saveToColorSet " + `getAttr ($layer + ".vbSaveToColorSet")`;
	if (`getAttr ($layer + ".vbSaveToColorSet")`) {
		string $colorSet = `getAttr ($layer + ".vbColorSet")`;
		if (size($colorSet) == 0) {
			$colorSet = "baked_$p";
		}
		$cmd += " -colorSet " + "\"" + $colorSet + "\"";
		$cmd += " -overwriteColorSet " + `getAttr ($layer + ".vbOverwriteColorSet")`;
	}
	$cmd += " -saveToFile " +  `getAttr ($layer + ".vbSaveToFile")`;
	if (`getAttr ($layer + ".vbSaveToFile")`) {
		string $d = `getAttr ($layer + ".vbDirectory")`;
		if (size($d) == 0) {
			$d = ilrGetBakedTextureDir();
		}
		$d = `workspace -expandName $d`; //Relative path fix.
		string $f = `getAttr ($layer + ".vbFileName")`;
		if (size($f) == 0) {
			$f = "baked_$p_$b.pc";
		}
		$cmd += " -directory " + "\"" + $d + "\"";
		$cmd += " -fileName "  + "\"" + $f + "\"";
	}	
	if (`getAttr ($layer + ".vbClamp")`) {
		$cmd += " -clamp 1";
		$cmd += " -rgbMin " + `getAttr ($layer + ".vbRgbMinR")` + " " + `getAttr ($layer + ".vbRgbMinG")` + " " + `getAttr ($layer + ".vbRgbMinB")`;
		$cmd += " -rgbMax " + `getAttr ($layer + ".vbRgbMaxR")` + " " + `getAttr ($layer + ".vbRgbMaxG")` + " " + `getAttr ($layer + ".vbRgbMaxB")`;
		$cmd += " -alphaMin " + `getAttr ($layer + ".vbAlphaMin")`;
		$cmd += " -alphaMax " + `getAttr ($layer + ".vbAlphaMax")`;
	}
	if (`getAttr ($layer + ".vbFilter")`) {
		$cmd += " -filter 1";
		$cmd += " -filterSize " + `getAttr ($layer + ".vbFilterSize")`;
		$cmd += " -filterShape " + `getAttr ($layer + ".vbFilterShape")`;
		$cmd += " -filterNormalDev " + `getAttr ($layer + ".vbFilterNormalDev")`;
	}

	//
	// Add output pass flags
	//
	if (`getAttr ($layer + ".fullShading")`)
		$cmd += " -fullShading 1";
	if (`getAttr ($layer + ".illumination")`)
		$cmd += " -illumination 1";
	if (`getAttr ($layer + ".indirectIllumination")`)
		$cmd += " -indirectIllumination 1";
	if (`getAttr ($layer + ".albedo")`)
		$cmd += " -albedo 1";
	if (`getAttr ($layer + ".diffuse")`)
		$cmd += " -diffuse 1";
	if (`getAttr ($layer + ".specular")`)
		$cmd += " -specular 1";
	if (`getAttr ($layer + ".ambient")`)
		$cmd += " -ambient 1";
	if (`getAttr ($layer + ".incandescence")`)
		$cmd += " -incandescence 1";
	if (`getAttr ($layer + ".sss")`)
		$cmd += " -sss 1";
	if (`getAttr ($layer + ".reflections")`)
		$cmd += " -reflections 1";
	if (`getAttr ($layer + ".refractions")`)
		$cmd += " -refractions 1";
	if (`getAttr ($layer + ".custom")`) {
		string $connections[] = `listConnections ($layer + ".customShader")`;
		if (size($connections)) {
			$cmd += " -custom 1";
			$cmd += " -customShader \"" + $connections[0] + "\"";
		}
	}	
	if (`getAttr ($layer + ".rnm")`) {
		$cmd += " -rnm 1";
		$cmd += " -rnmSampleType " + `getAttr ($layer + ".rnmSampleType")`;
		$cmd += " -rnmAdjustIntensity " + `getAttr ($layer + ".rnmAdjustIntensity")`;
		$cmd += " -rnmSamples " + `getAttr ($layer + ".rnmSamples")`;
		
	}
	if (`getAttr ($layer + ".lua")`) {
		$cmd += " -lua 1";
		if (`getAttr ($layer + ".luaFile")`) {
			$shortLuaFile = `getAttr ($layer + ".luaFile")`;
			$longLuaFile = `file -q -expandName $shortLuaFile`;
			$cmd += " -luaFile " + "\"" + $longLuaFile + "\"";
		}
	}

	if (`getAttr ($layer + ".ptm")`) {
		$cmd += " -ptm 1";
		$cmd += " -ptmSampleType " + `getAttr ($layer + ".ptmSampleType")`;
		$cmd += " -ptmOutput " + `getAttr ($layer + ".ptmOutput")`;
		$cmd += " -ptmSamples " + `getAttr ($layer + ".ptmSamples")`;
	}
	if (`getAttr ($layer + ".dirOcc")`) {
		$cmd += " -dirOcc 1";
		$cmd += " -dirOccSamples " + `getAttr ($layer + ".dirOccSamples")`;
		$cmd += " -dirOccExponent " + `getAttr ($layer + ".dirOccExponent")`;
		$cmd += " -dirOccVector1 " + `getAttr ($layer + ".dirOccVector1X")` + " " + `getAttr ($layer + ".dirOccVector1Y")` + " " + `getAttr ($layer + ".dirOccVector1Z")`;
		$cmd += " -dirOccVector2 " + `getAttr ($layer + ".dirOccVector2X")` + " " + `getAttr ($layer + ".dirOccVector2Y")` + " " + `getAttr ($layer + ".dirOccVector2Z")`;
		$cmd += " -dirOccVector3 " + `getAttr ($layer + ".dirOccVector3X")` + " " + `getAttr ($layer + ".dirOccVector3Y")` + " " + `getAttr ($layer + ".dirOccVector3Z")`;
		$cmd += " -dirOccVector4 " + `getAttr ($layer + ".dirOccVector4X")` + " " + `getAttr ($layer + ".dirOccVector4Y")` + " " + `getAttr ($layer + ".dirOccVector4Z")`;
	}
	
	if (`getAttr ($layer + ".sph")`) {
		$cmd += " -sph 1";
		$cmd += " -sphSampleType " + `getAttr ($layer + ".sphSampleType")`;
		$cmd += " -sphSpaceType " + `getAttr ($layer + ".sphSpaceType")`;
		//$cmd += " -sphSignLess " + `getAttr ($layer + ".sphSignLess")`;
		$cmd += " -sphOutput " + `getAttr ($layer + ".sphOutput")`;
		$cmd += " -sphSamples " + `getAttr ($layer + ".sphSamples")`;
		$cmd += " -sphBands " + `getAttr ($layer + ".sphBands")`;
		$cmd += " -sphConeAngle " + `getAttr ($layer + ".sphConeAngle")`;
	}

	
	return $cmd;
}

global proc ilrBakeCallback(int $width, int $height, int $doShadow, int $doGlow, string $camera, string $extraOptions)
{
	global int $g_ilrRenderRegionFlag;

	ilrDefaultNodes(1);

	string $layer = ilrGetCurrentBakeLayer();

	// Create the bake command
	//
	string $cmd = "";

	int $bakeTo = `getAttr ($layer + ".renderType")`;
	switch ($bakeTo)
	{
		case 1: // Texture
			$cmd = ilrGetTextureBakeCmdString($layer, "");
			$cmd += " -useRenderView 1";
			$cmd += $extraOptions;
			if ($g_ilrRenderRegionFlag) {
				int $r[] = `ilrRenderWindowCmd -region`;
				if (size($r) >= 4) {
					$cmd += " -region " + $r[0] + " " + $r[1] + " " + $r[2] + " " + $r[3];
				}
			}
			break;
		case 2: // Vertices
			$cmd = ilrGetVertexBakeCmdString($layer, "");
			$cmd += $extraOptions;
			break;
	}
	
	if (size($cmd) == 0)
	{
		error("Unsupported bake type, baking aborted!");
		return;
	}
	
	print($cmd + "\n");

	// Run command
	//
	string $items[] = `selectedNodes`;	
	if ( catch( eval($cmd) ) )
	{
		ilrProgressEnd();
		select -replace $items;
		error("Error during baking, see script editor for details!");
	}
	select -replace $items;

	// If vertex baking, setup shading to show vertex colors
	//
	if ($bakeTo == 2 && `optionVar -query polyAutoShowColorPerVertex`)
	{
		optionVar -intValue colorShadedDisplay 1 -intValueAppend colorShadedDisplay 1;
		polyOptions -cs 1;
		DisplaySmoothShaded;
	}
}

// Bake region procedure
// We use Maya's render region procedure, but make sure
// Turtle gets the -region flag
// 
global proc ilrBakeRegionCallback(string $editor)
{
	global int $g_ilrRenderRegionFlag;

	string $layer = ilrGetCurrentBakeLayer();
	if (`getAttr ($layer + ".renderType")` != 1)
	{
		error("Current bake type doesn't support region rendering!");
		return;
	}

	int $oldwidth  = `getAttr defaultResolution.width`;
	int $oldheight = `getAttr defaultResolution.height`;

	setAttr defaultResolution.width `getAttr ($layer + ".tbResX")`;
	setAttr defaultResolution.height `getAttr ($layer + ".tbResY")`;

	$g_ilrRenderRegionFlag = 1;
	eval("mayaRenderRegion " + $editor);
	$g_ilrRenderRegionFlag = 0;

	setAttr defaultResolution.width $oldwidth;
	setAttr defaultResolution.height $oldheight;
}

global proc ilrBakeBatchCallback(string $extraOptions)
{
	string $bakeLayers[] = `ls -type ilrBakeLayer`;
	for ($layer in $bakeLayers)
	{
		// Render all renderable layers that are not empty
		//
		int $renderable = (size(`sets -query $layer`) && `getAttr ($layer + ".renderable")`);
		if ($renderable)
		{
			// Make sure the output is saved to file
			//
			int $tbSaveToFile = `getAttr ($layer + ".tbSaveToFile")`;
			int $vbSaveToFile = `getAttr ($layer + ".tbSaveToFile")`;
			int $vbSaveToColorSet = `getAttr ($layer + ".vbSaveToColorSet")`;
			setAttr ($layer + ".tbSaveToFile") 1;
			setAttr ($layer + ".vbSaveToFile") 1;
			setAttr ($layer + ".vbSaveToColorSet") 0;
		
			// Create the bake command
			//
			string $cmd = "";

			int $bakeTo = `getAttr ($layer + ".renderType")`;
			switch ($bakeTo)
			{
				case 1: // Texture
					$cmd = ilrGetTextureBakeCmdString($layer, "");
					$cmd += " -useRenderView 0";
					$cmd += $extraOptions;
					break;
				case 2: // Vertices
					$cmd = ilrGetVertexBakeCmdString($layer, "");
					$cmd += $extraOptions;
					break;
			}
			
			// Reset the save options
			//
			setAttr ($layer + ".tbSaveToFile") $tbSaveToFile;
			setAttr ($layer + ".vbSaveToFile") $vbSaveToFile;
			setAttr ($layer + ".vbSaveToColorSet") $vbSaveToColorSet;
			
			if (size($cmd) == 0)
			{
				error("Unsupported bake type, baking aborted!");
				return;
			}
			
			print("\n\n" + $cmd + "\n\n");

			// Start the render
			//
			if ( catch( eval($cmd) ) )
			{
				print("Rendering bake layer " + $layer + " failed!\n");
			}
		}
	}
}

global proc ilrTextureBakeCmdlineCallback(int $useOverride, string $layerOptionsOverride, string $extraOptions)
{
	string $bakeLayers[] = `ls -type ilrBakeLayer`;
	for ($layer in $bakeLayers)
	{
		// Render all renderable texture bake layers that are not empty
		//
		int $renderable  = (size(`sets -query $layer`) && `getAttr ($layer + ".renderable")`);
		int $textureBake = (`getAttr ($layer + ".renderType")` == 1);
		if ($renderable && $textureBake)
		{
			// Make sure to ignore the override layer
			// if that's not requested 
			//
			if (!$useOverride) {
				$layerOptionsOverride = "";
			}
			
			// Make sure the textures are saved to file
			//
			int $saveToFile = `getAttr ($layer + ".tbSaveToFile")`;
			setAttr ($layer + ".tbSaveToFile") 1;
						
			// Create the bake command
			//
			string $cmd = ilrGetTextureBakeCmdString($layer, $layerOptionsOverride);
			$cmd += " -useRenderView 0";
			$cmd += $extraOptions;

			setAttr ($layer + ".tbSaveToFile") $saveToFile;

			print("\n\n" + $cmd + "\n\n");

			// Start the render
			//
			if ( catch( eval($cmd) ) )
			{
				print("Rendering bake layer " + $layer + " failed!\n");
			}
		}
	}
}
