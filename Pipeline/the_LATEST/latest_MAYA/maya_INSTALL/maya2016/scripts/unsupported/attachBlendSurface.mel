// Copyright (C) 1997-2014 Autodesk, Inc., and/or its licensors.
// All rights reserved.
//
// The coded instructions, statements, computer programs, and/or related
// material (collectively the "Data") in these files contain unpublished
// information proprietary to Autodesk, Inc. ("Autodesk") and/or its licensors,
// which is protected by U.S. and Canadian federal copyright law and by
// international treaties.
//
// The Data is provided for use exclusively by You. You have the right to use,
// modify, and incorporate this Data into other products for purposes authorized 
// by the Autodesk software license agreement, without fee.
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND. AUTODESK
// DOES NOT MAKE AND HEREBY DISCLAIMS ANY EXPRESS OR IMPLIED WARRANTIES
// INCLUDING, BUT NOT LIMITED TO, THE WARRANTIES OF NON-INFRINGEMENT,
// MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE, OR ARISING FROM A COURSE 
// OF DEALING, USAGE, OR TRADE PRACTICE. IN NO EVENT WILL AUTODESK AND/OR ITS
// LICENSORS BE LIABLE FOR ANY LOST REVENUES, DATA, OR PROFITS, OR SPECIAL,
// DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES, EVEN IF AUTODESK AND/OR ITS
// LICENSORS HAS BEEN ADVISED OF THE POSSIBILITY OR PROBABILITY OF SUCH DAMAGES.

//
//
//  Creation Date:  Oct 23, 1997
//
//  Description:
//      The attachBlendSurface() procedure takes the selected surface and 
//		closes it in the direction defined by the selected isoparm. The
//		selected surface must be open in that direction. The result is a 
//		periodic surface with the same number of cvs as the original surface.
//
//  Input Arguments:
//      None.
//
//  Return Value:
//      String.
//

global proc string attachBlendSurface()
{
	global int $gSelectIsoparmsBit;
	string $surfacesList[] = `filterExpand -ex true -sm $gSelectIsoparmsBit`;

	int $numSurfaces = size($surfacesList);
	if ( $numSurfaces == 0 ) 
	{
		error((uiRes("m_attachBlendSurface.kErrorSelectSurfaceIsoparm")) );
		return "";
	}

	if ( $numSurfaces > 1 )
	{
		warning((uiRes("m_attachBlendSurface.kWarningTooManySelected")) );
	}

	string $buffer[];
	tokenize($surfacesList[$numSurfaces-1], ".", $buffer);
	string $surface = $buffer[0];

	if ( $buffer[1] == "" )
	{
		error((uiRes("m_attachBlendSurface.kErrorSelectIsoparm")));
		return "";
	}

	string $dirString = `substring $buffer[1] 1 1`;
	if ( $dirString == "u" ) $direction = 0;
	else if ( $dirString == "v" )$direction = 1;
	else
	{
		error((uiRes("m_attachBlendSurface.kErrorNeedIsoparms")) );
		return "";
	}

	// check that we have the required # of spans in the given direction on 
	// the surface in order to do the attach blend
	//
	int $degreeU = eval("getAttr " + $surface + ".degreeU");
	int $numSpansU = eval("getAttr " + $surface + ".spansU");
	int $degreeV = eval("getAttr " + $surface + ".degreeV");
	int $numSpansV = eval("getAttr " + $surface + ".spansV");
	int $degree, $numSpans;
	if ( $direction == 0 )
	{
		$degree = $degreeU;
		$numSpans = $numSpansU;
	}
	else
	{
		$degree = $degreeV;
		$numSpans = $numSpansV;
	}
	int $minSpans;
	if ( $degree == 1 ) $minSpans = 3;
	else if ( $degree == 2 ) $minSpans = 4;
	else $minSpans = 2 * ($degree - 1);
	if ( $numSpans < $minSpans ) 
	{
		string $degreeStr = "" + $degree;
		string $minSpansStr = "" + $minSpans;
		warning(`format -s $degreeStr -s $minSpansStr (uiRes("m_attachBlendSurface.kWarningTooFewSpans"))` );
		return "";
	}

	// close the surface in the given direction with preserve shape off and 
	// keep original on
	//
	string $results[] = `closeSurface -ch 0 -rpo 0 -d $direction -ps 0 $surface`;

	int $resultCount = size($results);
	if ( $resultCount == 0 ) 
	{
		error((uiRes("m_attachBlendSurface.kErrorClosingSurfaceFailed")) );
		return "";
	}

	// rebuild the closed surface result to have the #spans as the original 
	// surface
	//
	$results = `rebuildSurface -ch 0 -rpo 1 -rt 0 -kr 0 -kcp 0 -kc 0 -fr 0 -su $numSpansU -sv $numSpansV -du $degreeU -dv $degreeV -tol 0.05 $results[0]`;

	$resultCount = size($results);
	if ( $resultCount == 0 ) 
	{
		error((uiRes("m_attachBlendSurface.kErrorRebuildingSurfaceFailed")) );
		return "";
	}

	// set interior cvs on new periodic surface to match cvs from original 
	// surface
	//
	float $origCvs[];
	int $i, $j, $n;
	int $numCvsU = $numSpansU + $degreeU;
	int $numCvsV = $numSpansV + $degreeV;
	if ( $direction == 0 )
	{
		for ( $j = 1, $n = $j + 1;  $j < $numSpansU; $j++, $n++ )
		{
			for ( $i = 0; $i < $numCvsV; $i++ )
			{
				$origCvs = eval("getAttr " + $surface + ".controlPoints[" + $n + "][" + $i + "]");
				eval("setAttr " + $results[0] + ".controlPoints[" + $j + "][" + $i + "]  -type double3 " + $origCvs[0] + " " + $origCvs[1] + " " + $origCvs[2]);
			}
		}
	}
	else
	{
		for ( $j = 1, $n = $j + 1;  $j < $numSpansV; $j++, $n++ )
		{
			for ( $i = 0; $i < $numCvsU; $i++ )
			{
				$origCvs = eval("getAttr " + $surface + ".controlPoints[" + $i + "][" + $n + "]");
				eval("setAttr " + $results[0] + ".controlPoints[" + $i + "][" + $j + "]  -type double3 " + $origCvs[0] + " " + $origCvs[1] + " " + $origCvs[2]);
			}
		}
	}

	// set start cv on new periodic surface to be at the midpoint between the
	// start and end of original surface
	//
	int $start, $end;
	float $origCvsEnd[];
	if ( $direction == 0 )
	{
		$start = 0;
		$end = $numCvsU - 1;
		for ( $i = 0; $i < $numCvsV; $i++ )
		{
			$origCvs = eval("getAttr " + $surface + ".controlPoints[" + $start + "][" + $i + "]");
			$origCvsEnd = eval("getAttr " + $surface + ".controlPoints[" + $end + "][" + $i + "]");

			for ( $j = 0; $j < 3; $j++ )
			{
				// get midpoint between cvs
				//
				$origCvs[$j] = ($origCvs[$j] + $origCvsEnd[$j]) * 0.5;
			}

			eval("setAttr " + $results[0] + ".controlPoints[0][" + $i + "] -type double3 " + $origCvs[0] + " " + $origCvs[1] + " " + $origCvs[2]);
		}
	}
	else
	{
		$start = 0;
		$end = $numCvsV - 1;
		for ( $i = 0; $i < $numCvsU; $i++ )
		{
			$origCvs = eval("getAttr " + $surface + ".controlPoints[" + $i + "][" + $start + "]");
			$origCvsEnd = eval("getAttr " + $surface + ".controlPoints[" + $i + "][" + $end + "]");

			for ( $j = 0; $j < 3; $j++ )
			{
				// get midpoint between cvs
				//
				$origCvs[$j] = ($origCvs[$j] + $origCvsEnd[$j]) * 0.5;
			}

			eval("setAttr " + $results[0] + ".controlPoints[" + $i + "][0] -type double3 " + $origCvs[0] + " " + $origCvs[1] + " " + $origCvs[2]);
		}
	}

	eval("select -r " + $results[0]);

	// return the final result surface
	return $results[0];
}
