// Copyright (C) 1997-2014 Autodesk, Inc., and/or its licensors.
// All rights reserved.
//
// The coded instructions, statements, computer programs, and/or related
// material (collectively the "Data") in these files contain unpublished
// information proprietary to Autodesk, Inc. ("Autodesk") and/or its licensors,
// which is protected by U.S. and Canadian federal copyright law and by
// international treaties.
//
// The Data is provided for use exclusively by You. You have the right to use,
// modify, and incorporate this Data into other products for purposes authorized 
// by the Autodesk software license agreement, without fee.
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND. AUTODESK
// DOES NOT MAKE AND HEREBY DISCLAIMS ANY EXPRESS OR IMPLIED WARRANTIES
// INCLUDING, BUT NOT LIMITED TO, THE WARRANTIES OF NON-INFRINGEMENT,
// MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE, OR ARISING FROM A COURSE 
// OF DEALING, USAGE, OR TRADE PRACTICE. IN NO EVENT WILL AUTODESK AND/OR ITS
// LICENSORS BE LIABLE FOR ANY LOST REVENUES, DATA, OR PROFITS, OR SPECIAL,
// DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES, EVEN IF AUTODESK AND/OR ITS
// LICENSORS HAS BEEN ADVISED OF THE POSSIBILITY OR PROBABILITY OF SUCH DAMAGES.

// get lots of information about a nurbs curve
proc float[] getNurbsCurveKnots( 
	string $crvName )
//
//	Description :
//    Get knots of a nurbs curve
{
	float $knots[] ;
	string $infoNode ;

	// create info Node.
	if( catch( $infoNode = `createNode curveInfo` ) ) {
		return $knots ;
	} 

	// connect curve on to the info node.
	//
	string $outAttr = $crvName + ".local" ; 
	string $inAttr = $infoNode + ".ic" ;
	connectAttr $outAttr $inAttr ;

	// read the knots.
	//
	$outAttr = $infoNode + ".knots" ; 
	$knots = `getAttr $outAttr` ;	

	// delete curve info node.
	//
	delete $infoNode ;

	// return the knots.
	//
	return $knots;
}

proc int getNurbsCurveTightBox( 
	string $crv, int $samplesPerSpan, 
	float $x[], float $y[], float $z[] )
//
//	Description :
//    Compute tight curve bounding box by computing points 
//  regularly spaced in parameter along the curve.
// 
{
	// initialise limits at first corner of curve
	float $xyz[] = eval ("pointOnCurve -pr 0 -top true -p " + $crv);
	$x[0] = $xyz[0]; $x[1] = $xyz[0];
	$y[0] = $xyz[1]; $y[1] = $xyz[1];
	$z[0] = $xyz[2]; $z[1] = $xyz[2];
// 	print ("Box limits after first point " 
// 		   + $x[0] + " " + $x[1] + " " 
// 		   + $y[0] + " " + $y[1] + " " 
// 		   + $z[0] + " " + $z[1] + "\n");

	// number of spans
	int $nspans = eval("getAttr " + $crv + ".spans");

	// degree
	int $degree = eval("getAttr " + $crv + ".degree");


	// knots
	float $knots[] = getNurbsCurveKnots($crv);

	// first and last knot values to use 
	int $first = $degree - 1;
	int $last = $nspans + $first;

	// loop over knot values
	int $index;
	int $sample;
	int $sampleMax;
	float $t;
	// loop over U spans
	for($index = $first; $index < $last; $index++) {

		// maximum number of samples for this span
		$sampleMax = ($index < $last-1) ? $samplesPerSpan - 1 : $samplesPerSpan;
		// parameter interval for this span
		float $interval = $knots[$index+1] - $knots[$index];

		// loop over parameter samples
		for($sample = 0; $sample <= $sampleMax; $sample++) {

			// get value of parameter
			$t = $knots[$index] + $sample*$interval/float($samplesPerSpan);
			// make sure rouding errors dont take it off the end
			if($index == ($last-1) && $sample == $sampleMax) {
				$t = $knots[$last];
			}

//  			print ("T " + $t + "\n");
			// compute the curve point
			$xyz = eval ("pointOnCurve -pr " + $t  + " -top false -p " + $crv);

			// update bounding box given the new point
			if($xyz[0] < $x[0]) $x[0] = $xyz[0]; 
			if($xyz[0] > $x[1]) $x[1] = $xyz[0]; 
			if($xyz[1] < $y[0]) $y[0] = $xyz[1]; 
			if($xyz[1] > $y[1]) $y[1] = $xyz[1]; 
			if($xyz[2] < $z[0]) $z[0] = $xyz[2]; 
			if($xyz[2] > $z[1]) $z[1] = $xyz[2]; 
// 			print ("Box limits after this point " 
// 				   + $x[0] + " " + $x[1] + " " 
// 				   + $y[0] + " " + $y[1] + " " 
// 				   + $z[0] + " " + $z[1] + "\n");
		}
	}

	return 0;
}


global proc nurbsCurveTightBox(int $samplesPerSpan)
{
	// Get the selection list.
	string $selList[] = `ls -sl`;

	// Run filter to select only the NURBS curves
	global int $gSelectNurbsCurvesBit ;

	string $crvList[] = `filterExpand -ex true 
		-sm $gSelectNurbsCurvesBit`;
	int $len = size($crvList) ;
	if( $len == 0 ) {
		print (uiRes("m_nurbsCurveTightBox.kNoCurveSelected")) ;
		return;
	}

	// always need at least one sample per span
	if($samplesPerSpan < 1) $samplesPerSpan = 1;

	// box values
	float $x[2], $y[2], $z[2];

	// Work on the last item if more than one NURBS curve in list.
	for($crvNum = 0; $crvNum < $len; $crvNum++) {
		string $crv = $crvList[$crvNum] ;

		// print separator if more than one curve
		if($len>1) print "----------------------------------\n";

		// print out the form,degree,nspans,bbox
		if(getNurbsCurveTightBox($crv, $samplesPerSpan, $x, $y, $z )) {
			print (`format -s $crv (uiRes("m_nurbsCurveTightBox.kFailedToComputeBox"))` );
			break;
		}
		print (`format -s $crv (uiRes("m_nurbsCurveTightBox.kBoxForCurve"))` );
		print ("  X: " + $x[0] + " " + $x[1] +"\n");
		print ("  Y: " + $y[0] + " " + $y[1] +"\n");
		print ("  Z: " + $z[0] + " " + $z[1] +"\n");
	}

	// print separator if more than one curve
	if($len>1) print "----------------------------------\n";

	// reselect curve for which information was returned
 	select -r $selList;
}
