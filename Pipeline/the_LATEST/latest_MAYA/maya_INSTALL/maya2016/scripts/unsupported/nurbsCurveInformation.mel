// Copyright (C) 1997-2014 Autodesk, Inc., and/or its licensors.
// All rights reserved.
//
// The coded instructions, statements, computer programs, and/or related
// material (collectively the "Data") in these files contain unpublished
// information proprietary to Autodesk, Inc. ("Autodesk") and/or its licensors,
// which is protected by U.S. and Canadian federal copyright law and by
// international treaties.
//
// The Data is provided for use exclusively by You. You have the right to use,
// modify, and incorporate this Data into other products for purposes authorized 
// by the Autodesk software license agreement, without fee.
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND. AUTODESK
// DOES NOT MAKE AND HEREBY DISCLAIMS ANY EXPRESS OR IMPLIED WARRANTIES
// INCLUDING, BUT NOT LIMITED TO, THE WARRANTIES OF NON-INFRINGEMENT,
// MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE, OR ARISING FROM A COURSE 
// OF DEALING, USAGE, OR TRADE PRACTICE. IN NO EVENT WILL AUTODESK AND/OR ITS
// LICENSORS BE LIABLE FOR ANY LOST REVENUES, DATA, OR PROFITS, OR SPECIAL,
// DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES, EVEN IF AUTODESK AND/OR ITS
// LICENSORS HAS BEEN ADVISED OF THE POSSIBILITY OR PROBABILITY OF SUCH DAMAGES.

// get lots of information about a nurbs curve
proc float[] getNurbsCurveKnots( 
	string $crvName )
//
//	Description :
//
{
	float $knots[] ;
	string $infoNode ;

	// create info Node.
	if( catch( $infoNode = `createNode curveInfo` ) ) {
		return $knots ;
	} 

	// connect curve on to the info node.
	//
	string $outAttr = $crvName + ".local" ; 
	string $inAttr = $infoNode + ".ic" ;
	connectAttr $outAttr $inAttr ;

	// read the knots.
	//
	$outAttr = $infoNode + ".knots" ; 
	$knots = `getAttr $outAttr` ;	

	// delete curve info node.
	//
	delete $infoNode ;

	// return the knots.
	//
	return $knots;
}

global proc printNurbsCurveMiscInfo(string $crv)
// Description :
//  prints the knot values
{
	// form
	int $form = eval("getAttr " + $crv + ".form");
	$w = `format -s $form (uiRes("m_nurbsCurveInformation.kForm"))`;
	print $w;
	
	// degree
	int $degree = eval("getAttr " + $crv + ".degree");
	$w = `format -s $degree (uiRes("m_nurbsCurveInformation.kDegree"))`;
	print $w;
	
	// number of spans
	int $nspans = eval("getAttr " + $crv + ".spans");
	$w = `format -s $nspans (uiRes("m_nurbsCurveInformation.kNspans"))`;
	print $w;
	
	// bounding box (what if it is 2d??)
	float $minBox[] = eval("getAttr " + $crv + ".boundingBoxMin");
	$w = `format -s $minBox[0] -s $minBox[1] -s $minBox[2] (uiRes("m_nurbsCurveInformation.kBoundingBoxMin"))`;
	print $w;
	
	float $maxBox[] = eval("getAttr " + $crv + ".boundingBoxMax");
	$w = `format -s $maxBox[0] -s $maxBox[1] -s $maxBox[2] (uiRes("m_nurbsCurveInformation.kBoundingBoxMax"))`;
	print $w;
	
}

global proc printNurbsCurveKnots(string $crv)
// Description :
//  prints the knot values
{

	float $knots[] = getNurbsCurveKnots($crv);
	print (uiRes("m_nurbsCurveInformation.kKnots"));
	int $numKnots = size($knots);
	for($i=0; $i<$numKnots; $i++) {
		$w = " " + $knots[$i];
		print $w;
	}
	print "\n";
		
}

global proc printNurbsCurveCVs(string $crv)
// Description :
//  prints the CV positions in world space
{
		
	// create info Node.
	string $infoNode = `createNode curveInfo`;
	
	// connect curve on to the info node.
	string $outAttr = $crv + ".ws[0]" ;
	string $inAttr = $infoNode + ".ic" ;
	connectAttr $outAttr $inAttr ;
	
	// CVs 
	int $numCVs = `getAttr -size ($infoNode + ".cp")`;
	
	$w = `format -s $numCVs (uiRes("m_nurbsCurveInformation.kNumCVs"))`;
	print $w;
	
	float $cv0[] = `getAttr ($infoNode + ".cp[0]")`;
	int $dim = size($cv0);
	$w = `format -s $dim (uiRes("m_nurbsCurveInformation.kCurveDimension"))`;
	print $w;
	
	// print out the CV positions
	print (uiRes("m_nurbsCurveInformation.kCVsInWorldSpace"));
	for($i=0; $i<$numCVs; $i++) {
		float $cvs[] = `getAttr ($infoNode + ".cp[" + $i + "]")`;
		$w = $i + ": ";
		for($j=0; $j<$dim; $j++) {
			$w +=  $cvs[$j] + " ";
		}
		$w += "\n";
		print $w;
	}
	
	// tidy up
	delete $infoNode ;
}

global proc nurbsCurveInformation()
{
	string $w; // for messages

	// 0. Grab the select list.
	//
	string $selList[] = `ls -sl`;

	// 1. Run filter to select only the NURBS curves and curves on surface
	//
	global int $gSelectNurbsCurvesBit ;
	global int $gSelectCurvesOnSurfacesBit;

	string $crvList[] = `filterExpand -ex true 
		-sm $gSelectNurbsCurvesBit 
		-sm $gSelectCurvesOnSurfacesBit $selList` ;	
	int $len = size($crvList) ;
	if( $len == 0 ) {
		print (uiRes("m_nurbsCurveInformation.kNoCurveSelected")) ;
		return;
	}

	// 2. Work on the last item if more than one NURBS curve in list.
	//
	for($crvNum = 0; $crvNum < $len; $crvNum++) {
		string $crv = $crvList[$crvNum] ;

		// print separator if more than one curve
		if($len>1) print "----------------------------------\n";

		// curve name
		$w = `format -s $crv (uiRes("m_nurbsCurveInformation.kCurve"))`;
		print $w;
		
		// print out the form,degree,nspans,bbox
		printNurbsCurveMiscInfo($crv);

		// print out the knots
		printNurbsCurveKnots($crv);

		// print out the CVs
		printNurbsCurveCVs($crv);
	}

	// print separator if more than one curve
	if($len>1) print "----------------------------------\n";

	// reselect curve for which information was returned
	select -r $selList;
}

