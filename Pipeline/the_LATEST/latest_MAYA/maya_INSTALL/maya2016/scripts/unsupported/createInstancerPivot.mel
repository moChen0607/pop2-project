// Copyright (C) 1997-2014 Autodesk, Inc., and/or its licensors.
// All rights reserved.
//
// The coded instructions, statements, computer programs, and/or related
// material (collectively the "Data") in these files contain unpublished
// information proprietary to Autodesk, Inc. ("Autodesk") and/or its licensors,
// which is protected by U.S. and Canadian federal copyright law and by
// international treaties.
//
// The Data is provided for use exclusively by You. You have the right to use,
// modify, and incorporate this Data into other products for purposes authorized 
// by the Autodesk software license agreement, without fee.
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND. AUTODESK
// DOES NOT MAKE AND HEREBY DISCLAIMS ANY EXPRESS OR IMPLIED WARRANTIES
// INCLUDING, BUT NOT LIMITED TO, THE WARRANTIES OF NON-INFRINGEMENT,
// MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE, OR ARISING FROM A COURSE 
// OF DEALING, USAGE, OR TRADE PRACTICE. IN NO EVENT WILL AUTODESK AND/OR ITS
// LICENSORS BE LIABLE FOR ANY LOST REVENUES, DATA, OR PROFITS, OR SPECIAL,
// DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES, EVEN IF AUTODESK AND/OR ITS
// LICENSORS HAS BEEN ADVISED OF THE POSSIBILITY OR PROBABILITY OF SUCH DAMAGES.

proc string[] filterOutInstancers( string $transforms[] )
//
// Description:
//
//    Remove all of the instancer node names from the given list.
//
{
	string $results[];
	clear( $results );

	int $i;
	for( $i = 0; $i < size( $transforms ); $i ++ )
	{
		if( `objectType -isType "instancer" $transforms[$i]` == 0 )
		{
			$results[size($results)] = $transforms[$i];
		}
	}

	return $results;
}

proc string[] getInstancers( string $object )
//
// Description:
//
//    For the given object, return all of the instancers that
// are using it.
//
{
	string $results[];
	clear( $results );

	if( `objectType $object` != "transform" )
	{
		return $results;
	}

	$results = `listConnections -source false -destination true -type instancer ($object+".matrix")`;

	return $results;
}

proc int indexInArray( string $value, string $array[] )
//
// Description:
//
//    Search the given array for the given string.  If it is found,
// then return the index in the array.  Otherwise, return -1.
//
{
	int $i;
	for( $i = 0; $i < size( $array ); $i ++ )
	{
		if( $array[$i] == $value )
			return $i;
	}

	return 0;
}

proc replaceInstance( string $instancer, string $instance, string $newInstance )
//
// Description:
//
//    Replace one object in an instancer with another object.
//
{
	if( `objectType $instancer` != "instancer" )
	{
		return;
	}

	if( `objectType $instance` != "transform" )
	{
		return;
	}

	if( `objectType $newInstance` != "transform" )
	{
		return;
	}

	string $connectedInstancers[] = `listConnections -source false -destination true -plugs off -type instancer ($instance+".matrix")`; 
	int $location = indexInArray( $instancer, $connectedInstancers );
	if( $location >= 0 )
	{
		string $connectedInstancerPlug[] = `listConnections -source false -destination true -plugs on -type instancer ($instance+".matrix")`; 
		string $dstPlug = $connectedInstancerPlug[$location];
		disconnectAttr ($instance+".matrix") $dstPlug;
		connectAttr ($newInstance+".matrix") $dstPlug;
	}

}

proc moveAttrAnimation( string $from, string $to, string $attr )
//
// Description:
//
//    Take any incoming animation from one object's attribute
// and move it to another object's corresponding attribute.
//
{
	string $connections[];

	$connections = `listConnections -source true -destination false -plugs true ($from+"."+$attr)`;
	if( size($connections) > 0 )
	{
		connectAttr $connections[0] ($to+"."+$attr);
		disconnectAttr $connections[0] ($from+"."+$attr);
	}
}

proc moveTransformAnimation( string $from, string $to )
//
// Description:
//
//    Moves all of the animation on one object's
// transformational attributes to another object.
//
{
	moveAttrAnimation( $from, $to, "translate" );
	moveAttrAnimation( $from, $to, "translateX" );
	moveAttrAnimation( $from, $to, "translateY" );
	moveAttrAnimation( $from, $to, "translateZ" );

	moveAttrAnimation( $from, $to, "rotate" );
	moveAttrAnimation( $from, $to, "rotateX" );
	moveAttrAnimation( $from, $to, "rotateY" );
	moveAttrAnimation( $from, $to, "rotateZ" );

	moveAttrAnimation( $from, $to, "scale" );
	moveAttrAnimation( $from, $to, "scaleX" );
	moveAttrAnimation( $from, $to, "scaleY" );
	moveAttrAnimation( $from, $to, "scaleZ" );

	moveAttrAnimation( $from, $to, "shear" );
	moveAttrAnimation( $from, $to, "shearXY" );
	moveAttrAnimation( $from, $to, "shearXZ" );
	moveAttrAnimation( $from, $to, "shearYZ" );
}

proc string addInstancerPivot( string $object, string $instancer )
//
// Description:
//
//    Adds the objects needed for the effect.
//
{
	//
	// First, it makes a locator to use as the "center" point
	// of the instance.  This locator will always stay at
	// the origin of its parent, and the attributes are locked.
	//
	string $locatorAry[] = `spaceLocator`;
	rename "InstPivotCenter";
	string $sl[] = `ls -sl`;
	string $locator = $sl[0];
	setAttr -lock true ($locator+".translate");
	setAttr -lock true ($locator+".rotate");
	setAttr -lock true ($locator+".scale");
	setAttr -lock true ($locator+".shear");
	setAttr ($locator+".template") 1;
	hide $locator;

	//
	// Now the object and the locator are grouped together.
	// The group is then put where the object was.
	//
	string $parents[] = `listRelatives -parent $object`;
	string $newGroup;
	if( size($parents) == 0 )
	{
		$newGroup = `group $object $locator`;
	}
	else
	{
		$newGroup = `group -parent $parents[0] $object $locator`;
	}
	xform -os -piv 0 0 0 $newGroup;
	rename $newGroup ($object+"_InstPivot");
	$sl = `ls -sl`;
	string $group = $sl[0];
	addAttr -ln "_instancerPivot_" -sn "_ip" $group;
	xform -os -piv 0 0 0 $group;
	float $pos[] = `getAttr ($object+".translate")`;
	float $rot[] = `getAttr ($object+".rotate")`;
	float $sca[] = `getAttr ($object+".scale")`;
	float $she[] = `getAttr ($object+".shear")`;
	move -objectSpace ($pos[0]) ($pos[1]) ($pos[2]) $group;
	rotate -objectSpace ($rot[0]) ($rot[1]) ($rot[2]) $group;
	scale ($sca[0]) ($sca[1]) ($sca[2]) $group;
	setAttr -type double3 ($group+".shear") ($she[0]) ($she[1]) ($she[2]);

	//
	// Now any animation that drove the object's tranformation
	// is moved onto the new group, and the object's attributes
	// are reset and locked.
	//
	moveTransformAnimation( $object, $group );
	move -objectSpace 0 0 0 $object;
	rotate -objectSpace 0 0 0 $object;
	setAttr -lock true ($object+".rotate");
	scale 1 1 1 $object;
	setAttr -lock true ($object+".scale");
	setAttr -type double3 ($object+".shear") 0 0 0;
	setAttr -lock true ($object+".shear");

	//
	// The position of the object is pointConstrained to
	// the locator.  This will put the object's
	// rotate pivot at the center of the new group.
	//
	select $locator $object;
	pointConstraint -weight 1;

	//
	// Now replace the object with the new group in the
	// instancer.  Any rotations of the group will now
	// have the effect of rotating the original object
	// about its roate pivot.
	//
	replaceInstance( $instancer, $object, $group );

	return $group;
}

global proc string[] createInstancerPivot()
//
// Description:
//
//    This procedure is used to take into account the
// rotate pivots of an object that is instanced with the
// instancer node.  It creates a group above the selected
// instanced objects and constrains the object so that
// its rotation pivot is centered on the new group.  Then
// the group is put into the object's place in the instancer
// node.  Any animation on the original object is moved onto
// the new group.
//
{
	string $results[];
	clear( $results );

	//
	// Get all of the selected instancers and non-instancer transforms.
	//
	// string $instancers[] = `ls -objectsOnly -type instancer -sl`;
	string $transforms[] = `ls -objectsOnly -type transform -sl`;
	string $nonInstancers[] = filterOutInstancers( $transforms );
	int $i;

	//
	// For each non-instancer transform...
	//
	for( $i = 0; $i < size($nonInstancers); $i ++ )
	{
		string $thisObject = $nonInstancers[$i];
		//
		// Get all of the objects instanced by this instancer node.
		//
		string $instancers[] = getInstancers( $thisObject );
		int $j;

		//
		// For each instancer using this transform...
		//
		for( $j = 0; $j < size( $instancers ); $j ++ )
		{
			string $thisInstancer = $instancers[$j];
			//
			// If the immediate parent of the instanced object is already a
			// group created by this effect, then do not make a new one.  Just
			// replace the object with the parent in the current instancer.
			//
			string $parents[] = `listRelatives -allParents $thisObject`;
			int $alreadyHasInstancerPivot = 0;
			int $p;
			for( $p = 0; $p < size( $parents ); $p ++ )
			{
				string $thisParent = $parents[$p];
				//
				// Groups that this effect made have an attribute called
				// "_instancerPivot_".  This is how we know if we have already
				// done this effect for this object (but maybe for a different
				// instancer.
				//
				if( `attributeQuery -exists -node $thisParent "_instancerPivot_"` == 1 )
				{
					print("// "+$thisObject+" already has an instancer pivot parent.  Using "+($parents[$p])+".\n");
					$alreadyHasInstancerPivot = 1;
					replaceInstance( $thisInstancer, $thisObject, $thisParent );
					$results[size($results)] = $thisParent;
					break;
				}
			}

			if( $alreadyHasInstancerPivot == 1 )
			{
				continue;
			}

			//
			// If this instanced object has not had this effect run on it,
			// then do it now.
			//
			string $newPivot = addInstancerPivot( $thisObject, $thisInstancer );
			$results[size($results)] = $newPivot;
		}
	}

	//
	// The return value is the list of instancer pivot objects created.
	//
	select $results;
	return $results;
}

