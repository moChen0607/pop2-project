// Copyright (C) 1997-2014 Autodesk, Inc., and/or its licensors.
// All rights reserved.
//
// The coded instructions, statements, computer programs, and/or related
// material (collectively the "Data") in these files contain unpublished
// information proprietary to Autodesk, Inc. ("Autodesk") and/or its licensors,
// which is protected by U.S. and Canadian federal copyright law and by
// international treaties.
//
// The Data is provided for use exclusively by You. You have the right to use,
// modify, and incorporate this Data into other products for purposes authorized 
// by the Autodesk software license agreement, without fee.
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND. AUTODESK
// DOES NOT MAKE AND HEREBY DISCLAIMS ANY EXPRESS OR IMPLIED WARRANTIES
// INCLUDING, BUT NOT LIMITED TO, THE WARRANTIES OF NON-INFRINGEMENT,
// MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE, OR ARISING FROM A COURSE 
// OF DEALING, USAGE, OR TRADE PRACTICE. IN NO EVENT WILL AUTODESK AND/OR ITS
// LICENSORS BE LIABLE FOR ANY LOST REVENUES, DATA, OR PROFITS, OR SPECIAL,
// DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES, EVEN IF AUTODESK AND/OR ITS
// LICENSORS HAS BEEN ADVISED OF THE POSSIBILITY OR PROBABILITY OF SUCH DAMAGES.

//
// Description : make a regular polygon given the number of sides
// and the length of a side. 
//
// Usage :
// 1. For a equilateral triangle of length 3 : makeRegularPolyon(3,2);
// 2. For a hexagon of length 2.5 : makeRegularPolyon(6,2.5);
//
// Note : number of sides should be atleast 3. We could build
// regular triangles, squares, pentagon, hexagon, ...., circle in the 
// limit. ? The polygon is created in the XY ( Z=0) plane.

//
// Find the radius of circle encompasing the polygon. 
//
proc float boundingCircleRadius( int $n, float $x )
//
//	Description:
//		number of sides on the polygon.
//		$x = length of the polygon.
//
{
	float $rad ;
	float $angle = 360.0 / $n ;

	float $cosx = cos(deg_to_rad($angle)) ; 	
	float $den = 2.0 * ( 1.0 - $cosx ) ;
	$rad = $x / sqrt($den) ;
	return $rad ;
}

proc float[] createRegularPolygonY( int $n, float $r )
{
	int $i ;
	float $x[] ;
	float $angle = 360.0 / $n ;

	for( $i = 0 ; $i < $n ; $i++ ) {
		float $a = $i * $angle ;	
		$x[$i] =  $r * cos(deg_to_rad($a)) ;
	}
	return $x ;	
}

proc float[] createRegularPolygonX( int $n,float $r )
{
	int $i ;
	float $x[] ;
	float $angle = 360.0 / $n ;
	for( $i = 0 ; $i < $n ; $i++ ) {
		float $a = $i * $angle ;	
		$x[$i] =  $r * sin(deg_to_rad($a)) ;
	}
	return $x ;	
}


global proc int makeRegularPolygon( int $n, float $len )

{

	if( $n <= 2 ) {
		error (uiRes("m_makeRegularPolygon.kErrorNeed3Sides")) ;
		return 1 ;
	}

	float $r = boundingCircleRadius( $n, $len ) ;

	float $x[] = createRegularPolygonX( $n, $r ) ;
	float $y[] = createRegularPolygonY( $n, $r ) ;

	// create the n-sided polygon. 
	//
	string $facet[] ;
	string $cmd = "polyCreateFacet -ch 0  ";
	string $vertStr ;
	float $z = 0.0 ;
	int $i ;
	for( $i = 0 ; $i < $n ; $i++ ) {
		$vertStr += " -p " ;
		$vertStr += $x[$i] ;
		$vertStr += " " ;
		$vertStr += $y[$i] ;
		$vertStr += " " ;
		$vertStr += $z ;
	}
	$cmd += $vertStr ; 
	$cmd += " "; 

	// do the polyCreateFacet cmd.
	//
    string $facet[] = eval($cmd) ;
	select -r $facet[0] ;
	return 0 ;

}

