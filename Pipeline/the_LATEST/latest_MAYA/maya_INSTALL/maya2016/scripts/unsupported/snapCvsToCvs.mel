// Copyright (C) 1997-2014 Autodesk, Inc., and/or its licensors.
// All rights reserved.
//
// The coded instructions, statements, computer programs, and/or related
// material (collectively the "Data") in these files contain unpublished
// information proprietary to Autodesk, Inc. ("Autodesk") and/or its licensors,
// which is protected by U.S. and Canadian federal copyright law and by
// international treaties.
//
// The Data is provided for use exclusively by You. You have the right to use,
// modify, and incorporate this Data into other products for purposes authorized 
// by the Autodesk software license agreement, without fee.
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND. AUTODESK
// DOES NOT MAKE AND HEREBY DISCLAIMS ANY EXPRESS OR IMPLIED WARRANTIES
// INCLUDING, BUT NOT LIMITED TO, THE WARRANTIES OF NON-INFRINGEMENT,
// MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE, OR ARISING FROM A COURSE 
// OF DEALING, USAGE, OR TRADE PRACTICE. IN NO EVENT WILL AUTODESK AND/OR ITS
// LICENSORS BE LIABLE FOR ANY LOST REVENUES, DATA, OR PROFITS, OR SPECIAL,
// DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES, EVEN IF AUTODESK AND/OR ITS
// LICENSORS HAS BEEN ADVISED OF THE POSSIBILITY OR PROBABILITY OF SUCH DAMAGES.

//
//
// Description :
//      To snap together two sets of nurbs surface Cvs . Each set is picked
//		by doing a marquee select.
//		select nurbsSurface1.cv[0][0:6] nurbsSurface2.cv[0][0:6]
//		snapCvsToCvs
//
//		Useful when attempting to snap boundary of one surfaces onto
//		another. 
//

proc float[] worldPosition( string $comp[] )
//
//  Description :
//
{
    float $pos[] ;
    float $p[] ;

    int $i, $n ;
    $n = size($comp) ;
    for( $i = 0 ; $i < $n ; $i++ ) {
        string $item = $comp[$i] ;
        $p = `pointPosition -w $item` ;
        int $j = $i*3 ;
        $pos[$j] = $p[0] ;
        $pos[$j+1] = $p[1] ;
        $pos[$j+2] = $p[2] ;
    }
    return $pos ;
}

global proc int snapCvsToCvs()
//
//	Description :
//
{
	int $i ;


	// 1.  look at select list. Should have Two entries !
	//
	string $list[] = `ls -sl` ;
	int $sz = size($list) ;
	if( $sz != 2 ) {
		error (uiRes("m_snapCvsToCvs.kErrorSelect2CVSets")) ;
		return 1 ;
	}

	// 2. Filter expand each of the two enteries.
	//
	global int $gSelectCVsBit ;
	string $slavecvs[] = `filterExpand -ex true -sm $gSelectCVsBit $list[0]` ;
	string $mastercvs[] = `filterExpand -ex true -sm $gSelectCVsBit $list[1]` ;

	// 3. After filter expand one should have identical #'s
	//
	int $ncv = size( $slavecvs ) ;
	if( $ncv !=  size($mastercvs) ) {
		error (uiRes("m_snapCvsToCvs.kErrorNeedSameNumOfCVs"));
		return 1 ;
	}	

	// 4. get world pos's
	//
	float $slavecvp[] = worldPosition( $slavecvs ) ;
	float $mastercvp[] = worldPosition( $mastercvs ) ;

	// 5. Issue move cmds.
	//
	int $j = 0 ;
	for( $i = 0 ; $i < $ncv ; $i += 1, $j += 3 )  {
		float $x = $mastercvp[$j] - $slavecvp[$j] ;
		float $y = $mastercvp[$j+1] - $slavecvp[$j+1] ;
		float $z = $mastercvp[$j+2] - $slavecvp[$j+2] ;
		string $item = $slavecvs[$i] ;
		move -r $x $y $z $item ;	
	}

	return 0;
}

