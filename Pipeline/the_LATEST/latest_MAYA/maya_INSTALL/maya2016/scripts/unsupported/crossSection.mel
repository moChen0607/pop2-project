// Copyright (C) 1997-2014 Autodesk, Inc., and/or its licensors.
// All rights reserved.
//
// The coded instructions, statements, computer programs, and/or related
// material (collectively the "Data") in these files contain unpublished
// information proprietary to Autodesk, Inc. ("Autodesk") and/or its licensors,
// which is protected by U.S. and Canadian federal copyright law and by
// international treaties.
//
// The Data is provided for use exclusively by You. You have the right to use,
// modify, and incorporate this Data into other products for purposes authorized 
// by the Autodesk software license agreement, without fee.
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND. AUTODESK
// DOES NOT MAKE AND HEREBY DISCLAIMS ANY EXPRESS OR IMPLIED WARRANTIES
// INCLUDING, BUT NOT LIMITED TO, THE WARRANTIES OF NON-INFRINGEMENT,
// MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE, OR ARISING FROM A COURSE 
// OF DEALING, USAGE, OR TRADE PRACTICE. IN NO EVENT WILL AUTODESK AND/OR ITS
// LICENSORS BE LIABLE FOR ANY LOST REVENUES, DATA, OR PROFITS, OR SPECIAL,
// DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES, EVEN IF AUTODESK AND/OR ITS
// LICENSORS HAS BEEN ADVISED OF THE POSSIBILITY OR PROBABILITY OF SUCH DAMAGES.

proc int getWorldSpaceBoundingBox( 
	string $surfaceShape, float $min[], float $max[], 
	float $center[], float $dimensions[] )
{
	string $surfaceSh = `createNode nurbsSurface`;
	string $surfaceCopy = `createNode transform`;
	string $xformNode = `createNode transformGeometry`;
	parent $surfaceSh $surfaceCopy;
	connectAttr ($surfaceShape + ".local") ($xformNode + ".inputGeometry");
	connectAttr ($surfaceShape + ".worldMatrix") ($xformNode + ".transform");
	connectAttr ($xformNode + ".outputGeometry") ($surfaceSh + ".create");

	$min = `getAttr ($surfaceCopy + ".boundingBoxMin")`;
	$max = `getAttr ($surfaceCopy + ".boundingBoxMax")`;
	$dimensions = `getAttr ($surfaceCopy + ".boundingBoxSize")`;
	$center = `getAttr ($surfaceCopy + ".center")`;
	delete $surfaceCopy;

	return 0;
}

global proc string[] crossSection( string $surface, int $axis, 
	float $spacing, float $offset )
//
//	Description:
//		Given a surface, this proc produces cross sections with the
//		given spacing along the specified axis.  
//		The resulting cross sections are 3D NURBS curves.
//		Offset is how far from the edge of the bounding box to start intersecting.
//		The axis should be given as 0, 1 or 2, for x, y, z respectively.
//
//	Method: 
//		A series of 1x1 degree NURBS planes are created, and intersected
//		with the given surface.
//
//	Returns:
//		A string array, where the first string is the name ofthe group of
//		resulting intersect curves.
//
//	Example:
//		To create cross sections on a surface in the Y direction,
//		where the sections are 2.2 units apart and offset by 1.5 units:
//			crossSection( "surface1", 1, 2.2, 1.5 );
//
{
	string $results[];

	// Check that the axis is valid.	
	//
	if( $axis != 0 && $axis != 1 && $axis != 2 )  {
		error((uiRes("m_crossSection.kErrorInvalidAxis")) );
		return $results;
	}
	if( size(`ls $surface`) != 1 ) {
		error((uiRes("m_crossSection.kErrorUnspecifiedSurface")) );
		return $results;
	}
	string $surfaceShape[] = `listRelatives -shapes $surface`;
	if( size($surfaceShape) != 1 ) {
		error((uiRes("m_crossSection.kErrorUnspecifiedTransform")) );
		return $results;
	}

	string $planes[];
	string $intersectCrvs[];
	string $intersectDNs[];

	// Get the bounding box from the surface, incorporate the spacing + offset
	//
	float $bboxMin[3];
	float $bboxMax[3];
	float $bboxSize[3];
	float $bboxCen[3];
	int $tmp = getWorldSpaceBoundingBox( $surfaceShape[0], $bboxMin, 
				$bboxMax, $bboxCen, $bboxSize );
	float $min = $bboxMin[$axis];
	float $max = $bboxMax[$axis];
	int $ax[3];
	$ax[0] = ($axis == 0) ? 1 : 0;
	$ax[1] = ($axis == 1) ? 1 : 0;
	$ax[2] = ($axis == 2) ? 1 : 0;
	float $pos[3];
	$pos[0] = ($axis == 0) ? $bboxMin[0] + $offset: $bboxCen[0];
	$pos[1] = ($axis == 1) ? $bboxMin[1] + $offset: $bboxCen[1];
	$pos[2] = ($axis == 2) ? $bboxMin[2] + $offset: $bboxCen[2];

	float $width = ($axis==0) ? $bboxSize[2] : 
					(($axis==1) ? $bboxSize[0] : $bboxSize[0]) ;
	float $lr = ($axis==0) ? $bboxSize[1]/$bboxSize[2] : 
				(($axis==1) ? $bboxSize[2]/$bboxSize[0] : 
				$bboxSize[1]/$bboxSize[0]) ;

	// Create nurbs planes in the specified direction, between min and max,
	// intersect with the surface.  
	//
	for( ; $pos[$axis] < $max; ) {

		string $plane[] = `nurbsPlane -d 1 -ch off -ax $ax[0] $ax[1] $ax[2] 
			-p $pos[0] $pos[1] $pos[2] -w $width -lr $lr`;
		$planes[size($planes)] = $plane[0];

		string $intersect[] = `intersect -ch on -cos off $plane[0] $surface`;
		$intersectCrvs[size($intersectCrvs)] = $intersect[0];

		$pos[0] += ($axis == 0) ? $spacing : 0.0;
		$pos[1] += ($axis == 1) ? $spacing : 0.0;
		$pos[2] += ($axis == 2) ? $spacing : 0.0;
	}

	// delete the intersecting planes and group the result curves.
	//
	delete $planes;
	string $intersectCrvsGrp = `group $intersectCrvs`;
	$results[0] = $intersectCrvsGrp;

	return $results;
}
