// Copyright (C) 1997-2014 Autodesk, Inc., and/or its licensors.
// All rights reserved.
//
// The coded instructions, statements, computer programs, and/or related
// material (collectively the "Data") in these files contain unpublished
// information proprietary to Autodesk, Inc. ("Autodesk") and/or its licensors,
// which is protected by U.S. and Canadian federal copyright law and by
// international treaties.
//
// The Data is provided for use exclusively by You. You have the right to use,
// modify, and incorporate this Data into other products for purposes authorized 
// by the Autodesk software license agreement, without fee.
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND. AUTODESK
// DOES NOT MAKE AND HEREBY DISCLAIMS ANY EXPRESS OR IMPLIED WARRANTIES
// INCLUDING, BUT NOT LIMITED TO, THE WARRANTIES OF NON-INFRINGEMENT,
// MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE, OR ARISING FROM A COURSE 
// OF DEALING, USAGE, OR TRADE PRACTICE. IN NO EVENT WILL AUTODESK AND/OR ITS
// LICENSORS BE LIABLE FOR ANY LOST REVENUES, DATA, OR PROFITS, OR SPECIAL,
// DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES, EVEN IF AUTODESK AND/OR ITS
// LICENSORS HAS BEEN ADVISED OF THE POSSIBILITY OR PROBABILITY OF SUCH DAMAGES.

//
//
//  Creation Date:  Jan 12, 1998
//
//  Description:
//      The attachCurveLine() procedure takes the selected two curves and 
//		creates a one span straight curve between them, using the end of curve1
//      and the start of curve2. The result will always be at least a degree
//      3 curve. If you don't want to attach the curves then call this proc
//      with $doAttach = 0.
//
//  Input Arguments:
//      $doAttach - if 1 attach results otherwise just create new curve
//
//  Return Value:
//      String.
//

global proc string attachCurveLine( int $doAttach )
{
	global int $gSelectNurbsCurvesBit;
	string $curvesList[] = `filterExpand -ex true -sm $gSelectNurbsCurvesBit`;

	int $numCurves = size($curvesList);
	if ( $numCurves < 2 )
	{
		error((uiRes("m_attachCurveLine.kErrorSelectTwoCurves")) );
		return "";
	}

    // get the last cv on the first curve and the first cv on the second curve
    //
	int $degree = eval("getAttr " + $curvesList[0] + ".degree");
	int $numSpans = eval("getAttr " + $curvesList[0] + ".spans");
    int $numCVs = $degree + $numSpans;

    int $lastCV = $numCVs - 1;
    float $cvCurve1[] = `getAttr ($curvesList[0] + ".cp[" + $lastCV + "]")`;
    float $cvCurve2[] = `getAttr ($curvesList[1] + ".cp[0]")`;

    // this is the vector between the two cvs
    //
    float $vector[3];
    $vector[0] = $cvCurve2[0] - $cvCurve1[0];
    $vector[1] = $cvCurve2[1] - $cvCurve1[1];
    $vector[2] = $cvCurve2[2] - $cvCurve1[2];

    // calculate two other cvs on the line between the end cvs
    //
    float $cvNew1[3];
    $cvNew1[0] = $cvCurve1[0] + ($vector[0] * 0.333);
    $cvNew1[1] = $cvCurve1[1] + ($vector[1] * 0.333);
    $cvNew1[2] = $cvCurve1[2] + ($vector[2] * 0.333);
    float $cvNew2[3];
    $cvNew2[0] = $cvCurve1[0] + ($vector[0] * 0.666);
    $cvNew2[1] = $cvCurve1[1] + ($vector[1] * 0.666);
    $cvNew2[2] = $cvCurve1[2] + ($vector[2] * 0.666);

    // create the degree 3 curve
    //
    string $resultCurve = eval("curve -p " + $cvCurve1[0] + " " + $cvCurve1[1] + " " + $cvCurve1[2] + " -p " + $cvNew1[0] + " " + $cvNew1[1] + " " + $cvNew1[2] + " -p " + $cvNew2[0] + " " + $cvNew2[1] + " " + $cvNew2[2] + " -p " + $cvCurve2[0] + " " + $cvCurve2[1] + " " + $cvCurve2[2] + " -k 0 -k 0 -k 0 -k 1 -k 1 -k 1");

    // attach all 3 curves if required
    //
    if ( $doAttach == 1 )
    {
        // attach curve1 to the new curve
        //
        string $attachedCurve[] = eval("attachCurve -ch 0 -rpo 0 -kmk 1 " + $curvesList[0] + " " + $resultCurve);

        // the straight curve is no longer needed
        //
        delete $resultCurve;

        // attach curve2 to the previously attached curves
        //
        $attachedCurve = eval("attachCurve -ch 0 -rpo 1 -kmk 1 " + $attachedCurve[0] + " " + $curvesList[1]);
        $resultCurve = $attachedCurve[0];
    }

    select -r $resultCurve;
    return $resultCurve;
}
