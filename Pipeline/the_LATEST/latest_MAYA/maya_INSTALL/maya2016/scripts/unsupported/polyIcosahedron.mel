// Copyright (C) 1997-2014 Autodesk, Inc., and/or its licensors.
// All rights reserved.
//
// The coded instructions, statements, computer programs, and/or related
// material (collectively the "Data") in these files contain unpublished
// information proprietary to Autodesk, Inc. ("Autodesk") and/or its licensors,
// which is protected by U.S. and Canadian federal copyright law and by
// international treaties.
//
// The Data is provided for use exclusively by You. You have the right to use,
// modify, and incorporate this Data into other products for purposes authorized 
// by the Autodesk software license agreement, without fee.
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND. AUTODESK
// DOES NOT MAKE AND HEREBY DISCLAIMS ANY EXPRESS OR IMPLIED WARRANTIES
// INCLUDING, BUT NOT LIMITED TO, THE WARRANTIES OF NON-INFRINGEMENT,
// MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE, OR ARISING FROM A COURSE 
// OF DEALING, USAGE, OR TRADE PRACTICE. IN NO EVENT WILL AUTODESK AND/OR ITS
// LICENSORS BE LIABLE FOR ANY LOST REVENUES, DATA, OR PROFITS, OR SPECIAL,
// DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES, EVEN IF AUTODESK AND/OR ITS
// LICENSORS HAS BEEN ADVISED OF THE POSSIBILITY OR PROBABILITY OF SUCH DAMAGES.

//
// Description : Construct an icosahedron given the length of the edge.
//

proc int remainder( int $x, int $y )
//
//
{
	int $q = $x/$y ;
	return $x - $q*$y   ;
}
// Find the radius of circle encompasing the polygon. 
//
proc float boundingCircleRadius( int $n, float $x )
//
//	Description:
//		number of sides on the polygon.
//		$x = length of the polygon.
//
{
	float $rad ;
	float $angle = 360.0 / $n ;

	float $cosx = cos(deg_to_rad($angle)) ; 	
	float $den = 2.0 * ( 1.0 - $cosx ) ;
	$rad = $x / sqrt($den) ;
	return $rad ;
}

proc float[] createRegularPolygonX( int $n, float $r )
{
	int $i ;
	float $x[] ;
	float $angle = 360.0 / $n ;

	for( $i = 0 ; $i < $n ; $i++ ) {
		float $a = $i * $angle ;	
		$x[$i] =  $r * cos(deg_to_rad($a)) ;
	}
	return $x ;	
}

proc float[] createRegularPolygonY( int $n,float $r )
{
	int $i ;
	float $x[] ;
	float $angle = 360.0 / $n ;
	for( $i = 0 ; $i < $n ; $i++ ) {
		float $a = $i * $angle ;	
		$x[$i] =  $r * sin(deg_to_rad($a)) ;
	}
	return $x ;	
}

proc pyramid( float $x[], float $y[], float $z[] )
//
//	Description :
//
{

}

global proc int polyIcosahedron( float $len )

{
	int $i ;
	int $n = 5 ;
	float $zp1[5] ;
	float $r = boundingCircleRadius( $n, $len ) ;

	// first pentagon.
	float $xp1[] = createRegularPolygonX( $n, $r ) ;
	float $yp1[] = createRegularPolygonY( $n, $r ) ;
	for( $i = 0 ; $i < $n ; $i++ ) $zp1[$i] = 0.0 ;

	// second pentagon.
	float $zp2[5] ;
	float $xp2[] = createRegularPolygonX( $n, -1.0 * $r ) ;
	float $yp2[] = createRegularPolygonY( $n, -1.0 * $r ) ;
	float $dx =  ( $xp2[0] - $xp1[2] ) ;
	float $dy =  ( $yp2[0] - $yp1[2] ) ;
	float $rhs = $len*$len - $dx*$dx - $dy*$dy ;
	float $z = sqrt(abs($rhs)); 
	for( $i = 0 ; $i < $n ; $i++ ) $zp2[$i] = $z ;



	// create triangles.
	//
	string $facets[] ;
	clear($facets);
	for( $i = 0 ; $i < $n ; $i++ ) {
		int $k ;
		int $i1 = $i+2 ;
		int $i2 = $i1+1 ;
		$i1 = remainder( $i1, $n ) ;	
		$i2 = remainder( $i2, $n ) ;	
		string $tmpFacets[] ;
		$tmpFacets = `polyCreateFacet -ch 0 -p $xp1[$i1] $yp1[$i1] $zp1[$i1] -p $xp1[$i2] $yp1[$i2] $zp1[$i2] -p $xp2[$i] $yp2[$i] $zp2[$i]`;		
		int $l = size($facets) ;
		for( $k = 0 ; $k < size($tmpFacets) ; $k++ ) {
			$facets[$l++] = $tmpFacets[$k] ;
		}
		int $i3 = remainder($i+1,$n) ;	
		$tmpFacets = `polyCreateFacet -ch 0 -p $xp1[$i2] $yp1[$i2] $zp1[$i2] -p $xp2[$i3] $yp2[$i3] $zp2[$i3] -p $xp2[$i] $yp2[$i] $zp2[$i]`;
		$l = size($facets) ;
		for( $k = 0 ; $k < size($tmpFacets) ; $k++ ) {
			$facets[$l++] = $tmpFacets[$k] ;
		}
	}

	string $ico[] ;	
	// unite.
	//
	string $part1[] ;	
	select -r $facets ;
	$part1 = `polyUnite -ch 0` ;


	clear($facets);
	// top pentagonal pyramid.
	//
	$z = $len*$len - ($xp1[0]*$xp1[0] + $yp1[0]*$yp1[0]) ;
	$z = -1.0 * sqrt(abs($z)) ;
	for( $i = 0 ; $i < $n ; $i++ ) {
		int $k ;
		float $x = 0.0 ;
		float $y = 0.0 ;
		string $tmpFacets[] ;
		int $i1 = remainder($i+1,$n) ;
		$tmpFacets = `polyCreateFacet -ch 0 -p $xp1[$i] $yp1[$i] $zp1[$i] -p $x $y $z -p $xp1[$i1] $yp1[$i1] $zp1[$i1]`; 
		int $l = size($facets) ;
		for( $k = 0 ; $k < size($tmpFacets) ; $k++ ) {
			$facets[$l++] = $tmpFacets[$k] ;
		}
	}
	string $part2[] ;	
	select -r $facets ;
	$part2 = `polyUnite -ch 0` ;

	clear($facets);
	// bottom pentagonal pyramid.
	//
	float $zt = $len*$len - ($xp2[0]*$xp2[0] + $yp2[0]*$yp2[0] ) ;
	$z = sqrt(abs($zt)) + $zp2[0] ;
	for( $i = 0 ; $i < $n ; $i++ ) {
		int $k ;
		float $x = 0.0 ;
		float $y = 0.0 ;
		string $tmpFacets[] ;
		int $i1 = remainder($i+1,$n) ;
		$tmpFacets = `polyCreateFacet -ch 0 -p $x $y $z -p $xp2[$i] $yp2[$i] $zp2[$i] -p $xp2[$i1] $yp2[$i1] $zp2[$i1]`; 
		int $l = size($facets) ;
		for( $k = 0 ; $k < size($tmpFacets) ; $k++ ) {
			$facets[$l++] = $tmpFacets[$k] ;
		}
	}

	// atlast the polyhedron.
	//
	string $part3[] ;	
	select -r $facets ;
	$part3 = `polyUnite -ch 0` ;
	string $ico[] = `polyUnite -ch 0 $part1[0] $part2[0] $part3[0]` ;
	
	select -r $ico[0] ; 
		
	return 0 ;
}


