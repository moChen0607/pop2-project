// Copyright (C) 1997-2014 Autodesk, Inc., and/or its licensors.
// All rights reserved.
//
// The coded instructions, statements, computer programs, and/or related
// material (collectively the "Data") in these files contain unpublished
// information proprietary to Autodesk, Inc. ("Autodesk") and/or its licensors,
// which is protected by U.S. and Canadian federal copyright law and by
// international treaties.
//
// The Data is provided for use exclusively by You. You have the right to use,
// modify, and incorporate this Data into other products for purposes authorized 
// by the Autodesk software license agreement, without fee.
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND. AUTODESK
// DOES NOT MAKE AND HEREBY DISCLAIMS ANY EXPRESS OR IMPLIED WARRANTIES
// INCLUDING, BUT NOT LIMITED TO, THE WARRANTIES OF NON-INFRINGEMENT,
// MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE, OR ARISING FROM A COURSE 
// OF DEALING, USAGE, OR TRADE PRACTICE. IN NO EVENT WILL AUTODESK AND/OR ITS
// LICENSORS BE LIABLE FOR ANY LOST REVENUES, DATA, OR PROFITS, OR SPECIAL,
// DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES, EVEN IF AUTODESK AND/OR ITS
// LICENSORS HAS BEEN ADVISED OF THE POSSIBILITY OR PROBABILITY OF SUCH DAMAGES.

//
//	Description:
//		Finds the circular arc that passes through the given three
//		3D points (p1, p2, p3).  Returns the radius of the circular arc
//		and the center and normal of the circular arc are
//		returned as arguments.  The center and normal are both float
//		arrays of 3 values each.
//
global proc float arc3Pt( 
	float $p1[], float $p2[], float $p3[], // the 3 pts the arc will pass thru
	float $center[], float $normal[] )	// these are returned
{
	if( size($p1) != 3 )
		warning((uiRes("m_arc3Pt.kIncorrectArguments1")));
	if( size($p2) != 3 )
		warning((uiRes("m_arc3Pt.kIncorrectArguments2")));
	if( size($p3) != 3 )
		warning((uiRes("m_arc3Pt.kIncorrectArguments3")));

	string $result;

	// Get the vector p1-p2, p1-p3
	//
	float $p1p2[3];
	float $p1p3[3];
	$p1p2[0] = $p2[0]-$p1[0]; $p1p2[1] = $p2[1]-$p1[1]; $p1p2[2]=$p2[2]-$p1[2];
	$p1p3[0] = $p3[0]-$p1[0]; $p1p3[1] = $p3[1]-$p1[1]; $p1p3[2]=$p3[2]-$p1[2];

	// Get the normal to the plane formed by p1, p2, p3, which is the
	// cross prod of p1-p2 and p1-p3
	//
	float $normal[3];
	$normal = crossProduct( $p1p2, $p1p3, 0, 0 );

	// Get the mid pts on each vector (the average of two pts)
	//
	float $mid1[3], $mid2[3];
	$mid1 = midPoint2Pts( $p1, $p2 );
	$mid2 = midPoint2Pts( $p1, $p3 );

	// Get the perp. vectors to p1-p2 and p1-p3, which is the
	// cross prod of the normal vector with p1-p2 and p1-p3. Get these
	// as normalized vectors before sending them to lineIntersection
	//
	float $perp_p1p2[3];
	float $perp_p1p3[3];
	$perp_p1p2 = crossProduct( $normal, $p1p2, 0, 1 );
	$perp_p1p3 = crossProduct( $normal, $p1p3, 0, 1 );

	// Intersect the persp. vectors going through the mid pts.
	// The intersection is the center of the arc.
	//
	$center = lineIntersection( $mid1, $perp_p1p2, $mid2, $perp_p1p3 );

	// Find the radius for the circle and return the radius.
	//
	float $radius = distance2Pts( $p1, $center );

	return $radius;
}
