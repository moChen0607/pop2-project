// Copyright (C) 1997-2014 Autodesk, Inc., and/or its licensors.
// All rights reserved.
//
// The coded instructions, statements, computer programs, and/or related
// material (collectively the "Data") in these files contain unpublished
// information proprietary to Autodesk, Inc. ("Autodesk") and/or its licensors,
// which is protected by U.S. and Canadian federal copyright law and by
// international treaties.
//
// The Data is provided for use exclusively by You. You have the right to use,
// modify, and incorporate this Data into other products for purposes authorized 
// by the Autodesk software license agreement, without fee.
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND. AUTODESK
// DOES NOT MAKE AND HEREBY DISCLAIMS ANY EXPRESS OR IMPLIED WARRANTIES
// INCLUDING, BUT NOT LIMITED TO, THE WARRANTIES OF NON-INFRINGEMENT,
// MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE, OR ARISING FROM A COURSE 
// OF DEALING, USAGE, OR TRADE PRACTICE. IN NO EVENT WILL AUTODESK AND/OR ITS
// LICENSORS BE LIABLE FOR ANY LOST REVENUES, DATA, OR PROFITS, OR SPECIAL,
// DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES, EVEN IF AUTODESK AND/OR ITS
// LICENSORS HAS BEEN ADVISED OF THE POSSIBILITY OR PROBABILITY OF SUCH DAMAGES.

//
// Description : Given the length of edge, construct an octahedron
//

// Find the radius of circle encompasing the polygon. 
//
proc float boundingCircleRadius( int $n, float $x )
//
//	Description:
//		number of sides on the polygon.
//		$x = length of the polygon.
//
{
	float $rad ;
	float $angle = 360.0 / $n ;

	float $cosx = cos(deg_to_rad($angle)) ; 	
	float $den = 2.0 * ( 1.0 - $cosx ) ;
	$rad = $x / sqrt($den) ;
	return $rad ;
}

proc float[] createRegularPolygonX( int $n, float $r )
{
	int $i ;
	float $x[] ;
	float $angle = 360.0 / $n ;

	for( $i = 0 ; $i < $n ; $i++ ) {
		float $a = $i * $angle ;	
		$x[$i] =  $r * cos(deg_to_rad($a)) ;
	}
	return $x ;	
}

proc float[] createRegularPolygonY( int $n,float $r )
{
	int $i ;
	float $x[] ;
	float $angle = 360.0 / $n ;
	for( $i = 0 ; $i < $n ; $i++ ) {
		float $a = $i * $angle ;	
		$x[$i] =  $r * sin(deg_to_rad($a)) ;
	}
	return $x ;	
}


global proc int polyOctahedron( float $len )
{

	int $n = 4 ;
	float $r = boundingCircleRadius( $n, $len ) ;

	float $x[] = createRegularPolygonX( $n, $r ) ;
	float $y[] = createRegularPolygonY( $n, $r ) ;


	float $p1x, $p1y, $p1z ; 	
	float $p2x, $p2y, $p2z ; 	

	// top half.
	//	
	$p1x = 0.0 ;	
	$p1y = 0.0 ;	
	$p1z = sqrt( $len*$len - $r*$r);	

	float $z = 0.0 ;
	string $facet1[] ;
	$facet1 = `polyCreateFacet -ch 0 -p $p1x $p1y $p1z -p $x[0] $y[0] $z -p $x[1] $y[1] $z` ;
	
	string $facet2[] ;
	$facet2 = `polyCreateFacet -ch 0 -p $p1x $p1y $p1z -p $x[1] $y[1] $z -p $x[2] $y[2] $z` ;

	string $facet3[] ;
	$facet3 = `polyCreateFacet -ch 0 -p $p1x $p1y $p1z -p $x[2] $y[2] $z -p $x[3] $y[3] $z` ;

	string $facet4[] ;
	$facet4 = `polyCreateFacet -ch 0 -p $p1x $p1y $p1z -p $x[3] $y[3] $z -p $x[0] $y[0] $z` ;

	// bottom half.
	//
	$p2x = 0.0 ;	
	$p2y = 0.0 ;	
	$p2z = -1.0 * $p1z;	

	string $facet5[] ;
	$facet5 = `polyCreateFacet -ch 0 -p $x[0] $y[0] $z -p $p2x $p2y $p2z -p $x[1] $y[1] $z` ;

	string $facet6[] ;
	$facet6 = `polyCreateFacet -ch 0 -p $x[1] $y[1] $z -p $p2x $p2y $p2z -p $x[2] $y[2] $z` ;

	string $facet7[] ;
	$facet7 = `polyCreateFacet -ch 0 -p $x[2] $y[2] $z -p $p2x $p2y $p2z -p $x[3] $y[3] $z` ;

	string $facet8[] ;
	$facet8 = `polyCreateFacet -ch 0 -p $x[3] $y[3] $z -p $p2x $p2y $p2z -p $x[0] $y[0] $z` ;

	string $octa[] ;
	$octa = `polyUnite -ch 0 $facet1[0] $facet2[0] $facet3[0] $facet4[0] $facet5[0] $facet6[0] $facet7[0] $facet8[0]` ;

	select -r $octa[0] ;
	return 0 ;

}

