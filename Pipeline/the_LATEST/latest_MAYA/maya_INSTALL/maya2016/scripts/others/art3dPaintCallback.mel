// Copyright (C) 1997-2014 Autodesk, Inc., and/or its licensors.
// All rights reserved.
//
// The coded instructions, statements, computer programs, and/or related
// material (collectively the "Data") in these files contain unpublished
// information proprietary to Autodesk, Inc. ("Autodesk") and/or its licensors,
// which is protected by U.S. and Canadian federal copyright law and by
// international treaties.
//
// The Data is provided for use exclusively by You. You have the right to use,
// modify, and incorporate this Data into other products for purposes authorized 
// by the Autodesk software license agreement, without fee.
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND. AUTODESK
// DOES NOT MAKE AND HEREBY DISCLAIMS ANY EXPRESS OR IMPLIED WARRANTIES
// INCLUDING, BUT NOT LIMITED TO, THE WARRANTIES OF NON-INFRINGEMENT,
// MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE, OR ARISING FROM A COURSE 
// OF DEALING, USAGE, OR TRADE PRACTICE. IN NO EVENT WILL AUTODESK AND/OR ITS
// LICENSORS BE LIABLE FOR ANY LOST REVENUES, DATA, OR PROFITS, OR SPECIAL,
// DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES, EVEN IF AUTODESK AND/OR ITS
// LICENSORS HAS BEEN ADVISED OF THE POSSIBILITY OR PROBABILITY OF SUCH DAMAGES.

//
//
//  Creation Date:  June 2000
//
//  Description:
//      Option tool callbacks for Artisan 3d Paint tool.
//
//
//  Procedure Name:
//     	art3dPaintCallback 
//
//  Description:
//      Initialize the option values for 3d Paint tool.
//
//  Input Arguments:
//		$artCommand - context command
//		$brushType  - brush type ( "artisanBrush" or "effectsBrush" )
//		$operation  - painting operation ( "Paint", "Erase", "Clone", "Smear", 
//					  or "Blur" )
//
//  Return Value:
//      None.
//
// 

global proc art3dUpdatePaintOperation(
	string  $artCommand,
	string  $brushType,
	string  $operation
)
//	Set the proper paint operation.	Enable and disable 
//	various parts of 3d Paint UI.
{
	// Clone stuff.
	radioButtonGrp -e -enable false art3dCloneMode;
	button 		   -e -enable false art3dCloneSourceSelectionButton;

	// Blur stuff.
	intSliderGrp   -e -enable false art3dBlurIntSlider;

	art3dPaintStoreBrushSettings();

	if ( $brushType == "effectsBrush" ) {
		floatSliderGrp -e -enable false art3dOpacitySlider;
	}
	else
	{
		floatSliderGrp -e -enable true art3dOpacitySlider;
	}

	int		$wrongPEBrush = 0;

	if ( $operation == "Clone" ) {
		// Clone.
		radioButtonGrp -e -enable true art3dCloneMode;
		button -e -enable true art3dCloneSourceSelectionButton;
	}
	else if ( $operation == "Smear" ) {
		// When loading new scene, the Paint Effects brush 
		// gets reset to a default paint brush but 3d Paint 
		// still thinks that it is in smear/blur mode. Therefore 
		// make sure that the type of brush is also consider 
		// when setting the paint brush for 3d Paint.
		if ( eval("getDefaultBrush()") != "defaultSmear" ) {
			$wrongPEBrush = 1;
		}
	} else if ( $operation == "Blur" ) {
		intSliderGrp -e -enable true art3dBlurIntSlider;
		
		// See comments for Smear. 
		if ( eval("getDefaultBrush()") != "defaultBlur" ) {
			$wrongPEBrush = 1;
		}
	} else if ( $operation == "Erase" ) {
		// Make sure that we go to aritsan brush.
		if ( $brushType == "effectsBrush" ) {
			// Switch to artisan brush. 
			art3dUpdateStampProfile( "poly", $artCommand );
		}
	} 


	// Get current brush type and operation
	//
	string $cmd = ($artCommand + " -q -pot " + `currentCtx`);
	string $oldOpType = `eval $cmd`;
	$cmd = $artCommand + " -q -brushtype `currentCtx`";
	string $oldBrushType = eval( $cmd );

	if (    ( $wrongPEBrush == 1 ) 
		 || ( $oldBrushType != $brushType ) 
		 || ( $oldOpType    != $operation ) ) 
	{
		// The operation in the context and the one passed in to us do not 
		// match, so we'll need to make them do so
		//
		if ( $brushType == "effectsBrush" ) {
			// Make sure that we are in paint effects mode
			//
			art3dUpdateStampProfile( "lastPFX", $artCommand );

			// We have been asked to switch into a paint effects mode (paint, 
			// blur, or smear).  We need to restore the paint effects brush
			// that we last used in this mode
			//
			art3dPaintRestoreBrushSettings( $operation );
		} 
		else 
		{
			// We have been asked to switch into an artisan mode (paint, 
			// erase, or clone).  We need to restore the brush profile
			// that we last used in this mode
			//
			
			// Stored brush profiles
			//
			global string $gArt3dPaintLastPaintProfile = "poly";
			global string $gArt3dPaintLastEraseProfile = "poly";
			global string $gArt3dPaintLastCloneProfile = "poly";

			global int    $gArt3dPaintArtisanRotateToStroke = 1;
			int $rotateToStroke = false;

			string $profile;
			switch ( $operation ) {
				case "Paint":
					$profile = $gArt3dPaintLastPaintProfile;
					$rotateToStroke = $gArt3dPaintArtisanRotateToStroke;
					break;
				case "Erase":
					$profile = $gArt3dPaintLastEraseProfile;
					$rotateToStroke = $gArt3dPaintArtisanRotateToStroke;
					break;
				case "Clone":
					$profile = $gArt3dPaintLastCloneProfile;
					break;
			}

			// Put in the appropriate rotate-to-stroke settings
			//
			$cmd = ($artCommand + " -e -brushalignment " + $rotateToStroke + " `currentCtx`");
			eval $cmd;

			// Set the stamp profile if necessary
			//
			if ( $profile == "shape" ) {
				$profile = "lastFile";
			}

			// This is required to work around an issue in the 3D paint 
			// context command
			//
			art3dUpdateStampProfile( $profile, $artCommand );
			art3dUpdateStampProfile( $profile, $artCommand );
		}

		// Set the new operation into the context.
		//
		string $cmd = $artCommand + " -e -brushtype " + $brushType 
			+ " -e -pot " + $operation + " `currentCtx`";
		eval( $cmd );

	}
}


global proc art3dUpdatePressure( 
	string $artCommand
)
// Set the proper pressure layout with respect to artisan 
// or paint effects brush.
{
	if ( `columnLayout -exists art3dArtisanPressure` ) {
		string $cmd = ($artCommand + " -q -usepressure " + `currentCtx` );
		string $tabletPresentCmd = $artCommand + " -q -tablet " + `currentCtx` ;
		if ( `eval $tabletPresentCmd` && `eval $cmd` ) {
			$cmd = ($artCommand + " -q -brushtype " + `currentCtx`);

			string $brushType = `eval $cmd`;
			if ( $brushType == "artisanBrush" ) {
				columnLayout -e -en true  art3dArtisanPressure;
				columnLayout -e -en false art3dPaintEffectPressure;
			} else {
				columnLayout -e -en false art3dArtisanPressure;
				columnLayout -e -en true  art3dPaintEffectPressure;
			}
			checkBoxGrp -e -en true	art3dStylusPressureChkBox ;
		}
		else {
			// Grey out both of them.
			columnLayout -e -en false art3dArtisanPressure;
			columnLayout -e -en false art3dPaintEffectPressure;
			
			checkBoxGrp -e -en true art3dStylusPressureChkBox ;			
		}
	}
}


global proc art3dUpdateDisplayValues( 
	string $artCommand
)
// Update the display checkboxes.
{
	$cmd = ($artCommand + " -q -outline " + `currentCtx`);
	if ( `eval $cmd` ) {
		checkBoxGrp -e -en true art3dBrushFeedbackChkBox;
	} else {
		checkBoxGrp -e -en false art3dBrushFeedbackChkBox;
	}
}

global proc art3dUpdateColor_CB(
	string $artCmd
)
//	Color slider callback - we need to get the value from the color node.
{
	float $c[3] = `colorSliderGrp -q -rgb art3dColorSlider`;

	string $cmd = $artCmd + " -q -brushtype `currentCtx`";
	string $brushType = eval( $cmd );

	if ( $brushType == "artisanBrush" ) {
		eval($artCmd + " -e -rgb " + $c[0] + " " + $c[1] + " " + $c[2] + " `currentCtx`");
	}
	else if ( $brushType == "effectsBrush" ) {
		// Set the color on the default Paint Effect brush.
		string  $pfx3dColor = (getDefaultBrush()+ ".color1");
		setAttr $pfx3dColor -type float3 $c[0] $c[1] $c[2];
	}
}


global proc art3dUpdateFlood_CB(
	string $artCmd
)
//	Flood slider callback - we need to get the value from the color node.
{
	float $c[3] = `colorSliderGrp -q -rgb art3dFloodColorSlider`;
	eval($artCmd + " -e -rgbflood " + $c[0] + " " + $c[1] + " " + $c[2] + " `currentCtx`");
}

global proc art3dUpdateBlurInt_CB(
	string $artCmd
)
// Make sure that the blur intensity is updated on the 
// Paint Effect brush.
{
	string $cmd = $artCmd + " -q -brushtype `currentCtx`";
    string $brushType = eval( $cmd );

	if ( $brushType == "effectsBrush" ) {
		int 	$blurInt = `intSliderGrp -q -value art3dBlurIntSlider`;
		string  $pfx3dBlurInt = (getDefaultBrush()+ ".blurIntensity");

		// Set the blur intensity attribute 
		// on the default paint effect brush.
		setAttr $pfx3dBlurInt $blurInt;
	}
}

global proc int art3dStampProfileCB(
	string 	$artCmd,
	string 	$fileName,
	string 	$fileType
)
{
	// Ask the context to load the file.
	eval($artCmd + " -e -profileShapeFile \"" + $fileName + "\" `currentCtx`");
    
	// Return true to close the filebrowser.
	return true;
}   


global proc art3dStampProfileDialog(
	string  $artCommand
)   
{
	// Set the working directory to MAYA_LOCATION/brushShapes
	string $shapesDir = getenv("MAYA_LOCATION");
	if ( $shapesDir != "" ) {
		$shapesDir = $shapesDir + "/" + "brushShapes";
	} else {
		$shapesDir = (`workspace -q -rd` + "sourceimages/" );
	}	

	global int    $gArtSetAttrMapWorkspace;
    if (`file -q -ex $shapesDir`) {
        workspace -dir $shapesDir;
		$gArtSetAttrMapWorkspace = 1;
    }

	string $callback = "art3dStampProfileCB " + $artCommand + " ";
	fileBrowser( $callback, (uiRes("m_art3dPaintCallback.kOpen")), "image", 0 );
}


global proc art3dUpdateRadiusSliders(
	string	$artCommand,
	string  $brushType
)
// Update the radius sliaders labels - if this is paint
// effects we need scale and width, otherwise we need
// lower and upper radius.
{
	if ( $brushType == "artisanBrush" ) {
		// Update the labels.
		floatSliderGrp -e -label (uiRes("m_art3dPaintCallback.kRadiusU")) art3dUppRadiusSlider;
		floatSliderGrp -e -label (uiRes("m_art3dPaintCallback.kRadiusL")) art3dLowRadiusSlider;

		// Update the values,
		string $cmd = ($artCommand + " -q -radius " + `currentCtx` );
		float  $value = `eval $cmd`;
		floatSliderGrp -e -v $value art3dUppRadiusSlider;

		$cmd = ($artCommand + " -q -lowerradius " + `currentCtx` );
		float $value = `eval $cmd`;
		floatSliderGrp -e -v $value art3dLowRadiusSlider;
	} 
	else if ( $brushType == "effectsBrush" ) {
		// Update the labels.
		floatSliderGrp -e -label (uiRes("m_art3dPaintCallback.kScalePFX"))  art3dUppRadiusSlider;
		floatSliderGrp -e -label (uiRes("m_art3dPaintCallback.kWidthPFX"))  art3dLowRadiusSlider;

		// Update the values,
		string $cmd = "getAttr " + (getDefaultBrush()) + ".globalScale ";
		float  $value = `eval $cmd`;
		floatSliderGrp -e -v $value art3dUppRadiusSlider;

		// Update the context.
		$cmd = ($artCommand + " -e -pfxScale " + $value + " " + `currentCtx` );
		eval( $cmd );

		$cmd   = "getAttr " + (getDefaultBrush()) + ".brushWidth";
		$value = `eval $cmd`;
		floatSliderGrp -e -v $value art3dLowRadiusSlider;

		// Update the context.
		$cmd = ($artCommand + " -e -pfxWidth " + $value + " " + `currentCtx` );
		eval( $cmd );
	} 
}


global proc art3dUpdateStampProfile(
	string	$profile, 
	string	$artCmd
)
//	Update the brush profile and make sure that the proper 
//	brush type is set for it. Also, it the brush type is
//	changing, store the radius for later use.
{

	symbolCheckBox -e -v false art3dGaussianChBx;
	symbolCheckBox -e -v false art3dPolyBrushChBx;
	symbolCheckBox -e -v false art3dSolidChBx;
	symbolCheckBox -e -v false art3dRectBrushChBx;
	symbolCheckBox -e -v false art3dFileBrushChBx;

	symbolCheckBox -e -v false art3dLastPFXBrush;
	symbolCheckBox -e -v false art3dPFXBrushEditor;
	symbolCheckBox -e -v false art3dVisorEditor;

	// Find out which mode we are currently in
	// 
	string $cmd;
	$cmd = $artCmd + " -q -brushtype `currentCtx`";
	string $oldMode = eval( $cmd );

	// Set the stamp profile.
	$cmd = $artCmd + " -e -stampProfile \"" + $profile + "\" `currentCtx`";
	eval( $cmd );

	// Update the last brush icon.
	art3dUpdateLastBrushIcon( $artCmd );

	string $brushType = "artisanBrush";
	switch ( $profile ) {
		case "gaussian":
			symbolCheckBox -e -v true art3dGaussianChBx;
			break;
		case "poly":
			symbolCheckBox -e -v true art3dPolyBrushChBx;
			break;
		case "solid":
			symbolCheckBox -e -v true art3dSolidChBx;
			break;
		case "square":
			symbolCheckBox -e -v true art3dRectBrushChBx;
			break;
		case "lastFile": 
		case "shape": 
			symbolCheckBox -e -v true art3dFileBrushChBx;
			break;
		case "lastPFX": 
		case "paintEffects": 
		{
			symbolCheckBox -e -v true art3dLastPFXBrush;
			$brushType = "effectsBrush";

			// Switch back to the last used paint effects operation
			//
			global string $gArt3dPaintLastEffectsOperation = "Paint";

			if ( $oldMode != "effectsBrush" ) 
			{
				// We aren't in paint effects mode, so we need to switch to it.  
				// Set the operation into the context and restore last brush setting
				//
				string $cmd = $artCmd + " -e -pot \"" 
					+ $gArt3dPaintLastEffectsOperation + "\" `currentCtx`";
				eval( $cmd );

				// Reload the last brush
				//
				art3dPaintRestoreBrushSettings( $gArt3dPaintLastEffectsOperation );

				// Set Paint Effects global scale.
				// 
				float $col[3] = getAttr (getDefaultBrush() + ".color1");
				colorSliderGrp -e
					-label (uiRes("m_art3dPaintCallback.kColor1")) 
					-rgb $col[0] $col[1] $col[2]
    			art3dColorSlider;
			}
			break;
		}
	}

	if ( ( $brushType == "artisanBrush" ) &&
		 ( $oldMode   != "artisanBrush" ) )
	{
		// We are switching into artisan, so we need to restore the last 
		// artisan operation that we were using
		//
		global string $gArt3dPaintLastArtisanOperation = "Paint";

		// Set the operation into the context.
		//
		string $cmd = $artCmd + " -e -pot \"" 
			+ $gArt3dPaintLastArtisanOperation + "\" `currentCtx`";
		eval( $cmd );

		// Set the artisan color.
		// 
		float $col[3] = eval($artCmd + " -q -rgb `currentCtx` ");
		colorSliderGrp -e
			-label (uiRes("m_art3dPaintCallback.kColor"))
        	-rgb $col[0] $col[1] $col[2]
    	art3dColorSlider;
	}

	// Set the brush type (artisan or paint effects).
	$cmd = $artCmd + " -e -brushtype \"" + $brushType + "\" `currentCtx`";
	eval( $cmd );
	
	// Update the radius sliders to reflect the proper brush type. 
	art3dUpdateRadiusSliders( $artCmd, $brushType );

	// Disable/enable pressure UI.
	art3dUpdatePressure( $artCmd );
}


global proc art3dUpdateLastBrushIcon(
    string  $artCmd
)
//
//  Decription:
//      Display a proper brush icon in the UI if one exists.
//
{
    string $cmd = $artCmd + " -q -lastStampName `currentCtx`";
    string $fileName = eval( $cmd );

	// If the new brush image has an icon, then replace 
	// the existing default one with the new one.
	string $names[];
	tokenize( $fileName, "\/", $names );
	if ( size($names) == 0 ) 
		return;

	string $iconDir = getenv("MAYA_LOCATION");
	if ( $iconDir != "" ) {
		if ( `about -nt` ) {
			$iconDir = $iconDir + "\\" + "brushShapes" + "\\" + "BrushIcons" + "\\";
		} else {
			$iconDir = $iconDir + "\/" + "brushShapes" + "\/" + "BrushIcons" + "\/";
		}
	} 

	// Construct the icon name.
	string  $imageName = $names[size($names)-1];
	if ( $imageName != "" ) {
		string  $tmpNames[];
		tokenize( $imageName, ".", $tmpNames );

		if ( size($tmpNames) == 0 ) 
			return;

		// If the icon exist then use to in the symbol box.
		string $iconName = $iconDir + $tmpNames[0] + ".xpm";
		if ( `file -q -ex $iconName `) {
			symbolCheckBox -e -i $iconName  art3dFileBrushChBx;
		} else {
			symbolCheckBox -e -i "file.png" art3dFileBrushChBx;
		}
	}	
}


global proc art3dSetUppRadiusSlider(
	float  $value,
	string $artCommand
)
// Set the upper radius slider. If we are in the paint effects
// mode we have to update the global scale as well.
{
	string $cmd = $artCommand + " -q -brushtype `currentCtx`";
	string $brushType = eval( $cmd );
	if ( $brushType == "artisanBrush" ) {
		$cmd = $artCommand + " -e -radius " + $value + " `currentCtx`";
		eval($cmd);
	} 
	else if ( $brushType == "effectsBrush" ) {
		// Set the 3d Paint (artisan) scale.
		$cmd = $artCommand + " -e -pfxScale " + $value + " `currentCtx`";
		eval($cmd);

		// Set Paint Effects global scale.
		$cmd = "setAttr " + (getDefaultBrush()) + ".globalScale " + $value;
		eval($cmd);
	}
}

global proc art3dDragUppRadiusSlider(
	string $artCommand
)
// Ensure that the upper radius does not get smaller than the lower one.
{
	string $cmd = $artCommand + " -q -brushtype `currentCtx`";
	string $brushType = eval( $cmd );
	if ( $brushType == "artisanBrush" ) {
		float $radius		= `floatSliderGrp -q -v art3dUppRadiusSlider`;
		float $lowerRadius  = `floatSliderGrp -q -v art3dLowRadiusSlider`;
		if( $lowerRadius > $radius ) {
			floatSliderGrp -e -v $lowerRadius art3dUppRadiusSlider;
		}
	}
}

global proc art3dSetLowRadiusSlider(
	float  $value,
	string $artCommand
)
// Set the lower radius slider. If we are in the paint effects
// mode we have to update the brush width as well.
{
	string $cmd = $artCommand + " -q -brushtype `currentCtx`";
	string $brushType = eval( $cmd );
	if ( $brushType == "artisanBrush" ) {
		$cmd = $artCommand + " -e -lowerradius " + $value + " `currentCtx`";
		eval($cmd);
	} 
	else if ( $brushType == "effectsBrush" ) {
		// Set the 3d Paint (artisan) scale.
		$cmd = $artCommand + " -e -pfxWidth " + $value + " `currentCtx`";
		eval($cmd);

		// Set Paint Effects global width.
		$cmd = "setAttr " + (getDefaultBrush()) + ".brushWidth " + $value;
		eval($cmd);
	}
}

global proc art3dDragLowRadiusSlider(
	string $artCommand
)
{
	string $cmd = $artCommand + " -q -brushtype `currentCtx`";
	string $brushType = eval( $cmd );
	if ( $brushType == "artisanBrush" ) {
		float $radius		= `floatSliderGrp -q -v art3dUppRadiusSlider`;
		float $lowerRadius  = `floatSliderGrp -q -v art3dLowRadiusSlider`;
		if( $lowerRadius > $radius ) {
			floatSliderGrp -e -v $radius art3dLowRadiusSlider;
		}
	}
}

global proc art3dUpdatePaintMode( 
	string  $artCommand
)
{
       // Update the Reflection mode
	string $cmdRef = ($artCommand + " -q -reflection " + `currentCtx` );
	if( ` eval $cmdRef` )
	{			
		radioButtonGrp -e -en true art3dReflectionRadBtn;		
	}
	else
	{
		radioButtonGrp -e -en false art3dReflectionRadBtn;		
	}

        // Update the paint mode
	string $cmdProj = ($artCommand + " -q -projective " + `currentCtx` );
	if ( `eval $cmdProj` ) {			// Screen mode
		
		// Make sure that there is no reflection in Z
		if(`radioButtonGrp -q -en3 art3dReflectionRadBtn`)
			radioButtonGrp -e -en3 false art3dReflectionRadBtn;
	}
	else  if( ` eval $cmdRef` ) {	// Tangent mode
		// Enable reflectionZ radio button if Reflection is ON & Screen Projection is OFF.
		 if(!`radioButtonGrp -q -en3 art3dReflectionRadBtn`)
			radioButtonGrp -e -en3 true art3dReflectionRadBtn;
	}

}


// ==============================================================
// FrameLayout Callbacks. 
// ==============================================================

proc art3dBrushCallback(
	string  $artCommand
)
//
//	Description:
//		Callbacks for brush properties.
//
{
	// Brush Framelayout.
	floatSliderGrp -e
		-cc ("art3dSetUppRadiusSlider #1 " + $artCommand)
		-dc ("art3dDragUppRadiusSlider " + $artCommand)	
	art3dUppRadiusSlider;

	floatSliderGrp -e
		-cc ("art3dSetLowRadiusSlider #1 " + $artCommand)
		-dc ("art3dDragLowRadiusSlider " + $artCommand)	
	art3dLowRadiusSlider;

	// Artisan Brush Profiles.
	symbolCheckBox -e
		-cc ("art3dUpdateStampProfile gaussian " + $artCommand )
	art3dGaussianChBx;

	symbolCheckBox -e
		-cc ("art3dUpdateStampProfile poly " + $artCommand )
	art3dPolyBrushChBx;

	symbolCheckBox -e
		-cc ("art3dUpdateStampProfile solid " + $artCommand )
	art3dSolidChBx;

	symbolCheckBox -e
		-cc ("art3dUpdateStampProfile square " + $artCommand )
	art3dRectBrushChBx;

	symbolCheckBox -e
		-cc ("art3dUpdateStampProfile lastFile " + $artCommand )
	art3dFileBrushChBx;

	button -e
        -c ( "art3dStampProfileDialog \"" + $artCommand + "\"" + "; art3dUpdateStampProfile shape " + $artCommand )
	art3dShapeButton;

	// Paint Effects Brush Profiles.
	symbolCheckBox -e
		-cc ("art3dUpdateStampProfile lastPFX " + $artCommand )
	art3dLastPFXBrush;

	symbolCheckBox -e
		-cc ("TemplateBrushSettings; art3dUpdateStampProfile paintEffects " + $artCommand )
	art3dPFXBrushEditor;

	symbolCheckBox -e
        -cc ( "VisorWindow; art3dUpdateStampProfile paintEffects " + $artCommand)
	art3dVisorEditor;

	// Brush Alignment.
	checkBoxGrp -e
		-cc ( $artCommand + " -e -brushalignment #1 `currentCtx`")
	art3dPaintBrushAlignmentChkBox;
}


proc art3dColorCallback(
	string $artCmd
)
//
//	Description:
//		Callbacks for 3d paint color options.
//
{
	// Color Sliders.
	string $cmd = $artCmd + " -q -brushtype `currentCtx`";
	string $brushType = eval( $cmd );
	if ( $brushType == "artisanBrush" ) {
		colorSliderGrp -e 
			-label (uiRes("m_art3dPaintCallback.kSliderColor")) 
			-cc ( "art3dUpdateColor_CB " + $artCmd )
        art3dColorSlider;
	}
	else if ( $brushType == "effectsBrush" ) {
		colorSliderGrp -e 
			-label (uiRes("m_art3dPaintCallback.kEffectsBrushColor1"))  
			-cc ( "art3dUpdateColor_CB " + $artCmd )
		art3dColorSlider;
    }

	symbolButton -e -command ($artCmd + " -e -pickValue `currentCtx`") art3dPaintColorPick ;

	// Opacity.
	floatSliderGrp -e
		-cc ($artCmd + " -e -opacity #1 `currentCtx`")
	art3dOpacitySlider;
}

global proc art3dFloodPaintCallback(
		string $artCmd
)
{
	string $cmd ;
	int $FloodOption;

// Get old operation & brush type

	string $cmd = ($artCmd + " -q -pot " + `currentCtx`);
	string $oldOpType = `eval $cmd`;

// set new operation
	$cmd = $artCmd + " -e -pot " + " Paint " + " `currentCtx`";
	eval( $cmd );
	
	$floodOption = `radioButtonGrp -q -sl art3dFloodOption` ;
	
	if( $floodOption == 1)
	{
		$cmd = $artCmd + "-e -floodall `currentCtx`";
	}
	else
	{
		$cmd = $artCmd + "-e -floodselect `currentCtx`";
	}	 
	eval( $cmd );

// re-set old operation
	$cmd = $artCmd + " -e -pot " + $oldOpType + " `currentCtx`";
	eval( $cmd );
}

global proc art3dFloodEraseCallback(
		string $artCmd
)
{
	string $cmd ;
	int $FloodOption;
	
// Get old operation & brush type

	string $cmd = ($artCmd + " -q -pot " + `currentCtx`);
	string $oldOpType = `eval $cmd`;

// set new operation
	$cmd = $artCmd + " -e -pot " + " Erase " + " `currentCtx`";
	eval( $cmd );

	$floodOption = `radioButtonGrp -q -sl art3dFloodOption` ;
	
	if( $floodOption == 1)
	{
		$cmd = $artCmd + " -e -floodall `currentCtx`";
	}
	else
	{		
		$cmd = $artCmd + " -e -floodselect `currentCtx`";
	}
	eval( $cmd ); 

// re-set old operation
	$cmd = $artCmd + " -e -pot " + $oldOpType + " `currentCtx`";
	eval( $cmd );
}

proc art3dFloodCallback(
	string $artCmd
)
//
//	Description:
//		Callbacks for 3d paint Flood options.
//
{
	// Flood Sliders.
	string $cmd = $artCmd + " -q -brushtype `currentCtx`";
	string $brushType = eval( $cmd );

	// Color slider
	colorSliderGrp -e 
			-label (uiRes("m_art3dPaintCallback.kFloodColor"))
			-cc ( "art3dUpdateFlood_CB " + $artCmd )
	art3dFloodColorSlider;

	// Opacity.
	floatSliderGrp -e
		-cc ($artCmd + " -e -floodOpacity #1 `currentCtx`")
	art3dFloodOpacitySlider;

	// Flood Buttons.
	
	button -e 
		-c ("art3dFloodPaintCallback( \"" + $artCmd + "\" )")
	art3dFloodPaintButton;

	button -e 
		-c ("art3dFloodEraseCallback( \"" + $artCmd + "\" )")
	art3dFloodEraseButton;
}


proc art3dOperationCallback(
	string $artCommand
)
//
//	Description:
//		Callbacks for 3d paint color options.
//
{
	// Paint Operation.
	radioButtonGrp -e
        -on1 ("art3dUpdatePaintOperation " + $artCommand + " artisanBrush Paint")
        -on2 ("art3dUpdatePaintOperation " + $artCommand + " artisanBrush Erase")
        -on3 ("art3dUpdatePaintOperation " + $artCommand + " artisanBrush Clone")
        art3dPaintOperation0;

    radioButtonGrp -e
        -on1 ("art3dUpdatePaintOperation " + $artCommand + " effectsBrush Paint")
        -on2 ("art3dUpdatePaintOperation " + $artCommand + " effectsBrush Smear")
        -on3 ("art3dUpdatePaintOperation " + $artCommand + " effectsBrush Blur")
        art3dPaintOperation1;

	button -e 
		-c ( "art3dResetBrushesCallback( \"" + $artCommand + "\" )" )
	art3dResetBrushesButton;

	button -e 
		-c ($artCommand + " -e -selectclonesource true `currentCtx`" )
	art3dCloneSourceSelectionButton;
	
	if( !`exists alphaBlend_uiToMel` ) {
		source "art3dPaintProperties.mel";
	}
 
	// Alpha Blend Mode.
	optionMenuGrp -e 
		-cc ($artCommand + " -e -alphablendmode `alphaBlend_uiToMel(\"#1\")` `currentCtx`")
	art3dBlendModeOptionMenu;


	// Clone stuff.
	radioButtonGrp -e
		-on1 ($artCommand + " -e -dynclonemode true `currentCtx`" ) 
		-on2 ($artCommand + " -e -dynclonemode false `currentCtx`" )
	art3dCloneMode;

	button -e 
		-c ($artCommand + " -e -selectclonesource true `currentCtx`" )
	art3dCloneSourceSelectionButton;

	// Blur intensity slider.
	intSliderGrp -e
		-cc ( "art3dUpdateBlurInt_CB " + $artCommand )
	art3dBlurIntSlider;
}

global proc setFloodEraseState(string $artCommand , int $flag)
{
	eval($artCommand + " -e -saveTextureOnStroke " + $flag + "`currentCtx`");

	if( $flag )
	{
		button -e -enable false art3dFloodEraseButton;
		radioButtonGrp -e -en2 false art3dPaintOperation0;
	}
	else
	{
		button -e -enable true art3dFloodEraseButton;
		radioButtonGrp -e -en2 true art3dPaintOperation0;
	}
}


proc art3dFileTextureCallback(
	string $artCommand
)
//
//	Description:
//		Callbacks for 3d paint file texture options.
//
{
	if( !`exists attributeToPaint_uiToMel` ) {
		source "art3dPaintProperties.mel";
	}

	optionMenuGrp -e
		-cc ($artCommand + " -e -painttxtattrname `attributeToPaint_uiToMel(\"#1\")` `currentCtx`")
	art3dPaintAttrOptionMenu;
	art3dPaintDimPaintableAttr( $artCommand );

	button -e 
		-c ($artCommand + " -e -reloadtexfile `currentCtx`" )
	art3dReloadTexturesButton;

	checkBoxGrp -e
		-cc1 ($artCommand + " -e -saveonstroke #1 `currentCtx`")
	art3dSaveOnStrokeChkBox;

	checkBoxGrp -e
		-cc1 ("setFloodEraseState ( \"" + $artCommand + "\", #1 )")
	art3dSaveTextureOnStrokeChkBox;

	checkBoxGrp -e
		-cc1 ($artCommand + " -e -extendFillColor #1 `currentCtx`")
	art3dExtendFillColorChkBox;

	checkBoxGrp -e
		-cc1 ($artCommand + " -e -soloAsDiffuse #1 `currentCtx`")
	art3dSoloAsDiffuseChkBox;
}

proc art3dStrokeCallback(
	string $artCommand
)
//
//	Description:
//		Callbacks for 3d paint stroke options.
//
{
	// Paint Mode.
	checkBoxGrp -e
		-cc ( $artCommand + " -e -projective  #1 `currentCtx`")
	art3dProjectionModeChkBox;
	
	// Reflection Mode.
	checkBoxGrp -e
		-cc ( $artCommand + " -e -reflection  #1 `currentCtx`")
	art3dReflectionModeChkBox;
	art3dUpdatePaintMode( $artCommand );	
	
	//Reflection Axis
	radioButtonGrp -e
		-on1 ($artCommand + " -e -ra \"x\" `currentCtx`")
		-on2 ($artCommand + " -e -ra \"y\" `currentCtx`")
		-on3 ($artCommand + " -e -ra \"z\" `currentCtx`")
	art3dReflectionRadBtn;

	// Stamp Quality Sliders.
	floatSliderGrp -e
		-cc  ($artCommand + " -e -stampSpacing #1 `currentCtx`")
	art3dStampSpacingSlider;

	floatSliderGrp -e
		-cc  ($artCommand + " -e -stampDepth #1 `currentCtx`")
	art3dStampDepthSlider;
}

proc art3dPressureCallback(
	string $artCommand
)
//
//	Description:
//		Stylus Pressure callbacks.
//
{

	// Tablet Pressure.
	checkBoxGrp -e
		-cc1 ( $artCommand + " -e -usepressure #1 `currentCtx`")
	art3dStylusPressureChkBox;

	art3dUpdatePressure( $artCommand );

	if( !`exists artisanPressureValue_uiToMel` ) {
		source "art3dPaintProperties.mel";
	}
	// Artisan Pressure.
	optionMenuGrp -e
		-cc ($artCommand + " -e -mappressure `artisanPressureValue_uiToMel(\"#1\")` `currentCtx`")
		art3dArtisanPressure;

	// Paint Effects Pressure.
	optionMenuGrp -e 
		-cc ("art3dPFXPressureMap(\"Pmap1\")")
	art3dPressureMap1;

	floatSliderGrp -e
		-cc ("art3dPFXPressureMap(\"pressureMin1\")")
	art3dPressureMin1;

	floatSliderGrp -e
		-cc ("art3dPFXPressureMap(\"pressureMax1\")")
	art3dPressureMax1;

	optionMenuGrp -e
		-cc ("art3dPFXPressureMap(\"Pmap2\")")
	art3dPressureMap2;

	floatSliderGrp -e
		-cc ("art3dPFXPressureMap(\"pressureMin2\")")
	art3dPressureMin2;	

	floatSliderGrp -e
		-cc ("art3dPFXPressureMap(\"pressureMax2\")")
	art3dPressureMax2;

	optionMenuGrp -e 
		-cc ("art3dPFXPressureMap(\"Pmap3\")")
	art3dPressureMap3;

	floatSliderGrp -e
		-cc ("art3dPFXPressureMap(\"pressureMin3\")")
	art3dPressureMin3;

	floatSliderGrp -e
		-cc ("art3dPFXPressureMap(\"pressureMax3\")")
	art3dPressureMax3;
}

global proc art3dUpdatePfxPressure(
	string 	$artisanCmd
)
{
	string 	$cmd;
	int 	$map;
	float 	$minV, $maxV;

	// Pressure mapping 1.
	$cmd  = $artisanCmd + " -q -pm1 `currentCtx`";	
	$map = eval( $cmd );
	$cmd = $artisanCmd + " -q -ps1 `currentCtx`";	
	$minV = eval( $cmd );
	$cmd = $artisanCmd + " -q -px1 `currentCtx`";	
	$maxV = eval( $cmd );
	
	art3dUpdatePFXPressureMap( "Pmap1", $map, $minV, $maxV );

	// Pressure mapping 2.
	$cmd  = $artisanCmd + " -q -pm2 `currentCtx`";	
	$map = eval( $cmd );
	$cmd = $artisanCmd + " -q -ps2 `currentCtx`";	
	$minV = eval( $cmd );
	$cmd = $artisanCmd + " -q -px2 `currentCtx`";	
	$maxV = eval( $cmd );
	
	art3dUpdatePFXPressureMap( "Pmap2", $map, $minV, $maxV );

	// Pressure mapping 3.
	$cmd  = $artisanCmd + " -q -pm3 `currentCtx`";	
	$map = eval( $cmd );
	$cmd = $artisanCmd + " -q -ps3 `currentCtx`";	
	$minV = eval( $cmd );
	$cmd = $artisanCmd + " -q -px3 `currentCtx`";	
	$maxV = eval( $cmd );

	art3dUpdatePFXPressureMap( "Pmap3", $map, $minV, $maxV );
}


global proc art3dPFXPressureMap(
    string $whichCallback
)
//
//	Description:
// 		Paint Effects pressure.
//
{
    float $fval;
    int   $rval, $ival;
   
	string $opt;
	string $artisanCmd = "art3dPaintCtx";
    switch( $whichCallback )
    {
        case "Pmap1":
        case "Pmap2":
        case "Pmap3":
            if( $whichCallback == "Pmap1" ) {
                $opt = `optionMenuGrp -q -v art3dPressureMap1`;
			} else if( $whichCallback == "Pmap2" ) {
                $opt = `optionMenuGrp -q -v art3dPressureMap2`;
			} else {
                $opt = `optionMenuGrp -q -v art3dPressureMap3`;
			}

            if( $opt == (uiRes("m_art3dPaintProperties.kScale")) )
            {
                $rval = 1;
            }
            else if( $opt == (uiRes("m_art3dPaintProperties.kWidth")) )
            {
                $rval = 2;
            }
            else if( $opt == (uiRes("m_art3dPaintProperties.kSoftness")) )
            {
                $rval = 3;
            }
            else if( $opt == (uiRes("m_art3dPaintProperties.kMenuItemColor")) )
            {
                $rval = 4;
            }
            else if( $opt == (uiRes("m_art3dPaintProperties.kMenuItemTransparency")) )
            {
                $rval = 5;
            }
            else if( $opt == (uiRes("m_art3dPaintProperties.kTubeWidth")) )
            {
                $rval = 6;
            }
            else if( $opt == (uiRes("m_art3dPaintProperties.kTubeLength")) )
            {
                $rval = 7;
            }
            else if( $opt == (uiRes("m_art3dPaintProperties.kMenuItemIncandescence")) )
            {
                $rval = 8;
            }
            else if( $opt == (uiRes("m_art3dPaintProperties.kGlowSpread")) )
            {
                $rval = 9;
            }
            else if( $opt == (uiRes("m_art3dPaintProperties.kTubesPerStep")) )
            {
                $rval = 10;
            }
            else if( $opt == (uiRes("m_art3dPaintProperties.kElevation")) )
            {
                $rval = 11;
            }
            else if( $opt == (uiRes("m_art3dPaintProperties.kAzimuth")) )
            {
                $rval = 12;
            }
            else if( $opt == (uiRes("m_art3dPaintProperties.kPathFollow")) )
            {
                $rval = 13;
            }
            else if( $opt == (uiRes("m_art3dPaintProperties.kPathAttract")) )
            {
                $rval = 14;
            }
            else if( $opt == (uiRes("m_art3dPaintProperties.kRandom")) )
            {
                $rval = 15;
            }
            else if( $opt == (uiRes("m_art3dPaintProperties.kWiggle")) )
            {
                $rval = 16;
            }
            else if( $opt == (uiRes("m_art3dPaintProperties.kCurl")) )
            {
                $rval = 17;
            }
            else if( $opt == (uiRes("m_art3dPaintProperties.kNoise")) )
            {
                $rval = 18;
            }
            else if( $opt == (uiRes("m_art3dPaintProperties.kTurbulence")) )
            {
                $rval = 19;
            }
            else if( $opt == (uiRes("m_art3dPaintProperties.kNumTwigs")) )
            {
                $rval = 20;
            }
            else if( $opt == (uiRes("m_art3dPaintProperties.kNumLeaves")) )
            {
                $rval = 21;
            }
            else if( $opt == (uiRes("m_art3dPaintProperties.kNumPetals")) )
            {
                $rval = 22;
            }
            else if( $opt == (uiRes("m_art3dPaintProperties.kSurfaceOffset")) )
            {
                $rval = 23;
            }
            else
            {
                $rval = 0;
            }
            if( $whichCallback == "Pmap1" )
                eval($artisanCmd) -e -pm1 $rval `currentCtx`;
            else if( $whichCallback == "Pmap2" )
                eval($artisanCmd) -e -pm2 $rval `currentCtx`;
            else
                eval($artisanCmd) -e -pm3 $rval `currentCtx`;
        break;
        case "pressureMin1":
            $fval = `floatSliderGrp -q -v art3dPressureMin1`;
			eval($artisanCmd) -e -ps1 $fval `currentCtx`;
        break;
        case "pressureMin2":
            $fval = `floatSliderGrp -q -v art3dPressureMin2`;
			eval($artisanCmd) -e -ps2 $fval `currentCtx`;
        break;
        case "pressureMin3":
            $fval = `floatSliderGrp -q -v art3dPressureMin3`;
			eval($artisanCmd) -e -ps3 $fval `currentCtx`;
        break;
        case "pressureMax1":
            $fval = `floatSliderGrp -q -v art3dPressureMax1`;
			eval($artisanCmd) -e -px1 $fval `currentCtx`;
        break;
        case "pressureMax2":
            $fval = `floatSliderGrp -q -v art3dPressureMax2`;
			eval($artisanCmd) -e -px2 $fval `currentCtx`;
        break;
        case "pressureMax3":
            $fval = `floatSliderGrp -q -v art3dPressureMax3`;
			eval($artisanCmd) -e -px3 $fval `currentCtx`;
        break;
    }
}

proc art3dDisplayCallback(
	string $artCommand
)
//
//	Description:
//		Callbacks for 3d paint display options.
//
{
	checkBoxGrp -e
		-cc ( $artCommand + " -e -outline #1 `currentCtx`")
	art3dDrawOutlineChkBox;

	checkBoxGrp -e
		-cc ( $artCommand + " -e -outwhilepaint #1 `currentCtx`")
	art3dBrushWhilePaintingChkBox;

	checkBoxGrp -e
		-cc ( $artCommand + " -e -brushfeedback #1 `currentCtx`")
	art3dBrushFeedbackChkBox;

	checkBoxGrp -e
		-cc ( $artCommand + " -e -showactive #1 `currentCtx`")
	art3dShowActiveLinesChkBox;	
}

//
//  Procedure Name:
//      art3dResetBrushesCallback
//
//  Description:
//      Reset all brushes and profiles for all of the painting operations back 
//		to their defaults
//
//  Input Arguments:
//      $artCommand - command to change tool settings
//
//  Return Value:
//      None.
//
global proc art3dResetBrushesCallback( string $artCommand ) 
{	
	// Stored brush profiles
	//
	global string $gArt3dPaintLastPaintProfile;
	global string $gArt3dPaintLastEraseProfile;
	global string $gArt3dPaintLastCloneProfile;

	$gArt3dPaintLastPaintProfile = "poly";
	$gArt3dPaintLastEraseProfile = "poly";
	$gArt3dPaintLastCloneProfile = "poly";

	// Variables containing names of nodes where we store the saved brush 
	// settings
	//
	global string $gArt3dPaintLastPaintBrush;
	global string $gArt3dPaintLastBlurBrush;
	global string $gArt3dPaintLastSmearBrush;

	// If they exists, delete the nodes with the saved brush settings 
	//
	if ( `objExists $gArt3dPaintLastPaintBrush` ) {
		delete $gArt3dPaintLastPaintBrush;
	}
	if ( `objExists $gArt3dPaintLastBlurBrush` ) {
		delete $gArt3dPaintLastBlurBrush;
	}
	if ( `objExists $gArt3dPaintLastSmearBrush` ) {
		delete $gArt3dPaintLastSmearBrush;
	}

	// Get current brush type and operation
	//
	string $cmd = ($artCommand + " -q -pot " + `currentCtx`);
	string $operation = `eval $cmd`;
	$cmd = $artCommand + " -q -brushtype `currentCtx`";
	string $brushType = eval( $cmd );

	if ( $brushType == "effectsBrush" ) {
		art3dPaintRestoreBrushSettings( $operation );
	} 
	else 
	{
		art3dUpdateStampProfile( "poly", $artCommand );
	}
} 

//
//  Procedure Name:
//      art3dSetupPaintEffectsBrushCallback
//
//  Description:
//      Sets up a script jobs to monitor the paint effects default brush for
//		changes.  
//
//  Input Arguments:
//      $artCommand - command to change tool settings
//		$parent - parent widget for script job (when it's deleted, so is the 
//				  job)
//
//  Return Value:
//      None.
//
proc art3dSetupPaintEffectsBrushCallback( string $artCommand, string $parent )
{
	global int $art3dPaintEffectsScriptJobBrushType = 0;
	global int $art3dPaintEffectsScriptJobGlobalScale = 0;
	global int $art3dPaintEffectsScriptJobBrushWidth = 0;
	
	if ( ( $art3dPaintEffectsScriptJobBrushType != 0 ) &&
		 ( $art3dPaintEffectsScriptJobGlobalScale != 0 ) &&
		 ( $art3dPaintEffectsScriptJobBrushWidth != 0 ) &&
		 ( `scriptJob -exists $art3dPaintEffectsScriptJobBrushType` ) &&
		 ( `scriptJob -exists $art3dPaintEffectsScriptJobGlobalScale` ) &&
		 ( `scriptJob -exists $art3dPaintEffectsScriptJobBrushWidth` ) )
	{
		// The script jobs are already in place, so return
		//
		return;
	}

	// Create the script jobs
	//
	string $cmd = "art3dPaintEffectsBrushCallback( \"" + $artCommand + "\" );";
	string $defaultBrush = getDefaultBrush();
	string $typeAttr = $defaultBrush + ".brushType";
	string $scaleAttr = $defaultBrush + ".globalScale";
	string $widthAttr = $defaultBrush + ".brushWidth";

	$art3dPaintEffectsScriptJobBrushType = 
		`scriptJob -parent $parent -attributeChange $typeAttr $cmd`;
	$art3dPaintEffectsScriptJobGlobalScale = 
		`scriptJob -parent $parent -attributeChange $scaleAttr $cmd`;
	$art3dPaintEffectsScriptJobBrushWidth = 
		`scriptJob -parent $parent -attributeChange $widthAttr $cmd`;
}

// =======================================================
// Main Procedure.
// =======================================================
global proc art3dPaintCallback(
	string 	$artCommand
)
{

	// Create callbacks to update the UI when paint effects 
	// brushes are modified
	//

	global string $gCreatorWireCtx;
	if (  $gCreatorWireCtx == "") {

		// Paint Effects is not loaded, disable all related stuff
		symbolCheckBox -e -enable false art3dLastPFXBrush;
		symbolCheckBox -e -enable false art3dPFXBrushEditor;
		symbolCheckBox -e -enable false art3dVisorEditor;
		radioButtonGrp -e -enable false art3dPaintOperation1;

		// force the interface to use Artisan Paint mode
		eval ("art3dUpdatePaintOperation " + $artCommand + " artisanBrush Paint");
	}
	else
	{
		art3dSetupPaintEffectsBrushCallback( $artCommand, "art3dCloneMode" );
	}

	// Brush frameLayout.
	art3dBrushCallback( $artCommand );

	// Color frameLayout.
	art3dColorCallback( $artCommand );

	// Flood frameLayout.
	art3dFloodCallback( $artCommand );

	// Operation frameLayout.
	art3dOperationCallback( $artCommand );

	// File frameLayout.
	art3dFileTextureCallback( $artCommand );

	// Stroke frameLayout.
	art3dStrokeCallback( $artCommand );

	// Pressure frameLayout.
	art3dPressureCallback( $artCommand );

	// Display frameLayout.
	art3dDisplayCallback( $artCommand );
}

// ==============================================================
// Assigning Textures 
// ==============================================================
//
global proc art3dPaintSaveFileTextures(
	string $currentTab
)
// Prompts the user to save the scene if necessary.
{
	setParent $currentTab;

	string $sceneName = `file -q -namespace`;

	if ( $sceneName == (untitledFileName()) ) {
		// Display the warning and return since we cannot 
		// save texture for untitled scenes.
		string $msg = (uiRes("m_art3dPaintCallback.kSaveMessage"));
		confirmDialog 
			-title (uiRes("m_art3dPaintCallback.kConfirm"))  
			-message $msg
			-button (uiRes("m_art3dPaintCallback.kOK")) ;

		// Return without saving.
		return;
	}

	// Save textures.
	art3dPaintCtx -e -savetexture `currentCtx`;
}

// ==============================================================
// Assigning Textures 
// ==============================================================
//
proc art3dAdjustFileTxtSizeSlider(
	string  $artCommand,
	string  $whichSlider
)
{
	if ( eval($artCommand + " -q -keepaspectratio `currentCtx`" ) ) {
		float $ratio = eval($artCommand + " -q -filetxtaspectratio `currentCtx`");

		if ( $whichSlider == "xSlider" ) {
			float $valX   = eval("intSliderGrp -q -v art3dPaintFileTxtSizeXSlider");
			int   $newVal = $valX/$ratio;
			intSliderGrp -e -v $newVal art3dPaintFileTxtSizeYSlider;
			eval($artCommand + " -e -filetxtsizey " + $newVal + " `currentCtx`");
		} else {
			float $valY   = eval("intSliderGrp -q -v art3dPaintFileTxtSizeYSlider");
			int   $newVal = $valY*$ratio;
			intSliderGrp -e -v $newVal art3dPaintFileTxtSizeXSlider;
			eval($artCommand + " -e -filetxtsizex " + $newVal + " `currentCtx`");
		}
	}
}

global proc art3dPaintSetFileSizeX(
	int 	$size
)
{
	int $kPLEMaxX = 1024;
	int $kPLEMaxY =  768;
	int $isMayaEvalVersion = `about -ev`;
	
	if( $isMayaEvalVersion )
	{
		string $textureWarn = uiRes("m_art3dPaintCallback.kPaintTextureWarn");
		if( $size > $kPLEMaxX ) {
			$size = $kPLEMaxX;
			warning(`format -s $kPLEMaxX -s $kPLEMaxY $textureWarn`);
		}
	
		int $aspect = eval("art3dPaintCtx -q -keepaspectratio `currentCtx`");
		if( $aspect ) {
			float $ratio = eval("art3dPaintCtx -q -filetxtaspectratio `currentCtx`");
			$sizeY = $size / $ratio;
			if( $sizeY > $kPLEMaxX ) {
				art3dPaintSetFileSizeX($kPLEMaxX);
				return;
			}
		} 
	}

	// Set the size to the context.
	art3dPaintCtx -e -filetxtsizex $size `currentCtx`;
	art3dAdjustFileTxtSizeSlider( "art3dPaintCtx",  "xSlider" );
	
	// Adjust the slider - make sure that it relfects the context setting.
	string $cmd = "art3dPaintCtx -q -filetxtsizex `currentCtx`";
	intSliderGrp -e -v `eval $cmd` art3dPaintFileTxtSizeXSlider;

	string $cmd = "art3dPaintCtx -q -filetxtsizey `currentCtx`";
	intSliderGrp -e -v `eval $cmd` art3dPaintFileTxtSizeYSlider;
}

global proc art3dPaintSetFileSizeY(
	int 	$size
)
{
	int $kPLEMaxX = 1024;
	int $kPLEMaxY =  768;
	int $isMayaEvalVersion = `about -ev`;
	
	if( $isMayaEvalVersion )
	{
		string $textureWarn = (uiRes("m_art3dPaintCallback.kPaintTextureWarn"));
		if( $size > $kPLEMaxY ) {
			$size = $kPLEMaxY;
			warning(`format -s $kPLEMaxX -s $kPLEMaxY $textureWarn`);
		}
	
		int $aspect = eval("art3dPaintCtx -q -keepaspectratio `currentCtx`");
		if( $aspect ) {
			float $ratio = eval("art3dPaintCtx -q -filetxtaspectratio `currentCtx`");
			$sizeX = $ratio * $size;
			if( $sizeX > $kPLEMaxX ) {
				art3dPaintSetFileSizeX($kPLEMaxX);
				return;
			}
		} 
	}

	// Set the size to the context.
	art3dPaintCtx -e -filetxtsizey $size `currentCtx`;
	art3dAdjustFileTxtSizeSlider( "art3dPaintCtx",  "ySlider" );
	
	// Adjust the slider - make sure that it relfects the context setting.
	string $cmd = "art3dPaintCtx -q -filetxtsizex `currentCtx`";
	intSliderGrp -e -v `eval $cmd` art3dPaintFileTxtSizeXSlider;

	string $cmd = "art3dPaintCtx -q -filetxtsizey `currentCtx`";
	intSliderGrp -e -v `eval $cmd` art3dPaintFileTxtSizeYSlider;
}

global proc art3dPaintKeepAspectRatio(
	int 	$aspect
)
{
	// Set the new aspect ratio.
	if ( $aspect ) {
		string $cmd = "art3dPaintCtx -q -filetxtsizex `currentCtx`";
		float $sizeX = eval( $cmd );

		string $cmd = "art3dPaintCtx -q -filetxtsizey `currentCtx`";
		float $sizeY = eval( $cmd );

		float $ratio = $sizeX/$sizeY;
		art3dPaintCtx -e -filetxtaspectratio $ratio `currentCtx`;
	}

	// Set the flag on the context.
	art3dPaintCtx -e -keepaspectratio $aspect `currentCtx`; 
}

global proc art3dPaintAssignFileTexture(
	string $currentTab
)
// 	Defines the window which pops when the user
// 	requests to assign textures. 
{
	int $maxX = 2048;
	int $maxY = 2048;
	int $isMayaEvalVersion = `about -ev`;
	if( $isMayaEvalVersion ) {
		int $kPLEMaxX = 1024;
		int $kPLEMaxY =  768;
		$maxX = $kPLEMaxX;
		$maxY = $kPLEMaxY;
	}

	setParent $currentTab;

	if ( !`window -exists art3dPaintAssignFileTxtWindow` ) {

		window -title (uiRes("m_art3dPaintCallback.kAssignEditFileTextures")) 
			-width 360 -height 300
			-iconName (uiRes("m_art3dPaintCallback.kAssign")) 
		art3dPaintAssignFileTxtWindow;

		setUITemplate -pushTemplate DefaultTemplate;

		formLayout mainForm;
			columnLayout colLayout;

				// Texture size.
				intSliderGrp -label (uiRes("m_art3dPaintCallback.kSizeX"))  
					-cw 1 100
					-min 32 -max 4096 -v 256
					-cc ("art3dPaintSetFileSizeX #1" )
					art3dPaintFileTxtSizeXSlider;

				intSliderGrp -label (uiRes("m_art3dPaintCallback.kSizeY")) 
					-cw 1 100
					-min 32 -max 4096 -v 256
					-cc ("art3dPaintSetFileSizeY #1" )
					art3dPaintFileTxtSizeYSlider;

				checkBoxGrp 
					-cw 1 100
					-label "" -label1 (uiRes("m_art3dPaintCallback.kKeepAspectRatio")) 
					-cc1 ("art3dPaintKeepAspectRatio #1 ")
					art3dPaintFileTxtKeepAspectChkBox;
				
				separator -h 5 -style "none";
					
				// File Format.	 
				optionMenuGrp -label (uiRes("m_art3dPaintCallback.kImageFormat")) 
							 -cc ("art3dPaintFileFormatOptionMenuCmd \"#1\"") 
							 art3dPaintFileFormatOptionMenu ;
								 
				buildImageFormatsMenu(0, 0, 0, 0, 0);
			
			separator -h 10;
			
			checkBoxGrp -label "" -label1 (uiRes("m_art3dPaintCallback.kAntialias"))  -numberOfCheckBoxes 1 
				-value1 off
				-cw 1 100
				-changeCommand ("" )
				art3dPaintconvertSolidTxAntiAlias;
				
			optionMenuGrp -label (uiRes("m_art3dPaintCallback.kBackgroundMode"))  -cal 1 "right"
				-cw 1 100
				-changeCommand "art3dPaintConvertSolidBackModeCB"
				art3dPaintConvertSolidBckMode;
				menuItem -label (uiRes("m_art3dPaintCallback.kShaderDefault")) ;
				menuItem -label (uiRes("m_art3dPaintCallback.kCustomColor")) ;
				menuItem -label (uiRes("m_art3dPaintCallback.kExtendEdgeColor")) ;

			colorSliderGrp -label (uiRes("m_art3dPaintCallback.kBackgroundColor"))  -rgb 0 0 0
				-cw 1 100
				-changeCommand ("")
				art3dPaintConvertSolidBckColor;
			
			disable -v true art3dPaintConvertSolidBckColor;

			checkBoxGrp -label "" -label1 (uiRes("m_art3dPaintCallback.kFillTextureSeams"))  
				-numberOfCheckBoxes 1 -value1 on
				-cw 1 100
				-changeCommand ("")
				art3dPaintConvertSolidTxFillTextureSeams;

			checkBoxGrp -label "" -label1 (uiRes("m_art3dPaintCallback.kBakeUsingVirtualPlane"))  -cw  2 210
				-cw 1 100
				-numberOfCheckBoxes 1
				-value1 off
				-changeCommand ("")
				art3dPaintConvertSolidTxSamplePlane;

			checkBoxGrp -label "" -label1 (uiRes("m_art3dPaintCallback.kBakeTransparency")) 
				-cw 1 100
				-cw  2 120
				-numberOfCheckBoxes 1
				-value1 off
				-changeCommand ("")
				art3dPaintConvertSolidTxBakeAlpha;

			setParent ..;

			button  -label (uiRes("m_art3dPaintCallback.kAssignEditTextures")) 
				-c art3dPaintAssignFileTextureNow
				art3dPaintAssignFileTexNowButton;

			button  -label (uiRes("m_art3dPaintCallback.kClose")) 
				-c ("{deleteUI art3dPaintAssignFileTxtWindow;}")
				cancelButton;

		setParent ..;

		formLayout -edit
			-af colLayout		"top"		5
			-af colLayout		"left"		5
			-af colLayout		"right"		5
			-ac colLayout		"bottom"	5 cancelButton
		
			-an art3dPaintAssignFileTexNowButton	"top"
			-af art3dPaintAssignFileTexNowButton	"left"		5
			-ap art3dPaintAssignFileTexNowButton	"right"		2 50
			-af art3dPaintAssignFileTexNowButton	"bottom"	5
		
			-an cancelButton	"top"		
			-ap cancelButton	"left"		3 50
			-af cancelButton	"right"		5
			-af cancelButton	"bottom"	5
		
			mainForm;
			
		setUITemplate -popTemplate;

		showWindow art3dPaintAssignFileTxtWindow;
	}
		
	// Initialize the values.
	$cmd = ("art3dPaintCtx -q -filetxtsizex " + `currentCtx` );
	intSliderGrp -e -v `eval $cmd` art3dPaintFileTxtSizeXSlider;

	$cmd = ("art3dPaintCtx -q -filetxtsizey " + `currentCtx` );
	intSliderGrp -e -v `eval $cmd` art3dPaintFileTxtSizeYSlider;

	$cmd = ("art3dPaintCtx -q -keepaspectratio " + `currentCtx` );
 	checkBoxGrp -e -v1 `eval $cmd` art3dPaintFileTxtKeepAspectChkBox;
 	
 	$cmd = ("art3dPaintCtx  -q -fileformat " + `currentCtx` );
 	string $imfKey = `eval $cmd`;
	imageFormatsMenuSelectImfKey("art3dPaintFileFormatOptionMenu", $imfKey);
	art3dPaintEnableDisableConvertSolidOptions();
}

global proc art3dPaintFileFormatOptionMenuCmd(string $menu)
{
	// Store directly the imfKey in art3dPaintCtx. 
	string $imfKey = imageFormatsMenuImfKey("art3dPaintFileFormatOptionMenu");
	art3dPaintCtx  -e -fileformat $imfKey `currentCtx`;	
}

global proc art3dPaintConvertSolidBackModeCB()
{
	int $isBackColor = `optionMenuGrp -q -sl art3dPaintConvertSolidBckMode`;
	disable -v ($isBackColor != 2) art3dPaintConvertSolidBckColor;
}

global proc art3dPaintEnableDisableConvertSolidOptions()
{
	string $shapeList[];
	string $shapeNames = eval("art3dPaintCtx -q -shapenames `currentCtx`"); // Get the surfaces which is supposed to be painted.
	tokenize $shapeNames $shapeList;
	string $proceduralTextures[];
	int $shapeIndex;
	for($shapeIndex = 0; $shapeIndex < size($shapeList); $shapeIndex++)
	{
		$proceduralTextures = art3dPaintGetConnectedTexture($shapeList[$shapeIndex]);
		if(size($proceduralTextures) > 0){
			break;
		}
	}
	
	int $disableFlag = false;
	if(size($proceduralTextures) ==  0)
	{
		$disableFlag = true;
	}
	disable  -v  $disableFlag art3dPaintconvertSolidTxAntiAlias;
	disable  -v  $disableFlag art3dPaintConvertSolidBckMode;
	if($disableFlag == false){
		art3dPaintConvertSolidBackModeCB();
	}
	else{
		disable	-v  $disableFlag art3dPaintConvertSolidBckColor;
	}
	disable  -v  $disableFlag art3dPaintConvertSolidTxFillTextureSeams;
	disable  -v  $disableFlag art3dPaintConvertSolidTxSamplePlane;
	disable  -v  $disableFlag art3dPaintConvertSolidTxBakeAlpha;
}


global proc art3dPaintConvertProceduralToFileTextures()
{	
	int $antiAliasFlag = true;
	int $fillTxFlag = true;
	int $bakeVirtualPlane = false;
	int $transFlag = false;
	string $bgMode = "Shader default";
	float $bgColor[] ={0,0,0};
	float $valueX   = 256;
	float $valueY   = 256;
    if ( `window -exists art3dPaintAssignFileTxtWindow`) {
		$antiAliasFlag = `checkBoxGrp -q -value1  art3dPaintconvertSolidTxAntiAlias`;
		$fillTxFlag = `checkBoxGrp -q -value1  art3dPaintConvertSolidTxFillTextureSeams`;
		$bakeVirtualPlane = `checkBoxGrp -q -value1  art3dPaintConvertSolidTxSamplePlane`;
		$transFlag = `checkBoxGrp -q -value1  art3dPaintConvertSolidTxBakeAlpha`;
		$bgMode = `optionMenuGrp -q -value  art3dPaintConvertSolidBckMode`;
		$bgColor = `colorSliderGrp -q  -rgbValue  art3dPaintConvertSolidBckColor`;
		$valueX   = eval("intSliderGrp -q -v art3dPaintFileTxtSizeXSlider");
		$valueY   = eval("intSliderGrp -q -v art3dPaintFileTxtSizeYSlider");
	}	
	
	switch ($bgMode)
	{
		case "Shader default":
				$bgMode = "shader";
				break;
		
		case	"Custom color":
				$bgMode = "color";
				break;
		
		case "Extend Edge Color":
				$bgMode = "extend";
				break;
	}
	
	
	string $shapeList[];
	string $shapeNames = eval("art3dPaintCtx -q -shapenames `currentCtx`"); // Get the surfaces which is supposed to be painted.
	string $matAttr = eval("art3dPaintCtx -q -painttxtattrname `currentCtx`"); // Get the attribute which is supposed to be painted
	tokenize $shapeNames $shapeList;
	string $proceduralNodes[];
	int $shapeIndex;
	for($shapeIndex = 0; $shapeIndex < size($shapeList); $shapeIndex++)
	{
		// Get the connected procedural textures for the given shape.
		$proceduralNodes = art3dPaintGetConnectedTexture($shapeList[$shapeIndex]);
		int $index;
		for($index = 0; $index < size($proceduralNodes); $index++)
		{
			string $sourceConnection, $destinationConnection;
			
			// Once the conversion is done we need to connect the file node appropriately to the shader.
			// So we need to have the information about the source node and the destination node.
			// The procedural nodes will be in the format "shader.attribute".
			if($matAttr == "normalCamera")
			{
				string $bumpConnections[] = `listConnections -source off -destination on -type "bump2d" $proceduralNodes[$index]`;
				if(size($bumpConnections) == 0)
				{
					$bumpConnections = `listConnections -source off -destination on -type "bump3d" $proceduralNodes[$index]`;
				}
				
				if(size($bumpConnections) == 0)
				{
					$bumpConnections = `listConnections -source off -destination on $proceduralNodes[$index]`;
				}
				if (`nodeType $bumpConnections[0]` == "singleShadingSwitch")
				{
					$bumpConnections = `listConnections -source off -destination on -plugs true $proceduralNodes[ $index]`;
					$destinationConnection = $bumpConnections[0];
				}else{
					$destinationConnection = $bumpConnections[0] + ".bumpValue";
				}
				$sourceConnection = ".outAlpha";
			}
			else if ($matAttr == "displacement")
			{
				string $dispConnections[] = `listConnections -source off -destination on -type "displacementShader" $proceduralNodes[$index]`;
				if(size($dispConnections) == 0)
				{
					$dispConnections = `listConnections -source off -destination on  $proceduralNodes[$index]` ;
				}
				if (`nodeType $dispConnections[0]` == "singleShadingSwitch")
				{
					$dispConnections = `listConnections -source off -destination on -plugs true $proceduralNodes[$index]` ;
					$destinationConnection = $dispConnections[0];
				}else{
					$destinationConnection = $dispConnections[0] + ".displacement";
				}
				$sourceConnection = ".outAlpha";
				
			}
			else
			{
				string $nodetype = `nodeType  $proceduralNodes[ $index]`;
				string $tokens[];
				tokenize $proceduralNodes[ $index] "." $tokens;
				string $regConnections[] = `listConnections -source off -destination on  $proceduralNodes[ $index]`;
				if (`nodeType $regConnections[0]` == "singleShadingSwitch" || `nodeType $regConnections[0]` == "tripleShadingSwitch")
				{
					$regConnections = `listConnections -source off -destination on -plugs true $proceduralNodes[ $index]`;
					$destinationConnection = $regConnections[0] ;
				}
				else
				{
					$destinationConnection = $regConnections[0] + "." + $matAttr;
				}
				$sourceConnection = "." + $tokens[1];
			}
			string $fileFormatCmd = "art3dPaintCtx  -q -fileformat " + `currentCtx`;
			string $fileFormat = `eval $fileFormatCmd`;
			// art3dPaintCtx returns it as "maya" and convert solid needs "iff"
			if($fileFormat == "maya")
			{
				$fileFormat = "iff" ;
			}
			string $fileNodes[];
			if($bgMode == "shader")
			{
				$fileNodes = `convertSolidTx  
											-antiAlias $antiAliasFlag 
											-fillTextureSeams  $fillTxFlag 
											-samplePlane  $bakeVirtualPlane
											-alpha $transFlag
											-backgroundMode $bgMode
											-resolutionX $valueX
											-resolutionY $valueY
											-fileFormat $fileFormat
											-force true
											$proceduralNodes[$index]
											$shapeList[$shapeIndex]`;
			}
			else
			{
				int $backgroundColor[3];
				$backgroundColor[0] = $bgColor[0] * 255;
				$backgroundColor[1] = $bgColor[1] * 255;
				$backgroundColor[2] = $bgColor[2] * 255;
				$fileNodes = `convertSolidTx  
										-antiAlias $antiAliasFlag 
										-fillTextureSeams  $fillTxFlag 
										-samplePlane  $bakeVirtualPlane
										-alpha $transFlag
										-backgroundMode $bgMode
										-backgroundColor  $backgroundColor[0] $backgroundColor[1] $backgroundColor[2]
										-resolutionX $valueX
										-resolutionY $valueY
										-fileFormat $fileFormat
										-force true
										$proceduralNodes[$index]
										$shapeList[$shapeIndex]`;
			}
            if (size($fileNodes) == 0)
               continue;
			$sourceConnection = $fileNodes[0] + $sourceConnection;
			connectAttr -force  $sourceConnection $destinationConnection;
			// Create a place2d to be connected to the newly created file texture node.
			string $place2d = `shadingNode -asUtility place2dTexture`;
            fileTexturePlacementConnect($fileNodes[0], $place2d);	
		}
	}
}

global proc string[] art3dPaintHandleSwitchNodes(string $connection)
{
	string $tokens[], $textureNodes[];
	
	tokenize $connection "." $tokens;
	string $shadingSwitchConnections[] = `listConnections -source on -destination off -shapes true -plugs true $tokens[0]` ;
	
	int $shadingIndex;
	int $count = 0 ;
	for($shadingIndex = 0; $shadingIndex < size($shadingSwitchConnections); $shadingIndex++)
	{
		string $switchConnectedType = `nodeType $shadingSwitchConnections[$shadingIndex]`;

		if($switchConnectedType == "file"|| $switchConnectedType == "mesh" ||  $switchConnectedType == "subdiv"
														|| $switchConnectedType == "nurbsSurface")
		{
			continue;
		}else{
			$textureNodes[$count++] = $shadingSwitchConnections[$shadingIndex];
		}
	}
	return $textureNodes;
}


global proc string[] art3dPaintGetConnectedTexture(string $shape)
{
	string $matAttr = eval("art3dPaintCtx -q -painttxtattrname `currentCtx`"); // Get the attribute which is supposed to be painted
	 
	string $proceduralTextureNodes[];
	
	if($shape == "")
		return $proceduralTextureNodes;
		
	string $shapeType = `nodeType $shape`;
	
	// Get the shading engine connected to the shape.
	string $sEng[]   = getShadingEngines($shape  );
	int $sEngSize = size($sEng);
	
	if($sEngSize == 0)
		return $proceduralTextureNodes;;
	
	int $sEngIndex, $count = 0;
	for($sEngIndex = 0; $sEngIndex < $sEngSize; $sEngIndex++)
	{
		//If the selected channel to be painted is displacement then handle it here.
		if($matAttr == "displacement")
		{
			// Get the displacement nodes connected to the shading engine.
			string $displacementNodes[] = `listConnections  -source on -destination off ($sEng[$sEngIndex] + ".displacementShader")`;
			int $dispSize = size($displacementNodes);
			int $dispIndex;
			for($dispIndex = 0; $dispIndex < $dispSize; $dispIndex++)
			{
				// Go through all the displacement nodes and get the incomming connection to the displacement node.
				string $textureConnections[] = `listConnections  -plugs true -source on -destination off ($displacementNodes[$dispIndex] + ".displacement")`;
				int $texIndex;
				for($texIndex = 0; $texIndex < size($textureConnections); $texIndex++)
				{
					// Check the node type which is connected. Do not do anything if it is a file node.
					string $nType = `nodeType $textureConnections[$texIndex]`;
					if($nType == "file")
					{
						continue;
					}else if($nType == "singleShadingSwitch")
					{
						string $tmpArray[] = art3dPaintHandleSwitchNodes($textureConnections[$texIndex]);
						$proceduralTextureNodes = stringArrayCatenate($proceduralTextureNodes, $tmpArray);
						$count = size($proceduralTextureNodes);
					}else{
						$proceduralTextureNodes[$count++] = $textureConnections[$texIndex];
					}
				}
			}
		}
		else
		{
			// If the channel selected is not displacement then we need to traverse back starting from  shaders.
			string $shaders[] = `listConnections  -source on -destination off ($sEng[$sEngIndex] + ".surfaceShader")`;
			int $shaderIndex;
			for($shaderIndex = 0; $shaderIndex < size($shaders); $shaderIndex++)
			{
				string $connections[];
				// Handle separetely if it is a bump channel, as this will be connected to a bump2d node.
				if($matAttr == "normalCamera"){
					$connections =  `listConnections  -source on -destination off ($shaders[$shaderIndex] + "." + $matAttr)`;
				}else{
					$connections =  `listConnections  -plugs true -source on -destination off ($shaders[$shaderIndex] + "." + $matAttr)`;
				}
				int $connIndex;
				for($connIndex = 0; $connIndex < size($connections); $connIndex++)
				{
					// Handling of bump channel here.
					if($matAttr == "normalCamera")
					{
						// The -plugs flag is set to true, as we need to get the source connection along with the attribute connected.
						string $textureConnections[] =  `listConnections -plugs true -source on -destination off ($connections[$connIndex] + ".bumpValue")`;
						int $texIndex;
						for($texIndex = 0; $texIndex < size($textureConnections); $texIndex++)
						{
							string $nType = `nodeType $textureConnections[$texIndex]`;
							if($nType == "file")
							{
								continue;
							}else if($nType == "singleShadingSwitch"){
								string $tmpArray[] = art3dPaintHandleSwitchNodes($textureConnections[$texIndex]);
								$proceduralTextureNodes = stringArrayCatenate($proceduralTextureNodes, $tmpArray);
								$count = size($proceduralTextureNodes);
							}else{
								$proceduralTextureNodes[$count++] = $textureConnections[$texIndex];
							}
						}
					}
					else
					{
						// Handle channels other than bump here.
						string $nType = `nodeType $connections[$connIndex]`;
						if($nType == "file")
							continue;
						else if($nType == "singleShadingSwitch" || $nType == "tripleShadingSwitch")
						{
				
							string $tmpArray[] = art3dPaintHandleSwitchNodes($connections[$connIndex]);
							$proceduralTextureNodes = stringArrayCatenate($proceduralTextureNodes, $tmpArray);
							$count = size($proceduralTextureNodes);
						}else{
						// We take into account everything including utilitility nodes.
							$proceduralTextureNodes[$count++] = $connections[$connIndex];
						}
					}
				}
			}
		}
	}
	string $tmpConnections[] =  stringArrayRemoveDuplicates($proceduralTextureNodes);
	$proceduralTextureNodes = $tmpConnections;
	return $proceduralTextureNodes;
}


global proc art3dPaintAssignFileTextureNow()
{
    int $shapeAttr = eval("art3dPaintCtx -q -shapeattr `currentCtx`");

	if( $shapeAttr == 0 )
		art3dPaintConvertProceduralToFileTextures();

    // Get the attr to paint name.
    string $matAttr = eval("art3dPaintCtx -q -painttxtattrname `currentCtx`");

    // Properly assign textures to that attribute.
    art3dPaintAssignFileTextures( $matAttr );

    // Pass the info back to the context that the assignment
    // has been completed.
    art3dPaintCtx -e -assigntxt `currentCtx`;

    // Delete the left over window.
    if ( `window -exists art3dPaintAssignFileTxtWindow`) {
        deleteUI art3dPaintAssignFileTxtWindow;
    }
}

