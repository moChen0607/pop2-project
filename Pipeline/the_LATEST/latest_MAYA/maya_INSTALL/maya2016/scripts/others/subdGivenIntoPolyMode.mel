// Copyright (C) 1997-2014 Autodesk, Inc., and/or its licensors.
// All rights reserved.
//
// The coded instructions, statements, computer programs, and/or related
// material (collectively the "Data") in these files contain unpublished
// information proprietary to Autodesk, Inc. ("Autodesk") and/or its licensors,
// which is protected by U.S. and Canadian federal copyright law and by
// international treaties.
//
// The Data is provided for use exclusively by You. You have the right to use,
// modify, and incorporate this Data into other products for purposes authorized 
// by the Autodesk software license agreement, without fee.
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND. AUTODESK
// DOES NOT MAKE AND HEREBY DISCLAIMS ANY EXPRESS OR IMPLIED WARRANTIES
// INCLUDING, BUT NOT LIMITED TO, THE WARRANTIES OF NON-INFRINGEMENT,
// MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE, OR ARISING FROM A COURSE 
// OF DEALING, USAGE, OR TRADE PRACTICE. IN NO EVENT WILL AUTODESK AND/OR ITS
// LICENSORS BE LIABLE FOR ANY LOST REVENUES, DATA, OR PROFITS, OR SPECIAL,
// DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES, EVEN IF AUTODESK AND/OR ITS
// LICENSORS HAS BEEN ADVISED OF THE POSSIBILITY OR PROBABILITY OF SUCH DAMAGES.

//
//
//	Creation Date:	Nov 4, 1999
//
//	Procedure:
//	    subdIntoPolyMode
//
//	Description:
//	    Given a subdivision surface (with no construction history),
//      create a polygon.  For more details see the description
//      with "subdiIntoPolyMode" function below.
//

proc subdGivenIntoPolyModeSimple( string $subd, string $poly, int $ap,
								  int $aut )
//
// Description:
//     See subdGivenIntoPolyMode description.
{
	string $conv[] = `polyToSubdiv -ch 1 -ap $ap -aut $aut -mpc 100000 -o 0 $poly`;
	if( size($conv) > 0 ) {
		// Connect:
		subdTransferUVsToCache $subd $conv[0];
		connectAttr ($conv[0] + ".o") ($subd + ".cr");
	}
}

proc subdGivenIntoPolyModeInvolved( string $subd, string $poly, int $ap,
									int $aut )
//
// Description:
//     See subdGivenIntoPolyMode description.
{
	string $conv[] = `polyToSubdiv -ch 1 -aut $aut -ap $ap -mpc 100000 -o 0 $poly`;
	if( size($conv) > 0 ) {

		// Transfer UVs to Cache before adding the lattice which forces
		// computation of the polyToSubd node, thus leaving the subd with
		// no finer level uvs. Bug #156705.
		//
		subdTransferUVsToCache $subd $conv[0];

		string $gpsFirst = "";
		string $gpsLast = "";
		string $newOrig = "";

		// Now produce the group parts nodes this object may have.
		// After that, disconnect and delete the newly created subd
		// but reconnect the group parts in there...
		string $lattice[] = `lattice -dv 2 2 2 -oc 0 -ldv 2 2 2 $subd`;
		string $subdHist[] = `listHistory $subd`;
		int $nLat = size($lattice);
		int $nSubdHist = size($subdHist);
		int $hadTweak = false;
		int $ii;

		if( $nLat < 3 ) {
			// Something weird happened...
			subdGivenIntoPolyModeSimple( $subd, $poly, $ap, $aut );
			return;
		}

		// Start at 1, as [0] is the shape itself.
		for( $ii=1; $ii<$nSubdHist; $ii+=1 ) {
			string $ntype = `nodeType $subdHist[$ii]`;
			if( "tweak" == $ntype ) {
				$hadTweak = true;
			}
			else if( $hadTweak ) {
				if( "groupParts" == $ntype ) {
					if( "" == $gpsLast ) {
						$gpsLast = $subdHist[$ii];
						$gpsFirst = $gpsLast;
					}
					else {
						$gpsFirst = $subdHist[$ii];
					}
				}
				else if( "subdiv" == $ntype ) {
					$newOrig = $subdHist[$ii];
					break;
				}
			}
		}

		string $tweak[];
		if( "" != $gpsLast ) {
			$tweak = `listConnections -plugs on
				($gpsLast + ".outputGeometry")`;
		}

		// Something weird happened...
		if( (0 == size($tweak)) ||
			("" == $gpsFirst) ||
			("" == $newOrig) ) {

			if( "" != $newOrig ) delete $newOrig;
			if( (size($tweak) > 0) && ("" != $tweak[0])) delete $tweak[0];
			delete $lattice[0] $lattice[1] $lattice[2];
			subdGivenIntoPolyModeSimple( $subd, $poly, $ap, $aut );
			return;
		}


		disconnectAttr ($gpsLast + ".outputGeometry") $tweak;
		disconnectAttr ($newOrig + ".worldSubdiv[0]")
										($gpsFirst + ".inputGeometry");
		disconnectAttr ($lattice[0] + ".outputGeometry[0]")
										($subd + ".create");

		connectAttr ($conv[0] + ".o") ($gpsFirst + ".inputGeometry");
		connectAttr ($gpsLast + ".outputGeometry") ($subd + ".cr");

		delete $lattice[0] $lattice[1] $lattice[2] $tweak[0] $newOrig;
	}
}

global proc string subdGivenIntoPolyMode( string $subd, int $hookAsHist,
										  int $allowHist, int $templateSubd,
										  int $ap )
// Description:
//     If $allowHistory is set, we will try and find a polygon in the
//     history of this object, delete that polygon's blind data of
//     the "hierarchical edits" type and put the new blind data on
//     the polygon shape.  If $allowHistory is not set, we will fail
//     if the subd has history in the first place.  If there is no
//     history on the subd, $allowHistory is ignored.  In that case,
//     we will make a new polygon (using "point position" option and
//     the base mesh on the subd -> poly conversion) and give it the blind
//     data that represents the hierarchical edits.  If $hookAsHistory is
//     set, we will then plug everything through polyToSubdiv node into
//     the subd we started with.  Otherwise, we just leave it be.  Note
//     that subd -> poly must be done without history, or we can end up
//     with a loop.
//
//     Ordinarilly, this would be called with a subdivision surface as $subd.
//     However, dagMenuProc.mel may call it with a transform above it instead,
//     so we do a filterExpand, just in case.
{
	global int $gSelectSubdivSurface;
	string $list[] = `filterExpand -ex 1 -fp 1 -sm $gSelectSubdivSurface $subd`;
	int $len = size($list);
	if( $len > 0 ) {
		$subd = $list[0];
	}

	int $whichMode = `subdiv -q -proxyMode $subd`;
	if( 2 == $whichMode ) {
		error( (uiRes("m_subdGivenIntoPolyMode.kErrorHistoryOrDeformers")) );
		return "";
	}
	else if( 1 == $whichMode ) {
		warning((uiRes("m_subdGivenIntoPolyMode.kWarningAlreadyPolyProxyMode")) );
		return "";
	}


	// We connect shaders to the new poly, if we are templating the subd.
	// Else, this is happening in poly proxy mode and we don't want
	// the shader assignment transferred.
	//
	int $connectShaders = $templateSubd;

	string $conn[] = `listConnections ($subd + ".cr")`;
	int $nConn = size($conn);

	string $hist[] = `listHistory $subd`;
	int $nHist = size($hist);

	string $poly = "";
	int $i;

	// If there is no history, we will just see the shape;
	if( ($nConn > 0) && $allowHist ) {
		// Find the polygon to give the blind data
		for( $i=0; $i<$nHist; $i+=1 ) {
			if( "mesh" == `nodeType $hist[$i]` ) {
				$poly = $hist[$i];
				break;
			}
		}
	}
	else if( 0 == $nConn ) {
		int $aut = !$ap;

		// we need to go and create the polygon
		string $res[] = `subdToPoly -ch 0 -aut $aut -cs $connectShaders -f 1 -d 0 -epp 1 -mp 100000 -cut 1 $subd`;
		if( size($res) > 0 ) {
			// Rename it to something nicer:
			if( $nHist > 0 ) {
				$poly = `rename $res[0] ($hist[0] + "HistPoly")`;
			}
		}
	}
	else {
		// This is not allowed:
		warning( `format -s $subd (uiRes("m_subdGivenIntoPolyMode.kWarningHistoryNotAllowed"))` );
		return "";
	}

	// At this point, we should have a $poly; if we don't we quit.
	if( "" == $poly ) {
		warning( `format -s $subd (uiRes("m_subdGivenIntoPolyMode.kWarningHistoryHasNoPoly"))` );
		return "";
	}

	// OK, we have the polygon.  Go ahead and make the blind stuff:
	if(catch(eval( "subdToBlind -ap " + $ap + " -ic true -izo false " + $subd + " " + $poly))){
		warning((uiRes("m_subdGivenIntoPolyMode.kWarningSubdToBlindFailed")) );
	}

    // In some cases, we need the extra poly node; this is when we have
    // more than 127 edits on some faces and thus multiple blind data nodes
    // of the same type.  If we don't do this poly component delete
	// will not work correctly.
	//
/*
	if( `getAttr -size ($poly + ".blindDataNodes")` > 7 ) {
		string $parent[] = `listRelatives -p $poly`;
		string $newPoly = `createNode mesh -p $parent[0]`;
		string $origPoly = `rename $poly ($poly + "Orig")`;
		$newPoly = `rename $newPoly $poly`;
		connectAttr ($origPoly + ".o") ($newPoly + ".i");
		setAttr ($origPoly + ".io") 1;
		$poly = $newPoly;
    }
*/

	// Now, produce the conversion node: note that that we list the
	// connections on .iog parent attribute.  listHistory seems to
	// mess up after one round of conversion, though it does get cleaned
	// up after a file I/O cycle.  It is always safe to go the involved
	// route, trouble is going "simple" route when you shouldn't.
	// 
	if( $hookAsHist ) {
		// Which one?
		string $iogConn[] = `listConnections ($subd + ".iog")`;
		if( ($nHist > 1) || (0 == size($iogConn)) ) {
			subdGivenIntoPolyModeInvolved( $subd, $poly, $ap, !$ap );
		}
		else {
			subdGivenIntoPolyModeSimple( $subd, $poly, $ap, !$ap );
		}
	}

	// Done.  Template the subd if necessary:
	if( $templateSubd ) {
		toggle -template -state on $subd;
	}

	return $poly;
}

