// Copyright (C) 1997-2014 Autodesk, Inc., and/or its licensors.
// All rights reserved.
//
// The coded instructions, statements, computer programs, and/or related
// material (collectively the "Data") in these files contain unpublished
// information proprietary to Autodesk, Inc. ("Autodesk") and/or its licensors,
// which is protected by U.S. and Canadian federal copyright law and by
// international treaties.
//
// The Data is provided for use exclusively by You. You have the right to use,
// modify, and incorporate this Data into other products for purposes authorized 
// by the Autodesk software license agreement, without fee.
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND. AUTODESK
// DOES NOT MAKE AND HEREBY DISCLAIMS ANY EXPRESS OR IMPLIED WARRANTIES
// INCLUDING, BUT NOT LIMITED TO, THE WARRANTIES OF NON-INFRINGEMENT,
// MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE, OR ARISING FROM A COURSE 
// OF DEALING, USAGE, OR TRADE PRACTICE. IN NO EVENT WILL AUTODESK AND/OR ITS
// LICENSORS BE LIABLE FOR ANY LOST REVENUES, DATA, OR PROFITS, OR SPECIAL,
// DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES, EVEN IF AUTODESK AND/OR ITS
// LICENSORS HAS BEEN ADVISED OF THE POSSIBILITY OR PROBABILITY OF SUCH DAMAGES.

//
//
//
//
includeEffectsGlobals();

proc markAllNewNodes( string $old[], string $new[], string $markingAttr )
{
	int $i;
	for( $i = 0; $i < size( $new ); $i ++ )
	{
		int $index = findInStringArray( $new[$i], $old );
		if( $index < 0 )
		{
			connectAttr -nextAvailable ($new[$i]+".message") $markingAttr;
		}
	}
}

proc lockAndHideTransformAttributes( string $object )
{
	string $ls[] = `ls -type transform $object`;
	if( size($ls) == 0 )
		return;

	setAttr -lock 1 ($object+".translateX");
	setAttr -lock 1 ($object+".translateY");
	setAttr -lock 1 ($object+".translateZ");
	setAttr -keyable 0 ($object+".translateX");
	setAttr -keyable 0 ($object+".translateY");
	setAttr -keyable 0 ($object+".translateZ");

	setAttr -lock 1 ($object+".rotateX");
	setAttr -lock 1 ($object+".rotateY");
	setAttr -lock 1 ($object+".rotateZ");
	setAttr -keyable 0 ($object+".rotateX");
	setAttr -keyable 0 ($object+".rotateY");
	setAttr -keyable 0 ($object+".rotateZ");

	setAttr -lock 1 ($object+".scaleX");
	setAttr -lock 1 ($object+".scaleY");
	setAttr -lock 1 ($object+".scaleZ");
	setAttr -keyable 0 ($object+".scaleX");
	setAttr -keyable 0 ($object+".scaleY");
	setAttr -keyable 0 ($object+".scaleZ");

	setAttr -lock 1 ($object+".shearXY");
	setAttr -lock 1 ($object+".shearXZ");
	setAttr -lock 1 ($object+".shearYZ");
	setAttr -keyable 0 ($object+".shearXY");
	setAttr -keyable 0 ($object+".shearXZ");
	setAttr -keyable 0 ($object+".shearYZ");

	setAttr -keyable 0 ($object+".visibility");
}

global proc string createNormalSurfaceManip( string $baseSurface, string $axis, float $location, int $resolutionU, int $resolutionV )
{
	if( ($axis != "u" ) &&
		($axis != "v" ) &&
		($axis != "x" ) )
	{
		string $fmt = (uiRes("m_createNormalSurfaceManip.kInvalidManipType"));
		error( `format -s $axis $fmt` );
		return "";
	}

	string $surfaceShape = getShapeFromObject( $baseSurface, 0, 0 );
	string $fmt = (uiRes("m_createNormalSurfaceManip.kNotNurbsSurface"));
	if( $surfaceShape == "" )
	{
		error( `format -s $baseSurface $fmt` );
		return "";
	}

	if( `nodeType $surfaceShape` != "nurbsSurface" )
	{
		error( `format -s $baseSurface $fmt` );
		return "";
	}

	string $oldNodeList[] = `ls`;

	float $surfaceMinU = `getAttr ($surfaceShape+".minValueU")`;
	float $surfaceMaxU = `getAttr ($surfaceShape+".maxValueU")`;
	float $rangeU = $surfaceMaxU - $surfaceMinU;

	float $surfaceMinV = `getAttr ($surfaceShape+".minValueV")`;
	float $surfaceMaxV = `getAttr ($surfaceShape+".maxValueV")`;
	float $rangeV = $surfaceMaxV - $surfaceMinV;


	float $minU = 0;
	float $maxU = 1;
	float $minV = 0;
	float $maxV = 1;

	string $manipName = "";
	if( $axis == "u" )
	{
		$minV = $maxV = $surfaceMinV + $rangeV * .5;
		$manipName = "NormalSurfaceUManip#";
	}
	else if( $axis == "v" )
	{
		$minU = $maxU = $surfaceMinU + $rangeU * .5;
		$manipName = "NormalSurfaceVManip#";
	}

	group -empty -name $manipName;
	string $manipGroup = getSelectedObject( 0 );
	// addAttr -at message -ln "_normalSurfaceManip_" $manipGroup;
	addMarkingAttribute($manipGroup,"_normalSurfaceManip_",0);

	//
	// The curve-on-surface for the manipulator is cubic to keep it smooth.
	//
	curveOnSurface -d 3 -uv $minU $minV -uv $minU $minV -uv $maxU $maxV -uv $maxU $maxV -k 0 -k 0 -k 0 -k 1 -k 1 -k 1 $surfaceShape;
	string $curve = getSelectedObject( 0 );
	lockAndHideTransformAttributes( $curve );
	// addAttr -at message -ln "manipBaseCurve" $manipGroup;
	markObjectWithAttribute($curve,$manipGroup,"manipBaseCurve");
	// connectAttr ($curve+".message") ($manipGroup+".manipBaseCurve");

	createNode pointOnSurfaceInfo;
	string $posi = getSelectedObject( 0 );
	connectAttr ($surfaceShape+".worldSpace[0]") ($posi+".inputSurface");
	setAttr -lock 1 ($curve+".translate");
	setAttr -lock 1 ($curve+".rotate");
	setAttr -lock 1 ($curve+".scale");

	string $locationString = "";
	string $minValueString = "";
	string $maxValueString = "";

	string $expressionString = "";

	if( $axis != "x" )
	{
		lockAndHideTransformAttributes( $manipGroup );
		{
			createNode plusMinusAverage;
			string $pma = getSelectedObject( 0 );
			connectAttr ($curve+".cp[0]") ($pma+".input3D[0]");
			connectAttr ($curve+".cp[1]") ($pma+".input3D[1]");
			connectAttr ($curve+".cp[2]") ($pma+".input3D[2]");
			connectAttr ($curve+".cp[3]") ($pma+".input3D[3]");
			setAttr ($pma+".operation") 3;
	
			connectAttr ($pma+".output3Dx") ($posi+".parameterU");
			connectAttr ($pma+".output3Dy") ($posi+".parameterV");
		}

		if( $axis == "u" )
		{
			setAttr ($curve+".cp[0].yValue") $surfaceMinV;
			setAttr ($curve+".cp[1].yValue") ($surfaceMinV + ($surfaceMaxV - $surfaceMinV)/3.0);
			setAttr ($curve+".cp[2].yValue") ($surfaceMinV + 2.0 * ($surfaceMaxV - $surfaceMinV)/3.0);
			setAttr ($curve+".cp[3].yValue") $surfaceMaxV;

			$locationString = "uLocation";
			$minValueString = "minV";
			$maxValueString = "maxV";
		}
		else
		{
			setAttr ($curve+".cp[0].xValue") $surfaceMinU;
			setAttr ($curve+".cp[1].yValue") ($surfaceMinU + ($surfaceMaxU - $surfaceMinU)/3.0);
			setAttr ($curve+".cp[2].yValue") ($surfaceMinU + 2.0 * ($surfaceMaxU - $surfaceMinU)/3.0);
			setAttr ($curve+".cp[3].xValue") $surfaceMaxU;

			$locationString = "vLocation";
			$minValueString = "minU";
			$maxValueString = "maxU";
		}

		addAttr -ln $locationString -min $surfaceMinU -max $surfaceMaxU
			-dv $location $manipGroup;
		setAttr -keyable 1 ($manipGroup+"."+$locationString);
		if( $axis == "u" )
		{
			connectAttr ($manipGroup+"."+$locationString) ($curve+".cp[0].xValue");
			connectAttr ($manipGroup+"."+$locationString) ($curve+".cp[1].xValue");
			connectAttr ($manipGroup+"."+$locationString) ($curve+".cp[2].xValue");
			connectAttr ($manipGroup+"."+$locationString) ($curve+".cp[3].xValue");
		}
		else
		{
			connectAttr ($manipGroup+"."+$locationString) ($curve+".cp[0].yValue");
			connectAttr ($manipGroup+"."+$locationString) ($curve+".cp[1].yValue");
			connectAttr ($manipGroup+"."+$locationString) ($curve+".cp[2].yValue");
			connectAttr ($manipGroup+"."+$locationString) ($curve+".cp[3].yValue");
		}

		addAttr -ln "minDistance" -dv 1 $manipGroup;
		setAttr -keyable 1 ($manipGroup+".minDistance");
		addAttr -ln "maxDistance" -dv 2 $manipGroup;
		setAttr -keyable 1 ($manipGroup+".maxDistance");

		addAttr -ln $minValueString -min $surfaceMinV -max $surfaceMaxV
			-dv $surfaceMinV  $manipGroup;
		setAttr -keyable 1 ($manipGroup+"."+$minValueString);

		addAttr -ln $maxValueString -min $surfaceMinV -max $surfaceMaxV
			-dv $surfaceMaxV  $manipGroup;
		setAttr -keyable 1 ($manipGroup+"."+$maxValueString);

		//
		// Create the expression to keep the curve-on-surface's CV's evenly
		// spaced across the "sampled" section of the main surface.
		//
		if( $axis == "u" )
		{
			string $minStr = $manipGroup+"."+$minValueString;
			string $maxStr = $manipGroup+"."+$maxValueString;
			$expressionString += ($curve+".cp[0].yValue = "+$minStr+";\n");
			$expressionString += ($curve+".cp[1].yValue = "+$minStr+" + ("+$maxStr+"-"+$minStr+")/3.0;\n");
			$expressionString += ($curve+".cp[2].yValue = "+$minStr+" + 2.0 * ("+$maxStr+"-"+$minStr+")/3.0;\n");
			$expressionString += ($curve+".cp[3].yValue = "+$maxStr+";\n");
		}
		else
		{
			string $minStr = $manipGroup+"."+$minValueString;
			string $maxStr = $manipGroup+"."+$maxValueString;
			$expressionString += ($curve+".cp[0].xValue = "+$minStr+";\n");
			$expressionString += ($curve+".cp[1].xValue = "+$minStr+" + ("+$maxStr+"-"+$minStr+")/3.0;\n");
			$expressionString += ($curve+".cp[2].xValue = "+$minStr+" + 2.0 * ("+$maxStr+"-"+$minStr+")/3.0;\n");
			$expressionString += ($curve+".cp[3].xValue = "+$maxStr+";\n");
		}

		setAttr ($curve+".template") 1;
	}
	else
	{
	}

	//
	// Create offset curves
	//
	offsetCurve -ch on -rn false -cb 0 -st true -cl true -d 1 $curve;
	string $minOffsetCurve = getSelectedObject( 0 );
	string $minHistory[] = `listHistory -leaf true -levels 1 $minOffsetCurve`;
	string $minHistoryOffsets[] = `ls -type offsetCurve $minHistory`;
	string $minOffset = $minHistoryOffsets[0];
	lockAndHideTransformAttributes( $minOffsetCurve );

	// addAttr -at message -ln "manipMinOffset" $manipGroup;
	// connectAttr ($minOffsetCurve+".message") ($manipGroup+".manipMinOffset");
	markObjectWithAttribute($minOffsetCurve,$manipGroup,"manipMinOffset");

	offsetCurve -ch on -rn false -cb 0 -st true -cl true -d 2 $curve;
	string $maxOffsetCurve = getSelectedObject( 0 );
	string $maxHistory[] = `listHistory -leaf true -levels 1 $maxOffsetCurve`;
	string $maxHistoryOffsets[] = `ls -type offsetCurve $maxHistory`;
	string $maxOffset = $maxHistoryOffsets[0];
	lockAndHideTransformAttributes( $maxOffsetCurve );

	// addAttr -at message -ln "manipMaxOffset" $manipGroup;
	// connectAttr ($maxOffsetCurve+".message") ($manipGroup+".manipMaxOffset");
	markObjectWithAttribute($maxOffsetCurve,$manipGroup,"manipMaxOffset");

	if( $axis == "u" )
	{
		connectAttr ($posi+".tangentU") ($minOffset+".normal");
		connectAttr ($posi+".tangentU") ($maxOffset+".normal");

		connectAttr ($manipGroup+".minDistance") ($minOffset+".distance");
		connectAttr ($manipGroup+".maxDistance") ($maxOffset+".distance");
		loft -ch 1 -u 1 -c 0 -ar 0 -d 3 -rn 0 -po 0 $maxOffsetCurve $minOffsetCurve;
		displaySmoothness -divisionsU 0 -divisionsV 3 -pointsWire 4 -pointsShaded 4;
	}
	else if( $axis == "v" )
	{
		connectAttr ($posi+".tangentV") ($minOffset+".normal");
		connectAttr ($posi+".tangentV") ($maxOffset+".normal");

		$expressionString += ($minOffset+".distance = -"+$manipGroup+".minDistance;\n");
		$expressionString += ($maxOffset+".distance = -"+$manipGroup+".maxDistance;\n");
		loft -ch 1 -u 1 -c 0 -ar 0 -d 3 -rn 0 -po 0 $minOffsetCurve $maxOffsetCurve;
		displaySmoothness -divisionsU 0 -divisionsV 3 -pointsWire 4 -pointsShaded 4;
	}
	else
	{
		//
		// I have no idea how to set the normal of the offsetCurve node
		// for this type of manipulator.
		//
	}

	expression -s $expressionString -alwaysEvaluate false -name "NormalSurfaceManipExpr#";

	string $loft = getSelectedObject( 0 );
	$loft = getSelectedObject( 0 );
	string $loftShape = getShapeFromObject( $loft, 0, 0 );
	lockAndHideTransformAttributes( $loft );
	// addAttr -at message -ln "manipLoft" $manipGroup;
	// connectAttr ($loft+".message") ($manipGroup+".manipLoft");
	markObjectWithAttribute($loft,$manipGroup,"manipLoft");

	string $ramp = createRampFromSurface( $loft, $resolutionU, $resolutionV, 1 );
	//
	// The RampResolutionPlane is the polygonal plane generated for the surface
	// to illustrate exactly which points on the surface are being sampled to
	// generate the ramp.
	//
	string $rampResPlane = getSelectedObject( 1 );
	markObjectWithAttribute($rampResPlane,$manipGroup,"manipResolutionPlane");
	// addAttr -at message -ln "manipRamp" $manipGroup;
	// connectAttr ($ramp+".message") ($manipGroup+".manipRamp");
	markObjectWithAttribute($ramp,$manipGroup,"manipRamp");
	// shadingNode -asShader lambert;
	// string $shader = getSelectedObject( 0 );
	// string $shadingGroup = `sets -renderable true -noSurfaceShader true -empty -name ($shader+"SG")`;
	// connectAttr ($shader+".outColor") ($shadingGroup+".surfaceShader");
	// defaultNavigation -connectToExisting -force true -source $ramp -destination $shadingGroup;
	// defaultNavigation -source $shadingGroup -destination ($loftShape+".instObjGroups[0]") -connectToExisting;

	// Add edge curve for strength ramp display.
	curveOnSurface -d 1 -uv 0 0 -uv 1 0 -k 0 -k 1 $loft;
	string $strengthCurve = getSelectedObject( 0 );
	lockAndHideTransformAttributes( $strengthCurve );
	// addAttr -at message -ln "manipEdgeCurve" $manipGroup;
	// connectAttr ($strengthCurve+".message") ($manipGroup+".manipEdgeCurve");
	markObjectWithAttribute($strengthCurve,$manipGroup,"manipEdgeCurve");

	connectAttr ($manipGroup+"."+$minValueString) ($strengthCurve+".cp[0].yValue");
	connectAttr ($manipGroup+"."+$minValueString) ($strengthCurve+".cp[1].yValue");

	parent $minOffsetCurve $manipGroup;
	parent $maxOffsetCurve $manipGroup;
	parent $rampResPlane $manipGroup;
	parent $loft $manipGroup;

	setAttr ($minOffsetCurve+".visibility") 0;
	setAttr ($maxOffsetCurve+".visibility") 0;
	setAttr ($minOffsetCurve+".template") 1;
	setAttr ($maxOffsetCurve+".template") 1;

	// Add edge curve for minDistance
	curveOnSurface -d 3 -uv 0 0 -uv 0 0.33333 -uv 0 0.66667 -uv 0 1 -k 0 -k 0 -k 0 -k 1 -k 1 -k 1 $loft;
	string $minCurve = getSelectedObject( 0 );
	lockAndHideTransformAttributes( $minCurve );

	connectAttr ($manipGroup+"."+$minValueString) ($minCurve+".cp[0].yValue");
	connectAttr ($manipGroup+"."+$maxValueString) ($minCurve+".cp[1].yValue");
	connectAttr ($manipGroup+"."+$maxValueString) ($minCurve+".cp[2].yValue");
	connectAttr ($manipGroup+"."+$maxValueString) ($minCurve+".cp[3].yValue");

	// Add edge curve for maxDistance
	curveOnSurface -d 3 -uv 1 0 -uv 1 0.33333 -uv 1 0.66667 -uv 1 1 -k 0 -k 0 -k 0 -k 1 -k 1 -k 1 $loft;
	string $maxCurve = getSelectedObject( 0 );
	lockAndHideTransformAttributes( $maxCurve );

	connectAttr ($manipGroup+"."+$minValueString) ($maxCurve+".cp[0].yValue");
	connectAttr ($manipGroup+"."+$maxValueString) ($maxCurve+".cp[1].yValue");
	connectAttr ($manipGroup+"."+$maxValueString) ($maxCurve+".cp[2].yValue");
	connectAttr ($manipGroup+"."+$maxValueString) ($maxCurve+".cp[3].yValue");

	string $newNodeList[] = `ls`;
	// addAttr -at message -ln "createdNodes" -multi -indexMatters false $manipGroup;
	//
	// Commenting this out because it takes longer for each new manip.
	//
	// addMarkingAttribute($manipGroup,"createdNodes",1);
	// markAllNewNodes( $oldNodeList, $newNodeList, ($manipGroup+".createdNodes") );
	//

	select $manipGroup;
	return $manipGroup;
}

global proc int isNormalSurfaceManip( string $object )
{
	if( `attributeQuery -exists -node $object "_normalSurfaceManip_"` == 1 )
		return 1;
	else
		return 0;
}

global proc int deleteNormalSurfaceManip( string $manip )
{
	if( isNormalSurfaceManip( $manip ) == 0 )
		return 0;

	// string $createdNodes[] = `listConnections -source true -destination false ($manip+".createdNodes")`;
	string $createdNodes[] = getMarkedObjects( $manip, "createdNodes" );
	if( size( $createdNodes ) > 0 )
	{
		delete $createdNodes;
	}

	return 1;
}

global proc string getLoftFromNormalSurfaceManip( string $manip )
{
	if( `attributeQuery -exists -node $manip "_normalSurfaceManip_"` == 1 )
	{
		// string $loft[] = `listConnections -source true -destination false ($manip+".manipLoft")`;
		string $loft[] = getMarkedObjects( $manip, "manipLoft" );
		if( size( $loft ) == 0 )
			return "";
		else
			return $loft[0];
	}

	return "";
}

global proc string getResolutionPlaneFromNormalSurfaceManip( string $manip )
{
	if( `attributeQuery -exists -node $manip "_normalSurfaceManip_"` == 1 )
	{
		// string $resPlane[] = `listConnections -source true -destination false ($manip+".manipResolutionPlane")`;
		string $resPlane[] = getMarkedObjects( $manip, "manipResolutionPlane" );
		if( size( $resPlane ) == 0 )
			return "";
		else
			return $resPlane[0];
	}

	return "";
}

global proc string getRampFromNormalSurfaceManip( string $manip )
{
	if( `attributeQuery -exists -node $manip "_normalSurfaceManip_"` == 1 )
	{
		// string $ramp[] = `listConnections -source true -destination false ($manip+".manipRamp")`;
		string $ramp[] = getMarkedObjects( $manip, "manipRamp" );
		if( size( $ramp ) == 0 )
			return "";
		else
			return $ramp[0];
	}

	return "";
}

global proc string getMinCurveFromNormalSurfaceManip( string $manip )
{
	if( `attributeQuery -exists -node $manip "_normalSurfaceManip_"` == 1 )
	{
		// string $curve[] = `listConnections -source true -destination false ($manip+".manipMinOffset")`;
		string $curve[] = getMarkedObjects( $manip, "manipMinOffset" );
		if( size( $curve ) == 0 )
			return "";
		else
			return $curve[0];
	}

	return "";
}

global proc string getMaxCurveFromNormalSurfaceManip( string $manip )
{
	if( `attributeQuery -exists -node $manip "_normalSurfaceManip_"` == 1 )
	{
		// string $curve[] = `listConnections -source true -destination false ($manip+".manipMaxOffset")`;
		string $curve[] = getMarkedObjects( $manip, "manipMaxOffset" );
		if( size( $curve ) == 0 )
			return "";
		else
			return $curve[0];
	}

	return "";
}

global proc string getEdgeCurveFromNormalSurfaceManip( string $manip )
{
	if( `attributeQuery -exists -node $manip "_normalSurfaceManip_"` == 1 )
	{
		// string $curve[] = `listConnections -source true -destination false ($manip+".manipEdgeCurve")`;
		string $curve[] = getMarkedObjects( $manip, "manipEdgeCurve" );
		if( size( $curve ) == 0 )
			return "";
		else
			return $curve[0];
	}

	return "";
}
