// Copyright (C) 1997-2014 Autodesk, Inc., and/or its licensors.
// All rights reserved.
//
// The coded instructions, statements, computer programs, and/or related
// material (collectively the "Data") in these files contain unpublished
// information proprietary to Autodesk, Inc. ("Autodesk") and/or its licensors,
// which is protected by U.S. and Canadian federal copyright law and by
// international treaties.
//
// The Data is provided for use exclusively by You. You have the right to use,
// modify, and incorporate this Data into other products for purposes authorized 
// by the Autodesk software license agreement, without fee.
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND. AUTODESK
// DOES NOT MAKE AND HEREBY DISCLAIMS ANY EXPRESS OR IMPLIED WARRANTIES
// INCLUDING, BUT NOT LIMITED TO, THE WARRANTIES OF NON-INFRINGEMENT,
// MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE, OR ARISING FROM A COURSE 
// OF DEALING, USAGE, OR TRADE PRACTICE. IN NO EVENT WILL AUTODESK AND/OR ITS
// LICENSORS BE LIABLE FOR ANY LOST REVENUES, DATA, OR PROFITS, OR SPECIAL,
// DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES, EVEN IF AUTODESK AND/OR ITS
// LICENSORS HAS BEEN ADVISED OF THE POSSIBILITY OR PROBABILITY OF SUCH DAMAGES.

//////////////////////////////////////////////////////////////////////////////
//	This file contains the MEL script to create the Paintable Attribute Menu
//////////////////////////////////////////////////////////////////////////////
global proc artAttrPaintMenu(
	string 	$parent
)
//
//	Description:
// 		Creates a menu that shows all the paintable attributes
// 
{
	if ( !(`popupMenu -exists $parent`) ) 
		return;

	// Get the name of the filter node.
	string $filterNode = "";

	string $tmp[];
	string $melArtAttrFilterLabel;
	if (`artAttrFilterLabel` == (uiRes("m_artAttrToolScript.kFilterAll"))) {
	    $melArtAttrFilterLabel = "Filter: all";
	} else {
		// I18N_TODO this value is localized though the logic
		// here implies that EN-only is expected.  Probably ok,
		// even if tokenize isn't MB-safe, as long as localized
		// string doesn't have a space embedded in a multibyte
		// character.
		//
	    $melArtAttrFilterLabel = `artAttrFilterLabel`;
	}
	 
	tokenize( $melArtAttrFilterLabel, " ", $tmp );
	if ( size($tmp) == 2 ) 
		if ( $tmp[1] != "all" )
			$filterNode = $tmp[1];
		
	// Get the list of all paintable attributes.
	string $artCommand = "artAttrCtx";

	string $cmd = "artAttrCtx -q -objattrArray " + `currentCtx`;
	string $paintAttr = `eval $cmd`;

	// Filter out the attributes which do not belong 
	// to the current filter selection.
	string $attributes[];
	if ( $filterNode != "" ) {
		tokenize( $paintAttr, " ", $attributes );

		// Recreate the paintAttr list taking into 
		// accout the filter node type. 
		$paintAttr = "";

		string $buffer[];
		int $size = size($attributes);
		int $i;
		for( $i = 0; $i < $size; $i++ ) {
			tokenize( $attributes[$i], ".", $buffer );	
			if ( $buffer[0] == $filterNode ) {
				$paintAttr = $paintAttr + " " + $attributes[$i];
			} 
		}
	} 

	//skip vertexColorRGB and vertexFaceColorRGB attrs as they cannot be painted
	// with Attribute paint tool till we support color painting.
	tokenize( $paintAttr, " ", $attributes );

	// Recreate the paintAttr list by removing vertex* attrs if they are present
	$paintAttr = "";

	string $buffer[];
	int $size = size($attributes);
	int $i;
	for( $i = 0; $i < $size; $i++ ) {
		tokenize( $attributes[$i], ".", $buffer );	
		if ( $buffer[2] != "vertexColorRGB" && $buffer[2] != "vertexFaceColorRGB" ) {
			$paintAttr = $paintAttr + " " + $attributes[$i];
		} 
	}

	popupMenu -e -dai $parent;
	setParent -menu $parent;

	// Create menu items from the paintable attribute list.
	string $excludeNodes[];
	artAttrCreateMenuItems( $parent, $paintAttr, $excludeNodes );
}
