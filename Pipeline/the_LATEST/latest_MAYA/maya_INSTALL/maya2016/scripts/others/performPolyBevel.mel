// Copyright (C) 1997-2014 Autodesk, Inc., and/or its licensors.
// All rights reserved.
//
// The coded instructions, statements, computer programs, and/or related
// material (collectively the "Data") in these files contain unpublished
// information proprietary to Autodesk, Inc. ("Autodesk") and/or its licensors,
// which is protected by U.S. and Canadian federal copyright law and by
// international treaties.
//
// The Data is provided for use exclusively by You. You have the right to use,
// modify, and incorporate this Data into other products for purposes authorized 
// by the Autodesk software license agreement, without fee.
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND. AUTODESK
// DOES NOT MAKE AND HEREBY DISCLAIMS ANY EXPRESS OR IMPLIED WARRANTIES
// INCLUDING, BUT NOT LIMITED TO, THE WARRANTIES OF NON-INFRINGEMENT,
// MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE, OR ARISING FROM A COURSE 
// OF DEALING, USAGE, OR TRADE PRACTICE. IN NO EVENT WILL AUTODESK AND/OR ITS
// LICENSORS BE LIABLE FOR ANY LOST REVENUES, DATA, OR PROFITS, OR SPECIAL,
// DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES, EVEN IF AUTODESK AND/OR ITS
// LICENSORS HAS BEEN ADVISED OF THE POSSIBILITY OR PROBABILITY OF SUCH DAMAGES.

//
//
//  Creation Date:  4 April 1997
//
//  Description:
//
//
//  Procedure Name:
//      performPolyBevel
//
//  Description:
//        perform a bevel of the selected polygon edges
//         
//  Input Arguments:
//        $option : Whether to set the options to default values.
//  Return Value:
//        command string iff $option==2
//

proc setOptionVars (int $forceFactorySettings)
{			   
	if ($forceFactorySettings || !`optionVar -exists polyBevelOffsetAsFraction`)
		optionVar -intValue polyBevelOffsetAsFraction 0; // fraction is default
	if ($forceFactorySettings || !`optionVar -exists polyBevelOffsetWorld`)
		optionVar -intValue polyBevelOffsetWorld 0; // world is default
    if ($forceFactorySettings || !`optionVar -exists polyBevelOffset`)
		optionVar -floatValue polyBevelOffset 0.5;
	if ($forceFactorySettings || !`optionVar -exists polyBevelRound`)
		optionVar -floatValue polyBevelRound 0.5;
	if ($forceFactorySettings || !`optionVar -exists polyBevelSegment`)
		optionVar -intValue polyBevelSegment 1;
	if ($forceFactorySettings || !`optionVar -exists polyBevelAutofit`)
		optionVar -intValue polyBevelAutofit 1;
	if ($forceFactorySettings || !`optionVar -exists polyBevelCompatibilityMode`)
		optionVar -intValue polyBevelCompatibilityMode 0; // new mode is default
	if ($forceFactorySettings || !`optionVar -exists polyBevelSmoothingAngle`)
		optionVar -intValue polyBevelSmoothingAngle 30;
}

global proc performPolyBevelSetup (string $parent, int $forceFactorySettings)
{
	setOptionVars($forceFactorySettings);
	setParent $parent;
     
	int $ival = `optionVar -query polyBevelOffsetAsFraction` + 1;
    radioButtonGrp -edit -select $ival polyBevelOffsetAsFraction;
	
	int $ival = `optionVar -query polyBevelOffsetWorld` + 1;
    radioButtonGrp -edit -select $ival polyBevelOffsetWorld;
	
	float $fval = `optionVar -query polyBevelOffset`;
	floatSliderGrp -edit -value $fval polyBevelOffset;
	
	$fval = `optionVar -query polyBevelRound`;
	floatSliderGrp -edit -value $fval polyBevelRound;
	
	$ival = `optionVar -query polyBevelSegment`;
     intSliderGrp -edit -value $ival polyBevelSegment;
	
	$ival = `optionVar -query polyBevelAutofit`;
    checkBoxGrp -edit -value1 $ival polyBevelAutofit;
	
	$ival = `optionVar -query polyBevelCompatibilityMode`;
    checkBoxGrp -edit -value1 $ival polyBevelCompatibilityMode;
	
	$fval = `optionVar -query polyBevelSmoothingAngle`;
	floatSliderGrp -edit -value $fval polyBevelSmoothingAngle;

	if (`checkBoxGrp -query -value1 polyBevelAutofit` == 1) {
		// disable roundness
		floatSliderGrp -e -en 0 polyBevelRound;
	} else {
		// enable roundness
		floatSliderGrp -e -en 1 polyBevelRound;
	}

	if (`radioButtonGrp -query -select polyBevelOffsetAsFraction` == 1) {
		// disable space selection
		radioButtonGrp -e -en 0 polyBevelOffsetWorld;
	} else {
		// enable space selection
		radioButtonGrp -e -en 1 polyBevelOffsetWorld;
	}
}

global proc performPolyBevelCallback (string $parent, int $doIt)
{
	setParent $parent;
	
	optionVar -intValue polyBevelOffsetAsFraction (`radioButtonGrp -query -select polyBevelOffsetAsFraction` - 1);
	optionVar -intValue polyBevelOffsetWorld (`radioButtonGrp -query -select polyBevelOffsetWorld` - 1);
	optionVar -floatValue polyBevelOffset `floatSliderGrp -query -value polyBevelOffset`;
	optionVar -floatValue polyBevelRound `floatSliderGrp -query -value polyBevelRound`;
	optionVar -intValue polyBevelSegment `intSliderGrp -query -value polyBevelSegment`;
	optionVar -intValue polyBevelAutofit `checkBoxGrp -query -value1 polyBevelAutofit`;
	optionVar -intValue polyBevelCompatibilityMode `checkBoxGrp -query -value1 polyBevelCompatibilityMode`;
	optionVar -floatValue polyBevelSmoothingAngle `floatSliderGrp -query -value polyBevelSmoothingAngle`;

	if (`checkBoxGrp -query -value1 polyBevelAutofit` == 1) {
		// disable roundness
		floatSliderGrp -e -en 0 polyBevelRound;
	} else {
		// enable roundness
		floatSliderGrp -e -en 1 polyBevelRound;
	}
	if (`radioButtonGrp -query -select polyBevelOffsetAsFraction` == 1) {
		// disable space selection
		radioButtonGrp -e -en 0 polyBevelOffsetWorld;
	} else {
		// enable space selection
		radioButtonGrp -e -en 1 polyBevelOffsetWorld;
	}
	if ($doIt) {
		performPolyBevel 0;
		addToRecentCommandQueue "performPolyBevel 0" "PolyBevel";
	}
}

proc polyBevelOptions ()
{
	// Global template variables for form spacing
	global int $gOptionBoxTemplateFrameSpacing;
	
	string $commandName = "performPolyBevel";
	string $callback = ($commandName + "Callback");
	string $setup = ($commandName + "Setup");
	   
	string $layout = getOptionBox();
	setParent $layout;
	setUITemplate -pushTemplate OptionBoxTemplate;
	waitCursor -state 1;
	
	// Form layout
	string $parent = `formLayout polyCutFaceOptions`;
	
		// Settings frame
		string $settingsFrame = 
		`frameLayout -label (uiRes("m_performPolyBevel.kSettingsFrame"))`;
	
			columnLayout;

			radioButtonGrp -nrb 2 -vr -label (uiRes("m_performPolyBevel.kOffsetType"))
				-l1 (uiRes("m_performPolyBevel.kOffsetType1"))
				-l2 (uiRes("m_performPolyBevel.kOffsetType2")) 
				-cc ($callback + " " + $parent + " " + 0) 
				polyBevelOffsetAsFraction;
			radioButtonGrp -nrb 2 -vr -label (uiRes("m_performPolyBevel.kOffsetSpace")) 
				-l1 (uiRes("m_performPolyBevel.kOffsetSpace1"))
				-l2 (uiRes("m_performPolyBevel.kOffsetSpace2"))
				-cc ($callback + " " + $parent + " " + 0)
				polyBevelOffsetWorld;

			floatSliderGrp -label (uiRes("m_performPolyBevel.kWidth")) -min 0 -max 1.0 -fmx 100.0 -cc ($callback + " " + $parent + " " + 0) polyBevelOffset;

			separator;

			intSliderGrp -label (uiRes("m_performPolyBevel.kSegments")) -min 1 -max 12 -fmx 100 -cc ($callback + " " + $parent + " " + 0) polyBevelSegment;
			floatSliderGrp -label (uiRes("m_performPolyBevel.kSmoothingAngle")) -min 0 -max 180 -fmn 0.0 -fmx 100.0 -cc ($callback + " " + $parent + " " + 0) polyBevelSmoothingAngle;

			checkBoxGrp 
				-label1 (uiRes("m_performPolyBevel.kAutoFit")) 
				-cc ($callback + " " + $parent + " " + 0) 
				polyBevelAutofit;
			floatSliderGrp -label (uiRes("m_performPolyBevel.kRoundness")) -min -0.5 -max 0.5 -fmn 0.0 -fmx 100.0 -cc ($callback + " " + $parent + " " + 0) polyBevelRound;

			separator;

			checkBoxGrp 
				-label1 (uiRes("m_performPolyBevel.kCompMode")) 
				-cc ($callback + " " + $parent + " " + 0) 
				polyBevelCompatibilityMode;

		setParent $parent;	
		
	setParent ..;

	// Attach frame to form layout
	formLayout -e
		-af $settingsFrame "top" $gOptionBoxTemplateFrameSpacing
		-af $settingsFrame "left" $gOptionBoxTemplateFrameSpacing
		-af $settingsFrame "right" $gOptionBoxTemplateFrameSpacing
		-an $settingsFrame "bottom"
	$parent;
	
	waitCursor -state 0;
	setUITemplate -popTemplate;
	   
	string $applyBtn = getOptionBoxApplyBtn();
	button -edit -label (uiRes("m_performPolyBevel.kBevelButton"))
	       -command ($callback + " " + $parent + " " + 1)
		$applyBtn;
	string $saveBtn = getOptionBoxSaveBtn();
	button -edit 
		-command ($callback + " " + $parent + " " + 0 + "; hideOptionBox")
		$saveBtn;
	string $resetBtn = getOptionBoxResetBtn();
	button -edit 
		-command ($setup + " " + $parent + " " + 1)
		$resetBtn;
			 
	setOptionBoxTitle( (uiRes("m_performPolyBevel.kBevelOptions")) );

	setOptionBoxHelpTag( "PolygonsBevel" );

	eval (($setup + " " + $parent + " " + 0));      
	showOptionBox();
}

global proc string performPolyBevel (int $option)
{
	string $cmd="";
	string $sel[];
	switch ($option) {
	case 3:
		// in this mode, bevel should only operate on selection boundary if only faces are selected
		string $faces[] = `polyListComponentConversion -fromFace -toFace`;
		string $edges[] = `polyListComponentConversion -fromEdge -toEdge`;

		if ( size($faces) > 0 && size($edges) == 0 ) {
			string $borderEdges[];
			string $containedFaces[];
			convertToSelectionBorder(-1, false, $borderEdges, $containedFaces);
			if (0 < size($borderEdges)) {
    			select $borderEdges;
			}
		}

	case 0:
		setOptionVars(false);
		int $asFraction = (0 == `optionVar -query polyBevelOffsetAsFraction`);
		int $world = (0 == `optionVar -query polyBevelOffsetWorld`);
		float $dist = `optionVar -query polyBevelOffset`;
		int $sg = `optionVar -query polyBevelSegment`;
		int $ival = `optionVar -query polyBevelAutofit`;
		int $comp = `optionVar -query polyBevelCompatibilityMode`;
		float $smoothingAngle = `optionVar -query polyBevelSmoothingAngle`;

		$cmd=("polyBevel3");
		if ($asFraction)
			$cmd=($cmd + " -fraction " + $dist);
		else
			$cmd=($cmd + " -offset " + $dist);
		$cmd=($cmd + " -offsetAsFraction " + $asFraction + " -autoFit " + $ival);
		if (!$ival) {
			float $fv2 = `optionVar -query polyBevelRound`;
			$cmd=($cmd + " -roundness " + $fv2);
		}
		$cmd = ($cmd + " -segments " + $sg + " -worldSpace " + $world + " -smoothingAngle " + $smoothingAngle);

		// hardcode the cleanup options - they can be set in the AE/channel box if needed
		$cmd = ($cmd + " -fillNgons 1 -mergeVertices 1 -mergeVertexTolerance 0.0001 -miteringAngle 180 -angleTolerance 180");

		polyPerformAction $cmd e 0;

		// make sure node is selected when there is history
		if ( 0 != size(`ls -sl`) || (0 != size(`ls -hl`)) ) {
			string $tmp[] = `listHistory`;
			string $totalSel[];
			for ($opNode in $tmp) {
				if (`nodeType $opNode` == "polyBevel3") {
					$totalSel[size($totalSel)] = $opNode;
				}
			}
			
 			if (size($totalSel) > 0) 
 				select -add $totalSel[0];
		}

		setToolTo ShowManips;
		break;

	case 1: polyBevelOptions; break;
	default:
		setOptionVars(false);
		int $asFraction = (0 == `optionVar -query polyBevelOffsetAsFraction`);
		int $world = (0 == `optionVar -query polyBevelOffsetWorld`);
		float $dist = `optionVar -query polyBevelOffset`;
		int $sg = `optionVar -query polyBevelSegment`;
		int $ival = `optionVar -query polyBevelAutofit`;
		float $smoothingAngle = `optionVar -query polyBevelSmoothingAngle`;
		$cmd=("polyBevel3 -offset " + $dist + " -offsetAsFraction " + $asFraction + " -autoFit " + $ival);
		if (!$ival) {
			float $fv2 = `optionVar -query polyBevelRound`;
			$cmd=($cmd + " -roundness " + $fv2);
		}
		$cmd = ($cmd + " -segments " + $sg + " -worldSpace " + $world + " -smoothingAngle " + $smoothingAngle);

		// hardcode the cleanup options - they can be set in the AE/channel box if needed
		$cmd = ($cmd + " -fillNgons 1 -mergeVertices 1 -mergeVertexTolerance 0.0001 -miteringAngle 180 -angleTolerance 180");

		$cmd = ("polyPerformAction \"" + $cmd + "\" e 0");
	}
	return $cmd;
}
