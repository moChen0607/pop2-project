// Copyright (C) 1997-2014 Autodesk, Inc., and/or its licensors.
// All rights reserved.
//
// The coded instructions, statements, computer programs, and/or related
// material (collectively the "Data") in these files contain unpublished
// information proprietary to Autodesk, Inc. ("Autodesk") and/or its licensors,
// which is protected by U.S. and Canadian federal copyright law and by
// international treaties.
//
// The Data is provided for use exclusively by You. You have the right to use,
// modify, and incorporate this Data into other products for purposes authorized 
// by the Autodesk software license agreement, without fee.
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND. AUTODESK
// DOES NOT MAKE AND HEREBY DISCLAIMS ANY EXPRESS OR IMPLIED WARRANTIES
// INCLUDING, BUT NOT LIMITED TO, THE WARRANTIES OF NON-INFRINGEMENT,
// MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE, OR ARISING FROM A COURSE 
// OF DEALING, USAGE, OR TRADE PRACTICE. IN NO EVENT WILL AUTODESK AND/OR ITS
// LICENSORS BE LIABLE FOR ANY LOST REVENUES, DATA, OR PROFITS, OR SPECIAL,
// DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES, EVEN IF AUTODESK AND/OR ITS
// LICENSORS HAS BEEN ADVISED OF THE POSSIBILITY OR PROBABILITY OF SUCH DAMAGES.

//
// Procedure: performHwConvert
// Description:
//		Run the hardware renderer on the current scene.
//		Bernard Kwok
// Usage:
//		performHwConvert 1; // for interactive UI
//		performHwConvert 0; // to run using last settings
// Defaults:
//		- render all geometry
//		- render using high quality lighting
//		- render with a default light if none
//		- texture and shadow map resolutions default to 128x128
//
proc setOptionVars (int $forceFactorySettings)
{			   
     if ($forceFactorySettings || !`optionVar -exists hwConvertInteractiveWindow`)
		optionVar -intValue hwConvertInteractiveWindow 1;

	 if ($forceFactorySettings || !`optionVar -exists hwConvertAllGeometry`)
        optionVar -intValue hwConvertAllGeometry 1;

	 if ($forceFactorySettings || !`optionVar -exists hwConvertFragmentLight`)
        optionVar -intValue hwConvertFragmentLight 1;
	 if ($forceFactorySettings || !`optionVar -exists hwConvertDefaultLight`)
        optionVar -intValue hwConvertDefaultLight 1;

     if ($forceFactorySettings || !`optionVar -exists hwConvertTextures`)
		optionVar -intValue hwConvertTextures 1;
	 if ($forceFactorySettings || !`optionVar -exists hwConvertTextureResolution`)
        optionVar -floatValue hwConvertTextureResolution 128.0;

	 if ($forceFactorySettings || !`optionVar -exists hwConvertShadows`)
        optionVar -intValue hwConvertShadows 1;
	 if ($forceFactorySettings || !`optionVar -exists hwConvertShadowResolution`)
        optionVar -floatValue hwConvertShadowResolution 128.0;
}

global proc performHWConvertSetup (string $parent, int $forceFactorySettings)
{
	setOptionVars($forceFactorySettings);
	setParent $parent;

	int $ival;
	float $fval;
	float $vals[];

	// All or selected geometry
	$ival = `optionVar -query hwConvertAllGeometry`;
	checkBoxGrp -edit -value1 $ival hwConvertAllGeometry;


	// Interactive window
	$ival = `optionVar -query hwConvertInteractiveWindow`;
	checkBoxGrp -edit -value1 $ival hwConvertInteractiveWindow;

	// Fragment lighting
	$ival = `optionVar -query hwConvertFragmentLight`;
	checkBoxGrp -edit -value1 $ival hwConvertFragmentLight;

	// Use default light
	$ival = `optionVar -query hwConvertDefaultLight`;
	checkBoxGrp -edit -value1 $ival hwConvertDefaultLight;	

	// Convert textures
	$ival = `optionVar -query hwConvertTextures`;
	checkBoxGrp -edit -value1 $ival hwConvertTextures;
	if ($ival)
	{
		disable -v false hwConvertTextureResolution;
	}
	else
	{
		disable hwConvertTextureResolution;
	}
	$fval = `optionVar -query hwConvertTextureResolution`;
	floatFieldGrp -edit -value1 $fval hwConvertTextureResolution;
	
	// Export shadows
	$ival = `optionVar -query hwConvertShadows`;
	checkBoxGrp -edit -value1 $ival hwConvertShadows;
	if ($ival)
	{
		disable -v false hwConvertShadowResolution;
	}
	else
	{
		disable hwConvertShadowResolution;
	}
	$fval = `optionVar -query hwConvertShadowResolution`;
	floatFieldGrp -edit -value1 $fval hwConvertShadowResolution;

}

global proc performHWConvertCallback (string $parent, int $doIt)
{
	setParent $parent;

	optionVar -intValue hwConvertAllGeometry
		`checkBoxGrp -query -value1 hwConvertAllGeometry`;
	
	optionVar -intValue hwConvertInteractiveWindow
		`checkBoxGrp -query -value1 hwConvertInteractiveWindow`;

	optionVar -intValue hwConvertFragmentLight
		`checkBoxGrp -query -value1 hwConvertFragmentLight`;

	optionVar -intValue hwConvertDefaultLight
		`checkBoxGrp -query -value1 hwConvertDefaultLight`;

	optionVar -intValue hwConvertTextures
		`checkBoxGrp -query -value1 hwConvertTextures`;
	if (`checkBoxGrp -query -value1 hwConvertTextures`)
	{
		disable -v false hwConvertTextureResolution;
	}
	else
	{
		disable hwConvertTextureResolution;
	}
	optionVar -floatValue hwConvertTextureResolution
		`floatFieldGrp -query -value1 hwConvertTextureResolution`;

	optionVar -intValue hwConvertShadows
		`checkBoxGrp -query -value1 hwConvertShadows`;
	if (`checkBoxGrp -query -value1 hwConvertShadows`)
	{
		disable -v false hwConvertShadowResolution;
	}
	else
	{
		disable hwConvertShadowResolution;
	}
	optionVar -floatValue hwConvertShadowResolution
		`floatFieldGrp -query -value1 hwConvertShadowResolution`;

	if ($doIt) {
		performHWConvert 0;
		addToRecentCommandQueue "performHWConvert 0" "HWConvert";
	}
}

proc hwConvertOptions()
{
	// Global from setDefaultTemplates.mel
	global int $kSingleWidgetWidthIndex;
	int $minMaxWidth = ($kSingleWidgetWidthIndex * 3) / 4;

	string $commandName = "performHWConvert";
	string $callback = ($commandName + "Callback");
	string $setup = ($commandName + "Setup");
	   
	string $layout = getOptionBox();
	setParent $layout;
	setUITemplate -pushTemplate DefaultTemplate;
	waitCursor -state 1;
	
	scrollLayout -hst 0;
	string $parent = `columnLayout -adjustableColumn 1`;

	//////////////////////////////////////////////////////////////////////

	frameLayout -label "General Options"
		-cl false -cll false;
	columnLayout;

	// Convert all geometry (versus just selected)
	checkBoxGrp -label1 "Convert All Geometry" hwConvertAllGeometry;

	// Display interactive window
	checkBoxGrp -label1 "Interactive Window Display" hwConvertInteractiveWindow;

	// Fragment lighting
	checkBoxGrp -label1 "High Quality Rendering" hwConvertFragmentLight;

	// Fragment lighting
	checkBoxGrp -label1 "Default Lighting" hwConvertDefaultLight;

	setParent $parent;
	//////////////////////////////////////////////////////////////////////

	frameLayout -label "Texture Options"
		-cl false -cll false;
	columnLayout;

	// Export textures
	checkBoxGrp -label1 "Display Material Textures" 
		-on1 ("disable -v false hwConvertTextureResolution")
		-of1 ("disable hwConvertTextureResolution;")
		hwConvertTextures;
	// Texture resolution
	floatFieldGrp -label "Material Texture Resolution" -numberOfFields 1
		-precision 0
		hwConvertTextureResolution;		
	
	// Export Shadows
	checkBoxGrp -label1 "Display Shadows" 
		-on1 ("disable -v false hwConvertShadowResolution;")
		-of1 ("disable hwConvertShadowResolution;")
		hwConvertShadows;
	// Shadow resolution
	floatFieldGrp -label "Shadow Map Resolution" -numberOfFields 1
		-precision 0
		hwConvertShadowResolution;

	setParent $parent;

	//////////////////////////////////////////////////////////////////////

	waitCursor -state 0;
	setUITemplate -popTemplate;
	   
	string $applyBtn = getOptionBoxApplyBtn();
	button -edit -label "Render"
	       -command ($callback + " " + $parent + " " + 1)
		$applyBtn;

	string $saveBtn = getOptionBoxSaveBtn();
	button -edit 
		-command ($callback + " " + $parent + " " + 0 + "; hideOptionBox")
		$saveBtn;

	string $resetBtn = getOptionBoxResetBtn();
	button -edit 
		-command ($setup + " " + $parent + " " + 1)
		$resetBtn;
			 
	setOptionBoxTitle("Hardware Renderer Options");

	//	Customize the 'Help' menu item text.
	//
	setOptionBoxHelpTag( "HWRenderer" );

	eval (($setup + " " + $parent + " " + 0));      
	showOptionBox();
}

global proc string performHWConvert (int $option)
{
	string $cmd="";
	string $sel[];
	switch ($option) {

	  case 1: hwConvertOptions; 
		// Just the option box
		break;
		
	  default:
		setOptionVars(false);
		int $allGeometry = `optionVar -query hwConvertAllGeometry`;
		int $interactive = `optionVar -query hwConvertInteractiveWindow`;
		int $fragLight = `optionVar -query hwConvertFragmentLight`;
		int $defaultLight = `optionVar -query hwConvertDefaultLight`;
		int $textures = `optionVar -query hwConvertTextures`;
		float $texRes = `optionVar -query hwConvertTextureResolution`;
		int $shadows = `optionVar -query hwConvertShadows`;
		float $shadowRes = `optionVar -query hwConvertShadowResolution`;

		if ($texRes < 64)
			$texRes = 64;
		if ($shadowRes < 64)
			$shadowRes = 64;

		if ($allGeometry)
		{
			$cmd = "select -r (`ls -type mesh`);";
		}

		$cmd = ($cmd + "polyHwConvert ");

		// Interactive window
		if ($interactive)
			$cmd = ($cmd + " -iw");

		// Fragment lighting
		if ($fragLight)
			$cmd = ($cmd + " -hql");

		// Default lighting
		if ($defaultLight)
			$cmd = ($cmd + " -dfl");

		// Textures
		if ($textures)
		{
			$cmd = ($cmd + " -et -res " + $texRes);
		}

		// To add when shadows available !!
		//if ($shadows)
		//{
		//}

		$cmd = ($cmd + ";");
			
		// Do the command	
		if ($option == 0)
			evalEcho $cmd;
		break;
	}
	return $cmd;
}


