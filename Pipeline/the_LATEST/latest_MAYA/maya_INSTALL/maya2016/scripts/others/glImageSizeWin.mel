// Copyright (C) 1997-2014 Autodesk, Inc., and/or its licensors.
// All rights reserved.
//
// The coded instructions, statements, computer programs, and/or related
// material (collectively the "Data") in these files contain unpublished
// information proprietary to Autodesk, Inc. ("Autodesk") and/or its licensors,
// which is protected by U.S. and Canadian federal copyright law and by
// international treaties.
//
// The Data is provided for use exclusively by You. You have the right to use,
// modify, and incorporate this Data into other products for purposes authorized 
// by the Autodesk software license agreement, without fee.
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND. AUTODESK
// DOES NOT MAKE AND HEREBY DISCLAIMS ANY EXPRESS OR IMPLIED WARRANTIES
// INCLUDING, BUT NOT LIMITED TO, THE WARRANTIES OF NON-INFRINGEMENT,
// MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE, OR ARISING FROM A COURSE 
// OF DEALING, USAGE, OR TRADE PRACTICE. IN NO EVENT WILL AUTODESK AND/OR ITS
// LICENSORS BE LIABLE FOR ANY LOST REVENUES, DATA, OR PROFITS, OR SPECIAL,
// DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES, EVEN IF AUTODESK AND/OR ITS
// LICENSORS HAS BEEN ADVISED OF THE POSSIBILITY OR PROBABILITY OF SUCH DAMAGES.

//
//
//  Creation Date:  21 June 1996
//
//  Description:
//  	Dialog for user to choose image render size.
//
//	Contents
//		okayRS			Okay button callback.
//		createWinRS		Create the window and controls.
//		registerRS		Register all the callbacks.
//		glImageSizeWin	Main entry point. Create and post dialog.
//



//  ========== okayRS ==========
//
//  SYNOPSIS
//		Okay button callback. Get the selected list item and 
//		set the new image size in the resolution attribute of 
//		the hwRenderGlobals node. A script job will make
//		sure the hardware render window is resized.
//

global proc  okayRS( string $win )
{

	// Dismiss the dialog.
	//
	setParent $win;
	window -e -vis 0 $win;


	// Get the name of the hardware render globals node.
	//
	string  $hwNodesAry[] = `ls -type hwRenderGlobals`;
	int		$hwNodesCnt = size( $hwNodesAry );

	if ($hwNodesCnt == 0) return;


	// Store new value in hardware render globals node. Make a new
	// string value with the extra spaces removed.
	//
	string  $item[] = `textScrollList -q -si xNtList`;
	string	$words[];
	tokenize( $item[0], $words );
	string	$value = $words[0]+" "+$words[1]+" "+$words[2]+" "+$words[3];

	for ($i = 0; $i < $hwNodesCnt; $i++)
	{
		setAttr -type "string" ($hwNodesAry[$i]+".resolution") $value;
	}


}  // okayRS //



//  ========== createRS ==========
//
//  SYNOPSIS
//		Create the window and all the controls.
//

proc  createWinRS( string $win )
{

	window 
		-title (uiRes("m_glImageSizeWin.kImageSize"))
		-minimizeButton false 
		-maximizeButton false 
		-width 230 
		-height 250 
		-retain 
		$win;

	formLayout -nd 100 workLyt;


	// Create user controls.
	//
	button -l (uiRes("m_glImageSizeWin.kOkButton")) -w 100 -h 26 xNtOkB;
	formLayout -e 
		-ap xNtOkB left -50 25 
		-af xNtOkB bottom 4 
		($win+"|workLyt");

	button -l (uiRes("m_glImageSizeWin.kCancelButton")) -w 100 -h 26 xNtCancelB;
	formLayout -e 
		-ap xNtCancelB left -50 75 
		-af xNtCancelB bottom 4 
		($win+"|workLyt");

	textScrollList -font "fixedWidthFont" -allowMultiSelection false xNtList;
	formLayout -e 
		-af xNtList left 4 
		-af xNtList top 4 
		-af xNtList right 4 
		-ac xNtList bottom 8 xNtCancelB
		($win+"|workLyt");


	// Add the image formats from the file imageFormats.mel.
	//
	global string	$gImageFormatData[];
	global string	$gPLEImageFormatData[];
	global int		$gImageFormatDividerPosition;

	int $isMayaEvalVersion = `about -ev`;
	if ( $isMayaEvalVersion ) {
		$gImageFormatData = $gPLEImageFormatData;
	}

	for ($i = 0; $i < size( $gImageFormatData ); $i++)
	{
		if( $i != $gImageFormatDividerPosition ){
			textScrollList -e -a $gImageFormatData[$i] xNtList;
		}
	}

	// Add the image formats from the file userImageFormats.mel.
	//
	global string	$gUserImageFormatData[];

	for ($i = 0; $i < size( $gUserImageFormatData ); $i++)
	{
	    if( $isMayaEvalVersion ) {
		int $kPLEMaxX = 1024;
		int $kPLEMaxY =  768;
		string $words[];
		tokenize($gUserImageFormatData[$i], $words);
		int $intValue;
		$intValue = $words[1];
		if( $intValue > $kPLEMaxX ) continue;
		$intValue = $words[2];
		if( $intValue > $kPLEMaxY ) continue;
	    }

	    textScrollList -e -a $gUserImageFormatData[$i] xNtList;
	}


}  // createWinRS //



//  ========== registerRS ==========
//
//  SYNOPSIS
//		Register the callbacks.
//

proc  registerRS( string $win )
{

	setParent $win;

	button -e -c ("okayRS " +$win) xNtOkB;
	button -e -c ("window -e -vis 0 " +$win) xNtCancelB;


}  // registerRS //



//  ========== glImageSizeWin ==========
//
//  SYNOPSIS
//		Create and show the add attribute dialog.
//

global proc int  glImageSizeWin() 
{
	string	$win = "glImageSizeWin";
	global string	$gImageFormatData[];
	global string	$gUserImageFormatData[];

	if ( ! `window -exists $win`)
	{
		if (size($gImageFormatData) == 0) {
			eval("source imageFormats");
		}
		//
		// If the user wants to add their own custom formats,
		// they can do so by putting them in userImageFormats.mel.
		// We do not encourage changes to imageFormats.mel, which
		// contains the built-in formats.
		//
		if (exists("userImageFormats.mel")
				&& size($gUserImageFormatData) == 0) {
			// Yes, we need the eval here, to avoid doing the source
			// until we know whether the file actually exists
			eval("source userImageFormats.mel");
		}
		createWinRS( $win );
		registerRS( $win );
	}

	showWindow( $win );
	return( 1 );

}  // glImageSizeWin //
