// Copyright (C) 1997-2014 Autodesk, Inc., and/or its licensors.
// All rights reserved.
//
// The coded instructions, statements, computer programs, and/or related
// material (collectively the "Data") in these files contain unpublished
// information proprietary to Autodesk, Inc. ("Autodesk") and/or its licensors,
// which is protected by U.S. and Canadian federal copyright law and by
// international treaties.
//
// The Data is provided for use exclusively by You. You have the right to use,
// modify, and incorporate this Data into other products for purposes authorized 
// by the Autodesk software license agreement, without fee.
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND. AUTODESK
// DOES NOT MAKE AND HEREBY DISCLAIMS ANY EXPRESS OR IMPLIED WARRANTIES
// INCLUDING, BUT NOT LIMITED TO, THE WARRANTIES OF NON-INFRINGEMENT,
// MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE, OR ARISING FROM A COURSE 
// OF DEALING, USAGE, OR TRADE PRACTICE. IN NO EVENT WILL AUTODESK AND/OR ITS
// LICENSORS BE LIABLE FOR ANY LOST REVENUES, DATA, OR PROFITS, OR SPECIAL,
// DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES, EVEN IF AUTODESK AND/OR ITS
// LICENSORS HAS BEEN ADVISED OF THE POSSIBILITY OR PROBABILITY OF SUCH DAMAGES.

//
//<doc>
//<name containerAssignTemplate>
//<synopsis>
//		containerAssignTemplate
//
//<returns>
//		None
//
//<description>
//      This script assigns a template to the specified container and
//      performs the related operations such as auto-bind and publishing
//      attributes.
//
//<flags>
//		string $container, the container to use, or "" to use selected
//		string $template, template to assign, or "" to use the existing template
//		int $autoBind, whether to autobind after template is assigned.
//		int $doStandins, whether to create dynamic attributes as stand-ins for unbound template attributes
//
//<examples>
//	// assign the specified template to dogContainer, and auto-bind
//	containerAssignTemplate(mimiContainer, "poodle", 1, 0);
//
//</doc>
//
global proc publishMissingNames( string $editedContainer,
								 string $templateAttrs[] )
//
//	Description:
//		Given the edited container's name, and the published attributes of the
//		associated template, publish any missing name.
//
//	Inputs:
//		$editedContainer	: Name of edited container
//		$templateAttrs		: Name(s) of published attrs in template
//
//	Return Value:
//		None.
//
{
	string $publishedNames[] = `container -q -publishName $editedContainer`;
	string $containerAttrs[] = `listAttr $editedContainer`;
	int $numNames = size($templateAttrs);
	int $index;
	while( $index < $numNames ){
		string $name = $templateAttrs[$index];
		if( !stringArrayContains( $name, $publishedNames ) &&
			!stringArrayContains( $name, $containerAttrs )) {
			container -e -publishName $name $editedContainer;
		}
		$index++;
	}
}

global proc
containerAssignTemplate(string $container, string $templateName,
						int $autoBind, int $doStandins)
{
	global string $gPinnedContainerForTemplateAssign; 
	if ($container == "") {
		if (size($gPinnedContainerForTemplateAssign) &&
			`objExists $gPinnedContainerForTemplateAssign`) {
			$container = $gPinnedContainerForTemplateAssign;
			$gPinnedContainerForTemplateAssign = "";
		} else {
			string $sel[] = `ls -sl -containers`;
			if (size($sel) > 0) {
				$container = $sel[0];
			} else {
				$sel = `ls -sl`;
				$container = `container -q -findContainer $sel`;
				if (size($container) == 0) {
					error((uiRes("m_containerAssignTemplate.kMustSelectContainer")));
				}
			}
		}
	}

	string $templatePath;
	if ($templateName == "") {
		$templateName = `getAttr ($container+".templateName")`;
		$templatePath = `getAttr ($container+".templatePath")`;
		if (size($templateName) == 0) {
			error((uiRes("m_containerAssignTemplate.kMustSpecifyTemplateName")));
		}
	}

	if (! `containerTemplate -exists $templateName`) {
		containerTemplate -load -fn $templatePath $templateName;
	}
	
    // Set template name value
	setAttr -type "string" ($container + ".templateName") $templateName;
	$templatePath = `containerTemplate -q -fn $templateName`;
    setAttr -type "string" ($container + ".templatePath") $templatePath;

	string $templateAttrs[] = `containerTemplate -q -al $templateName`;
	publishMissingNames($container,$templateAttrs);

	// do auto-bind
    if ($autoBind)
    {
        // When assigning a new template, autobind will
        // completely refresh the bindings
        // i.e. allNames and force options are both set to true
        containerAutobind($container, "", 1, 1);
	}

	if ($doStandins) {
		containerPublish -bindTemplateStandins $container;
	}
}
