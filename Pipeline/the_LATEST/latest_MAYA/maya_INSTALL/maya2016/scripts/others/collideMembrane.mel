// Copyright (C) 1997-2014 Autodesk, Inc., and/or its licensors.
// All rights reserved.
//
// The coded instructions, statements, computer programs, and/or related
// material (collectively the "Data") in these files contain unpublished
// information proprietary to Autodesk, Inc. ("Autodesk") and/or its licensors,
// which is protected by U.S. and Canadian federal copyright law and by
// international treaties.
//
// The Data is provided for use exclusively by You. You have the right to use,
// modify, and incorporate this Data into other products for purposes authorized 
// by the Autodesk software license agreement, without fee.
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND. AUTODESK
// DOES NOT MAKE AND HEREBY DISCLAIMS ANY EXPRESS OR IMPLIED WARRANTIES
// INCLUDING, BUT NOT LIMITED TO, THE WARRANTIES OF NON-INFRINGEMENT,
// MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE, OR ARISING FROM A COURSE 
// OF DEALING, USAGE, OR TRADE PRACTICE. IN NO EVENT WILL AUTODESK AND/OR ITS
// LICENSORS BE LIABLE FOR ANY LOST REVENUES, DATA, OR PROFITS, OR SPECIAL,
// DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES, EVEN IF AUTODESK AND/OR ITS
// LICENSORS HAS BEEN ADVISED OF THE POSSIBILITY OR PROBABILITY OF SUCH DAMAGES.

proc setupCollideMembrane( string $membrane, string $meshes[] )
{
	int $numMeshes = size( $meshes );
	string $collideIn = ($membrane + ".collideMesh");
	string $inPlug = `connectionInfo -sfd $collideIn`;
	if( $inPlug != "" ){
		string $con[] = `listConnections $collideIn`;
		string $inNode = $con[0];
		disconnectAttr $inPlug $collideIn;
		if( nodeType($inNode) == "polyUnite"){
			delete $inNode;
		}
	}
	if( $numMeshes == 1 ){
		connectAttr ($meshes[0] + ".worldMesh[0]") $collideIn;
	} else if( $numMeshes > 1 ){
		string $unite = `createNode polyUnite`;
		for( $i = 0; $i < $numMeshes; $i++ ){
			string $mesh = $meshes[$i];
			connectAttr ($mesh + ".outMesh") ($unite + ".inputPoly["+$i+"]");
			connectAttr ($mesh + ".worldMatrix[0]") ($unite + ".inputMat["+$i+"]");
		}
		connectAttr ($unite + ".output") $collideIn;		
	}
}

global proc collideMembrane()
{
	string $membranes[], $meshes[];
	string $allMeshes[] = `ls -sl -ni -dag -type mesh`;
	int $numMeshes = 0;
	int $numMembranes = 0;

	string $mesh;
	for( $mesh in $allMeshes ){
		string $membrane = `findTypeInHistory $mesh "membrane" 0 1`;
		if( $membrane == "" ){
			$meshes[$numMeshes] = $mesh;
			$numMeshes++;
		} else {
			$membranes[$numMembranes] = $membrane;
			$numMembranes++;
		}
	}

	if( $numMembranes < 1 ){
		warning( (uiRes("m_collideMembrane.kNoMembrane")));
		return;
	}
	for( $i = 0; $i < $numMembranes; $i++ ){
		setupCollideMembrane( $membranes[$i], $meshes );
	}
}
