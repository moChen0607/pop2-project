// Copyright (C) 1997-2014 Autodesk, Inc., and/or its licensors.
// All rights reserved.
//
// The coded instructions, statements, computer programs, and/or related
// material (collectively the "Data") in these files contain unpublished
// information proprietary to Autodesk, Inc. ("Autodesk") and/or its licensors,
// which is protected by U.S. and Canadian federal copyright law and by
// international treaties.
//
// The Data is provided for use exclusively by You. You have the right to use,
// modify, and incorporate this Data into other products for purposes authorized 
// by the Autodesk software license agreement, without fee.
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND. AUTODESK
// DOES NOT MAKE AND HEREBY DISCLAIMS ANY EXPRESS OR IMPLIED WARRANTIES
// INCLUDING, BUT NOT LIMITED TO, THE WARRANTIES OF NON-INFRINGEMENT,
// MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE, OR ARISING FROM A COURSE 
// OF DEALING, USAGE, OR TRADE PRACTICE. IN NO EVENT WILL AUTODESK AND/OR ITS
// LICENSORS BE LIABLE FOR ANY LOST REVENUES, DATA, OR PROFITS, OR SPECIAL,
// DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES, EVEN IF AUTODESK AND/OR ITS
// LICENSORS HAS BEEN ADVISED OF THE POSSIBILITY OR PROBABILITY OF SUCH DAMAGES.

//
//
//  Creation Date:  Mar 20, 1997
//
//  Description:
//      The intersectPreset() procedure executes a intersect operation on 
//      a pair of surfaces based on the intersect option vars. In general if
//		you have n surfaces selected, (n-1) surface intersect operations would 
//		be carried out.
//
//  Input Arguments:
//      None.
//
//  Return Value:
//      None.
//

proc string pieceTogetherACmd(
	int $cosOnlyOnFirstSurface,
	int $cosAs2D,
	int $history,
    float $tol )
//
//	Description :
//		piece together an intersect command.
//
{
	string $cmd;
	$cmd = "intersect " ;

	// construction history.
	//
	$cmd = $cmd + " -ch " ;

	if( $history == 1 ) {
		$cmd = $cmd + "true" ;
	} else {
		$cmd = $cmd + "false" ;
	}

	$cmd = $cmd + " -fs " ;
	$cmd = $cmd + $cosOnlyOnFirstSurface ;

	$cmd = $cmd + " -cos " ;
	$cmd = $cmd + $cosAs2D ;

	$cmd = $cmd + " -tol " + $tol ;

	return $cmd ;

}

global proc intersectPreset(
 int $cosOnlyOnFirstSurface,
 int $cosAs2D,
 int $history,
 float $tol )
//
//	Intersect with the preset options.
//	Use this proc when operation dragged to Shelf.
//
{
	string $cmd ;
	$cmd = pieceTogetherACmd( $cosOnlyOnFirstSurface, $cosAs2D, $history, $tol ) ;

	int $nitems = 2 ;
	$cmd = appendToCmdPlaceHoldersForSelectionItems($cmd,$nitems) ;

	// Get the list of nurbs surfaces selected.
	//
	global int $gSelectNurbsSurfacesBit;
	string $surfaceList[] = `filterExpand -ex true -sm $gSelectNurbsSurfacesBit`;
	int $i ;

	int $surfaceCount = size($surfaceList) ;
	if( $surfaceCount < 2 ) {
	   error (uiRes("m_intersectPreset.kIntersectSurfInvalSelection")); 
	} else {
		// all (n-1) combinations
		//
		string $intersectResults[] ;
		int $nr = size($intersectResults) ;
		for( $i = 0 ; $i < $surfaceCount-1 ; $i++ ) {
			string $surfacePair[2] ;
			$surfacePair[0] = $surfaceList[$i] ;
			$surfacePair[1] = $surfaceList[$surfaceCount-1] ;
			string $results[] = executeCmdOnItems( $cmd, $surfacePair );	
			$intersectResults = stringArrayCatenate( $intersectResults, $results ) ;
		} // for $i	

		// select the results.
		//
		int $resultCount = size($intersectResults) ;

		if( $resultCount > 0 ) {
			string $selectString;
        	$selectString = "select -r";

			// select all results to begin with
			//
			$resultCount = size($intersectResults) ;
			for( $i = 0 ; $i < $resultCount ; $i++ ) {
				$selectString += " ";
				$selectString += $intersectResults[$i] ;
			}
			$selectString += ";";
			eval($selectString) ;
		}
	}
}
