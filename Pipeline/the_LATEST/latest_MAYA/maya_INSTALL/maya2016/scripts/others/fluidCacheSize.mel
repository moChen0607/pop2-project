// Copyright (C) 1997-2014 Autodesk, Inc., and/or its licensors.
// All rights reserved.
//
// The coded instructions, statements, computer programs, and/or related
// material (collectively the "Data") in these files contain unpublished
// information proprietary to Autodesk, Inc. ("Autodesk") and/or its licensors,
// which is protected by U.S. and Canadian federal copyright law and by
// international treaties.
//
// The Data is provided for use exclusively by You. You have the right to use,
// modify, and incorporate this Data into other products for purposes authorized 
// by the Autodesk software license agreement, without fee.
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND. AUTODESK
// DOES NOT MAKE AND HEREBY DISCLAIMS ANY EXPRESS OR IMPLIED WARRANTIES
// INCLUDING, BUT NOT LIMITED TO, THE WARRANTIES OF NON-INFRINGEMENT,
// MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE, OR ARISING FROM A COURSE 
// OF DEALING, USAGE, OR TRADE PRACTICE. IN NO EVENT WILL AUTODESK AND/OR ITS
// LICENSORS BE LIABLE FOR ANY LOST REVENUES, DATA, OR PROFITS, OR SPECIAL,
// DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES, EVEN IF AUTODESK AND/OR ITS
// LICENSORS HAS BEEN ADVISED OF THE POSSIBILITY OR PROBABILITY OF SUCH DAMAGES.

//
//
//  Creation Date:  20 Feb 2002
//
//  Description:
//      Return an approximation of the expected file size, in Kbytes,
//      per frame, to cache this fluid.
//
global proc float fluidCacheSize( string $fluid, int $numFrames )
{
    float $res[] = `getAttr ($fluid + ".resolution")`;

    int $tag          = 8;   // tag size in bytes
    int $val          = 4;   // value size in bytes

    int $header       = 60;  // FOR4 up to but not including next FOR4

    int $for4ThruRes  = 60;  // FOR4 through DRES
    int $NUMD         = $tag + $val;
    int $DENS         = $tag + ( ($res[0] * $res[1] * $res[2]) * $val );
    int $NMVX         = $tag + $val;
    int $NMVY         = $tag + $val;
    int $NMVZ         = $tag + $val;
    int $VELX         = $tag + ( ($res[0]+1) * $res[1] * $res[2] * $val );
    int $VELY         = $tag + ( ($res[0]+1) * $res[1] * $res[2] * $val );
    int $VELZ         = $tag + ( ($res[0]+1) * $res[1] * $res[2] * $val );
    int $NUMT         = $tag + $val ;
    int $TEMP         = $tag + ( ($res[0] * $res[1] * $res[2]) * $val );
    int $NUMR         = $tag + $val ;
    int $REAC         = $tag + ( ($res[0] * $res[1] * $res[2]) * $val );
    int $NUMC         = $tag + $val ;
    int $COLR         = $tag + ( ($res[0] * $res[1] * $res[2]) * $val );
    int $COLB         = $tag + ( ($res[0] * $res[1] * $res[2]) * $val );
    int $COLG         = $tag + ( ($res[0] * $res[1] * $res[2]) * $val );
    int $NUMU         = $tag + $val ;
    int $TEXU         = $tag + ( ($res[0] * $res[1] * $res[2]) * $val );
    int $TEXV         = $tag + ( ($res[0] * $res[1] * $res[2]) * $val );
    int $TEXW         = $tag + ( ($res[0] * $res[1] * $res[2]) * $val );

	float $oneFrame = ( $for4ThruRes +
						$NUMD +
						$DENS +
						$NMVX +
						$NMVY +
						$NMVZ +
						$VELX +
						$VELY +
						$VELZ +
						$NUMT +
						$TEMP +
						$NUMR +
						$REAC +
						$NUMC +
						$COLR +
						$COLB +
						$COLG +
						$NUMU +
						$TEXU +
						$TEXV +
						$TEXW ); 
					
    int $overSampling = ( `optionVar -query fluidsDiskCacheSampling` == 1 );
    int $samplingRate = `optionVar -query fluidsDiskCacheSamplingRate`;

    if( $overSampling ) {
        $numFrames *= $samplingRate;
    } else if( $samplingRate != 0 ) {
        $numFrames /= $samplingRate;
    }

    // This isn't quite exact because it depends on whether the 
    // fluid grids have been allocated or not yet.  But this is 
    // a good place to start for a maximum value approximation.
    // 
    float $size = $header + ( $numFrames * $oneFrame );
    $size = $size / 1024.0; // kilobytes
	
    return $size;
}
