// Copyright (C) 1997-2014 Autodesk, Inc., and/or its licensors.
// All rights reserved.
//
// The coded instructions, statements, computer programs, and/or related
// material (collectively the "Data") in these files contain unpublished
// information proprietary to Autodesk, Inc. ("Autodesk") and/or its licensors,
// which is protected by U.S. and Canadian federal copyright law and by
// international treaties.
//
// The Data is provided for use exclusively by You. You have the right to use,
// modify, and incorporate this Data into other products for purposes authorized 
// by the Autodesk software license agreement, without fee.
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND. AUTODESK
// DOES NOT MAKE AND HEREBY DISCLAIMS ANY EXPRESS OR IMPLIED WARRANTIES
// INCLUDING, BUT NOT LIMITED TO, THE WARRANTIES OF NON-INFRINGEMENT,
// MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE, OR ARISING FROM A COURSE 
// OF DEALING, USAGE, OR TRADE PRACTICE. IN NO EVENT WILL AUTODESK AND/OR ITS
// LICENSORS BE LIABLE FOR ANY LOST REVENUES, DATA, OR PROFITS, OR SPECIAL,
// DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES, EVEN IF AUTODESK AND/OR ITS
// LICENSORS HAS BEEN ADVISED OF THE POSSIBILITY OR PROBABILITY OF SUCH DAMAGES.

global string $gImageFileNames[], $gShapeSelectedForScriptJob, $gEditPsdShape = "" ;
global int $gPsdEditImageResX , $gPsdEditImageResY, $gEditSelChangeScriptJob = -1, $gShaderChangeScriptJobs[] ;

proc buildPsdEditTextureWindowMenu ()
//
//  Procedure Name:
//      buildPsdTextureWindowMenu
//
//  Description:
//      Creates the menus for the PsdTexture Window
//
//  Input Arguments:
//		None.
//
//  Return Value:
//      None.
//
{

	global string 	$psdEditTextureWin;
	
	menu -label (uiRes("m_photoshopEditTexture.kEdit"))  
		-tearOff true
		-postMenuCommandOnce true;
		menuItem -label (uiRes("m_photoshopEditTexture.kResetSettings"))  
			-command ("psdEditWindowResetSettingsCmd");
		menuItem -label (uiRes("m_photoshopEditTexture.kSaveSettings"))  
			-command ("psdEditWindowSaveSettingsCmd");

	setParent -menu ..;

	addContextHelpProc $psdEditTextureWin "buildPhotoshopEditTextureContextHelpItems";
	doHelpMenu $psdEditTextureWin $psdEditTextureWin;

}

global proc psdEditWindowResetSettingsCmd()
//  Description:
//      Reset to factory settings
//
{
	psdEditSetFactorySettings(1);
}

global proc psdEditWindowSaveSettingsCmd()
//  Description:
//      Save the settings of the controls.
//
{
	global string $psdEditIncludeUVSnapshot, $psdEditUVLocation, $psdEditOpenPhotoshop;
	global string $psdEditDetailedListCheckbox, $psdEditAntiAlias, $psdEditColorValueSlider;
	int $value;
	float $coValues[3];

	$value = `checkBoxGrp -q -v1 $psdEditAntiAlias`;
	optionVar -intValue psdEditAntiAliasValue $value;	

	$value = `checkBoxGrp -q -v1 $psdEditDetailedListCheckbox`;
	optionVar -intValue psdEditDetailedListValue $value;
	
	$value = `radioButtonGrp -q -select  $psdEditUVLocation`;
	optionVar -intValue psdEditUVSnapshotPosition $value;

	$coValues = `colorSliderGrp  -q -rgb $psdEditColorValueSlider`;
	optionVar -clearArray "psdEditColorValue" ;
	optionVar -floatValueAppend psdEditColorValue $coValues[0] 
					-floatValueAppend psdEditColorValue $coValues[1]
					-floatValueAppend psdEditColorValue $coValues[2];

	$value = `checkBoxGrp -q -v1 $psdEditIncludeUVSnapshot`; 
	optionVar -intValue psdEditIncludeUVSnapValue $value;
	
	$value = `checkBoxGrp -q -v1 $psdEditOpenPhotoshop`; 
	optionVar -intValue psdEditOpenPhotoshopValue $value;
}

global proc psdEditSetFactorySettings(int $factorySettings)
//Discription
//			Resets the default settings for all the controls.
//
{
	global string	$psdEditIncludeUVSnapshot, $psdEditUVLocation, $psdEditOpenPhotoshop,
						$psdEditDetailedListCheckbox, $psdEditAntiAlias, $psdEditColorValueSlider;

	int $value;
	
	if($factorySettings || !`optionVar -exists psdEditAntiAliasValue`)
	{
		$value = 0;
		optionVar -intValue psdEditAntiAliasValue $value;
		checkBoxGrp -e -v1 $value $psdEditAntiAlias;
	}else{
		$value = `optionVar -q psdEditAntiAliasValue` ;
		checkBoxGrp -e -v1 $value $psdEditAntiAlias;
	}
	if($factorySettings || !`optionVar -exists psdEditDetailedListValue`)
	{
		$value = 0;
		optionVar -intValue psdEditDetailedListValue $value;
		checkBoxGrp -e -v1 $value $psdEditDetailedListCheckbox;
		psdEditDetailedListCmd();
	}else{
		$value = `optionVar -q psdEditDetailedListValue` ;
		checkBoxGrp -e -v1 $value $psdEditDetailedListCheckbox;
		psdEditDetailedListCmd();
	}
	
	if($factorySettings || !`optionVar -exists psdEditUVSnapshotPosition`)
	{
		$value = 1;
		optionVar -intValue psdEditUVSnapshotPosition $value;
		radioButtonGrp -e -select $value $psdEditUVLocation;	
	}else{
		$value = `optionVar -q psdEditUVSnapshotPosition`;
		radioButtonGrp -e -select $value $psdEditUVLocation;
	}

	if($factorySettings || !`optionVar -exists psdEditColorValue`){
		float $colorValue = 1.0;

		optionVar -clearArray "psdEditColorValue" ;
		optionVar -floatValueAppend psdEditColorValue $colorValue 
					-floatValueAppend psdEditColorValue $colorValue
					-floatValueAppend psdEditColorValue $colorValue;
		colorSliderGrp  -e -rgb $colorValue $colorValue $colorValue $psdEditColorValueSlider;

	}
	else{
		float $coValues[3] = `optionVar -q psdEditColorValue`;
		colorSliderGrp  -e -rgb $coValues[0] $coValues[1] $coValues[2] $psdEditColorValueSlider;
	}

	if($factorySettings || !`optionVar -exists psdEditIncludeUVSnapValue`)
	{
		$value = 1;
		optionVar -intValue psdEditIncludeUVSnapValue $value;
		checkBoxGrp -e -v1 $value $psdEditIncludeUVSnapshot;
		psdEditIncludeUVSnapShotCmd($value); 
	}else{
		$value = `optionVar -q psdEditIncludeUVSnapValue` ;
		checkBoxGrp -e -v1 $value $psdEditIncludeUVSnapshot;
		psdEditIncludeUVSnapShotCmd($value);
	}

	if($factorySettings || !`optionVar -exists psdEditOpenPhotoshopValue`)
	{
		$value = 0;
		optionVar -intValue psdEditOpenPhotoshopValue $value;
		checkBoxGrp -e -v1 $value $psdEditOpenPhotoshop;
	}else{
		$value = `optionVar -q psdEditOpenPhotoshopValue` ;
		checkBoxGrp -e -v1 $value $psdEditOpenPhotoshop;
	}
}

global proc buildPhotoshopEditTextureContextHelpItems(string $nameRoot, string $menuParent)
//
//  Description:
//		Build context sensitive menu items
//
//  Return Value:
//      None
//
{
	menuItem -label (uiRes("m_photoshopEditTexture.kHelpOnEditPSDNetworkOptions")) 
		-enableCommandRepeat false
		-command "showHelp photoshopEditTexture";
}

global proc string psdEditIsSelectedObjectProper(string $sList[])
//
//	Description:
//		Checks if the selected object is proper or not.
//		Only Nurbs, polys and Subdiv surfaces need to be 
//		selected.
//
{
	global string $gSelectedShape;
	string $psdShape[] = `listRelatives -s $sList[0]`;
	string $emptyString = "";
	string $objectSelectionError = (uiRes("m_photoshopEditTexture.kObjectSelectionError"));
	if(size($psdShape) < 1){
		string $initialNodetype = `nodeType $sList[0]`;
		if($initialNodetype == "nurbsSurface" || $initialNodetype == "mesh" 
												|| $initialNodetype == "subdiv"){
				$gSelectedShape = $sList[0];
				return $gSelectedShape;
		}
		else
		{
			if(size($gSelectedShape) > 0)
				return $gSelectedShape;
			else{
				error($objectSelectionError);
				return $emptyString;	
			}
		}
	}
	
	string $nodetype = `nodeType $psdShape[0]`;
	if($nodetype != "nurbsSurface" && $nodetype != "mesh" && $nodetype != "subdiv"){
			if(size($gSelectedShape) > 0)
			{
				$psdShape[0] = $gSelectedShape;
			}else{
				error($objectSelectionError);
				return $emptyString;
			}
	}
	$gSelectedShape = $psdShape[0];
	return $gSelectedShape;
}


global proc psdEditCmd()
//Discription
//			This writes the psd file on to the disk and creates the node
//			network appropriately and closes the window.
//
{		
	global string $gEditAddedChannels[], $gEditPsdFileName, $gConnectedAttributes[], $gImageFileNames[],
						$psdEditFileNameOptionMenu ;
	global int $gPsdEditImageResX, $gPsdEditImageResY, $gEditSelChangeScriptJob;
	string $initString[];
	int $closeFlag = 1;
	if(psdEditProcessAddedAndDeletedChannels()){
		string $shortName = `optionMenuGrp -q -value  $psdEditFileNameOptionMenu`;
		string $psdFileName = `workspace -expandName $shortName`;
		psdEditProcessSelectedAttributes($closeFlag, $psdFileName);
	}
		
	$gEditAddedChannels = $initString;
	$gImageFileNames = $initString;
	$gEditPsdFileName = "";
	$gPsdEditImageResX  = 0;
	$gPsdEditImageResY = 0;
	$gConnectedAttributes = $initString;
	$gEditPsdShape = "";
	if(`scriptJob -exists $gEditSelChangeScriptJob`)
	{
		scriptJob -kill $gEditSelChangeScriptJob;
	}
	//$gEditSelChangeScriptJob = 0;
	psdEditKillShaderChangeScriptJobs();
	psdEditWindowSaveSettingsCmd();
}

global proc psdEditCloseCmd()
//Discription
//			This closes the window without doing anything.
//

{
	global string $psdEditTextureWin;
	global string $gEditAddedChannels[], $gEditPsdFileName, $gConnectedAttributes[], $gImageFileNames[] ;
	global int $gPsdEditImageResX, $gPsdEditImageResY, $gEditSelChangeScriptJob;
	string $initString[];
	
	window -e -visible false $psdEditTextureWin;
	$gEditAddedChannels = $initString;
	$gEditPsdFileName = "";
	$gImageFileNames = $initString;
	$gPsdEditImageResX  = 0;
	$gPsdEditImageResY = 0;
	$gConnectedAttributes = $initString;
	$gEditPsdShape = "";
	if(`scriptJob -exists $gEditSelChangeScriptJob`)
	{
		scriptJob -kill $gEditSelChangeScriptJob;
	}
	//$gEditSelChangeScriptJob = 0;
	psdEditKillShaderChangeScriptJobs();
}

global proc psdEditApplyCmd()
//
//	Description:
//		This gets executed when the Apply button is pressed
//		in the connected attributes window. At this point 
//		all the node network gets created.
//
{
	global string $gEditAddedChannels[], $gEditPsdFileName, $gConnectedAttributes[], $gImageFileNames[],
						$psdEditFileNameOptionMenu ;
	global int $gPsdEditImageResX, $gPsdEditImageResY;
	int $closeFlag = 0, $index;
	string $initString[];
	
	if(!psdEditProcessAddedAndDeletedChannels())
		return;
	string $shortName = `optionMenuGrp -q -value  $psdEditFileNameOptionMenu`;
	string $psdFileName = `workspace -expandName $shortName`;
	psdEditProcessSelectedAttributes($closeFlag, $psdFileName);

	string $selectedItems[] = `ls -sl`;
	for($index = 0; $index < size($selectedItems); $index++){
			select -deselect $selectedItems[$index];
	}
	psdEditWindowSaveSettingsCmd();
	$gEditAddedChannels = $initString;
	$gConnectedAttributes = $initString;
	$gEditPsdFileName = "";
	$gImageFileNames = $initString;
	$gPsdEditImageResX  = 0;
	$gPsdEditImageResY = 0;
}

global proc int psdEditProcessAddedAndDeletedChannels()
{
	global string $psdEditRightList, $gConnectedAttributes[], $gEditAddedChannels[], $gEditDeletedChannels[];
	int $connIndex, $index, $count;
	
	string $initString[];
	
	string $connectedItems[] = `psdChannelOutliner -q -allItems $psdEditRightList`;
	if(!size($connectedItems))
		return false;
	
	// Initialize the array to zero.
	$gEditDeletedChannels = $initString;
	$gEditAddedChannels = $initString;
	
	// Store the deleted channels in a global variable. This will be useful
	// when we write the PSD file with the modified input.
	
	$count = 0;
	for($index = 0; $index < size($gConnectedAttributes); $index++)
	{
		for($connIndex = 0; $connIndex < size($connectedItems); $connIndex++)
		{
			if($gConnectedAttributes[$index] == $connectedItems[$connIndex]){
				break;
			}	
		}
		if($connIndex == size($connectedItems))
		{
			$gEditDeletedChannels[$count++] = $gConnectedAttributes[$index];
		}
	}
	
	// Store the added channels separately in a global variable.
	// This data needs to be sent for processing.
	
	$count = 0;

	for($connIndex = 0; $connIndex < size($connectedItems); $connIndex++)
	{
		for($index = 0; $index < size($gConnectedAttributes); $index++)
		{
			if($gConnectedAttributes[$index] == $connectedItems[$connIndex]){
				break;
			}	
		}
		if($index == size($gConnectedAttributes))
		{
			$gEditAddedChannels[$count++] = $connectedItems[$connIndex];
			
		}
	}
	
	if(size($gEditAddedChannels) == 0 && size($gEditDeletedChannels) == 0){
		return false;
	}
	return true;
}

global proc int psdEditProcessSelectedAttributes(int $closeFlag, string $psdFileName)
//
//	Description:
//  This function does the processing of the attributes added or deleted.
//  The added and the deleted attributes are kept in a separate list.
//  The added attributes are then used to create new connections and
//  deleted attributes are used to delete the connections.
//
{
	global string $gEditPsdFileName, $gEditSnapShotName, $gEditUVSnapPositionTop;	 
	global int $gForceConnectionFlag[]; 
	global string $psdEditRightList, $gConnectedAttributes[],  $psdEditResXTextField, $psdEditResYTextField, 
					  $psdEditUVListMenu, $psdEditColorValueSlider, $psdEditAntiAlias, $psdEditTextureWin,
					  $psdEditIncludeUVSnapshot, $psdEditUVLocation, $psdEditResXTextField, $psdEditResYTextField,
					  $psdEditOpenPhotoshop ; 
	
	
	// Handle UV snap shot here.
	int $uvsnap = `checkBoxGrp -q -value1 $psdEditIncludeUVSnapshot`;

	string $tempFileName = "";
	int $uvSnapPositionTop  = true;
	
	int $xRes = `intField -q -value  $psdEditResXTextField`;
	int $yRes = `intField -q -value  $psdEditResYTextField`;
	if($uvsnap){
		string $selectedUVSet = `optionMenuGrp -q -value $psdEditUVListMenu` ;
		
		$tempFileName = getenv("TMPDIR");
		$tempFileName += "/tempPsd.iff";

		float $rgb[3] = `colorSliderGrp -q -rgbValue $psdEditColorValueSlider`;
		int $antiAliasedVal = `checkBoxGrp -q -value1 $psdEditAntiAlias`;
		
		if(`radioButtonGrp -q -select $psdEditUVLocation` == 1){
			$uvSnapPositionTop = true ;
		}else{
			$uvSnapPositionTop = false ;
		}
  
	  // Get the options for uvsnap shot image

		 float $color[3];
		$color[0] = $rgb[0] * 255;
		$color[1] = $rgb[1] * 255;
		$color[2] = $rgb[2] * 255;
  
		if ($antiAliasedVal){
			uvSnapshot -o -antiAliased -name $tempFileName
								  -uvSetName $selectedUVSet 
								  -redColor $color[0]
								  -greenColor $color[1]
								  -blueColor $color[2]
								  -ff "iff"
								  -xResolution $xRes 
								  -yResolution $yRes ; 
		}else{
				uvSnapshot -o -name $tempFileName
								  -uvSetName $selectedUVSet 
								  -redColor $color[0]
								  -greenColor $color[1]
								  -blueColor $color[2]
								  -ff "iff"
								  -xResolution $xRes 
								  -yResolution $yRes ; 
		}

	}
	
	

	 $gEditPsdFileName = $psdFileName;
	 $gEditSnapShotName = $tempFileName;
	 $gEditUVSnapPositionTop = $uvSnapPositionTop;
	
	// Handle the procedural textures here.
	
	string $itemList[] = psdEditCheckBump();
	 int $index;	 
	 for ($index = 0; $index < size($itemList); $index++){
		if(`connectionInfo -isDestination $itemList[$index]`){
			$gForceConnectionFlag[$index] = 1;
			// Do not break the connection if it is connected to the PSD file node.
			if(psdIsConnectedToPsdFileNode($itemList[$index])){
				$gForceConnectionFlag[$index] = 0;
				continue;
			}
			if(psdIsConnectedToFileNode($itemList[$index])){
				continue;
			}
		}else{
			$gForceConnectionFlag[$index] = 0;
		}
	 }
	
	 // If the procedural textures exists then pop up the 
	 // Connected attribute dialog.

	psdEditConnectedWinApplyCmd();
	
	int $photoshopVal = `checkBoxGrp -q -value1 $psdEditOpenPhotoshop`;
	if ( $photoshopVal )
	{
		launchImageEditor -eif $psdFileName;
	}
	
	return true;
}

global proc psdEditHandleDeletedChannels()
//
//	Description:
//  Post processing of the deleted channels is done here
//
{
	global string $gEditDeletedChannels[];
	string $initString[], $tokens[];
	string $deleteChannel;
	for($index = 0; $index < size($gEditDeletedChannels); $index++){
		$deleteChannel = $gEditDeletedChannels[$index];
		tokenize $gEditDeletedChannels[$index] "." $tokens;
		// Check for the bump and change it to normalCamera.
		if($tokens[1] == "bump"){
			$deleteChannel = $tokens[0] + ".normalCamera";
		}
		string $connectedNode =`connectionInfo -sourceFromDestination  $deleteChannel`;
		disconnectAttr $connectedNode $deleteChannel;
	}
	$gEditDeletedChannels = $initString;
}


global proc psdEditConnectedWinApplyCmd()
//
//	Description:
//		This gets executed when the Apply button is pressed
//		in the connected attributes window. At this point 
//		all the node network gets created.
//
{
	global int $gForceConnectionFlag[];
	global string $gEditUVSnapPositionTop;
	global string $gEditPsdFileName, $psdEditFileNameOptionMenu, $psdEditResXTextField, $psdEditResYTextField;
	global string $gEditSnapShotName, $psdEditRightList, $psdEditTextureWin;	
	
	int $closeFlag = `optionVar -q "gCloseFlag"`;
	int $xRes = `intField -q -value $psdEditResXTextField`;
	int $yRes = `intField -q -value $psdEditResYTextField`;	 
	psdChannelOutliner -e -removeAll $psdEditRightList;
	
	string $items[] = `optionMenuGrp -q -itemListLong $psdEditFileNameOptionMenu`;
	int $itemCount = size($items);
	int $fileIndex;

	if($itemCount > 0) {
		for ($fileIndex=0; $fileIndex < $itemCount; ++$fileIndex) {
			deleteUI -menuItem $items[$fileIndex];
		}
	}
	psdProcessNodeConnections($gEditPsdFileName, $gEditSnapShotName, $gEditUVSnapPositionTop, 
								$psdEditRightList, $xRes, $yRes, false);
	// Have we pressed "Edit" or "Apply" button.
	if($closeFlag)
	{
		window -e -visible false $psdEditTextureWin;
	}
    // Once we are done with all the connections, delete the channels if any.
	psdEditHandleDeletedChannels();

	int $initValues[];
	$gForceConnectionFlag = $initValues;
	
	
	if(!$closeFlag){
		window -e -visible true $psdEditTextureWin;
	}
	psdUpdateTextures();
}

global proc psdEditConnectedWinCloseCmd()
{
	global int $gForceConnectionFlag[];
	global string $psdEditTextureWin ;

	int $initValues[];

	$gForceConnectionFlag = $initValues;
	window -e -visible true $psdEditTextureWin;

}

global proc string[] psdEditCheckBump()
{
		global string $gEditAddedChannels[];
		int $index, $numTokens;
		string $psdAttributes[], $bumpString;

		string $itemList[] = $gEditAddedChannels;
		
		for($index = 0; $index < size($itemList); $index++){
				$numTokens = `tokenize $itemList[$index] "." $psdAttributes`;
				if($psdAttributes[size($psdAttributes) - 1] == "bump"){
						$stringSize = size($itemList[$index]) ;
						$bumpString = `substring $itemList[$index] 1 ($stringSize - 4)`;
						$itemList[$index] = $bumpString + "normalCamera";
				}
		}
		return $itemList;
} 

global proc psdEditUpdateShortListControl(string $psdShape, string $detailedConnectedAttributes[], string $psdFileName)
//
//  Description:
//  Updates the controls associated with the connected and unconnected list.
//
{
	global string	$gPsdChannelList[], $psdEditLeftList, $psdEditRightList, $psdEditResXTextField, 
						$psdEditResYTextField, $gConnectedAttributes[], $gEditPsdShape;
	global int $gPsdEditImageResX , $gPsdEditImageResY ;
	
	// Store the list of connected attributes. This will be useful
	// when we want to differenciate with the newly added and
	// deleted attributes.
	
	$gEditPsdShape = $psdShape;	
	$gConnectedAttributes = $detailedConnectedAttributes;
		
	string $connectedAttributes[], $tokens[];
	string $attributeList[] , $pixmapFileName; // Needs to be assigned;
	int $index, $count = 0, $channelIndex;
	
	// We need to list all the shaders in the left list.
	string $psdShaders[] = psdGetMaterialsGivenShape($psdShape);
	
	// Remove everything fromt the right list and add
	// the new stuff to it.
	
	psdChannelOutliner -e -removeAll $psdEditRightList;
	for($index = 0; $index < size($detailedConnectedAttributes); $index++)
	{
		tokenize $detailedConnectedAttributes[$index] "."  $tokens;
		psdChannelOutliner -e 
									-psdParent  $tokens[0]
									-addChild $tokens[1]  "out_psdFileTex.png" // change this to psd file texture image.
									$psdEditRightList;
		int $i;
		for($i = 0 ; $i < size($gPsdChannelList); $i++){
		// Check for the displacement attribute. This will be displayed as "shader.displacementShader".
			if($tokens[1] == $gPsdChannelList[$i] || ($tokens[1] == "displacementShader" &&  $gPsdChannelList[$i] == "displacement")){
				$connectedAttributes[$count++] = $detailedConnectedAttributes[$index];
				break;
			}
		}
	}
	
	$count = 0;
	for($index = 0; $index < size($psdShaders); $index++)
	{
		// This is short list representation of channels of all the shaders attached to the shape object.
		for($channelIndex = 0; $channelIndex < size($gPsdChannelList); $channelIndex++)
		{
			$attributeList[$count++] = $psdShaders[$index] + "." + $gPsdChannelList[$channelIndex]; 
		}
	}
	
	int $i;
	int $channelIndex = 0;
	string $detailedChannelList[];
	for($i = 0; $i < size($psdShaders); $i++){
		// Here we get the detailed list of all the channels associated with a the particular shader.
		// This is useful to filter out which is one is connected and which one is not.
		$attrConnections = `listAttr -r -o $psdShaders[$i]` ;
		for($index = 0; $index < size($attrConnections); $index++){
				$combinedChannels[$channelIndex] = $attrConnections[$index];
				$detailedChannelList[$channelIndex] = $psdShaders[$i] + "." + $attrConnections[$index];
				$channelIndex++;
		}
	}
	// Start processing the left list (i.e the unconnected list).
	psdChannelOutliner -e -removeAll $psdEditLeftList;
	string $unconnectedList[];
	$count = 0;
	for($attrIndex = 0; $attrIndex < size($attributeList); $attrIndex++)
	{
		string $shortListTokens[];
		tokenize $attributeList[$attrIndex] "." $shortListTokens;
		int $displacementConnected = false;
		for($index = 0; $index < size($connectedAttributes); $index++)	
		{
			string $displacementTokens[];
			string $comparisionString;
			int $numTokens = `tokenize $connectedAttributes[$index] "." $displacementTokens`;
			
			// Check for the displacement attribute, as, in the short list we respresent this as "shader.diplacement".
			
			if($displacementTokens[$numTokens -1] == "displacementShader")
			{
				$comparisionString = $shortListTokens[0] + ".displacement";
			}
			else
			{
				$comparisionString = $connectedAttributes[$index] ;
			}
			
			if($comparisionString == $attributeList[$attrIndex]){
			// We are making sure if the displacement attributes is already connected or not.
				if($displacementTokens[$numTokens -1] == "displacementShader")
					$displacementConnected = true;
				break;
			}
		}
		if($index == size($connectedAttributes))
		{
		// If we have an unconnected displacement attribute, then add it to the short list.
			if($shortListTokens[1] == "displacement" && $displacementConnected == false)
			{
					$pixmapFileName = psdCheckConnectionsForChannel($attributeList[$attrIndex]);
					psdChannelOutliner -e 
									-psdParent  $shortListTokens[0]
									-addChild $shortListTokens[1]  $pixmapFileName
									$psdEditLeftList;
					continue;
			}
			// Now in order to build the unconnected  short list, we need to exclude the connected channels,
			// and the attributes which do not belong to the short list.
			
			for($channelIndex = 0; $channelIndex < size($detailedChannelList); $channelIndex++)
			{
				string $attrTokens[];
				int $numTokens = `tokenize $detailedChannelList[$channelIndex] "." $attrTokens`;
				string $comparisionString;
				// Handle bump and displacement channels in a special way.
				if ($attrTokens[$numTokens - 1] == "normalCamera")
				{
					$comparisionString  = $attrTokens[0] + "." + "bump";
				}
				else if ($attrTokens[$numTokens - 1] == "displacementShader")
				{
					string $displacementTokens[];
					int $numDispTokens = `tokenize $attributeList[$attrIndex] "." $displacementTokens`;
					$comparisonString = $displacementTokens[0] + ".displacement";
				}
				else
				{
					$comparisionString = $detailedChannelList[$channelIndex];
				}
				if($comparisionString == $attributeList[$attrIndex])
					break;
			}
			// This means the channel is either connected or not a part of the short list. 
			if($channelIndex == size($detailedChannelList))
				continue;
				
			$unconnectedList[$count++] = $attributeList[$attrIndex];
			tokenize $attributeList[$attrIndex] "."  $tokens;
			// Check to see if they are connected to any procedural textures or not.
			$pixmapFileName = psdCheckConnectionsForChannel($attributeList[$attrIndex]);
			psdChannelOutliner -e 
									-psdParent  $tokens[0]
									-addChild $tokens[1]  $pixmapFileName
									$psdEditLeftList;
		}
	}		
	intField -e -value $gPsdEditImageResX $psdEditResXTextField; 																
	intField -e	 -value $gPsdEditImageResY $psdEditResYTextField; 
}

global proc psdEditEnableDisableUVSnapControl(string $psdShape)
//
//	Description:
//		Function for enabling or disabling the UV sets for 
//		the selected object or not.
//
{
	global string $psdEditUVListMenu;
	
	// if user has selected any "non-mesh" objects disable UV set selection control

	string $items[] = `optionMenuGrp -q -itemListLong $psdEditUVListMenu`;
	int $itemCount = size($items);
	int $uvIndex;

	if($itemCount > 0) {
		for ($uvIndex=0; $uvIndex < $itemCount; ++$uvIndex) {
			deleteUI -menuItem $items[$uvIndex];
		}
	}
	if($psdShape == ""){
		menuItem -parent ($psdEditUVListMenu + "|OptionMenu")  -label "        ";
		optionMenuGrp -e -select 1  $psdEditUVListMenu;
		optionMenuGrp -e -width 80 $psdEditUVListMenu ;
		optionMenuGrp -e -enable false $psdEditUVListMenu ;
		return;
	}

	string $nodetype = `nodeType $psdShape`;
	if( $nodetype != "mesh" && $nodetype != "subdiv")
	{
		menuItem -parent ($psdEditUVListMenu + "|OptionMenu")  -label "        ";
		optionMenuGrp -e -select 1  $psdEditUVListMenu;
		optionMenuGrp -e -width 80 $psdEditUVListMenu ;
		optionMenuGrp -e -enable false $psdEditUVListMenu ;
	}
	else
	{
		string $allUVSet[];
		if($nodetype == "mesh"){
			$allUVSet  = `polyUVSet -q -allUVSets $psdShape`;
		}else{
			$allUVSet[0] = `getAttr ($psdShape + ".uvSet[0].uvSetName")`;
		}
		for($uvIndex = 0; $uvIndex < size($allUVSet); ++$uvIndex){
			menuItem -parent  ($psdEditUVListMenu + "|OptionMenu")  -label $allUVSet[$uvIndex] ;
		}

		if(size($allUVSet) > 0){
			optionMenuGrp -e -select 1  $psdEditUVListMenu;
		}

		optionMenuGrp -e -enable true $psdEditUVListMenu ;
	}
}

global proc string  psdEditIsSelectedShapeProper()
{
	global string $gEditPsdShape;
	
	string $sList[] = `ls -sl`;
	if (size($sList) > 1 ){
		error((uiRes("m_photoshopEditTexture.kManyObjectsSelectedError")));
		return "";
	}
	if( size($sList) == 0)
	{
		if(size($gEditPsdShape) > 0)
		{
			return $gEditPsdShape;
		}
		else
		{
			error((uiRes("m_photoshopEditTexture.kNoObjectSelectedError")));
			return "";
		}
	}
	
	string $psdEditShape = psdEditIsSelectedObjectProper($sList);	
	if($psdEditShape == "")
		return "";
		
	return $psdEditShape;
}

global proc string[]  psdEditProcessForConnectedAttributes(string $psdFileName)
//
//	Description:
//		Check  to see if the selected object is nurbs/poly/subdiv. Returns
//		a list of connected attributes of the shader associated with the shape.
//
{
	global string $gEditShadingEng[], $psdEditDetailedLeftList;
	
	string $detailedConnectedAttributes[] ;
	
	string $psdEditShape = psdEditIsSelectedShapeProper();
	
	if($psdEditShape == "")
	   return $detailedConnectedAttributes;

	// We need to source this script, as we are using some common globla variables here.	
	source photoShopPaintTex.mel;	
	string $tmpMaterialList[] = psdGetMaterialsGivenShape($psdEditShape);
	string $psdMaterialList[] = psdEditGetMaterialsForGivenFileAndShape($psdEditShape, $psdFileName, $tmpMaterialList);

	int $matIndex;
	int $count = 0;
	for($matIndex = 0; $matIndex < size($psdMaterialList); $matIndex++){
	
		string $tmpAttributes[] = psdEditIsShaderValidForGivenFile($psdFileName, $psdMaterialList[$matIndex]);
		int $tmpIndex;
		for($tmpIndex = 0; $tmpIndex < size($tmpAttributes); ++$tmpIndex)
		{
			$detailedConnectedAttributes[$count++] = $tmpAttributes[$tmpIndex];
		}
	}
	return $detailedConnectedAttributes;
}

global proc string[] psdEditGetMaterialsForGivenFileAndShape(string $psdShape, string $file, string $materialList[])
{
	
	int $matIndex;
	int $count = 0;
	string $shaderList[];
	for($matIndex = 0; $matIndex < size($materialList); $matIndex++)
	{
	// Get the psdfile nodes directly connected to the shader.
		string $psdFileNodes[] = `listConnections -source on -destination off -type "psdFileTex" $materialList[$matIndex]`;
		if(size($psdFileNodes) > 0)
		{
			int $psdIndex;
			for($psdIndex = 0; $psdIndex < size($psdFileNodes); $psdIndex++)
			{
				if(`getAttr ($psdFileNodes[$psdIndex] + ".fileTextureName")` == $file){
					$shaderList[$count++] = $materialList[$matIndex];
					break;
				}
			}
		}
		else
		{
		// If we do not have psdNodes then check if bump t is connected.
			string $bumpNodes[] = `listConnections -source on -destination off -type "bump2d" $materialList[$matIndex]` ;
			if(size($bumpNodes) > 0)
			{
				int $bumpIndex;
				for($bumpIndex = 0; $bumpIndex < size($bumpNodes); $bumpIndex++)
				{
					string $psdFileNodes[] = `listConnections -source on -destination off -type "psdFileTex"  $bumpNodes[$matIndex]`;
					int $psdIndex;
					for($psdIndex = 0; $psdIndex < size($psdFileNodes); $psdIndex++)
					{
						if(`getAttr ($psdFileNodes[$psdIndex] + ".fileTextureName")` == $file){
							$shaderList[$count++] = $materialList[$matIndex];
							break;
						}
					}
				}
			}
			// Check for the displacement connections.
			string $shadingEng[] = `listConnections -source off -destination on -type "shadingEngine" $materialList[$matIndex]`;
			int $shadingIndex; 
			for($shadingIndex = 0; $shadingIndex < size($shadingEng); $shadingIndex++)
			{
				string $dispNodes[] = `listConnections -source on -destination off  -type "displacementShader" $shadingEng[$shadingIndex]`;
				int $dispIndex;
				for($dispIndex = 0; $dispIndex < size($dispNodes); $dispIndex++)
				{
					string $psdFileNodes[]  = `listConnections -source on -destination off -type "psdFileTex"  $dispNodes[$dispIndex]`;
					int $psdIndex;
					for($psdIndex = 0; $psdIndex < size($psdFileNodes); $psdIndex++)
					{
						if(`getAttr ($psdFileNodes[$psdIndex] + ".fileTextureName")` == $file){
							$shaderList[$count++] = $materialList[$matIndex];
							break;
						}
					}
				}
			}
		}
	}
	string $finalShaderList[];
	if(size($shaderList) > 0)
	{
		$finalShaderList = stringArrayRemoveDuplicates($shaderList);
	}
	return $finalShaderList;
}

global proc psdProcessImageFileNamesConnectedToShape(string $shapeObject)
//
//	Description:
//		Traverse the dag path starting from shape object. Go to shader and then 
//		look for psd file nodes which are directly connected. Then search for 
//		the displacement and bump connections.
//
{
	global string $gImageFileNames[];
	string $initString[];
	
	$gImageFileNames = $initString;
	
	int $psdFileNameCount = 0;
	string $psdImageFileNames[];
	string $shadingEngines[] = `listConnections -source off -destination on -type "shadingEngine" $shapeObject`;
	int $index;
	for($index = 0; $index < size($shadingEngines); $index++)
	{
		// Handle the usual connections, i.e PSD file nodes  connected to the shader.l
		string $shaderConnections[] = `listConnections -source on -destination off ($shadingEngines[$index] + ".surfaceShader")`;
		int $shaderIndex;
		for($shaderIndex = 0; $shaderIndex < size($shaderConnections); $shaderIndex++)
		{
			// Handle the simple psdConnections here (except bump).
			string $psdConnections[] = `listConnections -source on -destination off -type "psdFileTex" $shaderConnections[$shaderIndex]`;
			int $psdIndex;
			for($psdIndex = 0; $psdIndex < size($psdConnections); $psdIndex++)
			{
				string $fileName = `getAttr ($psdConnections[$psdIndex] + ".fileTextureName")`;
				// Get all the image file names associated with the selected shape.
				$psdImageFileNames[$psdFileNameCount] = `workspace -projectPath  $fileName`;
				$psdFileNameCount++;
			}	// end of $psdConnections
			
			// Handle Bump connections now.
			string $bumpConnections[] = `listConnections -source on -destination off -type "bump2d" $shaderConnections[$shaderIndex]` ;
			int $bumpIndex;
			for($bumpIndex = 0; $bumpIndex < size($bumpConnections); $bumpIndex++)
			{
				string $psdConnections[] = `listConnections -source on -destination off -type "psdFileTex" $bumpConnections[$bumpIndex]`;
				for($psdIndex = 0; $psdIndex < size($psdConnections); $psdIndex++)
				{
					string $fileName = `getAttr ($psdConnections[$psdIndex] + ".fileTextureName")`;
					$psdImageFileNames[$psdFileNameCount] = `workspace -projectPath  $fileName`;
					$psdFileNameCount++;
				}	// end of $psdConnections.
			}	// end of $bumpConnections.
			
		}	// end of $shaderConnections.
		// Handle the displacement attribute conections.
		string $dispConnections[] = `listConnections -source on -destination off ($shadingEngines[$index] + ".displacementShader")`;
		int $dispIndex;
		for($dispIndex = 0; $dispIndex < size($dispConnections); $dispIndex++)
		{
			string $psdConnections[] = `listConnections -source on -destination off -type "psdFileTex" $dispConnections[$dispIndex]`;
			int $psdIndex;
			for($psdIndex = 0; $psdIndex < size($psdConnections); $psdIndex++)
			{
				string $fileName = `getAttr ($psdConnections[$psdIndex] + ".fileTextureName")`;
				$psdImageFileNames[$psdFileNameCount] = `workspace -projectPath  $fileName`;
				$psdFileNameCount++;
			}	// end of  $psdConnections.
		}	// end of $dispConnections
	}	// end of $shadingEngines.
	
	// Remove the duplicate names from the list.
	$gImageFileNames = stringArrayRemoveDuplicates($psdImageFileNames);
}

global proc string [] psdEditIsShaderValidForGivenFile(string $fileName, string $shader )
{
	global int $gPsdEditImageResX, $gPsdEditImageResY;
	string $tempConnections[] = `listConnections -source on -destination off -type "psdFileTex" $shader`;
	
	// There is a chance we may end up getting duplicate nodes, for eg. a single PSD node
	// is connected to the shader thru color and transparency channel.
	string $connections[] = stringArrayRemoveDuplicates($tempConnections);
	int $count = size($connections);
	int $index;
	// Look for bump connections.
	string $bumpConnections[] = `listConnections -source on -destination off -type "bump2d" $shader`;
	if(size($bumpConnections) > 0){
		for($index = 0; $index < size($bumpConnections); $index++){
			string $psdTexConnections[] =  `listConnections -source on -destination off
															 -type "psdFileTex" ($bumpConnections[$index] + ".bumpValue")`;
			
			int $psdIndex;
			for($psdIndex = 0; $psdIndex < size($psdTexConnections); $psdIndex++)
			{
				$connections[$count++] = $psdTexConnections[$psdIndex];
			}
		}
	}
	// Look for displacement connections.
	string $shadingGroups[] = `listConnections -source off -destination on -type "shadingEngine" ($shader + ".outColor")`;
	if(size($shadingGroups) > 0){
		
		for($index = 0; $index < size($shadingGroups); $index++){
			string $displacements[] = `listConnections -source on
									 -destination off -type "displacementShader" 
									 ($shadingGroups[$index] + ".displacementShader")`;
			int $dispIndex;
			for($dispIndex = 0; $dispIndex < size($displacements); $dispIndex++){
				int $psdIndex;
				string $psdConnections[] = `listConnections -source on
									 -destination off -type "psdFileTex" 
									 ($displacements[$dispIndex] + ".displacement")`;
				for($psdIndex = 0; $psdIndex < size($psdConnections); $psdIndex++)
				{
					$connections[$count++] = $psdConnections[$psdIndex];
				} // $psdConnections
			} // $displacements
		}// $displacementConnections
	} // end of size($displacementConnections).
	
	// Now we have all the psdNodes connected to this particular shader. Get the 
	// image resolutions for the selected file and the corresponding connected
	// channels.
	
	string $connectedAttributes[];
	string $tokens[];
	int $attrCount = 0;
	for($index = 0; $index < size($connections); $index++){
		string $file = `getAttr ($connections[$index] + ".fileTextureName")`;
		if($file == $fileName){
			$gPsdEditImageResX = `getAttr ($connections[$index] + ".osx")`;
			$gPsdEditImageResY = `getAttr ($connections[$index] + ".osy")`;
			// Handle the usual connections.
			string $nType = `nodeType $shader`;
			string $tmpConnections[] = `listConnections -source false -destination true 
														-plugs true -connections true  -type $nType 
														$connections[$index]`;
			// There is more than one connection going from the PSD node to the shader
			if(size($tmpConnections) > 2)
			{
				string $warningString = (uiRes("m_photoshopEditTexture.kMoreConnectionsWarn"));
				warning(`format -s $connections[$index] -s $shader $warningString`);
			}
			int $tmpIndex;
			for($tmpIndex = 1; $tmpIndex < size( $tmpConnections); $tmpIndex += 2)
			{
				$connectedAttributes[$attrCount++] = $tmpConnections[$tmpIndex];
			}
			
			if(size($tmpConnections) > 0)
				continue;
			
			// Check for the bump connections.
			$tmpConnections = `listConnections -source false -destination true 
														-plugs true -connections true  -type "bump2d" 
														$connections[$index]`;
			if(size($tmpConnections) > 0)
			{
				tokenize $tmpConnections[1] "." $tokens;
				$tmpConnections = `listConnections -source false -destination true 
														-plugs true -connections true  -type $nType  
														$tokens[0]`;
				if(size($tmpConnections) > 0){
					tokenize $tmpConnections[1] "." $tokens;
					// Change normalCamera to bump.
					$connectedAttributes[$attrCount++] = $tokens[0] + ".bump";
					continue;
				}
			}
			
			// Check for displacement connections.
			$tmpConnections = `listConnections -source false -destination true 
														-plugs true -connections true  -type "displacementShader" 
														$connections[$index]`;
			
			if(size($tmpConnections) > 0)
			{
				tokenize $tmpConnections[1] "." $tokens;
				// Assumes that only one shading group is connected.
				$nType = `nodeType $shadingGroups[0]` ;
				$tmpConnections = `listConnections -source false -destination true 
														-plugs true -connections true  -type $nType
														$tokens[0]`;
				if(size($tmpConnections) > 0){
					$connectedAttributes[$attrCount++] = $tmpConnections[1];
					continue;
				}
			}
		}
	}


	return $connectedAttributes;
}

global proc psdEditUpdateWithSelectionChange()
//
//	Description:
//		This is a script job and is called whenever the selection
//		changes.
//
{
	global string $gEditShadingEng[], $psdEditDetailedLeftList, $psdEditTextureWin,
					   $psdEditLeftList,	$psdEditRightList, $psdEditFileNameOptionMenu,
					   $gImageFileNames[], $gEditPsdFileName, $gConnectedAttributes[];
	int $gPsdEditImageResX, $gPsdEditImageResY; 
					   
	string $initString[];
	
	if(!`window -q -visible $psdEditTextureWin`)
			return;
			
	// Clean up all the UI elements first.
	psdChannelOutliner -e -removeAll $psdEditLeftList;
	nodeOutliner -e -removeAll $psdEditDetailedLeftList;
	psdChannelOutliner -e -removeAll $psdEditRightList;
	string $items[] = `optionMenuGrp -q -itemListLong $psdEditFileNameOptionMenu`;
	int $itemCount = size($items);
	int $fileIndex;

	if($itemCount > 0) {
		for ($fileIndex=0; $fileIndex < $itemCount; ++$fileIndex) {
			deleteUI -menuItem $items[$fileIndex];
		}
	}
	$gEditAddedChannels = $initString;
	$gImageFileNames = $initString;
	$gEditPsdFileName = "";
	$gPsdEditImageResX  = 0;
	$gPsdEditImageResY = 0;
	$gConnectedAttributes = $initString;
			
	// Get the shape object selected.
	string $psdEditShape = psdEditIsSelectedShapeProper();	
	if($psdEditShape == "")
		return;
	
	psdProcessImageFileNamesConnectedToShape($psdEditShape);
	
	// Add the list of image file names to the option menu.
	for($fileIndex = 0; $fileIndex < size($gImageFileNames); ++$fileIndex){
		menuItem -parent  ($psdEditFileNameOptionMenu + "|OptionMenu")  -label $gImageFileNames[$fileIndex] ;
	}

	// This case arises when the user has changed the selection of the PSD file without 
	// saving the addtion or deletion of the attributes from the previous PSD file. Here 
	// we try to shift to the selected file from the option menu	
	if(size($gEditPsdFileName) > 0)
	{
		string $shortName = `workspace -projectPath  $gEditPsdFileName`;
		optionMenuGrp -e -value $shortName $psdEditFileNameOptionMenu;
	}
	
	string $tmpFileName = `optionMenuGrp -q -value $psdEditFileNameOptionMenu`;
	$gEditPsdFileName = `workspace -expandName $tmpFileName`;
	psdEditProcessListForActiveFile( $gEditPsdFileName);
	
}

global proc psdEditProcessListForActiveFile(string $fileName)
{
	global string $psdEditDetailedLeftList, $psdEditTextureWin, $gEditPsdShape;
	
	string $psdEditShape = psdEditIsSelectedShapeProper();	
	if($psdEditShape == "")
		$psdEditShape = $gEditPsdShape;
		
	if($psdEditShape == "")
		return;
	// This list contains all the attributes, including those selected from the 
	// detailed attribute list. 	
	string $connectedAttributes[] = psdEditProcessForConnectedAttributes($fileName);
	if(size($connectedAttributes) == 0){
		window -e -visible false $psdEditTextureWin;
		error((uiRes("m_photoshopEditTexture.kNoPsdConnections")));
		return;
	}
	if(!`window -q -visible $psdEditTextureWin`){
		window -e -visible true $psdEditTextureWin;
	}
	// Fill the detaled list by calling the nodeOutliner command.
	// Get all the materials attached to this shape.
	string $tmpMaterialList[] = psdGetMaterialsGivenShape($psdEditShape);
	// Find the materials which are associated with the selected filename
	string $materialList[] = psdEditGetMaterialsForGivenFileAndShape($psdEditShape, $fileName, $tmpMaterialList);
	int $index;
	for($index = 0;  $index < size($tmpMaterialList); $index++)
	{
		// We need to list all the materials connected to the shape in the detailed attribute list.
		nodeOutliner -e -nc -showNonKeyable true -showReadOnly true 
									-showOutputs true -showInputs false 
									-a $tmpMaterialList[$index] $psdEditDetailedLeftList; 
	}
	// Update the short list with the selected shape for the selected file.
	psdEditUpdateShortListControl($psdEditShape, $connectedAttributes, $fileName);
	
	// Update the UV snap shot details
	psdEditEnableDisableUVSnapControl($psdEditShape);
	
}

global proc psdEditDetailedListCmd()
{
	global string $psdEditDetailedListCheckbox, $psdEditAttributeListLayout;
	
	int $checkBoxFlag = `checkBoxGrp -q -v1 $psdEditDetailedListCheckbox`;
	if($checkBoxFlag){
		tabLayout -e -selectTab editDetailedListLayout $psdEditAttributeListLayout;
	}else{
		tabLayout -e -selectTab editShortListLayout $psdEditAttributeListLayout;
	}
}

global proc psdEditRightButtonCmd()
{
	global string $psdEditDetailedLeftList, $psdDetlShrtList, $psdEditLeftList;
	global string $psdEditRightList, $psdXRes, $psdYRes, $psdEditDetailedListCheckbox ;
	global string $gPsdShadingEng[] ;
	global string $gPsdDetailedChannelList[] ;
	
	string $selectedItems[], $definedChannelTokens[], $tokens[];
	string $tempSelectedItems[];
	string $connectedItem, $imageFileName;
	int $index, $i, $selectItemIndex, $connIndex;
	
	int $checkBoxFlag = `checkBoxGrp -q -v1 $psdEditDetailedListCheckbox`;
	
	string $connectedItems[] = `psdChannelOutliner -q -allItems $psdEditRightList`;
	
	if($checkBoxFlag){
		// Do the processing for the detailed list.
		$selectedItems = `nodeOutliner -q -currentSelection  $psdEditDetailedLeftList`;
		if(size($selectedItems) == 0){
			error((uiRes("m_photoshopEditTexture.kNoChannelSelected")));
			return;
		}
		for($index = 0; $index < size($selectedItems); $index++)
		{
			for($connIndex = 0; $connIndex < size($connectedItems); $connIndex++)
			{
				// Check for the presence of bump in the right list.
				// If bump is found replace it with normalCamera
				// while doing a check, as, the detailed list recognizes
				// normalCamera and not bump.
				
				tokenize $connectedItems[$connIndex] "." $tokens;
				if($tokens[size($tokens) - 1] == "bump")
				{
					$connectedItem = $tokens[0] + ".normalCamera" ;
				}else{
					$connectedItem = $connectedItems[$connIndex];
				}
				 
				if($connectedItem == $selectedItems[$index])
					break;
			}
			if($connIndex == size($connectedItems))
			{
				tokenize $selectedItems[$index] "." $tokens;
				$imageFileName = psdCheckConnectionsForChannel($selectedItems[$index]);
				psdChannelOutliner -e 
										-psdParent  $tokens[0]
										-addChild $tokens[size($tokens) - 1] $imageFileName
										$psdEditRightList;
			}
		}
	}else{
		$tempSelectedItems = `psdChannelOutliner -q -selectItem $psdEditLeftList`;
		$selectItemIndex = 0;
		
		for ($index = 0; $index < size($tempSelectedItems); $index++){
		
			
			// We  return the list in the form "shader.channel" for the short list. 
			// So apply tokenize to get the channel name
				
			tokenize $tempSelectedItems[$index] "." $definedChannelTokens;
			// Delete the selected item from the left control.
			psdChannelOutliner -e 
									-psdParent  $definedChannelTokens[0]
									-removeChild $definedChannelTokens[size($definedChannelTokens) - 1]
									$psdEditLeftList;
			if($definedChannelTokens[size($definedChannelTokens) - 1] == "displacement"){
					string $shadingEngAttr[] = `listConnections -destination on -source off  ($definedChannelTokens[0] + ".outColor")`;
					if(size($shadingEngAttr) > 1){
						int $shadingEngIndex;
						for($shadingEngIndex = 0; $shadingEngIndex < size($shadingEngAttr); $shadingEngIndex++)
						{
							if(`nodeType $shadingEngAttr[$shadingEngIndex]` == "shadingEngine"){
									$shadingEngAttr[0] = $shadingEngAttr[$shadingEngIndex];
							}
						}
					}
					$definedChannelTokens[0] = $shadingEngAttr[0];
					$definedChannelTokens[1] = "displacementShader";
			}
								
			for($connIndex = 0; $connIndex < size($connectedItems); $connIndex++)
			{
				// Check for the presence of bump in the right list.
				// If normalCamera is found replace it with bump
				// while doing a check, as, the short list recognizes
				// bump and not normalCamera.
				
				tokenize $connectedItems[$connIndex] "." $tokens;
				if($tokens[size($tokens) - 1] == "normalCamera")
				{
					$connectedItem = $tokens[0] + ".bump";
				}else{
					$connectedItem = $connectedItems[$connIndex];
				}
				if($connectedItem == $tempSelectedItems[$index])
					break;
			}
			if($connIndex == size($connectedItems))
			{
				$imageFileName = psdCheckConnectionsForChannel($tempSelectedItems[$index]);
				psdChannelOutliner -e 
									-psdParent  $definedChannelTokens[0]
									-addChild $definedChannelTokens[size($definedChannelTokens) - 1] $imageFileName
									$psdEditRightList;
			}
		}
	}
}

global proc psdEditLeftButtonCmd()
//
//	Description:
//		This gets executed the left arrow button is pressed. This results 
//		in removal of some of the selected channels displayed in the
//		right side of the list. 
//
{
	global string $psdEditRightList, $psdEditLeftList, $gEditPsdShape, $gPsdChannelList[];
	
	string $selectedText[] = `psdChannelOutliner -q -selectItem $psdEditRightList`;
	if(size($selectedText) == 0){
		error(uiRes("m_photoshopEditTexture.kNoChannelSelected"));
		return;
	}
	
	int			$index, $channelIndex, $attrIndex;
	string	$tokens[], $imageFileName, $shadingEngAttr, $connectMatAttr, 
				$connectMatAttrTokens[], $attributeList[];
	
	
	string $psdShaders[] = psdGetMaterialsGivenShape($gEditPsdShape);
	$count = 0;
	for($index = 0; $index < size($psdShaders); $index++)
	{
		$attrConnections = `listAttr -r -o $psdShaders[$index]` ;
		// This is short list representation of channels of all the shaders attached to the shape object.
		for($channelIndex = 0; $channelIndex < size($gPsdChannelList); $channelIndex++)
		{
			string $tmpAttribute = $psdShaders[$index] + "." + $gPsdChannelList[$channelIndex]; 
			for($attrIndex = 0; $attrIndex < size($attrConnections); $attrIndex++)
			{
				if($attrConnections[$attrIndex] == $gPsdChannelList[$channelIndex] 
							|| $gPsdChannelList[$channelIndex] == "bump" || $gPsdChannelList[$channelIndex] == "displacement"){
					$attributeList[$count++] = $tmpAttribute;
					break;
				}
			}	
		}
	}
	
	string $allRightItemList[] = `psdChannelOutliner -q -allItems $psdEditRightList`;
	string $finalRightItems[] = stringArrayRemove($selectedText, $allRightItemList);
	
	string $finalLeftItemList[];
	$count = 0;
	for ($index = 0; $index < size($attributeList); $index++)
	{
		for($channelIndex = 0; $channelIndex < size($finalRightItems); $channelIndex++)
		{
			if($finalRightItems[$channelIndex] == $attributeList[$index])
				break;
		}
		if($channelIndex == size($finalRightItems)){
			$finalLeftItemList[$count++] = $attributeList[$index];
		}
	}
	
	
	for($index = 0; $index < size($selectedText); $index ++){
		// Tokenize to get the parent and child.
		tokenize $selectedText[$index] "." $tokens;
		psdChannelOutliner -e
								-psdParent  $tokens[0]
								-removeChild $tokens[size($tokens) -1]
								$psdEditRightList;
	}
	
	// We are trying to rearrange the attributes in the same order as before.
	psdChannelOutliner -e -removeAll $psdEditLeftList;
	
	for($index = 0; $index < size($finalLeftItemList); $index++)
	{
		tokenize $finalLeftItemList[$index] "." $tokens;	
		
		// Handle displacement channel separately.
								
		if($tokens[size($tokens)-1] == "displacementShader")
		{
			$shadingEngAttr = $tokens[0] + ".surfaceShader";
						
			// Take the incomming  connection from the shader to the Shading engine.	
			$connectMatAttr = `connectionInfo -sourceFromDestination $shadingEngAttr`;
			tokenize $connectMatAttr "." $connectMatAttrTokens;
			
			// When displacement shader attribute  is selected for deletion in the right window, put
			// back the channel as "displacement" under the appropriate shader in the left control.
			
			$tokens[0] = $connectMatAttrTokens[0] ;
			$tokens[size($tokens) -1] = "displacement" ;
		}
		
		$imageFileName = psdCheckConnectionsForChannel($finalLeftItemList[$index]);
		psdChannelOutliner -e 
									-psdParent  $tokens[0]
									-addChild $tokens[size($tokens) -1] $imageFileName
									$psdEditLeftList;
	}
}

global proc psdEditIncludeUVSnapShotCmd(int $switchFlag)
//Discription
//			Executes the command when UV snap shot check box
//			is made ON or OFF
//
{
	global string $psdEditAntiAlias, $psdEditUVLocation, $psdEditColorValueSlider;
	global string $psdEditUVListMenu;


	checkBoxGrp -e -enable1 $switchFlag $psdEditAntiAlias;
	colorSliderGrp -e -enable $switchFlag $psdEditColorValueSlider;
	radioButtonGrp -e -enable $switchFlag $psdEditUVLocation;
	
	
	if($switchFlag == 1){
		string $psdShape = psdEditIsSelectedShapeProper();		
		psdEditEnableDisableUVSnapControl($psdShape);
	}else{
		optionMenuGrp -e -enable $switchFlag $psdEditUVListMenu;
	}
}

global proc psdEditConvertSolidOptCmd()
{
	global string $psdEditRightList, $gConnectedAttributes[];
	
	string $itemList[] = `psdChannelOutliner -q -allItems $psdEditRightList`;
	if(size($itemList) == 0)
	   return;
	
	string $connectedChannels[], $imageName;   
	int $index, $count = 0, $connIndex;
	for($index = 0; $index < size($itemList); $index++)
	{
		for($connIndex = 0; $connIndex < size($gConnectedAttributes); $connIndex++)
		{
			if($gConnectedAttributes[$connIndex] == $itemList[$index])
				break;
		}
		if($connIndex <  size($gConnectedAttributes))
			continue;
		$imageName = psdCheckConnectionsForChannel($itemList[$index]);
		if(size($imageName) > 0)
		{
			$connectedChannels[$count] = $itemList[$index];
			$count++;
		}
	
	}
	if($count == 0)
	   return;
	   
	source psdConvertSolidTxPanel.mel;   
	psdConvertSolidTxPanel($connectedChannels);	
}

global proc psdEditFileNameChangeCmd()
{
	global string $psdEditFileNameOptionMenu, $gEditPsdFileName, $psdEditLeftList, 
					  $psdEditDetailedLeftList, $psdEditRightList, $gImageFileNames[], $gEditAddedChannels[],
					  $gEditDeletedChannels[], $gSelectedShape;
	
	string $tmpFileName = `optionMenuGrp -q -value $psdEditFileNameOptionMenu` ;
	
	if(size($gImageFileNames) > 0 && size($gEditPsdFileName) > 0 && psdEditProcessAddedAndDeletedChannels())
	{	
		string $yes = (uiRes("m_photoshopEditTexture.kYes"));
		string $warningMsg = `confirmDialog -title (uiRes("m_photoshopEditTexture.kWarning"))
											-ma "center"
											-message (uiRes("m_photoshopEditTexture.kAttrubeListModifiedMsg"))
											-button $yes -button (uiRes("m_photoshopEditTexture.kNo")) -defaultButton $yes `;
		if($warningMsg == $yes)
		{
			psdEditProcessSelectedAttributes(0, $gEditPsdFileName);
			select -clear;
			select -add $gSelectedShape;
		}	
	}
	psdChannelOutliner -e -removeAll $psdEditLeftList;
	nodeOutliner -e -removeAll $psdEditDetailedLeftList;
	psdChannelOutliner -e -removeAll $psdEditRightList;
	
	optionMenuGrp -e -value $tmpFileName $psdEditFileNameOptionMenu;
	$gEditPsdFileName = `workspace -expandName $tmpFileName`;
	psdEditProcessListForActiveFile($gEditPsdFileName);	 
}

global proc psdEditAssignShaderChangeScriptJobs(string $shape)
//Discription
//			Assign the script jobs to each of the channel's attribute, for the 
//			changes in the connections. 
//
{
	global string $gShapeSelectedForScriptJob ;
	global int $gShaderChangeScriptJobs[] ;
	
	int $initValues[];
	
	// Initialize the script jobs.
	$gShaderChangeScriptJobs = $initValues;
	string $shadingEngines[] = psdGetShadingEngines($shape);
	int $index;
	string $shadingEngAttr;
	for ($iindex = 0; $index < size($shadingEngines); $index++)
	{
		$shadingEngAttribute = $shadingEngines[$index] + ".surfaceShader";
		// Store the script jobs in the global variable.
		$gShaderChangeScriptJobs[$index] = `scriptJob -connectionChange $shadingEngAttribute "psdEditShaderChangeScriptJob"`;
	}
	$gShapeSelectedForScriptJob = $shape;
	
}

global proc psdEditKillShaderChangeScriptJobs()
{
	global int $gShaderChangeScriptJobs[] ;
	
	int $index, $initValues[];
	for ($iindex = 0; $index < size($gShaderChangeScriptJobs); $index++)
	{
		if(`scriptJob -exists $gShaderChangeScriptJobs[$index]`){
			scriptJob -kill $gShaderChangeScriptJobs[$index];
		}
	}
	$gShaderChangeScriptJobs = $initValues ;
}

global proc psdEditShaderChangeScriptJob()
{
	global string $gShapeSelectedForScriptJob, $psdEditTextureWin;
	if(!`window -q -visible $psdEditTextureWin`)
		return;
		
	if(size($gShapeSelectedForScriptJob) > 0)
	{
		select -r $gShapeSelectedForScriptJob;
	}
}

global proc photoshopEditTexture()
{
	global string $psdEditTextureWin, $psdEditFileNameOptionMenu, $psdEditIncludeUVSnapshot,
					   $psdEditUVListMenu, $psdEditAntiAlias, $psdEditLeftList,
					   $psdEditRightList, $psdEditAttributeListLayout, $psdEditDetailedLeftList,
					   $psdEditDetailedListCheckbox, $psdEditResXTextField, $psdEditResYTextField,
					   $psdEditUVLocation, $psdEditColorValueSlider, $psdEditOpenPhotoshop, $gEditPsdShape;
	global int	$gEditSelChangeScriptJob; 
	
					   
	string $shape= psdEditIsSelectedShapeProper();
	if($shape == "")
	{
		$shape = $gEditPsdShape;
	}
	if($shape == "")
	{
	    error((uiRes("m_photoshopEditTexture.kShapeSelectionError"))); 
		return;
	}
	
	if(`window -exists "psdEditTextureWindow"`) {
		psdEditCloseCmd(); // This is to initialize all the variables, when the window is about to show up.
		showWindow $psdEditTextureWin;
		window -e -visible true $psdEditTextureWin;
	}else{
		$psdEditTextureWin = `window -ret -rtf true -h 580 -w 490 
												-title (uiRes("m_photoshopEditTexture.kEditPSDNetworkOptions"))  
												psdEditTextureWindow`;

		string $texMenubar = `menuBarLayout editTexMenubarLayout`;
			string $editTexTopForm = `formLayout -p $texMenubar -numberOfDivisions 100 editTexTopForm`;
				string $scrollLayout = `scrollLayout -p $editTexTopForm  -childResizable true`;
					columnLayout -p $scrollLayout  -adjustableColumn 1 psdEditTopLayout;
							frameLayout -label (uiRes("m_photoshopEditTexture.kImageDetails"))  
								-collapsable true 
								-marginHeight 10 
								fileDetailsFrameLayout;
								
								columnLayout -adjustableColumn 1  -rowSpacing 5 psdImgDetailsLayout;
										rowLayout -nc 2 psdRowImageNameLayout;
											$psdEditFileNameOptionMenu = `optionMenuGrp
																								-cw 1 115 
																								-label (uiRes("m_photoshopEditTexture.kImageName"))  
																								-changeCommand  "psdEditFileNameChangeCmd"
																								psdFileName`;
											text -label "";
										setParent ..;

											//add check box for launching photoshop
										
										$psdEditOpenPhotoshop = `checkBoxGrp -numberOfCheckBoxes 1 
																					-adj 1
																					-cat 1 "left" 117
																					-label1 (uiRes("m_photoshopEditTexture.kOpenAdobeRPhotoshopR"))  
																					psdEditOpenPhotoshopCheckBox`;	
					

										rowLayout 
															-nc 2 
															-ct2 "both" "both"
															-cw 1 115
															-cw 2 80 
															psdEditResXRowLayout;
											text -align "right" -label (uiRes("m_photoshopEditTexture.kSizeX")) ;
											$psdEditResXTextField = `intField -editable false psdEditResX`;											
										setParent ..;

										rowLayout 
															-nc 2 
															-ct2 "both" "both"
															-cw 1 115 
															-cw 2 80  
															psdEditResYRowLayout;
											text -align "right" -label (uiRes("m_photoshopEditTexture.kSizeY")) ;
											$psdEditResYTextField = `intField -editable false psdEditResY`;
										setParent ..;

								setParent ..; // columnLayout
							setParent ..; // frame layout

							frameLayout -label (uiRes("m_photoshopEditTexture.kUVDetails"))  
								-collapsable true -marginHeight 2 uvDetailsFrameLayout;
								columnLayout   -rowSpacing 5 psdEditUVSnapColumnLayout ;

									$psdEditIncludeUVSnapshot = `checkBoxGrp -numberOfCheckBoxes 1 
																					-cat 1 "left" 117 
																					-label1 (uiRes("m_photoshopEditTexture.kIncludeUVSnapshot")) 
																					-value1 1
																					-cc1 ("psdEditIncludeUVSnapShotCmd #1")
																					psdEditIncludeUVSnapshotChkBox`;
									string $top = (uiRes("m_photoshopEditTexture.kTop"));
									$psdEditUVLocation = `radioButtonGrp -numberOfRadioButtons 2
													-cw 1 115
													-cw 2 60
													-cw 3 60
													-select 1
 													-label (uiRes("m_photoshopEditTexture.kPosition"))  
 													-annotation (uiRes("m_photoshopEditTexture.kPositionOfTheUVSnapshotLayerAnnot")) 
 													-labelArray2 $top (uiRes("m_photoshopEditTexture.kBottom")) psdEditUVLocation`;

									$psdEditUVListMenu = `optionMenuGrp 
																			-cw 1 115
																			-label (uiRes("m_photoshopEditTexture.kUVSet"))   
																			psdEditUVSetList`;
									$psdEditColorValueSlider = `colorSliderGrp 
																		-cw 1 115
																		-cw 2 80
																		-label (uiRes("m_photoshopEditTexture.kColorValue")) 
																		-rgb 1. 1. 1.
																		psdEditColorSlider`;
									$psdEditAntiAlias = `checkBoxGrp 
															-numberOfCheckBoxes 1 
															-cat 1 "left" 117 
															-label1 (uiRes("m_photoshopEditTexture.kAntialiasLines"))  psdEditAntiAliasChkBox`;


       							setParent ..;
       						setParent ..;
       						string $selectedAttributes = (uiRes("m_photoshopEditTexture.kSelectedAttributes"));

							frameLayout -label $selectedAttributes  
								-collapsable true 
								-marginWidth 10 -marginHeight 10 	attrDetailsFrameLayout;
								columnLayout   -cat  "left" 10  -rowSpacing 5 psdEditAttributesColumnLayout ;
										rowLayout -nc 4
													-cw4 195 20 20 195
													-columnAttach 1 "both"  0
													-columnAttach 2 "both"  0
													-columnAttach 3 "both"  0;
											columnLayout -adj true;
												text -align "left" -label (uiRes("m_photoshopEditTexture.kAttributes")) ;

												$psdEditAttributeListLayout = `tabLayout -tabsVisible false psdEditAttributeListLayout`;
													columnLayout -adj true editDetailedListLayout;
														$psdEditDetailedLeftList = `nodeOutliner -showInputs true 
								 												-height 175
								 												-showNonConnectable false 
																				-showConnectedOnly false  
								 												-showNonKeyable true 
																				-showHidden  false
        						 												-ms true 			
        						 												psdEditDetailedLeftList`;
													setParent ..;

													columnLayout -adj true editShortListLayout;
														$psdEditLeftList = `psdChannelOutliner -height 175 
																				-doubleClickCommand "psdEditRightButtonCmd"
        																		psdEditLeftList`;
													setParent ..;
												setParent ..;

												$psdEditDetailedListCheckbox = `checkBoxGrp -numberOfCheckBoxes 1 
																				-cw 1 150
																				-changeCommand "psdEditDetailedListCmd"
																				-label1 (uiRes("m_photoshopEditTexture.kDetailedAttributeList")) 
																				psdEditDetailedListCheckboxGrp`;
											setParent ..;

											button -label "<" -c "psdEditLeftButtonCmd" psdEditLeftButton;
											button -label ">" -c "psdEditRightButtonCmd" psdEditRightButton;

											columnLayout -adj true;
												text -align "left" -label $selectedAttributes ;

												$psdEditRightList = `psdChannelOutliner	-height 175
																		-doubleClickCommand "psdEditLeftButtonCmd" 
																		psdRightList`;

												button -label (uiRes("m_photoshopEditTexture.kConvertToFileTextureOptions"))  -c "psdEditConvertSolidOptCmd" psdEditConvertSolidButton;
											setParent ..;
										setParent ..;

								setParent ..; //psdEditAttributesColumnLayout
							setParent ..; // attrDetailsFrameLayout
					setParent.. ; // psdEditTopLayout
				setParent.. ; // scrollLayout
					
					string $psdEditButtonForm = `formLayout psdEditButtonForm`;
						button -label (uiRes("m_photoshopEditTexture.kEditButton")) -p $psdEditButtonForm -c "psdEditCmd" psdEditConvClButton;																			
						button -label (uiRes("m_photoshopEditTexture.kApply"))  -p $psdEditButtonForm  -c "psdEditApplyCmd" psdEditConvButton;
						button -label (uiRes("m_photoshopEditTexture.kClose"))  -p $psdEditButtonForm -c "psdEditCloseCmd" psdEditClButton;
					setParent ..;
					
					formLayout -edit
							-af psdEditConvClButton "bottom" 5
							-af psdEditConvClButton "left" 5
							-ap psdEditConvClButton "right" 3 33

							-af psdEditConvButton "bottom" 5 
							-ap psdEditConvButton "left" 2 33
							-ap psdEditConvButton "right" 3 66

							-af psdEditClButton "bottom" 5
							-ap psdEditClButton "left" 2 66
							-af psdEditClButton "right" 5
					$psdEditButtonForm;
			
		setParent ..; // editTexTopForm
		
		formLayout -e 
						
						-af $scrollLayout "left" 0
						-af $scrollLayout "right" 0
						-af $scrollLayout "top" 0
						-ac $scrollLayout "bottom" 5 $psdEditButtonForm
						
						
						-af $psdEditButtonForm "left" 0
						-af $psdEditButtonForm "right" 0
						-af $psdEditButtonForm "bottom" 0
						
						$editTexTopForm;
		
		buildPsdEditTextureWindowMenu;			
		showWindow $psdEditTextureWin;
		setParent ..;
		psdEditSetFactorySettings(0);
								
	}
	psdEditKillShaderChangeScriptJobs();
	psdEditAssignShaderChangeScriptJobs($shape);	
	$gEditSelChangeScriptJob = `scriptJob -parent $psdEditTextureWin -event "SelectionChanged" "psdEditUpdateWithSelectionChange"`;
	$gEditPsdShape = $shape;
	
	psdEditUpdateWithSelectionChange();
}
