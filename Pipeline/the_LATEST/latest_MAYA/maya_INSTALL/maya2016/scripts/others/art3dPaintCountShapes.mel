// Copyright (C) 1997-2014 Autodesk, Inc., and/or its licensors.
// All rights reserved.
//
// The coded instructions, statements, computer programs, and/or related
// material (collectively the "Data") in these files contain unpublished
// information proprietary to Autodesk, Inc. ("Autodesk") and/or its licensors,
// which is protected by U.S. and Canadian federal copyright law and by
// international treaties.
//
// The Data is provided for use exclusively by You. You have the right to use,
// modify, and incorporate this Data into other products for purposes authorized 
// by the Autodesk software license agreement, without fee.
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND. AUTODESK
// DOES NOT MAKE AND HEREBY DISCLAIMS ANY EXPRESS OR IMPLIED WARRANTIES
// INCLUDING, BUT NOT LIMITED TO, THE WARRANTIES OF NON-INFRINGEMENT,
// MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE, OR ARISING FROM A COURSE 
// OF DEALING, USAGE, OR TRADE PRACTICE. IN NO EVENT WILL AUTODESK AND/OR ITS
// LICENSORS BE LIABLE FOR ANY LOST REVENUES, DATA, OR PROFITS, OR SPECIAL,
// DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES, EVEN IF AUTODESK AND/OR ITS
// LICENSORS HAS BEEN ADVISED OF THE POSSIBILITY OR PROBABILITY OF SUCH DAMAGES.

proc string[] uniqueTransformNodes(
	string  $transNodes[]
)
//
//  Description:
//  	Eliminate all the double transform nodes, so the return list
//		has all the unique ones.
//
{
	string	$uniqTrans[];
	int		$transIdx = 0;

	for ( $trans in $transNodes ) {
		int $skip = 0;
		for ($tmpTrans in $uniqTrans ) {
			if ( $trans == $tmpTrans ) {
				$skip = 1;
				break;
			}
		}

		// add it to the list
		if ( $skip == 0 ) {
			$uniqTrans[$transIdx] = $trans;
			$transIdx ++;
		}
	}
	return $uniqTrans;
}


global proc int art3dPaintCountShapes(
	string 	$shader
) 
//
// Description:
//		Returns number of paintable shapes connected 
//		to a given shader. We need to eliminate all 
//		the intermediate objects from counting.
//
{
	int $numShapes = 0;

	string 	$shaderPlug = $shader + ".outColor";
	string 	$shEngs[] 	= `listConnections $shaderPlug`;

	int $intermediate = 0;
	for( $sE in $shEngs ) {
		string $shEngPlug 	 = $sE + ".dagSetMembers";

		// bug id 150916, skip layered shaders
		if( `objExists $shEngPlug` == 0 )	
			continue;

		string $transNodes[] = `listConnections $shEngPlug`; 
		string $trans[] 	 = uniqueTransformNodes( $transNodes );

		for ($t in $trans) {
			string $shapes[] = `listRelatives -shapes -pa $t`; 
			for ( $s in $shapes ) {
				// Skip the intermediate objects.
				$intermediate = `getAttr ($s + ".intermediateObject")`;
        		if ( $intermediate ) continue; 

				$numShapes ++;
			}
		}
	}

	return $numShapes;
}
