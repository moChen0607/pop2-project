// Copyright (C) 1997-2014 Autodesk, Inc., and/or its licensors.
// All rights reserved.
//
// The coded instructions, statements, computer programs, and/or related
// material (collectively the "Data") in these files contain unpublished
// information proprietary to Autodesk, Inc. ("Autodesk") and/or its licensors,
// which is protected by U.S. and Canadian federal copyright law and by
// international treaties.
//
// The Data is provided for use exclusively by You. You have the right to use,
// modify, and incorporate this Data into other products for purposes authorized 
// by the Autodesk software license agreement, without fee.
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND. AUTODESK
// DOES NOT MAKE AND HEREBY DISCLAIMS ANY EXPRESS OR IMPLIED WARRANTIES
// INCLUDING, BUT NOT LIMITED TO, THE WARRANTIES OF NON-INFRINGEMENT,
// MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE, OR ARISING FROM A COURSE 
// OF DEALING, USAGE, OR TRADE PRACTICE. IN NO EVENT WILL AUTODESK AND/OR ITS
// LICENSORS BE LIABLE FOR ANY LOST REVENUES, DATA, OR PROFITS, OR SPECIAL,
// DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES, EVEN IF AUTODESK AND/OR ITS
// LICENSORS HAS BEEN ADVISED OF THE POSSIBILITY OR PROBABILITY OF SUCH DAMAGES.

//
//
//	Creation Date:  April, 2001
//
//  Procedure Name:
//      removeUnusedInfluences
//
//  Description:
//    For selected skin objects, check for any joints or influence objects
//    that have no effect on the skin (i.e. all weights are 0.0). Remove
//    those joints as influence objects to improve performance.
//
//  Input Arguments:
//      None.
//
//  Return Value:
//      None.
//
//
//

global proc int removeUnusedForSkin(string $skinCluster, int $verbose)
{
	int $removeCount = 0;
	string $infls[] = `skinCluster -q -inf $skinCluster`;
	string $wtinfs[] = `skinCluster -q -wi $skinCluster`;
		
	// Set skinCluster to HasNoEffect so it won't process after each removal
	//
	int $nodeState = `getAttr ($skinCluster+".nodeState")`;
	setAttr ($skinCluster+".nodeState") 1;
	for ($infl in $infls) {
		int $found = 0;
		for ($wtinf in $wtinfs) {
			if ($wtinf == $infl) {
				$found = 1;
				break;
			}
		}
		if (! $found) {
			// remove the influence since it has no effect
			//
			string $cmd = ("skinCluster -e -ri "+$infl+" "+$skinCluster);
			$removeCount++;
			if ($verbose) {
				evalEcho($cmd);
			} else {
				eval $cmd;
			}
		}
	}
	// restore the old node state
	//
	setAttr ($skinCluster+".nodeState") $nodeState;
	return $removeCount;
}

global proc int removeUnusedInfluences()
{
	string $sel[] = `ls -sl`;
	if (size($sel) == 0) {
		error( (uiRes("m_removeUnusedInfluences.kNoSkinsSel")));
	}
	int $counter = 0;
	int $totalRemoveCount = 0;
	for ($selobj in $sel) {
		// find the skinCluster on the selected object
		//
		string $skinCluster = findRelatedSkinCluster($selobj);
		if ($skinCluster == "") {
			continue;
		}
		$counter++;
		int $removeCount = removeUnusedForSkin($skinCluster,1);

		if (0 == $removeCount) {
			string $infoFormat = (uiRes("m_removeUnusedInfluences.kAllUnusedAlreadyRemoved"));
			string $infoStr = `format -stringArg $selobj $infoFormat`;
			print $infoStr;
		} else {
			string $infoFormat = (uiRes("m_removeUnusedInfluences.kRemoveUnused"));
			string $infoStr = `format -stringArg $removeCount -stringArg $selobj $infoFormat`;
			print $infoStr;
		}
		$totalRemoveCount += $removeCount;
	}
	if (0 == $counter) {
		error( (uiRes("m_removeUnusedInfluences.kNoSkinsSelected")));
	}
	return $totalRemoveCount;
}
