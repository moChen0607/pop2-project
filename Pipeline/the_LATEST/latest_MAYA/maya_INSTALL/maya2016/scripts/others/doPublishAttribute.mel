// Copyright (C) 1997-2014 Autodesk, Inc., and/or its licensors.
// All rights reserved.
//
// The coded instructions, statements, computer programs, and/or related
// material (collectively the "Data") in these files contain unpublished
// information proprietary to Autodesk, Inc. ("Autodesk") and/or its licensors,
// which is protected by U.S. and Canadian federal copyright law and by
// international treaties.
//
// The Data is provided for use exclusively by You. You have the right to use,
// modify, and incorporate this Data into other products for purposes authorized 
// by the Autodesk software license agreement, without fee.
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND. AUTODESK
// DOES NOT MAKE AND HEREBY DISCLAIMS ANY EXPRESS OR IMPLIED WARRANTIES
// INCLUDING, BUT NOT LIMITED TO, THE WARRANTIES OF NON-INFRINGEMENT,
// MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE, OR ARISING FROM A COURSE 
// OF DEALING, USAGE, OR TRADE PRACTICE. IN NO EVENT WILL AUTODESK AND/OR ITS
// LICENSORS BE LIABLE FOR ANY LOST REVENUES, DATA, OR PROFITS, OR SPECIAL,
// DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES, EVEN IF AUTODESK AND/OR ITS
// LICENSORS HAS BEEN ADVISED OF THE POSSIBILITY OR PROBABILITY OF SUCH DAMAGES.


//
//  Description:
//      Publish attributes
//		
//
proc string getSafeAttrName(string $plug)
{
	string $attr = plugAttr($plug);
	if (size($attr) == 0) {
		$attr = $plug;
	}
	$attr = substituteAllString($attr,"[","");
	$attr = substituteAllString($attr,"]","");
	$attr = substituteAllString($attr,".","_");	
	return $attr;
}

global proc string customPublishedName( string $plug,
										int $namingConvention,
										string $customName )
//
//	Description:
//		Given the plug to be published, the naming convention, and the optional
//	custom name, return the resulting published name.
//
//	Inputs:
//		$plug				: plug to be published
//		$namingConvention	: 0 - make unique by adding a number
//							  1 - prepend the plug's node name
//							  2 - prepend the custom name
//							  3 - use the custom name
//		$customName			: custom name for $namingConvention 2 & 3
//
//	Return Value:
//		resulting published name
//
{
	string $node = plugNode($plug);
	string $longAttrName[];
	if (`container -q -isContainer $node`) {
		$longAttrName[0] = plugAttr($plug);
	} else {
		$longAttrName = `listAttr $plug`;
		$plug = ($node+"."+$longAttrName[0]);
	}
	
	string $publishName = $customName;
	switch ($namingConvention) {
	case 0:
		$publishName = `getSafeAttrName $plug`;
		break;
	case 1: 
	{
		string $nodeName = `plugNodeStripped $plug`;
		$publishName = ($nodeName + "_" + `getSafeAttrName $plug`);
	}
		break;
	case 2:
		$publishName = ($customName+ "_" + `getSafeAttrName $plug`);
		break;
	case 3:
		$publishName = $customName;
		break;
	}
	return( $publishName );
}

global proc publishTheAttr(string $plug,
						   string $container, 
						   string $prePublished[],
						   int $namingConvention,
						   string $customName)
{
	string $publishedAs[] = `container -q -publishName -publishAttr $plug $container`;
	if (size($publishedAs) > 0 ||
		stringArrayContains($plug,$prePublished)) {
		// attribute is already published
		//
		string $publishFormat = (uiRes("m_doPublishAttribute.kPublishedAttrSkip"));
		string $msg = `format -stringArg $plug $publishFormat`;
		warning($msg);
		return;
	}

	string $publishName = customPublishedName( $plug, $namingConvention,
												$customName );
	$publishName = `container -e -pn $publishName $container`;
	container -e -ba $plug $publishName $container;

	string $publishFormat = (uiRes("m_doPublishAttribute.kPublishedAttrMsg"));
	string $msg = `format -stringArg $plug -stringArg $container $publishFormat`;
	print $msg;
}


global proc doPublishAttribute( int $version, string $args[] )
//
// Description:
//	Publish attributes on their container according
//  to the specified flags described below.
//
// $version == 1:
//	$args[0] = which attribute to publish
//		which attributes = 0 : use selected in channel box
//		which attributes = 1 : all keyable
//		which attributes = 2 : incoming connections
//		which attributes = 3 : selected attributes
//  $args[1] = naming convention
//      naming convention = 0 : attribute name plus numerical suffix
//      naming convention = 1 : node name + attribute name
//      naming convention = 2 : custom string + attribute name
//      naming convention = 3 : custom string
//  $args[2] = custom string for use if naming convention == 2 or 3
//		
//
{
	int $whichAttrs = $args[0];
	int $namingConvention = $args[1];
	string $customName = $args[2];
	string $sel[] = `ls -sl -type TdependNode`; // type used to ignore component selections
	if (size($sel) == 0) {
		error((uiRes("m_doPublishAttribute.kNothingSelected")));
	}
	if (($namingConvention == 3 || $namingConvention == 2) &&
		(size($customName) == 0)) {
		error((uiRes("m_doPublishAttribute.kCustomNameProblem")));
	}

	string $noAttrsMsg;
	string $attrs[];
	string $container = `container -q -fc $sel`;
	switch ($whichAttrs) {
	case 0: {
		$attrs = `selectedChannelBoxPlugs`;
		if (size($attrs) > 0) {
			string $attrNode = plugNode($attrs[0]);
			$container = `container -q -fc { $attrNode }`;
		}
		$noAttrsMsg = (uiRes("m_doPublishAttribute.kNoChannelBoxAttrs"));
		break;
	}
	case 1: {
		for ($obj in $sel) {
			string $keyable[] = `listAttr -keyable -scalar $obj`;
			if (`objectType -isa transform $obj`) {
				// use the expected transform ordering (TRSV)
				//
				string $transAttrs[] = { "translateX", "translateY", "translateZ", "rotateX", "rotateY", "rotateZ", "scaleX", "scaleY", "scaleZ", "visibility" };
				for ($tAttr in $transAttrs) {
					if (stringArrayContains($tAttr,$keyable)) {
						$attrs[size($attrs)] = ($obj+"."+$tAttr);
					}
				}
				string $remainingKeyable[] = stringArrayRemove($transAttrs,$keyable);
				$keyable = $remainingKeyable;
			}
			for ($keyAttr in $keyable) {
				string $multis[] = `plugMultiAttrs ($obj+"."+$keyAttr)`;
				if (size($multis) > 0) {
					string $testAttr = ($obj+"."+$multis[size($multis)-1]);
					if (!stringArrayContains($testAttr,$attrs)) {
						$attrs[size($attrs)] = $testAttr;
					}
				} else {
					$attrs[size($attrs)] = ($obj+"."+$keyAttr);
				}
			}
		}
		$noAttrsMsg = (uiRes("m_doPublishAttribute.kNoKeyableAttrs"));
		break;
	}
	case 2: {
		for ($obj in $sel) {
			string $conns[] = `listConnections -destination 0 -connections 1 $obj`;
			int $len = size($conns);
			for ($ii = 0; $ii < $len; $ii += 2) {
				$attrs[size($attrs)] = $conns[$ii];
			}
		}
		$noAttrsMsg = (uiRes("m_doPublishAttribute.kNoIncomingConns"));
		break;
	}
	case 3: {
		string $sels[] = `ls -sl`;
		string $plug;
		for( $plug in $sels ){
			string $node = `plugNode $plug`;
			if( stringArrayContains( $node, $sel ) ){
				if( `plugAttr $plug` != "" ){
					$attrs[size($attrs)] = $plug;
				}
			}
		}
		$noAttrsMsg = (uiRes("m_doPublishAttribute.kNoSelectedAttrs"));
		break;
	}
	}

	if (size($attrs) == 0) {
		error($noAttrsMsg);
	}

	int $publishingError = 0;
	int $foundContainer = 0;
	waitCursor -state on;
	if (size($container) > 0) {
		string $prePublished[] = `container -q -ba $container`;
		for ($attr in $attrs) {
			if (catch(publishTheAttr($attr,$container,$prePublished,
									 $namingConvention,$customName))) {
				// stop if we hit an error
				//
				$publishingError = 1;
				break;
			}
		}
		$foundContainer = 1;
	} else {
		// selected nodes are on multiple containers
		//
		for ($obj in $sel) {
			$container = `container -q -fc { $obj }`;
			if (size($container) == 0) {
				if ($whichAttrs != 0) {
					string $format = (uiRes("m_doPublishAttribute.kSkippingNode"));
					string $warnStr = `format -stringArg $obj $format`;
					warning $warnStr;
				}
			} else {
				string $prePublished[] = `container -q -ba $container`;
				$foundContainer = 1;				
				for ($attr in $attrs) {
					if (plugNode($attr) == $obj) {
						if (catch(publishTheAttr($attr,$container,
												 $prePublished,
												 $namingConvention,
												 $customName))) {
							// stop if we hit an error
							//
							$publishingError = 1;
							break;
						}
					}
				}
			}
			if ($publishingError) break;
		}
	}
	waitCursor -state off;
	
	if (0 == $publishingError && 0 == $foundContainer) {
		error((uiRes("m_doPublishAttribute.kSelectedNotInContainer")));
	}
}
