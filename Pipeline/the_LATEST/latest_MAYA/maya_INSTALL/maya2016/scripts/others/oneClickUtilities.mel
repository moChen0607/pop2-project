// Copyright (C) 1997-2014 Autodesk, Inc., and/or its licensors.
// All rights reserved.
//
// The coded instructions, statements, computer programs, and/or related
// material (collectively the "Data") in these files contain unpublished
// information proprietary to Autodesk, Inc. ("Autodesk") and/or its licensors,
// which is protected by U.S. and Canadian federal copyright law and by
// international treaties.
//
// The Data is provided for use exclusively by You. You have the right to use,
// modify, and incorporate this Data into other products for purposes authorized 
// by the Autodesk software license agreement, without fee.
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND. AUTODESK
// DOES NOT MAKE AND HEREBY DISCLAIMS ANY EXPRESS OR IMPLIED WARRANTIES
// INCLUDING, BUT NOT LIMITED TO, THE WARRANTIES OF NON-INFRINGEMENT,
// MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE, OR ARISING FROM A COURSE 
// OF DEALING, USAGE, OR TRADE PRACTICE. IN NO EVENT WILL AUTODESK AND/OR ITS
// LICENSORS BE LIABLE FOR ANY LOST REVENUES, DATA, OR PROFITS, OR SPECIAL,
// DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES, EVEN IF AUTODESK AND/OR ITS
// LICENSORS HAS BEEN ADVISED OF THE POSSIBILITY OR PROBABILITY OF SUCH DAMAGES.

//
// Check whether the previously sent object list contains items still
// in the scene
//
global proc
string[] validatePreviousSendList(string $previousSendList[])
{
	string $stillAround[];
	for ($obj in $previousSendList) {
		if (`objExists $obj`) {
			$stillAround[size($stillAround)] = $obj;
		}
	}
	if (size($stillAround) != size($previousSendList)) {
		clear($previousSendList);
		$previousSendList = $stillAround;
	}
	return $stillAround;
}

global proc
string[] getEntireSceneNoCameras()
{
	string $entireScene[] = `ls -type dagNode`;

	// exclude the cameras from the list
	//
	string $cams[] = `ls -type camera`;	
	string $cameraParents[];
    int $camCount = size($cams);
	for ($ii = 0; $ii < $camCount; $ii++) {
		string $parent[] = `listRelatives -path -parent $cams[$ii]`;
		$cams[size($cams)] = $parent[0];
	}
	string $sceneNoCams[] = stringArrayRemoveExact($cams,$entireScene);
	return $sceneNoCams;
}

global proc oneClickSelectRoot( string $dagNode )
{
	if (`objectType -isa "dagNode" $dagNode`) {
		// select the top item in the hierarchy of the dagNode
		//
		string $fullPath[] = `ls -long $dagNode`;
		string $buffer[];
		if (tokenize($fullPath[0],"|",$buffer))
		{
			if (size($buffer) > 0 ) 
			{
				// Only modify the selection if the object is not already selected. Otherwise
				// needless messages and other checks are performed.
				//
				string $checkSel[] = `ls -sl ("|"+$buffer[0])`;
				if (size($checkSel) == 0) {
					select -add ("|"+$buffer[0]);
				}
			}
		}
	}
}

global proc addBlendShapeTargetsForSelection()
//
// If a blendShaped geometry is selected, add the targets
//	
{
	string $blendShapes[] = `ls -type blendShape`;
	string $targetsToAdd[];

	for ($blendShape in $blendShapes)
	{
		int $exportTargets = 0;
		string $meshes[] = `deformer -q -geometry $blendShape`;
		for ($mesh in $meshes) {
			string $checkSel[] = `ls -sl $mesh`;
			if (size($checkSel) > 0) {
				$exportTargets = 1;
				break;
			}
		}
		if ($exportTargets) {
			string $targets[] = `blendShape -q -target $blendShape`;
			for ($target in $targets) {
				string $checkTarget[] = `ls -sl $target`;
				if (size($checkTarget) == 0) {
					$targetsToAdd[size($targetsToAdd)] = $target;
				}
			}
			// also, if any base shapes were not selected, get them also
			//
			for ($mesh in $meshes) {			
				string $checkSel[] = `ls -sl $mesh`;
				if (size($checkSel) == 0) {
					$targetsToAdd[size($targetsToAdd)] = $mesh;
				}
			}
		}
	}
	if (size($targetsToAdd) > 0) {
		select -add $targetsToAdd;
	}
}


global proc addSkinRelatedToSelection()
//
// Select meshes bound to the selected transforms
//	
{
	string $influences[] = `ls -sl -type transform`;
	
	if( size( $influences ) > 0 )
	{
		string $skinClusters[] = `listConnections -s 0 -d 1 -type skinCluster $influences`;
		string $meshesToAdd[];
		
		for( $skinCluster in $skinClusters )
		{
			string $meshes[] = `deformer -q -geometry $skinCluster`;
			
			if( size($meshes) > 0 )
			{
				for ($mesh in $meshes) {
					// Only modify the selection if the object is not already selected. Otherwise
					// needless messages and other checks are performed.
					//
					string $checkSel[] = `ls -sl $mesh`;
					if (size($checkSel) == 0) {
						$meshesToAdd[size($meshesToAdd)] = $mesh;
					}
				}
			}
		}

		if (size($meshesToAdd) > 0) {
			select -add $meshesToAdd;
		}
	}
}

global proc
oneClickConstraintTargetValidation(string $constraintsToIgnore[])
//
// Check all selected constraints (other than $constraintsToIgnore).
// Deselect the constraint if all of its targets are not selected.
//
{
	// Build up the arrach and deselect all at once because it is
	// much better for performance.
	//
	string $constraintsToDeselect[];
	string $newConstraints[] = `ls -sl -type constraint`;

	for( $constraint in $newConstraints )
	{
		// Identify newly added constraints
		if( !stringArrayContains( $constraint, $constraintsToIgnore ) )
		{
			// Validate if all their targets are also selected
			string $allConns[] = `listConnections -s 1 -d 0 -type dagNode $constraint`;
			string $targets[] = stringArrayRemoveDuplicates($allConns);

			string $selectedTarget[];
			if( size( $targets ) > 0 )
			{
				$selectedTarget = `ls -sl $targets`;
			}
			
			if( size($selectedTarget) != size($targets) )
			{
				// Not all the targets were selected, so we don't want this 
				// constraint
				//
				$constraintsToDeselect[size($constraintsToDeselect)] = $constraint;
			}
		}
	}
	
	if (size($constraintsToDeselect) > 0) {
		select -deselect $constraintsToDeselect;
	}
}

global proc
string getOneClickSendFilename(string $nameInfo)
{   
   	string $tmpdir = `getenv "ONECLICK_TEMP_DIR"`;

	if( size( $tmpdir ) > 0 )
	{ 
        $tmpdir = fromNativePath( $tmpdir ) +"/";
	}
    else
    {
    	$tmpdir = `internalVar -userTmpDir`;
    }

    
	string $filename = ($tmpdir+$nameInfo);
	int $rn = rand(1e6);
	$filename += ($rn+".fbx");
	if (`filetest -e $filename`) {
		$filename = getOneClickSendFilename($nameInfo);
	}
	return $filename;
}

global proc
int getOneClickRestrictedUpdateVal()
{
	int $restrictedUpdate = 0;
	string $controlVar = tolower( `getenv "ONECLICK_SELECT_WHOLE_CHARACTER"` );
	if( ($controlVar != "maya") && ($controlVar != "all") )
	{ 
		$restrictedUpdate = 1;
	}
	return $restrictedUpdate;
}

global
proc string doOneClickSendOperation(string $fbxPresetCmd,
									string $fileNameString,
									int $restrictedUpdate,
									string $camName,
									string $isDefaultCam,
									int $includeConnections,
                                    int $embedTextures      )
{
	if (! `pluginInfo -q -loaded fbxmaya`) {
		loadPlugin fbxmaya;
	}
	
	string $newCamName;
	
	if (size($camName) > 0) {
		if ($isDefaultCam) {
			// FBX will not transfer the default cameras such as "top",
			// "persp" so we create a duplicate for use during the
			// transfer. It is deleted after the transfer.
			//
			string $result[] = `duplicate $camName`;
			$newCamName = `rename $result[0] MayaCamera`;
			lookThru $newCamName;
			select -add $newCamName;
		} else {
			string $activeCamSel[] = `ls -sl $camName`;
			if (size($activeCamSel) == 0) {
				// select the active camera so that it will be transferred
				//
				select -add $camName;
			} else {
				// Reset the camera name as an indicator that it was
				// already selected and should not be deselected after the
				// transfer.
				//
				$camName = "";
			}
		}
	}
	
	string $filename = `getOneClickSendFilename($fileNameString)`;

	// Save all import+export IOSettings
	//
	FBXPushSettings;
	
	// Load default presets
	//
	if (size($fbxPresetCmd) > 0) {
		eval $fbxPresetCmd;
	}
	
	if( $restrictedUpdate )
	{
		if ($includeConnections) {
			FBXExportInputConnections -v true;
		} else {
			FBXExportInputConnections -v false;			
		}
        // FBXExportBakeResampleAnimation -v true;
		FBXProperty "Export|IncludeGrp|Animation|CurveFilter" -v true;
		FBXExportApplyConstantKeyReducer -v true;
	}

    if( $embedTextures )
    {
        FBXExportEmbeddedTextures -v true;
    }

	// Save the file
	//
	FBXExport -f $filename -s;
	
	// Restore all import+export IOSettings from the push
	//
	FBXPopSettings;
	
	if (size($camName) > 0) {
		if (size($newCamName) > 0) {
			lookThru $camName;
			delete $newCamName;
		} else {
			select -d $camName;
		}
	}
	return $filename;
}

global
proc string doOneClickReceiveOperation(string $fbxPresetCmd,
									   string $filename,
									   int $newScene,
									   int $addFlag,
                                       int $performAnimTimeUnion )
{
	string $result = "";
	int $performReceive = 1;
	if ($newScene) {
		// import the file as a new scene
		//
		string $newSceneCmd = `performNewScene 2`;
		int $newScenePerformed = eval($newSceneCmd);
		if(!$newScenePerformed) {
			// Save operation cancelled
			$performReceive = 0;
		}
	}

	if ($performReceive) {
		if (! `pluginInfo -q -loaded fbxmaya`) {
			loadPlugin fbxmaya;
		}
		
		// Save all import+export IOSettings
		//
		FBXPushSettings;

		// Load the FBX import preset
		//
		if (size($fbxPresetCmd) > 0) {
			eval $fbxPresetCmd;
		}

		if ($addFlag) {
			FBXImportMode -v "add";
		} else {
			FBXImportMode -v "merge";
		}

        // Backuping current Maya timeline range, used only for creating union 
	    float $mayaMinTime = `playbackOptions -q -minTime`;
	    float $mayaMaxTime = `playbackOptions -q -maxTime`;
	    float $mayaAnimStartTime = `playbackOptions -q -animationStartTime`;
	    float $mayaAnimEndTime = `playbackOptions -q -animationEndTime`;

        
		if ($newScene) {
			// match timeline to imported file
			//
			FBXImportSetMayaFrameRate -v true; 
			FBXImportFillTimeline -v true;
			FBXProperty "Import|IncludeGrp|Animation|ExtraGrp|TimeLineSpan" -v true;
		}
        else if ( $performAnimTimeUnion )
        {
			FBXImportFillTimeline -v true;
			FBXProperty "Import|IncludeGrp|Animation|ExtraGrp|TimeLineSpan" -v true;
        }

		// Read in the file
		//
		$result = `FBXImport -f $filename`;

		// Restore all import+export IOSettings from the push
		//
		FBXPopSettings;

		if ($newScene || $performAnimTimeUnion ) {
			// restore the time-handling settings as well
			//
			FBXImportSetMayaFrameRate -v false;
			FBXProperty "Import|IncludeGrp|Animation|ExtraGrp|TimeLineSpan" -v false;
			// We used the timeline span property to match the timespan to the
			// imported file. However, when you do taht, FBX matches the
			// playback range to the span of keys on the imported object.
			// So set the playback range to match the total range since
			// for the OneClick workflow we don't think users expect the range
			// of their keys to impact the result
			//
			float $min = `playbackOptions -q -animationStartTime`;
			float $max = `playbackOptions -q -animationEndTime`;
			playbackOptions -minTime $min -maxTime $max;
		}

        if( $performAnimTimeUnion )
        {
    	    float $sceneMinTime = `playbackOptions -q -minTime`;
	        float $sceneMaxTime = `playbackOptions -q -maxTime`;
	        float $sceneAnimStartTime = `playbackOptions -q -animationStartTime`;
	        float $sceneAnimEndTime = `playbackOptions -q -animationEndTime`;

            playbackOptions -e -minTime (min( $mayaMinTime, $sceneMinTime ));
            playbackOptions -e -maxTime (max( $mayaMaxTime, $sceneMaxTime ));

            playbackOptions -e -animationStartTime (min( $mayaAnimStartTime, $sceneAnimStartTime ));
            playbackOptions -e -animationEndTime (max( $mayaAnimEndTime, $sceneAnimEndTime ));

        }
	}

	if ($result == "Success" || !$performReceive) {
		// Delete the file unless an environment variable is set
		//
		string $keepFilesVal = `getenv ONECLICK_KEEP_TEMP_FILES`;
		if (size($keepFilesVal) == 0 || ($keepFilesVal == "0")) {
			sysFile -del $filename;
		}
	}

	return $result;
}

global
proc doOneClickSelectHikSkeleton( string $character )
{
    // Select the character node (for the characterization) and the bones of the character

    string $skelNodes[] = hikGetSkeletonNodes($character);
    
    if (size($skelNodes) > 1) 
    {
        select -add $skelNodes;
        select -add $character; 
	}
}
	

