// Copyright (C) 1997-2014 Autodesk, Inc., and/or its licensors.
// All rights reserved.
//
// The coded instructions, statements, computer programs, and/or related
// material (collectively the "Data") in these files contain unpublished
// information proprietary to Autodesk, Inc. ("Autodesk") and/or its licensors,
// which is protected by U.S. and Canadian federal copyright law and by
// international treaties.
//
// The Data is provided for use exclusively by You. You have the right to use,
// modify, and incorporate this Data into other products for purposes authorized 
// by the Autodesk software license agreement, without fee.
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND. AUTODESK
// DOES NOT MAKE AND HEREBY DISCLAIMS ANY EXPRESS OR IMPLIED WARRANTIES
// INCLUDING, BUT NOT LIMITED TO, THE WARRANTIES OF NON-INFRINGEMENT,
// MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE, OR ARISING FROM A COURSE 
// OF DEALING, USAGE, OR TRADE PRACTICE. IN NO EVENT WILL AUTODESK AND/OR ITS
// LICENSORS BE LIABLE FOR ANY LOST REVENUES, DATA, OR PROFITS, OR SPECIAL,
// DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES, EVEN IF AUTODESK AND/OR ITS
// LICENSORS HAS BEEN ADVISED OF THE POSSIBILITY OR PROBABILITY OF SUCH DAMAGES.

proc string[] getAttrDataForNode(string $node)
//
// Return a string array containing the values of the keyable and channelBox
// attributes for the given node.	
//
{
	string $result[];
	int $count = 0;

	if (`objExists ($node+".nts")`) {
		string $notes = `getAttr ($node+".nts")`;
		if (size($notes) > 0) {
			$result[$count] = ("Notes ("+$node+"): "+$notes);
			$count++;
		}
	}
	
	string $cbAttrs[] = `listAttr -scalar -channelBox $node`;
	for ($cbAttr in $cbAttrs) {
		float $val = `getAttr ($node+"."+$cbAttr)`;
		$result[$count] = ($node+"."+$cbAttr+"="+$val);
		$count++;
	}

	string $keyAttrs[] = `listAttr -multi -scalar -keyable -hasData $node`;
	for ($keyAttr in $keyAttrs) {
		float $val = `getAttr ($node+"."+$keyAttr)`;
		$result[$count] = ($node+"."+$keyAttr+"="+$val);
		$count++;
	}

	return $result;
}

proc string[] getAttrDataForManyNodes(string $nodes[])
{
	string $result[];
	for ($node in $nodes) {
		string $info[];
		$info = getAttrDataForNode($node);
		$result = stringArrayCatenate($result,$info);
	}
	return $result;
}

proc string[] getConnectedNodesOfType(string $node, string $type)
{
	string $conn[] = `listConnections -type $type $node`;
	string $result[] = `stringArrayRemoveDuplicates $conn`;
	return $result;
}

proc string getCollisionInfo(string $ncloth)
{
	string $colliders = ("Passive Colliders: ");
	string $nucleusNodes[] = getConnectedNodesOfType($ncloth,"nucleus");
	for ($nuc in $nucleusNodes) {
		string $rigids[] = getConnectedNodesOfType($nuc,"nRigid");
		if (size($rigids) == 0) {
			$colliders += "none";
		} else {
			for ($rigid in $rigids) {
				string $inputShape[] = `listConnections ($rigid+".inputMesh")`;
				if (size($inputShape) > 0) {
					$colliders += (" "+$inputShape[0]);
				}
			}
		}
	}
	return $colliders;
}

proc string getNucleusConstraintInfo(string $ncloth)
{
	string $conInfo = ("Constraints: ");
	string $compNodes[] = getConnectedNodesOfType($ncloth,"nComponent");
	if (size($compNodes) == 0) {
		$conInfo += "none";
	}
	for ($comp in $compNodes) {
		string $constraints[] = getConnectedNodesOfType($comp,"dynamicConstraint");
		for ($const in $constraints) {
			$conInfo += (" "+$const);
		}
	}
	return $conInfo;
}


proc string[] getInfoForNCloth(string $ncloth)
{
	string $result[];

	string $colliders = getCollisionInfo($ncloth);
	$result[0] = $colliders;

	string $constraintInfo = getNucleusConstraintInfo($ncloth);
	$result[1] = $constraintInfo;
	
	string $nclothData[] = getAttrDataForNode($ncloth);
	$result = stringArrayCatenate($result,$nclothData);

	string $emitterNodes[] = getConnectedNodesOfType($ncloth,"pointEmitter");	
	string $emitInfo[] = getAttrDataForManyNodes($emitterNodes);
	$result = stringArrayCatenate($result,$emitInfo);

	string $components[] = getConnectedNodesOfType($ncloth,"nComponent");	
	string $compInfo[] = getAttrDataForManyNodes($components);
	$result = stringArrayCatenate($result,$compInfo);

	for ($comp in $components) {
		string $constraints[] = getConnectedNodesOfType($comp,"dynamicConstraint");
		string $conInfo[] = getAttrDataForManyNodes($constraints);
		$result = stringArrayCatenate($result,$conInfo);
	}

	string $nucleusNodes[] = getConnectedNodesOfType($ncloth,"nucleus");	
	string $nucInfo[] = getAttrDataForManyNodes($nucleusNodes);
	$result = stringArrayCatenate($result,$nucInfo);

	return $result;
	
}

global
proc string[] getNClothDescriptionInfo(string $obj)
{
	string $ncloths[];
	if ($obj == "selected") {
		$ncloths = getNclothObjectsToCache(0);
	} else {
		$ncloths[0] = $obj;
	}

	string $info[];
	string $result[];
	for ($ncloth in $ncloths) {
		$result[size($result)] = ("NCloth Info for "+$ncloth+":");
		clear($info);
		$info = getInfoForNCloth($ncloth);
		$result = stringArrayCatenate($result,$info);
	}
	return $result;
}
