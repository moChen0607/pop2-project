// Copyright (C) 1997-2014 Autodesk, Inc., and/or its licensors.
// All rights reserved.
//
// The coded instructions, statements, computer programs, and/or related
// material (collectively the "Data") in these files contain unpublished
// information proprietary to Autodesk, Inc. ("Autodesk") and/or its licensors,
// which is protected by U.S. and Canadian federal copyright law and by
// international treaties.
//
// The Data is provided for use exclusively by You. You have the right to use,
// modify, and incorporate this Data into other products for purposes authorized 
// by the Autodesk software license agreement, without fee.
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND. AUTODESK
// DOES NOT MAKE AND HEREBY DISCLAIMS ANY EXPRESS OR IMPLIED WARRANTIES
// INCLUDING, BUT NOT LIMITED TO, THE WARRANTIES OF NON-INFRINGEMENT,
// MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE, OR ARISING FROM A COURSE 
// OF DEALING, USAGE, OR TRADE PRACTICE. IN NO EVENT WILL AUTODESK AND/OR ITS
// LICENSORS BE LIABLE FOR ANY LOST REVENUES, DATA, OR PROFITS, OR SPECIAL,
// DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES, EVEN IF AUTODESK AND/OR ITS
// LICENSORS HAS BEEN ADVISED OF THE POSSIBILITY OR PROBABILITY OF SUCH DAMAGES.

//
// Procedure : generateLightMaps
//
// Description:
//		Generate a set of light maps for a set of
//		geometry.
//
// Arguments:
//		useThisShader : use the shader passed in versus shader 
//		associated with each object
//		postFix : string to stick on to end of light map file texture name
//		allMeshes : all poly geometry
//		shadows : compute shadows
//		antiAlias : anti-alias light map images
//		rx, ry : resolution of light map in x and y
//
// Last Updated : 08/23/00
//

//
// Create a set of dummy shaders for light mapping only
//
global proc
handleDummyLightMapShaders(int $deleteIt)
{
	global string $fakeShaders[];
	
	int $numFake = size($fakeShaders);
	for ($i=0; $i<$numFake; $i++) {
		catch ( `delete $fakeShaders[$i]` );
	}
	
	if ($deleteIt) {
		return;
	}

	// Create a dummy lambert shader + shading group
	string $newss = `shadingNode -name _fakeSS_lambert_ -asShader lambert`;
	string $sgName = ($newss + "SG");
	$sgName = `sets -renderable true -noSurfaceShader true -empty -name $sgName`;
	eval ("connectAttr -f " + $newss+".outColor " + $sgName+".surfaceShader");
	eval ("setAttr -type float3 " + $newss+".color 1.0 1.0 1.0");
	$fakeShaders[0] = $newss;
	$fakeShaders[1] = $sgName;
	
	// Create a dummy lambert shader + shading group
	$newss = `shadingNode -name _fakeSS_blinn_ -asShader blinn`;
	$sgName = ($newss + "SG");
	$sgName = `sets -renderable true -noSurfaceShader true -empty -name $sgName`;
	eval ("connectAttr -f " + $newss+".outColor " + $sgName+".surfaceShader");
	eval ("setAttr -type float3 " + $newss+".color 1.0 1.0 1.0");
	$fakeShaders[2] = $newss;
	$fakeShaders[3] = $sgName;
	
	// Create a dummy lambert shader + shading group
	$newss = `shadingNode -name _fakeSS_phong_ -asShader phong`;
	$sgName = ($newss + "SG");
	$sgName = `sets -renderable true -noSurfaceShader true -empty -name $sgName`;
	eval ("connectAttr -f " + $newss+".outColor " + $sgName+".surfaceShader");
	eval ("setAttr -type float3 " + $newss+".color 1.0 1.0 1.0");
	$fakeShaders[4] = $newss;
	$fakeShaders[5] = $sgName;
}

global proc 
generateLightMaps(string $useThisShader,
				  string $postFix,
				  string $fileFormat,
				  int $allMeshes,
				  int $blendMode,
				  int $shadows,
				  int $antiAlias,
				  int $rx, int $ry)
{
	global string $fakeShaders[];
	
	// Get what to work on
	string $selected[];
	int $needsUVRange[]; // Only polys should use the 0 1 0 1 uv range ?
	int $cnt = 0;
	
	// All untemplated meshes / subdivs / nurbs
	if ($allMeshes) {
		$selected = `ls -type "mesh" -type "subdiv" -type "nurbsSurface" -ut`;
		select -r $selected;
		$cnt = size($selected);
		for ($i=0; $i<$cnt; $i++)
		{
			$needsUVRange[$i] = 1;
		}
	}
	
	// Check the selection list, and screen out meshes / subdivs / nurbs
	else {
		string $unselect[];
		$cnt = 0;

		string $unfiltered[] = `ls -dag -ap -sl`;
		for ($i=0; $i<size($unfiltered); $i++) {
			string $item = $unfiltered[$i];
			string $ntype = `nodeType $item`;
			//print ("Node check " + $item + " = " + $ntype + "\n");
			if ($ntype == "mesh") {
				$selected[$cnt] = $item;
				$needsUVRange[$cnt] = 1;
				$cnt++;
			}
			else if ($ntype == "nurbsSurface") {
				$selected[$cnt] = $item;
				$needsUVRange[$cnt] = 0;
				$cnt++;
			}
			else if ($ntype == "subdiv") {
				$selected[$cnt] = $item;
				$needsUVRange[$cnt] = 0;
				$cnt++;
			}
		}
	}

	if ($cnt == 0) {
		error ((uiRes("m_generateLightMaps.kNoPolyMeshSelected")));
		return;
	}

	// Default to IFF if no format was given
	if ($fileFormat == "")
		$fileFormat = "iff";
	
	// Remove any shader duplicates
	print( (uiRes("m_generateLightMaps.kRemovingShaderInstance")) );

	removeObjectShaderInstances $selected;
	
	// Toggle off the material mappings
	print( (uiRes("m_generateLightMaps.kDisableShaderTex")) );
	toggleMaterialMapping 0;
	
	// Create fake shaders
	print( (uiRes("m_generateLightMaps.kGenFakeShader")) );
	handleDummyLightMapShaders( 0 );
	
	//print ("// **** Start working on objects: { **********\n");
	//print $selected;
	//print ("// }\n");
	
	// Get the shaders associated with each geometry,
	// and run "light map" generation on it.
	for ($i=0; $i<$cnt; $i++) {
		
		string $object = $selected[$i];
		string $shaders[] = `getConnectedShaders $object 0`;
		int $numShaders = size($shaders);
		
		string $uvRangeStr = " -uvRange 0 1 0 1 ";
 		string $noUVRangeStr = " ";
		if ($needsUVRange[$i] == 0)
			$uvRangeStr = $noUVRangeStr;
		
		// Let generate those light maps baby !
		if ($numShaders) {
			
			// Remove any path seperators and replace them with "_" characters.
			string $testName1 = `substitute "|" $object "_"`;
			string $testName2 = `substitute "|" $testName1 "_"`;
			// print ("// Testnames = " + $testName1 + " " + $testName2 + "\n");
			while ($testName1 != $testName2) {
				$testName1 = $testName2;
				$testName2 = `substitute "|" $testName1 "_"`;		
			}
			string $fileName;
			for ($j=0; $j<$numShaders; $j++) {
				
				string $shader = $shaders[$j];
				
				//print("** generating lmap for object " + $object + ", shader: " + $shader + "\n");
				
				$fileName = $testName1 + "_" + $shader + "_" + $postFix;
				
				string $msg = (uiRes("m_generateLightMaps.kGenLightmapforObj")) ;
				print `format -stringArg $fileName -stringArg $object $msg` ;
		
				// New texture name
				string $txtName[];
				int $cstHasBug = 1;
				
				// Use the user passed in shader
				if (size($useThisShader) != 0) {
					$txtName = `evalEcho ("convertSolidTx -aa " +
										  $antiAlias + 
										  " -rx " + $rx + " -ry " + $ry + 
										  " -sh " + $shadows + 
										  " -fin " + $fileName + 
										  " -n " + $fileName + 
										  " -fileFormat " + $fileFormat + 
										  $uvRangeStr + 
										  $object + " " + $useThisShader)`;		  
				}
				else {
					
					// Generate the lightmap. Notice that we only want
					// the 0,0 to 1 1 uvrange at all times.
					//
					if ($cstHasBug == 1) {
						// Creata a dummy shader of the correct type to eval lighting with
						// since there the object may be assigned to a shader which
						// has been duplicated + hooked to a texture.
						//
						// Get the surface shader
						//
						string $stype[];
						$stype = `ls -showType $shader`;
						if ($stype[1] == "shadingEngine") {
							string $sshader[] = eval ("listConnections -s 1 " + $shader + ".surfaceShader;");
							if (size($sshader)) {
								$stype = `ls -showType $sshader[0]`;
								string $fakeName;
								if ($stype[1] == "lambert") {
									$fakeName = $fakeShaders[1];
								}
								else if ($stype[1] == "blinn") {
									$fakeName = $fakeShaders[3];
								}
								if ($stype[1] == "phong") {
									$fakeName = $fakeShaders[5];				
								}
								
								$txtName = `evalEcho ("convertSolidTx -aa " +
													  $antiAlias + 
													  " -rx " + $rx + " -ry " + $ry + 
													  " -sh " + $shadows + 
													  " -fin " + $fileName + 
													  " -n " + $fileName + 
													  " -fileFormat " + $fileFormat + 
													  $uvRangeStr + 
													  $object + " " + $fakeName)`;		  
							}
						}
					}
					else {
						$txtName = `evalEcho ("convertSolidTx -aa " +
											  $antiAlias + 
											  " -rx " + $rx + " -ry " + $ry + 
											  " -sh " + $shadows + 
											  " -fin " + $fileName + 
											  " -fileFormat " + $fileFormat + 
											  " -n " + $fileName + 
											  $uvRangeStr + 
											  $object + " " + $shader)`;		  
					}
				}
				
				// Now hook the thing up
				if (size($txtName)) {
					addTextureToShaderLayered $shader $txtName[0] $blendMode 1 0;
					
				}
			}
		}
		else {
			string $warningString = (uiRes("m_generateLightMaps.kNoShadersForObj"));
			warning (`format -s $object $warningString `); 
		}
	}
	
	// Delete fake shaders
	handleDummyLightMapShaders( 1 );
	
	// Toggle on the material mappings
	select -r $selected;
	toggleMaterialMapping 1;
	print ( (uiRes("m_generateLightMaps.kLightMapGenFinished")) );
}

