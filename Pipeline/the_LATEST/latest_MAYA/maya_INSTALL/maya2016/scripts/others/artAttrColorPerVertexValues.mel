// Copyright (C) 1997-2014 Autodesk, Inc., and/or its licensors.
// All rights reserved.
//
// The coded instructions, statements, computer programs, and/or related
// material (collectively the "Data") in these files contain unpublished
// information proprietary to Autodesk, Inc. ("Autodesk") and/or its licensors,
// which is protected by U.S. and Canadian federal copyright law and by
// international treaties.
//
// The Data is provided for use exclusively by You. You have the right to use,
// modify, and incorporate this Data into other products for purposes authorized 
// by the Autodesk software license agreement, without fee.
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND. AUTODESK
// DOES NOT MAKE AND HEREBY DISCLAIMS ANY EXPRESS OR IMPLIED WARRANTIES
// INCLUDING, BUT NOT LIMITED TO, THE WARRANTIES OF NON-INFRINGEMENT,
// MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE, OR ARISING FROM A COURSE 
// OF DEALING, USAGE, OR TRADE PRACTICE. IN NO EVENT WILL AUTODESK AND/OR ITS
// LICENSORS BE LIABLE FOR ANY LOST REVENUES, DATA, OR PROFITS, OR SPECIAL,
// DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES, EVEN IF AUTODESK AND/OR ITS
// LICENSORS HAS BEEN ADVISED OF THE POSSIBILITY OR PROBABILITY OF SUCH DAMAGES.

//
//
//  Creation Date:  Nov 2002
//
//	Description:
//		Enable/disable controls according to the changing color set setup.
//		Validates values in controls and changes them appropriately.
//	Note: This behaviour happens immediately after the current Color Set has changed!
//

// Stores the previously set color set representation to accurately track state
//
global string $gLastColorSetRepr="";

//  Procedure Name:
//      syncColorPerVertexTool
//
//  Input Arguments:
//
//  Return Value:
//      None.
//
//	Description:
//		Disables channels that aren't included in the new
//		current representation scheme (immediately after the former representation
//		changes). Also sets up the state of color and alpha sliders appropriately.
//
global proc syncColorPerVertexTool()
{
	global string $gLastColorSetRepr;

	string $tool = `currentCtx` ;
	string $repr = `polyColorSet -q -ccs -representation`;

	// 302265: Handling of non-existent color sets / initial painting
	// (Consider not allowing painting on meshes that don't have any color sets)
	// For now, we allow painting on meshes that don't have color sets and ensure
	// that the user selected color is applied from the VERY first time it is set.
	// The if-block below is related to a workaround that prevents color values
	// from being lost when switching from an alpha color set
	//
	
	// If no color set has been defined on the mesh, assume RGBA channel selection behaviour
	if ($repr == "")
	{
		$repr = "RGBA";
	}
	
	$gLastColorSetRepr = $repr;

	if ( ( $gLastColorSetRepr == "A" ) && ( $repr != "A" ) )
	{
		float $c[] = `colorSliderGrp -q -rgbValue colorPerVertexColor`;
		float $a = `floatSliderGrp -q -value colorPerVertexAlpha`;
		artAttrPaintVertexCtx -e -colorRGBAValue $c[0] $c[1] $c[2] $a $tool;
		artAttrPaintVertexCtx -e -colorRGBValue $c[0] $c[1] $c[2] $tool; 
	}

	// Setup the channels and Color/Alpha slider selections to reflect the
	// current color set representation
	if($repr == "A") { // A
		if(`radioButtonGrp -q -sl artAttrColorChannelChoices` != 3) {
			radioButtonGrp -e -sl 3 artAttrColorChannelChoices;
		}
		radioButtonGrp -e -enable1 0 -enable2 0 -enable3 1
			artAttrColorChannelChoices;
		colorSliderGrp -e -en false colorPerVertexColor;
		floatSliderGrp -e -en true  colorPerVertexAlpha;
	} else if($repr == "RGB") { //RGB
		if(`radioButtonGrp -q -sl artAttrColorChannelChoices` != 1) {
			radioButtonGrp -e -sl 1 artAttrColorChannelChoices;
		}
		radioButtonGrp -e -enable1 1 -enable2 0 -enable3 0
			artAttrColorChannelChoices;
		colorSliderGrp -e -en true colorPerVertexColor;
		floatSliderGrp -e -en false colorPerVertexAlpha;
	} else if($repr == "RGBA") { // RGBA
		if(`radioButtonGrp -q -sl artAttrColorChannelChoices` == 3) {
			radioButtonGrp -e -sl 2 artAttrColorChannelChoices;
		}

		// No Alpha-only filter implemented yet for the RGBA color set
		//
		radioButtonGrp -e -enable1 1 -enable2 1 -enable3 0
			artAttrColorChannelChoices;

		colorSliderGrp -e -en true colorPerVertexColor;

		// Was the RGB or RGBA channel ultimately selected? Disable the
		// alpha value control where appropriately
		//
		if(`radioButtonGrp -q -sl artAttrColorChannelChoices` == 1)
		{
			floatSliderGrp -e -en false colorPerVertexAlpha;
		}
		else
		{
			floatSliderGrp -e -en true colorPerVertexAlpha;
		}
	}

	// Don't rsynchronize color value here in case the color picker is being used
	//
}


//  Procedure Name:
//      artColorPerVertexValues
//
//  Description:
//      Initialize the numeric VALUES of color per vertex UI elements based on available Artisan context information
//
//  Input Arguments:
//
//  Return Value:
//      None.
//


global proc artColorPerVertexPaintValues( 
	string	$artCommand,
	string	$currTool
)
{
	// Ensure that there is an up-to-date color set representation state 
	syncColorPerVertexTool();

	string $tool = `currentCtx` ;

	string $cmd;

	string $repr = `polyColorSet -q -ccs -representation`;

	// Determine the amount of paint channels, and setup Color/Alpha UI elements to reflect that count
	// Push the paint channel count and colors onto the Artisan tool context

	string $num = `radioButtonGrp -q -sl artAttrColorChannelChoices`;
	int $paintNumChannels = 4;

	if( $num == 1 ) 
		$paintNumChannels = 3;
	else if ( $num == 2 )
		$paintNumChannels = 4;
	else if ( $num == 3 )
		$paintNumChannels = 1;

	float $c[];
	float $alpha[];

	if( $paintNumChannels == 4 ) {

		$cmd = $artCommand + " -e -paintNumChannels 4 " + `currentCtx`;
		eval $cmd;
		$cmd = ($artCommand + " -q -colorRGBAValue " + `currentCtx` );
		$c = `eval $cmd`;
		if( size ($c) == 4 ) {
			colorSliderGrp -e -rgb $c[0] $c[1] $c[2] colorPerVertexColor;
			artAttrPaintVertexCtx -e -colorRGBAValue $c[0] $c[1] $c[2] $c[3] $tool;
		} else {
			artAttrPaintVertexCtx -e -colorRGBAValue 0.0 0.0 0.0 1.0 $tool ;
		}

	} else if ( $paintNumChannels == 1) {

		$cmd = $artCommand + " -e -paintNumChannels 1 " + `currentCtx`;
		eval $cmd;
		$cmd = ($artCommand + " -q -colorAlphaValue " + `currentCtx` );
		$alpha = `eval $cmd`;
		if( size ($alpha) == 1) {
			artAttrPaintVertexCtx -e -colorAlphaValue $alpha[0] $tool ;
		} else {
			artAttrPaintVertexCtx -e -colorAlphaValue 1.0 $tool ;
		}
	} else if ( $paintNumChannels == 3) {
		
		$cmd = $artCommand + " -e -paintNumChannels 3 " + `currentCtx`;
		eval $cmd;
		$cmd = ($artCommand + " -q -colorRGBValue " + `currentCtx` );
		$c = `eval $cmd`;
		if( size ($c) == 3 ) {
			colorSliderGrp -e -rgb $c[0] $c[1] $c[2] colorPerVertexColor;
			artAttrPaintVertexCtx -e -colorRGBValue $c[0] $c[1] $c[2] $tool ;

		} else {
			artAttrPaintVertexCtx -e -colorRGBValue 0.0 0.0 0.0 $tool ;
		}
	}

	$cmd = $artCommand + " -q -paintComponent " + `currentCtx`;

	int $vertexFace = `eval $cmd` ;

	radioButtonGrp -e -sl $vertexFace artAttrColorPaintChoices ;

	switch( $vertexFace ) 
	{
		case 1 : //vertex
			columnLayout -e -en true artImportFrameLayout ;
			columnLayout -e -en true artExportFrameLayout ;
			break ;
		case 2 : // vertex face
		case 3 : // face
			// we don't allow import/export operations in face and "vertex face" mode
			columnLayout -e -en true artImportFrameLayout ;
			columnLayout -e -en false artExportFrameLayout ;
			break ;
	}
	
	// Operation frameLayout.
	$cmd = ($artCommand + " -q -selectedattroper " + `currentCtx`);
	string $operation =  `eval $cmd`;

	if ( $operation == "absolute" ) {
		radioButtonGrp -e -sl 1 artAttrColorOperationChoices0;
	} else if ( $operation == "smooth" ) {
		radioButtonGrp -e -sl 2 artAttrColorOperationChoices0;
	} else if ( $operation == "remove" ) {
		radioButtonGrp -e -sl 3 artAttrColorOperationChoices0;
	} else if ( $operation == "additive" ) {
		radioButtonGrp -e -sl 1 artAttrColorOperationChoices1;
	} else if ( $operation == "subtract" ) {
		radioButtonGrp -e -sl 2 artAttrColorOperationChoices1;
	} else if ( $operation == "scale" ) {
		radioButtonGrp -e -sl 3 artAttrColorOperationChoices1;
	}

	// Colour Clamp Options.
	$cmd = ($artCommand + " -q -clamp " + `currentCtx` );
	string $clampOpt = `eval $cmd`;
	int $clampLower=0;
	int $clampUpper=0;
	if ( $clampOpt == "none" ) {
	} else if ( $clampOpt == "both" ) {
		$clampLower=1;
		$clampUpper=1;
	} else if ( $clampOpt == "lower" ) {
		$clampLower=1;
	} else if ( $clampOpt == "upper" ) {
		$clampUpper=1;
	}

	checkBoxGrp -e -v1 $clampLower artAttrClampChkBox;
	checkBoxGrp -e -v2 $clampUpper artAttrClampChkBox;


	// Colour Clamp Values.
	//
	$cmd = ($artCommand + " -q -clamplower " + `currentCtx` );
	float $clampLowerValue = `eval $cmd`;
	$cmd = ($artCommand + " -q -clampupper " + `currentCtx` );
	float $clampUpperValue = `eval $cmd`;

	floatFieldGrp -e -value1 $clampLowerValue -value2 $clampUpperValue
		artAttrClampField; 


	// Alpha Clamp Options.
	$cmd = ($artCommand + " -q -alphaclamp " + `currentCtx` );
	$clampOpt = `eval $cmd`;
	$clampLower=0;
	$clampUpper=0;
	if ( $clampOpt == "none" ) {
	} else if ( $clampOpt == "both" ) {
		$clampLower=1;
		$clampUpper=1;
	} else if ( $clampOpt == "lower" ) {
		$clampLower=1;
	} else if ( $clampOpt == "upper" ) {
		$clampUpper=1;
	}

	checkBoxGrp -e -v1 $clampLower artAttrAlphaClampChkBox;
	checkBoxGrp -e -v2 $clampUpper artAttrAlphaClampChkBox;

	// Alpha Clamp Values.
	//
	$cmd = ($artCommand + " -q -alphaclamplower " + `currentCtx` );
	$clampLowerValue = `eval $cmd`;
	$cmd = ($artCommand + " -q -alphaclampupper " + `currentCtx` );
	$clampUpperValue = `eval $cmd`;

	floatFieldGrp -e -value1 $clampLowerValue -value2 $clampUpperValue
		artAttrAlphaClampField; 

	updateColorPerVertexToolControls( $paintNumChannels );
}


//	Description:
//		Initialize the overall ENABLED STATE of color per vertex UI elements to reflect
//		the current channel selection
//
global proc updateColorPerVertexToolControls(
	string $paintNumChannels
)
{
	int $bEnableAlphaClampValues=true;
	int $bEnableAlphaControls=true;
	int $bEnablePaintClampValues=true;
	int $bEnableRGBControls=true;

	// Focus on disabling options based on Alpha channel inclusion
	//

	if ($paintNumChannels == 1 || $paintNumChannels==4) // RGBA or A
	{
		if($paintNumChannels==1)
		{
			$bEnableRGBControls=false;
		}
	}
	else
	{
		$bEnableAlphaControls=false;
	}

	// Setup controls in response to the current color set and channels selected
	//

	if (!$bEnableRGBControls)
	{
		$bEnablePaintClampValues=false;
	}

	if ($bEnableAlphaControls)
	{
		updateColorPerVertexAlphaValueControls();
	}
	else
	{
		$bEnableAlphaClampValues=false;
	}

	// Enabling Controls
	//
	colorSliderGrp -e -enable $bEnableRGBControls colorPerVertexColor;
	symbolButton -e -enable $bEnableRGBControls artAttrColorPick;
	
	floatSliderGrp -e -enable $bEnableAlphaControls colorPerVertexAlpha;
	floatFieldGrp -e -enable $bEnableAlphaControls colorPerVertexMinMaxAlphaValue;

	// Color clamp check box and fields
	//
	checkBoxGrp -e -enable $bEnablePaintClampValues artAttrClampChkBox;
	$bMinClampEnabled=`checkBoxGrp -q -value1 artAttrClampChkBox`;
	$bMaxClampEnabled=`checkBoxGrp -q -value2 artAttrClampChkBox`;
	floatFieldGrp -e -enable $bEnablePaintClampValues artAttrClampField;
	floatFieldGrp -e -enable1 $bMinClampEnabled -enable2 $bMaxClampEnabled
		artAttrClampField;

	// Alpha clamp check box and fields
	//
	checkBoxGrp -e -enable $bEnableAlphaClampValues artAttrAlphaClampChkBox;
	$bMinClampEnabled=`checkBoxGrp -q -value1 artAttrAlphaClampChkBox`;
	$bMaxClampEnabled=`checkBoxGrp -q -value2 artAttrAlphaClampChkBox`;
	floatFieldGrp -e -enable $bEnableAlphaClampValues artAttrAlphaClampField;
	floatFieldGrp -e -enable1 $bMinClampEnabled -enable2 $bMaxClampEnabled
		artAttrAlphaClampField;
}

// =======================================================
// Main callback procedure for ColorPerVertex Paint tool.
// =======================================================
global proc artAttrColorPerVertexValues(
	string 	$toolName
)
{
	// Important to check at the start of this procedure for color set representation changes
	// The values below won't be valid if placed later on in this procedure
	// 
	global string $gLastColorSetRepr;
	string $repr = `polyColorSet -q -ccs -representation`;
	string $lastRepr = $gLastColorSetRepr;

	source "artisanCallback.mel";
	source "artisanValues.mel";
	source "artAttrValues.mel";

	// 301882(primarily)/302288: toolProperty errors
	// Test early on whether there is a visible UI panel for the CPV tool
	// If there is no such UI, then it won't need any updating
	// One way to be sure that there is such a UI is to check for a parent UI
	//
	string $parent = (`toolPropertyWindow -q -location` + "|artAttrColorPerVertex");

	// Is the Color Per Vertex Paint tool presently visible?
	// If it is not, then "|artAttrColorPerVertex" will be returned as its parent
	// and none of the UI will require editing of values
	//
	if ($parent != "|artAttrColorPerVertex")
	{

		string 	$artCommand	 = "artAttrPaintVertexCtx";
		string	$currContext = `currentCtx`;
		string	$currTool	 = `contextInfo -c $currContext`;

		//disable color feedback for this tool
		$res = `artAttrCtx -e -colorfeedback false $toolName` ;

		// Enter color-per-vertex shaded mode if the switch indicates so
		//
		if (`optionVar -q polyAutoShowColorPerVertex`) {
			optionVar -intValue colorShadedDisplay 1
				-intValueAppend colorShadedDisplay 1;
			DisplaySmoothShaded;
			polyOptions -cs 1;
		}

		// Provide a different icon for different attribute tools.
		string $icon	= "paintVertexColour.png";
		string $helpTag = "PaintVertexColorTool";

		setParent $parent;

		toolPropertySetCommon $toolName $icon $helpTag;

		// Brush frameLayout values.
		artisanBrushValues( $artCommand, $currTool );

		// Color Per Vertex frameLayout values.
		artColorPerVertexPaintValues( $artCommand, $currTool );

		// Stroke frameLayout values.
		artisanStrokeValues( $artCommand, $currTool );

		// Stylus Pressure frameLayout values.
		artisanPressureValues( $artCommand, $currTool );

		// Attribute Maps frameLayout values.
		artisanAttrMapValues( $artCommand, $currTool );

		// Display frameLayout values.
		artisanDisplayValues( $artCommand, $currTool );

		toolPropertySelect artAttrColorPerVertex;

		// Note: It's important to resynchronize color value here now that the color
		// picker is finished. If done earlier, this prevents us from doing additive
		// painting when in alpha mode!!
		// Case:
		//		We have an RGBA colorset
		//		We set alpha + color. Then we go to another color set and paint in RGB.
		//		We want to retain the same color, even though there's no alpha in RGB.
		//		And when we go back to the RGBA colorset, we want to retain BOTH color+alpha
		//		(from earlier)!
		//
		// As well, we only want to resynchronize controls (enable/disable) when the Color Set representation changes.
		// Note: Callback code already is in place for channel changes, but it's not activated when the
		// color set representation changes (i.e. an outside event).
		//
		if ($repr!=$lastRepr)
		{
			artAttrColorPerVertexChannels( $artCommand );
		}
	}
}
