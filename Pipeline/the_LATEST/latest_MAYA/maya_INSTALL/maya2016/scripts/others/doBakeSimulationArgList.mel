// Copyright (C) 1997-2014 Autodesk, Inc., and/or its licensors.
// All rights reserved.
//
// The coded instructions, statements, computer programs, and/or related
// material (collectively the "Data") in these files contain unpublished
// information proprietary to Autodesk, Inc. ("Autodesk") and/or its licensors,
// which is protected by U.S. and Canadian federal copyright law and by
// international treaties.
//
// The Data is provided for use exclusively by You. You have the right to use,
// modify, and incorporate this Data into other products for purposes authorized 
// by the Autodesk software license agreement, without fee.
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND. AUTODESK
// DOES NOT MAKE AND HEREBY DISCLAIMS ANY EXPRESS OR IMPLIED WARRANTIES
// INCLUDING, BUT NOT LIMITED TO, THE WARRANTIES OF NON-INFRINGEMENT,
// MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE, OR ARISING FROM A COURSE 
// OF DEALING, USAGE, OR TRADE PRACTICE. IN NO EVENT WILL AUTODESK AND/OR ITS
// LICENSORS BE LIABLE FOR ANY LOST REVENUES, DATA, OR PROFITS, OR SPECIAL,
// DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES, EVEN IF AUTODESK AND/OR ITS
// LICENSORS HAS BEEN ADVISED OF THE POSSIBILITY OR PROBABILITY OF SUCH DAMAGES.

//
//  Creation Date:  10 Aug 98
//
//	Procedure Name:
//		doBakeSimulationArgList
//
//	Description:
//		This is the actual function that calls from the "Bake Simulation"
//		option box.
//
//	Input Arguments:
//	$version: The version of this option box.  Used to know how to 
//	interpret the $args array.
//		"1" : $useTS, $start, $end, $by, $below, $control, $shapes, $imp, $useCB
//		"2" : $preserveOutsideKeys
//		"3" : $selectionConnection
//	
//	$args
//	Version 1
//	[0]		$whichRange	1 : use the playback range
//	                    !(1) : use the $start and $end values
//	[1]		$start		only applicable if $whichRange is 2
//	[2]		$end		only applicable if $whichRange is 2
//	[3]		$by			the increment from start to end time of simulation
//						with which to view frames and capture keyframes
//	[4]		$below		0/1 : bake on selected items only, or all below
//	[5]		$control	0/1 : if 1 and a transform above a shape is selected,
//							bake animation of all control points also
//	[6]		$shapes		0/1 : if 1 and a transform above a shape is selected,
//							bake attributes of shape as well
//							(excluding control points)
//	[7]		$imp		0/1 : if we're baking attributes that are controlled by an
//							implicit animation (i.e. with no explicit DG connections),
//							then if 1, turn off this implicit control after the
//							bake is complete (e.g. turn off the IK handle's
//							effects after baking skeleton joints, controlled by IK)
//	[8]		$useCB		0/1 : if 1, set keyframes on attrs specified in channel box
//	Version 2
//	[9]		$preserveOutsideKeys 0/1 : if 1, preserve keys that are ouside the bake
//                                 range when there are directly connected anim 
//                                 curves
//	Version 3
//	[10]	$selectionConnection name of selection connection to use
//  [11]    $sparseAnimCurveBake 0 : insert a key at every time step
//								 1 : do not insert new keys into ranges
//                               where animation is defined, and try to
//                               use as few keys as possible to bake the
//                               pre and post infinity behavior
//	Version 4
//	[12]	$removeBakedAttributeFromLayer 1 remove attribute from layers
//	[13]	$bakeOnOverrideLayer 1 create an override layer to put the baking result
//
//	Version 5
//	[14]	$smartBake 1 perform a bake that put keyframes only at the frames where the source 
//						 curves have keyframes
//	[15]	$smartBakeTolerance acceptablev deviation percentage for the result, 0 means no refinement
//
//	Version 6
//	[16]	$minimizeRotation unroll rotation
//	Return Value:
//		None
//
//	Version 7
//	[17]	$removeBakedAnimFromLayer 1 remove baked animation from layers
//	Return Value:
//		None
//
global proc doBakeSimulationArgList (string $version, string $args[])
{
	int		$versionNum				= $version;

	int		$whichRange				= $args[0];
	float	$start					= $args[1];
	float	$end					= $args[2];
	float	$by						= $args[3];
	int		$below					= $args[4];
	int		$control				= $args[5];
	int		$shapes					= $args[6];
	int		$imp					= $args[7];
	int		$useCB					= $args[8];
	int		$preserveOutsideKeys	= ($versionNum >= 2 ? $args[9] : 0);
	string	$selectionConnection	= ($versionNum >= 3 ? $args[10] : "animationList");
	int 	$sparseAnimCurveBake	= ($versionNum >= 3 ? $args[11] : 0);
	int 	$removeBakedAttributeFromLayer	= ($versionNum >= 4 ? $args[12] : 0);
	int		$bakeOnOverrideLayer = ($versionNum >= 4 ? $args[13] : 0);
	int		$smartBake = ($versionNum >= 5 ? $args[14] : 0);
	float	$smartBakeTolerance = ($versionNum >= 5 ? $args[15] : 0.0);
	int		$minimizeRotation = ($versionNum >= 6 ? $args[16] : 0);
	int 	$removeBakedAnimFromLayer	= ($versionNum >= 7 ? $args[17] : 0);	
	string $cmd = "bakeResults -simulation true";

	if ($whichRange == 1 ) {
		$cmd = ($cmd + 
			" -t \"" + `playbackOptions -query -minTime` + ":" +
			`playbackOptions -query -maxTime` + "\"");
	}
	else {
		$cmd = ($cmd + " -t \""  + $start + ":" + $end + "\"");


	}

	// Hierarchy election
	//
	if ($below) {
		$cmd = $cmd + " -hierarchy below";
	}

	// Sample By and SmartBake
	//

	if( !$smartBake )
	{
		$cmd = ( $cmd + " -sampleBy " + $by );
	}
	else
	{
		$cmd= $cmd + " -smart 1";

		if( $smartBakeTolerance > 0 )
		{
			$cmd= $cmd+" "+ $smartBakeTolerance;
		}
	}

	// Disable Implicit Control
	//
	if ($imp)
		$cmd = ($cmd + " -disableImplicitControl true");
	else
		$cmd = ($cmd + " -disableImplicitControl false");
		
	// Keep Unbaked Keys
	//
	if ($preserveOutsideKeys)
		$cmd = ($cmd + " -preserveOutsideKeys true");
	else
		$cmd = ($cmd + " -preserveOutsideKeys false");

	// Sparse AnimCurve Bake
	//
	if ($sparseAnimCurveBake)
		$cmd = ($cmd + " -sparseAnimCurveBake true");
	else
		$cmd = ($cmd + " -sparseAnimCurveBake false");

	// remove attribute from layer
	//
	if ($removeBakedAttributeFromLayer)
		$cmd = ($cmd + " -removeBakedAttributeFromLayer true");
	else
		$cmd = ($cmd + " -removeBakedAttributeFromLayer false");

	if ($removeBakedAnimFromLayer)
		$cmd = ($cmd + " -removeBakedAnimFromLayer true");
	else
		$cmd = ($cmd + " -removeBakedAnimFromLayer false");
		
	if ($bakeOnOverrideLayer)
		$cmd = ($cmd + " -bakeOnOverrideLayer true");
	else
		$cmd = ($cmd + " -bakeOnOverrideLayer false");

	if ($minimizeRotation)
		$cmd = ($cmd + " -minimizeRotation true");
	else
		$cmd = ($cmd + " -minimizeRotation false");

	// The Channel Box option determines both attributes AND target
	// objects.
	//
	if( $useCB ) {
		string  $syntax[] = keySetOptionBoxCommon( { "bakeSimulation", 
													 "unknown", 
													 "channelBoxSyntax" } );
		if( size( $syntax[0] ) == 0 ) {
			warning( (uiRes("m_doBakeSimulationArgList.kNoChannelsSelected")) );
			return;
		}
		
		$cmd = ( $cmd + $syntax[0] );
	}
	// control points & shape  options only applicable without
	// explicit channel box selection of attributes
	//
	else {
		// Control points, shapes, elections
		//
		if ($control)
			$cmd = ( $cmd + " -controlPoints true" );
		else
			$cmd = ( $cmd + " -controlPoints false" );

		if ($shapes)
			$cmd = ($cmd + " -shape true");
		else
			$cmd = ($cmd + " -shape false");

		// Get the target objects
		//
		string $members = expandSelectionConnection ($selectionConnection);
		
		if( $members == "" ) {
			$cmd = $cmd + " -animation objects";
		}
		else {
			if ($members == "{}") {
				$cmd = "";
				warning ( (uiRes("m_doBakeSimulationArgList.kNoObjectsSelected")) );
			}
			else {
				$cmd = ($cmd + " " + $members);
			}
		}
	}

	if ($cmd != "") {
		evalEcho($cmd);
	}
}
