// Copyright (C) 1997-2014 Autodesk, Inc., and/or its licensors.
// All rights reserved.
//
// The coded instructions, statements, computer programs, and/or related
// material (collectively the "Data") in these files contain unpublished
// information proprietary to Autodesk, Inc. ("Autodesk") and/or its licensors,
// which is protected by U.S. and Canadian federal copyright law and by
// international treaties.
//
// The Data is provided for use exclusively by You. You have the right to use,
// modify, and incorporate this Data into other products for purposes authorized 
// by the Autodesk software license agreement, without fee.
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND. AUTODESK
// DOES NOT MAKE AND HEREBY DISCLAIMS ANY EXPRESS OR IMPLIED WARRANTIES
// INCLUDING, BUT NOT LIMITED TO, THE WARRANTIES OF NON-INFRINGEMENT,
// MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE, OR ARISING FROM A COURSE 
// OF DEALING, USAGE, OR TRADE PRACTICE. IN NO EVENT WILL AUTODESK AND/OR ITS
// LICENSORS BE LIABLE FOR ANY LOST REVENUES, DATA, OR PROFITS, OR SPECIAL,
// DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES, EVEN IF AUTODESK AND/OR ITS
// LICENSORS HAS BEEN ADVISED OF THE POSSIBILITY OR PROBABILITY OF SUCH DAMAGES.


global proc manipRotatePointHandleTowards(string $point, string $originalSelection[], string $originalHilite[], string $compSelType, int $restoreSymmetry) 
{
	// Restore symmetry
	if ($restoreSymmetry) {
	   symmetricModelling -s 1;
	}

	// Restore component mask	
	if (size($compSelType) > 0) {
		string $selCmd = "selectType ";
		int $objectMode = `selectMode -q -o`;
		if ($objectMode) $selCmd += "-ocm ";
		if ($compSelType == "none") {
			$selCmd += "-alc 0";
		} else {
		    $selCmd += "-" + $compSelType + " 1";
		}
		eval($selCmd);
	}

	// Restore original hilite
	if (size($originalHilite[0]) > 0) {
		hilite $originalHilite;
	}
	
	// Restore original selection
	if(size($originalSelection[0]) > 0) {
		print($originalSelection);
		select $originalSelection;
	}
	
	// Make Rotate tool current
	setToolTo Rotate;

	// Get wold position of point
	float $pos[] = `pointPosition $point`;
	// Set options on the rotate manip
	manipRotateContext -edit -mode 3 -orientTowards $pos[0] $pos[1] $pos[2] Rotate;
}

global proc manipRotateAlignHandleWith(string $object, string $originalSelection[], string $originalHilite[], string $compSelType, int $restoreSymmetry) 
{
	int $doIt = false;
	string $typedObject[];
	string $verts[];
	float $vFrom[], $vTo[];

	int $haveVerts = false;
	int $haveNormal = false;

	// See if we are dealing with polygon face
	$typedObject = `filterExpand -expand on -selectionMask 34 $object`;
	if(size($typedObject) > 0) {
		// Get normal from face
		string $infoStr[] = `polyInfo -faceNormals $typedObject[0]`;
		string $tokens[];
		int $numTokens = `tokenize $infoStr[0] $tokens`;
		float $faceNormal[3];
		if($numTokens == 5) {
			$faceNormal[0] = $tokens[2]; 
			$faceNormal[1] = $tokens[3]; 
			$faceNormal[2] = $tokens[4]; 
			// Get normal in world space
			float $worldMatrix[16] = `xform -q -ws -matrix $typedObject[0]`;
			$vTo = `pointMatrixMult $faceNormal $worldMatrix`;
			$haveNormal = true;
		}
	} else {
		// See if we dealing with polygon edge
		$typedObject = `filterExpand -expand on -selectionMask 32 $object`;
		if(size($typedObject) > 0) {
			// Get the vertices from edge
			$verts = `polyListComponentConversion -fromEdge -toVertex $typedObject[0]`;
			$haveVerts = true;
		} else {
			// See if we dealing with subd edge
			$typedObject = `filterExpand -expand on -selectionMask 37 $object`;
			if(size($typedObject) > 0) {
				// Get the vertices from edge
				$verts = `subdListComponentConversion -fromEdge -toVertex $typedObject[0]`;
				$haveVerts = true;
			} 
		}
	}

	if(!$haveNormal && !$haveVerts) {
		error (uiRes("m_manipRotateOrient.kInvalidSelection"));
		return;
	}

	if($haveVerts) {
		// Flatten verts selection in case they are compressed
		select -r $verts;
		$verts = `ls -sl -fl`;
		
		// We should get 2 verts
		if(size($verts) == 2) {
			$vFrom = `pointPosition $verts[0]`;
			$vTo = `pointPosition $verts[1]`;

			$vTo[0] -= $vFrom[0];
			$vTo[1] -= $vFrom[1];
			$vTo[2] -= $vFrom[2];
			
			$doIt = true;
		}
	} else if($haveNormal){
		$doIt = true;
	}

	// Restore symmetry
	if ($restoreSymmetry) {
	   symmetricModelling -s 1;
	}

	// Restore component mask	
	if (size($compSelType) > 0) {
		string $selCmd = "selectType ";
		int $objectMode = `selectMode -q -o`;
		if ($objectMode) $selCmd += "-ocm";
		if ($compSelType == "none") {
			$selCmd += "-alc 0";
		} else {
		    $selCmd += "-" + $compSelType + " 1";
		}
		eval($selCmd);
	}

	// Restore original hilite
	if (size($originalHilite[0]) > 0) {
		hilite $originalHilite;
	}
	
	// Restore original selection
	if(size($originalSelection[0]) > 0) {
		print($originalSelection);
		select $originalSelection;
	}
	
	// Make Rotate tool current
	setToolTo Rotate;

	if($doIt) {
		manipRotateContext -edit -mode 3 -alignAlong $vTo[0] $vTo[1] $vTo[2] Rotate;
	}
}

global proc manipRotateAlignHandleToComponent(string $component, string $originalSelection[], string $originalHilite[], string $compSelType, int $restoreSymmetry) 
{
	string $typedObject[];

	// 1) Polygon Face
	$typedObject = `filterExpand -expand on -selectionMask 34 $component`;
	if (size($typedObject) > 0) {
		manipRotateAlignHandleWith($component, $originalSelection, $originalHilite, $compSelType, $restoreSymmetry);
		return;
	}

	// 2) Polygon Edge
	$typedObject = `filterExpand -expand on -selectionMask 32 $component`;
	if (size($typedObject) > 0) {
		manipRotateAlignHandleWith($component, $originalSelection, $originalHilite, $compSelType, $restoreSymmetry);
		return;
	}

	// 3) Point or other component
	manipRotatePointHandleTowards($component, $originalSelection, $originalHilite, $compSelType, $restoreSymmetry);
}

// This procedure creates a script context that allows user to select point in the scene
// and orients current handle of the rotate manipulator so it points to it.
proc manipRotatePointTo() 
{
	
	string $ctx;
	string $currentSelection[] = `ls -sl`;

	// Something has to be selected
	if(size($currentSelection[0]) == 0) {
		error((uiRes("m_manipRotateOrient.kOrientRotateManipNoSelectErr")));
	}

	string $cmd = "manipRotatePointHandleTowards($Selection1[0], ";
	$cmd += "{\"" + stringArrayToString($currentSelection, "\", \"") + "\"}, ";
	$cmd += "{}, \"\", 0);";

	string $pointMsg = (uiRes("m_manipRotateOrient.kOrientRotateManipPointPrompt"));
	$ctx = `scriptCtx
				-title (uiRes("m_manipRotateOrient.kOrientRotateManipScaleTo"))
				-toolStart "select -clear"
				-finalCommandScript $cmd
				-showManipulators off
				-totalSelectionSets 1
				-setSelectionCount 1
			// Types of point allowed in selection
			// -----------------------------------
				-controlVertex on
				-editPoint on
				-polymeshVertex	on
				-locatorXYZ on
				-locator on
				-joint on
				-jointPivot on
				-scalePivot on
				-rotatePivot on
				-subdivMeshPoint on
				-latticePoint on
				-particle on
				-motionTrailPoint on
				-motionTrailTangent on
			// -----------------------------------
				-setNoSelectionPrompt $pointMsg
				-setNoSelectionHeadsUp $pointMsg
				-exitUponCompletion on
				-setAutoComplete on`;
			
	setToolTo $ctx;
}

// This procedure creates a script context that allows user to select face or edge in the scene
// and orients current handle of the rotate manipulator so it is parallel to the selected edge or the normal of selected face.
proc manipRotateAlignWith(string $component) 
{
	
	string $ctx;
	string $currentSelection[] = `ls -sl`;

	// Something has to be selected
	if(size($currentSelection[0]) == 0) {
		error (uiRes("m_manipRotateOrient.kNoSelection"));
	}

	string $cmd = "manipRotateAlignHandleWith($Selection1[0], ";
	$cmd += "{\"" + stringArrayToString($currentSelection, "\", \"") + "\"}, ";
	$cmd += "{}, \"\", 0);";
	
	string $ctxTitle = (uiRes("m_manipRotateOrient.kOrientRotateManipAlignWith"));
	string $faceMsg = (uiRes("m_manipRotateOrient.kOrientRotateManipFace"));
	string $edgeMsg = (uiRes("m_manipRotateOrient.kOrientRotateManipEdge"));
	if ($component == "face"){
		$ctx = `scriptCtx
				-title $ctxTitle
				-toolStart "select -clear"
				-finalCommandScript $cmd
				-showManipulators off
				-totalSelectionSets 1
				-setSelectionCount 1
			// Types of components allowed in selection
			// -----------------------------------
				-polymeshEdge off
				-polymeshFace on
				-subdivMeshEdge off
			// -----------------------------------
				-setNoSelectionPrompt $faceMsg
				-setNoSelectionHeadsUp $faceMsg
				-exitUponCompletion on
				-setAutoComplete on`;
	} else{//edge
		$ctx = `scriptCtx
				-title $ctxTitle
				-toolStart "select -clear"
				-finalCommandScript $cmd
				-showManipulators off
				-totalSelectionSets 1
				-setSelectionCount 1
			// Types of components allowed in selection
			// -----------------------------------
				-polymeshEdge on
				-polymeshFace off
				-subdivMeshEdge on
			// -----------------------------------
				-setNoSelectionPrompt $edgeMsg
				-setNoSelectionHeadsUp $edgeMsg
				-exitUponCompletion on
				-setAutoComplete on`;				
				
	}
			
	setToolTo $ctx;
}


proc manipRotateAlignComponent(string $component) 
{
	string $ctx;
	string $currentSelection[] = `ls -sl`;

	// Something has to be selected
	if(size($currentSelection[0]) == 0) {
		error((uiRes("m_manipRotateOrient.kOrientRotateManipComponentNoSelectErr")));
	}

	string $currentHilite[] = `ls -hl`;
	int $objectMode = `selectMode -q -o`;
	string $ocm = ($objectMode ? "-ocm " : "");
	int $restoreSymmetry = `symmetricModelling -q -s`;

	// Save component selectType
	string $compSelType = "";
	string $selQuery = "selectType -q " + $ocm;
	if (eval($selQuery + "-vertex")) $compSelType = "vertex";
	else if (eval($selQuery + "-edge")) $compSelType = "edge";
	else if (eval($selQuery + "-facet")) $compSelType = "facet";
	else if (eval($selQuery + "-meshComponents")) $compSelType = "meshComponents"; 
	else if (eval($selQuery + "-cv")) $compSelType = "cv";
	else $compSelType = "none";

	// Build setup command
	string $startCmd = "";
	if (size($currentHilite) == 0) $startCmd += "hilite;";
	$startCmd += "selectType " + $ocm + "-alc 0;";
	$startCmd += "selectType " + $ocm + "-" + $component + " 1;";
	$startCmd += "select -clear;";
	if ($restoreSymmetry) $startCmd += "symmetricModelling -s 0;";

	// Build final command
	string $cmd = "manipRotateAlignHandleToComponent($Selection1[0], ";
	$cmd += "{\"" + stringArrayToString($currentSelection, "\", \"") + "\"}, ";
	$cmd += "{\"" + stringArrayToString($currentHilite, "\", \"") + "\"}, ";
	$cmd += "\"" + $compSelType + "\", " + $restoreSymmetry + ");";

	int $multi = ($component == "meshComponents");
	int $verts = ($multi || $component == "vertex");
	int $edges = ($multi || $component == "edge");
	int $faces = ($multi || $component == "facet");

	string $pointMsg = (uiRes("m_manipRotateOrient.kOrientRotateManipComponentPrompt"));
	$ctx = `scriptCtx
				-title (uiRes("m_manipRotateOrient.kOrientRotateManipComponentScaleTo"))
				-toolStart $startCmd
				-finalCommandScript $cmd
				-showManipulators off
				-totalSelectionSets 1
				-setSelectionCount 1
			// Types of point allowed in selection
			// -----------------------------------
				-controlVertex on
				-editPoint on
				-polymeshVertex	$verts
				-polymeshEdge $edges
				-polymeshFace $faces
				-locatorXYZ on
				-locator on
				-joint on
				-jointPivot on
				-scalePivot on
				-rotatePivot on
				-subdivMeshPoint on
				-latticePoint on
				-particle on
				-motionTrailPoint on
				-motionTrailTangent on
			// -----------------------------------
				-setNoSelectionPrompt $pointMsg
				-setNoSelectionHeadsUp $pointMsg
				-exitUponCompletion on
				-setAutoComplete on`;
			
	setToolTo $ctx;
}

// This procedure creates context to allow orient axis of rotate manipulator
// relative to existing objects in the scene.
// It orients selected handle based on the specified mode.
// Possible modes:
//		1 - point to vertex;
//		2 - align with edge;
//		3 - align with face normal;
//		4 - align to multi component (vertex/edge/face)

global proc manipRotateOrient(int $mode) 
{
	global int $manipOrientLast = 4;
	if ($mode == -1) $mode = $manipOrientLast;
	else if ($mode != 0) $manipOrientLast = $mode;

	switch($mode) {
	case 0:
		manipRotateContext -edit -orientAxes 0 0 0 Rotate;
		break;
	case 1:
		manipRotateAlignComponent("vertex");
		break;
	case 2:
		manipRotateAlignComponent("edge");
		break;
	case 3:
		manipRotateAlignComponent("facet");
		break;
	case 4:
		manipRotateAlignComponent("meshComponents");
		break;
	}
}
