// Copyright (C) 1997-2014 Autodesk, Inc., and/or its licensors.
// All rights reserved.
//
// The coded instructions, statements, computer programs, and/or related
// material (collectively the "Data") in these files contain unpublished
// information proprietary to Autodesk, Inc. ("Autodesk") and/or its licensors,
// which is protected by U.S. and Canadian federal copyright law and by
// international treaties.
//
// The Data is provided for use exclusively by You. You have the right to use,
// modify, and incorporate this Data into other products for purposes authorized 
// by the Autodesk software license agreement, without fee.
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND. AUTODESK
// DOES NOT MAKE AND HEREBY DISCLAIMS ANY EXPRESS OR IMPLIED WARRANTIES
// INCLUDING, BUT NOT LIMITED TO, THE WARRANTIES OF NON-INFRINGEMENT,
// MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE, OR ARISING FROM A COURSE 
// OF DEALING, USAGE, OR TRADE PRACTICE. IN NO EVENT WILL AUTODESK AND/OR ITS
// LICENSORS BE LIABLE FOR ANY LOST REVENUES, DATA, OR PROFITS, OR SPECIAL,
// DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES, EVEN IF AUTODESK AND/OR ITS
// LICENSORS HAS BEEN ADVISED OF THE POSSIBILITY OR PROBABILITY OF SUCH DAMAGES.

global proc setupFluidShaderForParticles( string $fluid )
{
	setAttr ($fluid + ".densityMethod") 0;
	setAttr ($fluid + ".velocityMethod") 0;
	setAttr ($fluid + ".shadedDisplay") 0;
	setAttr ($fluid + ".boundaryDraw") 5;
	setAttr ($fluid + ".opacityInput") 4;
	setAttr ($fluid + ".selfShadowing") 1;
	setAttr ($fluid + ".opacityTexture") 1;
	setAttr ($fluid + ".opacityTexGain") 0.5;
	setAttr ($fluid + ".dropoffShape") 0;
	setAttr ($fluid + ".frequency") 4;
	setAttr ($fluid + ".opacityInputBias") -0.2;
	setAttr ($fluid + ".opacity[0].opacity_Position") 0.1;
	setAttr ($fluid + ".depthMax") 2;
	setAttr ($fluid + ".quality") 0.5;
	setAttr ($fluid + ".contrastTolerance") 0.02;
	setAttr ($fluid + ".inflection") 1;
}

global proc setupWaterShaderForParticles( string $blinn )
{
	setAttr ($blinn+".specularRollOff") 0.2;
	setAttr ($blinn+".diffuse") 0.5;
	setAttr ($blinn+".refractions") 1;
	setAttr ($blinn+".refractiveIndex") 1.3;
	setAttr ($blinn+".reflectivity") 1;
	setAttr ($blinn+".specularColor") -type double3 1 1 1 ;
}

global proc initNParticleShader(string $nParticle, string $style )
{
	string $shadingGroup = ("nParticle" + $style + "SE");
	int $createNew = true;
	if( !objExists( $shadingGroup )){
		$shadingGroup = `sets -renderable true -noSurfaceShader true -empty -name $shadingGroup`;
		// create a shading group for this preset type
		string $smplers[] = `ls -type particleSamplerInfo`;
		string $particleSampler = "";
		if( size( $smplers ) > 0 ){
			$particleSampler = $smplers[0];
		} else {
			$particleSampler = `createNode "particleSamplerInfo"`;
		}
		
		string $surfaceShad = "";
		string $volumeShad = "";
		int $fluidVolume = ($style == "ThickCloud");
		$surfaceShad = `shadingNode -asShader -name ("np"+$style+"Blinn") "blinn"`;

		if( $fluidVolume ){
			$volumeShad = `shadingNode -asShader -name ("np"+$style+"Fluid") "fluidShape"`;
		} else {
			$volumeShad = `shadingNode -asShader -name ("np"+$style+"Volume") "particleCloud"`;
		}
		connectAttr -f ($surfaceShad + ".outColor") ($shadingGroup+".surfaceShader");
		connectAttr -f ($volumeShad + ".outColor") ($shadingGroup+".volumeShader");
		
		if( $style == "Points" ){
			
		} else if ($style == "Balls"){

		} else if ($style == "Cloud"){

		} else if ($style == "ThickCloud"){
			setupFluidShaderForParticles( $volumeShad );
		} else if ($style == "Water"){
			setupWaterShaderForParticles( $surfaceShad );
		}
		
		
		connectAttr ($particleSampler + ".outColor") ($surfaceShad + ".color");
		connectAttr ($particleSampler + ".outTransparency") ($surfaceShad + ".transparency");
		connectAttr ($particleSampler + ".outIncandescence") ($surfaceShad + ".incandescence");
		
		connectAttr ($particleSampler + ".outTransparency") ($volumeShad + ".transparency");
		if( $fluidVolume ){
			connectAttr ($particleSampler + ".outColor") ($volumeShad + ".color[0].color_Color");
			connectAttr ($particleSampler + ".outIncandescence") ($volumeShad + ".incandescence[0].incandescence_Color");
		} else {
			connectAttr ($particleSampler + ".outColor") ($volumeShad + ".color");
			connectAttr ($particleSampler + ".outIncandescence") ($volumeShad + ".incandescence");	
		}
	}
	sets -e -forceElement $shadingGroup $nParticle;
}
