// Copyright (C) 1997-2014 Autodesk, Inc., and/or its licensors.
// All rights reserved.
//
// The coded instructions, statements, computer programs, and/or related
// material (collectively the "Data") in these files contain unpublished
// information proprietary to Autodesk, Inc. ("Autodesk") and/or its licensors,
// which is protected by U.S. and Canadian federal copyright law and by
// international treaties.
//
// The Data is provided for use exclusively by You. You have the right to use,
// modify, and incorporate this Data into other products for purposes authorized 
// by the Autodesk software license agreement, without fee.
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND. AUTODESK
// DOES NOT MAKE AND HEREBY DISCLAIMS ANY EXPRESS OR IMPLIED WARRANTIES
// INCLUDING, BUT NOT LIMITED TO, THE WARRANTIES OF NON-INFRINGEMENT,
// MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE, OR ARISING FROM A COURSE 
// OF DEALING, USAGE, OR TRADE PRACTICE. IN NO EVENT WILL AUTODESK AND/OR ITS
// LICENSORS BE LIABLE FOR ANY LOST REVENUES, DATA, OR PROFITS, OR SPECIAL,
// DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES, EVEN IF AUTODESK AND/OR ITS
// LICENSORS HAS BEEN ADVISED OF THE POSSIBILITY OR PROBABILITY OF SUCH DAMAGES.

//
//
//  Creation Date:  April 17, 1997
//
//  Description:
//      The alignPreset() procedure executes an align curve/surface operation
//      on a pair of curves/surfaces based on the align option vars. In general
//		if you have n curves/surfaces selected, only the last 2 curves/surfaces
//		would be aligned.
//
//  Input Arguments:
//      None.
//
//  Return Value:
//      None.
//

proc string pieceTogetherAlignCmd(
 	int $history,
	int $replaceOriginal,
 	int $attach,
	int $keepMultKnots,
	int $positionalType,
	int $doTangent,
	int $tangentType,
	int $doCurvature,
	float $tangentScale1,
	float $tangentScale2,
	float $curvatureScale1,
	float $curvatureScale2 )
//
//	Description :
//		Piece together an align command.
//
{
	string $cmd = "";
//	$cmd = "align ";

	// construction history
	$cmd = $cmd + " -ch ";
	if ( $history == 1 ) $cmd = $cmd + "on";
	else  $cmd = $cmd + "off";
	
	// replace original
	if ( $replaceOriginal == 1 ) $cmd = $cmd + " -rpo on";
	else $cmd = $cmd + " -rpo off";

	// attach
	if ( $attach == 1 )
	{
		$cmd = $cmd + " -at true";
		if ( $keepMultKnots == 1 ) $cmd = $cmd + " -kmk true";
		else $cmd = $cmd + " -kmk false";
	}
	else
	{
		// when attach is off, keep multiple knots has no meaning
		$cmd = $cmd + " -at false -kmk false";
	}

	// positional continuity type
	$cmd = $cmd + " -pct " + $positionalType;

	// tangent continuity
	if ( $doTangent == 1 )
	{
		$cmd = $cmd + " -tc true -tct " + $tangentType + " -ts1 " + $tangentScale1 + " -ts2 " + $tangentScale2;
		if ( $doCurvature == 1 ) $cmd = $cmd + " -cc true -cs1 " + $curvatureScale1 + " -cs2 " + $curvatureScale2;
		else $cmd = $cmd + " -cc false";
	}
	else
	{
		// tangent continuity is off so curvature continuity does not apply
		$cmd = $cmd + " -tc false -cc false";
	}

	return $cmd;

}

global proc alignPreset(
 	int $history,
	int $replaceOriginal,
 	int $attach,
	int $keepMultKnots,
	int $positionalType,
	int $doTangent,
	int $tangentType,
	int $doCurvature,
	float $tangentScale1,
	float $tangentScale2,
	float $curvatureScale1,
	float $curvatureScale2 )
//
//	align with the preset options.
//	Use this proc when operation dragged to Shelf.
//
{
	string $cmd = pieceTogetherAlignCmd( $history, $replaceOriginal, $attach, $keepMultKnots, $positionalType, $doTangent, $tangentType, $doCurvature, $tangentScale1, $tangentScale2, $curvatureScale1, $curvatureScale2 );

	int $nitems = 2;
	$cmd = appendToCmdPlaceHoldersForSelectionItems( $cmd, $nitems );

	// Get the list of nurbs curves/surfaces selected.
	//
	global int $gSelectNurbsCurvesBit;
	global int $gSelectCurvesOnSurfacesBit;
	global int $gSelectNurbsSurfacesBit;
	global int $gSelectIsoparmsBit;
	global int $gSelectCurveParmPointsBit;
	global int $gSelectEditPointsBit;
	string $surfacesList[] = `filterExpand -ex true -sm $gSelectNurbsSurfacesBit -sm $gSelectIsoparmsBit`;
	string $curvesList[] = `filterExpand -ex true -sm $gSelectNurbsCurvesBit -sm $gSelectCurvesOnSurfacesBit -sm $gSelectCurveParmPointsBit -sm $gSelectEditPointsBit`;

	int $numSurfaces = size($surfacesList);
	int $numCurves = size($curvesList);
	if ( $numSurfaces + $numCurves == 0 )
	{
		error (uiRes("m_alignPreset.kAlignInvalidSelection"));
	}
	else if ( $numCurves == 1 && $numSurfaces == 0 )
	{
		error (uiRes("m_alignPreset.kAlignTooFewCurves"));
	}
	else if ( $numCurves == 0 && $numSurfaces == 1 )
	{
		error (uiRes("m_alignPreset.kAlignTooFewSurfaces"));
	}
	else if ( $numCurves == 1 && $numSurfaces == 1 )
	{
		error (uiRes("m_alignPreset.kAlignImproperSelection"));
	}
	else if ( $numCurves > 1 || $numSurfaces > 1 )
	{
		int $doCurveAlign;
		if ( $numCurves > 1 && $numSurfaces > 1 )
		{
			 warning((uiRes("m_alignPreset.kWarningDifferentTypes")) );
			// figure out which items were selected last and do align on
			// those types of objects only
			string $selectedList[] = `filterExpand -ex true -sm $gSelectNurbsSurfacesBit -sm $gSelectIsoparmsBit -sm $gSelectNurbsCurvesBit -sm $gSelectCurvesOnSurfacesBit -sm $gSelectCurveParmPointsBit`;
			int $numSelected = size($selectedList);

			// if the last selected item is the last surface item then do
			// align on surfaces otherwise do align on curves
			if ( $surfacesList[$numSurfaces-1] == $selectedList[$numSelected-1] ) $doCurveAlign = 0;
			else $doCurveAlign = 1;
		}
		else if ( $numCurves > 1 ) $doCurveAlign = 1;
		else $doCurveAlign = 0;

		// just use the last 2 selected curves
		//
		if ( $doCurveAlign == 1 && $numCurves > 2 )
			 warning((uiRes("m_alignPreset.kWarningTooManyCurves")) );
		else if ( $doCurveAlign == 0 && $numSurfaces > 2 ) 
			warning((uiRes("m_alignPreset.kWarningTooManySurfaces")) );

		string $alignPair[2];
		if ( $doCurveAlign == 1 ) 
		{
			$cmd = "alignCurve " + $cmd;
			$alignPair[0] = $curvesList[$numCurves-2];
			$alignPair[1] = $curvesList[$numCurves-1];
		}
		else 
		{
			$cmd = "alignSurface " + $cmd;
			$alignPair[0] = $surfacesList[$numSurfaces-2];
			$alignPair[1] = $surfacesList[$numSurfaces-1];
		}

		if ( $history == 0 && $replaceOriginal == 1 && $attach == 1 )
		{
			// delete history on each input to align cmd (so that command won't
			// force history on)
			//
			string $buffer[];
			tokenize($alignPair[0], ".", $buffer);
			string $itemName = $buffer[0];
			$buffer = `listHistory -pdo 1 $itemName`;
			if ( size($buffer) > 0 )
			{
				// the first item has history so delete it
				//
				warning((uiRes("m_alignPreset.kWarningHistoryAffected")) );
				evalEcho("delete -ch " + $itemName);
			}

			tokenize($alignPair[1], ".", $buffer);
			$itemName = $buffer[0];
			$buffer = `listHistory -pdo 1 $itemName`;
			if ( size($buffer) > 0 )
			{
				// the second item has history so delete it
				//
				warning((uiRes("m_alignPreset.kWarningHistoryDeleted")) );
				evalEcho("delete -ch " + $itemName);
			}
		}

		string $results[] = executeCmdOnItems( $cmd, $alignPair );	

		// select the results.
		//
		int $resultCount = size($results);
		if ( $resultCount > 0 ) 
		{
			string $selectString;
        	$selectString = "select ";
			if ( $replaceOriginal && $attach )
			{
				if ( $history == 0 )
				{
					// delete the second curve since it is no longer required
					evalEcho("delete " + $results[1]);
				}
				else
				{
					// make the second curve an intermediate object (so that
					// the user won't ever see it). Note: can't do "delete"
					// here or else align result will go away due to history
					// on.
					//
					string $resultShapes[] = `listRelatives -s $results[1]`;
					int $shapeCount = size($resultShapes);
					if ( $shapeCount > 0 )
					{
						evalEcho("setAttr " + $resultShapes[0] + ".io true");
					}
				}
				$selectString +=  $results[0];
			}
			else
			{
				int $i;
				for ( $i = 0; $i < $resultCount; $i++ ) 
				{
					$selectString +=  $results[$i];
					$selectString += " ";
				}
			}
			$selectString += ";";
			select -cl;
			eval($selectString);
		}
	}
}
