// Copyright (C) 1997-2014 Autodesk, Inc., and/or its licensors.
// All rights reserved.
//
// The coded instructions, statements, computer programs, and/or related
// material (collectively the "Data") in these files contain unpublished
// information proprietary to Autodesk, Inc. ("Autodesk") and/or its licensors,
// which is protected by U.S. and Canadian federal copyright law and by
// international treaties.
//
// The Data is provided for use exclusively by You. You have the right to use,
// modify, and incorporate this Data into other products for purposes authorized 
// by the Autodesk software license agreement, without fee.
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND. AUTODESK
// DOES NOT MAKE AND HEREBY DISCLAIMS ANY EXPRESS OR IMPLIED WARRANTIES
// INCLUDING, BUT NOT LIMITED TO, THE WARRANTIES OF NON-INFRINGEMENT,
// MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE, OR ARISING FROM A COURSE 
// OF DEALING, USAGE, OR TRADE PRACTICE. IN NO EVENT WILL AUTODESK AND/OR ITS
// LICENSORS BE LIABLE FOR ANY LOST REVENUES, DATA, OR PROFITS, OR SPECIAL,
// DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES, EVEN IF AUTODESK AND/OR ITS
// LICENSORS HAS BEEN ADVISED OF THE POSSIBILITY OR PROBABILITY OF SUCH DAMAGES.

proc findAllJoints( string $node, string $all[] )
{
	if ( `objectType -isAType "joint" $node` == false )
		return;

	$all[ size( $all ) ] = $node;

	string $children[] = `listRelatives -children $node`;
	for ( $child in $children )
		findAllJoints( ($node+"|"+$child), $all );
}

// Sever connections between a clip and its ghost
proc disconnectClipFromGhost( string $clip )
{
	if ( size($clip) == 0 )
		return;

	string $ghost = getGhostShapeForClip( $clip );
	if ( size($ghost) == 0 )
		return;

	disconnectAttr ( $ghost + ".clipData" ) ( $clip  + ".clipData" );
	delete $ghost;
}

global proc performSetHierarchyRoot()
{
	string $characters[] = getCharactersForAction();
	if ( size( $characters ) > 1 )
		error( (uiRes("m_performSetHierarchyRoot.kTooManyActiveCharacters")) );

	if ( size( $characters ) == 0  )
		error( (uiRes("m_performSetHierarchyRoot.kNoActiveCharacters")) );

	string $sel[] = `ls -sl`;
	if ( size( $sel ) == 0 )
		error( (uiRes("m_performSetHierarchyRoot.kNothingSelected")) );

	if ( `objectType -isAType "transform" $sel[0]` == false )
	{
		string $msg = (uiRes("m_performSetHierarchyRoot.kNodeNotATransform"));
		error( `format -s $sel[0] $msg` );
	}

	string $clips[];

	string $scheduler = `character -q -sc $characters[0]`;
	if ( size( $scheduler ) )
		$clips = `clipSchedule -q -name $scheduler`;

	// Check if a clipToGhost node exists ...
	string $clipToGhostNodes[] = `listConnections -type clipToGhostData -d 1 -s 0 ( $characters[0] + ".message" )`;
	string $ghostedClips[];

	// ... if so 
	if ( size( $clipToGhostNodes ) )
	{
		// ... determine the clips in the scene that are ghosted
		$ghostedClips = getGhostedClips( $clipToGhostNodes[0] );

		// ... delete the clipToGhost node
		delete $clipToGhostNodes[0];

		// ... and sever any remaining connections between the clips and the ghost.
		for ( $clip in $ghostedClips )
			disconnectClipFromGhost( $clip );
	}

	// At this point there is no clipToGhost node and any old ghosts have been removed.
	// Next, create a new clipToGhost node ...
	string $clipToGhost = `createNode clipToGhostData` ;

	//  ... connect joints required to visualize the ghost
	string $members[] = {};
	findAllJoints( $sel[0], $members );
	for ( $i=0; $i<size($members); $i++ )
		connectAttr ( $members[$i] + ".message" ) ( $clipToGhost + ".members[" + $i + "]" );

	connectAttr ( $characters[0] + ".message" ) ( $clipToGhost + ".character" );

	// ... and wire up all clips to the new clipToGhost node
	for ( $clip in $clips )
		connectClipAndClipToGhost( $clip, $clipToGhost, $scheduler );

	// ... recreate the ghost on the clips (if any existed before this operation)
	performCreateClipGhost($ghostedClips);

	// restore the original selection
	select -r $sel;
}

