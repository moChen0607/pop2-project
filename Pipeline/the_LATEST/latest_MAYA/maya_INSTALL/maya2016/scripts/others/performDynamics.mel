// Copyright (C) 1997-2014 Autodesk, Inc., and/or its licensors.
// All rights reserved.
//
// The coded instructions, statements, computer programs, and/or related
// material (collectively the "Data") in these files contain unpublished
// information proprietary to Autodesk, Inc. ("Autodesk") and/or its licensors,
// which is protected by U.S. and Canadian federal copyright law and by
// international treaties.
//
// The Data is provided for use exclusively by You. You have the right to use,
// modify, and incorporate this Data into other products for purposes authorized 
// by the Autodesk software license agreement, without fee.
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND. AUTODESK
// DOES NOT MAKE AND HEREBY DISCLAIMS ANY EXPRESS OR IMPLIED WARRANTIES
// INCLUDING, BUT NOT LIMITED TO, THE WARRANTIES OF NON-INFRINGEMENT,
// MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE, OR ARISING FROM A COURSE 
// OF DEALING, USAGE, OR TRADE PRACTICE. IN NO EVENT WILL AUTODESK AND/OR ITS
// LICENSORS BE LIABLE FOR ANY LOST REVENUES, DATA, OR PROFITS, OR SPECIAL,
// DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES, EVEN IF AUTODESK AND/OR ITS
// LICENSORS HAS BEEN ADVISED OF THE POSSIBILITY OR PROBABILITY OF SUCH DAMAGES.

source dynApplyCallback.mel;
//
//
//  Creation Date:  April, 1997
//
//  Description:
//     This is one of five scripts used to implement menus and option boxes for
//  the Dynamics menu.  The five scripts are:
//
//    dynCreateLayout - makes the layout of the option boxes, declares the controls
//    dynApplyCallback - callback routines to set values of option vars from
//                      the option controls.
//    performDynamics - generates command lines which are invoked when a menu item
//                      is selected or dragged to the shelf.
//    dynSetOptionVars - sets default values of option variables (the variables which
//                      store the user's values for the option boxes)
//    dynSetOptionControls - sets values of the option box controls from the option vars.
//                      Sort of the inverse of dynApplyCallback.
//
//    All the data is actually stored in option vars.  These routines basically pass
//    the option vars around.  The flow is:
//
//    User brings up option box: 
//        dynCreateLayout sets up the option controls. (Done only once.) 
//        dynSetOptionVars creates option vars and sets factory defaults,
//           if the variables don't already exist. (If the variables have been
//           saved with the user's prefs, they are automatically read from there.)
//		  dynSetOptionControls reads values from option vars, sets 
//           option box controls accordingly.
//
//    User changes control:  
//        dynApplyCallback stores values in option vars 
//
//    User hits Create:  
//        performDynamics reads values from option vars, generates command
//      
//  
//  NOTE: There are frequent references in this script to "create" and "add."  These
//  were two different types of menu choices used in versions perior to v3.0.
//  As of v3.0, there is no more create vs. add distinction and these references are
//  largely vestigial.  Unfortunately we don't have the time to remove them all or
//  restructure the scripts.  js 11-01-99
//
//  Input Arguments to performDynamics():
//		$createFlag:	1 = create field/emitter 
//						0 = add field/emitter/collision/goal
//						2 = create/add not relevant
//
//		string $type      -- the command selected
//		int    $optionBox -- bring up the option box or not
//
//  Return Value:
//      None.
//
//
//  ========== createDynamicsOptions ==========
//
//  SYNOPSIS
//      Create the Dynamics option box and option vars,
//		and set up the appropriate layout for the selected
//		command.
//
global proc createDynamicsOptions (string $type, int $createFlag)
{
	// Title of the option box.
	//
	string $optionBoxTitle;

	// Used in the setOptionsControls command to tell whether to reset
	// the option vars and controls to their default values if the
	// option vars already exist.
	//
	int $resetToDefaults;

	// Name and arguments of the call to set the values of the option
	// box controls.
	//
	string $setOptionControls = "dynSetOptionControls ";

	// Name and arguments of the callback, called when the Create/Add
	// button is selected, that sets the option vars from the controls
	// and calls performDynamics to execute the command.
	//
	string $applyCallback = "dynApplyCallback ";

	// $type = name of the command (with initial capital letter)
	// for this option box 

	// Do some separate processing for rigid bodies, as we have to distinguish
	// between active and passive.
	//
	if ($type == "ActiveRigid" || $type == "PassiveRigid")
	{
		// Set the type optionVar to active or passive
		//
		if ($type == "ActiveRigid")
			optionVar -intValue rigidCollisionType 1;
		else
			optionVar -intValue rigidCollisionType 0;

		// Set the command type arg of the dynSetOptionControls proc.
		//
		$setOptionControls = $setOptionControls + "Rigid";

		// Set the command type arg of the option box Create/Add button
		// callback.
		//
		$applyCallback = $applyCallback + "Rigid";

		// Set the option box title for rigid bodies.
		//
		$optionBoxTitle = (uiRes("m_performDynamics.kRigidOptions"));
	}
	else
	{
		// Set the command type arg of the dynSetOptionControls proc.
		//
		$setOptionControls = $setOptionControls + $type;

		// Set the command type arg of the option box Create/Add button
		// callback.
		//
		$applyCallback = $applyCallback + $type;

		// Set the option box title.
		//
		if ($type == "ParticleRenderCache")
			$optionBoxTitle = (uiRes("m_performDynamics.kParticleDiskCacheOptions"));
		else
		if ($type == "ParticleInstancer")
			$optionBoxTitle = (uiRes("m_performDynamics.kParticleInstancerOptions"));
		else
		if ($type == "VolumeAxis")
			$optionBoxTitle = (uiRes("m_performDynamics.kVolumeAxisOptions"));
		else
		if ($type == "Constrain")
			$optionBoxTitle = (uiRes("m_performDynamics.kConstraintOptions"));		
		
		else
		if ($type == "Spring")
			$optionBoxTitle = (uiRes("m_performDynamics.kSpringOptions"));
		else
		if ($type == "Soft")
			$optionBoxTitle = (uiRes("m_performDynamics.kSoftOptions"));	
		else
		if ($type == "NSoft")
			$optionBoxTitle = (uiRes("m_performDynamics.kNSoftOptions"));	
		else
		if ($type == "Goal")
			$optionBoxTitle = (uiRes("m_performDynamics.kGoalOptions"));	
		else
		if ($type == "Air")
			$optionBoxTitle = (uiRes("m_performDynamics.kAirOptions"));
		else
		if ($type == "Drag")
			$optionBoxTitle = (uiRes("m_performDynamics.kDragOptions"));
		else
		if ($type == "Gravity")
			$optionBoxTitle = (uiRes("m_performDynamics.kGravityOptions"));	
		else
		if ($type == "Newton")
			$optionBoxTitle = (uiRes("m_performDynamics.kNewtonOptions"));
		else
		if ($type == "Radial")
			$optionBoxTitle = (uiRes("m_performDynamics.kRadialOptions"));	
		else
		if ($type == "Turbulence")
			$optionBoxTitle = (uiRes("m_performDynamics.kTurbulenceOptions"));
		else
		if ($type == "Uniform")
			$optionBoxTitle = (uiRes("m_performDynamics.kUniformOptions"));	
		else
		if ($type == "Vortex")
			$optionBoxTitle = (uiRes("m_performDynamics.kVortexOptions")); 		
		else
		if ($type == "Collision")
			$optionBoxTitle = (uiRes("m_performDynamics.kCollisionOptions"));	
		
		// For emitters, label according to whether we are creating
		// a positional or emitting from an object.
		//
		else
		if (($type == "Emitter" || $type == "nEmitter") && $createFlag == 1)
			$optionBoxTitle = (uiRes("m_performDynamics.kEmitterOptionsCreate"));
		else
		if (($type == "Emitter" || $type == "nEmitter") && $createFlag == 0)
			$optionBoxTitle = (uiRes("m_performDynamics.kEmitterOptions"));								
	}

	// Set the title for the apply button
	// 
	string $applyButtonTitle;
	$applyButtonTitle = (uiRes("m_performDynamics.kCreate"));
	
	// Get the parent option box layout and set to it.
	//
	string $layout = getOptionBox();
	setParent $layout;

	// Build the window, with a tab layout
	//
	setUITemplate -pushTemplate DefaultTemplate;
	waitCursor -state 1;

	tabLayout -scr true -tv false;
	string $parent = `columnLayout -adjustableColumn 1 -columnAttach "both" 5` ;

	// Create the layout for this option box.
	//
	if ($type == "ActiveRigid" || $type ==  "PassiveRigid")
		dynCreateLayout $parent "Rigid" $createFlag;
	else
		dynCreateLayout $parent $type $createFlag;
		
	waitCursor -state 0;
	setUITemplate -popTemplate;

	// Get and set the title and callback for the standard buttons.
	//
	int $executeCmd1;

    string $applyBtn = getOptionBoxApplyBtn();

	// Set up "apply" button with callback for executing the command.
	//
	$executeCmd = 1;
    button -edit
		-label $applyButtonTitle
        -command ($applyCallback + " " + $parent + " " + $executeCmd)
        $applyBtn;

    //  'Save' button.
    //
	// Set up "Save" button, to save the option vars, 
	// but not execute the command.
	//
	$executeCmd = 0;
    string $saveBtn = getOptionBoxSaveBtn();
    button -edit
        -command ($applyCallback + " " + $parent + " " + $executeCmd + "; hideOptionBox")
        $saveBtn;

    // Set up 'Reset' button to reset the option vars and controls 
	// to their default values.
    //
    string $resetBtn = getOptionBoxResetBtn();

	// The last arg means do reset the option controls and vars to their
	// default value.
	//
	$resetToDefaults = 1;
    button -edit
        -command ($setOptionControls + " " + $parent + " " + $resetToDefaults)
        $resetBtn;

	setOptionBoxTitle($optionBoxTitle);


	//	Customize the 'Help' menu item text.
	//
	switch ($type) 
	{
		case "Air":
			setOptionBoxHelpTag( "Air" );
			break;		

		case "Drag":
			setOptionBoxHelpTag( "Drag" );
			break;		

		case "Gravity":
			setOptionBoxHelpTag( "Gravity" );
			break;

		case "Newton":
			setOptionBoxHelpTag( "Newton" );
			break;

		case "Radial":
			setOptionBoxHelpTag( "Radial" );
			break;

		case "Turbulence":
			setOptionBoxHelpTag( "Turbulence" );
			break;

		case "Uniform":
			setOptionBoxHelpTag( "Uniform" );
			break;

		case "Vortex":
			setOptionBoxHelpTag( "Vortex" );
			break;

		case "VolumeAxis":
			setOptionBoxHelpTag( "VolumeAxis" );
			break;

		case "Emitter":
			if ($createFlag == 1) {
				setOptionBoxHelpTag( "CreateEmitter" );
			} else if ($createFlag == 0) {
				setOptionBoxHelpTag( "EmitfromObject" );
			}
			break;
			
		case "nEmitter":
			if ($createFlag == 1) {
				setOptionBoxHelpTag( "nCreateEmitter" );
			} else if ($createFlag == 0) {
				setOptionBoxHelpTag( "nEmitfromObject" );
			}
			break;

		case "Collision":
			setOptionBoxHelpTag( "MakeCollide" );
			break;

		case "Goal":
			setOptionBoxHelpTag( "Goal" );
			break;

		case "ActiveRigid":
			setOptionBoxHelpTag( "CreateActiveRigidBody" );
			break;

		case "PassiveRigid":
			setOptionBoxHelpTag( "CreatePassiveRigidBody" );
			break;

		case "Soft":
			setOptionBoxHelpTag( "CreateSoftBody" );
			break;

		case "NSoft":
			setOptionBoxHelpTag( "CreateNSoftBody" );
			break;

		case "Constrain":
			setOptionBoxHelpTag( "CreateConstraint" );
			break;

		case "Spring":
			setOptionBoxHelpTag( "CreateSprings" );
			break;

		case "ParticleInstancer":
			setOptionBoxHelpTag( "Instancer" );
			break;

		case "ParticleRenderCache":
			setOptionBoxHelpTag( "CreateParticleDiskCache" );
			break;
	}	


	// Call the "method" to set the values of the option box controls.
	//
	// The last arg means do not reset the option controls and vars to their
	// default value if they already exist.  Just use the current values.
	//
	$resetToDefaults = 0;
	eval (($setOptionControls + " " + $parent + " " + $resetToDefaults));      

	showOptionBox();	
}

global proc string dynSetCollisionShelfCommand(string $theCmd)
{
	// This is just setting up the command to drag to the shelf.  
	// The return command is the mel script that will execute
	// the collision command.
	//
	string $collisionCmd = "\"" + $theCmd + "\"";
	$collisionCmd = "dynExecuteCollisionCommand " + $collisionCmd;

	return $collisionCmd;

}	// dynSetCollisionShelfCommand

global proc string dynSetCreateFieldShelfCommand(string $theCmd)
{
	// This is just setting up the command to drag to the shelf.  
	// In create mode, the return command is the mel script
	// that will do the create and connect to items in the selection
	// list;  in add mode the return command is just the field command, 
	//	and it will add fields to the selection list.
	//
	string $fieldCmd = "\"" + $theCmd + "\"";
	$fieldCmd = "dynExecuteFieldCommands "+ "1 " + $fieldCmd;

	return $fieldCmd;

}	// dynSetCreateFieldShelfCommand


global proc string dynSetEmitterShelfCommand(int $isCreate, string $theCmd, int $createNParticle)
{
	// This is just setting up the command to drag to the shelf.  
	// The return command is the mel script that will make the
	// emitter, make the particle to emit into, and connect the particle
	// to the emitters.
	//
	string $emitterCmd = "\"" + $theCmd + "\"";
	$emitterCmd = 
		("dynExecuteEmitterCommands " + $isCreate + " " + $emitterCmd + " " + $createNParticle);

	return $emitterCmd;

}	// dynSetEmitterShelfCommand


global proc string dynSetGoalShelfCommand(string $theCmd)
{
	// This is just setting up the command to drag to the shelf.  
	// The return command is the mel script that will execute
	// the goal command.
	//
	string $goalCmd = "\"" + $theCmd + "\"";
	$goalCmd = "dynExecuteGoalCommand " + $goalCmd;

	return $goalCmd;

}	// dynSetGoalShelfCommand


//  ================== dynSetName ==================
//
//  SYNOPSIS
//		Set the name (-n) command arg, if a name has been specified.
//
global proc string dynSetName(string $theCmd)
{
	string $controlName = $theCmd+"Name";
	string $name = `optionVar -query $controlName`;

	// GG: strip out beginning spaces
	$name = match("[^ ].+", $name);
	if (size($name) > 0)
		$returnCmd = " -name \""+$name+"#\" ";

	return $returnCmd;
}


//  =============== dynSetMaxDist ====================
//
//  SYNOPSIS
//		Set the max distance command arg.  If "Use Max Distance" has not been
//		set, set it to -1, otherwise set it to the value of the
//		slider.
//
global proc string dynSetMaxDist(string $theCmd, string $cmdArgs)
{
	string $cBox = $theCmd+"MaxDistCBox";
	string $fSlider = $theCmd+"MaxDistance";
	string $returnCmd;


	if (`optionVar -query $cBox` == 0)
		$returnCmd = $cmdArgs + " -mxd -1 ";
	else
	{
		float $maxDist = `optionVar -query $fSlider`;
		$returnCmd = $cmdArgs + " -mxd "+$maxDist+" ";
	}

	return $returnCmd;

}	// dynSetMaxDist

proc string dynSetVolumeFieldCmdString( string $field )
//
//  Description:
//     Returns a string to append to the command string
//  to take care of the volume field aprameters
{
	string $cmd = " ";

	int $typeChoice = `optionVar -query ($field+"VolumeFieldTypesOM")`;

	switch($typeChoice)
	{
		case 1: $cmd = $cmd + "-vsh none ";
			break;
		case 2: $cmd = $cmd + "-vsh cube ";
				break;
		case 3: $cmd = $cmd + "-vsh sphere ";
				break;
		case 4: $cmd = $cmd + "-vsh cylinder ";
				break;
		case 5: $cmd = $cmd + "-vsh cone ";
			break;
		case 6: $cmd = $cmd + "-vsh torus ";
				break;
	}

	// volume exclusion doesn't apply to the volume axis field.
	//
	if ($field != "volumeAxis")
	{
		$cmd = $cmd + "-vex "+`optionVar -query ($field+"VolumeExclusion")`+" ";
	}

	$cmd = $cmd + "-vof "+`optionVar -query ($field+"VolumeOffsetX")`+" "
						 +`optionVar -query ($field+"VolumeOffsetY")`+" "
						 +`optionVar -query ($field+"VolumeOffsetZ")`+" ";
	$cmd = $cmd + "-vsw "+`optionVar -query ($field+"VolumeSweep")`+" ";
	$cmd = $cmd + "-tsr "+`optionVar -query ($field+"TorusSectionRadius")`+" ";

	return $cmd;
}

//  ============== setAirCmdString ==============
//
//  SYNOPSIS
//		Set the command and command args string for the air command.
//
global proc string setAirCmdString(int $isCreate)
{
	string $cmd;

	if ($isCreate)
		$cmd = "air -pos 0 0 0 ";
	else
		$cmd = "air ";

	$cmd = $cmd + dynSetName("air");
	$cmd = $cmd + "-m "+`optionVar -query airMagnitude`+" ";
	$cmd = $cmd + "-att "+`optionVar -query airAttenuation`+" ";
	$cmd = $cmd + "-dx "+`optionVar -query airDirectionX`+" ";
	$cmd = $cmd + "-dy "+`optionVar -query airDirectionY`+" ";
	$cmd = $cmd + "-dz "+`optionVar -query airDirectionZ`+" ";
	$cmd = $cmd + "-s "+`optionVar -query airSpeed`+" ";
	$cmd = $cmd + "-iv "+`optionVar -query airInheritVelocity`+" ";
	$cmd = $cmd + "-iro "+`optionVar -query airInheritRotation`+" ";
	$cmd = $cmd + "-vco "+`optionVar -query airComponent`+" ";
	//if (!$isCreate)
	//	$cmd = $cmd + "-pv "+`optionVar -query airPerVertex`+" ";

	int $enableSpread = `optionVar -query airEnableSpread`;
	$cmd = $cmd + "-es "+$enableSpread +" ";
	if ($enableSpread)
		$cmd = $cmd + "-sp "+`optionVar -query airSpread`+" ";

	$cmd = dynSetMaxDist("air", $cmd);

	$cmd = $cmd + dynSetVolumeFieldCmdString( "air" );

	return $cmd;
}

//  ============== setConstrainCmdString ==============
//
//  SYNOPSIS
//		Set the command and command args string for the constrain command.
//
global proc	string	setConstrainCmdString(int $numSelectedItems)
{
	string $cmd;

	int $whichConstraint = `optionVar -q constrainTypesOM`;
	switch($whichConstraint)
	{
		case 1: $cmd = "constrain -nail ";
				break;
		case 2: $cmd = "constrain -pin ";
				break;
		case 3: $cmd = "constrain -hinge ";
				break;
		case 4: $cmd = "constrain -spring ";
				break;
		case 5: $cmd = "constrain -barrier ";
				break;
	}

	$cmd = $cmd + dynSetName("constrain");

	if (`optionVar -query constrainPosCBox` == 1)
	{
		$cmd = $cmd + "-p "+`optionVar -q constrainPosX`+" "+ `optionVar -q constrainPosY`+" "+ `optionVar -q constrainPosZ`+" ";

	}

	if ( ( $whichConstraint == 3) || ( $whichConstraint == 5) )
	{
		$cmd = $cmd + "-o "+`optionVar -q constrainOrientX`+" "+ `optionVar -q constrainOrientY`+" "+ `optionVar -q constrainOrientZ`+" ";

	}

	if($whichConstraint == 4)
	{
		$cmd = $cmd + "-st "+`optionVar -q constrainSpringStiffness`+" ";
		$cmd = $cmd + "-d "+`optionVar -q constrainSpringDamping`+" ";
		if (`optionVar -query constrainSpringRestLengthCBox` == 1)
		{
			$cmd = $cmd + "-rl "+`optionVar -q constrainSpringRestLength`+" ";
		}
	}

	// If pin or if either hinge or spring and there are 2 items chosen,
	// then send the interpenetrate flag.
	//
	if (($whichConstraint == 2) ||
		(($whichConstraint == 3 || $whichConstraint == 4) && 
		  $numSelectedItems > 1)) 
	{
		$cmd = $cmd + "-i "+`optionVar -q constrainInterCB`+" " ;
	}

	return $cmd;
}

//  ============== setDragGravityCmdString ==============
//
//  SYNOPSIS
//		Set the command and command args string for the drag and
//		gravity commands.
//
global proc string setDragGravityCmdString(string $which, int $isCreate)
{
	string $cmd;

	if ($isCreate)
		$cmd = $which + " -pos 0 0 0 ";
	else
		$cmd = $which;

	$cmd = $cmd + dynSetName($which);
	$cmd = $cmd + "-m "+`optionVar -query ($which+"Magnitude")`+" ";
	$cmd = $cmd + "-att "+`optionVar -query ($which+"Attenuation")`+" ";
	$cmd = $cmd + "-dx "+`optionVar -query ($which+"DirectionX")`+" ";
	$cmd = $cmd + "-dy "+`optionVar -query ($which+"DirectionY")`+" ";
	$cmd = $cmd + "-dz "+`optionVar -query ($which+"DirectionZ")`+" ";

	if ($which == "drag")
		$cmd = $cmd + "-ud "+`optionVar -query ($which+"UseDirection")`+" ";

	//if (!$isCreate)
	//	$cmd = $cmd + "-pv "+`optionVar -query ($which+"PerVertex")`+" ";
	$cmd = dynSetMaxDist($which, $cmd);

	$cmd = $cmd + dynSetVolumeFieldCmdString( $which );

	return $cmd;
}

//  ============== setEmitterCmdString ==============
//
//  SYNOPSIS
//		Set the command and command args string for the emitter command.
//
global proc string setEmitterCmdString(int $isCreate)
{
	string $cmd;
	
	if ($isCreate)
		$cmd = "emitter -pos 0 0 0 ";
	else 
		$cmd = "emitter ";

	int $typeChoice = `optionVar -query emitterTypesOM`;

	// In Create, type 3 is volume.
	//
	if ($isCreate)
	{
		if ($typeChoice == 3)
			$typeChoice = 5;
	}
	// In Create, curve or surface is not valid.
	// If curve or surface was set, reset to omni.
	// Also reset the option.
	//
	if (($isCreate) && (($typeChoice == 3) || ($typeChoice == 4)))
	{
		optionVar -intValue emitterTypesOM 1;
		$typeChoice = 1;
	}
	else
	// In Add, volume isn't valid
	//
	if ((!$isCreate) && ($typeChoice == 5))
	{
		optionVar -intValue emitterTypesOM 1;
		$typeChoice = 1;
	}
 
	switch($typeChoice)
	{
		case 1: $cmd = $cmd + "-type omni ";
			break;
		case 2: $cmd = $cmd + "-type direction ";
				break;
		case 3: $cmd = $cmd + "-type surface ";
				break;
		case 4: $cmd = $cmd + "-type curve ";
				break;
		case 5: $cmd = $cmd + "-type volume ";
				break;
	}

	$cmd = $cmd + dynSetName("emitter");

	$cmd = $cmd + "-r "+`optionVar -query emitterRate`+" ";
	$cmd = $cmd + "-sro "+`optionVar -query emitterScaleRateByObjectSize`+" ";
	$cmd = $cmd + "-nuv "+`optionVar -query emitterNeedParentUV`+" ";

	int $cycleOption = `optionVar -query emitterCycleOM`;
	string $cycleString = "none";
	switch( $cycleOption )
	{
		case 1:
			$cycleString = "none";
			break;
		case 2:
			$cycleString = "frame";
			break;
		//case 3:
		//	$cycleString = "count";
		//	break;
	}

	$cmd = $cmd + "-cye "+ $cycleString + " ";
	$cmd = $cmd + "-cyi "+`optionVar -query emitterCycleInterval`+" ";

	$cmd = $cmd + "-spd "+`optionVar -query emitterSpeed`+" ";
	$cmd = $cmd + "-srn "+`optionVar -query emitterSpeedRandomRange`+" ";
	$cmd = $cmd + "-nsp "+`optionVar -query emitterNormalSpeed`+" ";
	$cmd = $cmd + "-tsp "+`optionVar -query emitterTangentSpeed`+" ";

	$cmd = $cmd + "-mxd "+`optionVar -query emitterMaxDistance`+" ";
	$cmd = $cmd + "-mnd "+`optionVar -query emitterMinDistance`+" ";
	$cmd = $cmd + "-dx "+`optionVar -query emitterDirectionX`+" ";
	$cmd = $cmd + "-dy "+`optionVar -query emitterDirectionY`+" ";
	$cmd = $cmd + "-dz "+`optionVar -query emitterDirectionZ`+" ";
	$cmd = $cmd + "-sp "+`optionVar -query emitterSpread`+" ";

	// Add in the volume parameters only if type is 5 (volume).
	//
	if ($typeChoice == 5)
	{
		int $volShapeChoice = `optionVar -query emitterVolumeShapeOM`;
		switch($volShapeChoice)
		{	
			case 1: $cmd = $cmd + "-vsh cube ";
				break;
			case 2: $cmd = $cmd + "-vsh sphere ";
				break;
			case 3: $cmd = $cmd + "-vsh cylinder ";
				break;
			case 4: $cmd = $cmd + "-vsh cone ";
				break;
			case 5: $cmd = $cmd + "-vsh torus ";
				break;
		}
		$cmd = $cmd + "-vof "+`optionVar -query emitterVolumeOffsetX`+" "
						 +`optionVar -query emitterVolumeOffsetY`+" "
						 +`optionVar -query emitterVolumeOffsetZ`+" ";
		$cmd = $cmd + "-vsw "+`optionVar -query emitterVolumeSweep`+" ";
		$cmd = $cmd + "-tsr "+`optionVar -query emitterTorusSectionRadius`+" ";
		$cmd = $cmd + "-afc "+`optionVar -query emitterAwayFromCenter`+" ";
		$cmd = $cmd + "-afx "+`optionVar -query emitterAwayFromAxis`+" ";
		$cmd = $cmd + "-arx "+`optionVar -query emitterAroundAxis`+" ";
		$cmd = $cmd + "-alx "+`optionVar -query emitterAlongAxis`+" ";
		$cmd = $cmd + "-rnd "+`optionVar -query emitterRandomSpread`+" ";
		$cmd = $cmd + "-drs "+`optionVar -query emitterDirectionalSpeed`+" ";
		$cmd = $cmd + "-ssz "+`optionVar -query emitterScaleSpeedBySize`+" ";
	}
	return $cmd;
}


//  ============== setRigidCmdString ==============
//
//  SYNOPSIS
//		Set the command and command args string for the rigid command.
//
global proc	string	setRigidCmdString()
{
	string $cmd;

	if (`optionVar -q rigidCollisionType` == 1) 
		$cmd = "rigidBody -active ";
	else 
		$cmd = "rigidBody -passive "; 

	$cmd = $cmd + dynSetName("rigid");
	$cmd = $cmd + "-m "+`optionVar -q rigidMass`+" ";
    $cmd = $cmd + "-dp "+`optionVar -q rigidDamping`+" ";
    $cmd = $cmd + "-sf "+`optionVar -q rigidStatFriction`+" ";
	$cmd = $cmd + "-df "+`optionVar -q rigidDynFriction`+" ";
	$cmd = $cmd + "-b "+`optionVar -q rigidBounciness`+" ";
	$cmd = $cmd + "-l "+`optionVar -q rigidLayer`+" ";
	$cmd = $cmd + "-tf "+`optionVar -q rigidTesselation`+" ";

	$cmd = $cmd + "-iv "+`optionVar -q rigidInitVelocityX`+" "+ `optionVar -q rigidInitVelocityY`+" "+ `optionVar -q rigidInitVelocityZ`+" ";

	$cmd = $cmd + "-iav "+`optionVar -q rigidAngVelocityX`+" "+ `optionVar -q rigidAngVelocityY`+" "+ `optionVar -q rigidAngVelocityZ`+" ";

	if (`optionVar -query rigidPosCBox` == 1)
	{
		$cmd = $cmd + "-p "+`optionVar -q rigidPosX`+" "+`optionVar -q rigidPosY`+" "+`optionVar -q rigidPosZ`+" ";
	}

	if (`optionVar -query rigidOrCBox` == 1)
	{
		$cmd = $cmd + "-o "+`optionVar -q rigidOrX`+" "+ `optionVar -q rigidOrY`+" "+ `optionVar -q rigidOrZ`+" ";
	}

	if (`optionVar -query rigidComCBox` == 1)
	{
		$cmd = $cmd + "-com "+`optionVar -q rigidComX`+" "+ `optionVar -q rigidComY`+" "+ `optionVar -q rigidComZ`+" ";
	}

	$cmd = $cmd + "-c "+`optionVar -q rigidCacheCBox`+" ";

	$cmd = $cmd + "-pc "+`optionVar -q rigidCollide`+" ";

	$cmd = $cmd + "-i "+`optionVar -q rigidImpulseX`+" "+ `optionVar -q rigidImpulseY`+" "+ `optionVar -q rigidImpulseZ`+" ";

	$cmd = $cmd + "-imp "+`optionVar -q rigidImpulsePosX`+" "+ `optionVar -q rigidImpulsePosY`+" "+ `optionVar -q rigidImpulsePosZ`+" ";

	$cmd = $cmd + "-si "+`optionVar -q rigidSpinImpulseX`+" "+ `optionVar -q rigidSpinImpulseY`+" "+ `optionVar -q rigidSpinImpulseZ`+" ";

	int $whichStandIn = `optionVar -q rigidStandInType`;

	switch($whichStandIn)
	{
		case 1: $cmd = $cmd + "-sio none ";
				break;
		case 2: $cmd = $cmd + "-sio cube ";
				break;

		case 3: $cmd = $cmd + "-sio sphere ";
				break;
	}

	return $cmd;
}



//  ============== setSpringCmdString ==============
//
//  SYNOPSIS
//		Set the command and command args string for the spring command.
//
global proc	string	setSpringCmdString()
{
	string $cmd = "spring ";

	$cmd = $cmd + dynSetName("spring");

	int $isAdd = `optionVar -q springAdd`;

	if ($isAdd)
		$cmd = $cmd + "-add ";

	int $isSet = `optionVar -q springNoDuplicate`;

	if ($isSet)
		$cmd = $cmd + "-noDuplicate true ";
	else
		$cmd = $cmd + "-noDuplicate false ";

	$isSet = `optionVar -q springExclusive`;

	if ($isSet)
		$cmd = $cmd + "-exclusive true ";

	int $springMethod = `optionVar -q springMethodsOM`;


	if ($springMethod == 1)
	{
		$cmd = $cmd + "-minMax true ";
		$cmd = $cmd + "-mnd "+`optionVar -q springMinDistance`+" "; 
		$cmd = $cmd + "-mxd "+`optionVar -q springMaxDistance`+" "; 
	}
	else if ($springMethod == 2)
	{
		$cmd = $cmd + "-all true ";
	}
	else if ($springMethod == 3)
	{
		$cmd = $cmd + "-wireframe true ";
		$cmd = $cmd + "-wl " + `optionVar -q springWireWalkLength` + " ";
	}

	if (!$isAdd)
	{
		int $usePS;

		$usePS = `optionVar -q springUseRestLengthPS`;
		if ($usePS)
		{
			$cmd = $cmd + "-useRestLengthPS true ";
		}
		else
		{
			$cmd = $cmd + "-useRestLengthPS false ";
			$cmd = $cmd + "-rl "+`optionVar -q springRestLength`+" "; 
		}

		$usePS = `optionVar -q springUseStiffnessPS`;
		if ($usePS)
			$cmd = $cmd + "-useStiffnessPS true ";
		else
			$cmd = $cmd + "-s "+`optionVar -q springStiffness`+" ";

		$usePS = `optionVar -q springUseDampingPS`;
		if ($usePS)
			$cmd = $cmd + "-useDampingPS true ";
		else
			$cmd = $cmd + "-d "+`optionVar -q springDamp`+" ";

		$cmd = $cmd + "-sfw "+`optionVar -q springStartForceWeight`+" ";
		$cmd = $cmd + "-efw "+`optionVar -q springEndForceWeight`+" ";

	}

	return $cmd;
}


//  ============== setNewtonCmdString ==============
//
//  SYNOPSIS
//		Set the command and command args string for the newton command.
//
global proc string setNewtonCmdString(int $isCreate)
{
	string $cmd;

	if ($isCreate)
		$cmd = "newton -pos 0 0 0 ";
	else
		$cmd = "newton ";

	$cmd = $cmd + dynSetName("newton");
	$cmd = $cmd + "-m "+`optionVar -query newtonMagnitude`+" ";
	$cmd = $cmd + "-att "+`optionVar -query newtonAttenuation`+" ";
	$cmd = $cmd + "-mnd "+`optionVar -query newtonMinDistance`+" ";
	//if (!$isCreate)
	//	$cmd = $cmd + "-pv "+`optionVar -query newtonPerVertex`+" ";
	$cmd = dynSetMaxDist("newton", $cmd);

	$cmd = $cmd + dynSetVolumeFieldCmdString( "newton" );

	return $cmd;
}

//  ============== setRadialCmdString ==============
//
//  SYNOPSIS
//		Set the command and command args string for the radial command.
//
global proc string setRadialCmdString(int $isCreate)
{
	string $cmd;

	if ($isCreate)
		$cmd = "radial -pos 0 0 0 ";
	else
		$cmd = "radial ";

	$cmd = $cmd + dynSetName("radial");
	$cmd = $cmd + "-m "+`optionVar -query radialMagnitude`+" ";
	$cmd = $cmd + "-att "+`optionVar -query radialAttenuation`+" ";
	$cmd = $cmd + "-typ "+`optionVar -query radialType`+" ";
	//if (!$isCreate)
	//	$cmd = $cmd + "-pv "+`optionVar -query radialPerVertex`+" ";
	$cmd = dynSetMaxDist("radial", $cmd);

	$cmd = $cmd + dynSetVolumeFieldCmdString( "radial" );
	return $cmd;
}


//  ============== setTurbulenceCmdString ==============
//
//  SYNOPSIS
//		Set the command and command args string for the turbulence command.
//
global proc string setTurbulenceCmdString(int $isCreate)
{
	string $cmd;

	if ($isCreate)
		$cmd = "turbulence -pos 0 0 0 ";
	else
		$cmd = "turbulence ";

	$cmd = $cmd + dynSetName("turbulence");
	$cmd = $cmd + "-m "+`optionVar -query turbulenceMagnitude`+" ";
	$cmd = $cmd + "-att "+`optionVar -query turbulenceAttenuation`+" ";
	$cmd = $cmd + "-f "+`optionVar -query turbulenceFrequency`+" ";
	$cmd = $cmd + "-phaseX "+`optionVar -query turbulencePhaseX`+" ";
	$cmd = $cmd + "-phaseY "+`optionVar -query turbulencePhaseY`+" ";
	$cmd = $cmd + "-phaseZ "+`optionVar -query turbulencePhaseZ`+" ";
	$cmd = $cmd + "-noiseLevel "+`optionVar -query turbulenceNoiseLevel`+" ";
	$cmd = $cmd + "-noiseRatio "+`optionVar -query turbulenceNoiseRatio`+" ";
	$cmd = dynSetMaxDist("turbulence", $cmd);

	$cmd = $cmd + dynSetVolumeFieldCmdString( "turbulence" );

	return $cmd;
}


//  ============== setUniformCmdString ==============
//
//  SYNOPSIS
//		Set the command and command args string for the uniform command.
//
global proc string setUniformCmdString(int $isCreate)
{
	string $cmd;

	if ($isCreate)
		$cmd = "uniform -pos 0 0 0 ";
	else
		$cmd = "uniform ";

	$cmd = $cmd + dynSetName("uniform");
	$cmd = $cmd + "-m "+`optionVar -query uniformMagnitude`+" ";
	$cmd = $cmd + "-att "+`optionVar -query uniformAttenuation`+" ";
	$cmd = $cmd + "-dx "+`optionVar -query uniformDirectionX`+" ";
	$cmd = $cmd + "-dy "+`optionVar -query uniformDirectionY`+" ";
	$cmd = $cmd + "-dz "+`optionVar -query uniformDirectionZ`+" ";
	//if (!$isCreate)
	//	$cmd = $cmd + "-pv "+`optionVar -query uniformPerVertex`+" ";
	$cmd = dynSetMaxDist("uniform", $cmd);

	$cmd = $cmd + dynSetVolumeFieldCmdString( "uniform" );

	return $cmd;
}


//  ============== setVortexCmdString ==============
//
//  SYNOPSIS
//		Set the command and command args string for the vortex command.
//
global proc string setVortexCmdString(int $isCreate)
{
	string $cmd;

	if ($isCreate)
		$cmd = "vortex -pos 0 0 0 ";
	else
		$cmd = "vortex ";

	$cmd = $cmd + dynSetName("vortex");
	$cmd = $cmd + "-m "+`optionVar -query vortexMagnitude`+" ";
	$cmd = $cmd + "-att "+`optionVar -query vortexAttenuation`+" ";
	$cmd = $cmd + "-ax "+`optionVar -query vortexAxisX`+" ";
	$cmd = $cmd + "-ay "+`optionVar -query vortexAxisY`+" ";
	$cmd = $cmd + "-az "+`optionVar -query vortexAxisZ`+" ";
	//if (!$isCreate)
	//	$cmd = $cmd + "-pv "+`optionVar -query vortexPerVertex`+" ";
	$cmd = dynSetMaxDist("vortex", $cmd);

	$cmd = $cmd + dynSetVolumeFieldCmdString( "vortex" );

	return $cmd;
}

//  ============== setVolumeAxisCmdString ==============
//
//  SYNOPSIS
//		Set the command and command args string for the volume axis command.
//
global proc string setVolumeAxisCmdString(int $isCreate)
{
	string $cmd;

	if ($isCreate)
		$cmd = "volumeAxis -pos 0 0 0 ";
	else
		$cmd = "volumeAxis ";

	$cmd = $cmd + dynSetName("volumeAxis");
	$cmd = $cmd + "-m "+`optionVar -query volumeAxisMagnitude`+" ";
	$cmd = $cmd + "-att "+`optionVar -query volumeAxisAttenuation`+" ";
	$cmd = $cmd + "-ia "+`optionVar -query volumeAxisInvertAttenuation`+" ";

	$cmd = $cmd + "-afc "+`optionVar -query volumeAxisAwayFromCenter`+" ";
	$cmd = $cmd + "-afx "+`optionVar -query volumeAxisAwayFromAxis`+" ";
	$cmd = $cmd + "-arx "+`optionVar -query volumeAxisAroundAxis`+" ";
	$cmd = $cmd + "-alx "+`optionVar -query volumeAxisAlongAxis`+" ";
	//$cmd = $cmd + "-rnd "+`optionVar -query volumeAxisRandomSpread`+" ";
	$cmd = $cmd + "-drs "+`optionVar -query volumeAxisDirectionalSpeed`+" ";

	$cmd = $cmd + "-dx "+`optionVar -query volumeAxisDirectionX`+" ";
	$cmd = $cmd + "-dy "+`optionVar -query volumeAxisDirectionY`+" ";
	$cmd = $cmd + "-dz "+`optionVar -query volumeAxisDirectionZ`+" ";
	
	$cmd = $cmd + "-trb "+`optionVar -query volumeAxisTurbulence`+" ";
	$cmd = $cmd + "-trs "+`optionVar -query volumeAxisTurbulenceSpeed`+" ";
	$cmd = $cmd + "-tfx "+`optionVar -query volumeAxisTurbulenceFrequencyX`+" ";
	$cmd = $cmd + "-tfy "+`optionVar -query volumeAxisTurbulenceFrequencyY`+" ";
	$cmd = $cmd + "-tfz "+`optionVar -query volumeAxisTurbulenceFrequencyZ`+" ";
	$cmd = $cmd + "-tox "+`optionVar -query volumeAxisTurbulenceOffsetX`+" ";
	$cmd = $cmd + "-toy "+`optionVar -query volumeAxisTurbulenceOffsetY`+" ";
	$cmd = $cmd + "-toz "+`optionVar -query volumeAxisTurbulenceOffsetZ`+" ";
	$cmd = $cmd + "-dtr "+`optionVar -query volumeAxisDetailTurbulence`+" ";

	$cmd = dynSetMaxDist("volumeAxis", $cmd);

	$cmd = $cmd + dynSetVolumeFieldCmdString( "volumeAxis" );

	return $cmd;
}

//  ============== setParticleRenderCacheCmdString ==============
//
//  SYNOPSIS
//		Set the command and command args string for 
//      creating a particle render cache.
//      This routine is used when dragging to the shelf
//      and when executing the menu item without the option box.
//
//   $flag has the same meaning as in performDynamics, whence it is passed.
//
global proc	string	setParticleRenderCacheCmdString( int $flag )
{
	// Get the string in dynGlobals.  If an empty string
	// is stored there, get the file default.
	// NOTE	: This gives the wrong result in the case where
	// the user has intentionally set an empty path.
	// We will release note this; no way around it.
	//
	string $path = "";
	string $theGlobal;
	if (!catch ($theGlobal = `dynGlobals -q -active`))
		$path = `getAttr ($theGlobal + ".cacheDirectory")`;

	if (size($path) == 0)
	{
		$path = `file -q -rpr`;
		if ($flag == 0) {
			string $fileWarn	= (uiRes("m_performDynamics.kFileWarn"));
			warning(`format -s $path $fileWarn`);
		}

		// If this is for execution, see whether user
		// wants to overwrite an existing cache.
		//
		if (($flag == 0) && (!dynCheckOverwriteCacheDirectory( $path )))
		{
			string $cmdString;
			return $cmdString;
		}
	}
	else
	{
		// If for execution, check whether path is different from scene name,
		// and if so, ask user to verify
		//
		$scene = `file -q -rpr`;
		if (($flag == 0) && ($path != $scene))
		{
			if (!dynVerifyPath( $path ))
			{
				string $cmdString;
				return $cmdString;
			}
		}
	}


	if ($flag == 0)
	{
		// Also check if path is currently "untitled."
		// If it is, recommend that user save scene first.
		// 
		if ($path == (untitledFileName()))
		{
			// Post dialog to ask the user to confirm
			//
			string $msgString	= (uiRes("m_performDynamics.kRecommendMsg"));
			string $cancel		= (uiRes("m_performDynamics.kCancel"));
			string $continue	= (uiRes("m_performDynamics.kContinue"));
			if ($cancel ==` confirmDialog -title (uiRes("m_performDynamics.kConfirm"))  -message $msgString -button $continue  -button $cancel -defaultButton $cancel  -cancelButton $cancel  -dismissString $cancel `)
			{
				string $cmdString;
				return $cmdString;
			}
		}
	}

	// If for execution, clean up the cache directory first
	//
	if ($flag == 0)
	{
		dynCleanCacheDirectory( $path );
	}

	// Get range of frames for export.
	//
	int $minFrame;	
	int $maxFrame;
	int $useRenderGlobals = `optionVar -query cacheForRenderGlobalsRange`;

	if (!$useRenderGlobals)
	{
		// Get current playback range for export.
		//
		$minFrame = `playbackOptions -query -min`;
		$maxFrame = `playbackOptions -query -max`;
	}
	else
	{
		// Get frame range from default render globals
		//
		$minFrame = `getAttr defaultRenderGlobals.startFrame`;
		$maxFrame = `getAttr defaultRenderGlobals.endFrame`;
	}

	// Check whether we have a particle data area.
	// If not, make one.
	//
	string $particleDir = `workspace -fre particles`;
	if (size($particleDir) == 0)
	{
		workspace -fr particles particles;
	}

	int $onlyUpdateParticles = `optionVar -query onlyUpdateParticles`;
	int $cacheAllParticleSystems = `optionVar -query cacheAllParticleSystems`;

	// Form the command string
	//
	string $cmdString = "dynExport -path \""+ $path + 
							"\" -f cache -mnf " + $minFrame + 
							" -mxf "+$maxFrame + " -oup " + $onlyUpdateParticles +
							" -all " + $cacheAllParticleSystems;

	return $cmdString;
}

//  ============== setParticleInstancerCmdString ==============
//
//  SYNOPSIS
//		Set command and command args string for the particle instancer command.
//
global proc	string	setParticleInstancerCmdString()
{
	int    $i;
	int    $count;
	string $menuString;
	string $cmd = "particleInstancer ";
	int $optionBoxExists = 0;

	$cmd = $cmd + dynSetName("particleInstancer");

	// If the option box is up, use the objects currently in the selected object
	// list and particle option menu.
	// If there is no option box, then use the selection list.  The last object
	// in the list is the particle to be instanced to.  All other objects in 
	// the list are instance objects.
	//
	string $selectedObjects[];
	string $particleShape;

    if ( `textScrollList -q -exists PIselectObjectList` == 1 )
    {
		$optionBoxExists = 1;

		$particleShape = `optionMenuGrp -q -v PIparticleObjectOM`;

		string $warnMsg = (uiRes("m_performDynamics.kNoParticleWarn"));
		if (size($particleShape) == 0)
		{
			warning($warnMsg);
			return "";
		}
		if ($particleShape == (uiRes("m_dynCreateLayout.kNoParticleShapesFound")))
		{
			warning($warnMsg);
			return "";
		}

		$selectedObjects = `textScrollList -q -allItems PIselectObjectList`;
		
        $count = size( $selectedObjects);
	}
	else
	{
		string $selectionList[] = `ls -sl`;

		// First, check that the last object is a particle, and if so, save
		// it, otherwise issue a warning and return.
		//
		int $numSelected = size($selectionList);

		if ($numSelected == 0)
		{
			warning (uiRes("m_performDynamics.kNoSelectionWarn"));
			return "";
		}

		$particleShape = getParticleShape($selectionList[$numSelected - 1]);
		if (size($particleShape) == 0)
		{
			string $selectionWarn = (uiRes("m_performDynamics.kSelectionWarn"));
			warning(`format -s $selectionList[$numSelected - 1] $selectionWarn`);
			return "";
		}

		// Now check each object in the list except the last an make sure it
		// is a valid object to be instanced.  Put the valid objects in
		// $selectedObjects, and issue warningas for invalid objects.
		//
		clear($selectedObjects);
		$count = 0;
		for ($i = 0; $i < size($selectionList) - 1; $i++)
		{
			if (isValidInstancedObject($selectionList[$i]))
			{
				$selectedObjects[$count] = $selectionList[$i];
				$count++;
			}
			else
			{
				string $invalidListWarn = (uiRes("m_performDynamics.kInvalidList"));
				warning(`format -s $selectionList[$i] $invalidListWarn`);
			}
		}

	}

	// Add the selected instance objects to the command line.
	//
	if ( $count > 0 )
	{
		string $objectName[];

		// addObject Flag.
		//
		$cmd = $cmd + " -addObject";

		for ( $i = 0; $i < $count; $i++ )
		{
			if ($optionBoxExists == 1)
			{
				tokenize( $selectedObjects[ $i ], ":", $objectName );
				if ( size( $objectName ) > 1 ) 
				{
					$cmd = $cmd + " -object " + $objectName[1];
				}
			}
			else
			{
				$cmd = $cmd + " -object " + $selectedObjects[$i];
			}
		}
	}
	else
	{
		warning (uiRes("m_performDynamics.kNoObjectsSelected"));
	}

	if(!`exists instancerOptionsValues_uiToMel`){	
		 source "dynCreateLayout.mel";
	}

	// Instancer Flags.
	//
	$cmd = $cmd + " -cycle " 		  + instancerOptionsValues_uiToMel(`optionVar -q PIautoCycleOM`);
	$cmd = $cmd + " -cycleStep "      + `optionVar -q PIautoCycleStepSize`;
	$cmd = $cmd + " -cycleStepUnits " + instancerOptionsValues_uiToMel(`optionVar  -q PIautoCycleStepUnitsOM`);
	$cmd = $cmd + " -levelOfDetail "  + instancerOptionsValues_uiToMel(`optionVar -q PIlevelOfDetailOM`);
	$cmd = $cmd + " -rotationUnits "  + instancerOptionsValues_uiToMel(`optionVar -q PIrotationUnitsOM`);
	$cmd = $cmd + " -rotationOrder "  + instancerOptionsValues_uiToMel(`optionVar -q PIrotationOrderOM`);
	
	// Position Flag.
	//
	$menuString = `optionVar -q  PositionOM`;
		
	if(!`exists instancerOptionsValues_melToUI`){	
		 source "dynCreateLayout.mel";
	}
	
	string $none = instancerOptionsValues_melToUI("None");
	if ( $menuString != $none )
	{
		$cmd = $cmd + " -position " + instancerOptionsValues_uiToMel($menuString);
	}

	// Rotation Flag.
	//
	$menuString = `optionVar -q RotationOM`;

	if ( $menuString != $none )
	{
		$cmd = $cmd + " -rotation " + instancerOptionsValues_uiToMel($menuString);
	}

	// Scale Flag.
	//
	$menuString = `optionVar -q ScaleOM`;

	if ( $menuString != $none )
	{
		$cmd = $cmd + " -scale " + instancerOptionsValues_uiToMel($menuString);
	}

	$menuString = `optionVar -q ShearOM`;

	if ( $menuString != $none )
	{
		$cmd = $cmd + " -shear " + instancerOptionsValues_uiToMel($menuString);
	}

	$menuString = `optionVar -q AimDirectionOM`;

	if ( $menuString != $none )
	{
		$cmd = $cmd + " -aimDirection " + instancerOptionsValues_uiToMel($menuString);
	}

	$menuString = `optionVar -q AimPositionOM`;

	if ( $menuString != $none )
	{
		$cmd = $cmd + " -aimPosition " + instancerOptionsValues_uiToMel($menuString);
	}

	$menuString = `optionVar -q AimAxisOM`;

	if ( $menuString != $none )
	{
		$cmd = $cmd + " -aimAxis " + instancerOptionsValues_uiToMel($menuString);
	}

	$menuString = `optionVar -q AimWorldUpOM`;

	if ( $menuString != $none )
	{
		$cmd = $cmd + " -aimWorldUp " + instancerOptionsValues_uiToMel($menuString);
	}

	$menuString = `optionVar -q RotationTypeOM`;

	if ( $menuString != $none )
	{
		$cmd = $cmd + " -rotationType " + instancerOptionsValues_uiToMel($menuString);
	}

	$menuString = `optionVar -q ObjectIndexOM`;

	if ( $menuString != $none )
	{
		$cmd = $cmd + " -objectIndex " + instancerOptionsValues_uiToMel($menuString);
	}

	$menuString = `optionVar -q CycleStartObjectOM`;

	if ( $menuString != $none )
	{
		$cmd = $cmd + " -cycleStartObject " + instancerOptionsValues_uiToMel($menuString);
	}

	$menuString = `optionVar -q AgeOM`;

	if ( $menuString != $none )
	{
		$cmd = $cmd + " -age " + instancerOptionsValues_uiToMel($menuString);
	}

	$menuString = `optionVar -q VisibilityOM`;

	if ( $menuString != $none )
	{
		$cmd = $cmd + " -visibility " + instancerOptionsValues_uiToMel($menuString);
	}

	// If the option box is up, get the particle object to be instanced
	// to from the optionVar, which has been updated to the optionMenuGrp.
	// Otherwise is is in $particleShape.
	//
	$cmd = $cmd + " " + $particleShape;

	return $cmd;
}

//  ========== performDynamics ==========
//
//  SYNOPSIS
//		Called when a user selects a Dynamics menu item, or selects 
//		the "Create/Add" button in a Dynamics option box.
//
//		Arguments:
//			$createFlag:	1 = create field/emitter 
//							0 = add field/emitter/collision/goal
//							2 = create/add not relevant
//
//			$type		command name (with initial Cap)
//			$flag		0 = execute the command
//						1 = bring up the option box
//						2 = dragging to shelf; just return the command string
//
global proc string performDynamics( int $createFlag, string $type, int $flag)
{	
	string $selected[];
	string $cmd;
	
	if ($flag == 1) 
	{
		// Create the options box and set the values of the
		// controls based on the option vars.
		//
		createDynamicsOptions($type, $createFlag);
	}
	else 
	{	
		// Create and set the option vars, if they don't exist already.
		// The second arg means don't reset the values to default if the
		// option vars already exsit.
		//
		if( $type == "nEmitter" ){
			dynSetOptionVars("Emitter", 0);
		} else {
			dynSetOptionVars($type, 0);
		}

		// Get the current selection list.
		//
		$selected = `ls -sl`;

		// Create the command args for the selected command, and
		// issue the command.
		//
		switch ($type) 
		{
			case "Air":

				$cmd = setAirCmdString($createFlag);
				if ($flag == 0)
					dynExecuteFieldCommands($createFlag, $cmd);
				else if ($createFlag)
					$cmd = dynSetCreateFieldShelfCommand($cmd);
				break;		

			case "Drag":

				$cmd = setDragGravityCmdString("drag", $createFlag);
				if ($flag == 0)
					dynExecuteFieldCommands($createFlag, $cmd);
				else 
					$cmd = dynSetCreateFieldShelfCommand($cmd);
				break;		

			case "Gravity":

				$cmd = setDragGravityCmdString("gravity", $createFlag);
				if ($flag == 0)
					dynExecuteFieldCommands($createFlag, $cmd);
				else 
					$cmd = dynSetCreateFieldShelfCommand($cmd);
				break;

			case "Newton":

				$cmd = setNewtonCmdString($createFlag);
				if ($flag == 0)
					dynExecuteFieldCommands($createFlag, $cmd);
				else if ($createFlag)
					$cmd = dynSetCreateFieldShelfCommand($cmd);
				break;

			case "Radial":

				$cmd = setRadialCmdString($createFlag);
				if ($flag == 0)
					dynExecuteFieldCommands($createFlag, $cmd);
				else if ($createFlag)
					$cmd = dynSetCreateFieldShelfCommand($cmd);
				break;

			case "Turbulence":

				$cmd = setTurbulenceCmdString($createFlag);
				if ($flag == 0)
					dynExecuteFieldCommands($createFlag, $cmd);
				else if ($createFlag)
					$cmd = dynSetCreateFieldShelfCommand($cmd);
				break;

			case "Uniform":

				$cmd = setUniformCmdString($createFlag);
				if ($flag == 0)
					dynExecuteFieldCommands($createFlag, $cmd);
				else if ($createFlag)
					$cmd = dynSetCreateFieldShelfCommand($cmd);
				break;

			case "Vortex":

				$cmd = setVortexCmdString($createFlag);
				if ($flag == 0)
					dynExecuteFieldCommands($createFlag, $cmd);
				else if ($createFlag)
					$cmd = dynSetCreateFieldShelfCommand($cmd);
				break;

			case "VolumeAxis":

				$cmd = setVolumeAxisCmdString($createFlag);
				if ($flag == 0)
				{
					dynExecuteFieldCommands($createFlag, $cmd);
					string $sl[] = `ls -sl`;
					string $timeCmd = ("connectAttr time1.outTime " +$sl[0]+ ".time"); 
					evalEcho( $timeCmd );
				}
				else if ($createFlag)
				{
					$cmd = dynSetCreateFieldShelfCommand($cmd);
				}
				break;

			case "Emitter":

				$cmd = setEmitterCmdString($createFlag);
				if ($flag == 0)
					dynExecuteEmitterCommands($createFlag, $cmd, false);
				else
					$cmd = dynSetEmitterShelfCommand($createFlag, $cmd, false);
				break;
				
			case "nEmitter":

				$cmd = setEmitterCmdString($createFlag);
				if ($flag == 0)
					dynExecuteEmitterCommands($createFlag, $cmd, true);
				else
					$cmd = dynSetEmitterShelfCommand($createFlag, $cmd, true);
				break;

			case "Collision":

				$cmd = "collision " + dynSetName("collision");
				$cmd = $cmd + "-r "+`optionVar -query collisionResilience`+" ";
				$cmd = $cmd + "-f "+`optionVar -query collisionFriction`+" ";
				$cmd = $cmd + "-o "+`optionVar -query collisionOffset`+" ";

				if ($flag == 0)
					dynExecuteCollisionCommand($cmd);
				else
					$cmd = dynSetCollisionShelfCommand($cmd);
					
				break;

			case "Goal":

				$cmd = "goal -w "+`optionVar -query goalWeight`+" -utr "+ `optionVar -query goalUseTransform`+"  ";

				if ($flag == 0)
					dynExecuteGoalCommand($cmd);
				else
					$cmd = dynSetGoalShelfCommand($cmd);
				break;

			case "ActiveRigid":
			case "PassiveRigid":

				if ($type == "ActiveRigid")
					optionVar -intValue rigidCollisionType 1;
				else
					optionVar -intValue rigidCollisionType 0;
				$cmd = setRigidCmdString();
				if ($flag == 0)
					evalEcho $cmd;
				break;

			case "Soft":

			      int $hide    = `optionVar -query softHide`;
				int $history = `optionVar -query softHistory`;
			      int $goal    = `optionVar -query softGoal`;
				float $goalWeight = `optionVar -query softWeight`;

				int $whichSoftCreation = `optionVar -q softCreationOption`;
				if ($whichSoftCreation == 1)  
				{
					$cmd = "soft " + dynSetName("soft");
					$cmd = $cmd + "-c ";
				}
				else
				if ($whichSoftCreation == 2)
				{
					$cmd = "dynCreateSoft " + $hide + " " + $history + " " + $goal + " " + $goalWeight + " 1";
				}
				else
				if ($whichSoftCreation == 3)
				{
					$cmd = "dynCreateSoft " + $hide + " " + $history + " " + $goal + " " + $goalWeight + " 0";
				}

				if ($flag == 0)
					evalEcho $cmd;
				break;

			case "NSoft":

			    int $hide    = `optionVar -query softHide`;
				int $history = `optionVar -query softHistory`;
			    int $goal    = `optionVar -query softGoal`;
				float $goalWeight = `optionVar -query softWeight`;

				int $whichSoftCreation = `optionVar -q softCreationOption`;
				if ($whichSoftCreation == 1)  
				{
					$cmd = "nSoft " + dynSetName("nSoft");
					$cmd = $cmd + "-c ";
				}
				else
				if ($whichSoftCreation == 2)
				{
					$cmd = "dynCreateNSoft " + $hide + " " + $history + " " + $goal + " " + $goalWeight + " 1";
				}
				else
				if ($whichSoftCreation == 3)
				{
					$cmd = "dynCreateNSoft " + $hide + " " + $history + " " + $goal + " " + $goalWeight + " 0";
				}

				if ($flag == 0)
					evalEcho $cmd;
				break;

			case "Constrain":

				$cmd = setConstrainCmdString(size($selected));
				if ($flag == 0)
					evalEcho $cmd;
				break;

			case "Spring":

				$cmd = setSpringCmdString();
				if ($flag == 0)
					evalEcho $cmd;
				break;

			case "ParticleInstancer":
			
				if ($flag == 2) {
					$cmd = "evalEcho `setParticleInstancerCmdString`";
				} else {
					$cmd = setParticleInstancerCmdString();
					if (($flag == 0) && (size($cmd) > 0))
						evalEcho $cmd;
				}
				break;

			case "ParticleRenderCache":

				string $cancel = (uiRes("m_performDynamics.kCancelOption"));
				if (`about -evalVersion`) {
					confirmDialog
						-message (uiRes("m_performDynamics.kCreateParticleMsg")) 
						-button $cancel  -defaultButton $cancel;
					break;
				}
	
				$cmd = setParticleRenderCacheCmdString( $flag );
				if (($flag == 0) && (size($cmd) > 0))
				{
					// execute the command.
					//
					evalEcho $cmd;
				}
				break;
		}	
	}
	return $cmd;
}


global proc string 	getParticleShape(string $object)
{
	string $particleShape[];
	string $objectArray[1];
	$objectArray[0] = $object;

	// First see if $object is itself a particle shape.  If it is return it.
	//
	$particleShape = `ls -type particle $objectArray`;
	if (size($particleShape) > 0)
	{
		return $particleShape[0];
	}

	// If $object is not a particle shape, perhaps it is the transform of
	// a particle shape.  If so, return it.
	//
	string $transforms[];
	string $children[];
	$transforms = `ls -type transform $objectArray`;
	if (size($transforms) > 0)
	{
		$children = `listRelatives -s $transforms[0]`;
		$particleShape = `ls -type particle $children`;
		if (size($particleShape) > 0)
		{
			return $particleShape[0];
		}
	}

	// If $object is neither a particle shape nor a transform of a particle
	// shape, then return nothing.
	//
	return "";
}

global proc int isValidInstancedObject( string $objectName )
{
	if( size($objectName) == 0 )
		return 0;

	string $temp[];
	//
	// First check to see if the selected object
	// is a transform.
	//
	clear($temp);
	$temp = `ls -type transform $objectName`;
	if( size($temp) == 0 )
		return 0;

	//
	// Now filter out special types derived from transforms
	//
	string $invalidTransformTypes[] = 
	{
		"pointEmitter",
		"field",
		"ikhandle",
		"ikEffector",
		"instancer",
		"joint"
	};
	clear($temp);
	$temp = `ls
		-type pointEmitter
		-type field
		-type ikHandle
		-type ikEffector
		-type joint
		-type instancer
		$objectName`;
	if( size($temp) > 0 )
		return 0;

	return 1;
}


proc string radialHelp()
{
	string $helpString;

	$helpString = "Create Radial Field: (1) select the objects you want to be influenced by the new radial field; (2) select \"Radial\" from the \"Create Fields\" menu or select the \"Create\" button in the option box.\nAdd Radial Field: (1) select the objects you want to be influenced by the new radial field; (2) shift-select the object to add the radial field to; (3) select \"Radial\" from the \"Add To Geometry\" menu or select the \"Add\" button in the option box.";

	return $helpString;
}
