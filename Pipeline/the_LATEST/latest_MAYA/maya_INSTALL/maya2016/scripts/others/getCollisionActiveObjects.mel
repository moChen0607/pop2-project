// Copyright (C) 1997-2014 Autodesk, Inc., and/or its licensors.
// All rights reserved.
//
// The coded instructions, statements, computer programs, and/or related
// material (collectively the "Data") in these files contain unpublished
// information proprietary to Autodesk, Inc. ("Autodesk") and/or its licensors,
// which is protected by U.S. and Canadian federal copyright law and by
// international treaties.
//
// The Data is provided for use exclusively by You. You have the right to use,
// modify, and incorporate this Data into other products for purposes authorized 
// by the Autodesk software license agreement, without fee.
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND. AUTODESK
// DOES NOT MAKE AND HEREBY DISCLAIMS ANY EXPRESS OR IMPLIED WARRANTIES
// INCLUDING, BUT NOT LIMITED TO, THE WARRANTIES OF NON-INFRINGEMENT,
// MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE, OR ARISING FROM A COURSE 
// OF DEALING, USAGE, OR TRADE PRACTICE. IN NO EVENT WILL AUTODESK AND/OR ITS
// LICENSORS BE LIABLE FOR ANY LOST REVENUES, DATA, OR PROFITS, OR SPECIAL,
// DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES, EVEN IF AUTODESK AND/OR ITS
// LICENSORS HAS BEEN ADVISED OF THE POSSIBILITY OR PROBABILITY OF SUCH DAMAGES.

//=============================================================================
//<doc>
//<name getCollisionActiveObjects>
//
//<synopsis>
//		getCollisionActiveObjects (string $nParticleShape)
//
//<flags>
//		string	$nParticleShape	nParticle shape
//
//<returns>
//		string[] : List of pathnames indexed by particle. If a
//				   particle did not collide with an active object
//				   in the previous frame then the entry for that
//				   particle will contain an empty string.
//
//<description>
//		Returns a string array containing the pathname of the active objects
//		that each particle in the given particle system collided with in
//		the previous frame. The particle system must have the
//		"collisionActiveGeometryIndex" dynamic attribute added to it.
//		If a particle did not collide with any active object in the previous
//		frame, then the array entry for that particle will contain an empty
//		string.
//
//<examples>
//		// Return list of active collision shapes for "nParticleShape1"
// 		getCollisionActiveObjects("nParticleShape1");
//</doc>
//=============================================================================
//
//	Module:	getCollisionActiveObjects.mel
//
//	Purpose:
//
//		Tool for figuring out the exact pathname of the active object that a
//		particle collided with.
//
//		The "collisionActiveGeometryIndex" attribute on the particle node
//		gives the index of the active collision object in the particle's
//		collision object array, but it is more useful to know the actual
//		pathname of the object. That is what the getCollisionActiveObjects()
//		procedure provides.
//
//		In order for this routine to work, the particle system must have
//		the dynamic "collisionActiveGeometryIndex" attribute added to it.
//
//		Note: Active collision objects are only supported in nParticles.
//
//	Details:
//
//		The getCollisionActiveObjects() procedure is the main procedure to call.
//		Given an nParticle system, it returns a string array containing the
//		full pathnames of the objects that each particle collided with in the
//		previous frame.  If a particle did not collide with an object, then
//		the array entry for that particle will contain the empty string.
//
//		The getCollisionObjectPath() procedure is a utility procedure defined
//		in getCollisionObject.mel that determines the pathname of a particular
//		collision object connected to a particular particle system.  Since a
//		full pathname is provided, this routine will differentiate between
//		different instances of the same shape.
//
//=============================================================================
global proc string[] getCollisionActiveObjects( string $particle )
//
//	Description:
//
//		Returns a string array containing the pathname of the active objects
//		that each particle in the given particle system collided with in
//		the previous frame.  The particle system must have the
//		"collisionActiveGeometryIndex" dynamic attribute added to it in order
//		for this routine to work.  If a particle did not collide with any
//		active object in the previous frame, then the array entry for that
//		particle will be the empty string.
//
{
	// Ensure shared fuction from getCollisionObjects.mel is loaded
	//
	if( !`exists getCollisionObjectPath` )
		source "getCollisionObjects.mel";

	//	make sure collisionActiveGeometryIndex attribute exists
	//
	if( !`attributeQuery -ex -n $particle "collisionActiveGeometryIndex"` )
	{
		string $fmt = (uiRes("m_getCollisionActiveObjects.kParticleMissingActiveAttribute"));
		error( `format -s $particle $fmt` );
	}

	//	stores the pathnames of the collision objects connected to the
	//	particle system.  These are computed on the fly as they are needed.
	//
	string $connectedCollisionObjects[] = {};

	//	collisionGeometryIndex attribute gives the indices in the collision
	//	object array of the object with which each particle collided in the 
	//	previous frame.
	//
	float $collisionIndices[] = `getAttr ($particle+".collisionActiveGeometryIndex")`;
	
	//	result array that stores the collision object names for each particle
	//
	string $collisionObjects[] = {};

	//	loop through each particle, and figure out the name of the object that
	//	it collided with
	//
	int $i;
	for( $i = 0; $i < size($collisionIndices); $i++ )
	{
		int $collisionObjIndex = $collisionIndices[$i];
		if( $collisionObjIndex == -1 )
		{
			//	particle didn't collide with anything
			//
			$collisionObjects[$i] = "";
		}
		else
		{
			//	particle collided with an object.  If we haven't already
			//	figured out the name of this object, then compute it now
			//	and store it in the $connectedCollisionObjects[] array.
			//
			if( $connectedCollisionObjects[$collisionObjIndex] == "" )
			{
				//	compute the name
				//
				$connectedCollisionObjects[$collisionObjIndex] = 
					getCollisionObjectPath( $particle, $collisionObjIndex, true/*active collision*/ );
			}
			
			//	fill in the result array entry for this particle with the name
			//	of the collision object
			//
			$collisionObjects[$i] = $connectedCollisionObjects[$collisionObjIndex];
		}
	}
	
	return $collisionObjects;
}
