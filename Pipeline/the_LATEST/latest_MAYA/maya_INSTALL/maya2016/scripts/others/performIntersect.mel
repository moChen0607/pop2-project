// Copyright (C) 1997-2014 Autodesk, Inc., and/or its licensors.
// All rights reserved.
//
// The coded instructions, statements, computer programs, and/or related
// material (collectively the "Data") in these files contain unpublished
// information proprietary to Autodesk, Inc. ("Autodesk") and/or its licensors,
// which is protected by U.S. and Canadian federal copyright law and by
// international treaties.
//
// The Data is provided for use exclusively by You. You have the right to use,
// modify, and incorporate this Data into other products for purposes authorized 
// by the Autodesk software license agreement, without fee.
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND. AUTODESK
// DOES NOT MAKE AND HEREBY DISCLAIMS ANY EXPRESS OR IMPLIED WARRANTIES
// INCLUDING, BUT NOT LIMITED TO, THE WARRANTIES OF NON-INFRINGEMENT,
// MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE, OR ARISING FROM A COURSE 
// OF DEALING, USAGE, OR TRADE PRACTICE. IN NO EVENT WILL AUTODESK AND/OR ITS
// LICENSORS BE LIABLE FOR ANY LOST REVENUES, DATA, OR PROFITS, OR SPECIAL,
// DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES, EVEN IF AUTODESK AND/OR ITS
// LICENSORS HAS BEEN ADVISED OF THE POSSIBILITY OR PROBABILITY OF SUCH DAMAGES.

//
//
//  Creation Date:  Mar 20, 1997
//
//  Description:
//      This script is defines the option box for the intersect surface menu item.
//
//  Input Arguments:
//      int action
//          0 - just execute the command.
//          1 - show option box dialog.
//          2 - return the drag command.
//
//  Return Value:
//      None.
//
proc setOptionVars (int $forceFactorySettings)
{
    intersectSetOptionVars( $forceFactorySettings );
}

global proc intersectSetup( string $parent,
							int $forceFactorySettings,
							string $goToTool )
{
	// retrieve option settings.
	//
	setOptionVars($forceFactorySettings);	
	intersectToolSetup( $forceFactorySettings, $goToTool );

	setParent $parent;	

	// query all the option vars.
	//
	int $createOnBoth = `optionVar -q intersectCosOnlyOnFirstSurface` ;
	int $cosAs2D = `optionVar -q intersectCosAs2D` ;

	if( $createOnBoth == 0 ) $createOnBoth = 2 ;
	else $createOnBoth = 1 ;

	int $dimOptions = $cosAs2D;
	if( $cosAs2D == 0 ) $cosAs2D = 2 ;
	else $cosAs2D = 1 ;

	// set the controls.
	//
	radioButtonGrp -edit -select $createOnBoth -enable $dimOptions intersectCurvesOnButton ;	
	radioButtonGrp -edit -select $cosAs2D intersectCreateAs2dButton ;	

	// Global vs. local tolerance
	int $useGlobalTol = `optionVar -q intersectSrfUseGlobalTol`;
	radioButtonGrp -e -select (2 - $useGlobalTol) useGlobalTolBtn;

	//	Tolerance
	//
	floatSliderGrp -edit 
		-v `optionVar -q intersectSrfTolerance`
		intersectSrfTolSlider;

	if( $useGlobalTol ) {
		tabLayout -e -selectTab noSlider useGlobalTolTab;
	}
	else {
		tabLayout -e -selectTab slider useGlobalTolTab;
	}

	if( "" != $goToTool ) { 
		checkBoxGrp -e -v1 `scriptCtx -q -euc $goToTool`
		  scriptToolExtraWidget;
		checkBoxGrp -e -v2 `scriptCtx -q -lac $goToTool`
		  scriptToolExtraWidget;
	}
}


global proc intersectCallback( string $parent, int $doIt, string $goToTool )
{
	if( "" != $goToTool ) {
		optionVar -iv intersectEuc `scriptCtx -q -euc $goToTool`;
		optionVar -iv intersectLac `scriptCtx -q -lac $goToTool`;
	}
	setParent $parent ;

	// get Values from controls.
	//

	int $createOnBoth = `radioButtonGrp -q -select intersectCurvesOnButton`;
	int $createAs2d = `radioButtonGrp -q -select intersectCreateAs2dButton`;

	int $createOnFirst ;
	if( $createOnBoth == 1 ) $createOnFirst = 1 ;
	else $createOnFirst = 0 ;

	int $create2d ;
	if( $createAs2d == 1 ) $create2d = 1 ;
	else $create2d = 0 ;

	optionVar -intValue intersectCosAs2D $create2d ;
	optionVar -intValue intersectCosOnlyOnFirstSurface $createOnFirst ;

	// global vs. local tolerance
	int $useGlobalTol = 2 - `radioButtonGrp -q -select useGlobalTolBtn`;
	optionVar -intValue intersectSrfUseGlobalTol $useGlobalTol;

	// tolerance
	optionVar -floatValue intersectSrfTolerance
		`floatSliderGrp -q -v intersectSrfTolSlider`;

	if( 1 == $doIt ) {
		performIntersect( 0, $goToTool ); 
		string $tmpCmd = "performIntersect( 0, \"" + $goToTool + "\")";
		addToRecentCommandQueue $tmpCmd "Intersect Curves";
	}
	else if( $doIt ) {
		setToolTo $goToTool;
	}
}

proc createIntersectUI( string $parent, int $inTheTool, string $goToTool )
{
	setParent $parent ;
	string $tabForm = `columnLayout -adjustableColumn true`;

	// cos for the first or both surfaces ?
	//
	string $firstSurface = (uiRes("m_performIntersect.kFirstSurface"));
	radioButtonGrp -nrb 2 -label (uiRes("m_performIntersect.kCreateCurves"))  -label1 $firstSurface  -da1 0
		-label2 (uiRes("m_performIntersect.kBothSurfaces"))  -da2 1  intersectCurvesOnButton;

	// cos type (2d, 3d). 
	//
	radioButtonGrp -nrb 2 -label (uiRes("m_performIntersect.kCurveType")) 
		-label1 (uiRes("m_performIntersect.kCurveOnSurface"))  -da1 0
		-label2 (uiRes("m_performIntersect.kWorld"))  -da2 1  
		-on1 ("radioButtonGrp -e -enable true intersectCurvesOnButton;")
		-on2 ("radioButtonGrp -e -enable false intersectCurvesOnButton;")
		intersectCreateAs2dButton;

	radioButtonGrp -nrb 2 -label (uiRes("m_performIntersect.kUseTolerance")) 
	   -label1 (uiRes("m_performIntersect.kGlobal")) 
	   -label2 (uiRes("m_performIntersect.kLocal")) 
	   -on1 "tabLayout -e -selectTab noSlider useGlobalTolTab"
	   -on2 "tabLayout -e -selectTab slider useGlobalTolTab"
	   useGlobalTolBtn;

	tabLayout -tabsVisible false useGlobalTolTab;
	   columnLayout slider;
		   floatSliderGrp -label (uiRes("m_performIntersect.kTolerance"))  
			   -min 0.001 -max 1.0 -fmn 0.00001 -fmx 10.0
			   intersectSrfTolSlider;
	   setParent ..;
	   columnLayout noSlider;
	   setParent ..;
	setParent ..;

	if( $inTheTool ) {
		separator;
		checkBoxGrp -ncb 2 -label (uiRes("m_performIntersect.kToolBehavior")) 
		  -label1 (uiRes("m_performIntersect.kExit")) 
		  -v1 off
		  -on1 ("scriptCtx -e -euc true " + $goToTool)
		  -of1 ("scriptCtx -e -euc false " + $goToTool)

		  -label2 (uiRes("m_performIntersect.kAuto")) 
		  -v2 on
		  -on2 ("scriptCtx -e -lac true -ssc 2 " + $goToTool)
		  -of2 ("scriptCtx -e -lac false -ssc 0 " + $goToTool)
		  scriptToolExtraWidget;
	}
}

proc string assembleCmd()
{
    string $cmd ;
    setOptionVars(false) ;

    // query history.
    //
    int $doHistory = `constructionHistory -q -tgl`;
	int $cosOnlyOn1stSurface = `optionVar -q intersectCosOnlyOnFirstSurface`;
    int $cosAs2D = `optionVar -q intersectCosAs2D`;

	float $tol = `optionVar -q intersectSrfTolerance`;
	if( `optionVar -q intersectSrfUseGlobalTol` ) {
		$tol = `optionVar -q positionalTolerance`;
	}

	$cmd = "intersectPreset" + "(" + $cosOnlyOn1stSurface + "," + $cosAs2D + "," +  $doHistory + "," + $tol + ")" ;
    return $cmd ;
}

proc intersectOptions( int $inTheTool, string $goToTool )
{
	//	Name of the command for this option box.
	//
	string $commandName = "intersect";

	//	Build the option box actions.
	//
	string $callback = ($commandName + "Callback");
	string $setup = ($commandName + "Setup");

	global string $gOptionBoxActionToolItem;
	$gOptionBoxActionToolItem = "modelWithToolIntersect";
	global string $gOptionBoxActionToolItemCB;
	$gOptionBoxActionToolItemCB = "intersectToolScript 3";

	//	Step 1:  Get the option box.
	//	============================
	string $layout = getOptionBox();
	setParent $layout;
	
	//	Step 2:  Pass the command name to the option box.
	//	=================================================
	setOptionBoxCommandName($commandName);
	
	//	Step 3:  Activate the default UI template.
	//	==========================================
	setUITemplate -pushTemplate DefaultTemplate;

	//	Step 4: Create option box contents.
	//	===================================
	
	//	Turn on the wait cursor.
	//
	waitCursor -state 1;

	tabLayout -scr true -tv false;
	
	string $parent = `columnLayout -adjustableColumn 1`;
	
	createIntersectUI( $parent, $inTheTool, $goToTool );

	//	Turn off the wait cursor.
	//
	waitCursor -state 0;
	
	//	Step 5: Deactivate the default UI template.
	//  ===========================================
	//
	setUITemplate -popTemplate;

	//	Step 6: Customize the buttons.  
	//	==============================

	//	'Apply' button.
	//
	string $applyBtn = getOptionBoxApplyBtn();
	if( $inTheTool ) {
		button -edit -label (uiRes("m_performIntersect.kIntersectTool")) 
			-command ($callback + " " + $parent + " 3 \"" + $goToTool + "\"")
			$applyBtn;
	}
	else {
		button -edit -label (uiRes("m_performIntersect.kIntersect")) 
			-command ($callback + " " + $parent + " 1 \"" + $goToTool + "\"")
			$applyBtn;
	}

	//	'Save' button.
	//
	string $saveBtn = getOptionBoxSaveBtn();
	button -edit 
		-command ($callback + " " + $parent + " 0 \"" +
				  $goToTool + "\"; hideOptionBox")
		$saveBtn;

	//	'Reset' button.
	//
	string $resetBtn = getOptionBoxResetBtn();
	button -edit 
		-command ($setup + " " + $parent + " 1 \"" + $goToTool + "\"")
		$resetBtn;

	//	Step 7: Set the option box title.
	//	=================================
	//
	if( $inTheTool ) {
		setOptionBoxTitle (uiRes("m_performIntersect.kSurfacesToolTitle"));
	} else {
		setOptionBoxTitle (uiRes("m_performIntersect.kSurfacesTitle"));
	}

	//	Step 8: Customize the 'Help' menu item text.
	//	============================================
	//
	setOptionBoxHelpTag( "IntersectSurfaces" );

	//	Step 9: Set the current values of the option box.
	//	=================================================
	//
	eval ($setup + " " + $parent + " 0 \"" + $goToTool + "\"");	
	
	//	Step 10: Show the option box.
	//	=============================
	//
	showOptionBox();
}

proc string intersectHelp()
{
	string $cmdHelp = "Command: Intersect - Intersects two NURBS surfaces to generate curve on surface(s). \n" ;
	string $selectHelp = "Select: Select at least two NURBS surfaces" ; 
    return $cmdHelp+$selectHelp ;
}

global proc string performIntersect( int $action, string $goToTool )
//
// Description :
//      0 - Execute the command.
//      1 - Show the option box dialog.
//      2 - Return the command.
//      3 - Show the tool option box dialog.
//	
{
	int $inTheTool = false;
	if( 3 == $action ) {
		$action = 1;
		$inTheTool = true;
	}

	string $cmd = "" ;
	switch( $action ) {
	  case 0 :
		$cmd = `assembleCmd` ;
		eval($cmd) ;
		break ;

	  case 1 :
		intersectOptions( $inTheTool, $goToTool );
		break ;
			
	  case 2 :
	  default:
		setOptionVars(false) ;
		$cmd = `assembleCmd` ;
		break ;	
	}
	return $cmd ;
}

