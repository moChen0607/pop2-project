// Copyright (C) 1997-2014 Autodesk, Inc., and/or its licensors.
// All rights reserved.
//
// The coded instructions, statements, computer programs, and/or related
// material (collectively the "Data") in these files contain unpublished
// information proprietary to Autodesk, Inc. ("Autodesk") and/or its licensors,
// which is protected by U.S. and Canadian federal copyright law and by
// international treaties.
//
// The Data is provided for use exclusively by You. You have the right to use,
// modify, and incorporate this Data into other products for purposes authorized 
// by the Autodesk software license agreement, without fee.
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND. AUTODESK
// DOES NOT MAKE AND HEREBY DISCLAIMS ANY EXPRESS OR IMPLIED WARRANTIES
// INCLUDING, BUT NOT LIMITED TO, THE WARRANTIES OF NON-INFRINGEMENT,
// MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE, OR ARISING FROM A COURSE 
// OF DEALING, USAGE, OR TRADE PRACTICE. IN NO EVENT WILL AUTODESK AND/OR ITS
// LICENSORS BE LIABLE FOR ANY LOST REVENUES, DATA, OR PROFITS, OR SPECIAL,
// DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES, EVEN IF AUTODESK AND/OR ITS
// LICENSORS HAS BEEN ADVISED OF THE POSSIBILITY OR PROBABILITY OF SUCH DAMAGES.

//
//
//  Creation Date:  19 Mar 1999
//
//  Description:
//      This script is a panel wrapper around the componentEditor script.  It
//	handles creating the panel, unparented listers, saving of state, 
//  initializing of preferences, etc.
//
//////////////////////////////////////////////////////////////////////
//
//  Procedure Name:
//      createComponentEditorPanel
//
//  Description:
// 		Called once on panel creation. Leave initialization for 
//		the init callback.  Do nothing here.
//		
//  Input Arguments:
//      $whichPanel - name of the panel, but not used.
//
//  Return Value:
//      None.
//

if ( !`exists buildComponentEditorControls` ) {
	source componentEditorWindow;
}

global proc buildComponentEditorContextHelpItems(
	string $nameRoot, string $menuParent)
//
//  Description:
//		Build context sensitive menu items
//		
//  Input Arguments:
//		$nameRoot - name to use as the root of all item names
//		$menuParent - the name of the parent of this menu
//
//  Return Value:
//      None
//
{
	menuItem -label (uiRes("m_componentEditorPanel.kHelpOnComponentEditor"))
		-enableCommandRepeat false
		-command "showHelp ComponentEditor";
}

global proc createComponentEditorPanel(string $whichPanel)
{
	//	Add support for the Context Sensitive Help Menu.
	//
	addContextHelpProc $whichPanel "buildComponentEditorContextHelpItems";
}

//////////////////////////////////////////////////////////////////////
//
//  Procedure Name:
//      initComponentEditorPanel
//
//  Description:
// 		Initialize editors to starting state.
//		
//  Input Arguments:
//      $whichPanel - name of the panel, but not used.
//
//  Return Value:
//      None.
//

global proc initComponentEditorPanel(string $whichPanel)
{}

//////////////////////////////////////////////////////////////////////
//
//  Procedure Name:
//      addComponentEditorPanel
//
//  Description:
// 		create unparented editors requested by the prefs
//		
//  Input Arguments:
//      $whichPanel - name of the panel, but not used.
//
//  Return Value:
//      None.
//
global proc addComponentEditorPanel(string $whichPanel) 
{
	// the scripted panel control is a menuBarLayout; it contains a
	// frame-layout child with the same name as the panel.
	//
	// Therefore: $panelControl is a menuBarLayout
	//			  $panelControl+"|"+$whichPanel is a frame layout

	buildComponentEditorControls $whichPanel;
}

//////////////////////////////////////////////////////////////////////
//
//  Procedure Name:
//      removeComponentEditorPanel
//
//  Description:
//      do whatever is necessary to clean up a given panel
//		
//  Input Arguments:
//      $whichPanel - name of the panel to clean up.
//
//  Return Value:
//      None.
//
global proc removeComponentEditorPanel(string $whichPanel)
{
	string $componentEditor = ($whichPanel + "ComponEditor");

	if (`componentEditor -exists $componentEditor`) {
		componentEditor -edit -unParent $componentEditor;
	}
}

//////////////////////////////////////////////////////////////////////
//
//  Procedure Name:
//      saveComponentEditorPanel
//
//  Description:
//      examine a given componentEditorPanel and return a MEL command
//	which will recreate the panel in its current state.
//		
//  Input Arguments:
//      $whichPanel - name of the panel to have its state examined.
//
//  Return Value:
//      a command string that will create a componentEditor panel in the 
//		same state as the input $whichPanel.
//
global proc string saveComponentEditorPanel(string $whichPanel)
{
	string $reCreateCmd = "";

	return $reCreateCmd;
}

global proc string componentEditorPanel(string $panelName) {
//
//  Procedure Name:
//      componentEditorPanel
//
//  Description:
//		This proc defines the componentEditor panel type and 
//		instantiates one.  Only one componentEditorPanel is allowed.
//
//  Input Arguments:
//      $panelName the name of the panel to be created.
//
//  Return Value:
//      None.
//
	global string $gMainPane;

	if (!`scriptedPanelType -exists componentEditorPanel`) {

		//  define the type of panel
		//
		scriptedPanelType
			-createCallback "createComponentEditorPanel" 
			-initCallback "initComponentEditorPanel"
			-addCallback "addComponentEditorPanel"
			-removeCallback "removeComponentEditorPanel" 
			-saveStateCallback "saveComponentEditorPanel"
			componentEditorPanel;

		//  create an instance of the test panel
		//
		setParent $gMainPane;
		scriptedPanel -unParent -type "componentEditorPanel" $panelName;
	}
	
	return $panelName;
}
