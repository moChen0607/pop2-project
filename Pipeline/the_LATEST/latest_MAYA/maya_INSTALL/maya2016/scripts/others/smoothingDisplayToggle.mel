// Copyright (C) 1997-2014 Autodesk, Inc., and/or its licensors.
// All rights reserved.
//
// The coded instructions, statements, computer programs, and/or related
// material (collectively the "Data") in these files contain unpublished
// information proprietary to Autodesk, Inc. ("Autodesk") and/or its licensors,
// which is protected by U.S. and Canadian federal copyright law and by
// international treaties.
//
// The Data is provided for use exclusively by You. You have the right to use,
// modify, and incorporate this Data into other products for purposes authorized 
// by the Autodesk software license agreement, without fee.
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND. AUTODESK
// DOES NOT MAKE AND HEREBY DISCLAIMS ANY EXPRESS OR IMPLIED WARRANTIES
// INCLUDING, BUT NOT LIMITED TO, THE WARRANTIES OF NON-INFRINGEMENT,
// MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE, OR ARISING FROM A COURSE 
// OF DEALING, USAGE, OR TRADE PRACTICE. IN NO EVENT WILL AUTODESK AND/OR ITS
// LICENSORS BE LIABLE FOR ANY LOST REVENUES, DATA, OR PROFITS, OR SPECIAL,
// DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES, EVEN IF AUTODESK AND/OR ITS
// LICENSORS HAS BEEN ADVISED OF THE POSSIBILITY OR PROBABILITY OF SUCH DAMAGES.

// smoothingDisplayToggle.mel
//
// this script controls the display of shape nodes that are connected 
// with a smoothing node - either via smoothProxy or subds in poly proxy
// mode



//	Procedure Name:
//		changeSubdivDisplay 
//
//	Description: 
//		this changes the display of subdiv shapes
//
//	Input Arguments:
//		int $toggle: refer to smoothingDisplayToggle below
//		string $object: shape node to operate on
//		string $toSubdiv: name of the nurbsToSubdiv or polyToSubdiv node
//
global proc changeSubdivDisplay( int $toggle, string $object, string $toSubdiv ){
	
	string $oppositeType;
	
	//need to accurately find the opposite node as it could be any construction history
	string $toSubdivConnections[] = `listConnections -shapes true $toSubdiv`;
	$toSubdivConnections = `ls -long $toSubdivConnections`;
	string $remove[] = {$object};
	string $opposite[] = `stringArrayRemove $remove $toSubdivConnections`;
	
	if (size($toSubdivConnections) && size($opposite)) {
		if ($toggle){	
			int $objVisible = `getAttr ($object + ".visibility")`;
			int $oppVisible = `getAttr ($opposite[0] + ".visibility")`;
			if ($objVisible && $oppVisible) {
				// Both are visible (in subdProxy mode)
				// Set the $object (subd) invisible, 
				// $opposite (mesh) visible
				
				setAttr ($object + ".visibility") 0;
				setAttr ($opposite[0] + ".visibility") 1;
			} else {
				// Just toggle the visibility
				setAttr ($object + ".visibility") (!$objVisible);
				setAttr ($opposite[0] + ".visibility") (!$oppVisible);
			}

			//put a shader on the poly
			string $poly[] = `ls -type "mesh" $toSubdivConnections`;
			string $shadingEngines[];
			clear($shadingEngines);
			if (size($poly)) {
				$shadingEngines = `listConnections -type "shadingEngine" -p 1 -c 1 $poly[0]`;
			}
			if (!size($shadingEngines)) {
				string $subdiv[] = `ls -type "subdiv" $toSubdivConnections`;
				$shadingEngines = `listConnections -type "shadingEngine" $subdiv[0]`;
				if (size($shadingEngines)) {
					sets -e -forceElement $shadingEngines[0] $poly[0];
				}
			}
		} else {
			for ($smooth in $toSubdivConnections){
				setAttr ($smooth + ".visibility") 1;

				//remove shader from poly
				if (`nodeType $smooth` == "mesh"){
					string $shadingEngines[] = `listConnections -type "shadingEngine" -p 1 -c 1 $smooth`;
					if (size($shadingEngines) >= 2) {
						disconnectAttr $shadingEngines[0] $shadingEngines[1];
					}
				}

			}
		}
	}
}

//	Procedure Name:
//		changeSmoothProxyDisplay 
//
//	Description:
//		this changes the display of smoothProxy shapes
//
//	Input Arguments:
//		int $toggle: refer to smoothingDisplayToggle proc below
//		string $object: shape node to operate on
//		string $smooth: name of the smoothProxy node
//
global proc changeSmoothProxyDisplay( int $toggle, string $object, string $smooth ){
	string $oppositeType;

	//need to accurately find the opposite node as it could be any construction history
	string $smoothConnections[] = `listConnections -shapes true -type "mesh" $smooth`;

	
	//listConnections does not return the fullpath name so manufacture it
	//this is required for smoothProxy when not sharing the transform
	int $i = 0;
	for ($connection in $smoothConnections){
		string $longName[] = `ls -long $connection`;
		$smoothConnections[$i] = $longName[0];
		$i++;
	}

	//remove the selected object from the list of connections
	//to get the opposite mesh node. the selected object already
	//had its visibility changed.
	string $longObjectName[] = `ls -long $object`;
	string $remove[] = {$longObjectName[0]};
	string $opposite[] = `stringArrayRemove $remove $smoothConnections`;

	if (size($smoothConnections) && size($opposite)) {
		if ($toggle){	
			int $objVisible = `getAttr ($object + ".visibility")`;
			int $oppVisible = `getAttr ($opposite[0] + ".visibility")`;
			if ($objVisible && $oppVisible) {
				// Both are visible (in subdProxy mode)
				// Set the $object (subd) invisible, 
				// $opposite (mesh) visible
				
				setAttr ($object + ".visibility") 0;
				setAttr ($opposite[0] + ".visibility") 1;

			} else {
				// Just toggle the visibility
				setAttr ($object + ".visibility") (!$objVisible);
				setAttr ($opposite[0] + ".visibility") (!$oppVisible);
			}
		} else {
			for ($smooth in $smoothConnections){
				setAttr ($smooth + ".visibility") 1;
			}
		}
	}
}

//	Procedure Name:
//		smoothingDisplayToggle  
//
//	Description:
//		this is the main proc which checks the 
//		selection and calls the appropriate sub proc
//		to control the display of subdiv and smoothProxy 
//		shape nodes
//
//	Input Arguments: 
//		int $toggle 0=show all, 1=toggle
global proc smoothingDisplayToggle (int $toggle) {

	// find selected objects
	// most likely user will have transform node(s) selected
	string $objects[] = `listRelatives -noIntermediate -children -fullPath -type "mesh" -type "subdiv" -type "nurbsSurface"`;
	
	// if this is not the case, check if they have components selected
	if (`size $objects` == 0){
		$objects = `listRelatives -noIntermediate -parent -fullPath -type "mesh" -type "subdiv" -type "nurbsSurface"`;

		// and lastly, if $objects is still 0, they may have selected the shape
		if (`size $objects` == 0){
			$objects = `ls -sl -noIntermediate -type "mesh" -type "subdiv" -type "nurbsSurface"`;

			// if still nothing give them an error
			if (`size $objects` == 0){
				error (uiRes("m_smoothingDisplayToggle.kErrorNothingSelected"));
			}
		}
	}

	if (size(`ls -sl`) > 1) {
		// Warn and proceed
		warning (uiRes("m_smoothingDisplayToggle.kWarningMoreThanOneSelected"));
	}
	
	if (size($objects)) {
		$object = $objects[0];
	
		// get connections to the smooth node
		// these connections will be the shapes to change the visibility for
		string $connection[] = `listConnections -type "polySmoothProxy" $object`;
		if (`size $connection` == 0){
			$connection = `listConnections -type "polyToSubdiv" $object`;

			if (`size $connection` == 0){
				$connection = `listConnections -type "nurbsToSubdiv" $object`;
			}
		}
		
		if (`size $connection` == 0){
			error ( (uiRes("m_smoothingDisplayToggle.kErrorNoProxy1")) + $object + 
					(uiRes("m_smoothingDisplayToggle.kErrorNoProxy2")) );
				
		} else if (`size $connection` > 1){
			error ( (uiRes("m_smoothingDisplayToggle.kErrorMoreThanOneProxy1")) +
				$object + (uiRes("m_smoothingDisplayToggle.kErrorMoreThanOneProxy2")) );	
		} else {
			
			if (`nodeType $connection[0]` == "polyToSubdiv" || 
				`nodeType $connection[0]` == "nurbsToSubdiv"){
				//object is a subd
				changeSubdivDisplay $toggle $object $connection[0];
				
			} else if (`nodeType $connection[0]` == "polySmoothProxy"){   
				//object is a poly
				changeSmoothProxyDisplay $toggle $object $connection[0];				
			}
		}
	}
}
