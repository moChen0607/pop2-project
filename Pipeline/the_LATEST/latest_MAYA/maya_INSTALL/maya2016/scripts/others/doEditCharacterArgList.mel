// Copyright (C) 1997-2014 Autodesk, Inc., and/or its licensors.
// All rights reserved.
//
// The coded instructions, statements, computer programs, and/or related
// material (collectively the "Data") in these files contain unpublished
// information proprietary to Autodesk, Inc. ("Autodesk") and/or its licensors,
// which is protected by U.S. and Canadian federal copyright law and by
// international treaties.
//
// The Data is provided for use exclusively by You. You have the right to use,
// modify, and incorporate this Data into other products for purposes authorized 
// by the Autodesk software license agreement, without fee.
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND. AUTODESK
// DOES NOT MAKE AND HEREBY DISCLAIMS ANY EXPRESS OR IMPLIED WARRANTIES
// INCLUDING, BUT NOT LIMITED TO, THE WARRANTIES OF NON-INFRINGEMENT,
// MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE, OR ARISING FROM A COURSE 
// OF DEALING, USAGE, OR TRADE PRACTICE. IN NO EVENT WILL AUTODESK AND/OR ITS
// LICENSORS BE LIABLE FOR ANY LOST REVENUES, DATA, OR PROFITS, OR SPECIAL,
// DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES, EVEN IF AUTODESK AND/OR ITS
// LICENSORS HAS BEEN ADVISED OF THE POSSIBILITY OR PROBABILITY OF SUCH DAMAGES.

proc string[] findOffsetObjectTRChannelsInArray( string $character, string $array[] )
{
	string $result[];

	string $offsets[] = `character -q -aoo $character`;
	if (size($offsets) == 0)
		return $result;

	string $channelNames[] = {
		".translateX", ".tx",
		".translateY", ".ty",
		".translateZ", ".tz",
		".rotateX",    ".rx",
		".rotateY",    ".ry",
		".rotateZ",    ".rz"
	};

	for ($o in $offsets)
	{
		for ($cn in $channelNames)
		{
			string $channel = ($o + $cn);

			// If offset object channel is a member of the character and also found
			// in the input array, add it to the result array.
			//
			if (`character -im $character $channel` &&
				stringArrayFind($channel, 0, $array) != -1)
				 $result[size($result)] = $channel;
		}
	}

	return $result;
}

proc int showRemoveChannelConfirmDialog( string $character, string $channels[] )
{
	string $continueBtn = (uiRes("m_doEditCharacterArgList.kContinue"));
	string $cancelBtn   = (uiRes("m_doEditCharacterArgList.kCancel"));
	string $msg         = (uiRes("m_doEditCharacterArgList.kSetWarningMsg1"));
	$msg = `format -s $character $msg`;

	for ( $channel in $channels )
		$msg += ( "\n" + $channel );

	$msg += ( "\n\n" + (uiRes("m_doEditCharacterArgList.kSetWarningMsg2")) );

	string $dialog = `confirmDialog
		-title (uiRes("m_doEditCharacterArgList.kWarning"))
		-message $msg
		-messageAlign "left"
		-button $continueBtn
		-button $cancelBtn
		-defaultButton $cancelBtn
		-cancelButton $cancelBtn
		-dismissString $cancelBtn`;

	return ( $dialog == $continueBtn );
}

//
//
//  Creation Date:  Oct, 1999
//
//	Procedure Name:
//		doEditCharacterArgList
//
//	Description:
//		Edit the character
//
//	Input Arguments:
//	$version: The version of this option box.  Used to know how to 
//	interpret the $args array.
//		"1" : first version of nla
//  
//	$args
//	Version 1
//	[0]		$editMode :  how to edit the character
// 			0 == Remove selected channel box attrs from character
// 			1 == Add select channel box attrs to character
//
//	Return Value:
//		$string: The command string
//


global proc
doEditCharacterArgList( string $version, string $args[] )
{
	string $editMode = $args[0];

	// Is a character selected?
	//
	string $sel[] = `ls -sl -type character`;

	// If no character selected, see if there is a current character
	//
	if (0 == size($sel)) {
		$sel = `currentCharacters`;
	}

	if (size($sel) == 0) {
		error (uiRes("m_doEditCharacterArgList.kMustHaveACurrentCharErr"));
		return;
	}

	// Find what is selected in the channel box
	//
	string $attrs[] = `selectedChannelBoxPlugs`;
	int $attrCount = size($attrs);
	if (0 == $attrCount) {
		error (uiRes("m_doEditCharacterArgList.kNoAttributesSelectedErr"));
		return;
	}

	// Filter attrs...
	//
	int $i;
	for ($i = 0; $i < $attrCount; $i++) {
		// Is the attribute on the character node? If so, translate it
		// to the corresponding member attribute.
		//
		string $buff[];
		tokenize($attrs[$i],".",$buff);
		if (nodeType($buff[0]) == "character") {
			string $conns[] = `listConnections -s 0 -d 1 -p true $attrs[$i]`;
			if (size($conns)) {
				$attrs[$i] = $conns[0];
			}
		}
	}

	for ($character in $sel) {
		int $hasOffsetObjects = size(`character -q -aoo $character`) > 0;
		if (0 == $editMode) {
			if ($hasOffsetObjects) {
				// Are we removing an offset object T or R channel ?
				//
				string $ooChannelsToRemove[] = findOffsetObjectTRChannelsInArray($character, $attrs);
				if (size($ooChannelsToRemove) > 0)
				{
					// Bail if user decides to cancel this operation
					//
					if (!showRemoveChannelConfirmDialog($character, $ooChannelsToRemove))
						continue;

					// Delete all clip ghost shapes associated with character clips
					//
					string $clipToGhost = getClipToGhostForScheduler(`character -q -scheduler $character`);
					if (size($clipToGhost) > 0)
					{
						string $clips[] = getGhostedClips($clipToGhost);
						for ($c in $clips)
							delete `getGhostShapeForClip($c)`;

						delete $clipToGhost;
					}

					// Remove all character offsets
					//
					character -e -roo $character ( `character -q -aoo $character` );
					$hasOffsetObjects = false;
				}
			}

			character -rm $character $attrs;
		} else {
			character -forceElement $character $attrs;
		}
		
		// Update offset objects and ghosts if we previously
		// had this enabled.
		//
		if ($hasOffsetObjects) {
			string $prevSel[] = `ls -sl`;
			select -r $character;
			performSetOffsetObject;
			select -r $prevSel;
		}
	}
}
