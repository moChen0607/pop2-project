// Copyright (C) 1997-2014 Autodesk, Inc., and/or its licensors.
// All rights reserved.
//
// The coded instructions, statements, computer programs, and/or related
// material (collectively the "Data") in these files contain unpublished
// information proprietary to Autodesk, Inc. ("Autodesk") and/or its licensors,
// which is protected by U.S. and Canadian federal copyright law and by
// international treaties.
//
// The Data is provided for use exclusively by You. You have the right to use,
// modify, and incorporate this Data into other products for purposes authorized 
// by the Autodesk software license agreement, without fee.
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND. AUTODESK
// DOES NOT MAKE AND HEREBY DISCLAIMS ANY EXPRESS OR IMPLIED WARRANTIES
// INCLUDING, BUT NOT LIMITED TO, THE WARRANTIES OF NON-INFRINGEMENT,
// MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE, OR ARISING FROM A COURSE 
// OF DEALING, USAGE, OR TRADE PRACTICE. IN NO EVENT WILL AUTODESK AND/OR ITS
// LICENSORS BE LIABLE FOR ANY LOST REVENUES, DATA, OR PROFITS, OR SPECIAL,
// DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES, EVEN IF AUTODESK AND/OR ITS
// LICENSORS HAS BEEN ADVISED OF THE POSSIBILITY OR PROBABILITY OF SUCH DAMAGES.

//
//
//  Creation Date:  4 April 1997
//
//  Procedure Name:
//      performPolyWedgeFace
//
//  Description:
//        
//         
//  Input Arguments:
//        $option : Whether to set the options to default values.
//  Return Value:
//        command string iff $option==2
//

//
// Initialize optionVars for polyWedgeFace:
// 
// 

proc setOptionVars (
	int			$forceFactorySettings
)
{
	// -wa/-wedgeAngle
	if ($forceFactorySettings || !`optionVar -exists "polyWedgeFaceAngle"`)
		optionVar -floatValue "polyWedgeFaceAngle" 90.;

	// -d/-divisions
	if ($forceFactorySettings || !`optionVar -exists "polyWedgeFaceDivisions"`)
		optionVar -intValue "polyWedgeFaceDivisions" 4;
}

global proc performPolyWedgeFaceSetup (string $parent, int $forceFactorySettings)
{
	string $prefix = "polyWedgeFace";
	float $fval;
	
	setOptionVars($forceFactorySettings);
	setParent $parent;

	$fval = `optionVar -query "polyWedgeFaceAngle"`;
	floatSliderGrp -edit -value $fval polyWedgeFaceAngle;

	int $ival = `optionVar -query polyWedgeFaceDivisions`;
	intSliderGrp -edit -value $ival polyWedgeFaceDivisions;
}

global proc performPolyWedgeFaceCallback (string $parent, int $doIt)
{
	string $prefix = "polyWedgeFace";
	
	setParent $parent;
	
	optionVar -floatValue "polyWedgeFaceAngle"
		`floatSliderGrp -query -value polyWedgeFaceAngle`;
	
	optionVar -intValue "polyWedgeFaceDivisions" 
		(`intSliderGrp -query -value polyWedgeFaceDivisions`);

	if ($doIt) 
	{
		performPolyWedgeFace 0;
		addToRecentCommandQueue "performPolyWedgeFace 0" "PolyWedgeFace";
	}
}

proc polyWedgeFaceOptions (string $prefix)
{
	// Global template variables for form spacing
	global int $gOptionBoxTemplateDescriptionMarginWidth;
	global int $gOptionBoxTemplateFrameSpacing;
	
	string $layout = getOptionBox();
	setParent $layout;
	setUITemplate -pushTemplate OptionBoxTemplate;
	waitCursor -state 1;
	//tabLayout -scr true -tv false;

	string $commandName = "performPolyWedgeFace";
	string $callback = ($commandName + "Callback");
	string $setup = ($commandName + "Setup");
	
	// Form layout
	string $parent = `formLayout polyWedgeFaceOptions`;
	
		// Description frame
		string $descriptionFrame = 
		`frameLayout -label (uiRes("m_performPolyWedgeFace.kDescriptionFrame")) -mw $gOptionBoxTemplateDescriptionMarginWidth`;	
		
			columnLayout;
			text -label (uiRes("m_performPolyWedgeFace.kDescription1"));
			text -label (uiRes("m_performPolyWedgeFace.kDescription2"));

		setParent $parent;

		// Settings frame
		string $settingsFrame = 
		`frameLayout -label (uiRes("m_performPolyWedgeFace.kSettingsFrame"))`;

			columnLayout;
			floatSliderGrp -label (uiRes("m_performPolyWedgeFace.kArcAngle")) -min 0.0 -max 360.0 polyWedgeFaceAngle;	
			intSliderGrp -label (uiRes("m_performPolyWedgeFace.kDivisions")) -min 1 -max 10 polyWedgeFaceDivisions;

		setParent $parent;

	setParent ..;

	// Attach Description/Settings frames to form layout
	formLayout -e
		-af $descriptionFrame "top" $gOptionBoxTemplateFrameSpacing
		-af $descriptionFrame "left" $gOptionBoxTemplateFrameSpacing
		-af $descriptionFrame "right" $gOptionBoxTemplateFrameSpacing
		-an $descriptionFrame "bottom"

		-ac $settingsFrame "top" $gOptionBoxTemplateFrameSpacing $descriptionFrame
		-af $settingsFrame "left" $gOptionBoxTemplateFrameSpacing
		-af $settingsFrame "right" $gOptionBoxTemplateFrameSpacing
		-an $settingsFrame "bottom"

	$parent;
	
	waitCursor -state 0;
	setUITemplate -popTemplate;

	string $applyBtn = getOptionBoxApplyBtn();
	button -edit -label (uiRes("m_performPolyWedgeFace.kWedgeFaceButton"))
	       -command ($callback + " " + $parent + " " + 1) $applyBtn;
	string $saveBtn = getOptionBoxSaveBtn();
	button -edit 
		-command ($callback + " " + $parent + " " + 0 + "; hideOptionBox")
		$saveBtn;
	string $resetBtn = getOptionBoxResetBtn();
	button -edit 
		-command ($setup + " " + $parent + " " + 1) $resetBtn;

	setOptionBoxTitle( (uiRes("m_performPolyWedgeFace.kWedgeFaceOptions")) );

	setOptionBoxHelpTag("WedgeFaces");

	eval (($setup + " " + $parent + " " + 0));

	showOptionBox();
}

proc int polyVerifyInputSelection()
// 
// Verify that faces and one or more edges from the selected 
// faces are selected for a wedge operation.
//
{
	string $msg1 = (uiRes("m_performPolyWedgeFace.kWedgeFaceErrorMsg"));

	// Verify that faces are selected.
	string $faces[] = `filterExpand -sm 34 -expand true`;
	if ( 0 == size($faces) ) { 
		string $msg = (uiRes("m_performPolyWedgeFace.kWedgeFaceNoFaceErrorMsg"));
		error( $msg + " " + $msg1 );
		return 0;
	}

	// Verify that edges from selected faces are selected.
	string $edges[] = `filterExpand -sm 32 -expand true`;
	if ( 0 == size($edges) ) { 
		string $msg = (uiRes("m_performPolyWedgeFace.kWedgeFaceNoEdgeErrorMsg"));
		error( $msg + " " + $msg1 );
		return 0;

	}

	// ------------------------------------------------ 
	// Faces and edges are selected. Now verify that the 
	// selected edges are from selected faces.
	// ------------------------------------------------ 

	// Get all edges which belong to selected faces.
	//
	string $faceE[]     = `polyListComponentConversion -toEdge $faces`;
	string $faceEdges[] = `filterExpand -sm 32 -expand true $faceE`;

	// For each selected edge, verify that it belongs 
	// to at least one of the selected faces.
	int $invalidEdges = 0;
	for ($e in $edges) {
		int $foundFaceEdge = 0;
		for ($fe in $faceEdges) {
			if ($e == $fe) {
				$foundFaceEdge = 1;
				break;	
			}  
		}
		if ( !$foundFaceEdge ) {
			$invalidEdges = 1;
			break;
		}
	}

	if ( $invalidEdges ) {
		string $msg = (uiRes("m_performPolyWedgeFace.kWedgeFaceNoMatchErrorMsg"));
		error( $msg + " " + $msg1 );
		return 0;
	}

	return 1;
}

proc int polyComponentId(string $selection)
{
	int $id;
	string $result[];
	tokenize $selection "[]" $result;
	if (size($result) < 1) return -1;
	if ($result[1] == "") return -1;
	$id = $result[1];
	return $id;
}

proc string assembleCmd()
{
	setOptionVars (false);

	int $doHistory = `constructionHistory -q -toggle`;

	string $cmd = "polyWedgeFace";
	$cmd += " -ws 1";
	
	float $wa = `optionVar -query "polyWedgeFaceAngle"`;
	int	  $wd = `optionVar -query "polyWedgeFaceDivisions"`;

	$cmd += " -wedgeAngle " + $wa;
	$cmd += " -divisions " + $wd;

	string $edges[] = `filterExpand -sm 32 -expand true`;
	for ($edge in $edges) {
		$cmd += " -ed " + polyComponentId($edge);
	}
	return $cmd;
}


global proc string performPolyWedgeFace (int $option)
{
	string $prefix = "polyWedgeFace";
	string $cmd="";

	switch ($option) 
	{
		case 0:
		// Verify that we have the correct selection.
		if ( polyVerifyInputSelection() ) {

			setOptionVars(false);
			
			string $cmd=`assembleCmd`;
		
			polyPerformAction $cmd "f" 0;    

			// make sure node is selected when there is history
			if ( 0 != size(`ls -sl`) || (0 != size(`ls -hl`)) ) {
				string $tmp[] = `listHistory`;
				string $totalSel[];
				for ($opNode in $tmp) {
					if (`nodeType $opNode` == "polyWedgeFace") {
						$totalSel[size($totalSel)] = $opNode;
					}
				}
			
 				if (size($totalSel) > 0) 
 					select -add $totalSel[0];
			}

			setToolTo ShowManips;
		}
		break;

		case 1:
			polyWedgeFaceOptions($prefix);
			break;
		case 2:
			$cmd="performPolyWedgeFace 0";
			break;
	}
	return $cmd;
}

