// Copyright (C) 1997-2014 Autodesk, Inc., and/or its licensors.
// All rights reserved.
//
// The coded instructions, statements, computer programs, and/or related
// material (collectively the "Data") in these files contain unpublished
// information proprietary to Autodesk, Inc. ("Autodesk") and/or its licensors,
// which is protected by U.S. and Canadian federal copyright law and by
// international treaties.
//
// The Data is provided for use exclusively by You. You have the right to use,
// modify, and incorporate this Data into other products for purposes authorized 
// by the Autodesk software license agreement, without fee.
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND. AUTODESK
// DOES NOT MAKE AND HEREBY DISCLAIMS ANY EXPRESS OR IMPLIED WARRANTIES
// INCLUDING, BUT NOT LIMITED TO, THE WARRANTIES OF NON-INFRINGEMENT,
// MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE, OR ARISING FROM A COURSE 
// OF DEALING, USAGE, OR TRADE PRACTICE. IN NO EVENT WILL AUTODESK AND/OR ITS
// LICENSORS BE LIABLE FOR ANY LOST REVENUES, DATA, OR PROFITS, OR SPECIAL,
// DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES, EVEN IF AUTODESK AND/OR ITS
// LICENSORS HAS BEEN ADVISED OF THE POSSIBILITY OR PROBABILITY OF SUCH DAMAGES.

//
//
//  Creation Date:  31 January 2006
//
//  Procedure Name:
//      performPolyMerge
//
//  Description:
//        Merge the selected polygon border edges or the selected vertices
//
//  Input Arguments:
//        $option :
//  Return Value:
//
//


global proc int getMergeElementsType()
{
	// return:	0 for vertex (default)
	//			1 for edge

	string $elems[] =`ls -selection`;
	if( size($elems) == 0 ){
		warning( (uiRes("m_performPolyMerge.kWarningNothingSelected")) );
	}

	// default to merge vert
	int $returnType = 0;

	// Check for edges first...
	if (0 != size(`filterExpand -expand false -selectionMask 32`))
	{
		return 1;
	}
	// then try verts...
	else if (0 != size(`filterExpand -expand false -selectionMask 31`))
	{
		return 0;
	}

	return $returnType;
}

proc setOptionVars (int $forceFactorySettings, int $mergeType)
{

	switch ($mergeType) {
		
		case 0:	// Merge vertex
	
			if ($forceFactorySettings || !`optionVar -exists polyMergeVertexDistance`)
				optionVar -floatValue polyMergeVertexDistance 0.0100;

			if ($forceFactorySettings || !`optionVar -exists polyMergeVertexAlwaysMergeTwoVertices`)
				optionVar -intValue polyMergeVertexAlwaysMergeTwoVertices 1;
				
			break;
			
		case 1:	// Merge edge

			if ($forceFactorySettings || !`optionVar -exists polyMergeEdgeMap`)
				optionVar -intValue polyMergeEdgeMap 1;

			if ($forceFactorySettings || !`optionVar -exists polyMergeEdge`)
				optionVar -floatValue polyMergeEdge 0.0;

			if ($forceFactorySettings || !`optionVar -exists polyMergeEdgeWorldSpace`)
				optionVar -intValue polyMergeEdgeWorldSpace 1;
				
			break;
			
	}
}

global proc performPolyMergeSetup (string $parent, int $forceFactorySettings, int $mergeType)
{
	setOptionVars($forceFactorySettings, $mergeType);
	setParent $parent;

	switch ($mergeType) {
		
		case 0:	// Merge vertex

			float $fval1 = `optionVar -query polyMergeVertexDistance`;
			floatSliderGrp -edit -value $fval1 polyMergeVertexDistance;

			int $ival = `optionVar -query polyMergeVertexAlwaysMergeTwoVertices`;
			checkBoxGrp -edit -value1 $ival polyMergeVertexAlwaysMergeTwoVertices;
			
			break;

		case 1:	// Merge edge

			int $iSM = `optionVar -query polyMergeEdgeMap`;
			checkBoxGrp -edit -value1 $iSM polyMergeEdgeMap;

			float $fval = `optionVar -query polyMergeEdge`;
			floatSliderGrp -edit -value $fval polyMergeEdge;

			int $iWS = `optionVar -query polyMergeEdgeWorldSpace`;

			int $val = 1;

			if($iWS == 0)
				$val = 2;

			radioButtonGrp -edit -sl $val polyMergeEdgeWorldSpace;
			
			break;
	}
}

global proc performPolyMergeCallback (string $parent, int $doIt, int $mergeType)
{
	setParent $parent;

	switch ($mergeType) {
		
		case 0:	// Merge vertex

			optionVar -floatValue polyMergeVertexDistance
				`floatSliderGrp -query -value polyMergeVertexDistance`;

			optionVar -intValue polyMergeVertexAlwaysMergeTwoVertices
				`checkBoxGrp -query -value1 polyMergeVertexAlwaysMergeTwoVertices`;
				
			if ($doIt) {
				performPolyMergeVertex 0;
				addToRecentCommandQueue "performPolyMergeVertex 0" "PolyMergeVertex";
			}
			
			break;

		case 1:	// Merge edge
		
			optionVar -intValue polyMergeEdgeMap
				`checkBoxGrp -query -value1 polyMergeEdgeMap`;
			optionVar -floatValue polyMergeEdge
				`floatSliderGrp -query -value polyMergeEdge`;

			int $val = 1;
			int $intVal = `radioButtonGrp -query -sl polyMergeEdgeWorldSpace`;
			if($intVal == 2)
				$val = 0;

			optionVar -intValue polyMergeEdgeWorldSpace $val;
			
			if ($doIt) {
				performPolyMerge 0;
				addToRecentCommandQueue "performPolyMerge 0" "PolySewEdge";
			}
			
			break;
	}
}

proc polyMergeOptions (int $mergeType)
{
	// Global template variables for form spacing
	global int $gOptionBoxTemplateFrameSpacing;
	global int $gOptionBoxTemplateDescriptionMarginWidth;
	
	string $commandName = "performPolyMerge";
	string $callback = ($commandName + "Callback");
	string $setup = ($commandName + "Setup");

	string $layout = getOptionBox();
	setParent $layout;
	setUITemplate -pushTemplate OptionBoxTemplate;
	waitCursor -state 1;

	// Form layout
	string $parent = `formLayout polyMergeOptions`;

		// Settings frame
		string $settingsFrame = 
		`frameLayout -label (uiRes("m_performPolyMerge.kSettingsFrame"))`;

				columnLayout;

				string $threshold = (uiRes("m_performPolyMerge.kThreshold"));

				switch ($mergeType) {

					case 0:	// Merge vertex				

						floatSliderGrp -label $threshold -min 0 -max 10 -fmx 10000000 polyMergeVertexDistance;
						checkBoxGrp -label1 (uiRes("m_performPolyMerge.kAlwaysMergeText")) polyMergeVertexAlwaysMergeTwoVertices;
						break;
						
					case 1:	// Merge edge

						checkBoxGrp -label1 (uiRes("m_performPolyMerge.kMergeUVs")) polyMergeEdgeMap;
						floatSliderGrp -label $threshold -min 0 -max 10 -fmx 10000000 polyMergeEdge;
						radioButtonGrp 
							-numberOfRadioButtons 2 
							-vr
							-label (uiRes("m_performPolyMerge.kThresholdDistance"))
							-labelArray2 	(uiRes("m_performPolyMerge.kWorldSpace")) 
											(uiRes("m_performPolyMerge.kLocalSpace"))
							polyMergeEdgeWorldSpace;
						break;
				}
					
			setParent ..; // columnLayout
	
		setParent $parent; // frameLayout
		
	setParent ..; // formLayout
	
	// Attach frames to form layout
	formLayout -e
		-af $settingsFrame "top" $gOptionBoxTemplateFrameSpacing
		-af $settingsFrame "left" $gOptionBoxTemplateFrameSpacing
		-af $settingsFrame "right" $gOptionBoxTemplateFrameSpacing
		-an $settingsFrame "bottom"
	$parent;

	waitCursor -state 0;
	setUITemplate -popTemplate;

	string $applyBtn = getOptionBoxApplyBtn();
	button -edit -label (uiRes("m_performPolyMerge.kMergeButton"))
		-command ($callback + " " + $parent + " " + 1 + " " + $mergeType)
		$applyBtn;
	string $saveBtn = getOptionBoxSaveBtn();
	button -edit
		-command ($callback + " " + $parent + " " + 0 + " " + $mergeType + "; hideOptionBox")
		$saveBtn;
	string $resetBtn = getOptionBoxResetBtn();
	button -edit
		-command ($setup + " " + $parent + " " + 1 + " " + $mergeType)
		$resetBtn;

	string $optionsTitle;
	string $optionsHelpTag;

	switch ($mergeType) {
		case 0:	
			$optionsTitle = (uiRes("m_performPolyMerge.kMergeVerticesOptions"));
			$optionsHelpTag = "MergeVertices";
			break;
		case 1:	
			$optionsTitle = (uiRes("m_performPolyMerge.kMergeEdgesOptions"));
			$optionsHelpTag = "MergeMultipleEdges";
			break;
	}

	setOptionBoxTitle( $optionsTitle );
	setOptionBoxHelpTag($optionsHelpTag);

	eval (($setup + " " + $parent + " " + 0 + " " + $mergeType));
	
	scriptJob -protected
		-parent $parent 
		-event "SelectTypeChanged" "evalDeferred \"performPolyMerge 1\"";
	
	showOptionBox();
}

global proc string performPolyMerge (int $option)
// 
// $option:
//   0: perform the merge.  Check for edges then vertices.
//   1: display option box.  Check for edges then vertices.
//   2: return the string for option 0.
//   3/4/5: maps to 0/1/2 but specifically for vertex components.
//   6/7/8: maps to 0/1/2 but specifically for edge components.
//
{
	string $cmd="";
	string $sel[];

	int $mergeType = getMergeElementsType();
	
	switch ($option) {
	case 0:
	case 1:
	case 2:
		$mergeType = getMergeElementsType();
		break;
	case 3:
	case 4:
	case 5:
		$mergeType = 0;
		$option -= 3;
		break;
	case 6:
	case 7:
	case 8:
	break;
		$mergeType = 1;
		$option -= 6;
		break;
	}

	switch ($option) {
		
	case 0:
	
		setOptionVars(false, $mergeType);
		switch ($mergeType) {
			case 0:	// Merge vertex

				float $fval = `optionVar -query polyMergeVertexDistance`;
				float $ival = `optionVar -query polyMergeVertexAlwaysMergeTwoVertices`;
				$cmd =("polyMergeVertex  -d " + $fval + " -am " + $ival);
				polyPerformAction $cmd v 0;
				break;
				
			case 1:	// Merge edge
			
				float $fval = `optionVar -query polyMergeEdge`;
				int $ivSM = `optionVar -query polyMergeEdgeMap`;
				int $ivWS = `optionVar -query polyMergeEdgeWorldSpace`;
				$cmd=("polySewEdge -t " + $fval + " -tx " + $ivSM + " -ws " + $ivWS);
				polyPerformAction $cmd e 0;
				break;
		}

		// make sure node is selected when there is history
		if ( 0 != size(`ls -sl`) || (0 != size(`ls -hl`)) ) {
			string $tmp[] = `listHistory`;
			string $totalSel[];
			for ($opNode in $tmp) {
				if (`nodeType $opNode` == "polyMergeVert" || `nodeType $opNode` == "polySewEdge") {
					$totalSel[size($totalSel)] = $opNode;
				}
			}
			
 			if (size($totalSel) > 0) 
 				select -add $totalSel[0];
		}

		setToolTo ShowManips;
		break;
		
	case 1: 
		
		polyMergeOptions $mergeType; 
		break;
		
	default:
		
		//Unneccesary because cmd simply calls performPolyEdge 0 in order to allow
		//component interoperability from a dragged shelf button
		
		setOptionVars(false, $mergeType);
		
		switch ($mergeType) {
			case 0:	// Merge vertex

				float $fval = `optionVar -query polyMergeVertexDistance`;
				float $ival = `optionVar -query polyMergeVertexAlwaysMergeTwoVertices`;
				$cmd =("polyMergeVertex -d " + $fval + " -am " + $ival);
				$cmd = ("polyPerformAction \"" + $cmd + "\" v 0");
				break;
				
			case 1:	// Merge edge

				float $fval = `optionVar -query polyMergeEdge`;
				int $ivSM = `optionVar -query polyMergeEdgeMap`;
				int $ivWS = `optionVar -query polyMergeEdgeWorldSpace`;
				$cmd =("polySewEdge -t " + $fval + " -tx " + $ivSM +" -ws " + $ivWS);
				$cmd = ("polyPerformAction \"" + $cmd + "\" e 0");
				break;
		}
	}
	
	//if dragging to shelf and need a command to call, calls the 0 execute command
	//which will query the current option vars
	$cmd = "performPolyMerge 0";	
	return $cmd;
}
