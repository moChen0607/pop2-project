// Copyright (C) 1997-2014 Autodesk, Inc., and/or its licensors.
// All rights reserved.
//
// The coded instructions, statements, computer programs, and/or related
// material (collectively the "Data") in these files contain unpublished
// information proprietary to Autodesk, Inc. ("Autodesk") and/or its licensors,
// which is protected by U.S. and Canadian federal copyright law and by
// international treaties.
//
// The Data is provided for use exclusively by You. You have the right to use,
// modify, and incorporate this Data into other products for purposes authorized 
// by the Autodesk software license agreement, without fee.
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND. AUTODESK
// DOES NOT MAKE AND HEREBY DISCLAIMS ANY EXPRESS OR IMPLIED WARRANTIES
// INCLUDING, BUT NOT LIMITED TO, THE WARRANTIES OF NON-INFRINGEMENT,
// MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE, OR ARISING FROM A COURSE 
// OF DEALING, USAGE, OR TRADE PRACTICE. IN NO EVENT WILL AUTODESK AND/OR ITS
// LICENSORS BE LIABLE FOR ANY LOST REVENUES, DATA, OR PROFITS, OR SPECIAL,
// DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES, EVEN IF AUTODESK AND/OR ITS
// LICENSORS HAS BEEN ADVISED OF THE POSSIBILITY OR PROBABILITY OF SUCH DAMAGES.

//
//
// Creation Date:  Sept, 2003
//
//
//  Procedure Name:
//      mapcharWindow
//
//  Description:
//              Creates a window to map and unmap character channels or nodes.
//
//  Input Arguments:
//      None.
//
//  Return Value:
//      None.
//
global string $gLoadedCharLeft;
global string $gLoadedCharRight;

proc
int MCsetCharacter(string $side, string $character)
{
	global string $gLoadedCharLeft;
	global string $gLoadedCharRight;

	// unmapped items
	//
	int $nodesOnly = `optionVar -q MCnodesOnly`;
	string $errorMap = (uiRes("m_mapcharWindow.kMapError"));
	if ($side == "left") {
		if ($gLoadedCharRight == $character) {
			error($errorMap);
			return 0;
		}
		if ($gLoadedCharLeft == $character) {
			return 0;
		}
		$gLoadedCharLeft = $character;
	} else {
		if ($gLoadedCharLeft == $character) {
			error($errorMap);
			return 0;
		}
		if ($gLoadedCharRight == $character) {
			return 0;
		}
		$gLoadedCharRight = $character;
	}
	return 1;
}

global
proc int loadCharacter(string $side)
//
// Description: Load the character into the specified side of the window.
// Return: true/false = success/failure
//
{
	global string $gLoadedCharLeft;
	global string $gLoadedCharRight;
	string $list;
	string $character;

	// unmapped items
	//
	int $nodesOnly = `optionVar -q MCnodesOnly`;
	int $alpha = `optionVar -q MCalphabetical`;
	if ($side == "left") {
		$character = $gLoadedCharLeft;
		$list = "unmappedLeft";
		textFieldGrp -e -text $gLoadedCharLeft fromText;
	} else {
		$character = $gLoadedCharRight;
		$list = "unmappedRight";
		textFieldGrp -e -text $gLoadedCharRight toText;
	}

	if (size($character) == 0) {
		return 1;
	}
	
	// mapped items
	//
	string $mems[];
	if ($nodesOnly) {
		string $allMems[] = `character -q -nodesOnly $character`;
		for ($member in $allMems) {
			// remove subcharacters from the list
			//
			if (nodeType($member) != "character") {
				$mems[size($mems)] = $member;
			}
		}
	} else {
		string $allMems[] = `character -q  $character`;
		for ($member in $allMems) {
			// remove subcharacters from the list
			//
			if (nodeType($member) != "character") {
				$mems[size($mems)] = $member;
			}
		}
	}

	textScrollList -e -ra $list;

	string $sorted[];
	if ($alpha) {
		$sorted = sort($mems);;
	} else {
		$sorted = sortHierarchically($character,$mems);
	}

	for ($sortedItem in $sorted) {
		textScrollList -e -a $sortedItem $list;
	}
	
	return 1;
}

proc
string getMapLabel(string $source, string $target)
{
	string $testObj = $source;
	if (size($source) == 0) {
		$source = "         ";
		$testObj = $target;
	}
	if (size($target) == 0) {
		$target = "         ";
	}
	string $assoc = ($source + " -----> " + $target);
	string $label = $assoc;

	return $label;
}

proc
string[] parseObjString(string $item)
//
// String will be of form:  source -----> target
//	
{
	string $result[2];
	$result[0] = "";
	$result[1] = "";	
	string $buffer[];
	tokenize($item," ",$buffer);
	int $sizeBuf = size($buffer);

	$result[0] = $buffer[0];
	$result[1] = $buffer[2];

	return $result;
}


proc updateMappedList()
//
// Update the "Mapped" list with the mapped attributes between the two characters.
// Or if the characters are not specified, simply clear the "Mapped" list.
//
{
	int $doMap = 0;
	global string $gLoadedCharLeft;
	global string $gLoadedCharRight;

	// clear the mapping
	//
	textScrollList -e -removeAll mappedObjects;
	
	if (size($gLoadedCharLeft) && size($gLoadedCharRight) &&
		nodeType($gLoadedCharLeft) == "character" &&
		nodeType($gLoadedCharRight) == "character")
	{
		string $map = `characterMap -q $gLoadedCharLeft $gLoadedCharRight`;
		if (size($map) > 0) {
			$doMap = 1;
		}
	}

	if ($doMap)
	{
		int $nodesOnly = `optionVar -q MCnodesOnly`;
		int $alpha = `optionVar -q MCalphabetical`;
		string $connCmd = ("listConnections -source 0 -destination 1 -plugs true ");
		
		string $mems[];
		if ($nodesOnly) {
			$mems = `characterMap -q -mapNode $gLoadedCharLeft $gLoadedCharRight`;
		} else {
			$mems = `characterMap -q -mapAttr $gLoadedCharLeft $gLoadedCharRight`;
		}
		int $mm;
		int $itemCount = 0;
		string $newItems[];
		for($mm = 0; $mm < size($mems); $mm += 2) {
			if ($nodesOnly) {
				string $newMapping = getMapLabel($mems[$mm],$mems[$mm+1]);
				textScrollList -e -ri $mems[$mm+1] unmappedRight;
				textScrollList -e -ri $mems[$mm]  unmappedLeft;
				$newItems[$itemCount++] = $newMapping;
			} else {
				string $cmd1 = ($connCmd + $mems[$mm]);
				string $cmd2 = ($connCmd + $mems[$mm+1]);
				string $conn1[] = `eval $cmd1`;
				string $conn2[] = `eval $cmd2`;
				
				string $newMapping = getMapLabel($conn1[0],$conn2[0]);
				textScrollList -e -ri $conn2[0] unmappedRight;
				textScrollList -e -ri $conn1[0]  unmappedLeft;
				$newItems[$itemCount++] = $newMapping;
			}
		}

		string $sorted[];
		if ($alpha) {
			$sorted = sort($newItems);
		} else {
			$sorted = $newItems;
		}
		
		for ($sortedItem in $sorted) {
			textScrollList -e -a $sortedItem mappedObjects;
		}
	}
}

global
proc mapCharLoad(string $side)
//
// Description: Callback called when the "Load Source" or "Load Target" button is pushed
//              to load characters based on the selection.	
//
{
	string $chars[] = getCharactersForAction();
	if (size($chars) == 0 || size($chars) > 1) {
		error (uiRes("m_mapcharWindow.kSelectionError"));
	}
	
	if (!MCsetCharacter($side, $chars[0])) {
		return;
	}
	refreshMapCharWindow(1);
}

global
proc mapCharLoadText(string $side)
//
// Description: Callback called when the user types in the character name text box.
//
{
	string $textField;
	if ($side == "left") {
		$textField = "fromText";
	} else {
		$textField = "toText";		
	}

	string $val = `textFieldGrp -q -text $textField`;
	string $isACharacter[] = `ls -type character $val`;
	if (size($isACharacter)) {
		if (!MCsetCharacter($side,$val)) {
			textField -e -text "" $textField;
		}
	} else {
		if ($side == "left") {
			textFieldGrp -e -removeAll unmappedLeft;
		} else {
			textFieldGrp -e -removeAll unmappedRight;
		}
		string $errMsg	  = (uiRes("m_mapcharWindow.kCharError")); 	
		string $errString =  `format -s $val $errMsg`;
		error($errString);
	}
	refreshMapCharWindow(1);
}

global
proc updateMapButton()
//
// Description: Callback to enable/disable the map button based on the selection.
//
{
	string $right[] = `textScrollList -q -si unmappedRight`;
	string $left[]  = `textScrollList -q -si unmappedLeft`;

	int $enable = 0;
	if (size($right) > 0 && size($left) > 0) {
		$enable = 1;
		button -e -label (uiRes("m_mapcharWindow.kMapOption"))  mapCharButton;
	}

	if (size($right) || size($left)) {
		textScrollList -e -da mappedObjects;
		select -r $right $left;
	}

	button -e -enable $enable mapCharButton;
}

global
proc updateUnmapButton()
//
// Description: Callback to enable/disable the unmap button based on the selection.
//
{
	string $mapped[] = `textScrollList -q -si mappedObjects`;
	int $enable = (size($mapped) > 0);
	string $label = (uiRes("m_mapcharWindow.kUpdateUnmap"));
	button -e -enable $enable mapCharButton;
	if ($enable) {
		button -e -label $label mapCharButton;
		textScrollList -e -da unmappedRight;
		textScrollList -e -da unmappedLeft;

		select -d;
		for ($mapItem in $mapped) {
			string $unmapObjs[] = parseObjString($mapItem);
			string $leftObj = $unmapObjs[0];
			string $rightObj = $unmapObjs[1];
			select -add $leftObj $rightObj;
		}
	}
}


proc unmapCharItem(string $item)
//
// Description: Callback for when the user pushes the "Unmap" button.
//
{
	global string $gLoadedCharLeft;
	global string $gLoadedCharRight;
	
	string $unmapObjs[] = parseObjString($item);
	string $leftObj = $unmapObjs[0];
	string $rightObj = $unmapObjs[1];	
	
	int $doCharacterMap = ((nodeType($gLoadedCharLeft) == "character") &&
						   (nodeType($gLoadedCharLeft) == "character"));
	if ($doCharacterMap) {
		string $mapCmd = "characterMap ";	
		int $nodesOnly = `optionVar -q MCnodesOnly`;
		if ($nodesOnly) {
			$mapCmd += "-unmapNode ";
		} else {
			$mapCmd += "-unmapAttr ";
		}
		$mapCmd += ($leftObj+" "+$rightObj+" ");
		$mapCmd += ($gLoadedCharLeft+" "+$gLoadedCharRight);
		evalEcho $mapCmd;
	}

	textScrollList -e -a $rightObj unmappedRight;
	textScrollList -e -a $leftObj  unmappedLeft;
	textScrollList -e -ri $item mappedObjects;
}

global
proc unmapAllCharItems()
{
	global string $gLoadedCharLeft;
	global string $gLoadedCharRight;

	string $mapped[]  = `textScrollList -q -allItems mappedObjects`;
	for ($mapItem in $mapped) {
		unmapCharItem($mapItem);
	}

	string $cmap = `characterMap -q $gLoadedCharLeft $gLoadedCharRight`;
	if (size($cmap) > 0) {
		delete $cmap;
	}
}

proc assignTypes(string $source, string $target)
{
	string $typeRadio = `radioCollection -q -sl puppetPartRadio`;
	int $type = 0;
	if ($typeRadio == "rootBtn") {
		$type = 1;
	} else if ($typeRadio == "hipBtn") {
		$type = 2;
	} else if ($typeRadio == "kneeBtn") {
		$type = 3;
	} else if ($typeRadio == "footBtn") {
		$type = 4;
	} else if ($typeRadio == "toeBtn") {
		$type = 5;
	} else if ($typeRadio == "spineBtn") {
		$type = 6;
	} else if ($typeRadio == "neckBtn") {
		$type = 7;
	} else if ($typeRadio == "headBtn") {
		$type = 8;
	} else if ($typeRadio == "collarBtn") {
		$type = 9;
	} else if ($typeRadio == "shoulderBtn") {
		$type = 10;
	} else if ($typeRadio == "elbowBtn") {
		$type = 11;
	} else if ($typeRadio == "handBtn") {
		$type = 12;
	} else if ($typeRadio == "fingerBtn") {
		$type = 13;
	} else if ($typeRadio == "thumbBtn") {
		$type = 14;
	}

	int $side = 1;
	int $sideRadio = `radioButtonGrp -q -sl sideGrp`;
	if ($sideRadio == 2) $side = 0;
	else if ($sideRadio == 3) $side = 2;
	
	if ($source != "") {
		string $typeCmdS = ("setAttr "+$source+".type "+$type);
		evalEcho $typeCmdS;
		string $sideCmdS = ("setAttr "+$source+".side "+$side);
		evalEcho $sideCmdS;
	}

	if ($target != "") {
		string $typeCmdT = ("setAttr "+$target+".type "+$type);
		evalEcho $typeCmdT;
		string $sideCmdT = ("setAttr "+$target+".side "+$side);
		evalEcho $sideCmdT;
	}
}

global
proc mapCharacterCallback()
//
// Description: Callback for when the user pushes the "Map" button.
//
{
	global string $gLoadedCharLeft;
	global string $gLoadedCharRight;
	
	string $right[] = `textScrollList -q -si unmappedRight`;
	string $left[]  = `textScrollList -q -si unmappedLeft`;
	string $mapped[]  = `textScrollList -q -si mappedObjects`;

	if (size($mapped)) {
		for ($map in $mapped) {
			unmapCharItem($map);
		}
	} else {
		int $doCharacterMap = ((nodeType($gLoadedCharLeft) == "character") &&
							   (nodeType($gLoadedCharLeft) == "character"));

		if ($doCharacterMap) {
			int $nodesOnly = `optionVar -q MCnodesOnly`;
			string $mapCmd = "characterMap ";
			if ($nodesOnly) {
				$mapCmd += "-mapNode ";
			} else {
				$mapCmd += "-mapAttr ";
			}
			$mapCmd += ($left[0]+" "+$right[0]+" ");
			$mapCmd += ($gLoadedCharLeft+" "+$gLoadedCharRight);
			
			evalEcho $mapCmd;
		}
		
		refreshMapCharWindow 1;
	}
	button -e -enable false mapCharButton;
}

global
proc MCupdateMenuCheckBoxes()
{
	int $alpha = `optionVar -q MCalphabetical`;
	int $nodeView = `optionVar -q MCnodesOnly`;

	menuItem -e -cb $alpha MCalphaItem;
	menuItem -e -cb (! $alpha) MChierItem;
	menuItem -e -cb $nodeView MCnodeViewItem;
	menuItem -e -cb (! $nodeView) MCchannelViewItem;
}

global proc MCupdateViewPrefs(int $nodeView, int $alpha, int $force)
{
	global string $gLoadedCharLeft;
	global string $gLoadedCharRight;
	
	int $alphaCurrent = `optionVar -q MCalphabetical`;
	int $nodesOnly = `optionVar -q MCnodesOnly`;
	if ($force || ($nodeView != $nodesOnly || $alpha != $alphaCurrent)) {
		optionVar -iv MCalphabetical $alpha;
		optionVar -iv MCnodesOnly $nodeView;

		string $char1 = $gLoadedCharLeft;
		string $char2 = $gLoadedCharRight;
		clearMapCharWindow();

		if (size($char1) > 0) MCsetCharacter("left",$char1);
		if (size($char2) > 0) MCsetCharacter("right",$char2);
		loadCharacter("left");
		loadCharacter("right");
		updateMappedList();
	}

	MCupdateMenuCheckBoxes();
}

global proc MCupdateWindowMode()
{
	global string $gLoadedCharLeft;
	global string $gLoadedCharRight;

	if (`objExists $gLoadedCharLeft` && nodeType($gLoadedCharLeft) != "character") {
		$gLoadedCharLeft = "";
	}
	if (`objExists $gLoadedCharRight` && nodeType($gLoadedCharRight) != "character") {
		$gLoadedCharRight = "";
	}
	
	MCupdateViewPrefs(`optionVar -q MCnodesOnly`,
					  `optionVar -q MCalphabetical`,
					  1);

	window -e -title (uiRes("m_mapcharWindow.kCharacterMapper"))  mapcharWnd;		
}

global proc MCupdateNodeViewPrefs(int $nodeView)
//
// Description: Update the windows if a node view pref has changed.
//
{
	int $alphaCurrent = `optionVar -q MCalphabetical`;
	MCupdateViewPrefs( $nodeView, $alphaCurrent, 0 );
}

global proc MCupdateChannelViewPrefs(int $channelView)
{
	MCupdateNodeViewPrefs( !($channelView) );
}


global proc MCupdateAlphabetical(int $alpha)
//
// Description: Update the windows if alphabetical pref has changed.
//
{
	int $nodeView = `optionVar -q MCnodesOnly`;
	MCupdateViewPrefs( $nodeView, $alpha, 0 );
}

global proc MCupdateHierarchical(int $hier)
{
	MCupdateAlphabetical( !($hier) );
}

proc int isParentInChar(string $obj, string $charMems[])
{
	string $parents[] = `listRelatives -pa -p $obj`;
	if (size($parents) == 0) {
		return 0;
	}
	int $parentInChar = AWNumberOfOccurrencesInStringArray($parents[0],$charMems);
	if ($parentInChar > 0) {
		return 1;
	}

	return (isParentInChar($parents[0],$charMems));
}

proc string findCharacterRoot(string $charName)
{
	string $allMems[] = `character -q -nodesOnly $charName`;
	int $count = size($allMems);

	int $ii;
	string $mems[];
	for ($ii = ($count-1); $ii >= 0; $ii--) {
		$member = $allMems[$ii];
		
		// remove subcharacters from the list
		//
		if (nodeType($member) == "character") {
			continue;
		}

		string $isDag[] = `ls -type transform $member`;
		if (size($isDag) > 0) {
			$mems[size($mems)] = $member;
		}
	}

	for ($member in $mems) { 
		if (! isParentInChar($member,$mems)) {
			return $member;
		}
	}
	return "";
}

proc
unmapPreExisting(string $src, string $dest,
				 string $srcChar, string $destChar)
{
	string $existingMap[] = `characterMap -q -mapNode $srcChar $destChar`;

	int $ii;
	int $count = size($existingMap);
	for ($ii = 0; $ii < $count; $ii += 2) {
		if ($existingMap[$ii] == $src ||
			$existingMap[$ii+1] == $dest) {
			characterMap -unmapNode $existingMap[$ii] $existingMap[$ii+1] $srcChar $destChar;
		}
	}
}

proc
mapNodesHierarchically(string $src, string $dest, string $srcMems[], string $destMems[])
{
	global string $gLoadedCharLeft;
	global string $gLoadedCharRight;

	// do the mapping
	//
	unmapPreExisting($src,$dest,$gLoadedCharLeft,$gLoadedCharRight);
	string $mapCmd = ("characterMap -mapNode "+$src+" "+$dest);
	$mapCmd += (" "+$gLoadedCharLeft+" "+$gLoadedCharRight);
	evalEcho $mapCmd;

	// iterate down the hierarchy looking for relatives to map
	//
	string $relSrc[] = `listRelatives -pa $src`;
	string $relDest[] = `listRelatives -pa $dest`;

	int $ii, $jj;
	int $currentDest = 0;
	int $srcCount = size($relSrc);
	int $destCount = size($relDest);
	for ($ii = 0; $ii < $srcCount; $ii++) {
		string $isDag[] = `ls -type transform $relSrc[$ii]`;
		if (size($isDag) == 0) {
			continue;
		}
		int $isInChar = AWNumberOfOccurrencesInStringArray($relSrc[$ii],$srcMems);
		if (! $isInChar) {
			continue;
		}
		for ($jj = $currentDest; $jj < $destCount; $jj++) {
			clear($isDag);
			$isDag = `ls -type transform $relDest[$jj]`;
			if (size($isDag) == 0) {
				continue;
			}
			int $isInChar = AWNumberOfOccurrencesInStringArray($relDest[$jj],$destMems);
			if (! $isInChar) {
				continue;
			}
			mapNodesHierarchically($relSrc[$ii],$relDest[$jj],$srcMems,$destMems);
			$currentDest++;
			break;
		}
	}
}

proc
mapBasedOnHierarchy()
{
	global string $gLoadedCharLeft;
	global string $gLoadedCharRight;
	string $allMems1[] = `character -q -nodesOnly $gLoadedCharLeft`;
	string $allMems2[] = `character -q -nodesOnly $gLoadedCharRight`;
	
	// If the user has selected 2 items in the list, use them.
	// Otherwise, look for the root of the character itself.
	//
	string $src, $dest;
	int $nodesOnly = `optionVar -q MCnodesOnly`;	
	string $right[] = `textScrollList -q -si unmappedRight`;
	string $left[]  = `textScrollList -q -si unmappedLeft`;
	if ($nodesOnly == 1 && size($right) == 1 && size($left) == 1) {
		$src = $left[0];
		$dest = $right[0];
	} else {
		$src = findCharacterRoot($gLoadedCharLeft);
		$dest = findCharacterRoot($gLoadedCharRight);
	}

	if (size($src) && size($dest)) {
		mapNodesHierarchically($src,$dest,$allMems1,$allMems2);
	} else {
		error (uiRes("m_mapcharWindow.kRootNodeError"));
	}
}

global
proc mapCharAutomap(string $type)
{
	global string $gLoadedCharLeft;
	global string $gLoadedCharRight;
	if (size($gLoadedCharLeft) == 0 || size($gLoadedCharRight) == 0) {
		error (uiRes("m_mapcharWindow.kLoadError"));
	}

	if ($type == "hierarchy") {
		mapBasedOnHierarchy();
	} else {
		string $mapMethod = "byNodeName";
		if ($type == "order") {
			$mapMethod = "byAttrOrder";
		}
		
		characterMap -mm $mapMethod $gLoadedCharLeft $gLoadedCharRight;
	}
	refreshMapCharWindow(1);
}

proc
string[] findCharacterChildren(string $root, string $mems[])
{
	string $result[];
	string $rel[] = `listRelatives -pa $root`;
	for ($relative in $rel) {
		int $isInChar = AWNumberOfOccurrencesInStringArray($relative,$mems);
		if ($isInChar) {
			$result[size($result)] = $relative;
		}
		string $children[] = findCharacterChildren($relative,$mems);
		for ($child in $children) {
			$result[size($result)] = $child;
		}
	}
	return $result;
}

global proc
string[] sortHierarchically(string $character, string $mems[])
{
	string $root = findCharacterRoot($character);

	string $result[];
	$result[0] = $root;
	string $children[] = findCharacterChildren($root,$mems);
	for ($child in $children) {
		$result[size($result)] = $child;
	}
	
	for ($member in $mems) {
		if (size($mems) == size($result)) {
			// we've found everything
			//
			break;
		}
		int $isInChar = AWNumberOfOccurrencesInStringArray($member,$result);
		if (! $isInChar) {
			if (! isParentInChar($member,$mems)) {
				$result[size($result)] = $member;
				string $newMems[] = findCharacterChildren($member,$mems);
				for ($newMem in $newMems) {
					$result[size($result)] = $newMem;
				}
			}
		}
	}
	return $result;
}

proc MCinitPrefs()
{
	if (! `optionVar -exists MCnodesOnly`) {
		optionVar -iv MCnodesOnly 1;
	}
	if (! `optionVar -exists MCalphabetical`) {
		optionVar -iv MCalphabetical 1;
	}
}

global proc buildMapCharacterContextHelpItems(string $nameRoot, string $menuParent)
{
	menuItem -label (uiRes("m_mapcharWindow.kHelpCharacterMapper")) 
		-enableCommandRepeat false
		-command "showHelp CharacterMapper";
}


proc createCharMapWnd()
//
//      Creates the characterMap window, with
//      four textScrollLists. One pair of lists is for mapped
//      objects, and one is for unmapped.
//
//      If the window already exists, then the proc
//      simply shows the window, effectively popping it
//      to the top, if it's under other windows.
{
	MCinitPrefs();
	int $nodeView = `optionVar -q MCnodesOnly`;
	int $alpha = `optionVar -q MCalphabetical`;

	string $title = (uiRes("m_mapcharWindow.kCharacterMapperTitle"));
	
	window -t $title
		-retain
		-iconName $title  -mb true
		-s true -wh 500 775 mapcharWnd;

 	menu -label (uiRes("m_mapcharWindow.kShow"))  -to true;

 	menuItem -label (uiRes("m_mapcharWindow.kAlphabetical"))  -cb $alpha
 		-c "MCupdateAlphabetical #1"
		MCalphaItem;
 	menuItem -label (uiRes("m_mapcharWindow.kHierarchical"))  -cb ($alpha == 0)
 		-c "MCupdateHierarchical #1"
		MChierItem;
 	setParent -m ..;

	menuItem -d true;
	
 	menuItem -label (uiRes("m_mapcharWindow.kDisplayNodeNames"))  -cb $nodeView
 		-c "MCupdateNodeViewPrefs #1"
		MCnodeViewItem ;
 	menuItem -label (uiRes("m_mapcharWindow.kDisplayChannelNames"))  -cb ($nodeView == 0)
 		-c "MCupdateChannelViewPrefs #1"
		MCchannelViewItem ;		

 	setParent -m ..;

 	menu -label (uiRes("m_mapcharWindow.kEdit")) 
		-to true;
 	menuItem -label (uiRes("m_mapcharWindow.kUnmap")) 
 		-c "mapCharacterCallback";

 	menuItem -label (uiRes("m_mapcharWindow.kUnmapAll")) 
 		-c "unmapAllCharItems";

 	menuItem -label (uiRes("m_mapcharWindow.kClearAll")) 
 		-c "clearMapCharWindow";

 	menuItem -label (uiRes("m_mapcharWindow.kRefresh")) 
 		-c "refreshMapCharWindow 1";

	menuItem -d true;

 	menuItem -label (uiRes("m_mapcharWindow.kMapBasedNodeNames")) 
 		-c "mapCharAutomap(\"nodes\")"
		mapNodeNamesMenu;
	
 	menuItem -label (uiRes("m_mapcharWindow.kMapBasedHierarchy")) 
 		-c "mapCharAutomap(\"hierarchy\")"
		mapHierMenu;
	
 	menuItem -label (uiRes("m_mapcharWindow.kMapBasedOrder")) 
 		-c "mapCharAutomap(\"order\")"
		mapOrderMenu;

 	setParent -m ..;

	//	Adds support for the Context Sensitive Help Menu.
	//
	addContextHelpProc "mapcharWnd" "buildMapCharacterContextHelpItems";
	
	doHelpMenu "mapcharWnd" "mapcharWnd";

	setParent -m ..;

	formLayout mapCharForm;

	formLayout topButtonForm;
	button -label (uiRes("m_mapcharWindow.kLoadSource")) 
		-annotation (uiRes("m_mapcharWindow.kLoadSourceAnnot"))  -w 90
		-c "mapCharLoad \"left\"" mcUpdateLeft;
	button -label (uiRes("m_mapcharWindow.kLoadTarget")) 
		-annotation (uiRes("m_mapcharWindow.kLoadTargetAnnot"))  -w 90
		-c "mapCharLoad \"right\"" mcUpdateRight;
	setParent ..;

	formLayout -e
		-af mcUpdateLeft left 5
		-af mcUpdateLeft top 5
		-an mcUpdateLeft bottom
		-ap mcUpdateLeft right 0 48
		
		-ap mcUpdateRight left 0 50
		-af mcUpdateRight top 5
		-an mcUpdateRight bottom
		-ap mcUpdateRight right 5 100

		topButtonForm;

	string $labelForm = `formLayout labelForm`;
    string $fromText = `textFieldGrp -p $labelForm -label (uiRes("m_mapcharWindow.kFrom")) -cw2 50 230
		-annotation (uiRes("m_mapcharWindow.kTypeNameFromAnnot")) 
		-cc "mapCharLoadText \"left\""  fromText`;
	string $toText = `textFieldGrp -p $labelForm -label (uiRes("m_mapcharWindow.kTo")) -cw2 45 230
		-annotation (uiRes("m_mapcharWindow.kTypeNameToAnnot")) 
		-cc "mapCharLoadText \"right\"" toText`;
	
	setParent ..;
	formLayout -e
		-af fromText left 2
		-af fromText top 2
		-af fromText bottom 5
		-ac fromText right 5 toText
		
		-af toText top 5
		-ap toText left 1 50
		-af toText right 2
		-af toText bottom 5

		$labelForm;

	formLayout objectsForm;
	
	frameLayout -label (uiRes("m_mapcharWindow.kMapped")) 
		-bv false
		-cl false -cll false 
		-mh 5 -mw 10
		mappedLayout;
	
	formLayout mappedForm;
	textScrollList 
		-ams true
		-font "smallFixedWidthFont"
		-sc "updateUnmapButton"
		mappedObjects;
	setParent ..;

	formLayout -e
		-af mappedObjects top 0
		-af mappedObjects left 0
		-af mappedObjects right 0
		-af mappedObjects bottom 0
		mappedForm;
	
	setParent ..;

    frameLayout -label (uiRes("m_mapcharWindow.kUnmapped")) 
		-bv false
		-cl false -cll false 
		-mh 5 -mw 10
		unmappedLayout;

	formLayout unmappedForm;

	textScrollList 
		-ams false
		-sc "updateMapButton"
		unmappedLeft;
	textScrollList 
		-sc "updateMapButton"
		-ams false
		unmappedRight;
	setParent ..;

	formLayout -e
		-af unmappedLeft top 0
		-af unmappedLeft left 0
		-ap unmappedLeft right 0 50
		-af unmappedLeft bottom 0

		-af unmappedRight top 0
		-ac unmappedRight left 0 unmappedLeft
		-af unmappedRight right 0
		-af unmappedRight bottom 0
		unmappedForm;
	setParent ..;
	setParent ..;
	
	formLayout -e
		-af mappedLayout top 2
		-af mappedLayout left 2
		-af mappedLayout right 2
		-ap mappedLayout bottom 2 50

		-ac unmappedLayout top 2 mappedLayout
		-af unmappedLayout left 2
		-af unmappedLayout right 2
		-af unmappedLayout bottom 2
		objectsForm;

	
	formLayout buttonForm;
	button -label (uiRes("m_mapcharWindow.kMap")) 
		-enable false
		-annotation (uiRes("m_mapcharWindow.kMapSelectedSourceAnnot")) 
		-c "mapCharacterCallback" mapCharButton;
	button -label (uiRes("m_mapcharWindow.kClose")) 
		-c "window -e -vis 0 mapcharWnd"
		closeButton;
	setParent ..;
	
	formLayout -e
		-af mapCharButton left 2
		-af mapCharButton top 5
		-af mapCharButton bottom 5
		-ac mapCharButton right 2 closeButton
		
		-af closeButton top 5
		-ap closeButton left 5 50
		-af closeButton right 2
		-af closeButton bottom 5
		buttonForm;

	setParent ..;

	formLayout -e

		-af topButtonForm top 5
		-af topButtonForm left 5
		-af topButtonForm right 5
		-an topButtonForm bottom

		-ac $labelForm top 5 topButtonForm
		-af $labelForm left 5
		-af $labelForm right 5
		
		-af buttonForm bottom 5
		-af buttonForm left 5
		-af buttonForm right 5

		-ac objectsForm top 5 $labelForm
		-af objectsForm left 5
		-af objectsForm right 5
		-ac objectsForm bottom 5 buttonForm

		mapCharForm;
}

global proc clearMapCharWindow() {
	global string $gLoadedCharLeft;
	global string $gLoadedCharRight;
	
	if( `window -exists mapcharWnd` ) {
		textScrollList -e -removeAll mappedObjects;
		textScrollList -e -removeAll unmappedLeft;
		textScrollList -e -removeAll unmappedRight;
		textFieldGrp -e -text "" fromText;
		textFieldGrp -e -text "" toText;		
	}
	$gLoadedCharLeft = "";
	$gLoadedCharRight = "";		
}

global proc refreshMapCharWindow(int $force) {
	if ($force || `window -q -vis mapcharWnd`) {
		MCupdateViewPrefs(`optionVar -q MCnodesOnly`,
						  `optionVar -q MCalphabetical`,
						  1);
	}
}


proc loadMapWnd()
{
	string $sel[] = getCharactersForAction();
	if (size($sel) > 0) {
		MCsetCharacter("left",$sel[0]);

		if (size($sel) > 1) {
			MCsetCharacter("right",$sel[1]);
		}
		refreshMapCharWindow(1);
	}
}

global proc mapcharWindow()
{
	global string $gLoadedCharLeft;
	global string $gLoadedCharRight;

	$gLoadedCharLeft = "";
	$gLoadedCharRight = "";

	if( `window -exists mapcharWnd` ) {
		clearMapCharWindow();
		MCupdateMenuCheckBoxes();
		MCupdateWindowMode();
		showWindow mapcharWnd;
	} else {

		// create the window
		//
		createCharMapWnd();

		scriptJob -protected
			-parent "mapcharWnd"
			-conditionTrue deleteAllCondition clearMapCharWindow;

		scriptJob
			-parent "mapcharWnd"
			-event "Undo" "refreshMapCharWindow 0";
		scriptJob
			-parent "mapcharWnd"
			-event "Redo" "refreshMapCharWindow 0";
	}

	showWindow mapcharWnd;
	loadMapWnd();
}
