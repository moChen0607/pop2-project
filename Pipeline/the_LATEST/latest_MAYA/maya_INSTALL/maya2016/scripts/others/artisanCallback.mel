// Copyright (C) 1997-2014 Autodesk, Inc., and/or its licensors.
// All rights reserved.
//
// The coded instructions, statements, computer programs, and/or related
// material (collectively the "Data") in these files contain unpublished
// information proprietary to Autodesk, Inc. ("Autodesk") and/or its licensors,
// which is protected by U.S. and Canadian federal copyright law and by
// international treaties.
//
// The Data is provided for use exclusively by You. You have the right to use,
// modify, and incorporate this Data into other products for purposes authorized 
// by the Autodesk software license agreement, without fee.
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND. AUTODESK
// DOES NOT MAKE AND HEREBY DISCLAIMS ANY EXPRESS OR IMPLIED WARRANTIES
// INCLUDING, BUT NOT LIMITED TO, THE WARRANTIES OF NON-INFRINGEMENT,
// MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE, OR ARISING FROM A COURSE 
// OF DEALING, USAGE, OR TRADE PRACTICE. IN NO EVENT WILL AUTODESK AND/OR ITS
// LICENSORS BE LIABLE FOR ANY LOST REVENUES, DATA, OR PROFITS, OR SPECIAL,
// DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES, EVEN IF AUTODESK AND/OR ITS
// LICENSORS HAS BEEN ADVISED OF THE POSSIBILITY OR PROBABILITY OF SUCH DAMAGES.

//
//
//  Creation Date:  June 2000
//
//  Description:
//      Option tool callback for Artisan tools
//
//
//  Procedure Name:
//      artisanCallback
//
//  Description:
//      Initialize the option values.
//
//  Input Arguments:
//
//  Return Value:
//      None.
//
// 

// ===================================================
// Artisan Update prcedures.
// ===================================================
global string $gArtWorkdirectory 		= "";
global int 	  $gArtSetAttrMapWorkspace 	= 1;

global proc artSetUpperRadius(
	string  $artCommand
)
//
//	Description:
//		Set upper radius with respect to the lower one.
//
{
	float $radius      = `floatSliderGrp -q -v upperRadiusSlider`;
	float $lowerRadius = `floatSliderGrp -q -v lowerRadiusSlider`;

	if( $lowerRadius > $radius ) {
		floatSliderGrp -e -v $lowerRadius upperRadiusSlider;
	}
}

global proc artSetLowerRadius(
	string  $artCommand
)
//
//	Description:
//		Set lower radius with respect to the upper one.
//
{
	float $radius      = `floatSliderGrp -q -v upperRadiusSlider`;
	float $lowerRadius = `floatSliderGrp -q -v lowerRadiusSlider`;

	if( $lowerRadius > $radius ) {
		floatSliderGrp -e -v $radius lowerRadiusSlider;
	}
}


global proc artUpdateStampProfile(
	string  $profile,
	string  $artCmd
)
//
//	Description:
//		Update stamp profile icons.
//
{
	symbolCheckBox -e -v false spGaussianChBx;
	symbolCheckBox -e -v false spPolyBrushChBx;
    symbolCheckBox -e -v false spSolidChBx;
	symbolCheckBox -e -v false spRectBrushChBx;
	symbolCheckBox -e -v false artFileBrushChBx;

	switch ( $profile ) {
		case "gaussian":
			symbolCheckBox -e -v true spGaussianChBx;
			break;
		case "poly":
			symbolCheckBox -e -v true spPolyBrushChBx;
			break;
		case "solid":
			symbolCheckBox -e -v true spSolidChBx;
			break;
		case "square":
			symbolCheckBox -e -v true spRectBrushChBx;
			break;
		case "lastFile":
		case "shape":
			symbolCheckBox -e -v true artFileBrushChBx;
			break;
	}

	// Set the stamp profile. 
    string $cmd;
    $cmd = $artCmd + " -e -stampProfile \"" + $profile + "\" `currentCtx`";
    eval( $cmd );

	artUpdateLastBrushIcon( $artCmd );
}


global proc artUpdateLastBrushIcon( 
	string 	$artCmd 
)
//
//	Decription:
// 		Display a proper brush icon in the UI if one exists.
//
{
	string $cmd = $artCmd + " -q -lastStampName `currentCtx`";
	string $fileName = eval( $cmd ); 

	// If the new brush image has an icon, then replace 
    // the existing default one with the new one.
    string $names[];
	tokenize( $fileName, "\/", $names );

	if ( size($names) == 0 ) 
		return;

    string $iconDir = getenv("MAYA_LOCATION");
    if ( $iconDir != "" ) {
        if ( `about -nt` ) {
            $iconDir = $iconDir + "\\" + "brushShapes" + "\\" + "BrushIcons" + "\\";
        } else {
            $iconDir = $iconDir + "\/" + "brushShapes" + "\/" + "BrushIcons" + "\/";
        }
    }

	// Construct the icon name.
	string  $imageName = $names[size($names)-1];
	if ( $imageName != "" ) {
		string  $tmpNames[];
		tokenize( $imageName, ".", $tmpNames );

		if ( size($tmpNames) == 0 )
			return;

		// If the icon exist then use to in the symbol box.
		string $iconName = $iconDir + $tmpNames[0] + ".xpm";
		if ( `file -q -ex $iconName `) {
			symbolCheckBox -e -i $iconName  artFileBrushChBx;
		} else {
			symbolCheckBox -e -i "file.png" artFileBrushChBx;
		}
	}
}


global proc artUpdatePaintMode(
	string  $artCommand
)
//
//	Description:
//		Update the paint mode - make sure that 'z' reflection
//		is grey out in projective paint mode.
//
{
        // Update the Reflection mode
	string $cmdRef = ($artCommand + " -q -reflection " + `currentCtx` );
	if( ` eval $cmdRef` )
	{			
		radioButtonGrp -e -en true artReflectionRadBtn;		
		checkBoxGrp -e -en true artReflectionModeAboutOriginChkBox ;
	}
	else
	{
		radioButtonGrp -e -en false artReflectionRadBtn;		
		checkBoxGrp -e -en false artReflectionModeAboutOriginChkBox ;
	}

        // Update the paint mode
	string $cmdProj = ($artCommand + " -q -projective " + `currentCtx` );
	if ( `eval $cmdProj` ) {			// Screen mode
		
		// Make sure that there is no reflection in Z
		if(`radioButtonGrp -q -en3 artReflectionRadBtn`)
			radioButtonGrp -e -en3 false artReflectionRadBtn;
	}
	else  if( ` eval $cmdRef` ) {	// Tangent mode
		// Enable reflectionZ radio button if Reflection is ON & Screen Projection is OFF.
		 if(!`radioButtonGrp -q -en3 artReflectionRadBtn`)
			radioButtonGrp -e -en3 true artReflectionRadBtn;
	}

}

global proc artUpdateInvertReferenceMode(
	string  $artCommand
)
//
//	Description:
//	Grey out "Invert Refrerence Vector" if reflection Paint is OFF or scereen projection if ON.
//
{
	string $cmdRN = ($artCommand + " -q -reflection  " + `currentCtx` );
	string $cmdSP = ($artCommand + " -q -projective " + `currentCtx` );

	if( (`eval $cmdSP`) )
	{
		checkBoxGrp -e  -en false invertVectorChkBox;
		checkBoxGrp -e  -v1 0 invertVectorChkBox;
	        string $cmdIrv0 = ($artCommand + " -e -irv  false "+`currentCtx` );
	        eval $cmdIrv0;
	}
	else
	{
		if ( !`eval $cmdRN` ) {
			checkBoxGrp -e  -en false invertVectorChkBox;
			checkBoxGrp -e  -v1 0 invertVectorChkBox;			
		}
		else
		{
			checkBoxGrp -e  -en true invertVectorChkBox;
		}
	}

	string $cmdIrv = ($artCommand + " -q -irv  " + `currentCtx` );
	int $irvValue = `eval $cmdIrv`;
	$cmdIrv = ($artCommand + " -e -irv  " +$irvValue+" "+`currentCtx` );
	eval $cmdIrv;
}

global proc artUpdateTabletPressure(
	string  $artCommand
)
//
//	Description:
//		Update the pressure menu. If pressure is off then 
//		grey out the pressure mapping option menu group.
//
{
	if ( `columnLayout -exists artPressureMappingLayout` ) {
		string $tabletPresentCmd = $artCommand + " -q -tablet " + `currentCtx` ;
		
		if( `eval $tabletPresentCmd` )
		{
			columnLayout -e -enable true artStylusPressureLayout;

			string $cmd = ($artCommand + " -q -usepressure " + `currentCtx`);
			if  ( `eval $cmd` ) {   // user wants to use pressure for something 
				optionMenuGrp -e -enable true artStylusPressureOpMenu ;
			} else {
				optionMenuGrp -e -enable false artStylusPressureOpMenu ;
			}
		}
		else
		{
			columnLayout -e -enable false artStylusPressureLayout;
		}
	}
}


global proc artUpdateDisplayValues(
	string  $artCommand
)
//
//	Description:
// 		Update the display checkboxes.
//
{
	if ( `checkBoxGrp -exists artBrushFeedbackChkBox` ) {
		$cmd = ($artCommand + " -q -outline " + `currentCtx`);
		if ( `eval $cmd` ) {
			checkBoxGrp -e -en true artBrushFeedbackChkBox;
		} else {
			checkBoxGrp -e -en false artBrushFeedbackChkBox;
		}
	}
	if ( `checkBoxGrp -exists artBrushWhilePaintingChkBox` ) {
		$cmd = ($artCommand + " -q -outline " + `currentCtx`);
		if ( `eval $cmd` ) {
			checkBoxGrp -e -en true artBrushWhilePaintingChkBox;
		} else {
			checkBoxGrp -e -en false artBrushWhilePaintingChkBox;
		}
	}
	if ( `checkBoxGrp -exists artDrawTangentOutlineChkBox` ) {
		$cmd = ($artCommand + " -q -outline " + `currentCtx`);
		if ( `eval $cmd` ) {
			checkBoxGrp -e -en true artDrawTangentOutlineChkBox;
		} else {
			checkBoxGrp -e -en false artDrawTangentOutlineChkBox;
		}
	}
	/*
	if( `checkBoxGrp -ex surfaceConformedChkBox` ) {
		$cmd = ($artCommand + " -q -outline " + `currentCtx`);
		if ( `eval $cmd` ) {
			checkBoxGrp -e -en true surfaceConformedChkBox;
		} else {
			checkBoxGrp -e -en false surfaceConformedChkBox;
		}
	}
	*/
	if( `checkBoxGrp -ex surfaceConformedVtxChkBox` ) {
		$cmd = ($artCommand + " -q -outline " + `currentCtx`);
		if ( `eval $cmd` ) {
			checkBoxGrp -e -en true surfaceConformedVtxChkBox;
		} else {
			checkBoxGrp -e -v1 0 surfaceConformedVtxChkBox;
			checkBoxGrp -e -en false surfaceConformedVtxChkBox;
		}
	}
}


global proc artAttrUpdateVertexColorRangeChkBox(
	string $artCommand, int $bColorRangeEnabled
)
//
//	Description:
//		Enables/Disables min/max color range sliders
//		based on their new corresponding check box value
//
{
	// Support for color ranges
	//
	
	$cmd = ($artCommand + " -e -vertexColorRange " + $bColorRangeEnabled + " " + `currentCtx` );
	eval($cmd);

	checkBoxGrp -e -v1 $bColorRangeEnabled artVertexColorRangeChkBox;

	floatSliderGrp -e -enable $bColorRangeEnabled artVertexColorMinSlider;
	floatSliderGrp -e -enable $bColorRangeEnabled artVertexColorMaxSlider;
}


global proc artAttrUpdateVertexColorMinRangeSlider(
	string 	$artCommand, float $minRange
)
//
//	Description:
//		Min color range value has changed. Validate it and
//		and update the min/max color range sliders if necessary.
//
{
	// Support for color ranges
	$cmd = ($artCommand + " -q -vertexColorRangeUpper " + `currentCtx` );
	float $maxRange = eval ( $cmd );

	if ( $minRange > $maxRange ) {
		$msg = (uiRes("m_artisanCallback.kColorRangeMinExceedsColorRangeMax"));
		warning($msg);

		$minRange=$maxRange;
		floatSliderGrp -e -v $minRange artVertexColorMinSlider;
	}

	$cmd = ($artCommand + " -e -vertexColorRangeLower " + $minRange + " " + `currentCtx` );
	eval($cmd);

}


global proc artAttrUpdateVertexColorMaxRangeSlider(
	string 	$artCommand, float $maxRange
)
//
//	Description:
//		Max color range value has changed. Validate it and
//		and update the min/max color range sliders if necessary.
//
{
	// Support for color ranges
	//
	$cmd = ($artCommand + " -q -vertexColorRangeLower " + `currentCtx` );
	float $minRange = eval ( $cmd );

	if ( $maxRange < $minRange ) {
		$msg = (uiRes("m_artisanCallback.kColorRangeMaxBelowColorRangeMin"));
		warning($msg);

		$maxRange=$minRange;
		floatSliderGrp -e -v $maxRange artVertexColorMaxSlider;
	}

	$cmd = ($artCommand + " -e -vertexColorRangeUpper " + $maxRange + " " + `currentCtx` );
	eval($cmd);
}


global proc artAdjustMapSizeSlider(
	string $artCommand,
	string $whichSlider
)
//
//	Description:
//		When 'keepAspectRatio' is on make sure that 
//		the X and Y sliders are correctly adjusted.
//
{
	float $ratio;
	if ( eval("checkBoxGrp -q -v1 exportKeepAspectChkBox") ) {

		$ratio = eval($artCommand + " -q -exportaspectratio `currentCtx`");

		if ( $whichSlider == "xSlider" ) {
			float $valX   = eval("intSliderGrp -q -v exportMapSizeXSlider");
			float $newVal = $valX/$ratio;
			intSliderGrp -e -v $newVal exportMapSizeYSlider;
			eval($artCommand + " -e -exportfilesizey " + $newVal + " `currentCtx`");
		}
		else {
			float $valY   = eval("intSliderGrp -q -v exportMapSizeYSlider");
			float $newVal = $valY*$ratio;
			intSliderGrp -e -v $newVal exportMapSizeXSlider;
			eval($artCommand + " -e -exportfilesizex " + $newVal + " `currentCtx`");
		}
	}
}


global proc int artStampProfileCB(
    string $artCmd,
    string $fileName,
    string $fileType
)
{
	// Ask the context to load the file.
	eval($artCmd + " -e -profileShapeFile \"" + $fileName + "\" `currentCtx`");

    // Return true to close the filebrowser.
    return true;
}


global proc artStampProfileDialog(
	string	$artCommand
)
{
	// Set the working directory to MAYA_LOCATION/brushShapes
    string $shapesDir = getenv("MAYA_LOCATION");
	if ( $shapesDir != "" ) {
		if ( `about -nt` ) {
    		$shapesDir = $shapesDir + "\\" + "brushShapes";
		} else {
    		$shapesDir = $shapesDir + "\/" + "brushShapes";
		}
	}
	else {
        $shapesDir = (`workspace -q -rd ` + "sourceimages\/" );
    }

	// Save the current directory.
	global int 	  $gArtSetAttrMapWorkspace;
    if (`file -q -ex $shapesDir`) {
		// Set the workspace area to the brush directory.
        workspace -dir $shapesDir;
		$gArtSetAttrMapWorkspace = 1;
    }

	string $action = (uiRes("m_artisanCallback.kOpen"));
    string $fileCallback = "artStampProfileCB " + $artCommand + " ";
	// third parameter is "" ,that means it will use All Files as selected file filter
    fileBrowser( $fileCallback, $action, "", 0 );
}

// -------------------------------------------
// Attribute Maps stuff.
// -------------------------------------------
global proc int artImportAttrMapCB(
    string $artCommand,
    string $fileName,
    string $fileType
)
{
	// Ask the context to load the file.
    eval($artCommand + " -e -importfileload \"" + $fileName + "\" `currentCtx`");

    // Return true to close the filebrowser.
    return true;
}

global proc artImportMapDialog(
	string	$artCommand
)
{
	global int 		$gArtSetAttrMapWorkspace;
	global string 	$gArtWorkdirectory;

	// Set the proper image directory.
	string $imageDir = $gArtWorkdirectory;
	if ( "" == $imageDir ) {
		$imageDir = (`workspace -q -rd` + "sourceimages\/" );
	}

    if (`file -q -ex $imageDir`) {
		if ( 1 == $gArtSetAttrMapWorkspace ) {
        	workspace -dir $imageDir;
			$gArtSetAttrMapWorkspace = 0;
		}
    }

	string $action = (uiRes("m_artisanCallback.kImport"));
    string $callback = "artImportAttrMapCB " + $artCommand + " ";
    fileBrowser( $callback, $action, "image", 0 );

	// Set the currenrt workspace directory.
	$gArtWorkdirectory = `workspace -q -dir`;
}


global proc int artExportAttrMapCB(
    string $artCommand,
    string $fileName,
    string $fileType
)
{
	// Ask the context to load the export file.
    eval($artCommand + " -e -exportfilesave \"" + $fileName + "\" `currentCtx`");

    // Return true to close the filebrowser.
    return true;
}


global proc artExportMapDialog(
	string $artCommand
)
{
	global int 		$gArtSetAttrMapWorkspace;
	global string 	$gArtWorkdirectory;

	// Set the proper image directory.
	string $imageDir = $gArtWorkdirectory;
	if ( "" == $imageDir ) {
		$imageDir = (`workspace -q -rd` + "sourceimages\/" );
	}

	if (`file -q -ex $imageDir`) {
		if ( 1 == $gArtSetAttrMapWorkspace ) {
			workspace -dir $imageDir;
			$gArtSetAttrMapWorkspace = 0;
		}
	}

	string $action = (uiRes("m_artisanCallback.kExport"));
	string $callback = "artExportAttrMapCB " + $artCommand + " ";
	fileBrowser( $callback, $action, "map", 1 );

	// Set the currenrt workspace directory.
	$gArtWorkdirectory = `workspace -q -dir`;
}


global proc artSetAspectRatio(
	string $artCommand
)
{
	if ( eval("checkBoxGrp -q -v1 exportKeepAspectChkBox") ) {
		float  $valX  = eval("intSliderGrp -q -v exportMapSizeXSlider");
		float  $valY  = eval("intSliderGrp -q -v exportMapSizeYSlider");

		// Calculate the aspect ratio.
		float  $ratio = $valX/$valY;

		// Set the aspect ratio in artisan.
		eval($artCommand + " -e -exportaspectratio " + $ratio + " `currentCtx`");
	}
}


global proc artImportMapValue(
	string $imMapValue,
	string $artCommand
)
{
	string $alpha     = (uiRes("m_artisanCallback.kAlpha"));
	string $luminance = (uiRes("m_artisanCallback.kLuminance"));
	string $rgb       = (uiRes("m_artisanCallback.kRGB"));
	string $rgba      = (uiRes("m_artisanCallback.kRGBA"));
	string $red       = (uiRes("m_artisanCallback.kRed"));
	string $green     = (uiRes("m_artisanCallback.kGreen"));
	string $blue      = (uiRes("m_artisanCallback.kBlue"));
	string $cmd;
	if ( $imMapValue == $luminance ) {
		$cmd = $artCommand + " -e -importfilemode \"luminance\" `currentCtx`";
	} else if ( $imMapValue == $alpha ) {
		$cmd = $artCommand + " -e -importfilemode \"alpha\" `currentCtx`";
	} else if ( $imMapValue == $red  ) {
		$cmd = $artCommand + " -e -importfilemode \"red\" `currentCtx`";
	} else if ( $imMapValue == $green ) {
		$cmd = $artCommand + " -e -importfilemode \"green\" `currentCtx`";
	} else if ( $imMapValue == $blue ) {
		$cmd = ($artCommand + " -e -importfilemode \"blue\" `currentCtx`");
	} else if ( $imMapValue == $rgb ) {
		$cmd = ($artCommand + " -e -importfilemode \"rgb\" `currentCtx`");
	} else if ( $imMapValue == $rgba ) {
		$cmd = ($artCommand + " -e -importfilemode \"rgba\" `currentCtx`");
	}
	eval( $cmd );
}

global proc artExportMapValue(
	string $exMapValue,
	string $artCommand
)
{
	string $cmd;
	if ( $exMapValue == (uiRes("m_artisanCallback.kLuminance")) ) {
		$cmd = ($artCommand +" -e -exportfilemode \"luminance\" `currentCtx`");
	} else 	if ( $exMapValue == (uiRes("m_artisanCallback.kAlpha")) ) {
		$cmd = ($artCommand + " -e -exportfilemode \"alpha\" `currentCtx`");
	} else if ( $exMapValue == (uiRes("m_artisanCallback.kRGB")) ) {
		$cmd = ($artCommand + " -e -exportfilemode \"rgb\" `currentCtx`");
	} else if ( $exMapValue == (uiRes("m_artisanCallback.kRGBA")) ) {
		$cmd = ($artCommand + " -e -exportfilemode \"rgba\" `currentCtx`");
	}
	eval( $cmd );
}

// ==============================================================
// FrameLayout Callbacks. 
// ==============================================================
global proc artisanBrushCallback(
	string  $artCommand,
	string	$currTool
)
//
//  Description:
//      Callbacks for brush properties.
//
{
	floatSliderGrp -e
		-cc ($artCommand + " -e -radius #1 `currentCtx`")
		-dc ( "artSetUpperRadius " + $artCommand )
	upperRadiusSlider;

	floatSliderGrp -e
		-cc ($artCommand + " -e -lowerradius #1 `currentCtx`")
		-dc ( "artSetLowerRadius " + $artCommand )
	lowerRadiusSlider;

	if ( $currTool != "artSelect" ) {
		floatSliderGrp -e
			-cc ($artCommand + " -e -opacity #1 `currentCtx`")
		opacitySlider;

		if ( isOpacityAccumulationRequired() ) {
			checkBoxGrp -e
				-cc ($artCommand + " -e -accopacity #1 `currentCtx`")
			accOpacityChkBox ;
		}

		if ( `checkBoxGrp -exists artDrawTangentOutlineChkBox` ) {
			checkBoxGrp -e
				-cc ($artCommand + " -e -tangentOutline #1 `currentCtx`")
			artDrawTangentOutlineChkBox;
		}

		if ( isSurfaceConformedBrushAvailable() ) {
			/*
			checkBoxGrp -e
				-cc ($artCommand + " -e -surfaceConformedBrush #1 `currentCtx`")
			surfaceConformedChkBox;
			*/
			checkBoxGrp -e
				-cc ($artCommand + " -e -surfaceConformedBrushVertices #1 `currentCtx`")
			surfaceConformedVtxChkBox;
		}
	}

	symbolCheckBox -e
		-cc ("artUpdateStampProfile gaussian " + $artCommand )
	spGaussianChBx;

	symbolCheckBox -e
		-cc ("artUpdateStampProfile poly " + $artCommand )
	spPolyBrushChBx;

	symbolCheckBox -e
		-cc ("artUpdateStampProfile solid " + $artCommand )
	spSolidChBx;

	symbolCheckBox -e
		-cc ("artUpdateStampProfile square " + $artCommand )
	spRectBrushChBx;

	symbolCheckBox -e
		-cc ("artUpdateStampProfile lastFile " + $artCommand )
	artFileBrushChBx;

	button -e
		-c ( "artStampProfileDialog \"" + $artCommand + "\"" + "; artUpdateStampProfile shape " + $artCommand )
	spShapeButton;

	// Brush Alignment.
	if(`checkBoxGrp -exists artBrushAlignmentChkBox`)
	{
	    checkBoxGrp -e
		    -cc ( $artCommand + " -e -brushalignment #1 `currentCtx`")
	    artBrushAlignmentChkBox;
	}
}


global proc artisanStrokeCallback( 
	string 	$artCommand,
	string	$currTool
)
//
//  Description:
//		Stroke framelayout callbacks.
//
{
	// Paint Mode.
	checkBoxGrp -e
		-cc ( $artCommand + " -e -projective  #1 `currentCtx`")
	artProjectionModeChkBox;
	
	// Reflection Mode.
	checkBoxGrp -e
		-cc ( $artCommand + " -e -reflection  #1 `currentCtx`")
	artReflectionModeChkBox;
	artUpdatePaintMode( $artCommand );
	
	// Reflection Mode.
	checkBoxGrp -e
		-cc ( $artCommand + " -e -reflectionaboutorigin  #1 `currentCtx`")
	artReflectionModeAboutOriginChkBox;
	artUpdatePaintMode( $artCommand );	
	
	//Reflection Axis
	radioButtonGrp -e
		-on1 ($artCommand + " -e -ra \"x\" `currentCtx`")
		-on2 ($artCommand + " -e -ra \"y\" `currentCtx`")
		-on3 ($artCommand + " -e -ra \"z\" `currentCtx`")
	artReflectionRadBtn;
	
	// Invert Reference vector
	if ( $currTool == "artPutty" ) {
		checkBoxGrp -e
		-cc ( $artCommand + " -e -irv  #1 `currentCtx`")
	invertVectorChkBox;
	artUpdateInvertReferenceMode ($artCommand);
	}
	
	// Stamp Quality Sliders.
	floatSliderGrp -e
		-cc  ($artCommand + " -e -stampSpacing #1 `currentCtx`")
	artStampSpacingSlider;

	floatSliderGrp -e
		-cc  ($artCommand + " -e -stampDepth #1 `currentCtx`")
	artStampDepthSlider;

	// Stroke commands for Paint Selection tool.
	if ( $currTool == "artSelect" || $currTool == "artPutty" ) {
		textFieldGrp -e
			-cc ($artCommand+ " -e -bsc \"#1\" `currentCtx`")
		artPreStrokeTextField;

		textFieldGrp -e
			-cc ($artCommand+ " -e -asc \"#1\" `currentCtx`")
		artPostStrokeTextField;
	}

	// Stroke commands for Attribute Paint tool.
	if ( $currTool == "artAttr" ) {
		checkBoxGrp -e
			-cc ( $artCommand + " -e -interactiveUpdate  #1 `currentCtx`")
		artAttrInteractiveUpdate;
	}
}

global proc artPressureValue(string $pressureValue,string $artCommand)
{
    string $opacity = (uiRes("m_artisanCallback.kOpacity"));
    string $radius  = (uiRes("m_artisanCallback.kRadius"));
    string $both    = (uiRes("m_artisanCallback.kBoth"));
    
    string $cmd;
	if ( $pressureValue == $opacity ) {
		$cmd = ($artCommand + " -e -mappressure \"Opacity\" `currentCtx`");
	} else 	if ( $pressureValue == $radius ) {
		$cmd = ($artCommand + " -e -mappressure \"Radius\" `currentCtx`");
	} else if ( $pressureValue == $both ) {
		$cmd = ($artCommand + " -e -mappressure \"Both\" `currentCtx`");
	} 
	eval( $cmd );
}

global proc artisanPressureCallback( 
	string 	$artCommand,
	string	$currTool
)
//
//  Description:
//		Stylus pressure framelayout callbacks.
//
{
	// Tablet Pressure.
	checkBoxGrp -e
		-cc1 ( $artCommand + " -e -usepressure #1 `currentCtx`")
	artStylusPressureChkBox;

	artUpdateTabletPressure( $artCommand  );

	optionMenuGrp -e
		-cc ( "artPressureValue \"#1\" " + $artCommand )
	artStylusPressureOpMenu;
}


global proc artExportFileTypeValue(string $fileTypeValue,string $artCommand)
{
    string $tiff  = (uiRes("m_artisanCallback.kTIFF"));
    string $sgi   = (uiRes("m_artisanCallback.kSGI"));
    string $iff   = (uiRes("m_artisanCallback.kIFF"));
    string $jpeg  = (uiRes("m_artisanCallback.kJPEG"));
    string $targa = (uiRes("m_artisanCallback.kTarga"));
    string $windowsBitmap  = (uiRes("m_artisanCallback.kWindowsBitmap"));
    string $quickTimeImage = (uiRes("m_artisanCallback.kQuickTimeImage"));
    string $quickDraw = (uiRes("m_artisanCallback.kQuickDraw"));
    string $photoshop = (uiRes("m_artisanCallback.kPhotoshop"));
    string $png       = (uiRes("m_artisanCallback.kPNG"));
    string $macPaint  = (uiRes("m_artisanCallback.kMacPaint"));
    
    string $gif       = (uiRes("m_artisanCallback.kGIF"));
    string $softImage = (uiRes("m_artisanCallback.kSoftImage"));
    string $rla       = (uiRes("m_artisanCallback.kRLA"));
    string $alias     = (uiRes("m_artisanCallback.kAlias"));
    string $eps       = (uiRes("m_artisanCallback.kEPS"));
    
    string $cmd;
    if ( $fileTypeValue == $tiff ) {
        $cmd = ($artCommand + " -e -exportfiletype \"TIFF\" `currentCtx`");
    }
    else if ( $fileTypeValue == $sgi ) {
        $cmd = ($artCommand + " -e -exportfiletype \"SGI\" `currentCtx`");
    }
    else if ( $fileTypeValue == $iff ) {
        $cmd = ($artCommand + " -e -exportfiletype \"IFF\" `currentCtx`");
    }
    else if ( $fileTypeValue == $jpeg ) {
        $cmd = ($artCommand + " -e -exportfiletype \"JPEG\" `currentCtx`");
    }
    else if ( $fileTypeValue == $targa ) {
        $cmd = ($artCommand + " -e -exportfiletype \"Targa\" `currentCtx`");
    }
    else if ( $fileTypeValue == $windowsBitmap ) {
        $cmd = ($artCommand + " -e -exportfiletype \"WindowsBitmap\" `currentCtx`");
    }
    else if ( $fileTypeValue == $quickTimeImage ) {
        $cmd = ($artCommand + " -e -exportfiletype \"QuickTime Image\" `currentCtx`");
    }
    else if ( $fileTypeValue == $quickDraw ) {
        $cmd = ($artCommand + " -e -exportfiletype \"QuickDraw\" `currentCtx`");
    }
    else if ( $fileTypeValue == $photoshop ) {
        $cmd = ($artCommand + " -e -exportfiletype \"Photoshop\" `currentCtx`");
    }
    else if ( $fileTypeValue == $png ) {
        $cmd = ($artCommand + " -e -exportfiletype \"PNG\" `currentCtx`");
    }
    else if ( $fileTypeValue == $macPaint ) {
        $cmd = ($artCommand + " -e -exportfiletype \"MacPaint\" `currentCtx`");
    }
    else if ( $fileTypeValue == $gif ) {
        $cmd = ($artCommand + " -e -exportfiletype \"GIF\" `currentCtx`");
    }
    else if ( $fileTypeValue == $softImage ) {
        $cmd = ($artCommand + " -e -exportfiletype \"SoftImage\" `currentCtx`");
    }
    else if ( $fileTypeValue == $rla ) {
        $cmd = ($artCommand + " -e -exportfiletype \"RLA\" `currentCtx`");
    }
    else if ( $fileTypeValue == $alias ) {
        $cmd = ($artCommand + " -e -exportfiletype \"Alias\" `currentCtx`");
    }
    else if ( $fileTypeValue == $eps ) {
        $cmd = ($artCommand + " -e -exportfiletype \"EPS\" `currentCtx`");
    }
    eval( $cmd );
}

global proc artisanAttrMapCallback( 
	string 	$artCommand,
	string	$currTool
)
//
//  Description:
//		Import/Export of attribute maps callbacks.
//
{
	source "artisanToolConfigurations.mel" ;

	//  Import Map frameLayout
	button -e
		-c ( "artImportMapDialog \"" + $artCommand + "\"" )
	importMapBrowseButton;

	checkBoxGrp -e
		-cc1 ($artCommand + " -e -importreassign #1 `currentCtx`" )
	reassignMapsChkBox;

	string $importMapMenu = $currTool + "importMapValueMenu";
	optionMenuGrp -e 
		-cc ( "artImportMapValue \"#1\" " + $artCommand )
	$importMapMenu;
	
	if ( $currTool == "artSelect" ) {
		floatSliderGrp -e
			-cc ($artCommand + " -e -importthreshold #1 `currentCtx`" )
		importThresholdSlider;
	}

	//  Export Map frameLayout
	if ( isExportPanelUsed() )
	{
		button -e
			-c ( "artExportMapDialog \"" + $artCommand + "\"" )
		exportMapBrowseButton;

		string $exportMapMenu = $currTool + "exportMapValueMenu";
		optionMenuGrp -e 
			-cc ( "artExportMapValue \"#1\" " + $artCommand )
		$exportMapMenu;
	
		intSliderGrp -e
			-cc ($artCommand + " -e -exportfilesizex #1 `currentCtx`; artAdjustMapSizeSlider " + $artCommand + " " + "xSlider")
		exportMapSizeXSlider;

		intSliderGrp -e
			-cc ($artCommand + " -e -exportfilesizey #1 `currentCtx`; artAdjustMapSizeSlider " + $artCommand + " " + "ySlider")
		exportMapSizeYSlider;

		checkBoxGrp -e
			-cc1 ("artSetAspectRatio " + $artCommand )
		exportKeepAspectChkBox;

		optionMenuGrp -e
			-cc ( "artExportFileTypeValue \"#1\" " + $artCommand )
		exportImageFormat;
	}
}


global proc artisanDisplayCallback( 
	string 	$artCommand,
	string	$currTool
)
//
//  Description:
//		 Callbacks for Artisan display options.
//
{
	source "artisanNamedCommandSetup.mel" ;

    checkBoxGrp -e
		-cc ( $artCommand + " -e -outline #1 `currentCtx`")
	artDrawOutlineChkBox;
	artUpdateDisplayValues( $artCommand );

	checkBoxGrp -e
		-cc ( $artCommand + " -e -outwhilepaint #1 `currentCtx`")
	artBrushWhilePaintingChkBox;

	checkBoxGrp -e
		-cc ( $artCommand + " -e -brushfeedback #1 `currentCtx`")
	artBrushFeedbackChkBox;

	checkBoxGrp -e
		-cc ( $artCommand + " -e -showactive #1 `currentCtx`")
	artShowActiveLinesChkBox;

	if( isArtColorPerVertexCtx() )
	{
		checkBoxGrp -e
			-cc1 ( "toggleAutoShowColorPerVertex")
			artAutoShowColorChkBox;

		checkBoxGrp -e
			-cc1 ( "artAttrUpdateVertexColorRangeChkBox " + $artCommand + " #1")
			artVertexColorRangeChkBox;

		floatSliderGrp -e
			-cc ( "artAttrUpdateVertexColorMinRangeSlider " + $artCommand + " #1")
			-dc ( "artAttrUpdateVertexColorMinRangeSlider " + $artCommand + " #1")
			artVertexColorMinSlider;

		floatSliderGrp -e
			-cc ( "artAttrUpdateVertexColorMaxRangeSlider " + $artCommand + " #1")
			-dc ( "artAttrUpdateVertexColorMaxRangeSlider " + $artCommand + " #1")
			artVertexColorMaxSlider;
	}
	// Support for color feedback.
	else if ( isArtColorFeedbackCtx() ) {
		checkBoxGrp -e
			-cc1 ($artCommand + " -e -colorfeedback #1 `currentCtx`")
		artColorFeedbackChkBox;
		
		if( isArtSkinCtx() ) {
		    checkBoxGrp -e
			    -cc1 ($artCommand + " -e -colorfeedbackOverride #1 `currentCtx`")
		    artMultiColorFeedbackChkBox;    
		    
		    checkBoxGrp -e
			    -cc1 ($artCommand + " -e -xrayJoints #1 `currentCtx`")
		    artXrayJointsChkBox;    
		}

		floatSliderGrp -e
			-cc ($artCommand + " -e -colorrangelower #1 `currentCtx`")
		artColorFeedbackMinSlider;

		floatSliderGrp -e
			-cc ($artCommand + " -e -colorrangeupper #1 `currentCtx`")
		artColorFeedbackMaxSlider;
	}
	else if ( $currTool == "artSetPaint" )
	{
		checkBoxGrp -e
			-cc1 ($artCommand + " -e -setcolorfeedback #1 `currentCtx`")
		artColorFeedbackChkBox;

		checkBoxGrp -e
			-cc1 ($artCommand + " -e -setdisplaycvs #1 `currentCtx`")
		artDisplayActiveCVsChkBox;
	}
}
