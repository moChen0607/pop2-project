// Copyright (C) 1997-2014 Autodesk, Inc., and/or its licensors.
// All rights reserved.
//
// The coded instructions, statements, computer programs, and/or related
// material (collectively the "Data") in these files contain unpublished
// information proprietary to Autodesk, Inc. ("Autodesk") and/or its licensors,
// which is protected by U.S. and Canadian federal copyright law and by
// international treaties.
//
// The Data is provided for use exclusively by You. You have the right to use,
// modify, and incorporate this Data into other products for purposes authorized 
// by the Autodesk software license agreement, without fee.
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND. AUTODESK
// DOES NOT MAKE AND HEREBY DISCLAIMS ANY EXPRESS OR IMPLIED WARRANTIES
// INCLUDING, BUT NOT LIMITED TO, THE WARRANTIES OF NON-INFRINGEMENT,
// MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE, OR ARISING FROM A COURSE 
// OF DEALING, USAGE, OR TRADE PRACTICE. IN NO EVENT WILL AUTODESK AND/OR ITS
// LICENSORS BE LIABLE FOR ANY LOST REVENUES, DATA, OR PROFITS, OR SPECIAL,
// DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES, EVEN IF AUTODESK AND/OR ITS
// LICENSORS HAS BEEN ADVISED OF THE POSSIBILITY OR PROBABILITY OF SUCH DAMAGES.

//
//
//  Creation Date:  Nov, 1999
//
//  Procedure Name:
//      doRemoveClipArgList
//
//  Description:
//      Remove a clip from the timeline or delete the clip altogether.
//
//  Input Arguments:
//  $version: The version of this option box.  Used to know how to 
//  interpret the $args array.
//  
//  $args
//  Version 1
//  [0]     $name :  name of the clip window
//  [1]       $op :  type of removal operation:
//                   0 = remove from timeline
//                   1 = delete from library
//
global proc
doRemoveClipArgList( string $version, string $args[] )
{
    string $clipWnd        = $args[0];
    int    $op             = $args[1];

    string $selClips[]  = getSelectedClips("allowAudioCache");
    string $selBlends[] = getSelectedBlends();
    string $selAudio[]  = `ls -sl -type audio -type cacheFile`;
    // Terminate the script if there are no nodes to process
    if ( ( size( $selClips  ) == 0 ) && 
         ( size( $selBlends ) == 0 ) && 
         ( size( $selAudio  ) == 0 ) )
        error( (uiRes("m_doRemoveClipArgList.kSelectTheClipsErr")) );

    // delete the blends first since deleting the clips will sometimes
    // delete associated blends
    //
    for ($blend in $selBlends)
        delete $blend;

    string $removedClips[];
    int $removeCount = 0;

    for ($clip in $selClips)
    {
        // If a clipGhostShape has been added for this particular clip, delete it.
        string $clipGhostShape = getGhostShapeForClip( $clip );
        if ( size( $clipGhostShape ) )
            delete $clipGhostShape ;

        string $sch = getClipScheduler($clip);
        int $clipIndex = getClipIndex($clip, $sch);

        if ($op == 0) {
            // remove from timeline
            //
            string $cmdString = ("clipSchedule -rm -ci "+$clipIndex+" "+$sch);
            evalEcho $cmdString;

        } else {
            string $character[] = `listConnections -type character $sch`;
            string $clipName = `clipSchedule -ci $clipIndex -q -n $sch`;
            if (size($clipName) && size($character)) {
                int $removeIt = 1;
                for ($rclip in $removedClips) {
                    if ($rclip == $clipName) {
                        $removeIt = 0;
                        break;
                    }
                }
                if ($removeIt) {
                    string $cmdString = ("clip -rm -name "+$clipName+" "+$character[0]);
                    evalEcho $cmdString;
                    $removedClips[$removeCount] = $clipName;
                    $removeCount++;
                }
            }
        }

        // Ensure that deletion of clips does not mess up ordering if
        // connections to/from clipToGhose node.
        ghostReorderConnections( $sch );

    }

    // Delete anything else we can select in Trax
    for ($audio in $selAudio)
        delete $audio;
}
