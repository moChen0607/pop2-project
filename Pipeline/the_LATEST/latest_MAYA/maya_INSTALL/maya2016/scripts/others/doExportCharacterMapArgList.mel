// Copyright (C) 1997-2014 Autodesk, Inc., and/or its licensors.
// All rights reserved.
//
// The coded instructions, statements, computer programs, and/or related
// material (collectively the "Data") in these files contain unpublished
// information proprietary to Autodesk, Inc. ("Autodesk") and/or its licensors,
// which is protected by U.S. and Canadian federal copyright law and by
// international treaties.
//
// The Data is provided for use exclusively by You. You have the right to use,
// modify, and incorporate this Data into other products for purposes authorized 
// by the Autodesk software license agreement, without fee.
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND. AUTODESK
// DOES NOT MAKE AND HEREBY DISCLAIMS ANY EXPRESS OR IMPLIED WARRANTIES
// INCLUDING, BUT NOT LIMITED TO, THE WARRANTIES OF NON-INFRINGEMENT,
// MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE, OR ARISING FROM A COURSE 
// OF DEALING, USAGE, OR TRADE PRACTICE. IN NO EVENT WILL AUTODESK AND/OR ITS
// LICENSORS BE LIABLE FOR ANY LOST REVENUES, DATA, OR PROFITS, OR SPECIAL,
// DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES, EVEN IF AUTODESK AND/OR ITS
// LICENSORS HAS BEEN ADVISED OF THE POSSIBILITY OR PROBABILITY OF SUCH DAMAGES.

//
//
//  Creation Date:  Feb, 2000
//
//	Procedure Name:
//		doExportCharacterMapArgList
//
//	Description:
//		This mel script is used to generate a mel script that contains a mapping 
//		between the currently selected characters. The user may then edit the mel
//		script to control the mapping, and execute the mel script to put the
//		mapping into place on the character.	
//
//	Input Arguments:
//	$version: The version of this option box.  Used to know how to 
//	interpret the $args array.
//  
//	$args
//	Version 1
//
//
global int $gCurrExportCharacterDepth = 0;
global string $gCharacterMapMethod = "";

proc printHeader(string $fileName, int $fileId, string $ch1, string $ch2)
{
	string $buff[];
	tokenize($fileName,"/",$buff);
	string $fn = $buff[size($buff)-1];
	tokenize($fn,"\\",$buff);
	$fn = $buff[size($buff)-1];	
	tokenize($fn,".",$buff);
	$fn = $buff[0];
	
	fprint($fileId,"// Exported character map .mel file: "+$fn+"\n// \n");
	fprint($fileId,"// Instructions for editing attribute mapping:\n//\n");
	fprint($fileId,"//      1. Find the array $currMap below. The left column contains all\n");
	fprint($fileId,"//         the attributes in "+$ch1+" and the right column contains all\n");
	fprint($fileId,"//         the attributes in "+$ch2+". Maya maps each pair of attributes \n");
	fprint($fileId,"//         on the same row.\n");
	fprint($fileId,"//      2. Edit each row so that the attribute of "+$ch1+" in the left\n");
	fprint($fileId,"//         column is followed by the appropriate attribute of "+$ch2+"\n");
	fprint($fileId,"//         in the right column.\n");	
	fprint($fileId,"//      3. If you see a row where one column contains UNMAPPED_ATTR, \n");
	fprint($fileId,"//         the adjacent attribute has no attribute mapped to it.\n");
	fprint($fileId,"//         This indicates that one character has more attributes than the \n");
	fprint($fileId,"//         other. If you want to map an unmapped attribute, replace \n");
	fprint($fileId,"//         UNMAPPED_ATTR with the desired attribute name. Unmap one of \n");
	fprint($fileId,"//         the previously mapped attributes to prevent double mapping \n");
	fprint($fileId,"//        of the same attribute.\n");
	fprint($fileId,"//      4. Source and execute this MEL script to complete the mapping.\n");
	fprint($fileId,"//      5. Delete the original pasted clip that had the bad mapping.\n");
	fprint($fileId,"//      6. Copy and paste the clip as you did before, except in \n");
	fprint($fileId,"//         the Paste options window, select By Current Map as the Paste Method.\n");
	fprint($fileId,"//\n\n");

	fprint($fileId,"global proc "+$fn+"\(\)\n{\n");
}

proc printRemoveOldMap(int $fileId, string $ch1, string $ch2)
{
	fprint($fileId,"\t// Delete the old map if there is one.\n\t//\n");
	fprint($fileId,"\tstring $oldMap = `characterMap -q "+$ch1+" "+$ch2+"`;\n");
	fprint($fileId,"\tif ($oldMap != \"\") {\n");
	fprint($fileId,"\t\tdelete $oldMap;\n\t}\n\n");
}

proc printSubcharacters(int $fileId, string $subCharacters1[], string $subCharacters2[])
{
	global int $gCurrExportCharacterDepth;
	int $s1 = size($subCharacters1);
	int $s2 = size($subCharacters2);
	int $smax = $s1;
	int $smin = $s2;	
	if ($s2 > $s1) { $smax = $s2; $smin = $s1; }
	if (0 == $smax) {
		return;
	}

	int $ii;
	for ($ii = 0; $ii < $smax; $ii++) {
		$gCurrExportCharacterDepth += 1;
		if ($ii >= $s1) {
			printCharacterArrays($fileId,$subCharacters2[$ii],"");
		} else if ($ii >= $s2) {
			printCharacterArrays($fileId,$subCharacters1[$ii],"");
		} else {
			printCharacterArrays($fileId,$subCharacters1[$ii],$subCharacters2[$ii]);
		}
	}
}

global proc printCharacterArrays(int $fileId,string $ch1, string $ch2)
//
//	Description:
//		Print out the members of the 2 characters in a format that won't be
//		too difficult to edit if you want to change the mapping between members.
//
{
	global string $gCharacterMapMethod;
	global int $gCurrExportCharacterDepth;

	string $mapMethod = $gCharacterMapMethod;
	int $characterDepth = $gCurrExportCharacterDepth;
	
	// Get the members of character1 and character2
	//
	string $attrsToMapCharacter1[];
	string $attrsToMapCharacter2[];
	string $extraAttrsCharacter1[];
	string $extraAttrsCharacter2[];	
	string $membersOfCharacter1[] = (`character -q $ch1`);;
	string $membersOfCharacter2[];
	if ($ch2 != "") {
		$membersOfCharacter2 = (`character -q $ch2`);		
		// A value of "" for character2 indicates that one character had more
		// subcharacters than the other character and we list all UNMAPPED_ATTRS
		// for those member values.
		//
		// Sort the members according to the map mathod requested
		//
		if ($mapMethod == "currentMap") {
			// current map
			//
			string $mapNode = `characterMap -q $ch1 $ch2`;
			if ("" != $mapNode) {
				string $currentMap[] = `characterMap -q -ma $ch1 $ch2`;
				int $mm;
				int $count = 0;
				for ($mm = 0; $mm < size($currentMap); $mm+=2, $count++) {
					string $p1[] = `listConnections -d 1 -s 0 -p true $currentMap[$mm]`;
					string $p2[] = `listConnections -d 1 -s 0 -p true $currentMap[$mm+1]`;
					$attrsToMapCharacter1[$count] = $p1[0];
					$attrsToMapCharacter2[$count] = $p2[0];
				}
			} else {
				if ($characterDepth == 0) {
					error( (uiRes("m_doExportCharacterMapArgList.kNoCurrentMapErr")) );
					return;
				}
			}
		} else {

			string $potentialMap[] = `characterMap -mm $mapMethod -q -pm $ch1 $ch2`;
			int $ii;
			int $count = 0;
			for ($ii = 0; $ii < size($potentialMap); $ii+=2) {
				$attrsToMapCharacter1[$count] = $potentialMap[$ii];
				$attrsToMapCharacter2[$count] = $potentialMap[$ii+1];
				$count++;
			}
		}
	}

	string $subCharacters1[];
	string $subCharacters2[];
	string $attrs1[];
	string $attrs2[];	

	// separate character1 into attrs and subcharacters
	//
	for ($mem in $membersOfCharacter1) {
		if (size(`ls -type character $mem`)) {
			// found a subcharacter
			//
			$subCharacters1[size($subCharacters1)] = $mem;
		} else {
			int $found = 0;
			for ($at in $attrsToMapCharacter1) {
				if ($at == $mem) {
					$found = 1;
					break;
				}
			}
			if (! $found) {
				$extraAttrsCharacter1[size($extraAttrsCharacter1)] = $mem;
			}
		}
	}

	// separate character2 into attrs and subcharacters
	//
	for ($mem in $membersOfCharacter2) {
		if (size(`ls -type character $mem`)) {
			// found a subcharacter
			//
			$subCharacters2[size($subCharacters2)] = $mem;
		} else {
			int $found = 0;
			for ($at in $attrsToMapCharacter2) {
				if ($at == $mem) {
					$found = 1;
					break;
				}
			}
			if (! $found) {
				$extraAttrsCharacter2[size($extraAttrsCharacter2)] = $mem;
			}
		}
	}

	if (0 == $characterDepth) {
		// print the mapping for the current characters
		//
		fprint($fileId,("\t// Rearrange the string below to modify the mapping.\n"));
		fprint($fileId,("\t// Left column = "+$ch1+" attributes\n"));
		fprint($fileId,("\t// Right column = "+$ch2+" attributes\n\t//\n"));			   
		fprint($fileId,("\tstring $currMap = \"\\\n"));
	}
	
	if (size($attrsToMapCharacter1) == 0 &&
		size($extraAttrsCharacter1) == 0 &&
		size($extraAttrsCharacter2) == 0) {
		printSubcharacters($fileId, $subCharacters1, $subCharacters2);
		return;
	}

	int $ii;
	for ($ii = 0; $ii < size($attrsToMapCharacter1); $ii++) {
		fprint($fileId,("\t\t"+$attrsToMapCharacter1[$ii]+"\t\t\t"+$attrsToMapCharacter2[$ii]+"\t\t\\\n"));
	}

	for ($ii = 0; $ii < size($extraAttrsCharacter1); $ii++) {
		fprint($fileId,("\t\t"+$extraAttrsCharacter1[$ii]+"\t\t\tUNMAPPED_ATTR\t\t\\\n"));			
	}

	for ($ii = 0; $ii < size($extraAttrsCharacter2); $ii++) {
		fprint($fileId,("\t\tUNMAPPED_ATTR\t\t\t"+$extraAttrsCharacter2[$ii]+"\t\t\\\n"));			
	}

	// print mapping for subcharacters
	//
	printSubcharacters($fileId, $subCharacters1, $subCharacters2);
	
	if (0 != $characterDepth) {
		return; 
	}
	
	fprint($fileId,("\t\";\n\n"));
		   
	fprint($fileId,"\n\n//================================================================\n");
	fprint($fileId,"//===        DO NOT MODIFY THE SCRIPT BELOW THIS LINE          ===\n");
	fprint($fileId,"//================================================================\n");	

	printRemoveOldMap($fileId,$ch1,$ch2);

	fprint($fileId,"\tstring $buffer[];\n");
	fprint($fileId,"\ttokenize($currMap,$buffer);\n");
	fprint($fileId,"\tint $sb = size($buffer);\n");
	fprint($fileId,"\tfor ($ii = 0; $ii < $sb; $ii += 2) {\n");
	fprint($fileId,"\t\tif ($buffer[$ii] == \"UNMAPPED_ATTR\" || ");
	fprint($fileId,"$buffer[$ii+1] == \"UNMAPPED_ATTR\") { continue; }\n");
	fprint($fileId,"\t\tstring $cmdString = \"characterMap\";\n");
	fprint($fileId,"\t\t$cmdString += (\" -mapAttr \"+$buffer[$ii]+\" \"+$buffer[$ii+1]);\n");
	fprint($fileId,("\t\t$cmdString += (\" "+$ch1+" "+$ch2+";\");\n"));
	fprint($fileId,"\t\tevalEcho($cmdString);\n");
	fprint($fileId,"\t}\n");
}

proc printFileEnd(int $fileId)
{
	fprint($fileId,"\n}\n");
}

global proc int
exportCharacterMap(string $fileName, string $fileType)
//
//	Description:
//		This mel script is used to generate a mel script that contains a mapping 
//		between the currently selected characters. The user may then edit the mel
//		script to control the mapping, and execute the mel script to put the
//		mapping into place on the character.	
//
{
	global int $gCurrExportCharacterDepth;
	global string $gCharacterMapMethod;
	$gCurrExportCharacterDepth = 0;
	
	if ($fileName == "") {
		error( (uiRes("m_doExportCharacterMapArgList.kNoFileNameErr")) );
		return 0;
	}

	int $ii;
	string $selCharacters[] = getCharactersForAction();

	if (2 != size($selCharacters)) {	
		error( (uiRes("m_doExportCharacterMapArgList.kSelectTwoCharsErr")) );
		return 0;
	}

	if ($gCharacterMapMethod == "currentMap") {
		string $mapNode = `characterMap -q $selCharacters[0] $selCharacters[1]`;
		if ("" == $mapNode) {
			error( uiRes("m_doExportCharacterMapArgList.kNoCurrentMapErr") );
			return 0;
		}
	}
	
	$fileId = fopen( $fileName, "w" );
	if ($fileId == 0) {
	    string $errMsg = (uiRes("m_doExportCharacterMapArgList.kUnableToOpenFileErr"));
	    $errMsg = `format -s $fileName $errMsg`;
		error($errMsg);
		return 0;
	}

	printHeader($fileName,$fileId,$selCharacters[0],$selCharacters[1]);
	printCharacterArrays($fileId,$selCharacters[0],$selCharacters[1]);
	printFileEnd($fileId);
	
	if (catch(`fclose $fileId`)) {
		string $errMsg = (uiRes("m_doExportCharacterMapArgList.kUnableToCloseFileErr"));
	    $errMsg = `format -s $fileName $errMsg`;
		error($errMsg);
		return 0;
	}

    string $printMsg = (uiRes("m_doExportCharacterMapArgList.kWrote"));
    $printMsg = `format -s $fileName $printMsg`;
	print($printMsg);
	return 1;
}

global proc
doExportCharacterMapArgList( string $version, string $args[] )
{
	global string $gCharacterMapMethod;
	if ($args[0] == "") {
		$gCharacterMapMethod = "byAttrName";
	} else {
		$gCharacterMapMethod = $args[0];
	}
	
	if (`about -evalVersion`) {
		// Because fopen and fprint are disabled in PLE, exporting of
		// character maps is not supported.
		//
		string $cancel = (uiRes("m_doExportCharacterMapArgList.kCancel"));
		confirmDialog
			-message (uiRes("m_doExportCharacterMapArgList.kExportingofCharacterMapsMessage"))
			-button $cancel -defaultButton $cancel;
		return;
	}
	
	// bring up the file browser dialog so that they can choose a file name
	//
	string $writeMap = (uiRes("m_doExportCharacterMapArgList.kWriteMap"));
	fileBrowser("exportCharacterMap",$writeMap,"mel",1);
}
