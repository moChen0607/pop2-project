// Copyright (C) 1997-2014 Autodesk, Inc., and/or its licensors.
// All rights reserved.
//
// The coded instructions, statements, computer programs, and/or related
// material (collectively the "Data") in these files contain unpublished
// information proprietary to Autodesk, Inc. ("Autodesk") and/or its licensors,
// which is protected by U.S. and Canadian federal copyright law and by
// international treaties.
//
// The Data is provided for use exclusively by You. You have the right to use,
// modify, and incorporate this Data into other products for purposes authorized 
// by the Autodesk software license agreement, without fee.
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND. AUTODESK
// DOES NOT MAKE AND HEREBY DISCLAIMS ANY EXPRESS OR IMPLIED WARRANTIES
// INCLUDING, BUT NOT LIMITED TO, THE WARRANTIES OF NON-INFRINGEMENT,
// MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE, OR ARISING FROM A COURSE 
// OF DEALING, USAGE, OR TRADE PRACTICE. IN NO EVENT WILL AUTODESK AND/OR ITS
// LICENSORS BE LIABLE FOR ANY LOST REVENUES, DATA, OR PROFITS, OR SPECIAL,
// DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES, EVEN IF AUTODESK AND/OR ITS
// LICENSORS HAS BEEN ADVISED OF THE POSSIBILITY OR PROBABILITY OF SUCH DAMAGES.

//
//
//  Creation Date:  Mar 14, 1997
//
//  Description:
//      This script runs rebuild curve on the selection list.
//

proc int checkForBezier( string $objs[] )
{
	int $foundBezier = 0;
	int $i;
	for( $i = 0; $i < size($objs); $i++ )
	{
		string $shapes[] = `listRelatives -pa -s $objs[$i]`;
		int $j;
		for( $j = 0; $j < size($shapes); $j++ )
		{
			if( `objectType $shapes[$j]` == "bezierCurve" )
			{
				$foundBezier = 1;
				break;
			}
		}
		if( $foundBezier )
		{
			break;
		}
	}
	return $foundBezier;
}

global proc performRebuildCurveSet( int $doHistory, int $replaceOriginal,
									int $rebuildType, float $globalTol,
									int $crvNumSpans, int $crvDegree,
									int $endKnots,
									int $keepParmRange, int $keepControlPoints,
									int $keepEndPts, int $keepTan,
									int $crvUseGlobalTol, float $crvLocalTol)
{
	// Get a list of each type of acceptable object type - 
	// curves, and curves-on-surface.
	//
	global int $gSelectNurbsCurvesBit;
	global int $gSelectCurvesOnSurfacesBit;
	string $curveList[] = `filterExpand -ex true -sm $gSelectNurbsCurvesBit`;
	string $cosList[] = `filterExpand -ex true -sm $gSelectCurvesOnSurfacesBit`;

	int $i;

	int $curveBezier = checkForBezier( $curveList );
	int $cosBezier = checkForBezier( $cosList );
	if( $curveBezier || $cosBezier )
	{
		error (uiRes("m_performRebuildCurveSet.kRebuildCurveBezierSelection"));
		return;
	}

	if( $rebuildType == 2 ) {
		if( (size($curveList) + size($cosList)) < 2 ) {
			error (uiRes("m_performRebuildCurveSet.kRebuildCurveInvalSelection")) ;
			return;
		}
	}
	else {
		if( (size($curveList) + size($cosList)) < 1 ) {
			error (uiRes("m_performRebuildCurveSet.kRebuildCurveImproperSelection"));
			return;
		}
	}

	// Execute rebuildCurve on all active curves.
	//
	$cmd = "rebuildCurve" + " -ch " + $doHistory + 
		   " -rpo " + $replaceOriginal+
		   " -rt " + $rebuildType + 
		   " -end " + $endKnots +
		   " -kr " + $keepParmRange +
		   " -kcp " + $keepControlPoints +
		   " -kep " + $keepEndPts + 
		   " -kt " + $keepTan;
	$cmd += " -s " + $crvNumSpans + " -d " + $crvDegree;
	if( $crvUseGlobalTol == 0 ) {	// Use globl tolerance vs. local tolerance
		$cmd += " -tol " + $crvLocalTol;
	} else {
		$cmd += " -tol " + $globalTol;
	}

	string $cosCmd;
	$cosCmd = $cmd;

	string $curveResults[] ;

	if( $rebuildType == 2 ) {
		int $l = size($curveList) ;
		if( $l > 2 ) {
			warning( (uiRes("m_performRebuildCurveSet.kWarningRebuilding")) );
		}
		if( $l >= 2 ) {
			int $nitems = 2 ;
			$cmd = appendToCmdPlaceHoldersForSelectionItems( $cmd, $nitems ) ;
			string $curvePair[2] ;

			for( $i=0; $i<($l-1); $i+=1 ) {
				$curvePair[0] = $curveList[$i] ;	
				$curvePair[1] = $curveList[$l-1];
				string $oneRes[] = executeCmdOnItems($cmd,$curvePair);
				appendStringArray( $curveResults, $oneRes, size($oneRes));
			}
		}
	} else {
		$cmd += " %s;";
		$curveResults = executeForEachObject( $curveList, $cmd );
	}

	// Execute rebuildCurve on all active curves-on-surface.
	//
	// $cosCmd +=  " -cos on ";
	string $cosResults[];
	if( $rebuildType == 2 ) {
		int $l = size($cosList) ;
		if( $l > 2 ) {
			warning( (uiRes("m_performRebuildCurveSet.kWarningRebuilding")));
		}
		if( $l >= 2  ) {
			int $nitems = 2 ;
			$cosCmd = appendToCmdPlaceHoldersForSelectionItems( $cosCmd, $nitems ) ;
			for( $i=0; $i<($l-1); $i+=1 ) {
				$curvePair[0] = $cosList[$i] ;	
				$curvePair[1] = $cosList[$l-1];
				string $oneRes[] = executeCmdOnItems($cmd,$curvePair);
				appendStringArray( $curveResults, $oneRes, size($oneRes));
			}
		}
	} else {
		$cosCmd += " %s;" ;
		$cosResults = executeForEachObject( $cosList, $cosCmd );
	}


	if( (size($curveResults)+size($cosResults)) == 0 ) {
		int $l = size($curveList) ;
		if( $rebuildType == 2  && (size($curveList) < 2) ) {
			error( uiRes( "m_performRebuildCurveSet.kRebuildCurveInvalSelection"));
		}
		else if( 0 == (size($curveList) + size($cosList)) ) {
			error (uiRes("m_performRebuildCurveSet.kRebuildCurvesImproperSelection"));
		}
		else {
			error( (uiRes("m_performRebuildCurveSet.kErrorRebuildFailed")) );
		}
	} else {
		// Select all the results with one select command
		//
		select -r $curveResults $cosResults;
	}
}

