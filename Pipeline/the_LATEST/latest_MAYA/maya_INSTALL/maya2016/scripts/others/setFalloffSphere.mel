// Copyright (C) 1997-2014 Autodesk, Inc., and/or its licensors.
// All rights reserved.
//
// The coded instructions, statements, computer programs, and/or related
// material (collectively the "Data") in these files contain unpublished
// information proprietary to Autodesk, Inc. ("Autodesk") and/or its licensors,
// which is protected by U.S. and Canadian federal copyright law and by
// international treaties.
//
// The Data is provided for use exclusively by You. You have the right to use,
// modify, and incorporate this Data into other products for purposes authorized 
// by the Autodesk software license agreement, without fee.
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND. AUTODESK
// DOES NOT MAKE AND HEREBY DISCLAIMS ANY EXPRESS OR IMPLIED WARRANTIES
// INCLUDING, BUT NOT LIMITED TO, THE WARRANTIES OF NON-INFRINGEMENT,
// MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE, OR ARISING FROM A COURSE 
// OF DEALING, USAGE, OR TRADE PRACTICE. IN NO EVENT WILL AUTODESK AND/OR ITS
// LICENSORS BE LIABLE FOR ANY LOST REVENUES, DATA, OR PROFITS, OR SPECIAL,
// DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES, EVEN IF AUTODESK AND/OR ITS
// LICENSORS HAS BEEN ADVISED OF THE POSSIBILITY OR PROBABILITY OF SUCH DAMAGES.

proc float[] mult( float $pt[], float $mat[] )
{
	float $a = $pt[0]*$mat[0] + $pt[1]*$mat[4] + $pt[2]*$mat[8] + $pt[3]*$mat[12];
	float $b = $pt[0]*$mat[1] + $pt[1]*$mat[5] + $pt[2]*$mat[9] + $pt[3]*$mat[13];
	float $c = $pt[0]*$mat[2] + $pt[1]*$mat[6] + $pt[2]*$mat[10] + $pt[3]*$mat[14];
	float $d = $pt[0]*$mat[3] + $pt[1]*$mat[7] + $pt[2]*$mat[11] + $pt[3]*$mat[15];

	return { $a, $b, $c, $d };
}

proc float[] worldOrigin( string $obj )
{
	float $mat[] = `getAttr ($obj+".worldMatrix")`;
	float $res[] = mult( {0,0,0,1}, $mat );
	return {$res[0],$res[1],$res[2]};
}

proc float[] toLocal( float $pt[], string $obj )
{
	float $mat[] = `getAttr ($obj+".worldInverseMatrix")`;
	float $point[] = { $pt[0], $pt[1], $pt[2], 1.0 };
	return mult( $point, $mat );
}



global proc setFalloffSphere( 
	string $fluid, 
	string $obj, 
	float $min, 
	float $max )
//-----------------------------------------------------------------------------
//	
//	Description: 
//
//		Initializes the falloff grid for the given fluid with a function
//		dropping off with distance from the center of the transform of
//		the given object "obj".
//
//		For distances between 0 and $min, the falloff grid will have a 
//		value of 1.  Between $min and $max, the value will fall off to 0,
//		and after distance $max, the value will be 0.
//
//-----------------------------------------------------------------------------
{
	float $dim[] = `getAttr ($fluid+".dim")`;
	float $res[] = `getAttr ($fluid+".res")`;

	//	get center of obj in fluid space
	//	
	float $objCenter[] = toLocal( worldOrigin($obj), $fluid );
	$objCenter[0] /= ($res[0]/4.0);
	$objCenter[1] /= ($res[1]/4.0);
	$objCenter[2] /= ($res[2]/4.0);
	
	print( "$objCenter = " + $objCenter[0] + "," + $objCenter[1] + "," + $objCenter[2] + "\n" );
	
	setAttr ($fluid + ".falloffMethod") 1;
	setAttr ($fluid + ".dropoffShape") 12;
	setAttr ($fluid + ".edgeDropoff") 0.5;
	
	int $i, $j, $k;
	for( $i = 0; $i < $res[0]; $i++ )
	{
		float $x = -1.0 + 2*($i+0.5)/$res[0];
		
		for( $j = 0; $j < $res[1]; $j++ )
		{
			float $y = -1.0 + 2*($j+0.5)/$res[1];

			for( $k = 0; $k < $res[2]; $k++ )
			{
				float $z = -1.0 + 2*($k+0.5)/$res[2];
				
				float $diff[] = { $x-$objCenter[0], $y-$objCenter[1], $z-$objCenter[2] };
				float $dist = sqrt($diff[0]*$diff[0]+$diff[1]*$diff[1]+$diff[2]*$diff[2] );

				float $val;				
				if( $dist < $min )
				{
					$val = 1.0;
				}
				else if( $dist > $max )
				{
					$val = 0.0;
				}
				else
				{
					$theta = 3.14*($dist-$min)/($max-$min);
					$val = 0.5 + 0.5*cos($theta);

					$val = 1.0 - ($dist-$min)/($max-$min);
				}
				
				setFluidAttr -at falloff -xi $i -yi $j -zi $k -fv $val $fluid;
			}
		}
	}
}
	
	
