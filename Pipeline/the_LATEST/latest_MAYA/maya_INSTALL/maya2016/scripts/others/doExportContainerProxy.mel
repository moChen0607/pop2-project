// Copyright (C) 1997-2014 Autodesk, Inc., and/or its licensors.
// All rights reserved.
//
// The coded instructions, statements, computer programs, and/or related
// material (collectively the "Data") in these files contain unpublished
// information proprietary to Autodesk, Inc. ("Autodesk") and/or its licensors,
// which is protected by U.S. and Canadian federal copyright law and by
// international treaties.
//
// The Data is provided for use exclusively by You. You have the right to use,
// modify, and incorporate this Data into other products for purposes authorized 
// by the Autodesk software license agreement, without fee.
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND. AUTODESK
// DOES NOT MAKE AND HEREBY DISCLAIMS ANY EXPRESS OR IMPLIED WARRANTIES
// INCLUDING, BUT NOT LIMITED TO, THE WARRANTIES OF NON-INFRINGEMENT,
// MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE, OR ARISING FROM A COURSE 
// OF DEALING, USAGE, OR TRADE PRACTICE. IN NO EVENT WILL AUTODESK AND/OR ITS
// LICENSORS BE LIABLE FOR ANY LOST REVENUES, DATA, OR PROFITS, OR SPECIAL,
// DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES, EVEN IF AUTODESK AND/OR ITS
// LICENSORS HAS BEEN ADVISED OF THE POSSIBILITY OR PROBABILITY OF SUCH DAMAGES.


//
//	Procedure Name:
//		doExportContainerProxy
//
//	Description:
//		Export a file containing lo-res proxy container.
//
//	Input Arguments:
//	$version: The version of this option box.  Used to know how to 
//	interpret the $args array.
//  
//	$args
//    Version 1: None
//    Version 2:
//     $args[0]: proxy name
//     $args[1]: 1 = from template, 0 = from container
//     $args[2]: 1 = export, 0 = keep in scene
//
global string $gExportContainerProxyNamespace = "temporaryNamespace_____";
global string $gContainerProxyExportName = "";

global 
proc containerProxyFromTemplateCB(string $type, string $fileName, string $template)
{
	global string $gContainerProxyExportName;

	string $newContainers[] = `containerProxy -fromTemplate $template -type $type`;
	select -r $newContainers[0];
	if (size($gContainerProxyExportName) > 0) {
		rename $newContainers[0] $gContainerProxyExportName;
	}
}

proc
string validateExportContainerSelection()
//
// A container from a referenced file must be selected. If more than one
// container is selected, they must all be from the same referenced file.
//
{
	string $containers[] = `ls -sl -containers`;
	if (size($containers) == 0) {
		string $sel[] = `ls -sl`;
		string $selContainer = `container -q -findContainer $sel`;
		if (size($selContainer) > 0) {
			$containers[0] = $selContainer;
		} else {
			error( (uiRes("m_doExportContainerProxy.kSelectContainerExportErr")) );
		}
	}

	// Test that all the containers are from the same file and that it
	// is not the main scene file.
	//
	string $originalContainerFileName;
	for ($container in $containers) {
		string $containerFile;
		if (`referenceQuery -isNodeReferenced $container`) {
			$containerFile = `referenceQuery -filename $container`;
		} else {
			string $errMsg = (uiRes("m_doExportContainerProxy.kContainerIsNotReferenced"));
			$errMsg = `format -s $container $errMsg`;
			error($errMsg);
		}
		if (size($originalContainerFileName) == 0) {
			$originalContainerFileName = $containerFile;
		} else if ($originalContainerFileName != $containerFile) {
			error((uiRes("m_doExportContainerProxy.kContainersNotFromSameFile")));
		}
	}
	return $originalContainerFileName;
}

global proc 
checkForContainersWithNameClashes()
{
	global string $gExportContainerProxyNamespace;
	if (! `namespace -exists $gExportContainerProxyNamespace`) {
		namespace -add $gExportContainerProxyNamespace;
	}
	
	string $buff[];
	string $containers[] = `ls -sl -containers`;
	for ($container in $containers) {
		clear($buff);
		tokenize($container,":",$buff);
		if (size($buff) == 1) {
			restoreNameClashContainers();
			error((uiRes("m_doExportContainerProxy.kMustUseNamespaces")));
		}
		string $baseName = $buff[size($buff)-1];
		if (`objExists $baseName`) {
			string $newName = ($gExportContainerProxyNamespace+":"+$baseName); 
			rename $baseName $newName;
		}
	}
}

global proc
restoreNameClashContainers()
{
	string $buff[];
	global string $gExportContainerProxyNamespace;	
	if (`namespace -exists $gExportContainerProxyNamespace`) {
		namespace -set $gExportContainerProxyNamespace;
		string $nodes[] = `namespaceInfo -lod`;
		for ($node in $nodes) {
			clear($buff);
			tokenize($node,":",$buff);
			rename $node $buff[1];
		}
		namespace -set ":";
		namespace -rm $gExportContainerProxyNamespace;
	}
}


global proc createAndExportContainerProxy(string $fileName,
										  string $fileType, 
										  string $origFileName)
{
	global string $gContainerProxyExportName;	
	string $proxies[];
	string $containers[] = `ls -sl -containers`;
	if (size($containers) == 0) {
		string $sel[] = `ls -sl`;
		string $selContainer = `container -q -findContainer $sel`;
		if (size($selContainer) > 0) {
			$proxies = `containerProxy $selContainer`;
		} else {
			error((uiRes("m_doExportContainerProxy.kNContainerNotFound")));
		}
	} else {
		$proxies = `containerProxy`;
	}
	if (size($proxies) > 0) {
		// export the proxies to the file
		//
		select -r $proxies;
		string $expName = `file -type $fileType -exportSelected -channels false -constructionHistory false $fileName`;
		string $path = dirname($fileName);
		$fileName = ($path+"/"+$expName);
		delete $proxies;

		// set up the Reference Proxy
		//
		string $refNode = `referenceQuery -referenceNode $origFileName`;
		proxyAdd($refNode,$fileName,$gContainerProxyExportName);

		string $resultMsg = (uiRes("m_doExportContainerProxy.kProxyResult"));
		$resultMsg = `format -s "proxyContainer" $resultMsg`;
		print($resultMsg);
	} else {
		error( (uiRes("m_doExportContainerProxy.kUnableToExportErr")) );
	}
}

global proc int
exportContainerProxy(string $fileName)
{
	if ($fileName == "") {
		error( (uiRes("m_doExportContainerProxy.kNoFileNameSpecified")) );
		return 0;
	}

	string $fileExt = fileExtension($fileName), $fileType;

	if (`about -evalVersion`) {
		$fileType = "mayaPLE";
	} else if ($fileExt == "ma") {
		$fileType = "mayaAscii";
	} else if ($fileExt == "mb") {
		$fileType = "mayaBinary";
	}
	
	if ($fileType != "mayaBinary" && $fileType != "mayaAscii" && $fileType != "mayaPLE") {
	    string $errMsg = (uiRes("m_doExportContainerProxy.kInvalidFileTypeErr"));
	    $errMsg = `format -s $fileType $errMsg`;
		error($errMsg);
		return 0;
	}

	// save the current selection to restore it at the end
	//
	string $sel[] = `ls -sl`;
	string $currNamespace = `namespaceInfo -cur`;
	namespace -set ":";
	
	string $origFileName = validateExportContainerSelection();

	// check if there are name clashes with main scene nodes and the
	// base name of the referenced containers
	//
	checkForContainersWithNameClashes();
	
	// Create the proxy and export it
	//
	int $origEditsPref = `optionVar -query proxyOptionsSharedEdits`;
	optionVar -intValue proxyOptionsSharedEdits 1;
	catch(`createAndExportContainerProxy $fileName $fileType $origFileName`);
	optionVar -intValue proxyOptionsSharedEdits $origEditsPref;

	restoreNameClashContainers();

	// restore original selection and namespace
	//
	select -r $sel;
	namespace -set $currNamespace;
	return 1;
}

global proc
doExportContainerProxy( string $version, string $args[] )
//
//	$args
//    Version 1: None
//    Version 2:
//     $args[0]: proxy name
//     $args[1]: 1 = from template, 0 = from container
//     $args[2]: containerType (used only when fromTemplate enabled)
//     $args[3]: 1 = export, 0 = keep in scene
//
{
	global string $gContainerProxyExportName;	
	string $proxyName = "containerProxy";
	int $export = 1;
	int $fromTemplate = 0;
	int $versionNum = $version;
	string $containerType = "dagContainer";
	if ($versionNum > 1) {
		$proxyName = $args[0];
		$fromTemplate = $args[1];
		$containerType = $args[2];
		$export = $args[3];
	}
	$gContainerProxyExportName = $proxyName;

	if ($fromTemplate == 0) {
		if ($export) {
			// will error out if selection is not valid
			//
			validateExportContainerSelection();
			
			string $windowCaption = (uiRes("m_doExportContainerProxy.kExportContainerProxy"));
			string $okButtonCaption = (uiRes("m_doExportContainerProxy.kExport"));
			
			string $cmd = ("fileDialog2 -caption \"" + $windowCaption + "\"");
			$cmd += (" -fileMode 0 ");
			$cmd += (" -okCaption \"" + $okButtonCaption + "\"");
			$cmd += (" -fileFilter \"");
			$cmd += buildDefaultMayaSaveFilterList();
			$cmd += ("\"");
			
			string $file[] = `eval $cmd`;
			
			if( size($file) > 0 && $file[0] != "" )
			{
				string $path = fromNativePath($file[0]);
				string $finalCmd = "exportContainerProxy";
				$finalCmd += (" \"" + $path + "\"");
				
				eval $finalCmd;
			}
		} else {
			string $containers[] = `ls -sl -containers`;
			if (size($containers) == 0) {
				error((uiRes("m_doExportContainerProxy.kMustSelectContainer")));
			}
			string $result[] = `containerProxy $containers`;
			select -r $result;
		}
	} else {
		string $callback = ("containerProxyFromTemplateCB "+$containerType+" ");
		containerTemplateBrowser($callback,"",0);
	}
}
