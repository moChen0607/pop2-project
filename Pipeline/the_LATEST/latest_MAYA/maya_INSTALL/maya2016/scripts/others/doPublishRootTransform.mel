// Copyright (C) 1997-2014 Autodesk, Inc., and/or its licensors.
// All rights reserved.
//
// The coded instructions, statements, computer programs, and/or related
// material (collectively the "Data") in these files contain unpublished
// information proprietary to Autodesk, Inc. ("Autodesk") and/or its licensors,
// which is protected by U.S. and Canadian federal copyright law and by
// international treaties.
//
// The Data is provided for use exclusively by You. You have the right to use,
// modify, and incorporate this Data into other products for purposes authorized 
// by the Autodesk software license agreement, without fee.
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND. AUTODESK
// DOES NOT MAKE AND HEREBY DISCLAIMS ANY EXPRESS OR IMPLIED WARRANTIES
// INCLUDING, BUT NOT LIMITED TO, THE WARRANTIES OF NON-INFRINGEMENT,
// MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE, OR ARISING FROM A COURSE 
// OF DEALING, USAGE, OR TRADE PRACTICE. IN NO EVENT WILL AUTODESK AND/OR ITS
// LICENSORS BE LIABLE FOR ANY LOST REVENUES, DATA, OR PROFITS, OR SPECIAL,
// DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES, EVEN IF AUTODESK AND/OR ITS
// LICENSORS HAS BEEN ADVISED OF THE POSSIBILITY OR PROBABILITY OF SUCH DAMAGES.

//
//	Procedure Name:
//		doPublishRootTransform
//
//	Description:
//		Publish or unpublish the selected transform as as the root
//		of the advanced asset (container). If an asset has also been selected,
//		the publishing/unpublishing is relative to that asset, if possible.
//
//	Input Arguments:
//	$version: The version of this option box.  Used to know how to 
//	interpret the $args array.
//  
//	$args
//	Version 1:
//		$args[0]: boolean, whether to publish or unpublish
//		$args[1]: boolean, whether root should be published
//				  as parent and child anchor as well.
//	Version 2:
//		$args[2]: boolean,
//					For publish: whether to unpublish existing root
// 					  in order to publish the new one (vs. give error),
//					For unpublish: whether to unpublish existing root
//					  (vs. trying to unpublish the selection)
//

proc checkPublished(string $transform,
					string $container,
					int $isPublished,
					int	$asAnchors )
//
//	Description:
//		Given transform, check it if its published state with respect to the
//	given container matches $isPublished. If $asAnchors is true, also check
//	the state of published parent/child anchors. Issue an error message if
//	anything is not as desired, otherwise return.
//
//	Inputs:
//		$transform	: transform for which we check published state
//		$container	: container against which publication is checked
//		$isPublished: if true, we want $transform to be published, else not.
//		$asAnchors	: if true, also check if published as both parent and
//					  child anchors.
//
//	Return Value.
//		None, but only returns if there are no errors.
//
{
	string $errFmt;
	if( $isPublished ){
		// These messages are fairly general because of the fact that they get
		// used in multiple cases. For example, if you try to publish something
		// as a root and it is already published, you will get the 2nd message.
		// You'll also get the 2nd message if you have a hierarchically
		// published root and you try to unpublish it from the base container
		// when it is still published to the parent container.
		//
		$errFmt = (uiRes("m_doPublishRootTransform.kPublishedErr"));
	} else {
		$errFmt = (uiRes("m_doPublishRootTransform.kNotPublishedErr"));
	}
	// Is $transform published as root (and possibly also as
	// child/parent) on $container? If so, pop up a level. If not,
	// bail, and issue an error message.
	//
	// First, check if it's published as root
	//
	int $numFailures = 0;
	string $failedTypes[];
	string $root = `container -q -pro $container`;
	if( ($root == $transform) != $isPublished ){
		$failedTypes[$numFailures++] = (uiRes("m_doPublishRootTransform.kRoot"));
	}
	// If necessary, check if it's published as parent and child
	// anchors.
	//
	if( $asAnchors ){
		string $anchors[] = `container -q -pap -ba $container`;
		if( stringArrayContains( $transform, $anchors ) != $isPublished ){
			$failedTypes[$numFailures++] = (uiRes("m_doPublishRootTransform.kParentAnchor"));
		}
		clear $anchors;
		$anchors = `container -q -pac -ba $container`;
		if( stringArrayContains( $transform, $anchors ) != $isPublished ){
			$failedTypes[$numFailures++] = (uiRes("m_doPublishRootTransform.kChildAnchor"));
		}
	}
	if( $numFailures > 0 ){
		string $catFailedTypes = $failedTypes[0];
		int $index = 1;
		while( $index < $numFailures ){
			$catFailedTypes += "/";
			$catFailedTypes += $failedTypes[$index++];
		}
		error( `format -s $transform -s $catFailedTypes -s $container $errFmt` );
	}
}

global proc
doPublishRootTransform( string $version, string $args[] )
{
	int $publish = $args[0];
	int $parentChild = $args[1];
	int $versionNo = $version;
	int $removeExisting = 0;
	if ($versionNo > 1) {
		$removeExisting = $args[2];
	}

	string $transforms[] = `ls -sl -type transform`;
	string $containers[] = `ls -sl -type container`;
	int $numTransforms = size($transforms);
	int $numContainers = size($containers);
	string $transform;
	string $container;
	string $tContainer;	// transform's container
	if( $numContainers > 1 ){
		error( (uiRes("m_doPublishRootTransform.kTooManyContainers")) );
	}
	if( $numTransforms > 1 ){
		error( (uiRes("m_doPublishRootTransform.kTooManyTransforms")));
	}

	if (0 == $publish && $removeExisting == 1) {
		// The user has requested that we remove the existing root, so
		// ignore the selected transform, except as a way of finding its
		// container.
		//
		if ($numContainers == 0 && $numTransforms > 0) {
			$tContainer = `container -q -fc $transforms[0]`;
			if ($tContainer != "") {
				$containers[0] = $tContainer;
				$numContainers = 1;
			}
			$numTransforms = 0;
		}
	}
	
	if ( $numTransforms == 0 ) {
		// The only scenario under which not picking a transform makes sense is
		// if a user is unpublishing, and has selected a container, since a
		// container can have have at most one root to unpublish implicitly.
		// Under any other circumstance, we'll issue an appropriate error
		// message.
		//
		if( 0 == $publish ){
			if( $numContainers == 0 ){
				// Nothing selected can be unpublished; user must select either
				// a transform, and/or a container.
				//
				error( (uiRes("m_doPublishRootTransform.kNoContainers")) );
			} else {
				$container = $containers[0];
				string $root = `container -q -publishAsRoot $container`;
				if (size($root) == 0) {
					// The container does not have a root transform, so there
					// is nothing to be unpublished, even implicitly.
					//
					error((uiRes("m_doPublishRootTransform.kNoRootInContainer")));
					return;
				}
				$transform = $root;
			}
		} else {
			// If we're publishing, a transform must be specified.
			//
			error( (uiRes("m_doPublishRootTransform.kNoTransforms")) );
		}
	} else {
		$transform = $transforms[0];
		$tContainer = `container -q -fc $transform`;
		if( $tContainer == "" ){
			// A transform was selected, but it's not in a container
			//
			error( (uiRes("m_doPublishRootTransform.kNotInContainer")) );
		}
		if( $numContainers == 0 ){
			// Implicit publishing/unpublishing
			//
			$container = $tContainer;
		} else {
			// Explicit publishing/unpublishing, for hierarchical pub/unpub
			//
			$container = $containers[0];
		}
	}
	if( $publish ){
		// First, check if $tContainer is a descendant of $container.
		//
		string $tContainerOriginal = $tContainer;
		while( ($tContainer != "") && ($tContainer != $container) ){
			$tContainer = `container -q -fc $tContainer`;
		}
		if( $tContainer == "" ){
			// We got to the top of the hierarchy without ever finding the
			// selected container, which means that the selected transform
			// doesn't have the selected container as an ancestor. Bail.
			//
			string $errFmt = (uiRes("m_doPublishRootTransform.kNotInHierarchy"));
			error( `format -s $transform -s $container $errFmt` );
		}
		// User could be trying to do hierarchical publishing. Check if the
		// conditions are right for this to be allowed.
		//
		$tContainer = $tContainerOriginal;
		while( ($tContainer != "") && ($tContainer != $container) ){
			// Check published status: the method will only return without
			// an error message if everything is ok.
			//
			checkPublished( $transform, $tContainer, true, $parentChild );
			// So far, so good, pop up to the next container, if possible.
			//
			$tContainer = `container -q -fc $tContainer`;
		}
		// Make sure it's not published to $container
		//
		checkPublished( $transform, $container, false, $parentChild );
	} else {
		// User could be trying to do hierarhical unpublishing. Only allow
		// the transform to be unpublished if its not also published to its
		// immediate ancestor.
		//
		// Is it published as root? Don't check anchor publishing, since
		// that will happen automatically if necessary, at unpublish time.
		//
		checkPublished( $transform, $container, true, false );
		// Is it not published to this container's parent? Note that it
		// can't be published as an anchor, since that would imply that
		// it is also published as an anchor wrt $container, and we would
		// need to unpublish those as well, but wouldn't be able to do so.
		//
		$tContainer = `container -q -fc $container`;
		if( $tContainer != "" ){
			checkPublished( $transform, $tContainer, false, true );
		}
	}
	// If we get to here, the operation is possible, so go ahead and do it.
	//
	if ($publish && $removeExisting) {
		string $currRoot = `container -q -publishAsRoot $container`;
		if ("" != $currRoot) {
			string $removeCmd = ("container -e -publishAsRoot "+$currRoot);
			$removeCmd += (" 0 "+$container+"; ");
			evalEcho $removeCmd;
		}
	}
	
	string $cmd = ("container -e -publishAsRoot "+$transform+" "+$publish);
	$cmd += (" "+$container+"; ");

	if( $publish && $parentChild ) {
		$cmd += ("container -e -publishAsParent "+$transform+" rootParent "+$container+"; ");
		$cmd += ("container -e -publishAsChild "+$transform+" rootChild "+$container+"; ");
	}
	evalEcho $cmd;
}
