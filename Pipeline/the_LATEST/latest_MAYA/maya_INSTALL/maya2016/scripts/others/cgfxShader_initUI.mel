// Copyright (C) 1997-2014 Autodesk, Inc., and/or its licensors.
// All rights reserved.
//
// The coded instructions, statements, computer programs, and/or related
// material (collectively the "Data") in these files contain unpublished
// information proprietary to Autodesk, Inc. ("Autodesk") and/or its licensors,
// which is protected by U.S. and Canadian federal copyright law and by
// international treaties.
//
// The Data is provided for use exclusively by You. You have the right to use,
// modify, and incorporate this Data into other products for purposes authorized 
// by the Autodesk software license agreement, without fee.
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND. AUTODESK
// DOES NOT MAKE AND HEREBY DISCLAIMS ANY EXPRESS OR IMPLIED WARRANTIES
// INCLUDING, BUT NOT LIMITED TO, THE WARRANTIES OF NON-INFRINGEMENT,
// MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE, OR ARISING FROM A COURSE 
// OF DEALING, USAGE, OR TRADE PRACTICE. IN NO EVENT WILL AUTODESK AND/OR ITS
// LICENSORS BE LIABLE FOR ANY LOST REVENUES, DATA, OR PROFITS, OR SPECIAL,
// DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES, EVEN IF AUTODESK AND/OR ITS
// LICENSORS HAS BEEN ADVISED OF THE POSSIBILITY OR PROBABILITY OF SUCH DAMAGES.

// Copyright 2003-2004, NVIDIA
//
//
// This script is run automatically when the cgfxShader plug-in is loaded.

{
    string $dir;
    string $s;

    // Get path to the directory containing the plug-in files.
    //   We load our MEL scripts from this directory only, so
    //   that we cannot inadvertently pick up a wrong version
    //   from some other directory on the search path.
    string $dir = `cgfxShader -q -pluginPath`;

    // Load some MEL procedures.  
    //   These utilities could be shared by other tools that work with
    //   cgfxShader nodes, so load them at the time the plug-in is loaded.
    eval( "source \"cgfxShader_util.mel\"" );

    // Load attribute editor template for cgfxVector node.  It's small.
    if ( !`about -batch` )
        eval( "source \"AEcgfxVectorTemplate.mel\"" );

    // User can provide a customization script in which any of our
    //   MEL procedures can be redefined.  Since our procedures may
    //   differ from version to version of the cgfxShader plug-in,
    //   it is the user's responsibility to check the version and
    //   ensure that their customization works properly.  The MEL
    //   command `pluginInfo -q -version cgfxShader` will return
    //   the cgfxShader version string.
    if ( `exists cgfxShader_customInit` )    // using the normal MEL search path
        eval "cgfxShader_customInit";

    // Set default definitions for tool buttons in cgfxShader attribute editor.
    //   [0]:    for each of the 3 tool buttons, the assigned tool name (tab separated)
    //   [1..N]: any number of tool definitions consisting of tab-separated
    //             tool name, description, and MEL command string 
    $s = "AEcgfxShader_toolButtons";
    if ( !`about -batch` &&
         !`optionVar -exists $s` )
    {
		string $EditStr = 		getPluginResource("cgfxShader", "kEdit");
		string $ReloadStr = 	getPluginResource("cgfxShader", "kReload");
		string $OpenStr = 		getPluginResource("cgfxShader", "kOpen");
		string $ReloadAnnStr = getPluginResource("cgfxShader", "kReloadAnn");
		string $OpenAnnStr = 	getPluginResource("cgfxShader", "kOpenFileAnn");
		string $SetOptionVarWarning = `format -stringArg $s (getPluginResource("cgfxShader", "kSetOptionVarWarning"))`;

        if ( `about -nt` ) {
            optionVar -sva $s ($EditStr + "\t" + $ReloadStr + "\t" + $OpenStr)
                      -sva $s ($EditStr + "\t" + getPluginResource("cgfxShader", "kEditWindowsAnn") + "\tsystem \"start notepad.exe <file>\";")
                      -sva $s ($OpenStr + "\t" + $OpenAnnStr + "\tsystem \"load <file>\";")
                     -sva $s ($ReloadStr + "\t" + $ReloadAnnStr + "\tcgfxShader -e -fx <file> <node>;")
                      ;
        }
        else if ( `about -macOS` ) {
            optionVar -sva $s ($EditStr + "\t" + $ReloadStr + "\t" + $OpenStr)
                      -sva $s ($EditStr + "\t" + getPluginResource("cgfxShader", "kEditMacAnn") + "\tsystem \"open -a TextEdit <file>\";")
                      -sva $s ($OpenStr + "\t" + $OpenAnnStr + "\tsystem \"open <file>\";")
                      -sva $s ($ReloadStr + "\t" + $ReloadAnnStr + "\tcgfxShader -e -fx <file> <node>;")
                      ;
        }
        else {
            optionVar -sva $s ($EditStr + "\t" + $ReloadStr + "\t" + $OpenStr)
                      -sva $s ($EditStr + "\t" + getPluginResource("cgfxShader", "kEditAnn") + "\tprint \"" + $SetOptionVarWarning + "\";")
                      -sva $s ($OpenStr + "\t" + $OpenAnnStr + "\tprint \"" + $SetOptionVarWarning + "\";")
                      -sva $s ($ReloadStr + "\t" + $ReloadAnnStr + "\tcgfxShader -e -fx <file> <node>;")
                      ;
        }
    }                            
}

// This procedure is called by the Attribute Editor to load the
// cgfxShader node template *from our subdirectory* upon demand.
global proc AEcgfxShaderTemplate( string $node )
{
    // Get path to the directory containing the plug-in files.
    //   We load our MEL scripts from this directory only, so
    //   that we cannot inadvertently pick up a wrong version
    //   from some other directory on the search path.
    string $dir = `cgfxShader -q -pluginPath`;

    // Load attribute editor template.
    eval( "source \"AEcgfxShaderTemplate.mel\"" );

    // User can provide a customization script in which any of our
    //   MEL procedures can be redefined.  Since our procedures may
    //   differ from version to version of the cgfxShader plug-in,
    //   it is the user's responsibility to check the version and
    //   ensure that their customization works properly.  The MEL
    //   command `pluginInfo -q -version cgfxShader` will return
    //   the cgfxShader version string.
    if ( `exists cgfxShader_customAE` ) // using the normal MEL search path
        eval "source cgfxShader_customAE";

    // Redefine this procedure so this dynamic loading stuff is done just once.
    evalDeferred ( "global proc AEcgfxShaderTemplate( string $node ) " +
                   "{ AEcgfxShader_template( $node ); }" );

    // Invoke the real template.
    eval ( "AEcgfxShader_template " + $node );
}                                      // AEcgfxShaderTemplate


