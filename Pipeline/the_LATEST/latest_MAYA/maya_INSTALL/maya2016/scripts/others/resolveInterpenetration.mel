// Copyright (C) 1997-2014 Autodesk, Inc., and/or its licensors.
// All rights reserved.
//
// The coded instructions, statements, computer programs, and/or related
// material (collectively the "Data") in these files contain unpublished
// information proprietary to Autodesk, Inc. ("Autodesk") and/or its licensors,
// which is protected by U.S. and Canadian federal copyright law and by
// international treaties.
//
// The Data is provided for use exclusively by You. You have the right to use,
// modify, and incorporate this Data into other products for purposes authorized 
// by the Autodesk software license agreement, without fee.
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND. AUTODESK
// DOES NOT MAKE AND HEREBY DISCLAIMS ANY EXPRESS OR IMPLIED WARRANTIES
// INCLUDING, BUT NOT LIMITED TO, THE WARRANTIES OF NON-INFRINGEMENT,
// MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE, OR ARISING FROM A COURSE 
// OF DEALING, USAGE, OR TRADE PRACTICE. IN NO EVENT WILL AUTODESK AND/OR ITS
// LICENSORS BE LIABLE FOR ANY LOST REVENUES, DATA, OR PROFITS, OR SPECIAL,
// DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES, EVEN IF AUTODESK AND/OR ITS
// LICENSORS HAS BEEN ADVISED OF THE POSSIBILITY OR PROBABILITY OF SUCH DAMAGES.

proc string setRPlayObjects(float $pushOut, float $crossoverPush, float $damp, int $ignoreGravity, string $cObjs[], float $cPushOut[], 
	float $cCrossover[], float $cSelfCrossover[], float $cDamp[], int $cIgnoreGravity[], float $cDrag[], float $cTDrag[], int $cCollide[], int $cTrapped[])
{
	string $meshes[] = `ls -sl -dag -ni -o -visible -type mesh`;
	string $mesh;
	string $nucleus = "";
	for($mesh in $meshes){
		string $cloth = `findTypeInHistory $mesh "nBase" 1 1`;
		if( $cloth != "" ){
			string $nucleusCons[] = 
				`listConnections -type nucleus ($cloth + ".currentState")`;
			$nucleus = $nucleusCons[0];
			if( size( $nucleusCons) > 0 ){
				int $i = size( $cObjs );
				$cObjs[ $i ] = $cloth;
				int $isCloth = nodeType( $cloth ) == "nCloth";
				if( $isCloth || nodeType( $cloth ) == "nRigid" ){

					$cPushOut[ $i ] = getAttr( $cloth + ".pushOut" );
					$cCrossover[ $i ] = getAttr( $cloth + ".crossoverPush" );
					$cCollide[ $i ] = getAttr( $cloth + ".collide" );
					$cTrapped[ $i ] = getAttr( $cloth + ".trappedCheck" );
					setAttr ($cloth + ".pushOut") $pushOut;
					setAttr ($cloth + ".crossoverPush") $crossoverPush;
					setAttr ($cloth + ".collide") false;
					setAttr ($cloth + ".trappedCheck") false;
					if( $isCloth ){
						$cDamp[ $i ] = getAttr( $cloth + ".damp");
						$cDrag[ $i ] = getAttr( $cloth + ".drag");
						$cTDrag[ $i ] = getAttr( $cloth + ".tangentialDrag");
						setAttr ($cloth + ".damp") $damp;
						setAttr ($cloth + ".drag") 0.1;
						setAttr ($cloth + ".tangentialDrag") 1.0;
						$cSelfCrossover[ $i ] = getAttr( $cloth + ".selfCrossoverPush");
						setAttr ($cloth + ".selfCrossoverPush") $crossoverPush;
						$cIgnoreGravity[ $i ] = getAttr( $cloth + ".ignoreSolverGravity");
						if( !$cIgnoreGravity[$i] && $ignoreGravity){
							setAttr ($cloth + ".ignoreSolverGravity") $ignoreGravity;
						}
					}
				}
				$cObjs[ $i+1 ] = $nucleusCons[0];
			}
		}
	}
	$cObjs = stringArrayRemoveDuplicates( $cObjs );
	string $obj;
	for( $obj in $cObjs ){
		disconnectAttr time1.outTime ($obj + ".currentTime");
	}
	return $nucleus;
}


proc rPlayRemoveObjects(string $cObjs[], float $cPushOut[], float $cCrossover[], float $cSelfCrossover[], float $cDamp[], int $cIgnoreGravity[], float $cDrag[], float $cTDrag[], int $cCollide[], int $cTrappedCheck[])
{
	string $obj;
	int $i = 0;
	for( $obj in $cObjs ){
		int $isCloth = (nodeType( $obj ) == "nCloth");
			
		if( $isCloth || nodeType( $obj ) == "nRigid" ){
			nBase -e -stuffStart $obj;
			setAttr ($obj + ".pushOut") $cPushOut[$i];	
			setAttr ($obj + ".crossoverPush") $cCrossover[$i];	
			setAttr ($obj + ".collide") $cCollide[$i];	
			setAttr ($obj + ".trappedCheck") $cTrappedCheck[$i];	
			if( $isCloth ){
				setAttr ($obj + ".selfCrossoverPush") $cSelfCrossover[$i];	
				setAttr ($obj + ".damp") $cDamp[$i];	
				setAttr ($obj + ".ignoreSolverGravity") $cIgnoreGravity[$i];	
				setAttr ($obj + ".drag") $cDrag[$i];	
				setAttr ($obj + ".tangentialDrag") $cTDrag[$i];	
			}
		}
		connectAttr time1.outTime ($obj + ".currentTime");
		$i++;
	}
	$cObjs = {};
}

global proc resolveInterpenetration( int $numSteps, float $pushOut, float $crossoverPush, float $damp, int $ignoreGravity )
{
	// int $setInitialState = true; 
	global string $gMainProgressBar;  // This is defined on maya startup
	int $playTime;

	progressBar -edit
		-beginProgress
		-isInterruptable true 
		-status (uiRes("m_resolveInterpenetration.kResolvingInterpenetration"))
		-maxValue $numSteps 
		$gMainProgressBar;
	
	
	$playTime = getAttr( "time1.outTime" );
	string $obj;
	string $cObjs[];
	float $cPushOut[], $cCrossover[], $cSelfCrossover[], $cDamp[], $cDrag[], $cTDrag[];
	int $cCollide[], $cTrapped[], $cIgnoreGravity[];

	string $nucleus = setRPlayObjects( $pushOut, $crossoverPush, $damp, $ignoreGravity, $cObjs, $cPushOut, $cCrossover, 
					$cSelfCrossover, $cDamp, $cIgnoreGravity, $cDrag, $cTDrag, $cCollide, $cTrapped);

	float $airDensity = 0;
	if( $nucleus != "" ){
		$airDensity = getAttr( $nucleus + ".airDensity" );
		setAttr ( $nucleus + ".airDensity" ) 0.2;
	}
	if( size( $cObjs ) < 1 ){
		$numSteps = 0;
		warning (uiRes("m_resolveInterpenetration.kNoObjectsToResolve"));
	}
	int $i;	
	for( $i = 0; $i < $numSteps; $i++ ){
		$playTime++;
		for( $obj in $cObjs ){
			setAttr ($obj+".currentTime") $playTime;
			getAttr ($obj+".forceDynamics");
		}
		refresh -f;
		if(`progressBar -query -isCancelled $gMainProgressBar` ){
			break;
		}
		progressBar -edit -step 1 $gMainProgressBar;
	}
	if( $nucleus != "" ){
		setAttr ( $nucleus + ".airDensity" ) $airDensity;
	}
	rPlayRemoveObjects($cObjs, $cPushOut, $cCrossover, $cSelfCrossover, $cDamp, $cIgnoreGravity, $cDrag, $cTDrag, $cCollide, $cTrapped);
	progressBar -edit -endProgress $gMainProgressBar;
}
