// Copyright (C) 1997-2014 Autodesk, Inc., and/or its licensors.
// All rights reserved.
//
// The coded instructions, statements, computer programs, and/or related
// material (collectively the "Data") in these files contain unpublished
// information proprietary to Autodesk, Inc. ("Autodesk") and/or its licensors,
// which is protected by U.S. and Canadian federal copyright law and by
// international treaties.
//
// The Data is provided for use exclusively by You. You have the right to use,
// modify, and incorporate this Data into other products for purposes authorized 
// by the Autodesk software license agreement, without fee.
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND. AUTODESK
// DOES NOT MAKE AND HEREBY DISCLAIMS ANY EXPRESS OR IMPLIED WARRANTIES
// INCLUDING, BUT NOT LIMITED TO, THE WARRANTIES OF NON-INFRINGEMENT,
// MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE, OR ARISING FROM A COURSE 
// OF DEALING, USAGE, OR TRADE PRACTICE. IN NO EVENT WILL AUTODESK AND/OR ITS
// LICENSORS BE LIABLE FOR ANY LOST REVENUES, DATA, OR PROFITS, OR SPECIAL,
// DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES, EVEN IF AUTODESK AND/OR ITS
// LICENSORS HAS BEEN ADVISED OF THE POSSIBILITY OR PROBABILITY OF SUCH DAMAGES.

//
//
//  ==================== dynExpressions.mel ==========
//
//  SYNOPSIS
//      Manage particle expressions for the Expression Editor.
//
//  CONTENTS
//		(The procs are in the file in the order listed here.)
//
//	Particle Expression Procedures:
//
//	EEisParticle			Is the node a particle?
//	EEisDynExpression		Is the particle expression a dynExpression?
//	EEisValidDynAttr		Is the particle attribute a valid one to show?
//	EEgetParticleExpression Get the p. expression from the particle
//	EEdisplayParticleExpression	Display a particle expression.
//	EEdynExpressionCmd		Print the expression command just issued.
//	EEapplyParticleExpression	Create or edit the particle expression
//	EErestoreParticleExpression	Restore curr particle expression from node.
//  EEparticleListChanged	User selected a particle in the node list.
//	EEonlyLaunchParticleEditor Launch a text editor for a particle expression.
//
//

// ******************************************************************
//
//				PARTICLE EXPRESSION EDITOR PROCEDURES
//
// ******************************************************************


//  ================ EEisParticle ================
//
//  SYNOPSIS
//      Return whether the object is a particle shape
//
global proc int EEisParticle(string $nodeName)
{
	if (!`isTrue "DynamicsUIExists"`)
		return 0;

	string $particles[] = `ls -type particle`;
	int $i;
	for ($i = 0; $i < size($particles); $i++)
	{
		if ($nodeName == $particles[$i])
			return 1;
	}
	return 0;

}	// EEisParticle


//  ================ EEisDynExpression ================
//
//  SYNOPSIS
//      Return whether the particle attribute has an expression or
//		a dynExpression
//
global proc int EEisDynExpression(string $objAttrName)
{
	// If the attribute is connected to a TdnExpression node, it is
	// not a dynExpression.
	//
	string $exprName[] =
	`listConnections -s true -d false -t "expression"  -scn true  $objAttrName`;

	if (size($exprName))
		return 0;
	else
		return 1;

}	// EEisDynExpression


//  ================ EEisValidDynAttr ================
//
//  SYNOPSIS
//      Return whether the particle attribute is one that's valid
//		to show in the editor.
//
global proc int EEisValidDynAttr(string $attribute)
{
	int $isValid = 0;

	if ($attribute != "input" && $attribute != "output" &&
		$attribute != "age" && $attribute != "particleId")
	{
		string $testMatch;
		$testMatch = match("PP0", $attribute);
		if (size($testMatch))
			return 0;
		
		$testMatch = match("PPCache", $attribute);
		if (size($testMatch))
			return 0;

		// We can't do match for a word that has a bracked in it;
		// it doesn't work in MEL.  But this does.
		//
		string $buffer[];
		tokenize($attribute, "[", $buffer);
		if ($buffer[0] == "output" && size($buffer) > 1)
			return 0;

		$isValid = 1;
	}

	return $isValid;

}	// EEisValidDynAttr


//  ================ EEgetParticleExpression ================
//
//  SYNOPSIS
//      Get and return the particle expression for nodeName
//
global proc string EEgetParticleExpression(string $nodeName, string $attrName)
{
	global int $EEexpressionType;
	string $particleExpr;

	if ("" != $nodeName) {
		// If an attrName has been sent in, an attribute is selected, so see
		// first if it is connected to a TdnExpression node, and get that
		// expression.  Otherwise, get a dynExpression if there is one.
		//
		if (size($attrName))
		{
			string $objAttrName = $nodeName + "." + $attrName;
			string $exprName[] =
				`listConnections -s true -d false -t "expression"  -scn true $objAttrName`;
			if (size($exprName))
				$particleExpr  = `expression -q -s $exprName[0]`;
		}

		if (size($particleExpr) == 0) {
			if ($EEexpressionType == 1) {
				$particleExpr = `dynExpression -q -rbd $nodeName`;
			} else if ($EEexpressionType == 2) {
				$particleExpr = `dynExpression -q -rad $nodeName`;
			} else if ($EEexpressionType == 3) {
				$particleExpr = `dynExpression -q -c $nodeName`;
			}
		}
	}
	return $particleExpr;

}	// EEgetParticleExpression


//  ================ EEdisplayParticleExpression ================
//
//  SYNOPSIS
//      Display the expression connected to the current
//      particle or particle attribute, and
//		put the name in the expression name textfield.
//
//
global proc EEdisplayParticleExpression(string $objAttrName,
										string $expression)
{
	global int $EEobjIsParticle;
	global int $EEcurrentEditor;
	global int $EEdoLaunchTextEd;
	global int $EEpExpressionInEditor;
	global int $EEexpressionInEditor;
	global string $EEorigExpressionName;
	global string $EEcurrExpressionName;

	// Set the data into the editor controls.
	//
	scrollField -e -tx $expression EEmultiText;

	string $buffer[];
	tokenize($objAttrName, ".", $buffer);

	if ($EEcurrentEditor != 1 && $EEdoLaunchTextEd)
	{
		EElaunchParticleEditor($expression, $buffer[0]);
		scrollField -e -enable false EEmultiText;
	}
	else
	{
		int $index = EEexpressionIsInTextEditor($buffer[0], 1);

		if ($index == -1)
		{
			$EEpExpressionInEditor = -1;
			scrollField -e -enable true EEmultiText;
		}
		else
		{
			$EEpExpressionInEditor = $index;
			scrollField -e -enable false EEmultiText;
		}
	}
	$EEexpressionInEditor = -1;
	$EEdoLaunchTextEd = 0;

	text -e -enable false EEexprNameLabel;
	EEresetExpressionName($objAttrName);
	
	textField -e -enable false EEexprNameT;
	textFieldGrp -e -tx $objAttrName EEselNameT;
	textFieldGrp -e -tx "" -enable false EEdefNameT;
	
	$EEcurrExpressionName = $objAttrName;
	$EEorigExpressionName = $objAttrName;

	EEsetEditMode("Editing Particle Expression");

}	// EEdisplayParticleExpression


//  ================ EEdynExpressionCmd ================
//
//  SYNOPSIS
//      Build the optional command args for the dynExpression command
//
//
global proc string EEdynExpressionCmd( int $expressionType,
										string $expression, string $particleObj)
{
	global int $EEeditedInEditor;

	string $cmd;

	$EEeditedInEditor = 1;
	if ($expressionType == 1) {
	    $cmd = ("dynExpression -s \""+encodeString($expression)+"\" -rbd "+$particleObj+";");
	} else if ($expressionType == 2) {
	    $cmd = ("dynExpression -s \""+encodeString($expression)+"\" -rad "+$particleObj+";");
	} else {
	    $cmd = ("dynExpression -s \""+encodeString($expression)+"\" -c "+$particleObj+";");
	}
        return evalEcho($cmd);
    
}	// EEdynExpressionCmd



//  ================ EEapplyParticleExpression ================
//
//  SYNOPSIS
//      Create the expression in the editor and connect it to
//		to the current selected attribute or
//		replace its current expression with the newly edited one.
//
//
global proc EEapplyParticleExpression(string $expression)
{
	global int $EEexpressionType;
	global string $EEcurrExpressionName;
	global string $EEorigExpressionName;

	string $particleAttrName, $particleObj, $particleAttr;
	string $exprReturn;

    $particleAttrName = `textFieldGrp -q -tx EEselNameT`;

	string $buffer[];
	tokenize($particleAttrName, ".", $buffer);
	$particleObj = $buffer[0];
	$particleAttr = $buffer[1];

	if (size($particleObj) == 0)
	{
		warning (uiRes("m_dynExpressions.kNoParticleSelected"));
		return;
	}

	string $testExpr;
	$testExpr = ("\""+$expression+"\"");

	$exprReturn = EEdynExpressionCmd($EEexpressionType, $expression, $particleObj);

	if ($exprReturn != "NULL")
		EEsetEditMode("Editing Particle Expression");

}	// EEapplyParticleExpression



//  ================ EErestoreParticleExpression ================
//
//  SYNOPSIS
//      Restore the current particle expression to the editor 
//
//
global proc EErestoreParticleExpression()
{
	string $currObjAttrName = `textFieldGrp -q -tx EEselNameT`;

	string $buffer[];
	tokenize($currObjAttrName, ".", $buffer);

	string $expression = EEgetParticleExpression($buffer[0], $buffer[1]);

	scrollField -e -tx $expression EEmultiText;

}	// EErestoreParticleExpression


//  ================ EEparticleListChanged ================
//
//  SYNOPSIS
//     A particle node in the scrolled text list of nodes is selected.
//
global proc EEparticleListChanged(string $nodeName)
{
	global string $EEnodeMode;
	global string $EEcurrSelectedNode;
	global int $EEcurrentEditor;
	global int $EEdoLaunchTextEd;

	string $particleExpr;

	// Here and below have to take into account that the user may
	// have clicked (esp. double-clicked) on the node that is 
	// currently already in the editor.  In that case, the only
	// thing that needs to be done is launch a text editor, if the
	// the user double-clicked.
	//
	if ($nodeName != $EEcurrSelectedNode)
	{
		if ($EEnodeMode == "object")  
		{
			// Object/attribute mode; user is selecting an object:
	
			// Clear all the controls in the editor, if a new node has
			// been selected, and display the attrs of the new one.
			//
			EEclearAllControls();
			EEresetNodeControls($nodeName);
	
		}
		else
		{
			// Open the rules form.
			//
			EEswitchRulesForm(1);
		}
		// Display the particle expression if there is one.  If the
		// user has double-clicked, it will be put in a text editor 
		// in the display procedure.
		//
		$particleExpr = EEgetParticleExpression($nodeName, "");
		if (size($particleExpr) == 0)
			EEdisplayNoExpression($nodeName);
		else
			EEdisplayParticleExpression($nodeName, $particleExpr);
	}
	else
	{
		// User has re-selected the previous node, so just launch a
		// text editor if the user double-clicked.
		//
		if ( $EEcurrentEditor != 1 && $EEdoLaunchTextEd)
		{
			string $particleExpr = EEgetParticleExpression($nodeName, "");

			EElaunchParticleEditor($particleExpr, $nodeName);
			scrollField -e -enable false EEmultiText;
		}
	}

}	// EEparticleListChanged


//  ================ EEonlyLaunchParticleEditor ================
//
//  SYNOPSIS
//      Don't create and show the expression editor window; just
//		launch a text editor.
//
global proc EEonlyLaunchParticleEditor(string $nodeName, string $attrName)
{

	// Find the expression, if there is one that this node.attr is
	// connected to.
	//
	$particleExpr = EEgetParticleExpression($nodeName, $attrName);

	EElaunchParticleEditor($particleExpr, $nodeName);

}	// EEonlyLaunchParticleEditor


