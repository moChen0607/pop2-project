// Copyright (C) 1997-2014 Autodesk, Inc., and/or its licensors.
// All rights reserved.
//
// The coded instructions, statements, computer programs, and/or related
// material (collectively the "Data") in these files contain unpublished
// information proprietary to Autodesk, Inc. ("Autodesk") and/or its licensors,
// which is protected by U.S. and Canadian federal copyright law and by
// international treaties.
//
// The Data is provided for use exclusively by You. You have the right to use,
// modify, and incorporate this Data into other products for purposes authorized 
// by the Autodesk software license agreement, without fee.
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND. AUTODESK
// DOES NOT MAKE AND HEREBY DISCLAIMS ANY EXPRESS OR IMPLIED WARRANTIES
// INCLUDING, BUT NOT LIMITED TO, THE WARRANTIES OF NON-INFRINGEMENT,
// MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE, OR ARISING FROM A COURSE 
// OF DEALING, USAGE, OR TRADE PRACTICE. IN NO EVENT WILL AUTODESK AND/OR ITS
// LICENSORS BE LIABLE FOR ANY LOST REVENUES, DATA, OR PROFITS, OR SPECIAL,
// DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES, EVEN IF AUTODESK AND/OR ITS
// LICENSORS HAS BEEN ADVISED OF THE POSSIBILITY OR PROBABILITY OF SUCH DAMAGES.

//
//
//  Creation Date:  May 26, 2000
//
//  Description:
//      This script is used to determine which channel is being driven
//		by the animation curves that make up a clip (or pose).
//
//  Input Arguments:
//      Either the an animation curve associated with a clip, or the
//		input plug on a clipLibrary that is attached to a clip animCurve.
//		
//  Return Value:
//      The associated plug that is being driven by this channel.
//		If no associated plug is found, an empty string is returned.
//
proc int indexForString(string $str)
//
// Given a string that contains a [xx], return the index xx
{
	string $buffer[], $buffer2[];
	tokenize($str,"[",$buffer);
	if (size($buffer) != 2) {
		return(-1);
	}
	tokenize($buffer[1],"]",$buffer2);
	return $buffer2[0];
}


global proc string characterMemberForClipChannel(string $channel)
{
	string $result = "";

	string $libPlug = $channel;

	string $buffer[], $buffer2[];
	// If input is an animCurve, find the associated clipLibrary
	//
	$buffer = `ls -type animCurve $channel`;
	if (size($buffer)) {
		$buffer2 = `listConnections -type clipLibrary -p true $channel`;
		if (size($buffer2)) {
			$libPlug = $buffer2[0];
		}
	}

	// library plug on clips is of the form:
	//   library.clipEvalList[0].clipEval[0].clipEval_Raw
	//
	tokenize($libPlug,".",$buffer);
	if (size($buffer) == 4) {
		// First find the associated clip
		//
		int $clipIndex = indexForString($buffer[1]);
		int $charIndex = indexForString($buffer[2]);		
		if (-1 != $clipIndex && -1 != $charIndex) {
			string $sourceClip[] = `listConnections -type animClip ($buffer[0]+".start["+$clipIndex+"]")`;
			if (size($sourceClip) > 0) {
				string $character[] = `clip -q -character $sourceClip[0]`;
				if (size($character)) {
					string $member = `character -mi $charIndex -q $character[0]`;
					if ($member != "") {
						$buffer = `listConnections -p true -s 0 -d 1 $member`;
						if (size($buffer)) {
							$result = $buffer[0];
						}
					}
				}
			}
		}
	}
	return $result;
}
