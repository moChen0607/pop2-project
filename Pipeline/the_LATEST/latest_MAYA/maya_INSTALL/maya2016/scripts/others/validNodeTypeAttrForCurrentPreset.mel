// Copyright (C) 1997-2014 Autodesk, Inc., and/or its licensors.
// All rights reserved.
//
// The coded instructions, statements, computer programs, and/or related
// material (collectively the "Data") in these files contain unpublished
// information proprietary to Autodesk, Inc. ("Autodesk") and/or its licensors,
// which is protected by U.S. and Canadian federal copyright law and by
// international treaties.
//
// The Data is provided for use exclusively by You. You have the right to use,
// modify, and incorporate this Data into other products for purposes authorized 
// by the Autodesk software license agreement, without fee.
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND. AUTODESK
// DOES NOT MAKE AND HEREBY DISCLAIMS ANY EXPRESS OR IMPLIED WARRANTIES
// INCLUDING, BUT NOT LIMITED TO, THE WARRANTIES OF NON-INFRINGEMENT,
// MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE, OR ARISING FROM A COURSE 
// OF DEALING, USAGE, OR TRADE PRACTICE. IN NO EVENT WILL AUTODESK AND/OR ITS
// LICENSORS BE LIABLE FOR ANY LOST REVENUES, DATA, OR PROFITS, OR SPECIAL,
// DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES, EVEN IF AUTODESK AND/OR ITS
// LICENSORS HAS BEEN ADVISED OF THE POSSIBILITY OR PROBABILITY OF SUCH DAMAGES.

//
//
//
//  Creation Date:  2001 
//


global string	$gAEAttrPresetExcludeAttrs[] = {
	// for now simply reject doubleSided: bug159621
	// Eventually this could check for membership in attribute
	// groupings for selective loading of attributes
	"doubleSided",
	"rotateQuaternionX",
	"rotateQuaternionY",
	"rotateQuaternionZ",
	"rotateQuaternionW",
	"outStippleThreshold",
	"face",
	"boundary",
	"currentDisplayLayer",
	"useComponentPivot",
	"currentRenderLayer",	// layer needs to exist
	"springStiffness",
	"springDamping",
	"springRestLength",
	"caching",
	"overridePlayback",
	"overrideEnabled",
	"playFromCache",
	"nodeState"
};
global string	$gAEAttrPresetExcludeNodeAttrs[] = {
	"timeToUnitConversion.output",	// should be output-only
	"unitToTimeConversion.output",
	"oceanShader.outFoam",
	"solidNoise.outColorR",
	"solidNoise.outColorG",
	"solidNoise.outColorB",
	"solidNoise.outAlpha",
	"joint.rotatePivotX",			// normalised, so they affect one another
	"joint.rotatePivotY",
	"joint.rotatePivotZ",
	"hikFKJoint.rotatePivotX",
	"hikFKJoint.rotatePivotY",
	"hikFKJoint.rotatePivotZ",
	"samplerInfo.normalCameraX",	// normalised, so they affect one another
	"samplerInfo.normalCameraY",
	"samplerInfo.normalCameraZ",
	"samplerInfo.rayDirectionX",	// normalised, so they affect one another
	"samplerInfo.rayDirectionY",
	"samplerInfo.rayDirectionZ",
	"airField.maxDistance",		// can be set below their minimum value by presets
	"dragField.maxDistance",
	"gravityField.maxDistance",
	"newtonField.maxDistance",
	"radialField.maxDistance",
	"turbulenceField.maxDistance",
	"uniformField.maxDistance",
	"volumeAxisField.maxDistance",
	"vortexField.maxDistance",
	"torusField.maxDistance",
	"FurFeedback.realUSamples",	// dynamic/internal, affected by other attributes
	"FurFeedback.realVSamples",
	"globalStitch.updateSampling", // reset by the 'sampling' attribute
	"fluidShape.controlPoints.xValue",
	"fluidShape.controlPoints.yValue",
	"fluidShape.controlPoints.zValue",
	"fluidShape.weights",
	"fluidShape.seed",
	"stroke.pathCurve.samples", // because these depend on the actual curve thats connected
	"stroke.pathCurve.opposite",
	"cpStitcher.outputPropertyChangeNotify",
	"cpStitcher.outputCreaseAngleChangeNotify",
	"nCloth.collisionDamp",
	"nCloth.collisionDampMap",
	"nCloth.collisionDampPerVertex",
	"nCloth.collisionDampMapType",
	"nCloth.displayThickness",
	"nCloth.numDampingIterations",
	"nCloth.numSelfCollisionIterations",
	"nCloth.numSelfCollisionSubcycles",
	"nCloth.sphereTree",
	"nCloth.numStretchIter",
	"nCloth.maxStretchIter",
	"nCloth.stretchSubcycles",
	"nCloth.numBendIter",
	"nCloth.linksTension",
	"nCloth.numShearIter",
	"nCloth.numRigidityIterations",
	"nCloth.selfCrossoverCheck",
	"nCloth.newStretchModel",
	"nCloth.selfCollisionThicknessScale",
	"nCloth.pressureStrength",
	"nCloth.betterVolumeConserve",
	"nCloth.maxPressureIter",
	"nCloth.solverOverride",
	"nCloth.gravity",
	"nCloth.gravityDirectionX",
	"nCloth.gravityDirectionY",
	"nCloth.gravityDirectionZ",
	"nCloth.dragOffset",
	"nCloth.windSpeed",
	"nCloth.windDirectionX",
	"nCloth.windDirectionY",
	"nCloth.windDirectionZ",
	"nCloth.collisionDrag"
};

// Decide which parameters we will use from the current preset.  
// If the attribute is in the excluded attrs list above, or 
// the type.attr string is in the excluded node.attrs list above,
// this attribute will neither be SAVED to a preset file *or*
// READ back in from a preset file.
// 
global proc int validNodeTypeAttrForCurrentPreset( string $type, 
												   string $attr ) 
{
	global string $gAEAttrPresetExcludeAttrs[];
	global string $gAEAttrPresetExcludeNodeAttrs[];

	string $oldAttr = "";
	int    $i;

	// For the purposes of matching the above string
	// arrays, we should strip off any multi indexing
	// from the attr names.  Paranoia of a pathological
	// test case causing an infinite loop means we're
	// capping the multi parent hierarchy at 10 levels...
	//
	for( $i = 0; $oldAttr != $attr && $i < 10; $i++ ) {
		// This is our loop control.
		//
		$oldAttr = $attr;

		// For the following example: parent[1].child[2].x
		// we'd loop through three times with these results
		// after each execution of the following substitution.
		// 
		// 	1) $oldAttr = parent[1].child[2].x
		//     $attr    = parent.child[2].x
		// 	2) $oldAttr = parent.child[2].x
		//     $attr    = parent.child.x
		// 	3) $oldAttr = parent.child.x
		//     $attr    = parent.child.x
		// 
		$attr = substitute( "\\[[0-9]*\\]", $attr, "" );
	} 

	// Check attributes regardless of node type.
	//
	if (stringArrayCount($attr, $gAEAttrPresetExcludeAttrs) > 0) {
		return 0;
	}

	// Check attributes with specific node types.
	//
	string $excludeNodeAttr = $type + "." + $attr;
	if (stringArrayCount($excludeNodeAttr, $gAEAttrPresetExcludeNodeAttrs) > 0) {
		return 0;
	}

	return 1;
}
