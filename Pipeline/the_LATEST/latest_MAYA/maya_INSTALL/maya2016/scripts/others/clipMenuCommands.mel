// Copyright (C) 1997-2014 Autodesk, Inc., and/or its licensors.
// All rights reserved.
//
// The coded instructions, statements, computer programs, and/or related
// material (collectively the "Data") in these files contain unpublished
// information proprietary to Autodesk, Inc. ("Autodesk") and/or its licensors,
// which is protected by U.S. and Canadian federal copyright law and by
// international treaties.
//
// The Data is provided for use exclusively by You. You have the right to use,
// modify, and incorporate this Data into other products for purposes authorized 
// by the Autodesk software license agreement, without fee.
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND. AUTODESK
// DOES NOT MAKE AND HEREBY DISCLAIMS ANY EXPRESS OR IMPLIED WARRANTIES
// INCLUDING, BUT NOT LIMITED TO, THE WARRANTIES OF NON-INFRINGEMENT,
// MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE, OR ARISING FROM A COURSE 
// OF DEALING, USAGE, OR TRADE PRACTICE. IN NO EVENT WILL AUTODESK AND/OR ITS
// LICENSORS BE LIABLE FOR ANY LOST REVENUES, DATA, OR PROFITS, OR SPECIAL,
// DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES, EVEN IF AUTODESK AND/OR ITS
// LICENSORS HAS BEEN ADVISED OF THE POSSIBILITY OR PROBABILITY OF SUCH DAMAGES.

//
//  Methods called from the trax and visor popup menus.
//
global proc clipApplyPoseMenuCommand(string $clip)
{
	string $character[] = `clip -q -ch $clip`;
	if (size($character) > 0)
	{
		// apply the clip
		for ($c in $character) {
			string $poseCmd = ("pose -apply -name "+$clip+" "+$c);
			evalEcho($poseCmd);
		}
	} else {
		string $errorStr = (uiRes("m_clipMenuCommands.kNotAttachedToChar"));
		error(`format -s $clip $errorStr`);
	}
}


global proc
clipDuplicateMenuCommand(string $clip)
{
	string $characters[] = `clip -q -ch $clip`;
	string $topCharacters[];
	if (size($characters) > 0)
	{
		// Schedule an duplicate of the clip at the current time
		//
		string $curTime = `currentTime -query`;
		
		if (size($characters) == 1) {
			$topCharacters[0] = $characters[0];
		} else {
			// find the top level characters, duplicating them
			// will also duplicate their subcharacters so we do not
			// need to duplicate the subcharacters on their own
			//
			int $isSubCharacter[];
			int $ii, $jj;
			int $charCount = size($characters);
			for ($ii = 0; $ii < $charCount; $ii++) {
				$isSubCharacter[$ii] = 0;
				for ($jj = 0; $jj < $charCount; $jj++) {
					if ($ii == $jj) continue;
					if (`character -isMember $characters[$jj] $characters[$ii]`)
					{
						$isSubCharacter[$ii] = 1;
						break;
					}
				}
				if (0 == $isSubCharacter[$ii]) {
					$topCharacters[size($topCharacters)] = $characters[$ii];
				}
			}
		}
			
		// duplicate the clip
		//
		for ($c in $topCharacters) {
			string $cmd = ("clip -startTime "+$curTime);
			$cmd += (" -duplicate -name "+$clip+" "+$c);
			evalEcho $cmd;
		}
	} else {
		string $errorStr = uiRes("m_clipMenuCommands.kNotAttachedToChar");
		error(`format -s $clip $errorStr`);
	}
}

global proc
clipInstanceMenuCommand( string $source )
{
	string $characters[] = `clip -q -ch $source`;
	if (size($characters) == 0)
	{
		string $errorStr = uiRes("m_clipMenuCommands.kNotAttachedToChar");
		error(`format -s $source $errorStr`);
	}

	string $curTime = `currentTime -query`;

	// Schedule an instance of the clip.
	for ( $character in $characters ) 
	{
		string $sch  = `character -q -sc $character`;
		string $cmd  = `format -s $curTime -s $source -s $sch "clipSchedule -start ^1s -allAbsolute -in ^2s ^3s"`;
		string $clip = eval( $cmd );
		ghostAppendedClip $sch { $clip, $clip } 0;
	}
}

global proc
clipCopyMenuCommand(string $clip)
{
	string $cmdString = ("clip -copy "+$clip);
	evalEcho($cmdString);
}
