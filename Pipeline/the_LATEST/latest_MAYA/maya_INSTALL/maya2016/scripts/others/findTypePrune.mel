// Copyright (C) 1997-2014 Autodesk, Inc., and/or its licensors.
// All rights reserved.
//
// The coded instructions, statements, computer programs, and/or related
// material (collectively the "Data") in these files contain unpublished
// information proprietary to Autodesk, Inc. ("Autodesk") and/or its licensors,
// which is protected by U.S. and Canadian federal copyright law and by
// international treaties.
//
// The Data is provided for use exclusively by You. You have the right to use,
// modify, and incorporate this Data into other products for purposes authorized 
// by the Autodesk software license agreement, without fee.
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND. AUTODESK
// DOES NOT MAKE AND HEREBY DISCLAIMS ANY EXPRESS OR IMPLIED WARRANTIES
// INCLUDING, BUT NOT LIMITED TO, THE WARRANTIES OF NON-INFRINGEMENT,
// MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE, OR ARISING FROM A COURSE 
// OF DEALING, USAGE, OR TRADE PRACTICE. IN NO EVENT WILL AUTODESK AND/OR ITS
// LICENSORS BE LIABLE FOR ANY LOST REVENUES, DATA, OR PROFITS, OR SPECIAL,
// DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES, EVEN IF AUTODESK AND/OR ITS
// LICENSORS HAS BEEN ADVISED OF THE POSSIBILITY OR PROBABILITY OF SUCH DAMAGES.

//
//
//  Creation Date:  2007
//
//	Description:
//		Given a node, find one of type $type that is the closest traversal in
//	either its past or future. While doing the search, prune any nodes that can
//	only be reached by visiting a node of type specified in $pruneTypes
//
//

global proc string findTypePrune(	string $obj,			// Starting node
									string $type,			// Type to find
									string $pruneTypes[] )	// prune types
//
//	Description:
//		Given a node, find one of type $type in either its past or future.
//	While doing the search, prune any nodes that can only be reached by
//	visiting a node of type specified in $pruneTypes
//
{
	// In the case that the object type exists in both past and future
	// find the one that is fewer connections away. Technically, this may not
	// be quite true, depending on the level of branching of past vs future,
	// but close enough.
	//
	string $past[] = pruneSearch( $obj, false, $pruneTypes );
	string $pastObjs[] = `ls -type $type $past`;

	string $future[] = pruneSearch( $obj, true, $pruneTypes );
	string $futureObjs[] = `ls -type $type $future`;

	int $numPast = size( $pastObjs );
	int $numFuture = size( $futureObjs );

	if($numPast>0){
		if( $numFuture > 0) {
			int $i;
			int $min = size($future);
			if( size($past) < $min ){
				$min = size($past);
			}
			for( $i = 0; $i <  $min; $i++){
				if( $past[$i] == $pastObjs[0] ){
					return $pastObjs[0];
				}
				if( $future[$i] == $futureObjs[0] ){
					return $futureObjs[0];
				}
			}
		} else {
			return $pastObjs[0];
		}
	} else if( $numFuture > 0) {
		return $futureObjs[0];
	}
	return("");
}

