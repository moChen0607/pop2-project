// Copyright (C) 1997-2014 Autodesk, Inc., and/or its licensors.
// All rights reserved.
//
// The coded instructions, statements, computer programs, and/or related
// material (collectively the "Data") in these files contain unpublished
// information proprietary to Autodesk, Inc. ("Autodesk") and/or its licensors,
// which is protected by U.S. and Canadian federal copyright law and by
// international treaties.
//
// The Data is provided for use exclusively by You. You have the right to use,
// modify, and incorporate this Data into other products for purposes authorized 
// by the Autodesk software license agreement, without fee.
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND. AUTODESK
// DOES NOT MAKE AND HEREBY DISCLAIMS ANY EXPRESS OR IMPLIED WARRANTIES
// INCLUDING, BUT NOT LIMITED TO, THE WARRANTIES OF NON-INFRINGEMENT,
// MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE, OR ARISING FROM A COURSE 
// OF DEALING, USAGE, OR TRADE PRACTICE. IN NO EVENT WILL AUTODESK AND/OR ITS
// LICENSORS BE LIABLE FOR ANY LOST REVENUES, DATA, OR PROFITS, OR SPECIAL,
// DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES, EVEN IF AUTODESK AND/OR ITS
// LICENSORS HAS BEEN ADVISED OF THE POSSIBILITY OR PROBABILITY OF SUCH DAMAGES.

//
//
//  Creation Date:  April 18, 1997
//
//  Description:
//      This script is defines the option box for the bevel surface menu item.
//
//  Input Arguments:
//      int action
//		  0 - show the option box dialog
//        1 - just execute the bevel operation
//
//  Return Value:
//      None.
//


proc setOptionVars (int $forceFactorySettings)
{
    bevelSetOptionVars( $forceFactorySettings );
}

global proc bevelVisibility()
//  Description:
//		Dim/show any bevel options as required by the number of edges
//		to bevel.
//
{
	int $nedges = 4;
	int $val = `radioButtonGrp -q -select bevelTopBottomRadioOptions`;
	if ( $val == 1 ) $nedges = 2;
	else if ( $val == 2 ) $nedges = 3;
	else if ( $val == 0 ) 
	{
		$val = `radioButtonGrp -q -select bevelBothOffRadioOptions`;
		if( $val == 1 ) $nedges = 4;
		else $nedges = 1;
	}

	if ( $nedges == 1 )
	{
		// dim all the options for bevel so that extrude is only left
		//
		checkBoxGrp -e -en 0 bevelJoinSrfBox;
		floatSliderGrp -e -en 0 bevelWidthFloatField;
		floatSliderGrp -e -en 0 bevelDepthFloatField;
		radioButtonGrp -e -en 0 bevelCornerRadioButtonGrp;
		radioButtonGrp -e -en 0 bevelEdgesRadio;
	}
	else
	{
		// show all the options for bevel
		//
		checkBoxGrp -e -en 1 bevelJoinSrfBox;
		floatSliderGrp -e -en 1 bevelWidthFloatField;
		floatSliderGrp -e -en 1 bevelDepthFloatField;
		radioButtonGrp -e -en 1 bevelCornerRadioButtonGrp;
		radioButtonGrp -e -en 1 bevelEdgesRadio;
	}
}

proc createBevelUI( string $parent, int $inTheTool, string $goToTool )
//
//	Description :
//		Bevel operation options
//
{
	setParent $parent ;

	// layout for bevel options.
	//
	checkBoxGrp -ncb 1 -label "" -label1 (uiRes("m_performBevel.kAttachSurfaces"))  -v1 on bevelJoinSrfBox;

	radioButtonGrp -nrb 2 -label (uiRes("m_performBevel.kBevel")) 
		-label1 (uiRes("m_performBevel.kTopSide"))  -da1 2
		-label2 (uiRes("m_performBevel.kBottomSide"))  -da2 3
		-cc "bevelVisibility"
		bevelTopBottomRadioOptions;

	radioButtonGrp -nrb 2 -label "" -scl bevelTopBottomRadioOptions
		-label1 (uiRes("m_performBevel.kBoth"))  -da1 4
		-label2 (uiRes("m_performBevel.kOff"))  -da2 1
		-cc "bevelVisibility"
		bevelBothOffRadioOptions;

	separator;

	floatSliderGrp -label (uiRes("m_performBevel.kBevelWidth")) 
		-min 0.00001 -max 1.0 -fmn -10000.0 -fmx 10000.0
		bevelWidthFloatField;
	floatSliderGrp -label (uiRes("m_performBevel.kBevelDepth")) 
		-min 0.00001 -max 1.0 -fmn -10000.0 -fmx 10000.0
		bevelDepthFloatField;
	floatSliderGrp -label (uiRes("m_performBevel.kExtrudeHeight")) 
		-min 0.00001 -max 1.0 -fmn -10000.0 -fmx 10000.0
		extrudeDepthFloatField;

	radioButtonGrp -nrb 2 -select 1 -label (uiRes("m_performBevel.kBevelCorners")) 
		-label1 (uiRes("m_performBevel.kStraightCorner"))  -da1 1
		-label2 (uiRes("m_performBevel.kCircularArcs"))  -da2 2
		bevelCornerRadioButtonGrp;

	radioButtonGrp -nrb 3
		-label (uiRes("m_performBevel.kBevelCapEdge")) 
		-label1 (uiRes("m_performBevel.kConvex")) 
		-label2 (uiRes("m_performBevel.kConcave")) 
		-label3 (uiRes("m_performBevel.kStraight")) 
		bevelEdgesRadio;

	separator;

	// layout for add curve range, create as polygons.
    //
   radioButtonGrp -nrb 2 -label (uiRes("m_performBevel.kUseTolerance")) 
	   -label1 (uiRes("m_performBevel.kGlobal")) 
	   -label2 (uiRes("m_performBevel.kLocal")) 
	   -on1 "tabLayout -e -vis false useGlobalTolTab"
	   -on2 "tabLayout -e -vis true useGlobalTolTab"
	   useGlobalTol;

   tabLayout -tabsVisible false useGlobalTolTab;
	   columnLayout showSlider;
			floatSliderGrp -label (uiRes("m_performBevel.kTolerance")) 
		 		-min 0.00001 -max 1.0 -fmn 0.00001 -fmx 1000.0
				bevelToleranceFloatField;
	   setParent ..;
   setParent ..;

   separator;

	radioButtonGrp -nrb 2 -label (uiRes("m_performBevel.kCurveRange"))
		-label1 (uiRes("m_performBevel.kComplete")) -da1 0
		-label2 (uiRes("m_performBevel.kPartial")) -da2 1 -select 1
		curveRangeRadioButtonGrp;

	string $outputGeometry = (uiRes("m_performBevel.kOutputGeometry"));
	string $nurbs          = (uiRes("m_performBevel.kNurbs"));
	string $polygons       = (uiRes("m_performBevel.kPolygons"));
	string $bezier         = (uiRes("m_performBevel.kBezier"));
	if( `isTrue "SubdivUIExists"` && `isTrue "SurfaceUIExists"` ) {
		radioButtonGrp -nrb 4 -label $outputGeometry
		  -label1 $nurbs -da1 0
		  -label2 $polygons -da2 1 -select 1
		  -label3 (uiRes("m_performBevel.kSubdiv")) -da3 1
		  -label4 $bezier -da4 1
		  -cc1 "tabLayout -e -vis false bevelPolyOptions"	// there are currently no NURBS options
		  -cc2 "tabLayout -e -vis true bevelPolyOptions"
		  -cc3 "tabLayout -e -vis false bevelPolyOptions"	// there are currently no subdiv options
		  -cc4 "tabLayout -e -vis false bevelPolyOptions"	// there are currently no bezier options
		  outputPolyRadioButtonGrp;
	}
	else if( `isTrue "SurfaceUIExists"` ) {
		radioButtonGrp -nrb 3 -label $outputGeometry
		  -label1 $nurbs -da1 0
		  -label2 $polygons -da2 1 -select 1
		  -label3 $bezier -da3 1
		  -cc1 "tabLayout -e -vis false bevelPolyOptions"	// there are currently no NURBS options
		  -cc2 "tabLayout -e -vis true bevelPolyOptions"
		  -cc3 "tabLayout -e -vis false bevelPolyOptions"	// there are currently no bezier options
		  outputPolyRadioButtonGrp;
	}

	separator;

	tabLayout -tabsVisible false bevelPolyOptions;
	  string $par = `columnLayout bevelPolyOptionsOK`;
		nurbsToPolyAddOptions $par;
	  setParent ..;
	setParent ..;

	if( $inTheTool ) {
		separator;
		checkBoxGrp -ncb 2 -label (uiRes("m_performBevel.kToolBehavior")) 
		  -label1 (uiRes("m_performBevel.kExitOnCompletion")) 
		  -v1 off
		  -on1 ("scriptCtx -e -euc true " + $goToTool)
		  -of1 ("scriptCtx -e -euc false " + $goToTool)

		  -label2 (uiRes("m_performBevel.kAutoCompletion")) 
		  -v2 on
		  -on2 ("scriptCtx -e -lac true " + $goToTool)
		  -of2 ("scriptCtx -e -lac false " + $goToTool)
		  scriptToolExtraWidget;
	}
}

proc string assembleCmd()
//
//	Description :
//		To assemble bevel proc.
//
{
	setOptionVars(false);
	string $cmd = "bevelPreset"  ;
	$cmd = $cmd + "(" ;  

	int $history = `constructionHistory -q -tgl`;
	$cmd = $cmd + $history ;  
	$cmd = $cmd + "," ;  

	int $curveRangePartial = `optionVar -q bevelCurveRangePartial` ;
	$cmd = $cmd + $curveRangePartial ;  
	$cmd = $cmd + "," ;  

	int $polygons = `optionVar -q bevelOutputPolygons` ;
	if( !`isTrue "SurfaceUIExists"` ) $polygons = 1;
	$cmd = $cmd + $polygons ;  
	$cmd = $cmd + "," ;  

	float $tol = `optionVar -q bevelTolerance` ;
	if( `optionVar -q bevelUseGlobalTol` ) {
		$tol = `optionVar -q positionalTolerance`;
	}
	$cmd = $cmd + $tol ;  
	$cmd = $cmd + "," ;
  
	int $bevelJoin = `optionVar -q bevelAttachSurfaces` ;
	$cmd = $cmd + $bevelJoin ;  
	$cmd = $cmd + "," ;  

	int $bevelSides = `optionVar -q bevelNSides` ;
	$cmd = $cmd + $bevelSides ;  
	$cmd = $cmd + "," ;  

	float $bevelWidth = `optionVar -q bevelWidth` ;
	$cmd = $cmd + $bevelWidth ;  
	$cmd = $cmd + "," ;  

	float $bevelDepth = `optionVar -q bevelDepth` ;
	$cmd = $cmd + $bevelDepth ;
	$cmd = $cmd + "," ;  

	float $bevelExtrudeHt = `optionVar -q bevelExtrudeHeight` ;
	$cmd = $cmd + $bevelExtrudeHt ;  
	$cmd = $cmd + "," ;  

	int $bevelCorner = `optionVar -q bevelCorner` ;
	$cmd = $cmd + $bevelCorner ;  
	$cmd = $cmd + "," ;  

	int $bevelCapEdge = `optionVar -q bevelCapEdge` ;
	$cmd = $cmd + $bevelCapEdge ;  
	$cmd = $cmd + ")" ;  

	return $cmd ;
}

proc bevelOptions( int $inTheTool, string $goToTool )
{
	//	Name of the command for this option box.
	//
	string $commandName = "bevel";

	//	Build the option box actions.
	//
	string $callback = ($commandName + "Callback");
	string $setup = ($commandName + "Setup");

	global string $gOptionBoxActionToolItem;
	$gOptionBoxActionToolItem = "modelWithToolBevel";
	global string $gOptionBoxActionToolItemCB;
	$gOptionBoxActionToolItemCB = "bevelToolScript 3";

	//	Step 1:  Get the option box.
	//	============================
	string $layout = getOptionBox();
	setParent $layout;
	
	//	Step 2:  Pass the command name to the option box.
	//	=================================================
	setOptionBoxCommandName($commandName);
	
	//	Step 3:  Activate the default UI template.
	//	==========================================
	setUITemplate -pushTemplate DefaultTemplate;

	//	Step 4: Create option box contents.
	//	===================================
	
	//	Turn on the wait cursor.
	//
	waitCursor -state 1;

	tabLayout -scr true -tv false;
	
	string $parent = `columnLayout -adjustableColumn 1`;
	
	createBevelUI( $parent, $inTheTool, $goToTool );

	//	Turn off the wait cursor.
	//
	waitCursor -state 0;
	
	//	Step 5: Deactivate the default UI template.
	//  ===========================================
	//
	setUITemplate -popTemplate;

	//	Step 6: Customize the buttons.  
	//	==============================

	//	'Apply' button.
	//
	string $applyBtn = getOptionBoxApplyBtn();
	if( $inTheTool ) {
		button -edit -label (uiRes("m_performBevel.kBevelTool")) 
		  -command ($callback + " " + $parent + " 3 \"" + $goToTool + "\"")
		  $applyBtn;
	}
	else {
		button -edit -label (uiRes("m_performBevel.kBevelButton")) 
		  -command ($callback + " " + $parent + " 1 \"" + $goToTool + "\"")
		  $applyBtn;
	}

	//	'Save' button.
	//
	string $saveBtn = getOptionBoxSaveBtn();
	button -edit 
		-command ($callback + " " + $parent + " 0 \"" +
				  $goToTool + "\"; hideOptionBox")
		$saveBtn;

	//	'Reset' button.
	//
	string $resetBtn = getOptionBoxResetBtn();
	button -edit 
		-command ($setup + " " + $parent + " 1 \"" + $goToTool + "\"")
		$resetBtn;

	//	Step 7: Set the option box title.
	//	=================================
	//
	if( $inTheTool ) {
		setOptionBoxTitle (uiRes("m_performBevel.kBevelToolOptions"));
	}
	else {
		setOptionBoxTitle (uiRes("m_performBevel.kBevelOptions"));
	}

	//	Step 8: Customize the 'Help' menu item text.
	//	============================================
	//
	setOptionBoxHelpTag( "Bevel" );

	//	Step 9: Set the current values of the option box.
	//	=================================================
	//
	eval ($setup + " " + $parent + " 0 \"" + $goToTool + "\"");	
	
	//	Step 10: Show the option box.
	//	=============================
	//
	showOptionBox();
}

proc string bevelHelp()
{
	string $cmdHelp = "Command: Bevel - creates a bevelled surface. \n " ;
	string $selectHelp = "Selection: Select a curve or surface isoparm or curve on surface to bevel " ;
    return $cmdHelp+$selectHelp ;
}

global proc bevelSetup( string $parent,
						int $forceFactorySettings,
						string $goToTool)
{
	// retrieve option settings.
	//
	setOptionVars($forceFactorySettings);	
	bevelToolSetup( $forceFactorySettings, $goToTool );

	setParent $parent;	

	// query and set controls for all the option vars.
	//
	float $bwidth = `optionVar -q bevelWidth` ;
	floatSliderGrp -e -v $bwidth bevelWidthFloatField ;
	if( $forceFactorySettings ) {
		floatSliderGrp -e
			-min 0.00001 -max 1.0 -fmn -10000.0 -fmx 10000.0
			bevelWidthFloatField ;
	}

	// bevel depth.
	//
	float $bdepth = `optionVar -q bevelDepth` ;
	floatSliderGrp -e -v $bdepth bevelDepthFloatField ;
	if( $forceFactorySettings ) {
		floatSliderGrp -e
			-min 0.00001 -max 1.0 -fmn -10000.0 -fmx 10000.0
			bevelDepthFloatField;
	}

	// extrude height.
	//
	float $edepth = `optionVar -q bevelExtrudeHeight` ;
	floatSliderGrp -e -v $edepth extrudeDepthFloatField ;
	if( $forceFactorySettings ) {
		floatSliderGrp -e
			-min 0.00001 -max 1.0 -fmn -10000.0 -fmx 10000.0
			extrudeDepthFloatField;
	}

	// global vs. local tolerance.
	int $useGlobalTol = `optionVar -q bevelUseGlobalTol`;
	radioButtonGrp -e -select (2 - $useGlobalTol) useGlobalTol;

	// bevel tolerance.
	//
	float $tol = `optionVar -q bevelTolerance` ;
	floatSliderGrp -e -v $tol bevelToleranceFloatField ;
	if( $forceFactorySettings ) {
		floatSliderGrp -e
			-min 0.00001 -max 1.0 -fmn 0.00001 -fmx 1000.0
			bevelToleranceFloatField;
	}

	if( $useGlobalTol == 1 ) {
		tabLayout -e -vis false useGlobalTolTab;
	}
	else {
		tabLayout -e -vis true useGlobalTolTab;
	}

	// attach the surfaces.
	//
	int $attach = `optionVar -q bevelAttachSurfaces` ;

	if( $attach == 1 ) {
		checkBoxGrp -edit -v1 true bevelJoinSrfBox  ;
	} else {
		checkBoxGrp -edit -v1 0 bevelJoinSrfBox  ;
	}

	// bevel corner.
	//
	int $bcorner = `optionVar -q bevelCorner`;
	radioButtonGrp -edit -select $bcorner bevelCornerRadioButtonGrp ;		
	
	// cap.
	//	
	int $bcap = `optionVar -q bevelCapEdge` ;

	if( $bcap == 1 ) {
		radioButtonGrp -edit -select 3 bevelEdgesRadio ;
	}
	else {
		radioButtonGrp -edit -select ($bcap-1) bevelEdgesRadio ;
	}

	// curve range on bevel inputs.
	//
	int $curveRangePartial = `optionVar -q bevelCurveRangePartial`+1 ;
	radioButtonGrp -edit -select $curveRangePartial curveRangeRadioButtonGrp ;

	// polygon output.
	//
	int $polygons = `optionVar -q bevelOutputPolygons`;
	if( `isTrue "SurfaceUIExists"` ) {
		if( `isTrue "SubdivUIExists"` && (3 != $polygons)) {
			radioButtonGrp -edit -select ($polygons+1)
				outputPolyRadioButtonGrp;
		}
		else {
			radioButtonGrp -edit -select 3 outputPolyRadioButtonGrp;
		}
	}
	else {
		$polygons = 1;
	}

	int $nedges = `optionVar -q bevelNSides` ;
	
	if( $nedges == 1 ) {
		int $ne = 2 ;
		radioButtonGrp -edit -select $ne bevelBothOffRadioOptions ;
	} else if( $nedges == 4 ) {
		int $ne = 1 ;
		radioButtonGrp -edit -select $ne bevelBothOffRadioOptions ;
	} else if( $nedges == 3 ) {
		int $ne = 2 ;
		radioButtonGrp -edit -select $ne bevelTopBottomRadioOptions ;
	} else if( $nedges == 2 ) {
		int $ne = 1 ;
		radioButtonGrp -edit -select $ne bevelTopBottomRadioOptions ;
	}

	// dim/show any options as required
	//
	bevelVisibility();

	switch( $polygons ) {
	  case 0:
	  default:
		tabLayout -e -vis false bevelPolyOptions;	// there are currently no NURBS options
		break;
	  case 1:
		tabLayout -e -vis true bevelPolyOptions;
		break;
	  case 2:
		tabLayout -e -vis false bevelPolyOptions;	// there are currently no subdiv options
		break;
	}

	if( "" != $goToTool ) { 
		checkBoxGrp -e -v1 `scriptCtx -q -euc $goToTool`
		  scriptToolExtraWidget;
		checkBoxGrp -e -v2 `scriptCtx -q -lac $goToTool`
		  scriptToolExtraWidget;
	}

	nurbsToPolySetup( $parent, $forceFactorySettings );
	nurbsToSubdivSetup( $parent, $forceFactorySettings );
}

global proc bevelCallback( string $parent, int $doIt, string $goToTool )
{
	if( "" != $goToTool ) {
		optionVar -iv bevelEuc `scriptCtx -q -euc $goToTool`;
		optionVar -iv bevelLac `scriptCtx -q -lac $goToTool`;
	}

	setParent $parent ;

	// get Values from controls.
	//
	int $curveRangePartial = `radioButtonGrp -q -select curveRangeRadioButtonGrp` - 1 ;
	optionVar -intValue bevelCurveRangePartial $curveRangePartial ;

	if( `isTrue "SurfaceUIExists"` ) {
		int $polys = `radioButtonGrp -q -select outputPolyRadioButtonGrp`;
		if( (3 == $polys) && ! `isTrue "SubdivUIExists"` ) {
			$polys = 4;
		}
		optionVar -intValue bevelOutputPolygons ($polys-1) ;
	}

	// global vs. local
	int $useGlobalTol = 2 - `radioButtonGrp -q -select useGlobalTol`;
	optionVar -intValue bevelUseGlobalTol $useGlobalTol;

	float $value = `floatSliderGrp -q -v bevelToleranceFloatField` ;
	optionVar -floatValue bevelTolerance $value ;

	$value = `floatSliderGrp -q -v bevelWidthFloatField` ;
	optionVar -floatValue bevelWidth $value ;

	$value = `floatSliderGrp -q -v bevelDepthFloatField` ;
	optionVar -floatValue bevelDepth $value ;

	$value = `floatSliderGrp -q -v extrudeDepthFloatField` ;
	optionVar -floatValue bevelExtrudeHeight $value ;

	// attach surfaces or not.
	//
	int $val = `checkBoxGrp -q -v1 bevelJoinSrfBox` ;
	optionVar -intValue bevelAttachSurfaces $val ;

	// bevel corner type.
	//
	$val = `radioButtonGrp -q -select bevelCornerRadioButtonGrp` ;
	optionVar -intValue bevelCorner $val ;

	// bevel number of edges.
	//
	int $ne = 4 ;
	$val = `radioButtonGrp -q -select bevelTopBottomRadioOptions` ;
	if( $val == 1 ) $ne = 2 ;
	else if( $val == 2 ) $ne = 3 ;
	else if( $val == 0 ) {
		$val = `radioButtonGrp -q -select bevelBothOffRadioOptions` ;
		if( $val == 1 ) $ne = 4 ;
		else $ne = 1 ;
	}
	optionVar -intValue bevelNSides $ne ;

	int $nb = 1;
	$val = `radioButtonGrp -q -select bevelEdgesRadio`;
	if( $val < 3 ) {
		$nb = $val + 1;
	}
	optionVar -intValue bevelCapEdge $nb ;

	nurbsToPolyCallback( $parent, 0 );
	nurbsToSubdivCallback( $parent, 0 );

	if( 1 == $doIt ) {
		performBevel(0, $goToTool); 
		string $tmpCmd = "performBevel(0, \"" + $goToTool + "\")";
		addToRecentCommandQueue $tmpCmd "Bevel";
	}
	else if( $doIt ) {
		setToolTo $goToTool;
	}
}

global proc string performBevel( int $action, string $goToTool )
//
//	Description :
//		$action = 0 ==> do the command.
//		$action = 1 ==>show option box.
//		$action = 2 ==>drag to shelf.
//		$action = 3 ==>Show the tool option box
{
	int $inTheTool = false;
	if( 3 == $action ) {
		$action = 1;
		$inTheTool = true;
	}

	string $cmd = "" ;
	switch( $action ) {
	  case 0:
		$cmd = `assembleCmd` ;
		eval $cmd ;
		break ;
	  case 1:
		bevelOptions( $inTheTool, $goToTool );
		break ;
	  case 2:
	  default:
		$cmd = `assembleCmd` ;
		break ;
	}
	return $cmd ;
}

