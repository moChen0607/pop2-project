// Copyright (C) 1997-2014 Autodesk, Inc., and/or its licensors.
// All rights reserved.
//
// The coded instructions, statements, computer programs, and/or related
// material (collectively the "Data") in these files contain unpublished
// information proprietary to Autodesk, Inc. ("Autodesk") and/or its licensors,
// which is protected by U.S. and Canadian federal copyright law and by
// international treaties.
//
// The Data is provided for use exclusively by You. You have the right to use,
// modify, and incorporate this Data into other products for purposes authorized 
// by the Autodesk software license agreement, without fee.
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND. AUTODESK
// DOES NOT MAKE AND HEREBY DISCLAIMS ANY EXPRESS OR IMPLIED WARRANTIES
// INCLUDING, BUT NOT LIMITED TO, THE WARRANTIES OF NON-INFRINGEMENT,
// MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE, OR ARISING FROM A COURSE 
// OF DEALING, USAGE, OR TRADE PRACTICE. IN NO EVENT WILL AUTODESK AND/OR ITS
// LICENSORS BE LIABLE FOR ANY LOST REVENUES, DATA, OR PROFITS, OR SPECIAL,
// DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES, EVEN IF AUTODESK AND/OR ITS
// LICENSORS HAS BEEN ADVISED OF THE POSSIBILITY OR PROBABILITY OF SUCH DAMAGES.

//
//
//  Creation Date:  Nov, 1999
//
//  Procedure Name:
//      doCutClipArgList
//
//  Description:
//      Cut a clip
//
//  Input Arguments:
//  $version: The version of this option box.  Used to know how to 
//  interpret the $args array.
//
//  $args
//  Version 1
//  [0]     $name :  name of the clip window
//  Version 2
//  [1]     $clip :  specific clip to cut
//
global proc
doCutClipArgList( string $version, string $args[] )
{
	int $versionNo  = $version;
	string $clipWnd = $args[0];

	string $selClips[];
	if (($versionNo >= 2) && ($args[1] != "")) {
		$selClips[0] = $args[1];
	}
	else {
		$selClips = getSelectedClips("noOptions");
	}

	string $selBlends[] = getSelectedBlends();
	if (size($selBlends) > 0)
		error( (uiRes("m_doCutClipArgList.kNoClipboardForBlendsErr")) );

	if (size($selClips) == 0)
		error( (uiRes("m_doCutClipArgList.kSelectTheClipsErr")) );

	string $sch = "";

	for ($clip in $selClips)
	{
		if ($sch == "") {
			$sch = getClipScheduler($clip);
		} else if (getClipScheduler($clip) != $sch) {
			error( (uiRes("m_doCutClipArgList.kToPutClipsErr")) );
		}
	}

	string $copyCmd;
	if (($version == "2") && ($args[1] != "")) {
		$copyCmd = "doCopyClipArgList 2 {\"" + $clipWnd + "\", \"" + $args[1] + "\"}";
	}
	else {
		$copyCmd = "doCopyClipArgList 1 {\"" + $clipWnd + "\"}";
	}

	if (!catch(eval($copyCmd))) {
		for ($clip in $selClips) {
			// If the clip being deleted is ghosted, remove the ghost shape
			// from the scene.
			string $ghost = getGhostShapeForClip($clip);
			if (size($ghost))
				delete $ghost;

			int $clipIndex = getClipIndex($clip, $sch);
			string $cmdString = ("clipSchedule -rm -ci "+$clipIndex+" "+$sch);
			evalEcho $cmdString;
		}
	}

}
