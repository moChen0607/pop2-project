// Copyright (C) 1997-2014 Autodesk, Inc., and/or its licensors.
// All rights reserved.
//
// The coded instructions, statements, computer programs, and/or related
// material (collectively the "Data") in these files contain unpublished
// information proprietary to Autodesk, Inc. ("Autodesk") and/or its licensors,
// which is protected by U.S. and Canadian federal copyright law and by
// international treaties.
//
// The Data is provided for use exclusively by You. You have the right to use,
// modify, and incorporate this Data into other products for purposes authorized 
// by the Autodesk software license agreement, without fee.
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND. AUTODESK
// DOES NOT MAKE AND HEREBY DISCLAIMS ANY EXPRESS OR IMPLIED WARRANTIES
// INCLUDING, BUT NOT LIMITED TO, THE WARRANTIES OF NON-INFRINGEMENT,
// MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE, OR ARISING FROM A COURSE 
// OF DEALING, USAGE, OR TRADE PRACTICE. IN NO EVENT WILL AUTODESK AND/OR ITS
// LICENSORS BE LIABLE FOR ANY LOST REVENUES, DATA, OR PROFITS, OR SPECIAL,
// DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES, EVEN IF AUTODESK AND/OR ITS
// LICENSORS HAS BEEN ADVISED OF THE POSSIBILITY OR PROBABILITY OF SUCH DAMAGES.

// Utility funcs
proc connectIfNotConnected( string $src, string $dst )
{
	if ( `isConnected $src $dst` == false )
		connectAttr $src $dst;
}

proc disconnectIncoming( string $clipToGhost, string $attr )
{
	string $conns[] = `listConnections -s 1 -p 1 ( $clipToGhost + "." + $attr )`;
	for ( $c in $conns )
	{
		string $dest[] = `listConnections -s 0 -d 1 -p 1 $c`;
		if ( size($dest) )
			disconnectAttr $c $dest[0];
	}
}

proc disconnectOutgoing( string $clipToGhost, string $attr )
{
	// Disconnect outgoing connections from the clipToGhost node
	string $conns[] = `listConnections -d 1 -p 1 ( $clipToGhost + "." + $attr )`;
	for ( $c in $conns )
	{
		string $source[] = `listConnections -s 1 -d 0 -p 1 $c`;
		if ( size($source) )
			disconnectAttr $source[0] $c;
	}
}

// Main entry point/function

//
//  Procedure Name:
//      ghostReorderConnections
//
//  Description:
//      If clip are duplicated or split the number and ordering of
//      clips managed by the scheduler can change. Since connections
//      to/from the clipToGhost node are maintained in the same order
//      as the scheduler clip order, it can be necessary to rewire 
//      up nodes to ensure this ordering is preserved.
//      GhostReshuffleConnections takes care of doing this.
//
// Input Arguments:
//      $scheduler: The name of the scheduler
//
global proc ghostReorderConnections( string $scheduler )
{
	// Get the list of all clips managed by the scheduler
	string $clips[]    = `clipSchedule -q -name $scheduler`;
	int $nclips = size($clips); 
	if ( $nclips == 0 ) // If there are no clips, bail.
		return;

	// Otherwise, get the name of the clipToPGhost node for the scheduler ...
	string $clipToGhost = getClipToGhostForScheduler( $scheduler );
	if ( size( $clipToGhost ) == 0 )
		return;

	// ... disconnect existing connections in the ghost node n/w (since they may be stale)
	disconnectIncoming $clipToGhost "clipSourceStart";
	disconnectIncoming $clipToGhost "clipSourceEnd";
	disconnectIncoming $clipToGhost "clipPreCycle";
	disconnectIncoming $clipToGhost "clipPostCycle";
	disconnectIncoming $clipToGhost "clipIntermediatePoses";
	disconnectOutgoing $clipToGhost "clipGhostData";

	// ... and reconnect node in the correct order
	for ( $i=0; $i<$nclips; $i++ )
	{
		connectClipAndClipToGhost( $clips[$i], $clipToGhost, $scheduler );
		string $ghost = getGhostShapeForClip( $clips[$i] );
		if ( size( $ghost ) == 0 )
			continue;

		connectIfNotConnected ( $clipToGhost + ".clipGhostData[" + $i + "]" ) ( $ghost       + ".clipGhostData" );
		connectIfNotConnected ( $ghost       + ".clipData"                  ) ( $clips[$i]   + ".clipData"      );
		connectIfNotConnected ( $ghost       + ".intermediatePoses"         ) ( $clipToGhost + ".clipIntermediatePoses[" + $i + "]" );
	}
}