// Copyright (C) 1997-2014 Autodesk, Inc., and/or its licensors.
// All rights reserved.
//
// The coded instructions, statements, computer programs, and/or related
// material (collectively the "Data") in these files contain unpublished
// information proprietary to Autodesk, Inc. ("Autodesk") and/or its licensors,
// which is protected by U.S. and Canadian federal copyright law and by
// international treaties.
//
// The Data is provided for use exclusively by You. You have the right to use,
// modify, and incorporate this Data into other products for purposes authorized 
// by the Autodesk software license agreement, without fee.
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND. AUTODESK
// DOES NOT MAKE AND HEREBY DISCLAIMS ANY EXPRESS OR IMPLIED WARRANTIES
// INCLUDING, BUT NOT LIMITED TO, THE WARRANTIES OF NON-INFRINGEMENT,
// MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE, OR ARISING FROM A COURSE 
// OF DEALING, USAGE, OR TRADE PRACTICE. IN NO EVENT WILL AUTODESK AND/OR ITS
// LICENSORS BE LIABLE FOR ANY LOST REVENUES, DATA, OR PROFITS, OR SPECIAL,
// DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES, EVEN IF AUTODESK AND/OR ITS
// LICENSORS HAS BEEN ADVISED OF THE POSSIBILITY OR PROBABILITY OF SUCH DAMAGES.

//
//
//  Creation Date:  20 Feb 2002
//
//  Description:
//      Returns a command to rebuild the initial state of a fluid,
//		to preserve contents when the resolution has changed.
//
global proc string rebuildFluidInitialStateCmd( string $cmd, 
												string $optionVar ) 
{
	string $preCmd = "";
	string $postCmd = "";

	if( !`exists getActiveFluidShapes` ) {
		source "getFluidShape.mel";
	}
	string $activeFluids[] = getActiveFluidShapes();

	int $rebuildIC = `optionVar -query $optionVar`;

	for( $fluid in $activeFluids ) {
		string $icCaches[] = eval( "listConnections \"" + 
								   $fluid + ".diskCacheIC\"" );

		// Only rebuild the IC cache, if there IS one. 
		//
		if( size($icCaches) > 0 ) {
			if( $rebuildIC ) {
				float $currTime = `currentTime -q`;
				
				// Go back to the start of the IC cache
				//
				$preCmd = ( "currentTime `fluidCacheInfo -sf -ic " + $fluid + "`; " );
				
				// Resave the initial state, and return to the current time
				//
				$postCmd = ( "performSetFluidState 0; " + 
							 "currentTime " + $currTime + "; " );
			} else {
				string $msg = (uiRes("m_rebuildFluidInitialStateCmd.kResamplingExtendingMessage"));
				string $no = (uiRes("m_rebuildFluidInitialStateCmd.kNo"));
				string $lastChance = `confirmDialog 
					-title (uiRes("m_rebuildFluidInitialStateCmd.kWarning"))
					-message $msg
					-button (uiRes("m_rebuildFluidInitialStateCmd.kYes"))
					-button $no 
					-defaultButton $no
					-cancelButton $no -dismissString $no`;	
				
				// If they've cancelled, then set things up so
				// nothing important gets executed.
				//
				if( $lastChance == $no ) {
					$cmd = "";
				}
			}
		}
	}

	$postCmd = ( $postCmd + "fluidCheckResolutionAgainstCaches; " );

	return ( $preCmd + $cmd + $postCmd );
}

