// Copyright (C) 1997-2014 Autodesk, Inc., and/or its licensors.
// All rights reserved.
//
// The coded instructions, statements, computer programs, and/or related
// material (collectively the "Data") in these files contain unpublished
// information proprietary to Autodesk, Inc. ("Autodesk") and/or its licensors,
// which is protected by U.S. and Canadian federal copyright law and by
// international treaties.
//
// The Data is provided for use exclusively by You. You have the right to use,
// modify, and incorporate this Data into other products for purposes authorized 
// by the Autodesk software license agreement, without fee.
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND. AUTODESK
// DOES NOT MAKE AND HEREBY DISCLAIMS ANY EXPRESS OR IMPLIED WARRANTIES
// INCLUDING, BUT NOT LIMITED TO, THE WARRANTIES OF NON-INFRINGEMENT,
// MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE, OR ARISING FROM A COURSE 
// OF DEALING, USAGE, OR TRADE PRACTICE. IN NO EVENT WILL AUTODESK AND/OR ITS
// LICENSORS BE LIABLE FOR ANY LOST REVENUES, DATA, OR PROFITS, OR SPECIAL,
// DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES, EVEN IF AUTODESK AND/OR ITS
// LICENSORS HAS BEEN ADVISED OF THE POSSIBILITY OR PROBABILITY OF SUCH DAMAGES.

//
// Run this script before saving a file for hardware
// rendering test-o-matic tests.
//
// Last Updated: Sept, 26, 2002
//
global proc setSoftwareQualityToProduction()
{
  // Set software to production quality preset. Taken
  // from renderGlobalsWindow.mel
  //
  string $rendQual[] = `listConnections defaultRenderGlobals.qual`;

  setAttr ($rendQual[0] + ".edgeAntiAliasing") 0;
  setAttr ($rendQual[0] + ".useMultiPixelFilter") 1;
  setAttr ($rendQual[0] + ".shadingSamples") 2;
  setAttr ($rendQual[0] + ".maxShadingSamples") 8;
  setAttr ($rendQual[0] + ".visibilitySamples") 1;
  setAttr ($rendQual[0] + ".maxVisibilitySamples") 4;
  setAttr ($rendQual[0] + ".redThreshold") 0.4;
  setAttr ($rendQual[0] + ".greenThreshold") 0.3;
  setAttr ($rendQual[0] + ".blueThreshold") 0.6;
  setAttr ($rendQual[0] + ".reflections") 10;
  setAttr ($rendQual[0] + ".refractions") 10;
  setAttr ($rendQual[0] + ".shadows") 10;

  updateRenderQuality;
}

// Set for <sceneName>.#.ext or <sceneName>
global proc setSoftwareFrameExtension(int $animate)
{
  if ($animate) {

    // Animation on
    setAttr defaultRenderGlobals.animation 1; 
    if (`checkBoxGrp -q -v1 imageCheckBox`) {
      // Override image file format type
      setAttr defaultRenderGlobals.outFormatControl 2;  
    } else {
      // Standard image file format type
      setAttr defaultRenderGlobals.outFormatControl 0;	
    }
    setAttr "defaultRenderGlobals.putFrameBeforeExt" 1;
    setAttr "defaultRenderGlobals.periodInExt" 1;
  }
  else {
    // Animation off
    setAttr defaultRenderGlobals.animation 0;
    // No image file format type		
    setAttr defaultRenderGlobals.outFormatControl 1;	
    setAttr "defaultRenderGlobals.periodInExt" 1;
  }

  updateFrames;
  updateExtOptions;
  updateFileOutputFeedback;

  // Also update the main render window if it exists.
  if (`exists updateMainRenderMenu`) {
    updateMainRenderMenu();
  }
  // And the batch render window	
  if (`exists updateBatchRenderWindowTitle`) {
    updateBatchRenderWindowTitle();
  }
}

global proc hwRendertestSetup(int $startFrame, int $endFrame, int $byFrame)
{
  // Load the hw renderer
  hwRenderLoad;
  string $hwRenderNodes[] = `ls -type hardwareRenderGlobals`;
  int $i;
  int $haveHwRenderGlobals = 0;
  for ($i=0; $i<size($hwRenderNodes); $i++)
  {
	if ($hwRenderNodes[$i] == "hardwareRenderGlobals")
		$haveHwRenderGlobals = 1;
	else
		delete $hwRenderNodes[$i];
  }
  if ($haveHwRenderGlobals = 0)
  {
	string $newNode = `createNode hardwareRenderGlobals`;
	rename $newNode "hardwareRenderGlobals_blah";
	rename "hardwareRenderGlobals_blah" "hardwareRenderGlobals";
  }

  //** Setup hardware globals
  // Start-end frame
  setAttr "defaultRenderGlobals.startFrame" $startFrame;
  setAttr "defaultRenderGlobals.endFrame" $endFrame;
  setAttr "defaultRenderGlobals.byFrameStep" $byFrame;

  // TIFF
  setAttr hardwareRenderGlobals.imageFormat 3; 

  //** Setup sofware globals
  setSoftwareQualityToProduction; // Production quality
  setAttr defaultRenderGlobals.imageFormat 3; // TIFF
  setAttr defaultRenderGlobals.startFrame $startFrame;
  setAttr defaultRenderGlobals.endFrame $endFrame;
  setAttr defaultRenderGlobals.byFrameStep $byFrame;
  setAttr defaultRenderGlobals.renderAll 1;
  
  if ($startFrame != $endFrame) {

    // Set software render globals
    setSoftwareFrameExtension(1);

    // Set hardware render globals
    setAttr -type "string" hardwareRenderGlobals.filename "%s.%4n";
  }

  else {
    // Set software render globals
    setSoftwareFrameExtension(0);

    // Set hardware render globals
    setAttr -type "string" hardwareRenderGlobals.filename "%s";
  }
}
