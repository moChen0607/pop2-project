// Copyright (C) 1997-2014 Autodesk, Inc., and/or its licensors.
// All rights reserved.
//
// The coded instructions, statements, computer programs, and/or related
// material (collectively the "Data") in these files contain unpublished
// information proprietary to Autodesk, Inc. ("Autodesk") and/or its licensors,
// which is protected by U.S. and Canadian federal copyright law and by
// international treaties.
//
// The Data is provided for use exclusively by You. You have the right to use,
// modify, and incorporate this Data into other products for purposes authorized 
// by the Autodesk software license agreement, without fee.
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND. AUTODESK
// DOES NOT MAKE AND HEREBY DISCLAIMS ANY EXPRESS OR IMPLIED WARRANTIES
// INCLUDING, BUT NOT LIMITED TO, THE WARRANTIES OF NON-INFRINGEMENT,
// MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE, OR ARISING FROM A COURSE 
// OF DEALING, USAGE, OR TRADE PRACTICE. IN NO EVENT WILL AUTODESK AND/OR ITS
// LICENSORS BE LIABLE FOR ANY LOST REVENUES, DATA, OR PROFITS, OR SPECIAL,
// DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES, EVEN IF AUTODESK AND/OR ITS
// LICENSORS HAS BEEN ADVISED OF THE POSSIBILITY OR PROBABILITY OF SUCH DAMAGES.

//
//  Procedure Name:
//      performPolyMirrorCut


global proc polyMirrorCut( int $axis,
						   int $combine,
						   float $mergeVertexTolerance){
//
//  Description:
//		This proc provides the guts of the poly mirror cut command
//
//  Arguments:
//		$axis:	axis to cut across
//				1 = X, 2 = Y, 3 = Z
//		$combine: combine the mirrored mesh with the cut mesh
//				0 = no, 1 = yes
//		$mergeVertexTolerance: if combining, the value for the merge vertex operation

	// get selected meshes
	string $selectedMeshes[] = `ls -sl`;

	// need warning for multiple meshes or error for no meshes
	if (size($selectedMeshes) == 0) {
		error (uiRes("m_polyMirrorCut.kInvalidSelection"));
	} else if (size($selectedMeshes) > 1) {
		warning (uiRes("m_polyMirrorCut.kTooManySelected"));
	}

	// get pivot point for mesh and set to the origin
	// later on we set this back to where it was - if we don't do this,
	// objects away from the origin can have unsightly gaps and offsets
	float $pivotPoint[6] = `xform -query -worldSpace -pivots $selectedMeshes[0]`;
	xform -worldSpace -pivots 0.0 0.0 0.0 $selectedMeshes[0];

	// freeze transforms
	makeIdentity -apply true -t 1 -r 1 -s 1 $selectedMeshes[0];

	// bbox check - bbox away from origin may produce unexpected results
	// bbox is also used for the cut plane sizing
	float $bbox[] = `xform -q -ws -bb $selectedMeshes[0]`;

	// cut first mesh - throw out the rest
	float $size[3];
	$size[0] = abs($bbox[0] - $bbox[3]);
	$size[1] = abs($bbox[1] - $bbox[4]);
	$size[2] = abs($bbox[2] - $bbox[5]);
	$size = `sort $size`;

	string $cutPlane[] = `polyCut -ws 1 -cd "Z" -eo 0 0 0 -df 1 -ch 1 $selectedMeshes[0]`;
	
	// get cutPlane position
	float $xPos = `getAttr ($cutPlane[0] + ".cutPlaneCenterX") $cutPlane[0]`;
	float $yPos = `getAttr ($cutPlane[0] + ".cutPlaneCenterY") $cutPlane[0]`;
	float $zPos = `getAttr ($cutPlane[0] + ".cutPlaneCenterZ") $cutPlane[0]`;

	// create construction plane
	//string $constructionPlane[] = `polyPlane -w ($size[2] + 1) -h ($size[2] + 1) -sx 3 -sy 3 -ax 0 0 1 -tx 1 -ch 1 -n "mirrorCutPlane#"`;
	string $constructionPlane = `plane -w ($size[2] + 1) -l ($size[2] + 1) -n "mirrorCutPlane#"`;

	// set position of constructionPlane and default manip to smart
	setAttr ($constructionPlane + ".translateX") $xPos;
	setAttr ($constructionPlane + ".translateY") $yPos;
	setAttr ($constructionPlane + ".translateZ") $zPos;
	setAttr ($constructionPlane + ".showManipDefault") 4;//transform manip

	// connect construction plane to cutPlane
	connectAttr -f ($constructionPlane + ".translate") 
		($cutPlane[0] + ".cutPlaneCenter");
	connectAttr -f ($constructionPlane + ".rotate") 
		($cutPlane[0] + ".cutPlaneRotate");

	// create mirrored mesh and name it so that the user knows this half is untweakable
	// if they are not using the combine option
	string $duplicate[] = `duplicate -n "mirroredCutMesh#" -rr $selectedMeshes[0]`;

	// turn allowTopologyMod off so user doesn't make any inadvertent tweaks
	setAttr ($duplicate[0] + ".allowTopologyMod") 0;

	// scale
	scale -relative 1 1 -1 $duplicate[0];

	// connect mirror
	connectAttr -f ($constructionPlane + ".translate")
		($duplicate[0] + ".translate");
	connectAttr -f ($constructionPlane + ".rotate")
		($duplicate[0] + ".rotate") ;		

	// one more connection for the mirror since we use construction plane
	// and it doesn't accept freeze transforms
	string $multiplyDivide = `createNode multiplyDivide -name "polyMirrorCutMultiplyDivide#"`;
	connectAttr -f ($constructionPlane + ".scale")
		($multiplyDivide + ".input1") ;
	// and set input2Z to -1 so the mirrored mesh doesn't get scaled strangely
	setAttr ($multiplyDivide + ".input2Z") -1;
	connectAttr -f ($multiplyDivide + ".output")
		($duplicate[0] + ".scale") ;
	
	// create transformGeometry and hook up
	string $transformGeometry = `createNode transformGeometry`;
	connectAttr -f ($constructionPlane + ".inverseMatrix")
		($transformGeometry + ".transform");
	string $sourceShape[] = `listRelatives -fullPath -shapes $selectedMeshes[0]`;
	connectAttr -f ($sourceShape[0] + ".outMesh")
		($transformGeometry + ".inputGeometry");
	string $targetShape[] = `listRelatives -fullPath -shapes $duplicate[0]`;
	connectAttr -f ($transformGeometry + ".outputGeometry")
		($targetShape[0] + ".inMesh");

	// apply user specified orientation to the cut
	if ($axis == 1){//X
		setAttr ($constructionPlane + ".ry") 90;
	} else if ($axis == 2){//Y
		setAttr ($constructionPlane + ".rx") -90;
	}

	if ($combine){
		// combine the two meshes and merge verts
		string $combined[] = `polyUnite -constructionHistory 1 $selectedMeshes[0] $duplicate[0]`;
		polyMergeVertex -distance $mergeVertexTolerance -constructionHistory 1 $combined[0];

		// set the pivot point back
		xform -worldSpace 
			-scalePivot $pivotPoint[0] $pivotPoint[1] $pivotPoint[2]
			-rotatePivot $pivotPoint[3] $pivotPoint[4] $pivotPoint[5]
			$combined[0];
	} else {
		// set the pivot point back
		xform -worldSpace 
			-scalePivot $pivotPoint[0] $pivotPoint[1] $pivotPoint[2]
			-rotatePivot $pivotPoint[3] $pivotPoint[4] $pivotPoint[5]
			$selectedMeshes[0];
	}

	// select cutPlane and activate move rotate scale tool
	select -replace $constructionPlane;
	ShowManipulators;
	
}

