// Copyright (C) 1997-2014 Autodesk, Inc., and/or its licensors.
// All rights reserved.
//
// The coded instructions, statements, computer programs, and/or related
// material (collectively the "Data") in these files contain unpublished
// information proprietary to Autodesk, Inc. ("Autodesk") and/or its licensors,
// which is protected by U.S. and Canadian federal copyright law and by
// international treaties.
//
// The Data is provided for use exclusively by You. You have the right to use,
// modify, and incorporate this Data into other products for purposes authorized 
// by the Autodesk software license agreement, without fee.
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND. AUTODESK
// DOES NOT MAKE AND HEREBY DISCLAIMS ANY EXPRESS OR IMPLIED WARRANTIES
// INCLUDING, BUT NOT LIMITED TO, THE WARRANTIES OF NON-INFRINGEMENT,
// MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE, OR ARISING FROM A COURSE 
// OF DEALING, USAGE, OR TRADE PRACTICE. IN NO EVENT WILL AUTODESK AND/OR ITS
// LICENSORS BE LIABLE FOR ANY LOST REVENUES, DATA, OR PROFITS, OR SPECIAL,
// DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES, EVEN IF AUTODESK AND/OR ITS
// LICENSORS HAS BEEN ADVISED OF THE POSSIBILITY OR PROBABILITY OF SUCH DAMAGES.

//
//	Procedure Name:
//		doReplayblastShotArgList
//
//	Description:
//		Re-Playblast a shot
//
//	 Input Arguments:
//	[0]	$replaceStart   :  Start frame, in Sequence Time, for replayblast
//	[1] $replaceEnd     :  End frame, in Sequence Time, for replayblast
//	[2]	$audioOnly      :  Only update the audio, no images rendered
//	[3] $format			:  qt avi or iff
//	[4]	$compression	:  the codec
//	[5]	$quality		:  0 to 100 range
//	[6]	$wantOffscreen	:  offscreen
//
//
//	$shot      		:  The shot being re-playblasted
//
//	Return Value:
//		none
//

source sequencerUtils.mel;
source AEimagePlaneTemplate.mel;


global proc
doReplayblastShotArgList( string $version, string $args[], string $shot )
{
	if ( !`exists doPlayblastArgList`) {
		source doPlayblastArgList.mel;
	}

	if (( $version == 1 && size($args) != 2 ) ||
		( $version == 2 && size($args) != 6 ) ||
		( $version == 3 && size($args) != 7 ))
	{
		print (uiRes("m_doReplayblastShotArgList.kReArgListWrongLength"));
		return;
	}	

	// get the current display options of the view port
	getEditorViewVars();
	
	// set display options from the playblast controls
	setPlayblastViewVars();

	// Get the argument settings
	float $replaceStart = $args[0];
	float $replaceEnd = $args[1];
	int $audioOnly = 0;
	string $format  = "qt";
	string $compression = "";
	int $quality = "50";	
	int $wantOffscreen = 1;

	if (int($version) >= 2) {
		$audioOnly = $args[2];
		$format  = $args[3];
		$compression = $args[4];
		$quality = $args[5];		
	}
	if ($version == 3) {
		$wantOffscreen = $args[6];
	}

	int $useMovie = true;			
	if( $format == "iff" ) $useMovie = false;
	
	int $resolutionW = `getAttr ( $shot + ".wres")`;  
	int $resolutionH = `getAttr ( $shot + ".hres")`;		
	
	string $offscreen = ""; 
	if ($wantOffscreen) {
		$offscreen = " -offScreen";
	}
	
	// Get start/end frames of current clip
	float $start = `getAttr ( $shot + ".sequenceStartFrame")` - `getAttr ( $shot + ".czo")`;
	float $end = $start + `getAttr ( $shot + ".clipDuration")`;

	// What track is clip on?
	int $shootOutTrack =  `getAttr ( $shot + ".track")`;

	if ($audioOnly)
	{
		$replaceStart = $start;
		$replaceEnd   = $end;
	}
	else if (($replaceStart < $start) || ($replaceStart > $end ) ||
		($replaceEnd < $start)   || ($replaceStart > $end ) || ($replaceStart > $replaceEnd))
	{
		error ( (uiRes("m_doReplayblastShotArgList.kReInvalidReplaceRange")));
	}

	// If the shot is in a group but not the active shot, make it the active shot.
	string $curActiveShot = "";
	if (isShotInactive($shot))
	{
		// Remember the currently active shot of the shot's group.
		string $group = getShotsGroup($shot);
		$curActiveShot = getActiveShot($group);

		setShotActive($shot);
	}

	// Mute all the shots not on the current track, retaining their
	// current state for later reset
	$shots = `ls -type shot`;
	int $shotState[];

	for ( $i = 0; $i < size($shots); $i++ )
	{	
		$shotState[$i] = `getAttr ( $shots[$i] + ".trackState")`;	
		int $shotTrack = `getAttr ( $shots[$i] + ".track")`;
		if( $shotTrack != $shootOutTrack )
		{
			setAttr ( $shots[$i] + ".trackState") 4;	// Mute
		}
	}

	// Get started
	sequenceManager -currentTime $replaceStart;

	// Attrs we need later 
	string $camera = getShotsCamera( $shot );
	string $oldClip = getShotsClip( $shot );

	// Reshoot assumes theres an existing image plane, and a file associated with it	
	if ( $oldClip == "" )
	{
		error ( (uiRes("m_doReplayblastShotArgList.kReImageMissing")));
		return;
	}

	string $imageFile =  `getAttr ($oldClip + ".imageName")`;
	if ( $imageFile == "" )
	{
		error ( (uiRes("m_doReplayblastShotArgList.kReImageFileMissing")));
		return;
	}
	
	// If there's an existing IP, disconnect it, and clear out its name
	// to ensure it's never rendered or accessed.  If there is more than one,
	// just remember the first one, as the others are corrupted.
	string $oldIP[]    = getCamerasImagePlanes($camera); 
	float $savedAlpha  = `getAttr ($oldClip + ".alphaGain")`;
	string $savedImage = `getAttr ($oldClip + ".imageName")`;
	string $savedType = `getAttr ($oldClip + ".type")`;

	if (size($oldIP) > 0)
	{
		string $ip;
		for ($ip in $oldIP)
			seqDisconnectImagePlane($ip, $camera);
	}

	// Needed in case AE is open, which will cause IP to try read from the file on disk
	setAttr ($oldClip + ".imageName") -type "string" "";
	
	if ( $useMovie ){
		// set the type to movie 
		setAttr ($oldClip + ".type") 2;
	}
	
	// Playblast out the images to a movie file
	string $cmd, $outFile = "";
	if ($audioOnly)
		$audioOnlyFlag = " -replaceAudioOnly ";

	if ( $useMovie )
	{
		// strip off the extension 
		string $basename = basename( $imageFile, ".mov" );
		$basename = basename( $basename, ".avi" );
		string $tmpImage = $basename + "_tmp";

		$cmd = "playblast -fmt " + $format +
			 " -startTime " + $start + " -endTime " + $end +
			 " -replaceStartTime " + $replaceStart + " -replaceEndTime " + $replaceEnd +
			 $audioOnlyFlag +
			 " -sequenceTime 1 -forceOverwrite -filename \"" + $tmpImage + 
			 "\" -replaceFilename \"" + $imageFile +
			 "\" -wh " + $resolutionW + " " + $resolutionH + $offscreen +
			 " -clearCache 1 -showOrnaments 0 -percent 100 -viewer 0 -useTraxSounds";
	
		if ( $compression != "" && $compression != "global") {
			// TODO internationalization this string. 
	        // global is used for get the render setting from the global render settings
	        // this will be used if there is no compression flag set.
			$cmd += " -compression \""+ $compression + "\" -quality " + $quality;
		}
	
		// Use catch() to ensure the remainder of the code, especially the un-mute of tracks, happens
		if ( catch ( $outFile = evalEcho($cmd) ) )
		{
			$setupImagePlane = false;	// Don't try do anything with the image plane.
			error((uiRes("m_doReplayblastShotArgList.kRePlayblastFailed")));
		}
		else {
			string $fullPath = $imageFile;
			if ( substring($fullPath, 1, 1) != "/" && substring($fullPath, 1, 1) != "$" 
				&& (size($fullPath) > 1 && substring($fullPath, 2, 2) != ":")) {

				// relative path, get the project's root directory
				//
				$fullPath = `workspace -q -fn` + "/" + $fullPath;	
			}
			
			sysFile -rename $fullPath $outFile;
		}
	}
	else
	{
		// Playblast out the images to IFF files
		//	Note we don't need to replace a file as they are just images
		//
		$cmd = "playblast -startTime " + $replaceStart + " -endTime " + $replaceEnd +
			$audioOnlyFlag +
			" -sequenceTime 1 -forceOverwrite -filename \"" + $imageFile +
			"\" -wh " + $resolutionW + " " + $resolutionH + $offscreen +
			" -format iff -clearCache 1 -showOrnaments 0 -percent 100 -viewer 0 -fp 4";

		if ( $compression != "" && $compression != "global") {
			// TODO internationalization this string. 
	        // global is used for get the render setting from the global render settings
	        // this will be used if there is no compression flag set.
			$cmd += " -compression \""+ $compression + "\" -quality " + $quality;
		}
			
		if ( catch ( $outFile = evalEcho($cmd) ) )
		{
			$updateIP = false;	// Don't try do anything with the image plane
			error((uiRes("m_doReplayblastShotArgList.kIffPlayblastFailed")));
		}
	}

	// Restore the old image plane.
	setAttr ($oldClip + ".alphaGain") $savedAlpha;
	// setAttr ($oldClip + ".type") $savedType;  // we haven't change type.
	connectAttr -na ( $oldClip + ".message " ) ( $camera + ".imagePlane");
	setAttr ($oldClip + ".imageName") -type "string" $imageFile;

	// Restore the original active shot if it had been changed.
	if ($curActiveShot != "")
		setShotActive($curActiveShot);

	// Reset (un-mute) all the shot states
	for ( $i = 0; $i < size($shots); $i++ )
	{	
		setAttr ( $shots[$i] + ".trackState") $shotState[$i];
	}

	// recover the display options
	restoreEditorViewVars();	 

}
