// Copyright (C) 1997-2014 Autodesk, Inc., and/or its licensors.
// All rights reserved.
//
// The coded instructions, statements, computer programs, and/or related
// material (collectively the "Data") in these files contain unpublished
// information proprietary to Autodesk, Inc. ("Autodesk") and/or its licensors,
// which is protected by U.S. and Canadian federal copyright law and by
// international treaties.
//
// The Data is provided for use exclusively by You. You have the right to use,
// modify, and incorporate this Data into other products for purposes authorized 
// by the Autodesk software license agreement, without fee.
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND. AUTODESK
// DOES NOT MAKE AND HEREBY DISCLAIMS ANY EXPRESS OR IMPLIED WARRANTIES
// INCLUDING, BUT NOT LIMITED TO, THE WARRANTIES OF NON-INFRINGEMENT,
// MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE, OR ARISING FROM A COURSE 
// OF DEALING, USAGE, OR TRADE PRACTICE. IN NO EVENT WILL AUTODESK AND/OR ITS
// LICENSORS BE LIABLE FOR ANY LOST REVENUES, DATA, OR PROFITS, OR SPECIAL,
// DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES, EVEN IF AUTODESK AND/OR ITS
// LICENSORS HAS BEEN ADVISED OF THE POSSIBILITY OR PROBABILITY OF SUCH DAMAGES.

//
//
//  Creation Date:  18 April 1997
//
//

proc int booleanOperation(string $action)
{
	string $tmp[];
	tokenize $action $tmp;
	return $tmp[2];
}

proc setOptionVars(int $forceFactorySettings)
{
	if( $forceFactorySettings || !`optionVar -exists booleanOpUseLegacy`)
		optionVar -intValue booleanOpUseLegacy 0;

	if( $forceFactorySettings || !`optionVar -exists booleanUnionClassification`)
		optionVar -intValue booleanUnionClassification 2;

	if( $forceFactorySettings || !`optionVar -exists booleanDifferenceClassification`)
		optionVar -intValue booleanDifferenceClassification 2;

	if( $forceFactorySettings || !`optionVar -exists booleanIntersectionClassification`)
		optionVar -intValue booleanIntersectionClassification 2;

	if( $forceFactorySettings || !`optionVar -exists booleanOpPreserveColor`)
		optionVar -intValue booleanOpPreserveColor 0;
	if( $forceFactorySettings || !`optionVar -exists uniteMergeUVSets`)
		optionVar -intValue uniteMergeUVSets 1;
	if( $forceFactorySettings || !`optionVar -exists uniteCombineSkinning`)
		optionVar -intValue uniteCombineSkinning 0;
	if( $forceFactorySettings || !`optionVar -exists polyConnectComponentsInsertWithEdgeFlow`)
		optionVar -intValue polyConnectComponentsInsertWithEdgeFlow 0;
	if( $forceFactorySettings || !`optionVar -exists polyConnectComponentsAdjustEdgeFlow`)
		optionVar -floatValue polyConnectComponentsAdjustEdgeFlow 1.0;
}

proc int carveClassification()
{
	int $classification = 2;
	if (`radioButtonGrp -exists booleanOpEdgeClassification_RBG`)
	{
		int $choice = `radioButtonGrp -q -select booleanOpNormalClassification_RBG`;
		if (1 != $choice)
			$classification = 1;
	}
	return $classification;
}

proc setCarveClassification(int $choice)
{
	if (`radioButtonGrp -exists booleanOpEdgeClassification_RBG`)
	{
		if (1 == $choice)
		{
			radioButtonGrp -e -select 1 booleanOpEdgeClassification_RBG;
		}
		else
		{
			radioButtonGrp -e -select 1 booleanOpNormalClassification_RBG;
		}
	}
}


global proc performActionLegacyBooleanOpChange()
{
	if (`checkBoxGrp -exists booleanOpUseLegacy`)
	{
		int $useLegacy = `checkBoxGrp -query -value1 booleanOpUseLegacy`;
		checkBoxGrp -edit -enable $useLegacy booleanOpPreserveColor;

		rowColumnLayout -edit -enable (!$useLegacy) CarveClassification_RBG;
	}
}

proc polyBooleanOptionsInit(string $parent, int $op)
{
	polyBooleanOptionsSetup($parent, 0);

	int $classification = 2;
	switch ($op)
	{
	case 1:
		$classification = `optionVar -query booleanUnionClassification`;
		break;
	case 2:
		$classification = `optionVar -query booleanDifferenceClassification`;
		break;
	case 3:
		$classification = `optionVar -query booleanIntersectionClassification`;
		break;
	}
	setCarveClassification( $classification );
}


//
//  Procedure Name:
//      polyBooleanOptionsSetCallback
//
//  Description:
//		Update the option values with the current state of the option box UI
//
//  Input Arguments:
//      parent               - Top level parent layout of the option box UI.
//                             Required so that UI object names can be 
//                             successfully resolved.
//
//	doIt                 - whether the command should execute
//
//  Return Value:
//      None.
//
global proc polyBooleanOptionsCallback(string $action, string $funtype, string $parent, int $doIt)
{
 	setParent $parent;

	int $preserveColor = `checkBoxGrp -query -value1 booleanOpPreserveColor`;
	optionVar -iv booleanOpPreserveColor $preserveColor;

	int $useLegacy = `checkBoxGrp -query -value1 booleanOpUseLegacy`;
	optionVar -iv booleanOpUseLegacy $useLegacy;

	string $tmp[], $actionbase;
	tokenize $action $tmp;
	$actionbase = $tmp[0];

	int $len = size($tmp), $i;

	if ($useLegacy && "polyBoolOp" != $actionbase)
	{
		$action = "polyBoolOp";
		for ($i=1; $i<$len; $i++)
		{
			$action += (" " + $tmp[$i]);
		}
	}
	else if (!$useLegacy && "polyCBoolOp" != $actionbase)
	{
		$action = "polyCBoolOp";
		for ($i=1; $i<$len; $i++)
		{
			$action += (" " + $tmp[$i]);
		}
	}

	int $classification = carveClassification();
	int $op = $tmp[2];
	switch ($op)
	{
	case 1:
		optionVar -iv booleanUnionClassification $classification;
		break;
	case 2:
		optionVar -iv booleanDifferenceClassification $classification;		
		break;
	case 3:
		optionVar -iv booleanIntersectionClassification $classification;		
		break;
	}	

	if ($doIt)
	{
		string $cmd =("polyPerformAction \"" + $action + "\" " + $funtype + " 0");
		eval($cmd);
	}
}

//
//  Procedure Name:
//      polyBooleanOptionsSetSetup
//
//  Description:
//		Update the state of the option box UI to reflect the option values.
//
//  Input Arguments:
//      parent               - Top level parent layout of the option box UI.
//                             Required so that UI object names can be 
//                             successfully resolved.
//
//	forceFactorySettings - Whether the option values should be set to
//                             default values.
//
//  Return Value:
//      None.
//
global proc polyBooleanOptionsSetup(string $parent, int $forceFactorySettings)
{
	setOptionVars($forceFactorySettings);
 	setParent $parent;

	int $preserveColor = `optionVar -query booleanOpPreserveColor`;
	checkBoxGrp -e -value1 $preserveColor booleanOpPreserveColor;

	int $useLegacy = `optionVar -query booleanOpUseLegacy`;
	checkBoxGrp -e -value1 $useLegacy booleanOpUseLegacy;

	int $classification = `optionVar -query booleanUnionClassification`;
	setCarveClassification( $classification );

	performActionLegacyBooleanOpChange();
}


//  Procedure Name:
//      polyBooleanOptions
//
//  Description:
//		Construct the option box UI.  Involves accessing the standard option
//		box and customizing the UI accordingly.
//
//  Input Arguments:
//      None.
//
//  Return Value:
//      None.
//
proc polyBooleanOptions(string $action, string $funtype)
{
	//	Name of the command for this option box.
	//
	string $commandName = "polyBooleanOptions";

	//	Build the option box actions.
	//
	string $callback = ($commandName + "Callback \"" + $action + "\" " + $funtype);
	string $setup = ($commandName + "Setup");

 	//	STEP 1:  Get the option box.
	//	============================
	//
	//	The value returned is the name of the layout to be used as
	//	the parent for the option box UI.
	//
	string $layout = getOptionBox();
	setParent $layout;
	
	//	STEP 2:  Pass the command name to the option box.
	//	=================================================
	//
	//	Any default option box behaviour based on the command name is set 
	//	up with this call.  For example, updating the 'Help' menu item with
	//	the name of the command.
	//
	setOptionBoxCommandName($commandName);
	
	//	STEP 3:  Activate the default UI template.
	//	==========================================
	//
	//	Activate the default UI template so that the layout of this 
	//	option box is consistent with the layout of the rest of the 
	//	application.
	//
	setUITemplate -pushTemplate DefaultTemplate;

	//	STEP 4: Create option box contents.
	//	===================================
	//	
	//	This, of course, will vary from option box to option box.	
	//	Turn on the wait cursor.
	//
	waitCursor -state 1;

	tabLayout -tabsVisible 0 -scrollable 1;
	
	string $parent = `columnLayout -adjustableColumn 1`;

	frameLayout -label (uiRes("m_polyPerformAction.kSettingsLabel")) -collapse 0; 
		columnLayout; 

		//	Create the widgets for this option box
		//
		checkBoxGrp -label1 (uiRes("m_polyPerformAction.kBooleanOpUseLegacy"))   
				-changeCommand "performActionLegacyBooleanOpChange"
			 booleanOpUseLegacy;

		checkBoxGrp -label1 (uiRes("m_polyPerformAction.kBooleanOpPreserveColor"))   
			 booleanOpPreserveColor;
		setParent ..;
	setParent ..;

	int $op = booleanOperation($action);
	string $edgeImage = "UnionClassON";
	string $normalImage = "UnionClassON";

	switch ($op)
	{
	case 1:
		$edgeImage = "UnionClassOFF";
		$normalImage = "UnionClassON";		
		break;
	case 2:
		$edgeImage = "DifferenceClassOFF";
		$normalImage = "DifferenceClassON";		
		break;
	case 3:
		$edgeImage = "IntersectionClassOFF";
		$normalImage = "IntersectionClassON";		
		break;
	}

	string $l1 = (uiRes("m_polyPerformAction.kEdgeLabel"));
	string $l2 = (uiRes("m_polyPerformAction.kNormalLabel"));

	frameLayout -label (uiRes("m_polyPerformAction.kOpenSurfaceSettingsLabel")) -collapse 0; 

		rowColumnLayout -numberOfRows 2 -rowHeight 1 60 -rowHeight 2 60 CarveClassification_RBG;
			radioButtonGrp -numberOfRadioButtons 1 
						-label (uiRes("m_polyPerformAction.kIntersectionClassificationLable")) 
						-labelArray2 $l1 ""
						booleanOpEdgeClassification_RBG;
			radioButtonGrp -numberOfRadioButtons 1 
						-label "" 
						-labelArray2 $l2 ""
						-shareCollection "booleanOpEdgeClassification_RBG"
						booleanOpNormalClassification_RBG;

			picture -image $edgeImage;
			picture -image $normalImage;

		setParent ..;

		separator -height 10;

	setParent ..;

	//	Turn off the wait cursor.
	//
	waitCursor -state 0;
	
	//	Step 5: Deactivate the default UI template.
	//	===========================================
	//
	setUITemplate -popTemplate;

	//	Step 6: Customize the buttons.  
	//	==============================
	//
	//	Provide more descriptive labels for the buttons.  This is not 
	//	necessary, but in some cases, for example, a button labelled 
	//	'Create' may be more meaningful to the user than one labelled
	//	'Apply'.
	//
	//	Disable those buttons that are not applicable to the option box.
	//
	//	Attach actions to those buttons that are applicable to the option
	//	box.  Note that the 'Close' button has a default action attached 
	//	to it that will hide the window.  If a a custom action is
	//	attached to the 'Close' button then be sure to call the 'hide the
	//	option box' procedure within the custom action so that the option
	//	box is hidden properly.
	//
	//	'Reset' button.
	//
	string $applyBtn = getOptionBoxApplyBtn();
	button -edit 
		-command ($callback + " " + $parent + " " + 1)
		$applyBtn;

	string $saveBtn = getOptionBoxSaveBtn();
	button -edit 
		-command ($callback + " " + $parent + " " + 0)
		$saveBtn;

	string $resetBtn = getOptionBoxResetBtn();
	button -edit 
		-command ($setup + " " + $parent + " " + 1)
		$resetBtn;

	//	Step 7: Set the option box title.
	//	=================================
	//
	switch ($op)
	{
	case 1:
		setOptionBoxTitle((uiRes("m_polyPerformAction.kUnionOpWindowTitle")));
		break;
	case 2:
		setOptionBoxTitle((uiRes("m_polyPerformAction.kDifferenceOpWindowTitle")));
		break;
	case 3:
		setOptionBoxTitle((uiRes("m_polyPerformAction.kIntersectionOpWindowTitle")));
		break;
	}

	//	Step 8: Set the current values of the option box.
	//	=================================================
	//
	polyBooleanOptionsInit $parent $op;

	setOptionBoxHelpTag("PolyBoolean");
	
	//	Step 9: Show the option box.
	//	=============================
	//
	showOptionBox();
}

//
//  Procedure Name:
//      polyUniteOptionsCallback
//
//  Description:
//		Update the option values with the current state of the option box UI
//
//  Input Arguments:
//      parent               - Top level parent layout of the option box UI.
//                             Required so that UI object names can be 
//                             successfully resolved.
//
//	doIt                 - whether the command should execute
//
//  Return Value:
//      None.
//
global proc polyUniteOptionsCallback(string $action, string $funtype, string $parent, int $doIt)
{
 	setParent $parent;

	int $mergeUVSets = `radioButtonGrp -query -select uniteMergeUVSets` - 1;
	optionVar -iv uniteMergeUVSets $mergeUVSets;

	int $combineSkinning = `checkBoxGrp -query -value1 uniteCombineSkinning`;
	optionVar -iv uniteCombineSkinning $combineSkinning;

	if ($doIt)
	{
		string $cmd =("polyPerformAction \"" + $action + "\" " + $funtype + " 0");
		eval($cmd);
	}
}

//
//  Procedure Name:
//      polyUniteOptionsSetup
//
//  Description:
//		Update the state of the option box UI to reflect the option values.
//
//  Input Arguments:
//      parent               - Top level parent layout of the option box UI.
//                             Required so that UI object names can be 
//                             successfully resolved.
//
//	forceFactorySettings - Whether the option values should be set to
//                             default values.
//
//  Return Value:
//      None.
//
global proc polyUniteOptionsSetup(string $parent, int $forceFactorySettings)
{
	setOptionVars($forceFactorySettings);
 	setParent $parent;

	int $mergeUVSets = `optionVar -query uniteMergeUVSets`;
	radioButtonGrp -e -select ($mergeUVSets+1) uniteMergeUVSets;

	int $combineSkinning = `optionVar -query uniteCombineSkinning`;
	checkBoxGrp -e -value1 $combineSkinning uniteCombineSkinning;
}

//  Procedure Name:
//      polyUniteOptions
//
//  Description:
//		Construct the option box UI.  Involves accessing the standard option
//		box and customizing the UI accordingly.
//
//  Input Arguments:
//      None.
//
//  Return Value:
//      None.
//
proc polyUniteOptions(string $action, string $funtype)
{
	//	Name of the command for this option box.
	//
	string $commandName = "polyUniteOptions";

	//	Build the option box actions.
	//
	string $callback = ($commandName + "Callback \"" + $action + "\" " + $funtype);
	string $setup = ($commandName + "Setup");

 	//	STEP 1:  Get the option box.
	//	============================
	//
	//	The value returned is the name of the layout to be used as
	//	the parent for the option box UI.
	//
	string $layout = getOptionBox();
	setParent $layout;
	
	//	STEP 2:  Pass the command name to the option box.
	//	=================================================
	//
	//	Any default option box behaviour based on the command name is set 
	//	up with this call.  For example, updating the 'Help' menu item with
	//	the name of the command.
	//
	setOptionBoxCommandName($commandName);
	
	//	STEP 3:  Activate the default UI template.
	//	==========================================
	//
	//	Activate the default UI template so that the layout of this 
	//	option box is consistent with the layout of the rest of the 
	//	application.
	//
	setUITemplate -pushTemplate DefaultTemplate;

	//	STEP 4: Create option box contents.
	//	===================================
	//	
	//	This, of course, will vary from option box to option box.	
	//	Turn on the wait cursor.
	//
	waitCursor -state 1;

	tabLayout -tabsVisible 0 -scrollable 1;
	
	string $parent = `columnLayout -adjustableColumn 1`;

	frameLayout -label (uiRes("m_polyPerformAction.kUniteSettingsLabel")) -collapse 0; 
		columnLayout; 

		//	Create the widgets for this option box
		//
		radioButtonGrp -nrb 3 -label (uiRes("m_polyPerformAction.kUniteMergeUVSets"))
			 -label1 (uiRes("m_polyPerformAction.kNoMerge"))
			 -label2 (uiRes("m_polyPerformAction.kMergeByName"))
			 -label3 (uiRes("m_polyPerformAction.kMergeByUVLinks"))
			 -cw4 100 120 120 120
			 uniteMergeUVSets;
		checkBoxGrp -label1 (uiRes("m_polyPerformAction.kCombineSkinning"))   
			 uniteCombineSkinning;
		setParent ..;
	setParent ..;

	//	Turn off the wait cursor.
	//
	waitCursor -state 0;
	
	//	Step 5: Deactivate the default UI template.
	//	===========================================
	//
	setUITemplate -popTemplate;

	//	Step 6: Customize the buttons.  
	//	==============================
	//
	//	Provide more descriptive labels for the buttons.  This is not 
	//	necessary, but in some cases, for example, a button labelled 
	//	'Create' may be more meaningful to the user than one labelled
	//	'Apply'.
	//
	//	Disable those buttons that are not applicable to the option box.
	//
	//	Attach actions to those buttons that are applicable to the option
	//	box.  Note that the 'Close' button has a default action attached 
	//	to it that will hide the window.  If a a custom action is
	//	attached to the 'Close' button then be sure to call the 'hide the
	//	option box' procedure within the custom action so that the option
	//	box is hidden properly.
	//
	//	'Reset' button.
	//
	string $applyBtn = getOptionBoxApplyBtn();
	button -edit 
		-command ($callback + " " + $parent + " " + 1)
		$applyBtn;

	string $saveBtn = getOptionBoxSaveBtn();
	button -edit 
		-command ($callback + " " + $parent + " " + 0)
		$saveBtn;

	string $resetBtn = getOptionBoxResetBtn();
	button -edit 
		-command ($setup + " " + $parent + " " + 1)
		$resetBtn;

	//	Step 7: Set the option box title.
	//	=================================
	//
	setOptionBoxTitle((uiRes("m_polyPerformAction.kCombineWindowTitle")));

	setOptionBoxHelpTag("polyUniteOptions");

	//	Step 8: Set the current values of the option box.
	//	=================================================
	//
	eval (($setup + " " + $parent + " " + 0));	
	
	//	Step 9: Show the option box.
	//	=============================
	//
	showOptionBox();
}

//
//  Procedure Name:
//		polyConnectComponentsCallback
//
//  Description:
//		Update the option values with the current state of the option box UI
//
//  Input Arguments:
//      parent               - Top level parent layout of the option box UI.
//                             Required so that UI object names can be 
//                             successfully resolved.
//
//	doIt                 - whether the command should execute
//
//  Return Value:
//      None.
//
global proc polyConnectComponentsCallback(string $action, string $funtype, string $parent, int $doIt)
{
 	setParent $parent;

	optionVar -intValue polyConnectComponentsInsertWithEdgeFlow `checkBoxGrp -q -value1 insertWithEdgeFlow`;
	optionVar -floatValue polyConnectComponentsAdjustEdgeFlow `floatSliderGrp -q -value adjustEdgeFlow`;

	if ($doIt) {
		polyPerformAction $action $funtype 0;
	}
}

//
//  Procedure Name:
//		polyConnectComponentsSetup
//
//  Description:
//		Update the state of the option box UI to reflect the option values.
//
//  Input Arguments:
//      parent               - Top level parent layout of the option box UI.
//                             Required so that UI object names can be 
//                             successfully resolved.
//
//	forceFactorySettings - Whether the option values should be set to
//                             default values.
//
//  Return Value:
//      None.
//
global proc polyConnectComponentsSetup(string $parent, int $forceFactorySettings)
{
	setOptionVars($forceFactorySettings);
 	setParent $parent;

	int $insertWithEdgeFlow = `optionVar -q polyConnectComponentsInsertWithEdgeFlow`;
	checkBoxGrp -e -value1 $insertWithEdgeFlow insertWithEdgeFlow;

	float $adjustEdgeFlow = `optionVar -q polyConnectComponentsAdjustEdgeFlow`;
	floatSliderGrp -e -value $adjustEdgeFlow -enable $insertWithEdgeFlow adjustEdgeFlow;

}

//  Procedure Name:
//		polyConnectComponentsOptions
//
//  Description:
//		Construct the option box UI.  Involves accessing the standard option
//		box and customizing the UI accordingly.
//
//  Input Arguments:
//      None.
//
//  Return Value:
//      None.
//
proc polyConnectComponentsOptions(string $action, string $funtype)
{
	//	Name of the command for this option box.
	//
	string $commandName = "polyConnectComponents";

	//	Build the option box actions.
	//
	string $callback = ($commandName + "Callback \"" + $action + "\" " + $funtype);
	string $setup = ($commandName + "Setup");

 	//	STEP 1:  Get the option box.
	//	============================
	//
	//	The value returned is the name of the layout to be used as
	//	the parent for the option box UI.
	//
	string $layout = getOptionBox();
	setParent $layout;
	
	//	STEP 2:  Pass the command name to the option box.
	//	=================================================
	//
	//	Any default option box behaviour based on the command name is set 
	//	up with this call.  For example, updating the 'Help' menu item with
	//	the name of the command.
	//
	setOptionBoxCommandName($commandName);
	
	//	STEP 3:  Activate the default UI template.
	//	==========================================
	//
	//	Activate the default UI template so that the layout of this 
	//	option box is consistent with the layout of the rest of the 
	//	application.
	//
	setUITemplate -pushTemplate DefaultTemplate;

	//	STEP 4: Create option box contents.
	//	===================================
	//	
	//	This, of course, will vary from option box to option box.	
	//	Turn on the wait cursor.
	//
	waitCursor -state 1;

	string $parent = `scrollLayout -childResizable 1`;
		
		columnLayout -adjustableColumn true;

			// Settings tab
			frameLayout -label (uiRes("m_polyPerformAction.kSettingsFrame")) -collapse 0;
				columnLayout;
					checkBoxGrp 
						-label1 (uiRes("m_polyPerformAction.kInsertWithEdgeFlow")) 
						-changeCommand1 ("setParent " + $parent + "; floatSliderGrp -e -enable #1 adjustEdgeFlow")
						insertWithEdgeFlow;

					floatSliderGrp 
						-field true
						-label (uiRes("m_polyPerformAction.kAdjustEdgeFlow")) 
						-min 0.0
						-max 1.0
						-fieldMinValue -1000000
						-fieldMaxValue 1000000
						adjustEdgeFlow;
				setParent ..;
			setParent ..;

		setParent ..;

	setParent ..;

	//	Turn off the wait cursor.
	//
	waitCursor -state 0;
	
	//	Step 5: Deactivate the default UI template.
	//	===========================================
	//
	setUITemplate -popTemplate;

	//	Step 6: Customize the buttons.  
	//	==============================
	//
	//	Provide more descriptive labels for the buttons.  This is not 
	//	necessary, but in some cases, for example, a button labelled 
	//	'Create' may be more meaningful to the user than one labelled
	//	'Apply'.
	//
	//	Disable those buttons that are not applicable to the option box.
	//
	//	Attach actions to those buttons that are applicable to the option
	//	box.  Note that the 'Close' button has a default action attached 
	//	to it that will hide the window.  If a a custom action is
	//	attached to the 'Close' button then be sure to call the 'hide the
	//	option box' procedure within the custom action so that the option
	//	box is hidden properly.
	//
	//	'Reset' button.
	//
	string $applyBtn = getOptionBoxApplyBtn();
	button -e -label (uiRes("m_polyPerformAction.kConnect"))
			-command ($callback + " " + $parent + " " + 1)
			$applyBtn;

	string $saveBtn = getOptionBoxSaveBtn();
	button -e 
			-command ($callback + " " + $parent + " " + 0)
			$saveBtn;

	string $resetBtn = getOptionBoxResetBtn();
	button -e 
			-command ($setup + " " + $parent + " " + 1)
			$resetBtn;

	//	Step 7: Set the option box title.
	//	=================================
	//
	setOptionBoxTitle((uiRes("m_polyPerformAction.kConnectComponentsOptions")));

	//	Step 8: Set the current values of the option box.
	//	=================================================
	//
	eval (($setup + " " + $parent + " " + 0));

	setOptionBoxHelpTag("Connect_Components");
	
	//	Step 9: Show the option box.
	//	=============================
	//
	showOptionBox();
}

proc string quoteStarSelection(string $searchString)
// Some of the poly actions require a star to be quoted when the
// command is called.
// eg. will generate an error if passed in something like:
//     poly1.e[*], this will be replace by poly1.e["*"]
{
    string $regExpr = "\\[\\*]";
    string $swapString = "[\"*\"]";
    string $returnString = $searchString;
    
    string $temp = `match $regExpr $returnString`;
        
    while ($temp != "")
    {
        $returnString = `substitute $regExpr $returnString $swapString`;
        $temp = `match $regExpr $returnString`;
    }
    
    return $returnString;
}

global proc polyFinalizeAction ()
{
	global string $polyLastTool;
	global string $gSelect;
	if ($polyLastTool != "" && $polyLastTool != $gSelect)
		setToolTo $polyLastTool;
	$polyLastTool="";
}

proc selectResultAndFinalizeAction(string $result[])
{
	int $hasOptionsScript = false;
	if (0 < `size $result` && "" != $result[0])
	{
		$hasOptionsScript = ("" != optionsPopupFile($result[0]));
	}

	if ($hasOptionsScript)
	{
		global string $polyLastTool;
		$polyLastTool="";

		setToolTo ShowManips;
	}
	else
	{
		polyFinalizeAction;
	}
}

global proc string polyPerformBooleanAction (int $op, string $funtype, int $ret)
{
	setOptionVars(0);

	string $action;
	int $useLegacy = `optionVar -query booleanOpUseLegacy`;
	if (1 == $useLegacy)
	{
		$action = "polyBoolOp -op ";
	}
	else
	{
		$action = "polyCBoolOp -op ";
	}

	$action += $op;

	return polyPerformAction($action, $funtype, $ret);
}

global proc string polyPerformAction (string $action, string $funtype, int $ret)
{
	string $cmd="";
	string $sel[];
	
	string $tmp[], $actionbase;
	tokenize $action $tmp;
	$actionbase = $tmp[0];
	int $doHistory = `constructionHistory -q -toggle`;
	
	setOptionVars(0);

	switch ($ret) {
	case 0:
		waitCursor -state on;

		// check if any objects selected (shapes or transforms)
		string $objsSelected[] = `ls -sl -s -tr`; 
		int $objectMode = (size($objsSelected) > 0);

		if ($actionbase == "polySeparate") {
			$sel = `polyCheckSelection $actionbase $funtype 0`;
		} else {
			$sel=`ls -sl`;
		}
		
		string $result[];

		if (size($sel) != 0) {
			if ($actionbase == "polyUnite" || $actionbase == "polyBoolOp"|| $actionbase == "polyCBoolOp") {
				// unite is the only action that can work on multiple objects at once
				// and needs to, in fact.
				// booleans are in the same case, but need to separate
				// lead from others (for difference)
				$cmd =($action + " -ch " + $doHistory);

				// old booleans have a threshold setting which is enabled by default
				// new booleans work in double precision and the threshold doesn't help as much
				if ($actionbase == "polyBoolOp") {
					$cmd += " -useThresholds 1";
				}

				if ($actionbase == "polyBoolOp" || $actionbase == "polyCBoolOp") {
					int $preserveColor = `optionVar -query booleanOpPreserveColor`;
					$cmd += " -preserveColor " + $preserveColor;
				}

				if ($actionbase == "polyCBoolOp") {
					int $classification = 2;
					int $op = $tmp[2];
					switch ($op)
					{
					case 1:
						$classification = `optionVar -query booleanUnionClassification`;
						break;
					case 2:
						$classification = `optionVar -query booleanDifferenceClassification`;
						break;
					case 3:
						$classification = `optionVar -query booleanIntersectionClassification`;
						break;
					}
					$cmd += " -classification " + $classification;
				}

				if ($actionbase == "polyUnite") {
					int $mergeUVSets = `optionVar -query uniteMergeUVSets`;
					$cmd += " -mergeUVSets " + $mergeUVSets;
					int $combineSkinning = `optionVar -query uniteCombineSkinning`;
					if ( $combineSkinning ) {
						$cmd = `substitute "^polyUnite" $cmd "polyUniteSkinned"`;
					}
				}

				int $addName = ($actionbase != "polyUnite" || 0 == `optionVar -q uniteCombineSkinning`);

				int $nsel = 0;
				for ($i in $sel)
				{
					if(`nodeType $i` == "transform" || `nodeType $i` == "mesh") {
						$nsel++;
						
						if ($addName && 1 == $nsel)
						{
							$cmd += (" -name " + $i);
						}

						$cmd=($cmd + " " + $i);
					}
				}
				if ($actionbase == "polyBoolOp" && $nsel != 2) {
					string $msg = (uiRes("m_polyPerformAction.kSelectMeshBoolError"));
 					error ($msg);
 					return $cmd;
				}
				if ($actionbase == "polyCBoolOp" && $nsel < 2) {
					string $msg = (uiRes("m_polyPerformAction.kSelectMeshBoolError2"));
 					error ($msg);
 					return $cmd;
				}

				$result = `evalEcho $cmd`;
			} else {
				string $filteredSel[];
				for ($i in $sel)
				{
					string $theNodeType = `nodeType $i`;
					if( $theNodeType == "transform" || $theNodeType == "mesh" )
						$filteredSel[size($filteredSel)]=$i;
				}

				int $index=0;
				while (size($filteredSel) > $index) {
					string $cursel[];
					$index=`polyNextSelectionBatch $filteredSel $cursel $index`;

					$cmd =($action + " -ch " + $doHistory);

					if ($actionbase == "polyConnectComponents") {
						int $insertWithEdgeFlow = `optionVar -q polyConnectComponentsInsertWithEdgeFlow`;
						$cmd = ($cmd + " -insertWithEdgeFlow " + $insertWithEdgeFlow);

						float $adjustEdgeFlow = `optionVar -q polyConnectComponentsAdjustEdgeFlow`;
						$cmd = ($cmd + " -adjustEdgeFlow " + $adjustEdgeFlow);
					}

					if (size($cursel) != 0) 
					{
						for ($i in $cursel) 
						{
							$cmd=($cmd + " " + $i);
						}

						// The called command will generate an error if a non-quoted * is used
						// Do a substitution before eval'ing the command.
						$cmd = quoteStarSelection($cmd);
						$result = `evalEcho $cmd`;
					}
				}
			}

			if ($actionbase == "polyUnite" || 
				$actionbase == "polyBoolOp" ||
				$actionbase == "polySeparate" || 
				$actionbase == "polyCBoolOp") {
				
				// Initialize the just created mesh node with global settings
				setupNewMesh();
			}
			
			// make sure node is selected when there is history
			if ($actionbase == "polyCBoolOp") {
				if (0 != size(`ls -sl`) || (0 != size(`ls -hl`))) {
					string $tmp[] = `listHistory`;
					string $totalSel[];
					for ($opNode in $tmp) {
						if (`nodeType $opNode` == "polyCBoolOp") {
							$totalSel[size($totalSel)] = $opNode;
						}
					}

					if (size($totalSel) > 0) 
						select -add $totalSel[0];

					global string $polyLastTool;
					$polyLastTool="";
					setToolTo ShowManips;
				}
			}

			// go back to object mode if the original selection was an object
			if($objectMode) {
				setSelectMode("objects", "Objects");
			}

			selectResultAndFinalizeAction($result);
		}
		waitCursor -state off;
		break;
	case 1:
		if ($actionbase == "polyBoolOp" || $actionbase == "polyCBoolOp") {
			polyBooleanOptions($action, $funtype);
		} else if ($actionbase == "polyUnite") {
			polyUniteOptions($action, $funtype);
		} else if ($actionbase == "polyConnectComponents") {
			polyConnectComponentsOptions($action, $funtype);
		}
		break;
	case 2: $cmd =("polyPerformAction \"" + $action + "\" " + $funtype + " 0");
	}
	return $cmd;
}
