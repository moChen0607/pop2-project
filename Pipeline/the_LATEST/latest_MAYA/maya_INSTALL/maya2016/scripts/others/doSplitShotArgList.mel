// Copyright (C) 1997-2014 Autodesk, Inc., and/or its licensors.
// All rights reserved.
//
// The coded instructions, statements, computer programs, and/or related
// material (collectively the "Data") in these files contain unpublished
// information proprietary to Autodesk, Inc. ("Autodesk") and/or its licensors,
// which is protected by U.S. and Canadian federal copyright law and by
// international treaties.
//
// The Data is provided for use exclusively by You. You have the right to use,
// modify, and incorporate this Data into other products for purposes authorized 
// by the Autodesk software license agreement, without fee.
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND. AUTODESK
// DOES NOT MAKE AND HEREBY DISCLAIMS ANY EXPRESS OR IMPLIED WARRANTIES
// INCLUDING, BUT NOT LIMITED TO, THE WARRANTIES OF NON-INFRINGEMENT,
// MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE, OR ARISING FROM A COURSE 
// OF DEALING, USAGE, OR TRADE PRACTICE. IN NO EVENT WILL AUTODESK AND/OR ITS
// LICENSORS BE LIABLE FOR ANY LOST REVENUES, DATA, OR PROFITS, OR SPECIAL,
// DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES, EVEN IF AUTODESK AND/OR ITS
// LICENSORS HAS BEEN ADVISED OF THE POSSIBILITY OR PROBABILITY OF SUCH DAMAGES.

//
//	Procedure Name:
//		doSplitShotArgList
//
//	Description:
//		Split a shot 
//
//	Input Arguments:
//	$version: The version of this option box.  Used to know how to 
//	interpret the $args array.
//
//	$args
//	Version 1
//	[0]     $timeMethod : method to set time
//				"currTimeMethod" = use current sequencer time
//				"specifyMethod" = use $time
//  [1] 	$time : time to split shot
//

global proc string[]
doSplitShotArgList( string $version, string $args[], string $shots )
{
    int $versionNo     = $version;
    string $timeMethod = $args[0];
    float $time        = $args[1];

    if ($timeMethod == "currTimeMethod") {
        $time = getSequenceTime();
    }

    // Shift the split time back a frame so the new clip will start at the
    // given time.
    $time = $time - 1;

    // Shots to operate on
    string $selShots[];
        tokenize $shots $selShots;

    // List of shots, existing and new ones will be added
    string $splitShots[] = $selShots;

    if (size($selShots)== 0) 
        error((uiRes("m_doSplitShotArgList.kSelectShots")));

    string $shot;
    for ($shot in $selShots)
    {
        if (nodeType($shot) != "shot")
            continue;

        float $shotStart     = `getAttr ($shot+".sequenceStartFrame")`;
        float $shotEnd       = `getAttr ($shot+".sequenceEndFrame")`;
        float $shotScale     = `getAttr ($shot+".scale")`;
        float $shotOffset    = `getAttr ($shot+".czo")`;
        float $shotOrigStart = `getAttr ($shot+".startFrame")`;
        float $shotOrigEnd   = `getAttr ($shot+".endFrame")`;
        float $shotDuration  = ($shotOrigEnd - $shotOrigStart);

        // verify that the time is within the range of the shot
        //
        if ($time <= $shotStart || $time >= $shotEnd) {
            string $format = (uiRes("m_doSplitShotArgList.kInvalidTime"));
            warning `format -stringArg $time -stringArg $shot $format`;
            continue;
        }

        // Duplicate the shot, and it's connected nodes
        string $newShot = duplicateShot( $shot, ($shot+"End"));

        // Record the new shot
        $splitShots[size($splitShots)] = $newShot;

        // Now trim the shots to enact the split
        shotTrimAfter($shot, $time);
        shotTrimBefore($newShot, ($time+1));

        // The duplicated shots will overlap before the trim, so trim and fix the track index
        int $track = `getAttr ($shot + ".track")`;
        setAttr ($newShot + ".track") $track;
    
        // If an audio node is connected, create an audio node on the new shot using the same audio filename.
        string $aud[] = `listConnections ( $shot + ".audio")`;
        if (size($aud) > 0 )
        {
            string $audio = $aud[0];
            shot -e -audio `getAttr ($audio + ".filename")` $newShot;
            string $newAudio[] = `listConnections ( $newShot + ".audio")`;
            if (size($newAudio) != 0 )
            {
                float $newEnd = (`getAttr ($audio + ".sourceStart")` + 
                    `getAttr ($shot + ".sequenceEndFrame")` +1 - `getAttr ($shot + ".sequenceStartFrame")`);
                sound -e -sourceEnd $newEnd $audio;

                float $newStart = `sound -q -sourceEnd $audio`;// Last frame of previous clip
                sound -e -sourceStart $newStart $newAudio[0];

                $newEnd = (`getAttr ($newAudio[0] + ".sourceStart")` + 
                    `getAttr ($newShot + ".sequenceEndFrame")` +1 - `getAttr ($newShot + ".sequenceStartFrame")`);
                sound -e -sourceEnd $newEnd $newAudio[0];
            }
        }
    }

    // restore the initial selection, plus any new shots created
    //
    select $splitShots;

    return $splitShots;
}

global proc string duplicateShot( string $shot, string $newName )
{
    string $newNodes[] = `duplicate -n $newName $shot`;
    
    if( size( $newNodes) == 0 )
        return "";

    //
    string $newShot =  $newNodes[0];
    
    //The duplicate command above is currently duplicating output connections.
    //We don't want the new shot to be connected to anything at this point, as we are
    //going to try to connect it up below (otherwise we may end up with duplicate connections bug 350034).  
    // So check for any existing connections, and break them before going to do the steps below:
    
    //check source connections:
    string $srcConns[] = `listConnections -s 1 -d 0 -p 1 -c 1 $newShot`;
    int $len = size($srcConns) / 2;
    for($ii=0;$ii<$len;$ii++)
    {
        string $dstPlug = $srcConns[$ii*2];
        string $srcPlug = $srcConns[$ii*2+1];
        disconnectAttr $srcPlug $dstPlug;
    }
    
    //check destination connections:
    string $dstConns[] = `listConnections -s 0 -d 1 -p 1 -c 1 $newShot`;
    $len = size($dstConns) / 2;
    for($ii=0;$ii<$len;$ii++)
    {
        string $srcPlug = $dstConns[$ii*2];
        string $dstPlug = $dstConns[$ii*2+1];
        disconnectAttr $srcPlug $dstPlug;
    }

    // Connect up the new shot to the sequencer, we'll trim the start/end later
    string $shotConnections[] = `listConnections -type sequencer $shot`;

    // This should never happen since all shots need to be connected to the Sequencer
    if (size($shotConnections) == 0 || $shotConnections[0] == "" )
    {
        error((uiRes("m_doSplitShotArgList.kShotNotConnected")));
        return "";
    }

    string $sequencer =  $shotConnections[0];

    // Connect to the same camera shape
    string $cams[] = `listConnections -sh 1 ( $shot + ".currentCamera")`;
    if (size($cams) > 0 )
    {
        string $camera = $cams[0];
        string $src = $camera + ".message";
        string $dst = $newShot + ".currentCamera";
        connectAttr $src $dst;
    }

    // Connect to the same set/members
    string $members[] = `listConnections ( $shot + ".members")`;
    if (size($members) > 0 )
    {
        string $set = $members[0];
        string $src = $set + ".message";
        string $dst = $newShot + ".members";
        connectAttr $src $dst;
    }

    // Build a new image plane and connect it
    string $ip = getShotsImagePlane( $shot );
    if( $ip != "" )
    {

        // Update the shot with the same image file. Do this after the IP is built to ensure we get a copy of the existing IP
        string $image = `getAttr ( $ip + ".imageName" )`;
        shot -e -cl $image $newShot;
    }

    // Link to the Sequencer. Note, depending on the add/delete order, the number of
    // existing shots does not necessarily match the next free index. So check to make
    // sure it's free first.
    //
    int $shotIndex = getNextFreeMultiIndex( ($sequencer + ".shots"), 0);
    string $src = $newShot + ".message";
    string $dst = $sequencer + ".shots[" + $shotIndex + "]";
    connectAttr $src $dst;

    return $newShot;
}
