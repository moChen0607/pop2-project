// Copyright (C) 1997-2014 Autodesk, Inc., and/or its licensors.
// All rights reserved.
//
// The coded instructions, statements, computer programs, and/or related
// material (collectively the "Data") in these files contain unpublished
// information proprietary to Autodesk, Inc. ("Autodesk") and/or its licensors,
// which is protected by U.S. and Canadian federal copyright law and by
// international treaties.
//
// The Data is provided for use exclusively by You. You have the right to use,
// modify, and incorporate this Data into other products for purposes authorized 
// by the Autodesk software license agreement, without fee.
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND. AUTODESK
// DOES NOT MAKE AND HEREBY DISCLAIMS ANY EXPRESS OR IMPLIED WARRANTIES
// INCLUDING, BUT NOT LIMITED TO, THE WARRANTIES OF NON-INFRINGEMENT,
// MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE, OR ARISING FROM A COURSE 
// OF DEALING, USAGE, OR TRADE PRACTICE. IN NO EVENT WILL AUTODESK AND/OR ITS
// LICENSORS BE LIABLE FOR ANY LOST REVENUES, DATA, OR PROFITS, OR SPECIAL,
// DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES, EVEN IF AUTODESK AND/OR ITS
// LICENSORS HAS BEEN ADVISED OF THE POSSIBILITY OR PROBABILITY OF SUCH DAMAGES.

//
//
//  Creation Date:  June 26, 1998
//
//  Description:
//      This script defines the option box for the intersect curves menu item.
//


//
//  Procedure Name:
//      setOptionVars
//
//  Description:
//		Initialize the option values.
//
//  Input Arguments:
//		Whether to set the options to default values.
//
//  Return Value:
//      None.
//
proc setOptionVars(int $forceFactorySettings)
{
	//  Direction Type (0 - don't use direction, 1 - use direction from
	//  option vars, 2 - use active view, 3 - use X axis, 4 - use Y axis, 5 - use Z,
	//	6 - use smart mode: use view vectors in ortho views but don't use direction
	//	in persp view. )
	//	Default value is to use smart mode.
	//
	if ($forceFactorySettings || !`optionVar -exists intersectCurveUseDirection`) {
		optionVar -intValue intersectCurveUseDirection 2;
	}

	//	Direction in x, y, z
	//
	if ($forceFactorySettings || !`optionVar -exists intersectCurveDirX`) {
		optionVar -floatValue intersectCurveDirX 0.0;
	}
	if ($forceFactorySettings || !`optionVar -exists intersectCurveDirY`) {
		optionVar -floatValue intersectCurveDirY 1.0;
	}
	if ($forceFactorySettings || !`optionVar -exists intersectCurveDirZ`) {
		optionVar -floatValue intersectCurveDirZ 0.0;
	}

	// Option to cut all curves with each other OR
	// cut all curves with last curve only
	//	1 - cut all curves with each other
	//	2 - cut all curves with last curve
	//
	if ($forceFactorySettings || 
		!`optionVar -exists intersectCurveWithAllCurvesOrLastCurve`) {
		optionVar -intValue intersectCurveWithAllCurvesOrLastCurve 1;
	}

    // Tolerance for curve intersection - whether to use global (1) or 
	// local (2) tolerance, and the local tolerance (a float)
	//
    if ($forceFactorySettings || 
        !`optionVar -exists crvIntersectUseGlobalTolerance`) {
        optionVar -intValue crvIntersectUseGlobalTolerance 2;
    }
    if ($forceFactorySettings || 
        !`optionVar -exists crvIntersectLocalTolerance`) {
        optionVar -floatValue crvIntersectLocalTolerance 0.01;
    }
}

//
//  Procedure Name:
//      crvIntersectVisibility
//
//  Description:
//		Depending on the options, some other options do or do not show.
//
//  Input Arguments:
//      parent               - Top level parent layout of the option box UI.
//                             Required so that UI object names can be 
//                             successfully resolved.
//  Return Value:
//      None.
//

global proc crvIntersectVisibility( string $parent, int $useGlobalTol )
{
	if( $useGlobalTol < 0 ) {
		$useGlobalTol = `radioButtonGrp -q -select toleranceRadioButtonGrp`;
	}

	if( $useGlobalTol == 1 ) {
		tabLayout -e -vis false localToleranceTabLayout;
	}
	else {
		tabLayout -e -vis true localToleranceTabLayout;
	}
}

//
//  Procedure Name:
//      crvIntersectSetup
//
//  Description:
//		Update the state of the option box UI to reflect the option values.
//
//  Input Arguments:
//      parent               - Top level parent layout of the option box UI.
//                             Required so that UI object names can be 
//                             successfully resolved.
//
//		forceFactorySettings - Whether the option values should be set to
//                             default values.
//
//  Return Value:
//      None.
//

global proc crvIntersectSetup(string $parent,
							  int $forceFactorySettings,
							  string $goToTool)
{
	//	Retrieve the option settings
	//
	setOptionVars($forceFactorySettings);
	intersectCurveToolSetup( $forceFactorySettings, $goToTool );

	setParent $parent;
	//	Set use direction or not:
	//  Direction Type (0 - don't use direction, 1 - use direction from
	//  option vars, 2 - use active view, 3 - use X axis, 4 - use Y axis, 5 - use Z)
	//	(6 - use smart mode: use view vectors in ortho views but don't use direction
	//	in persp view. )
	//
	int $useDir = `optionVar -query intersectCurveUseDirection`;
	if( $useDir == 0 ) {
		radioButtonGrp -edit -select 2 intersectCurveUseDirRadioGrp;
		radioButtonGrp -e -en 0 intersectCurveDirectionGrp;
		radioButtonGrp -e -en 0 intersectCurveDirectionGrp2;
		floatFieldGrp -edit -en 0 intersectCurveDirectionField;
	} else if( $useDir == 6 ) {
		radioButtonGrp -edit -select 1 intersectCurveUseDirRadioGrp;
		radioButtonGrp -e -en 0 intersectCurveDirectionGrp;
		radioButtonGrp -e -en 0 intersectCurveDirectionGrp2;
		floatFieldGrp -edit -en 0 intersectCurveDirectionField;
	} else {
		radioButtonGrp -edit -select 1 intersectCurveUseDirRadioGrp2;
		radioButtonGrp -e -en 1 intersectCurveDirectionGrp;
		radioButtonGrp -e -en 1 intersectCurveDirectionGrp2;
	}

	//	Set the direction radio button and the direction vector values.
	//
	switch( $useDir ) {
		case 1: 							// use direction from option vars
			floatFieldGrp -edit -en 1 intersectCurveDirectionField;
		case 0:
		case 6:
			radioButtonGrp -e -select 2 intersectCurveDirectionGrp2;
			float $dirX = `optionVar -query intersectCurveDirX`;
			float $dirY = `optionVar -query intersectCurveDirY`;
			float $dirZ = `optionVar -query intersectCurveDirZ`;
			floatFieldGrp -edit -v $dirX $dirY $dirZ 0.0 intersectCurveDirectionField;
			break;	
		case 2: 							// use active view
			radioButtonGrp -e -select 1 intersectCurveDirectionGrp2;
			float $viewVector[] = nurbsViewDirectionVector(0);
			floatFieldGrp -e -v1 $viewVector[0] -v2 $viewVector[1]
				-v3 $viewVector[2] intersectCurveDirectionField;
			floatFieldGrp -edit -en 0 intersectCurveDirectionField;
			break;
		case 3: 							// use X axis
			radioButtonGrp -e -select 1 intersectCurveDirectionGrp;
			floatFieldGrp -e -v1 1.0 -v2 0.0 -v3 0.0 intersectCurveDirectionField;
			floatFieldGrp -edit -en 0 intersectCurveDirectionField;
			break;	
		case 4: 							// use Y axis
			radioButtonGrp -e -select 2 intersectCurveDirectionGrp;
			floatFieldGrp -e -v1 0.0 -v2 1.0 -v3 0.0 intersectCurveDirectionField;
			floatFieldGrp -edit -en 0 intersectCurveDirectionField;
			break;	
		case 5:								// use Z axis
			radioButtonGrp -e -select 3 intersectCurveDirectionGrp;
			floatFieldGrp -e -v1 0.0 -v2 0.0 -v3 1.0 intersectCurveDirectionField;
			floatFieldGrp -edit -en 0 intersectCurveDirectionField;
			break;	
	}

	// Option to cut curve with all other curves or with last curve only
	//
	int $intersectAllOrLastCurve = 
		`optionVar -query intersectCurveWithAllCurvesOrLastCurve`;
	radioButtonGrp -edit -select $intersectAllOrLastCurve
		intersectCurveAllOrWithLastCurveGrp;

	// Query the optionVar's and set the values into the controls
	//
	int $useGlobalTol = `optionVar -query crvIntersectUseGlobalTolerance`;
	float $localTol = `optionVar -query crvIntersectLocalTolerance`;

	radioButtonGrp -edit -select $useGlobalTol toleranceRadioButtonGrp;
	floatSliderGrp -edit -value $localTol localTolFloatFieldGrp;

	if( "" != $goToTool ) { 
		checkBoxGrp -e -v1 `scriptCtx -q -euc $goToTool`
		  scriptToolExtraWidget;
		checkBoxGrp -e -v2 `scriptCtx -q -lac $goToTool`
		  scriptToolExtraWidget;
	}

	crvIntersectVisibility $parent $useGlobalTol;
}

//
//  Procedure Name:
//      crvIntersectCallback
//
//  Description:
//		Update the option values with the current state of the option box UI.
//
//  Input Arguments:
//      parent - Top level parent layout of the option box UI.  Required so
//               that UI object names can be successfully resolved.
//
//		doIt   - Whether the command should execute.
//
//  Return Value:
//      None.
//

global proc crvIntersectCallback(string $parent, int $doIt, string $goToTool)
{
	if( "" != $goToTool ) {
		optionVar -iv intersectCurveEuc `scriptCtx -q -euc $goToTool`;
		optionVar -iv intersectCurveLac `scriptCtx -q -lac $goToTool`;
	}
    setParent $parent;

	// Set the optionVar's from the current control values, and then perform 
	// the command
	//
	int $intersectionType = `radioButtonGrp -q -select intersectCurveUseDirRadioGrp`;
	if( $intersectionType == 1 ) {
		// Use smart mode
		optionVar -intValue intersectCurveUseDirection 6;
	} else if( $intersectionType == 2 ) {
		// don't use direction, always find 3d intersections
		optionVar -intValue intersectCurveUseDirection 0;
	} else if( `radioButtonGrp -q -select intersectCurveUseDirRadioGrp` == 1 ) {
		// Use direction
		optionVar -intValue intersectCurveUseDirection 1;
	}

	//  Use Direction option var, intersectCurveUseDirection
	//  Direction Type (0 - don't use direction, 1 - use direction from
	//  option vars, 2 - use active view, 3 - use X axis, 4 - use Y axis, 5 - use Z)
	//	6 - use smart mode: use view vectors in ortho views but don't use direction
	//	in persp view. )
	if( $intersectionType != 1 && $intersectionType != 2 ) {
		int $dirType = `radioButtonGrp -q -select intersectCurveDirectionGrp`;
		switch( $dirType ) {
			case 1:
				optionVar -intValue intersectCurveUseDirection 3;
				break;
			case 2:
				optionVar -intValue intersectCurveUseDirection 4;
				break;
			case 3:
				optionVar -intValue intersectCurveUseDirection 5;
				break;
		}
		int $dirType = `radioButtonGrp -q -select intersectCurveDirectionGrp2`;
		switch( $dirType ) {
			case 1:
				optionVar -intValue intersectCurveUseDirection 2;
				break;
			case 2:
				optionVar -intValue intersectCurveUseDirection 1;
				break;
		}
	}

	// Direction
	//
	float $dirX = `floatFieldGrp -q -v1 intersectCurveDirectionField`;
	float $dirY = `floatFieldGrp -q -v2 intersectCurveDirectionField`;
	float $dirZ = `floatFieldGrp -q -v3 intersectCurveDirectionField`;
	optionVar -floatValue intersectCurveDirX $dirX;
	optionVar -floatValue intersectCurveDirY $dirY;
	optionVar -floatValue intersectCurveDirZ $dirZ;

	// Option to cut curve with all other curves or with last curve only
	//
	int $intersectWithAllOrWithLastCurve = 
		`radioButtonGrp -q -select intersectCurveAllOrWithLastCurveGrp`;
	optionVar -intValue intersectCurveWithAllCurvesOrLastCurve 
		$intersectWithAllOrWithLastCurve;


	// Values for tolerance
	//
	int $useGlobalTol = `radioButtonGrp -q -select toleranceRadioButtonGrp`;
	float $localtol = `floatSliderGrp -q -value localTolFloatFieldGrp`;

	optionVar -intValue crvIntersectUseGlobalTolerance $useGlobalTol;
	optionVar -floatValue crvIntersectLocalTolerance $localtol;

	if( 1 == $doIt ) {
		performIntersectCrv( 0, $goToTool ); 
		string $tmpCmd = "performIntersectCrv( 0, \"" + $goToTool + "\")";
		addToRecentCommandQueue $tmpCmd "Intersect Curves";
	}
	else if( $doIt ) {
		setToolTo $goToTool;
	}
}

//
//  Procedure Name:
//      crvIntersectOptions
//
//  Description:
//		Construct the option box UI.  Involves accessing the standard option
//		box and customizing the UI accordingly.
//
//  Input Arguments:
//      None.
//
//  Return Value:
//      None.
//

proc crvIntersectOptions( int $inTheTool, string $goToTool )
{
	//	Name of the command for this option box.
	//
	string $commandName = "crvIntersect";

	//	Build the option box actions.
	//
	string $callback = ($commandName + "Callback");
	string $setup = ($commandName + "Setup");

	global string $gOptionBoxActionToolItem;
	$gOptionBoxActionToolItem = "modelWithToolIntersectCurve";
	global string $gOptionBoxActionToolItemCB;
	$gOptionBoxActionToolItemCB = "intersectCurveToolScript 3";

	//	Step 1:  Get the option box.
	//	============================
	string $layout = getOptionBox();
	setParent $layout;
	
	//	Step 2:  Pass the command name to the option box.
	//	=================================================
	setOptionBoxCommandName($commandName);
	
	//	Step 3:  Activate the default UI template.
	//	==========================================
	setUITemplate -pushTemplate DefaultTemplate;

	//	Step 4: Create option box contents.
	//	===================================
	
	//	Turn on the wait cursor.
	//
	waitCursor -state 1;

	tabLayout -scr true -tv false;
	
	string $parent = `columnLayout -adjustableColumn 1`;
	
	tabLayout -tabsVisible false directionTabLayout;
		columnLayout directionGroups;

		// radio button group for using direction or not.
		radioButtonGrp -label (uiRes("m_performIntersectCrv.kFindIntersections"))   -nrb 2
			-label1 (uiRes("m_performIntersectCrv.kIn2DAnd3D")) 
			-label2 (uiRes("m_performIntersectCrv.kIn3DOnly")) 
			intersectCurveUseDirRadioGrp;
		radioButtonGrp  -nrb 1 -shareCollection intersectCurveUseDirRadioGrp
			-label1 (uiRes("m_performIntersectCrv.kUseDirection")) 
			intersectCurveUseDirRadioGrp2;

		// Two sets of radio buttons - for projecting the curves before
		// intersecting.
		radioButtonGrp -label (uiRes("m_performIntersectCrv.kDirection"))  -numberOfRadioButtons 3
			-label1 (uiRes("m_performIntersectCrv.kX")) 
			-label2 (uiRes("m_performIntersectCrv.kY")) 
			-label3 (uiRes("m_performIntersectCrv.kZ")) 
			-select 1
			intersectCurveDirectionGrp;

		radioButtonGrp -shareCollection intersectCurveDirectionGrp
			-numberOfRadioButtons 2
			-label1 (uiRes("m_performIntersectCrv.kActiveView")) 
			-label2 (uiRes("m_performIntersectCrv.kFree")) 
			intersectCurveDirectionGrp2;

		floatFieldGrp -label (uiRes("m_performIntersectCrv.kDirectionValue"))  
			-numberOfFields 3 intersectCurveDirectionField;

		// Option whether or not to cut all curves with each other
		// or cut all curves with the last curve.
		radioButtonGrp -label (uiRes("m_performIntersectCrv.kIntersect")) 
			-numberOfRadioButtons 2 
			-label1 (uiRes("m_performIntersectCrv.kAllCurves")) 
			-label2 (uiRes("m_performIntersectCrv.kWithLastCurveOnly")) 
			intersectCurveAllOrWithLastCurveGrp;
		setParent ..;
	setParent ..;

	tabLayout -tabsVisible false toleranceTabLayout;
		columnLayout toleranceGroups;
			radioButtonGrp
				-numberOfRadioButtons 2
				-label (uiRes("m_performIntersectCrv.kUseTolerance")) 
				-label1 (uiRes("m_performIntersectCrv.kGlobal")) 
				-label2 (uiRes("m_performIntersectCrv.kLocal")) 
				toleranceRadioButtonGrp;
		
			tabLayout -tabsVisible false localToleranceTabLayout;
				columnLayout localToleranceSlider;
					floatSliderGrp -label (uiRes("m_performIntersectCrv.kTolerance"))  
						-min 0.001 -max 1.0 -fmn 0.00001 -fmx 1000.0
						localTolFloatFieldGrp;
				setParent ..;
			setParent ..;
		setParent ..;
	setParent ..;

	if( $inTheTool ) {
		separator;
		checkBoxGrp -ncb 2 -label (uiRes("m_performIntersectCrv.kToolBehavior")) 
		  -label1 (uiRes("m_performIntersectCrv.kExitOnCompletion")) 
		  -v1 off
		  -on1 ("scriptCtx -e -euc true " + $goToTool)
		  -of1 ("scriptCtx -e -euc false " + $goToTool)

		  -label2 (uiRes("m_performIntersectCrv.kAutoCompletion")) 
		  -v2 on
		  -on2 ("scriptCtx -e -lac true -ssc 2 " + $goToTool)
		  -of2 ("scriptCtx -e -lac false -ssc 0 " + $goToTool)
		  scriptToolExtraWidget;
	}

	//--------------------------------------------
	// Now link some of the controls together....
	//--------------------------------------------

	// Edit the "Find Intersections" radio button grp so that it enables/disables
	// the other direction vector controls.
	string $onCmd = "radioButtonGrp -e -en 1 intersectCurveDirectionGrp;" +
		"radioButtonGrp -e -en 1 intersectCurveDirectionGrp2;" +
		"if( `radioButtonGrp -q -select intersectCurveDirectionGrp2` == 2) " +
		"floatFieldGrp -e -en 1 intersectCurveDirectionField;";
	string $offCmd = "radioButtonGrp -e -en 0 intersectCurveDirectionGrp;" +
		"radioButtonGrp -e -en 0 intersectCurveDirectionGrp2;" +
		"if( `radioButtonGrp -q -select intersectCurveDirectionGrp2` == 2) " +
		"floatFieldGrp -e -en 0 intersectCurveDirectionField;";
	radioButtonGrp  -e
		-onCommand1 $offCmd
		-onCommand2 $offCmd
		intersectCurveUseDirRadioGrp;
	radioButtonGrp -e
		-onCommand1 $onCmd			// use direction button
		intersectCurveUseDirRadioGrp2;

	// Edit the "X" direction button so when it's selected, then 
	// the direction field will be (1, 0, 0)
	$onCmd = "floatFieldGrp -e -en 0 intersectCurveDirectionField;" +
			"floatFieldGrp -e -v 1.0 0.0 0.0 0.0 intersectCurveDirectionField;";
	radioButtonGrp -e -onCommand1 $onCmd intersectCurveDirectionGrp;

	// Edit the "Y" direction button so when it's selected, then 
	// the direction field will be (0, 1, 0)
	$onCmd = "floatFieldGrp -e -en 0 intersectCurveDirectionField;" +
			"floatFieldGrp -e -v 0.0 1.0 0.0 0.0 intersectCurveDirectionField;";
	radioButtonGrp -e -onCommand2 $onCmd intersectCurveDirectionGrp;

	// Edit the "Z" direction button so when it's selected, then 
	// the direction field will be (0, 0, 1)
	$onCmd = "floatFieldGrp -e -en 0 intersectCurveDirectionField;" +
			"floatFieldGrp -e -v 0.0 0.0 1.0 0.0 intersectCurveDirectionField;";
	radioButtonGrp -e -onCommand3 $onCmd intersectCurveDirectionGrp;

	// Edit the "Active View" direction button so when it's selected, then 
	// the float field group is disabled.
	$onCmd = "floatFieldGrp -e -en 0 intersectCurveDirectionField;" +
		"float $v[] = nurbsViewDirectionVector(0);" +
		"floatFieldGrp -e -v1 $v[0] -v2 $v[1] -v3 $v[2] intersectCurveDirectionField;"
	;
	radioButtonGrp -e -onCommand1 $onCmd intersectCurveDirectionGrp2;

	// Edit the "Free" direction button so when it's selected, then
	// the float field group is enabled.
	$onCmd = "floatFieldGrp -e -en 1 intersectCurveDirectionField;";
	radioButtonGrp -e -onCommand2 $onCmd intersectCurveDirectionGrp2;

	// Set the tolerance radio button up so that when "Global" is
	// selected, then the local tolerance slider is disabled.
	// When "Local" is selected then the local tolerance slider is enabled.
	//
	radioButtonGrp -edit
		-cc1 ("crvIntersectVisibility " + $parent + " 1")
		-cc2 ("crvIntersectVisibility " + $parent + " 0")
		toleranceRadioButtonGrp;

	//	Turn off the wait cursor.
	//
	waitCursor -state 0;
	
	//	Step 5: Deactivate the default UI template.
	//  ===========================================
	//
	setUITemplate -popTemplate;

	//	Step 6: Customize the buttons.  
	//	==============================

	//	'Apply' button.
	//
	string $applyBtn = getOptionBoxApplyBtn();
	if( $inTheTool ) {
		button -edit -label (uiRes("m_performIntersectCrv.kIntersectTool")) 
			-command ($callback + " " + $parent + " 3 \"" + $goToTool + "\"")
			$applyBtn;
	}
	else {
		button -edit -label (uiRes("m_performIntersectCrv.kIntersectButton")) 
			-command ($callback + " " + $parent + " 1 \"" + $goToTool + "\"")
			$applyBtn;
	}

	//	'Save' button.
	//
	string $saveBtn = getOptionBoxSaveBtn();
	button -edit 
		-command ($callback + " " + $parent + " 0 \"" +
				  $goToTool + "\"; hideOptionBox")
		$saveBtn;

	//	'Reset' button.
	//
	string $resetBtn = getOptionBoxResetBtn();
	button -edit 
		-command ($setup + " " + $parent + " 1 \"" + $goToTool + "\"")
		$resetBtn;

	//	Step 7: Set the option box title.
	//	=================================
	//
	if( $inTheTool ) {
		setOptionBoxTitle (uiRes("m_performIntersectCrv.kIntersectCurvesToolOptions"));
	} else {
		setOptionBoxTitle (uiRes("m_performIntersectCrv.kIntersectCurvesOptions"));
	}

	//	Step 8: Customize the 'Help' menu item text.
	//	============================================
	//
	setOptionBoxHelpTag( "IntersectCurves" );

	//	Step 9: Set the current values of the option box.
	//	=================================================
	//
	eval ($setup + " " + $parent + " 0 \"" + $goToTool + "\"");	
	
	//	Step 10: Show the option box.
	//	=============================
	//
	showOptionBox();
}

//
//  Procedure Name:
//      crvIntersectHelp
//
//  Description:
//		Return a short description about this command.
//
//  Input Arguments:
//      None.
//
//  Return Value:
//      string.
//

proc string crvIntersectHelp()
{
	return 
	"  Command: Intersect Curves - Intersects two NURBS curves to generate parameter locators on each curve. \n";
}

//
//  Procedure Name:
//      assembleCmd
//
//  Description:
//		Construct the command that will apply the option box values.
//
//  Input Arguments:
//      None.
//
//  Return Value:
//      None.
//
proc string assembleCmd()
{
	string $cmd = "intersectCrvPreset";

	setOptionVars(false);

	int $doHistory = `constructionHistory -q -tgl`;

	// query direction type and direction vector
	int $useDirection = `optionVar -query intersectCurveUseDirection`;
	float $dirX = `optionVar -query intersectCurveDirX`;
	float $dirY = `optionVar -query intersectCurveDirY`;
	float $dirZ = `optionVar -query intersectCurveDirZ`;

	int $intersectWithAllOrLast = 
		`optionVar -query intersectCurveWithAllCurvesOrLastCurve`;

	float $globalTol = `optionVar -q positionalTolerance`;

	int $crvUseGlobalTol = `optionVar -q crvIntersectUseGlobalTolerance`;
	float $crvLocalTol = `optionVar -q crvIntersectLocalTolerance`;

	// note: 1 means global and 2 is local
	//
	float $tolerance;
	if ( $crvUseGlobalTol == 1 ) $tolerance = $globalTol;
	else $tolerance = $crvLocalTol;

	$cmd = ( $cmd + " " +
			 $doHistory + " " +
			 $tolerance + " " +
			 $useDirection + " " + $dirX + " " + $dirY + " " + $dirZ+ " " + 
			 $intersectWithAllOrLast   );

	return $cmd;
}

//
//  Procedure Name:
//      performIntersectCrv
//
//  Description:
//		Perform the intersect curves command using the corresponding 
//		option values.  This procedure will also show the option box
//		window if necessary as well as construct the command string
//		that will invoke the intersect curves command with the current
//		option box values.
//
//  Input Arguments:
//      0 - Execute the command.
//      1 - Show the option box dialog.
//      2 - Return the command.
//
//  Return Value:
//      None.
//

global proc string performIntersectCrv(int $action, string $goToTool)
{
	int $inTheTool = false;
	if( 3 == $action ) {
		$action = 1;
		$inTheTool = true;
	}

	string $cmd = "";
	switch ($action) {
	  case 0:
		setOptionVars(false);
		$cmd = `assembleCmd`;
		evalEcho($cmd);
		break;

	  case 1:
		crvIntersectOptions( $inTheTool, $goToTool );
		break;

	  case 2:
	  default:
		setOptionVars (false);
		$cmd = `assembleCmd`;
		break;
	}
	return $cmd;
}

