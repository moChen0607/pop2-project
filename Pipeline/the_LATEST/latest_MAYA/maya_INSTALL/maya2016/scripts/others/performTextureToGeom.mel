// Copyright (C) 1997-2014 Autodesk, Inc., and/or its licensors.
// All rights reserved.
//
// The coded instructions, statements, computer programs, and/or related
// material (collectively the "Data") in these files contain unpublished
// information proprietary to Autodesk, Inc. ("Autodesk") and/or its licensors,
// which is protected by U.S. and Canadian federal copyright law and by
// international treaties.
//
// The Data is provided for use exclusively by You. You have the right to use,
// modify, and incorporate this Data into other products for purposes authorized 
// by the Autodesk software license agreement, without fee.
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND. AUTODESK
// DOES NOT MAKE AND HEREBY DISCLAIMS ANY EXPRESS OR IMPLIED WARRANTIES
// INCLUDING, BUT NOT LIMITED TO, THE WARRANTIES OF NON-INFRINGEMENT,
// MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE, OR ARISING FROM A COURSE 
// OF DEALING, USAGE, OR TRADE PRACTICE. IN NO EVENT WILL AUTODESK AND/OR ITS
// LICENSORS BE LIABLE FOR ANY LOST REVENUES, DATA, OR PROFITS, OR SPECIAL,
// DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES, EVEN IF AUTODESK AND/OR ITS
// LICENSORS HAS BEEN ADVISED OF THE POSSIBILITY OR PROBABILITY OF SUCH DAMAGES.

global int $gEnableMeshGenerationSettings = 0;

global proc textureToGeomImageFileLoad( string $layout, string $filename,
										string $fileType )
{
	string $oldParent = `setParent -query`;
	setParent $layout; 
	if ( `textFieldButtonGrp -exists textureToGeomInputFile` ) { 
		textFieldButtonGrp -edit 
			-text $filename textureToGeomInputFile; 
	} 
	setParent $oldParent;
}

global proc textureToGeomFileBrowser( string $layout, string $type ) 
{
	if ( $type == "image" ) { 
		string $cmd = ("textureToGeomImageFileLoad " + $layout);
		fileBrowser( $cmd, (uiRes("m_performTextureToGeom.kSelectImage")), "image", 0 ); 
	} 
}

proc setOptionVars (int $forceFactorySettings)
{
	// Input image settings. 
	//
	if( $forceFactorySettings || 
		!`optionVar -exists textureToGeomInputFileOV`) {
		optionVar -stringValue textureToGeomInputFileOV "";
	}

	// Segmentation options 
	// 
	if ( $forceFactorySettings ||
		 !`optionVar -exists textureToGeomQuantizeOV` ) { 
		optionVar -intValue textureToGeomQuantizeOV 0; 
	}
	if ( $forceFactorySettings ||
		 !`optionVar -exists textureToGeomQuantLevelsOV` ) { 
		optionVar -intValue textureToGeomQuantLevelsOV 10; 
	}
	
	if ( $forceFactorySettings || 
		 !`optionVar -exists textureToGeomSpatialRadiusOV` ) { 
		optionVar -intValue textureToGeomSpatialRadiusOV 7; 
	}

	if ( $forceFactorySettings ||
		 !`optionVar -exists textureToGeomMinSegmentSizeOV` ) { 
		optionVar -floatValue textureToGeomMinSegmentSizeOV 0.005; 
	}

	if ( $forceFactorySettings || 
		 !`optionVar -exists textureToGeomColorRangeOV` ) { 
		optionVar -floatValue textureToGeomColorRangeOV 4.5;
	}

	if ( $forceFactorySettings || 
		 !`optionVar -exists textureToGeomMaxColorDiffOV` ) { 
		optionVar -floatValue textureToGeomMaxColorDiffOV 0.125; 
	}

	global int $gEnableMeshGenerationSettings;

	// Mesh generation
	//
	if ( $gEnableMeshGenerationSettings ) {
		if ( $forceFactorySettings ||
			 !`optionVar -exists textureToGeomSmoothBoundaryOV` ) { 
			optionVar -intValue textureToGeomSmoothBoundaryOV 1 ;
		}

		if ( $forceFactorySettings ||
			 !`optionVar -exists textureToGeomSmoothFactorOV` ) { 
			optionVar -floatValue textureToGeomSmoothFactorOV 0.5; 
		}

		if ( $forceFactorySettings ||
			 !`optionVar -exists textureToGeomHardCornerDetectOV` ) { 
			optionVar -intValue textureToGeomHardCornerDetectOV 1; 
		}

		if ( $forceFactorySettings ||
			 !`optionVar -exists textureToGeomHardCornerMaxLenOV` ) { 
			optionVar -floatValue textureToGeomHardCornerMaxLenOV 10.0; 
		}
	
		if ( $forceFactorySettings ||
			 !`optionVar -exists textureToGeomSimplifyBoundaryOV` ) { 
			optionVar -intValue textureToGeomSimplifyBoundaryOV 1; 
		}

		if ( $forceFactorySettings || 
			 !`optionVar -exists textureToGeomMeshQualityOV` ) { 
			optionVar -floatValue textureToGeomMeshQualityOV 0.1;
		}
	}

	if ( $forceFactorySettings ||
		 !`optionVar -exists textureToGeomMaxPointsOV` ) { 
		optionVar -intValue textureToGeomMaxPointsOV 0;
	}

	// Constraint mesh 
	// 
	if ( $forceFactorySettings || 
		 !`optionVar -exists textureToGeomFitToSelectedOV` ) { 
		optionVar -intValue textureToGeomFitToSelectedOV 1;
	}
	
	if ( $forceFactorySettings ||
		 !`optionVar -exists textureToGeomFitOffsetOV` ) { 
		optionVar -floatValue textureToGeomFitOffsetOV 0.01; 
	}

	if ( $forceFactorySettings ||
		 !`optionVar -exists textureToGeomFitUVSetOV` ) { 
		optionVar -stringValue textureToGeomFitUVSetOV "";
	}
	
	// Shader generation 
	//
	if ( $forceFactorySettings ||
		 !`optionVar -exists textureToGeomCreateShadersOV` ) { 
		optionVar -intValue textureToGeomCreateShadersOV 1;
	}

	if ( $forceFactorySettings ||
		 !`optionVar -exists textureToGeomShaderTemplateOV` ) { 
		optionVar -stringValue textureToGeomShaderTemplateOV "";
	}
}

global proc textureToGeomSetup (string $parent, int $forceFactorySettings)
{
	// Retrieve the option settings
	//
	setOptionVars( $forceFactorySettings );
	setParent $parent;

	if ( `textFieldButtonGrp -exists textureToGeomInputFile` ) { 
		string $iname = `optionVar -query textureToGeomInputFileOV`;
		textFieldButtonGrp -edit 
			-text $iname textureToGeomInputFile; 
	}

	int $enabled = 0; 
	if ( `checkBoxGrp -exists textureToGeomQuantize` ) { 
		$enabled = `optionVar -query textureToGeomQuantizeOV`; 
		checkBoxGrp -edit 
			-value1 $enabled textureToGeomQuantize; 
	}

	if ( `intSliderGrp -exists textureToGeomQuantLevels` ) { 
		int $val = `optionVar -query textureToGeomQuantLevelsOV`; 
		intSliderGrp -edit 
			-value $val textureToGeomQuantLevels; 
		intSliderGrp -edit -en $enabled textureToGeomQuantLevels; 
	}

	if ( `intSliderGrp -exists textureToGeomSpatialRadius` ) { 
		int $val = `optionVar -query textureToGeomSpatialRadiusOV`; 
		intSliderGrp -edit 
			-value $val textureToGeomSpatialRadius;
	}
	
	if ( `floatSliderGrp -exists textureToGeomMinSegmentSize` ) { 
		float $val = `optionVar -query textureToGeomMinSegmentSizeOV`; 
		floatSliderGrp -edit 
			-value $val textureToGeomMinSegmentSize;
	}

	if ( `floatSliderGrp -exists textureToGeomColorRange` ) { 
		float $val = `optionVar -query textureToGeomColorRangeOV`; 
		floatSliderGrp -edit 
			-value $val textureToGeomColorRange; 
	}

	if ( `floatSliderGrp -exists textureToGeomMaxColorDiff` ) { 
		float $val = `optionVar -query textureToGeomMaxColorDiffOV`;
		floatSliderGrp -edit 
			-value $val textureToGeomMaxColorDiff;
	}

	global int $gEnableMeshGenerationSettings;

	if ( $gEnableMeshGenerationSettings ) {
		// Meshing properties. 
		//
		int $smoothEnabled = 1; 
		if ( `checkBoxGrp -exists textureToGeomSmoothBoundary` ) { 
			$smoothEnabled = `optionVar -query textureToGeomSmoothBoundaryOV`; 
			checkBoxGrp -edit 
				-value1 $smoothEnabled textureToGeomSmoothBoundary; 
		}

		if ( `floatSliderGrp -exists textureToGeomSmoothFactor` ) { 
			float $value = `optionVar -query textureToGeomSmoothFactorOV`; 
			floatSliderGrp -edit 
				-value $value textureToGeomSmoothFactor; 
			floatSliderGrp -edit -en $smoothEnabled textureToGeomSmoothFactor;
		}

		int $hardEnabled = 1;
		if ( `checkBoxGrp -exists textureToGeomHardCornerDetect` ) { 
			$hardEnabled = `optionVar -query textureToGeomHardCornerDetectOV`; 
			checkBoxGrp -edit 
				-value1 $hardEnabled textureToGeomHardCornerDetect; 
		}

		if ( `floatSliderGrp -exists textureToGeomHardCornerMaxLen` ) { 
			float $val = `optionVar -query textureToGeomHardCornerMaxLenOV`; 
			floatSliderGrp -edit 
				-value $val textureToGeomHardCornerMaxLen; 
			floatSliderGrp -edit -en $hardEnabled textureToGeomHardCornerMaxLen;
		}
		
		if ( `checkBoxGrp -exists textureToGeomSimplifyBoundary` ) { 
			int $val = `optionVar -query textureToGeomSimplifyBoundaryOV`; 
			checkBoxGrp -edit -value1 $val textureToGeomSimplifyBoundary;
		}

		if ( `floatSliderGrp -exists textureToGeomMeshQuality` ) { 
			float $val = `optionVar -query textureToGeomMeshQualityOV`; 
			floatSliderGrp -edit 
				-value $val textureToGeomMeshQuality; 
		}
	}

	if ( `intSliderGrp -exists textureToGeomMaxPoints` ) { 
		int $val = `optionVar -query textureToGeomMaxPointsOV`; 
		intSliderGrp -edit 
			-value $val textureToGeomMaxPoints; 
	}

	// Fit to surface properties 
	//
	int $fitEnabled = 0;
	if ( `checkBoxGrp -exists textureToGeomFitToSelected` ) { 
		$fitEnabled = `optionVar -query textureToGeomFitToSelectedOV`;
		checkBoxGrp -edit -value1 $fitEnabled textureToGeomFitToSelected; 

	}

	if ( `floatSliderGrp -exists textureToGeomFitOffset` ) { 
		float $val = `optionVar -query textureToGeomFitOffsetOV`; 
		floatSliderGrp -edit -value $val textureToGeomFitOffset; 
		floatSliderGrp -edit -en $fitEnabled textureToGeomFitOffset; 
	}

	if ( `textFieldGrp -exists textureToGeomFitUVSet` ) { 
		string $text = `optionVar -query textureToGeomFitUVSetOV`;
		textFieldGrp -edit -text $text textureToGeomFitUVSet;
		textFieldGrp -edit -en $fitEnabled textureToGeomFitUVSet;
	}

	// Shader properties
	//
	if ( `checkBoxGrp -exists textureToGeomCreateShaders` ) { 
		int $val = `optionVar -query textureToGeomCreateShadersOV`; 
		checkBoxGrp -edit
			-value1 $val textureToGeomCreateShaders; 
	}

	if ( `optionMenuGrp -exists textureToGeomShaderTemplate` ) { 
		string $menuGrp = "textureToGeomShaderTemplate";
		string $val = `optionVar -query textureToGeomShaderTemplateOV`;
		string $menuItems[] = `optionMenuGrp -q -ill $menuGrp`;
		int $accept = 0;
		for ( $menu in $menuItems ) { 
			string $menuLabel = `menuItem -q -label $menu`;
			if ( $menuLabel == $val ) { 
				$accept = 1; 
				break;
			}
		}
		if ( $val == "" || !$accept ) { 
			$val = uiRes("m_performTextureToGeom.kDefault"); 
		}
		optionMenuGrp -edit -value $val $menuGrp; 
	}
}

global proc textureToGeomCallback(string $parent, int $doIt)
{
	setParent $parent; 
	
	// Input image. 
	// 
	if ( `textFieldButtonGrp -exists textureToGeomInputFile` ) { 
		string $val = `textFieldButtonGrp -query
								-text textureToGeomInputFile`; 
		optionVar -stringValue textureToGeomInputFileOV $val;
	}

	// Segmentation Options 
	//
	if ( `checkBoxGrp -exists textureToGeomQuantize` ) { 
		int $val = `checkBoxGrp -query -value1 textureToGeomQuantize`; 
		optionVar -intValue textureToGeomQuantizeOV $val; 
	}

	if ( `intSliderGrp -exists textureToGeomQuantLevels` ) { 
		int $val = `intSliderGrp -query -value textureToGeomQuantLevels`; 
		optionVar -intValue textureToGeomQuantLevelsOV $val;
	}

	if ( `intSliderGrp -exists textureToGeomSpatialRadius` ) { 
		int $val = `intSliderGrp -query -value textureToGeomSpatialRadius`;
		optionVar -intValue textureToGeomSpatialRadiusOV $val; 
	}
	
	if ( `floatSliderGrp -exists textureToGeomMinSegmentSize` ) { 
		float $val = `floatSliderGrp -query -value textureToGeomMinSegmentSize`;
		optionVar -floatValue textureToGeomMinSegmentSizeOV $val; 
	}

	if ( `floatSliderGrp -exists textureToGeomColorRange` ) { 
		float $val = `floatSliderGrp -query -value textureToGeomColorRange`; 
		optionVar -floatValue textureToGeomColorRangeOV $val; 
	}

	if ( `floatSliderGrp -exists textureToGeomMaxColorDiff` ) { 
		float $val = `floatSliderGrp -query -value textureToGeomMaxColorDiff`;
		optionVar -floatValue textureToGeomMaxColorDiffOV $val; 
	}

	global int $gEnableMeshGenerationSettings;

	if ( $gEnableMeshGenerationSettings ) {
		// Meshing 
		// 
		if ( `checkBoxGrp -exists textureToGeomSmoothBoundary` ) { 
			int $val = 
				`checkBoxGrp -query -value1 textureToGeomSmoothBoundary`; 
			optionVar -intValue textureToGeomSmoothBoundaryOV $val; 
		}

		if ( `floatSliderGrp -exists textureToGeomSmoothFactor` ) { 
			float $val = 
				`floatSliderGrp -query -value textureToGeomSmoothFactor`;
			optionVar -floatValue textureToGeomSmoothFactorOV $val; 
		}

		if ( `checkBoxGrp -exists textureToGeomHardCornerDetect` ) { 
			int $val = 
				`checkBoxGrp -query -value1 textureToGeomHardCornerDetect`;
			optionVar -intValue textureToGeomHardCornerDetectOV $val; 
		}

		if ( `floatSliderGrp -exists textureToGeomHardCornerMaxLen` ) { 
			float $val = 
				`floatSliderGrp -query -value textureToGeomHardCornerMaxLen`; 
			optionVar -floatValue textureToGeomHardCornerMaxLenOV $val; 
		}
	
		if ( `checkBoxGrp -exists textureToGeomSimplifyBoundary` ) { 
			int $val = 
				`checkBoxGrp -query -value1 textureToGeomSimplifyBoundary`;
			optionVar -intValue textureToGeomSimplifyBoundaryOV $val; 
		}

		if ( `floatSliderGrp -exists textureToGeomMeshQuality` ) { 
			float $val = `floatSliderGrp -query 
				-value textureToGeomMeshQuality`; 
			optionVar -floatValue textureToGeomMeshQualityOV $val;
		}
	}
	
	if ( `intSliderGrp -exists textureToGeomMaxPoints` ) { 
		int $val = `intSliderGrp -query -value textureToGeomMaxPoints`; 
		optionVar -intValue textureToGeomMaxPointsOV $val; 
	}

	// Fit to surface properties 
	//
	if ( `checkBoxGrp -exists textureToGeomFitToSelected` ) { 
		int $val = `checkBoxGrp -query -value1 textureToGeomFitToSelected`;
		optionVar -intValue textureToGeomFitToSelectedOV $val; 
	}

	if ( `floatSliderGrp -exists textureToGeomFitOffset` ) { 
		float $val = `floatSliderGrp -query -value textureToGeomFitOffset`; 
		optionVar -floatValue textureToGeomFitOffsetOV $val; 

	}

	if ( `textFieldGrp -exists textureToGeomFitUVSet` ) { 
		string $text = `textFieldGrp -query -text textureToGeomFitUVSet`;
		optionVar -stringValue textureToGeomFitUVSetOV $text;
	}
	
	// Shader generation 
	// 
	if ( `checkBoxGrp -exists textureToGeomCreateShaders` ) {
		int $val = `checkBoxGrp -query
						-value1 textureToGeomCreateShaders`;
		optionVar -intValue textureToGeomCreateShadersOV $val;
	}
	if ( `optionMenuGrp -exists textureToGeomShaderTemplate` ) { 
		string $val = `optionMenuGrp -query -value textureToGeomShaderTemplate`;
		if ( $val == (uiRes("m_performTextureToGeom.kDefault"))) { 
			$val = ""; 
		}
		optionVar -stringValue textureToGeomShaderTemplateOV $val; 
	}

	if ( $doIt ) { 
		string $performCommand = "performTextureToGeom 0";
		eval( $performCommand );
		addToRecentCommandQueue $performCommand ""; 
	}
}

global proc TGdisableFloatUI( string $parent, string $ui, int $state )
{
	string $oldparent = `setParent -q`; 
	setParent $parent; 
	
	floatSliderGrp -edit -en $state $ui;

	setParent $oldparent;
}

global proc TGdisableFloatTxtUI( string $parent, string $uifloat, 
								 string $uitxt, int $state )
{
	TGdisableFloatUI( $parent, $uifloat, $state ); 
	string $oldparent = `setParent -q`; 
	setParent $parent; 
	textFieldGrp -edit -en $state $uitxt; 
	setParent $oldparent; 
}

global proc TGdisableIntUI( string $parent, string $ui, int $state )
{
	string $oldparent = `setParent -q`; 
	setParent $parent; 
	
	intSliderGrp -edit -en $state $ui; 
	
	setParent $oldparent; 
}

global proc textureToGeomSetupOptionMenus( string $parent ) 
{
	string $oldparent = `setParent -q`;
	string $menuItems[] = `optionMenuGrp -q -ill $parent`;
    string $menuItem;
    for ( $menuItem in $menuItems ) {
        deleteUI -mi $menuItem;
    }

	string $nodes[]; 
	$nodes[0] = (uiRes("m_performTextureToGeom.kDefault"));
	int $index = 1; 
	string $types[] = `listNodeTypes "shader/surface"`;
	for ( $type in $types ) { 
		string $materialArray[] = `ls -exactType $type`;
		for ( $material in $materialArray ) { 
			$nodes[$index] = $material;
			$index = $index + 1;
		}
	}

	setParent $parent; 
	for ( $node in $nodes ) { 
		menuItem -label $node -p ($parent + "|OptionMenu");
	}
	setParent $oldparent;
}

proc createTextureToGeomUI( string $layout )
{
	string $parent; 

	setUITemplate -pushTemplate DefaultTemplate; 
	
	scrollLayout; 
	
	columnLayout 
		-adj true
		-columnAttach "both" 5
		-columnOffset "both" 5; 

	frameLayout -label (uiRes("m_performTextureToGeom.kImageProperties"))
		-collapsable true -collapse false textureToGeomImageProperties;
	
		columnLayout -adj true; 

		textFieldButtonGrp -label (uiRes("m_performTextureToGeom.kInputImage"))  
			-buttonLabel (uiRes("m_performTextureToGeom.kSelect"))	
			-buttonCommand ("textureToGeomFileBrowser " + $layout + " image")
			textureToGeomInputFile;
	
		setParent ..;
	setParent ..; 

	frameLayout -label (uiRes("m_performTextureToGeom.kSegmentDetectionOptions")) 
		-collapsable true -collapse false textureToGeomSegmentOptions;
		
		$parent = `columnLayout -adj true`;

		checkBoxGrp -ncb 1 -label1 "" -label (uiRes("m_performTextureToGeom.kQuantize"))  textureToGeomQuantize;
		string $slider = `intSliderGrp -label (uiRes("m_performTextureToGeom.kQuantizeLevels"))  -min 1 -max 64
			textureToGeomQuantLevels`;

		checkBoxGrp -edit -onCommand1  
			("TGdisableIntUI(\"" + $parent + "\", \"" + $slider + "\", 1)")
				-offCommand1 
			("TGdisableIntUI(\"" + $parent + "\", \"" + $slider + "\", 0)")		
			textureToGeomQuantize;
		
		intSliderGrp -label (uiRes("m_performTextureToGeom.kSearchRadius"))  -min 3 -max 10 
			textureToGeomSpatialRadius;

		floatSliderGrp -label (uiRes("m_performTextureToGeom.kMinimumSegmentSize"))  -min 0.0001 -max 0.5 
			textureToGeomMinSegmentSize; 
		
		floatSliderGrp -label (uiRes("m_performTextureToGeom.kColorRange"))  -min 1.0 -max 10.0 
			textureToGeomColorRange; 

		floatSliderGrp -label (uiRes("m_performTextureToGeom.kMaxColorDifference"))  -min 0.0001 -max 0.5
			textureToGeomMaxColorDiff; 
		
		setParent ..;
	setParent ..;
	
	global int $gEnableMeshGenerationSettings;
	frameLayout -label (uiRes("m_performTextureToGeom.kSegmentMeshingOptions")) 
		-collapsable true -collapse false textureToGeomMeshingOptions;

		columnLayout -adj true; 

	string $points = (uiRes("m_performTextureToGeom.kMaxPoints"));
	if ( $gEnableMeshGenerationSettings ) {
		frameLayout -label (uiRes("m_performTextureToGeom.kSmoothing"))
			-collapsable false textureToGeomMeshingSmooth; 

				$parent = `columnLayout -adj true`;
				checkBoxGrp -ncb 1 -label1 "" -label (uiRes("m_performTextureToGeom.kSmoothBoundaries")) 
					textureToGeomSmoothBoundary; 

				string $slider = 
					`floatSliderGrp -label (uiRes("m_performTextureToGeom.kSmoothingFactor"))  -min 0.0 -max 0.8 
						textureToGeomSmoothFactor`; 

				checkBoxGrp -edit -onCommand1  
					("TGdisableFloatUI(\"" + $parent + "\", \"" + $slider + "\", 1)")
					-offCommand1 
					("TGdisableFloatUI(\"" + $parent + "\", \"" + $slider + "\", 0)")
					textureToGeomSmoothBoundary;
			setParent ..;
		setParent ..;

		frameLayout -label (uiRes("m_performTextureToGeom.kCornerDetection"))
			-collapsable false textureToGeomMeshingCorner; 
		
				$parent = `columnLayout -adj true`;
				checkBoxGrp -ncb 1 -label1 "" -label (uiRes("m_performTextureToGeom.kHardCornerDetection"))  
					textureToGeomHardCornerDetect; 

				string $slider = 
					`floatSliderGrp -label (uiRes("m_performTextureToGeom.kHardCornerMaxLength"))  
					-min 1.0 -max 90.0 textureToGeomHardCornerMaxLen`;

				checkBoxGrp -edit -onCommand1  
					("TGdisableFloatUI(\"" + $parent + "\", \"" + $slider + "\", 1)")
					-offCommand1 
					("TGdisableFloatUI(\"" + $parent + "\", \"" + $slider + "\", 0)")
					textureToGeomHardCornerDetect; 
				setParent ..;
		setParent ..; 

		frameLayout -label (uiRes("m_performTextureToGeom.kQuality")) 
			-collapsable false textureToGeomMeshingQuality; 
		
				columnLayout -adj true; 

				checkBoxGrp -ncb 1 -label1 "" -label (uiRes("m_performTextureToGeom.kSimplifyBoundaries"))  
					textureToGeomSimplifyBoundary; 

				floatSliderGrp -label (uiRes("m_performTextureToGeom.kMeshQuality"))  -min 0.0 -max 1.0
					textureToGeomMeshQuality;

				intSliderGrp -label $points  textureToGeomMaxPoints;
				
				setParent ..;
		setParent ..;
	} else { 
		columnLayout -adj true; 
		intSliderGrp -label $points  textureToGeomMaxPoints;
		setParent ..; 
	}

	setParent ..; // Column Layout 
	setParent ..; // Frame layout Mesh

	frameLayout -label (uiRes("m_performTextureToGeom.kSurfaceFitting")) 
		-collapsable true -collapse false textureToGeomFittingOptions;
		$parent = `columnLayout -adj true`;
		checkBoxGrp -ncb 1 -label1 "" -label (uiRes("m_performTextureToGeom.kFitToSelection")) 
			textureToGeomFitToSelected; 
		
		string $slider = 
			`floatSliderGrp -label (uiRes("m_performTextureToGeom.kSurfaceOffset")) 	textureToGeomFitOffset`; 

		string $textField = 
			`textFieldGrp -label (uiRes("m_performTextureToGeom.kUVSet"))  textureToGeomFitUVSet`;
		
		string $args = 
			("\""+$parent+"\", \""+$slider+"\", \""+$textField+"\", ");
		checkBoxGrp -edit -onCommand1  
			("TGdisableFloatTxtUI(" + $args + "1)")
			-offCommand1 
			("TGdisableFloatTxtUI(" + $args + "0)")
			textureToGeomFitToSelected;
		
		setParent ..; 
	setParent ..;

	frameLayout -label (uiRes("m_performTextureToGeom.kSurfaceOutputOptions")) 
		-collapsable true -collapse false textureToGeomSurfaceOptions; 
	
		columnLayout -adj true; 
		checkBoxGrp -ncb 1 -label1 "" -label (uiRes("m_performTextureToGeom.kGenerateShaders"))  
			textureToGeomCreateShaders;
		
		string $om = `optionMenuGrp -label (uiRes("m_performTextureToGeom.kShaderTemplate"))  
			textureToGeomShaderTemplate`;
		textureToGeomSetupOptionMenus( $om );
		
		string $callback = ("textureToGeomSetupOptionMenus( \"" + $om + "\" )");
		scriptJob -event "deleteAllCondition" $callback -p $layout;
		scriptJob -event "NewSceneOpened" $callback -p $layout;
		scriptJob -event "SceneOpened" $callback -p $layout;
		
		setParent ..;
	setParent ..;

	eval(("textureToGeomSetup " + $layout + " " + 0));
	setUITemplate -popTemplate;
}

global proc textureToGeomOptions( )
{
	// Name of the command for this option box 
	//
	string $commandName = "textureToGeom";

	// Title for the option box window
	//
	string $optionBoxTitle = (uiRes("m_performTextureToGeom.kTexturetoGeometry"));
	
	// Build the option box "methods"
	//
	string $callback = ($commandName + "Callback");
	string $setup = ($commandName + "Setup");
	
	string $layout = getOptionBox(); 
	setParent $layout; 

	setOptionBoxCommandName($commandName); 
	setOptionBoxTitle( $optionBoxTitle );
	setOptionBoxHelpTag( "TextureToGeometry" );  

	createTextureToGeomUI( $layout ); 

	//	'Apply' button.
	//
	string $applyBtn = getOptionBoxApplyBtn();
	button -edit
		-label (uiRes("m_performTextureToGeom.kApply")) 
		-command ($callback + " " + $layout + " " + 1)
		$applyBtn;

	//	'Save' button.
	//
	string $saveBtn = getOptionBoxSaveBtn();
	button -edit 
		-label (uiRes("m_performTextureToGeom.kApplyClose")) 
		-command ($callback + " " + $layout + " " + 1 + "; hideOptionBox")
		$saveBtn;

	//	'Reset' button.
	//
	string $resetBtn = getOptionBoxResetBtn();
	button -edit 
		-label (uiRes("m_performTextureToGeom.kClose")) 
		-command ($callback + " " + $layout + " " + 0 + ";hideOptionBox")
		$resetBtn;

	showOptionBox();

	// We want to customize the menu options and we have to do it after 
	// the box has been shown.
	//
	global string $gOptionBoxEditMenuResetItem; 
	global string $gOptionBoxEditMenuSaveItem; 
	global string $gOptionBoxEditMenu; 

	menuItem -edit -command ($setup + " " + $layout + " " + 1 + ";")
		$gOptionBoxEditMenuResetItem; 
	menuItem -edit -command ($callback + " " + $layout + " " + 0 + ";")
		$gOptionBoxEditMenuSaveItem;
}

global proc setTextureToGeomValues( string $cnv )
{
	int $quantize = 
		`optionVar -query textureToGeomQuantizeOV`; 
	
	int $quantLevels = 
		`optionVar -query textureToGeomQuantLevelsOV`; 
	
	int $radius = 
		`optionVar -query textureToGeomSpatialRadiusOV`; 
	
	float $minSegSize = 
		`optionVar -query textureToGeomMinSegmentSizeOV`;
	
	float $maxColor = 
		`optionVar -query textureToGeomMaxColorDiffOV`; 

	float $range = 
		`optionVar -query textureToGeomColorRangeOV`;

	global int $gEnableMeshGenerationSettings;

	int $smoothBoundary; 
	float $smoothFactor; 
	int $hardCorner; 
	float $hardCornerMaxLen;
	int $simplifyBoundary;
	float $meshQuality;
	
	if ( $gEnableMeshGenerationSettings ) {	
		$smoothBoundary = 
			`optionVar -query textureToGeomSmoothBoundaryOV`;

		$smoothFactor = 
			`optionVar -query textureToGeomSmoothFactorOV`;
		
		$hardCorner = 
			`optionVar -query textureToGeomHardCornerDetectOV`;
		
		$hardCornerMaxLen = 
			`optionVar -query textureToGeomHardCornerMaxLenOV`;

		$simplifyBoundary = 
			`optionVar -query textureToGeomSimplifyBoundaryOV`;

		$meshQuality = 
			`optionVar -query textureToGeomMeshQualityOV`; 	
	}
		
	int $maxPoints = 
			`optionVar -query textureToGeomMaxPointsOV`;

	float $offset = 
		`optionVar -query textureToGeomFitOffsetOV`; 

	string $uvSet = 
		`optionVar -query textureToGeomFitUVSetOV`;
	

	if ( $gEnableMeshGenerationSettings ) { 
		// Meshing properties. 
		//
		setAttr ($cnv + ".meshQuality") $meshQuality; 
		setAttr ($cnv + ".smoothBoundary") $smoothBoundary; 
		setAttr ($cnv + ".smoothFactor") $smoothFactor; 
		setAttr ($cnv + ".hardCornerDetect") $hardCorner; 
		setAttr ($cnv + ".hardCornerMaxLength") $hardCornerMaxLen; 
		setAttr ($cnv + ".simplifyBoundary") $simplifyBoundary; 
	}

	setAttr ($cnv + ".maxPointsAdded") $maxPoints; 
	setAttr ($cnv + ".surfaceOffset") $offset; 
	setAttr ($cnv + ".inputMeshUVSet") -type "string" $uvSet; 
	
	// Image properties 
	// 
	setAttr ($cnv + ".quantize") $quantize; 
	setAttr ($cnv + ".quantizeLevels" ) $quantLevels; 
	setAttr ($cnv + ".maxColorDiff") $maxColor;
	setAttr ($cnv + ".spatialRadius") $radius; 
	setAttr ($cnv + ".colorRange") $range;
	setAttr ($cnv + ".minSegmentSize") $minSegSize; 
}

proc string assembleCmdAndDoIt( )

//
// Description:
//	
//	
{
	int $fitToGeom = 
		`optionVar -query textureToGeomFitToSelectedOV`; 

	string $fname = 
		`optionVar -query textureToGeomInputFileOV`; 
	if ( $fname == "" ) { 
		error (uiRes("m_performTextureToGeom.kInvalidSelection"));
	}

	int $genShaders = `optionVar -query textureToGeomCreateShadersOV`;
	string $template = `optionVar -query textureToGeomShaderTemplateOV`;
	if ( $genShaders && $template != "" && !`objExists $template` ) { 
		error (uiRes("m_performTextureToGeom.kShaderNoLongerExists"));
	}

	string $cmd = ("createTextureToGeom( \"" + $fname + "\", \"\", \"setTextureToGeomValues\", " + $fitToGeom + " )\n");
	print $cmd ;

	string $converter[] = eval($cmd);
	
	if ( $genShaders ) {
		addAttr -ln "shaderAssignment" -sn "sas" -r true 
			-w true -dt "string" $converter[0];
		addAttr -ln "shaderTemplate" -sn "sht" -r true 
			-w true -dt "string" $converter[0];
		setAttr ($converter[0] + ".shaderAssignment") -type "string" "shaders";
		setAttr ($converter[0] + ".shaderTemplate") -type "string" $template;
		textureToGeomApplyColor( $converter[0], $fname, $converter[1], 
								 "shaders" );
		setAttr ($converter[0] + ".shaderScript") -type "string" "TGcolorChange";
	}
	
	// We want the converter to show up in the attribute editor first. 
	//
	select -r $converter[1] $converter[0]; 
	
	return $cmd;
}


global proc string performTextureToGeom( int $action )
{
	string $cmd = "";

	switch( $action ) {
		case 0:
			setOptionVars( false );
			assembleCmdAndDoIt( ); 
			break;
		case 1:
			textureToGeomOptions;
			break;
	}

	return $cmd;
}
