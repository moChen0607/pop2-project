// Copyright (C) 1997-2014 Autodesk, Inc., and/or its licensors.
// All rights reserved.
//
// The coded instructions, statements, computer programs, and/or related
// material (collectively the "Data") in these files contain unpublished
// information proprietary to Autodesk, Inc. ("Autodesk") and/or its licensors,
// which is protected by U.S. and Canadian federal copyright law and by
// international treaties.
//
// The Data is provided for use exclusively by You. You have the right to use,
// modify, and incorporate this Data into other products for purposes authorized 
// by the Autodesk software license agreement, without fee.
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND. AUTODESK
// DOES NOT MAKE AND HEREBY DISCLAIMS ANY EXPRESS OR IMPLIED WARRANTIES
// INCLUDING, BUT NOT LIMITED TO, THE WARRANTIES OF NON-INFRINGEMENT,
// MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE, OR ARISING FROM A COURSE 
// OF DEALING, USAGE, OR TRADE PRACTICE. IN NO EVENT WILL AUTODESK AND/OR ITS
// LICENSORS BE LIABLE FOR ANY LOST REVENUES, DATA, OR PROFITS, OR SPECIAL,
// DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES, EVEN IF AUTODESK AND/OR ITS
// LICENSORS HAS BEEN ADVISED OF THE POSSIBILITY OR PROBABILITY OF SUCH DAMAGES.

//
//  Creation Date:  Aug2003
//
//  Procedure Name:
//      performPolyWarpImage
//
//  Description:
//        
//         
//  Input Arguments:
//        $option : Whether to set the options to default values.
//  Return Value:
//        None
//
proc string polyWarpFixFileName(string $file)
{
	string $ext = `imageFormatsMenuImfExt("polyWarpImageFileOutPutType")`;
	string $ext2 = "\\."+`fileExtension($file)`+"$";
	$file = substitute($ext2, $file, "");
	return $file+"."+$ext;
}

proc setOptionVars (int	$forceFactorySettings)
{
	if ($forceFactorySettings || !`optionVar -exists "polyWarpInImageFileName"`)
    	{
		string $dir = (`workspace -q -rd` + "images/warpMe");
        	optionVar -stringValue polyWarpInImageFileName $dir; 
    	}

	if ($forceFactorySettings || !`optionVar -exists "polyWarpOutImageFileName"`)

	{
		string $dir = (`workspace -q -rd` + "images/warped");
        	optionVar -stringValue polyWarpOutImageFileName $dir; 
	}

	if ($forceFactorySettings || !`optionVar -exists "polyWarpImageFileOutPutType"`)
		optionVar -stringValue "polyWarpImageFileOutPutType" "iff";
	
	if ($forceFactorySettings || !`optionVar -exists "polyWarpInUVSet"`)
		optionVar -stringValue "polyWarpInUVSet" "map1";

	if ($forceFactorySettings || !`optionVar -exists "polyWarpOutUVSet"`)
		optionVar -stringValue "polyWarpOutUVSet" "uvSet";

	if ($forceFactorySettings || !`optionVar -exists "polyWarpImageXRes"`)
		optionVar -intValue "polyWarpImageXRes" 256;

	if ($forceFactorySettings || !`optionVar -exists "polyWarpImageYRes"`)
		optionVar -intValue "polyWarpImageYRes" 256;

	if ($forceFactorySettings || !`optionVar -exists "polyWarpImageOverWrite"`)
		optionVar -intValue "polyWarpImageOverWrite" 1;

	if ($forceFactorySettings || !`optionVar -exists "polyWarpImageBilinear"`)
		optionVar -intValue "polyWarpImageBilinear" 1;

	if ($forceFactorySettings || !`optionVar -exists "polyWarpImageAlpha"`)
		optionVar -intValue "polyWarpImageAlpha" 0;

	if ($forceFactorySettings || !`optionVar -exists "polyWarpImageTiled"`)
		optionVar -intValue "polyWarpImageTiled" 1;

	// Background Color
	if ($forceFactorySettings || !`optionVar -exists polyWarpImageColorMode`) {
		optionVar -intValue polyWarpImageColorMode 0 ;
	}

	// Background Color
	if ($forceFactorySettings || !`optionVar -exists polyWarpImageColor`) {
		optionVar -fv polyWarpImageColor 0
			-fva polyWarpImageColor 0
			-fva polyWarpImageColor 0 ;
	}

}
global proc polyWarpImageSetup (string $parent, int $forceFactorySettings)
{
	setOptionVars($forceFactorySettings);
	setParent $parent;

	string $imageIn = `optionVar -q polyWarpInImageFileName`;
	string $imageOut = `optionVar -q polyWarpOutImageFileName`;
	if ( `about -nt` ) {
		$imageIn = substituteAllString($imageIn, "/", "\\");
		$imageOut = substituteAllString($imageOut, "/", "\\");
	}

	textFieldButtonGrp
		-edit
		-tx $imageIn 
	polyWarpInImageFileName;

	textFieldButtonGrp
		-edit
		-tx $imageOut 
	polyWarpOutImageFileName;

	imageFormatsMenuSelectImfKey("polyWarpImageFileOutPutType",
								 `optionVar -query polyWarpImageFileOutPutType`);

	textField
		-edit
		-text `optionVar -query polyWarpInUVSet`
		polyWarpInUVSet;

	textField
		-edit
		-text `optionVar -query polyWarpOutUVSet`
		polyWarpOutUVSet;

	intSliderGrp
        -edit
        -value `optionVar -query polyWarpImageXRes`
        polyWarpImageXRes;

	intSliderGrp
        -edit
        -value `optionVar -query polyWarpImageYRes`
        polyWarpImageYRes;

	checkBoxGrp
        -edit
        -value1 `optionVar -query polyWarpImageOverWrite`
        polyWarpImageOverWrite;

	checkBoxGrp
        -edit
        -value1 `optionVar -query polyWarpImageBilinear`
        polyWarpImageBilinear;

	checkBoxGrp
        -edit
        -value1 `optionVar -query polyWarpImageAlpha`
        polyWarpImageAlpha;

	checkBoxGrp
        -edit
        -value1 `optionVar -query polyWarpImageTiled`
        polyWarpImageTiled;

	// Background Color Mode
    radioButtonGrp -edit
		-select `optionVar -q polyWarpImageColorMode`
		polyWarpImageColorMode;

	// Background Color
	float $a[] = `optionVar -q polyWarpImageColor`;
    colorSliderGrp -edit
		-rgbValue $a[0] $a[1] $a[2]
		-enable (`optionVar -q polyWarpImageColorMode` == 2)
		polyWarpImageColor;
}

global proc polyWarpImageCallback (string $parent, int $doIt)
{	
	setParent $parent;

	optionVar -stringValue "polyWarpInImageFileName"
		`textFieldButtonGrp -query -text polyWarpInImageFileName`;

	optionVar -stringValue "polyWarpOutImageFileName"
		`textFieldButtonGrp -query -text polyWarpOutImageFileName`;

	optionVar -stringValue "polyWarpImageFileOutPutType"
		`imageFormatsMenuImfKey("polyWarpImageFileOutPutType")`;

	optionVar -stringValue "polyWarpInUVSet"
		`textField -query -text polyWarpInUVSet`;

	optionVar -stringValue "polyWarpOutUVSet"
		`textField -query -text polyWarpOutUVSet`;

	optionVar -intValue "polyWarpImageXRes"
		`intSliderGrp -query -value polyWarpImageXRes`;

	optionVar -intValue "polyWarpImageYRes"
		`intSliderGrp -query -value polyWarpImageYRes`;

	optionVar -intValue "polyWarpImageOverWrite"
		`checkBoxGrp -query	-value1 polyWarpImageOverWrite`;

	optionVar -intValue "polyWarpImageBilinear"
		`checkBoxGrp -query -value1 polyWarpImageBilinear`;

	optionVar -intValue "polyWarpImageAlpha"
		`checkBoxGrp -query	-value1 polyWarpImageAlpha`;
	
	optionVar -intValue "polyWarpImageTiled"
		`checkBoxGrp -query	-value1 polyWarpImageTiled`;

	// Background Color Mode
	optionVar -intValue "polyWarpImageColorMode"
		`radioButtonGrp -query -select polyWarpImageColorMode`;

	// Background Color
	float $a[] = `colorSliderGrp -q -rgb polyWarpImageColor`;
	optionVar -fv polyWarpImageColor $a[0] 
		-fva polyWarpImageColor $a[1] 
		-fva polyWarpImageColor $a[2];

	if ($doIt) 
	{
		performPolyWarpImage 0;
		string $tmpCmd = "performPolyWarpImage 0 ";
		addToRecentCommandQueue $tmpCmd "Warp Image";
	}
}

global proc polyWarpSourceImageFileNameCallback()
{
	string $currentFileName = `textFieldGrp -q -text polyWarpInImageFileName`;
	optionVar -stringValue polyWarpInImageFileName $currentFileName;
}

global proc int polyWarpSourceImageBrowseCallback(string $fileName, string $fileType)
{
	textFieldGrp -e -fileName $fileName polyWarpInImageFileName;
	optionVar -stringValue polyWarpInImageFileName $fileName; 
	return true;
}

global proc polyWarpSourceImageBrowse()
{
	string $dir = `workspace -q -rd`;
	setWorkingDirectory $dir "image" "images";
	fileBrowser("polyWarpSourceImageBrowseCallback", (uiRes("m_performPolyWarpImage.kImageTitle")), "image", 0);
}

global proc polyWarpNewImageFileNameCallback()
{
	string $currentFileName = `textFieldGrp -q -text polyWarpOutImageFileName`;
	optionVar -stringValue polyWarpOutImageFileName $currentFileName;
}

global proc int polyWarpNewImageBrowseCallback(string $fileName, string $fileType)
{
	textFieldGrp -e -fileName $fileName polyWarpOutImageFileName;
	optionVar -stringValue polyWarpOutImageFileName $fileName; 
	return true;
}

global proc polyWarpNewImageBrowse()
{
	string $dir = `workspace -q -rd`;
	setWorkingDirectory $dir "image" "images";
	
	string $fileImage = (uiRes("m_performPolyWarpImage.kFileImage"));
	fileBrowser("polyWarpNewImageBrowseCallback", $fileImage, "image", 1);
}

proc polyWarpImageOptions ()
{
	string $commandName = "polyWarpImage";
	string $callback = ($commandName + "Callback");
	string $setup = ($commandName + "Setup");
	//	STEP 1:  Get the option box.
	//	============================
	//
	string $layout = getOptionBox();
	setParent $layout;
	//	STEP 2:  Pass the command name to the option box.
	//	=================================================
	//
	setOptionBoxCommandName($commandName);
	//	STEP 3:  Activate the default UI template.
	//	==========================================
	//
	setUITemplate -pushTemplate DefaultTemplate;
	//	STEP 4: Create option box contents.
	//	===================================
	//
	waitCursor -state 1;
	
	string $parent = `columnLayout -adjustableColumn 1`;

	frameLayout -label (uiRes("m_performPolyWarpImage.kImage"))
		-collapsable 0;

	columnLayout;

	string $imageIn = `optionVar -q polyWarpInImageFileName`;
	string $imageOut = `optionVar -q polyWarpOutImageFileName`;
	if ( `about -nt` ) {
		$imageIn = substituteAllString($imageIn, "/", "\\");
		$imageOut = substituteAllString($imageOut, "/", "\\");
	}

	string $browse = (uiRes("m_performPolyWarpImage.kBrowse"));
	textFieldButtonGrp -label (uiRes("m_performPolyWarpImage.kSourceImageName"))
		-tx $imageIn 
		-buttonLabel $browse 
		-cc polyWarpSourceImageFileNameCallback
		-bc polyWarpSourceImageBrowse 
		polyWarpInImageFileName;

	textFieldButtonGrp -label (uiRes("m_performPolyWarpImage.kNewImageName"))
		-tx $imageOut 
		-buttonLabel $browse 
		-cc polyWarpNewImageFileNameCallback
		-bc polyWarpNewImageBrowse 
		polyWarpOutImageFileName;

	radioButtonGrp -nrb 2
		-label (uiRes("m_performPolyWarpImage.kBackgroundMode"))
		-label1 (uiRes("m_performPolyWarpImage.kAutomatic"))
		-label2 (uiRes("m_performPolyWarpImage.kFixedColor"))
		-onCommand1 "colorSliderGrp -edit -enable 0 polyWarpImageColor"
		-onCommand2 "colorSliderGrp -edit -enable 1 polyWarpImageColor"
		polyWarpImageColorMode;

	colorSliderGrp -label (uiRes("m_performPolyWarpImage.kBackgroundColor")) -rgb 0 0 0
        polyWarpImageColor;

	optionMenuGrp -label (uiRes("m_performPolyWarpImage.kFileFormat")) polyWarpImageFileOutPutType;
	buildImageFormatsMenu(0, 0, 0, 0, 0);

	rowLayout -numberOfColumns 3
		-columnWidth 2 212 
		-columnWidth 3 25;
		text -label (uiRes("m_performPolyWarpImage.kSourceUVSet"));
		textField 
			polyWarpInUVSet;
		setParent ..;

	rowLayout -numberOfColumns 3
		-columnWidth 2 212 
		-columnWidth 3 25;
		text -label (uiRes("m_performPolyWarpImage.kDestinationUVSet"));
		textField 
			polyWarpOutUVSet;
		setParent ..;

	intSliderGrp
        -field on
        -label (uiRes("m_performPolyWarpImage.kXResolution"))
        -minValue 1
        -maxValue 1024
        -fieldMinValue 1
        -fieldMaxValue 32768
        -value 256
        polyWarpImageXRes;

	intSliderGrp
        -field on
        -label (uiRes("m_performPolyWarpImage.kYResolution"))
        -minValue 1
        -maxValue 1024
        -fieldMinValue 1
        -fieldMaxValue 32768
        -value 256
        polyWarpImageYRes;
	
	setParent ..;

	setParent ..;

	frameLayout -label (uiRes("m_performPolyWarpImage.kImageOptions"))
		-collapsable 0;

	columnLayout;

	checkBoxGrp 
		-numberOfCheckBoxes 1
		-label1 (uiRes("m_performPolyWarpImage.kOverwriteExistingFile"))
		-value1 1
        polyWarpImageOverWrite;

	checkBoxGrp 
		-numberOfCheckBoxes 1
		-label1 (uiRes("m_performPolyWarpImage.kBilinearFiltering"))
		-value1 1
        polyWarpImageBilinear;

	checkBoxGrp 
		-numberOfCheckBoxes 1
		-label1 (uiRes("m_performPolyWarpImage.kIncludeAlpha"))
		-value1 0
		polyWarpImageAlpha;

	checkBoxGrp 
		-numberOfCheckBoxes 1
		-label1 (uiRes("m_performPolyWarpImage.kTiled"))
		-value1 1
		polyWarpImageTiled;

	setParent ..;

	setParent ..;
	
	setParent -menu ..;

	waitCursor -state 0;
	//	Step 5: Deactivate the default UI template.
	//	===========================================
	//
	setUITemplate -popTemplate;

	//	Step 6: Customize the buttons.  
	//	==============================
	//
	string $applyBtn = getOptionBoxApplyBtn();
	button -edit 
		-label (uiRes("m_performPolyWarpImage.kApply"))
		-command ($callback + " " + $parent + " " + 1) 
		$applyBtn;
	
	string $applyAndCloseBtn = getOptionBoxApplyAndCloseBtn();
	button -edit 
		-label (uiRes("m_performPolyWarpImage.kWarpImage"))
		$applyAndCloseBtn;

	string $saveBtn = getOptionBoxSaveBtn();
	button -edit 
		-command ($callback + " " + $parent + " " + 0 + " " +"; hideOptionBox")
		$saveBtn;

	string $resetBtn = getOptionBoxResetBtn();
	button -edit 
		-command ($setup + " " + $parent + " " + 1)
		$resetBtn;

	//	Step 7: Set the option box title.
	//	=================================
	//
	setOptionBoxTitle (uiRes("m_performPolyWarpImage.kWarpImageOptions"));
	//	Step 8: Customize the 'Help' menu item text.
	//	============================================
	//
	setOptionBoxHelpTag("WarpImage");
	//	Step 9: Set the current values of the option box.
	//	=================================================
	//
	eval (($setup + " " + $parent + " " + 0));
	//	Step 10: Show the option box.
	//	=============================
	//
	showOptionBox();
}

proc string assembleCmd()
{
	setOptionVars (false);

	int $doHistory = `constructionHistory -q -toggle`;

	string $cmd = "polyWarpImage -xResolution ";
	$cmd += `optionVar -query "polyWarpImageXRes"`;

	$cmd += " -yResolution ";
	$cmd += `optionVar -query "polyWarpImageYRes"`;

	$cmd += " -inputName \"";
	string $inName = `optionVar -query "polyWarpInImageFileName"`;
	$inName = `encodeString $inName`;
	$cmd += $inName;
	$cmd += "\"";
	
	$cmd += " -outputName \"";
	string $outName = `optionVar -query "polyWarpOutImageFileName"`;
	$outName = polyWarpFixFileName($outName);
	$outName = `encodeString $outName`;
	$cmd += $outName;
	$cmd += "\"";
	
	$cmd += " -inputUvSetName ";
	$cmd += `optionVar -query "polyWarpInUVSet"`;
	
	$cmd += " -outputUvSetName ";
	$cmd += `optionVar -query "polyWarpOutUVSet"`;

	$cmd += " -fileFormat ";
	$cmd += `optionVar -query "polyWarpImageFileOutPutType"`;

	// For automatic mode, simply skip the -background flag
	if (`optionVar -query polyWarpImageColorMode` == 2) {
		float $color[] = `optionVar -query polyWarpImageColor`;
		$cmd = ($cmd + " -background"
				+ " " + floor($color[0]*255)
				+ " " + floor($color[1]*255)
				+ " " + floor($color[2]*255) );
	}

	if (`optionVar -query "polyWarpImageOverWrite"`){
		$cmd += " -overwrite";
	}
	if (`optionVar -query "polyWarpImageBilinear"`){
		$cmd += " -bilinear";
	}
	int $alphaChoice = `optionVar -query "polyWarpImageAlpha"`;
	if ($alphaChoice == 0){
		$cmd += " -noAlpha";
	}
	if (`optionVar -query "polyWarpImageTiled"`){
		$cmd += " -tiled";
	}

	return $cmd;	
}


global proc string performPolyWarpImage (int $option)
{
	string $cmd="";

	switch ($option) 
	{
		case 0:
			$cmd = `assembleCmd`;
			evalEcho($cmd);
			break;
		case 1:
			polyWarpImageOptions;
			break;
		case 2:
			$cmd = `assembleCmd`;
			break;
	}
	return $cmd;
}
