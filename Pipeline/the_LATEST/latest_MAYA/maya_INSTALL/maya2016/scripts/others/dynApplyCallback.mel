// Copyright (C) 1997-2014 Autodesk, Inc., and/or its licensors.
// All rights reserved.
//
// The coded instructions, statements, computer programs, and/or related
// material (collectively the "Data") in these files contain unpublished
// information proprietary to Autodesk, Inc. ("Autodesk") and/or its licensors,
// which is protected by U.S. and Canadian federal copyright law and by
// international treaties.
//
// The Data is provided for use exclusively by You. You have the right to use,
// modify, and incorporate this Data into other products for purposes authorized 
// by the Autodesk software license agreement, without fee.
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND. AUTODESK
// DOES NOT MAKE AND HEREBY DISCLAIMS ANY EXPRESS OR IMPLIED WARRANTIES
// INCLUDING, BUT NOT LIMITED TO, THE WARRANTIES OF NON-INFRINGEMENT,
// MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE, OR ARISING FROM A COURSE 
// OF DEALING, USAGE, OR TRADE PRACTICE. IN NO EVENT WILL AUTODESK AND/OR ITS
// LICENSORS BE LIABLE FOR ANY LOST REVENUES, DATA, OR PROFITS, OR SPECIAL,
// DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES, EVEN IF AUTODESK AND/OR ITS
// LICENSORS HAS BEEN ADVISED OF THE POSSIBILITY OR PROBABILITY OF SUCH DAMAGES.

//
//
//  Creation Date:  April, 1997
//
//  Description:
//      This script contains the callbacks for the Dynamics menus (if
//		no option box is requested) and the "Apply" (Create/Add)
//		buttons of the Dynamics option boxes.  Each callback sets
//		the option vars from the controls, then calls performDynamics()
//		to execute the command.
//
//  Input Arguments to dynApplyCallback():
//		string $theCmd  -- the command selected
//		int $parent --  the parent layout
//
//  IMPORTANT NOTE: dynApplyCallback forms command string for each
//  individual callback as "apply<Cmd Name>Callback( string $parent, int $executeCmd )"
//  where <Cmd Name> is the command name passed from performDynamics and
//  ultimately from the -c argument of the menuItem -optionBox command in
//  the menu script. Each separate callback must take the (string, int)
//  argument pair event if it does not use them.
//

global proc int dynCheckOverwriteCacheDirectory( string $path )
//
// Description:
//  if the user has never cached this particular scene before,
// but a directory called "path" already exists, post a confirm
// dialog asking if user wants to overwrite.  If the user aborts,
// return 0 and send a warning to the command line telling the 
// user he/she aborted the operation.  In any other event (either
// the user confirms or she/she had already cached the scene before)
// return 1.
{
	// If the user has not cached this scene before, we want to prevent him/her 
	// from overwriting a previously existing directory by mistake.
	// The dynGlobals cache path attribute will be empty if and only if the user
	// has not cached the scene before.  So, check that attribute.
	//
    string $theGlobal;
	string $dynGlobalsPath;
	if (!catch ($theGlobal = `dynGlobals -q -active`))
	{
		$dynGlobalsPath = `getAttr ($theGlobal + ".cacheDirectory")`;
	}

	if (size( $dynGlobalsPath ) == 0) 
	{
		int $dirExists = 0; 
		string $dirName;

		// if no workspace particle area defined yet, no cache directory exists.
		//
		string $particleDir =  `workspace -fre particles`;
		if (size($particleDir) > 0)
		{
			$dirName = `workspace -q -rd` + $particleDir + "/" + $path;
			$dirExists = `filetest -d $dirName`;
		}
		if ($dirExists)
		{
			// the directory already exists. Does the user wish to overwrite?
			//
			string $msgString = (uiRes("m_dynApplyCallback.kCacheDirectoryMessage"));
			$msgString = `format -s $path $msgString`;
			string $confirm = (uiRes("m_dynApplyCallback.kConfirm")); 
			string $no = (uiRes("m_dynApplyCallback.kNo"));
			string $yes = (uiRes("m_dynApplyCallback.kYes"));
			if ($no ==`confirmDialog -title $confirm 
				-message $msgString -button $yes 
				-button $no -defaultButton $yes 
				-cancelButton $no -dismissString $no`)
			{
				// User does not wish to overwrite, so abort
				//
				warning (uiRes("m_dynApplyCallback.kAbortedOperation"));
				return 0;
			}
		}
	}

	return 1;
}
		
global proc int dynVerifyPath( string $path )
//
// Description:
//   Verifies that the user wants to use this path. Returns true if
// verified, false otherwise.
//
//   If the user has not confirmed this path for this scene, 
// posts a dialog box asking confirmation that the user wants to use $path. 
// Returns true if the user confirms, false otherwise.
// If the user confirms, sets the pathConfirmed attribute to true.
//
//   The effect of this is that each time the user does a Save As and
// attempts to cache the new scene, or else attempt to cache a scene under
// a new path that is not the same as the scene name, he/she will be prompted 
// to provide a new cache name instead of overwriting the old cache.
{
	// If scene agrees with pathname, ok.
	//
	string $scene = `file -q -rpr`;
	if ($path == $scene) return 1;
	
	// If scene does not agree with path name, 
	// check the pathConfirmed and confirmSceneName attributes
	// of dynGlobals. 
	//
	int $pathConfirmed = 1;
	string $confirmName;
	string $confirmedPath;

	string $theGlobal = `dynGlobals -q -active`;
	if (size($theGlobal) > 0)
	{
		$confirmedPath = `getAttr ($theGlobal+".confirmedPath")`;
		$confirmName   = `getAttr ($theGlobal+".confirmSceneName")`;
	}

	// Get confirmation if either the path has not been confirmed,
	// or the scene name is not the same as what it was confirmed under.
	//
	if (($path != $confirmedPath) || ($scene != $confirmName))
	{
		// Post dialog to ask the user to confirm
		//
		string $msgString = (uiRes("m_dynApplyCallback.kCacheDirectoryMsg"));
		$msgString=`format -s $path $msgString`;
		string $yes = (uiRes("m_dynApplyCallback.kYes"));
		string $no = (uiRes("m_dynApplyCallback.kNo"));

		if ($yes ==`confirmDialog -title (uiRes("m_dynApplyCallback.kConfirm")) 
			-message $msgString -button $yes 
			-button $no -defaultButton $yes 
			-cancelButton $no -dismissString $no`)
		{
			// Yes, this is what the user wants.
			//
			$pathConfirmed = 1;

			// Record that the path has been confirmed.
			//
			setAttr -type "string" ($theGlobal+".confirmedPath") $path;

			// Store the scene name for which the path was confirmed.
			//
			setAttr -type "string" ($theGlobal+".confirmSceneName") $scene;
		}
		else
		{
			$pathConfirmed = 0;

			// User said No. Tell him/her how to give us a new path.
			//
			string $ok = (uiRes("m_dynApplyCallback.kOk"));
			string $infoString = (uiRes("m_dynApplyCallback.kNewCacheCreationMessage"));
			confirmDialog -title (uiRes("m_dynApplyCallback.kInformation")) -message $infoString -button $ok -defaultButton $ok -cancelButton $ok -dismissString $ok;
		}
	}

	return $pathConfirmed;
}

global proc dynCleanCacheDirectory( string $dir ) 
//
// Description:
//   Delete any previously existing pdc files in the cache directory.
// $dir identifies the cache directory relative to the particle area.
// If particle directory or $dir have not been set up, does nothing 
// (there's nothing to delete).
{
	string $particleDir = `workspace -fre particles`;
	if (size($particleDir) == 0) return;

	string $fullPath = `workspace -q -rd` + $particleDir + "/" + $dir + "/";
	if (!`filetest -d $fullPath`) return;
	
	// See if the directory has anything in it.
	// We do not want to issue the delete command on a directory
	// that contains no pdc files. It gives a confusing message.
	//
	string $dirArr[];  
	$dirArr = `getFileList -fld $fullPath -fs "*.pdc"`;	

	// If there were files, delete them.
	//
	if (size( $dirArr ) > 0)
	{
           string $flName;
		for($flName in $dirArr)
		{
			string $fullFlName = $fullPath + $flName;
			sysFile -del $fullFlName;
		}
	}
}

global proc dynApplyCallback(string $theCmd, string $parent, int $executeCmd )
{
    string $procName = ("apply"+$theCmd+"Callback");
	string $cmd = $procName+" "+$parent + " " + $executeCmd;
    eval ( $cmd );
}

proc volumeFieldCallback( string $field )
// Description:
//    Get volume field option values from controls.
{

	optionVar -intValue ($field+"VolumeFieldTypesOM") `optionMenuGrp -q -sl ($field+"VolumeFieldTypesOM")`;

	// Volume exclusion does not apply to the volume axis field.
	//
	if ($field != "volumeAxis")
	{
		optionVar -intValue ($field+"VolumeExclusion") `checkBoxGrp -q -v1 ($field+"VolumeExclusion")`;
	}

	optionVar -floatValue ($field+"VolumeOffsetX") `floatSliderGrp -q -v ($field+"VolumeOffsetX")`;
	optionVar -floatValue ($field+"VolumeOffsetY") `floatSliderGrp -q -v ($field+"VolumeOffsetY")`;
	optionVar -floatValue ($field+"VolumeOffsetZ") `floatSliderGrp -q -v ($field+"VolumeOffsetZ")`;

	optionVar -floatValue ($field+"VolumeSweep") `floatSliderGrp -q -v ($field+"VolumeSweep")`;
	optionVar -floatValue ($field+"TorusSectionRadius") `floatSliderGrp -q -v ($field+"TorusSectionRadius")`;

}
global proc applyAirCallback (string $parent, int $executeCmd)
//
// Description:
//	Set the optionVar's from the control values, and then perform
//	the command
//
{
	global int $dynIsCreate;
    setParent $parent;

	optionVar -stringValue airName `textFieldGrp -q -text airName`;
	optionVar -floatValue airMagnitude `floatSliderGrp -q -v airMagnitude`;
	optionVar -floatValue airAttenuation `floatSliderGrp -q -v airAttenuation`;
	optionVar -floatValue airDirectionX `floatSliderGrp -q -v airDirectionX`;
	optionVar -floatValue airDirectionY `floatSliderGrp -q -v airDirectionY`;
	optionVar -floatValue airDirectionZ `floatSliderGrp -q -v airDirectionZ`;
	optionVar -floatValue airSpeed `floatSliderGrp -q -v airSpeed`;
	optionVar -floatValue airInheritVelocity `floatSliderGrp -q -v airInheritVelocity`;

	optionVar -intValue airInheritRotation `checkBoxGrp -q -v1 airInheritRotation`;
	optionVar -intValue airComponent `checkBoxGrp -q -v1 airComponent`;
	//optionVar -intValue airPerVertex `checkBoxGrp -q -v1 airPerVertex`;
	optionVar -intValue airEnableSpread `checkBoxGrp -q -v1 airEnableSpread`;
	optionVar -floatValue airSpread `floatSliderGrp -q -v airSpread`;
	optionVar -intValue airMaxDistCBox `checkBoxGrp -q -v1 airMaxDistCBox`;
	optionVar -floatValue airMaxDistance `floatSliderGrp -q -v airMaxDistance`;

	volumeFieldCallback( "air" );
	
	if ($executeCmd) {
		performDynamics $dynIsCreate "Air" 0;
		string $tmpCmd = "performDynamics " + $dynIsCreate + " \"Air\" 0";
		addToRecentCommandQueue $tmpCmd "Air";
	}
}


global proc applyDragCallback (string $parent, int $executeCmd)
//
// Description:
//	Set the optionVar's from the control values, and then perform
//	the command
//
{
	global int $dynIsCreate;
    setParent $parent;

	optionVar -stringValue dragName `textFieldGrp -q -text dragName`;
	optionVar -floatValue dragMagnitude `floatSliderGrp -q -v dragMagnitude`;
	optionVar -floatValue dragAttenuation `floatSliderGrp -q -v dragAttenuation`;
	optionVar -floatValue dragDirectionX `floatSliderGrp -q -v dragDirectionX`;
	optionVar -floatValue dragDirectionY `floatSliderGrp -q -v dragDirectionY`;
	optionVar -floatValue dragDirectionZ `floatSliderGrp -q -v dragDirectionZ`;
	optionVar -intValue   dragUseDirection `checkBoxGrp -q -v1 dragUseDirection`;
	//optionVar -intValue   dragPerVertex `checkBoxGrp -q -v1 dragPerVertex`;
	optionVar -floatValue dragMaxDistCBox `checkBoxGrp -q -v1 dragMaxDistCBox`;
	optionVar -floatValue dragMaxDistance `floatSliderGrp -q -v dragMaxDistance`;


	volumeFieldCallback( "drag" );
	
	if ($executeCmd) {
		performDynamics $dynIsCreate "Drag" 0;
		string $tmpCmd = "performDynamics " + $dynIsCreate + " \"Drag\" 0";
		addToRecentCommandQueue $tmpCmd "Drag";
	}
}


global proc applyGravityCallback (string $parent, int $executeCmd)
//
// Description:
//	Set the optionVar's from the control values, and then perform
//	the command
//
{
	global int $dynIsCreate;
    setParent $parent;

	optionVar -stringValue gravityName `textFieldGrp -q -text gravityName`;
	optionVar -floatValue gravityMagnitude `floatSliderGrp -q -v gravityMagnitude`;
	optionVar -floatValue gravityAttenuation `floatSliderGrp -q -v gravityAttenuation`;
	optionVar -floatValue gravityDirectionX `floatSliderGrp -q -v gravityDirectionX`;
	optionVar -floatValue gravityDirectionY `floatSliderGrp -q -v gravityDirectionY`;
	optionVar -floatValue gravityDirectionZ `floatSliderGrp -q -v gravityDirectionZ`;
	//optionVar -intValue   gravityPerVertex `checkBoxGrp -q -v1 gravityPerVertex`;
	optionVar -floatValue gravityMaxDistCBox `checkBoxGrp -q -v1 gravityMaxDistCBox`;
	optionVar -floatValue gravityMaxDistance `floatSliderGrp -q -v gravityMaxDistance`;

	volumeFieldCallback( "gravity" );
	
	if ($executeCmd) {
		performDynamics  $dynIsCreate "Gravity" 0;
		string $tmpCmd = "performDynamics " + $dynIsCreate + " \"Gravity\" 0";
		addToRecentCommandQueue $tmpCmd "Gravity";
	}
}


global proc applyNewtonCallback (string $parent, int $executeCmd)
//
// Description:
//	Set the optionVar's from the control values, and then perform
//	the command
//
{
	global int $dynIsCreate;

    setParent $parent;

	optionVar -stringValue newtonName `textFieldGrp -q -text newtonName`;
	optionVar -floatValue newtonMagnitude `floatSliderGrp -q -v newtonMagnitude`;
	optionVar -floatValue newtonAttenuation `floatSliderGrp -q -v newtonAttenuation`;
	optionVar -floatValue newtonMinDistance `floatSliderGrp -q -v newtonMinDistance`;
	//optionVar -intValue newtonPerVertex `checkBoxGrp -q -v1 newtonPerVertex`;
	optionVar -floatValue newtonMaxDistCBox `checkBoxGrp -q -v1 newtonMaxDistCBox`;
	optionVar -floatValue newtonMaxDistance `floatSliderGrp -q -v newtonMaxDistance`;

	volumeFieldCallback( "newton" );
	
	if ($executeCmd) {
		performDynamics $dynIsCreate "Newton" 0;
		string $tmpCmd = "performDynamics " + $dynIsCreate + " \"Newton\" 0";
		addToRecentCommandQueue $tmpCmd "Newton";
	}
}


global proc applyRadialCallback (string $parent, int $executeCmd)
//
// Description:
//	Set the optionVar's from the control values, and then perform
//	the command
//
{
	global int $dynIsCreate;

    setParent $parent;

	optionVar -stringValue radialName `textFieldGrp -q -text radialName`;
	optionVar -floatValue radialMagnitude `floatSliderGrp -q -v radialMagnitude`;
	optionVar -floatValue radialAttenuation `floatSliderGrp -q -v radialAttenuation`;
	optionVar -floatValue radialType `floatSliderGrp -q -v radialType`;
	//optionVar -intValue radialPerVertex `checkBoxGrp -q -v1 radialPerVertex`;
	optionVar -intValue radialMaxDistDBox `checkBoxGrp -q -v1 radialMaxDistCBox`;
	optionVar -floatValue radialMaxDistCBox `checkBoxGrp -q -v1 radialMaxDistCBox`;
	optionVar -floatValue radialMaxDistance `floatSliderGrp -q -v radialMaxDistance`;

	volumeFieldCallback( "radial" );
	
	if ($executeCmd) {
		performDynamics $dynIsCreate "Radial" 0;
		string $tmpCmd = "performDynamics " + $dynIsCreate + " \"Radial\" 0";
		addToRecentCommandQueue $tmpCmd "Radial";
	}
}


global proc applyTurbulenceCallback (string $parent, int $executeCmd)
//
// Description:
//	Set the optionVar's from the control values, and then perform
//	the command
//
{
	global int $dynIsCreate;

    setParent $parent;

	optionVar -stringValue turbulenceName `textFieldGrp -q -text turbulenceName`;
	optionVar -floatValue turbulenceMagnitude `floatSliderGrp -q -v turbulenceMagnitude`;
	optionVar -floatValue turbulenceAttenuation `floatSliderGrp -q -v turbulenceAttenuation`;
	optionVar -floatValue turbulenceFrequency `floatSliderGrp -q -v turbulenceFrequency`;
	optionVar -floatValue turbulencePhaseX `floatSliderGrp -q -v turbulencePhaseX`;
	optionVar -floatValue turbulencePhaseY `floatSliderGrp -q -v turbulencePhaseY`;
	optionVar -floatValue turbulencePhaseZ `floatSliderGrp -q -v turbulencePhaseZ`;
	optionVar -intValue turbulenceNoiseLevel `intSliderGrp -q -v turbulenceNoiseLevel`;
	optionVar -floatValue turbulenceNoiseRatio `floatSliderGrp -q -v turbulenceNoiseRatio`;
	optionVar -floatValue turbulenceMaxDistCBox `checkBoxGrp -q -v1 turbulenceMaxDistCBox`;
	optionVar -floatValue turbulenceMaxDistance `floatSliderGrp -q -v turbulenceMaxDistance`;

	volumeFieldCallback( "turbulence" );
	
	if ($executeCmd) {
		performDynamics $dynIsCreate "Turbulence" 0;
		string $tmpCmd = "performDynamics " + $dynIsCreate + " \"Turbulence\" 0";
		addToRecentCommandQueue $tmpCmd "Turbulence";
	}
}


global proc applyUniformCallback (string $parent, int $executeCmd)
//
// Description:
//	Set the optionVar's from the control values, and then perform
//	the command
//
{
	global int $dynIsCreate;

    setParent $parent;

	optionVar -stringValue uniformName `textFieldGrp -q -text uniformName`;
	optionVar -floatValue uniformMagnitude `floatSliderGrp -q -v uniformMagnitude`;
	optionVar -floatValue uniformAttenuation `floatSliderGrp -q -v uniformAttenuation`;
	optionVar -floatValue uniformDirectionX `floatSliderGrp -q -v uniformDirectionX`;
	optionVar -floatValue uniformDirectionY `floatSliderGrp -q -v uniformDirectionY`;
	optionVar -floatValue uniformDirectionZ `floatSliderGrp -q -v uniformDirectionZ`;
	//optionVar -intValue uniformPerVertex `checkBoxGrp -q -v1 uniformPerVertex`;
	optionVar -floatValue uniformMaxDistCBox `checkBoxGrp -q -v1 uniformMaxDistCBox`;
	optionVar -floatValue uniformMaxDistance `floatSliderGrp -q -v uniformMaxDistance`;

	volumeFieldCallback( "uniform" );
	
	if ($executeCmd) {
		performDynamics $dynIsCreate "Uniform" 0;
		string $tmpCmd = "performDynamics " + $dynIsCreate + " \"Uniform\" 0";
		addToRecentCommandQueue $tmpCmd "Uniform";
	}
}


global proc applyVortexCallback (string $parent, int $executeCmd)
//
// Description:
//	Set the optionVar's from the control values, and then perform
//	the command
//
{
	global int $dynIsCreate;

    setParent $parent;

	optionVar -stringValue vortexName `textFieldGrp -q -text vortexName`;
	optionVar -floatValue vortexMagnitude `floatSliderGrp -q -v vortexMagnitude`;
	optionVar -floatValue vortexAttenuation `floatSliderGrp -q -v vortexAttenuation`;
	optionVar -floatValue vortexAxisX `floatSliderGrp -q -v vortexAxisX`;
	optionVar -floatValue vortexAxisY `floatSliderGrp -q -v vortexAxisY`;
	optionVar -floatValue vortexAxisZ `floatSliderGrp -q -v vortexAxisZ`;
	//optionVar -intValue vortexPerVertex `checkBoxGrp -q -v1 vortexPerVertex`;
	optionVar -floatValue vortexMaxDistCBox `checkBoxGrp -q -v1 vortexMaxDistCBox`;
	optionVar -floatValue vortexMaxDistance `floatSliderGrp -q -v vortexMaxDistance`;

	volumeFieldCallback( "vortex" );
	
	if ($executeCmd) {
		performDynamics $dynIsCreate "Vortex" 0;
		string $tmpCmd = "performDynamics " + $dynIsCreate + " \"Vortex\" 0";
		addToRecentCommandQueue $tmpCmd "Vortex";
	}
}


global proc applyVolumeAxisCallback (string $parent, int $executeCmd)
//
// Description:
//	Set the optionVar's from the control values, and then perform
//	the command
//
{
	global int $dynIsCreate;

    setParent $parent;

	optionVar -stringValue volumeAxisName `textFieldGrp -q -text volumeAxisName`;
	optionVar -floatValue volumeAxisMagnitude `floatSliderGrp -q -v volumeAxisMagnitude`;
	optionVar -floatValue volumeAxisAttenuation `floatSliderGrp -q -v volumeAxisAttenuation`;
	optionVar -floatValue volumeAxisInvertAttenuation `checkBoxGrp -q -v1 volumeAxisInvertAttenuation`;
	optionVar -floatValue volumeAxisMaxDistCBox `checkBoxGrp -q -v1 volumeAxisMaxDistCBox`;
	optionVar -floatValue volumeAxisMaxDistance `floatSliderGrp -q -v volumeAxisMaxDistance`;
	optionVar -floatValue volumeAxisDirectionX `floatSliderGrp -q -v volumeAxisDirectionX`;
	optionVar -floatValue volumeAxisDirectionY `floatSliderGrp -q -v volumeAxisDirectionY`;
	optionVar -floatValue volumeAxisDirectionZ `floatSliderGrp -q -v volumeAxisDirectionZ`;
	optionVar -floatValue volumeAxisAwayFromCenter `floatSliderGrp -q -v volumeAxisAwayFromCenter`;
	optionVar -floatValue volumeAxisAwayFromAxis `floatSliderGrp -q -v volumeAxisAwayFromAxis`;
	optionVar -floatValue volumeAxisAlongAxis `floatSliderGrp -q -v volumeAxisAlongAxis`;
	optionVar -floatValue volumeAxisAroundAxis `floatSliderGrp -q -v volumeAxisAroundAxis`;
	//optionVar -floatValue volumeAxisRandomSpread `floatSliderGrp -q -v volumeAxisRandomSpread`;
	optionVar -floatValue volumeAxisDirectionalSpeed `floatSliderGrp -q -v volumeAxisDirectionalSpeed`;
	optionVar -floatValue volumeAxisTurbulence `floatSliderGrp -q -v volumeAxisTurbulence`;
	optionVar -floatValue volumeAxisTurbulenceSpeed `floatSliderGrp -q -v volumeAxisTurbulenceSpeed`;
	optionVar -floatValue volumeAxisTurbulenceFrequencyX `floatSliderGrp -q -v volumeAxisTurbulenceFrequencyX`;
	optionVar -floatValue volumeAxisTurbulenceFrequencyY `floatSliderGrp -q -v volumeAxisTurbulenceFrequencyY`;
	optionVar -floatValue volumeAxisTurbulenceFrequencyZ `floatSliderGrp -q -v volumeAxisTurbulenceFrequencyZ`;
	optionVar -floatValue volumeAxisTurbulenceOffsetX `floatSliderGrp -q -v volumeAxisTurbulenceOffsetX`;
	optionVar -floatValue volumeAxisTurbulenceOffsetY `floatSliderGrp -q -v volumeAxisTurbulenceOffsetY`;
	optionVar -floatValue volumeAxisTurbulenceOffsetZ `floatSliderGrp -q -v volumeAxisTurbulenceOffsetZ`;
	optionVar -floatValue volumeAxisDetailTurbulence `floatSliderGrp -q -v volumeAxisDetailTurbulence`;

	volumeFieldCallback( "volumeAxis" );
	
	if ($executeCmd) {
		performDynamics $dynIsCreate "VolumeAxis" 0;
		string $tmpCmd = "performDynamics " + $dynIsCreate + " \"VolumeAxis\" 0";
		addToRecentCommandQueue $tmpCmd "VolumeAxis";
	}
}


global proc doDynEmitCallback (string $parent, int $executeCmd, int $createNParticle)
//
// Description:
//	Set the optionVar's from the control values, and then perform
//	the command
//
{
	global int $dynIsCreate;

    setParent $parent;

	optionVar -stringValue emitterName `textFieldGrp -q -text emitterName`;

	// In create, emitter type 3 is volume, which we write to option var as 5.
	//
	int $emitterType =  `optionMenuGrp -q -sl emitterTypesOM`;
	if (($dynIsCreate) && ($emitterType == 3))
		$emitterType = 5;
	optionVar -intValue emitterTypesOM $emitterType;
	optionVar -floatValue emitterRate `floatSliderGrp -q -v emitterRate`;
	optionVar -intValue emitterScaleRateByObjectSize `checkBoxGrp -q -v1 emitterScaleRateByObjectSize`;
	optionVar -intValue emitterNeedParentUV `checkBoxGrp -q -v1 emitterNeedParentUV`;
	optionVar -intValue emitterCycleOM `optionMenuGrp -q -sl emitterCycleOM`;
	optionVar -intValue emitterCycleInterval `intSliderGrp -q -v emitterCycleInterval`;

	optionVar -floatValue emitterMaxDistance `floatSliderGrp -q -v emitterMaxDistance`;
	optionVar -floatValue emitterMinDistance `floatSliderGrp -q -v emitterMinDistance`;
	optionVar -floatValue emitterDirectionX `floatSliderGrp -q -v emitterDirectionX`;
	optionVar -floatValue emitterDirectionY `floatSliderGrp -q -v emitterDirectionY`;
	optionVar -floatValue emitterDirectionZ `floatSliderGrp -q -v emitterDirectionZ`;
	optionVar -floatValue emitterSpread `floatSliderGrp -q -v emitterSpread`;

	optionVar -floatValue emitterSpeed `floatSliderGrp -q -v emitterSpeed`;
	optionVar -floatValue emitterSpeedRandomRange `floatSliderGrp -q -v emitterSpeedRandomRange`;
	optionVar -floatValue emitterNormalSpeed `floatSliderGrp -q -v emitterNormalSpeed`;
	optionVar -floatValue emitterTangentSpeed `floatSliderGrp -q -v emitterTangentSpeed`;

	
	optionVar -intValue emitterVolumeShapeOM `optionMenuGrp -q -sl emitterVolumeShapeOM`;
	optionVar -floatValue emitterVolumeOffsetX `floatSliderGrp -q -v emitterVolumeOffsetX`;
	optionVar -floatValue emitterVolumeOffsetY `floatSliderGrp -q -v emitterVolumeOffsetY`;
	optionVar -floatValue emitterVolumeOffsetZ `floatSliderGrp -q -v emitterVolumeOffsetZ`;
	optionVar -floatValue emitterVolumeSweep `floatSliderGrp -q -v emitterVolumeSweep`;
	optionVar -floatValue emitterTorusSectionRadius `floatSliderGrp -q -v emitterTorusSectionRadius`;

	optionVar -floatValue emitterAwayFromCenter `floatSliderGrp -q -v emitterAwayFromCenter`;
	optionVar -floatValue emitterAwayFromAxis `floatSliderGrp -q -v emitterAwayFromAxis`;
	optionVar -floatValue emitterAlongAxis `floatSliderGrp -q -v emitterAlongAxis`;
	optionVar -floatValue emitterAroundAxis `floatSliderGrp -q -v emitterAroundAxis`;
	optionVar -floatValue emitterRandomSpread `floatSliderGrp -q -v emitterRandomSpread`;
	optionVar -floatValue emitterDirectionalSpeed `floatSliderGrp -q -v emitterDirectionalSpeed`;
	optionVar -intValue emitterScaleSpeedBySize `checkBoxGrp -q -v1 emitterScaleSpeedBySize`;
	optionVar -intValue emitterDieOnExit `checkBoxGrp -q -v1 emitterDieOnExit`;

	if ($executeCmd) {
		if( $createNParticle ){
			performDynamics $dynIsCreate "nEmitter" 0;
			string $tmpCmd = "performDynamics " + $dynIsCreate + " \"nEmitter\" 0";
			addToRecentCommandQueue $tmpCmd "nEmitter";
		} else {
			performDynamics $dynIsCreate "Emitter" 0;
			string $tmpCmd = "performDynamics " + $dynIsCreate + " \"Emitter\" 0";
			addToRecentCommandQueue $tmpCmd "Emitter";
		}
	}
}

global proc applyEmitterCallback (string $parent, int $executeCmd)
{
	doDynEmitCallback( $parent, $executeCmd, false );
}

global proc applynEmitterCallback (string $parent, int $executeCmd)
{
	doDynEmitCallback( $parent, $executeCmd, true );
}

global proc applyCollisionCallback (string $parent, int $executeCmd)
//
// Description:
//	Set the optionVar's from the control values, and then perform
//	the command
//
{
    setParent $parent;

	optionVar -floatValue collisionResilience `floatSliderGrp -q -v collisionResilience`;
	optionVar -floatValue collisionFriction `floatSliderGrp -q -v collisionFriction`;
	optionVar -floatValue collisionOffset `floatSliderGrp -q -v collisionOffset`;
	
	if ($executeCmd) {
		performDynamics 0 "Collision" 0;
		string $tmpCmd = "performDynamics 0 \"Collision\" 0";
		addToRecentCommandQueue $tmpCmd "Collision";
	}
}


global proc applyGoalCallback (string $parent, int $executeCmd)
//
// Description:
//	Set the optionVar's from the control values, and then perform
//	the command
//
{
    setParent $parent;

	optionVar -floatValue goalWeight `floatSliderGrp -q -v goalWeight`;
	optionVar -floatValue goalUseTransform `checkBoxGrp -q -v1 goalUseTransform`;
	
	if ($executeCmd) {
		performDynamics 0 "Goal" 0;
		string $tmpCmd = "performDynamics 0 \"Goal\" 0";
		addToRecentCommandQueue $tmpCmd "Goal";
	}
}


global proc applyRigidCallback (string $parent, int $executeCmd)
//
// Description:
//	Set the optionVar's from the control values, and then perform
//	the command
//
{
    setParent $parent;

	optionVar -stringValue rigidName `textFieldGrp -q -text rigidName`;

	optionVar -intValue rigidCollisionType `checkBoxGrp -q -v1 rigidActiveCollision`; 
	optionVar -intValue rigidCollide `checkBoxGrp -q -v2 rigidActiveCollision`; 

	optionVar -floatValue rigidMass `floatSliderGrp -q -v rigidMass`;
	optionVar -intValue rigidComCBox `checkBoxGrp -q -v1 rigidComCBox`;
	optionVar -floatValue rigidComX `floatSliderGrp -q -v rigidComX`;
	optionVar -floatValue rigidComY `floatSliderGrp -q -v rigidComY`;
	optionVar -floatValue rigidComZ `floatSliderGrp -q -v rigidComZ`;

	optionVar -floatValue rigidStatFriction `floatSliderGrp -q -v rigidStatFriction`;
	optionVar -floatValue rigidDynFriction `floatSliderGrp -q -v rigidDynFriction`;
	optionVar -floatValue rigidBounciness `floatSliderGrp -q -v rigidBounciness`;
	optionVar -floatValue rigidDamping `floatSliderGrp -q -v rigidDamping`;

	optionVar -floatValue rigidImpulseX `floatSliderGrp -q -v rigidImpulseX`;
	optionVar -floatValue rigidImpulseY `floatSliderGrp -q -v rigidImpulseY`;
	optionVar -floatValue rigidImpulseZ `floatSliderGrp -q -v rigidImpulseZ`;

	optionVar -floatValue rigidImpulsePosX `floatSliderGrp -q -v rigidImpulsePosX`;
	optionVar -floatValue rigidImpulsePosY `floatSliderGrp -q -v rigidImpulsePosY`;
	optionVar -floatValue rigidImpulsePosZ `floatSliderGrp -q -v rigidImpulsePosZ`;

	optionVar -floatValue rigidSpinImpulseX `floatSliderGrp -q -v rigidSpinImpulseX`;
	optionVar -floatValue rigidSpinImpulseY `floatSliderGrp -q -v rigidSpinImpulseY`;
	optionVar -floatValue rigidSpinImpulseZ `floatSliderGrp -q -v rigidSpinImpulseZ`;

	optionVar -floatValue rigidAngVelocityX `floatSliderGrp -q -v rigidAngVelocityX`;
	optionVar -floatValue rigidAngVelocityY `floatSliderGrp -q -v rigidAngVelocityY`;
	optionVar -floatValue rigidAngVelocityZ `floatSliderGrp -q -v rigidAngVelocityZ`;

	optionVar -intValue rigidPosCBox `checkBoxGrp -q -v1 rigidPosCBox`;
	optionVar -floatValue rigidPosX `floatSliderGrp -q -v rigidPosX`;
	optionVar -floatValue rigidPosY `floatSliderGrp -q -v rigidPosY`;
	optionVar -floatValue rigidPosZ `floatSliderGrp -q -v rigidPosZ`;

	optionVar -intValue rigidOrCBox `checkBoxGrp -q -v1 rigidOrCBox`;
	optionVar -floatValue rigidOrX `floatSliderGrp -q -v rigidOrX`;
	optionVar -floatValue rigidOrY `floatSliderGrp -q -v rigidOrY`;
	optionVar -floatValue rigidOrZ `floatSliderGrp -q -v rigidOrZ`;

	optionVar -floatValue rigidInitVelocityX `floatSliderGrp -q -v rigidInitVelocityX`;
	optionVar -floatValue rigidInitVelocityY `floatSliderGrp -q -v rigidInitVelocityY`;
	optionVar -floatValue rigidInitVelocityZ `floatSliderGrp -q -v rigidInitVelocityZ`;

	optionVar -intValue rigidStandInType `optionMenuGrp -q -sl rigidStandInType`;

	optionVar -intValue rigidTesselation `intFieldGrp -q -v1 rigidTesselation`;
	optionVar -intValue rigidLayer `intFieldGrp -q -v1 rigidLayer`;
	optionVar -intValue rigidCacheCBox `checkBoxGrp -q -v1 rigidCacheCBox`;

	if ($executeCmd)
	{
		string $rigidType;
		if (`optionVar -query  rigidCollisionType` == 1)
			$rigidType = "ActiveRigid";
		else
			$rigidType = "PassiveRigid";
		performDynamics 0 $rigidType 0;
		string $tmpCmd = "performDynamics 0 \"" + $rigidType + "\" 0";
		string $tmpLabel = $rigidType + "Body";
		addToRecentCommandQueue $tmpCmd $tmpLabel;
	}
}

global proc applySoftOptionVars (string $parent)
//
// Description:
//	Set the optionVar's from the control values
//
{
    setParent $parent;

	optionVar -intValue softCreationOption `optionMenuGrp -q -sl softCreationOption`;
	optionVar -intValue softGoal `checkBoxGrp -q -v1 softGoal`;
	optionVar -intValue softHide `checkBoxGrp -q -v1 softHide`;
	optionVar -intValue softHistory `checkBoxGrp -q -v1 softHistory`;

	optionVar -floatValue softWeight `floatSliderGrp -q -v softWeight`;
}

global proc applySoftCallback (string $parent, int $executeCmd)
//
// Description:
//	Set the optionVar's from the control values, and then perform
//	the command
//
{
	applySoftOptionVars( $parent );

	if ($executeCmd) {
		performDynamics 0 "Soft" 0;
		string $tmpCmd = "performDynamics 0 \"Soft\" 0";
		addToRecentCommandQueue $tmpCmd "Soft";
	}
}

global proc applyNSoftCallback (string $parent, int $executeCmd)
//
// Description:
//	Set the optionVar's from the control values, and then perform
//	the command
//
{
	applySoftOptionVars( $parent );

	if ($executeCmd) {
		performDynamics 0 "NSoft" 0;
		string $tmpCmd = "performDynamics 0 \"NSoft\" 0";
		addToRecentCommandQueue $tmpCmd "NSoft";
	}
}

global proc applyConstrainCallback (string $parent, int $executeCmd)
//
// Description:
//	Set the optionVar's from the control values, and then perform
//	the command
//
{
    setParent $parent;

	optionVar -stringValue constrainName `textFieldGrp -q -text constrainName`;
	optionVar -intValue constrainTypesOM `optionMenuGrp -q -sl constrainTypesOM`;
	optionVar -intValue constrainInterCB `checkBoxGrp -q -v1 constrainInterCB`;

	optionVar -intValue constrainPosCBox `checkBoxGrp -q -v1 constrainPosCBox`;
	optionVar -floatValue constrainPosX `floatSliderGrp -q -v constrainPosX`;
	optionVar -floatValue constrainPosY `floatSliderGrp -q -v constrainPosY`;
	optionVar -floatValue constrainPosZ `floatSliderGrp -q -v constrainPosZ`;

	optionVar -floatValue constrainOrientX
				`floatSliderGrp -q -v constrainOrientX`;
	optionVar -floatValue constrainOrientY
				`floatSliderGrp -q -v constrainOrientY`;
	optionVar -floatValue constrainOrientZ
				`floatSliderGrp -q -v constrainOrientZ`;

	optionVar -floatValue constrainSpringStiffness
				`floatSliderGrp -q -v constrainSpringStiffness`;
	optionVar -floatValue constrainSpringDamping 
				`floatSliderGrp -q -v constrainSpringDamping`;
	optionVar -intValue   constrainSpringRestLengthCBox
				`checkBoxGrp -q -v1 constrainSpringRestLengthCBox`;
	optionVar -floatValue constrainSpringRestLength
				`floatSliderGrp -q -v constrainSpringRestLength`;

	if ($executeCmd) {
		performDynamics 0 "Constrain" 0;
		string $tmpCmd = "performDynamics 0 \"Constrain\" 0";
		addToRecentCommandQueue $tmpCmd "Constrain";
	}
}


global proc applySpringCallback (string $parent, int $executeCmd)
//
// Description:
//	Set the optionVar's from the control values, and then perform
//	the command
//
{
    setParent $parent;

	optionVar -stringValue springName `textFieldGrp -q -text springName`;
	optionVar -intValue springAdd `checkBoxGrp -q -v1 springAdd`;
	optionVar -intValue springNoDuplicate `checkBoxGrp -q -v1 springNoDuplicate`;
	optionVar -intValue springExclusive `checkBoxGrp -q -v1 springExclusive`;
	optionVar -intValue springMethodsOM `optionMenuGrp -q -sl springMethodsOM`;

	optionVar -floatValue springMinDistance 
				`floatSliderGrp -q -v springMinDistance`;
	optionVar -floatValue springMaxDistance
				`floatSliderGrp -q -v springMaxDistance`;
	optionVar -intValue springWireWalkLength 
				`intFieldGrp -q -v1 springWireWalkLength`;

	optionVar -intValue springUseStiffnessPS
				`checkBoxGrp -q -v1 springUseStiffnessPS`;
	optionVar -intValue springUseDampingPS
				`checkBoxGrp -q -v1 springUseDampingPS`;
	optionVar -intValue springUseRestLengthPS
				`checkBoxGrp -q -v1 springUseRestLengthPS`;

	optionVar -floatValue springStiffness
				`floatSliderGrp -q -v springStiffness`;
	optionVar -floatValue springDamp `floatSliderGrp -q -v springDamp`;
	optionVar -floatValue springRestLength
				`floatSliderGrp -q -v springRestLength`;
	optionVar -floatValue springStartForceWeight
				`floatSliderGrp -q -v springStartForceWeight`;
	optionVar -floatValue springEndForceWeight
				`floatSliderGrp -q -v springEndForceWeight`;

	if ($executeCmd) {
		performDynamics 0 "Spring" 0;
		string $tmpCmd = "performDynamics 0 \"Spring\" 0";
		addToRecentCommandQueue $tmpCmd "Spring";
	}
}

global proc applyParticleInstancerCallback (string $parent, int $executeCmd )
{
    setParent $parent;


	int $value = `optionMenuGrp -q -sl PIautoCycleOM`;
	optionVar -stringValue particleInstancerName  `textFieldGrp   -q -tx particleInstancerName`;
	optionVar -stringValue PIautoCycleOM          `optionMenuGrp  -q -v PIautoCycleOM`;
	optionVar -floatValue  PIautoCycleStepSize    `floatSliderGrp -q -v  PIautoCycleStepSize`;
	optionVar -stringValue PIautoCycleStepUnitsOM `optionMenuGrp  -q -v PIautoCycleStepUnitsOM`;
	optionVar -stringValue PIlevelOfDetailOM      `optionMenuGrp  -q -v PIlevelOfDetailOM`;
	optionVar -stringValue PIrotationUnitsOM      `optionMenuGrp  -q -v PIrotationUnitsOM`;
	optionVar -stringValue PIrotationOrderOM      `optionMenuGrp  -q -v PIrotationOrderOM`;

	updateAllDynamicAttributeOptionVar();

	if ( $executeCmd )
	{
		performDynamics 0 "ParticleInstancer" 0;
		string $tmpCmd = "performDynamics 0 \"ParticleInstancer\" 0";
		addToRecentCommandQueue $tmpCmd "ParticleInstancer";
	}
}


global proc applyParticleRenderCacheCallback( string $parent, int $executeCmd )
//
//  Create the particle render cache for the given frame range.
//  Set the useParticleRenderCache variable to true.
//
//  VERY IMPORTANT NOTE:
//  If you make changes here, ALSO CHANGE setParticleRenderCacheCmdString
//  in dynApplyCallback.mel.  That routine sets the string for dragging to the shelf.
{
	setParent $parent;

	// Get path control value.
	// (Note: In the case where that value is supposed to come from
	// dynGlobals, it is already set to the control by dynSetOptionControls.)
	// 
	string $path = `textFieldGrp -q -text particleRenderCacheDirectory`;

	// If path is empty, use scene name instead. We don't allow empty path.
	//
	if (size($path) == 0)
	{
		$path = `file -q -rpr`;
	}
	else
	{
		// If user did specify a path, but it is not the same
		// same as the scene name, make sure this is what the user
		// really wants to do.
		//
		if (!dynVerifyPath( $path ))
		{
				// user aborted operation. return.
				//
				return;
		}
	}

	if ($path == (untitledFileName()) )
	{
			// Post dialog to ask the user to confirm
			//
			string $msgString = (uiRes("m_dynApplyCallback.kSceneNameFirstMessage"));
			string $yes = (uiRes("m_dynApplyCallback.kYes"));
			string $no = (uiRes("m_dynApplyCallback.kNo"));
			if ($no ==`confirmDialog -title (uiRes("m_dynApplyCallback.kConfirm"))
				-message $msgString -button $yes 
				-button $no -defaultButton $yes 
				-cancelButton $no -dismissString $no`)
			{
				return;
			}
	}

	if (!dynCheckOverwriteCacheDirectory( $path )) return;

	// Check whether we have a particle data area.
	// If not, make one.
	//
	string $particleDir = `workspace -fre particles`;
	if (size($particleDir) == 0)
	{
		workspace -fr particles particles;
	}
	
	// Get and store the value of the useRenderGlobals control
	//
	optionVar -intValue cacheForRenderGlobalsRange `checkBoxGrp -q -v1 cacheForRenderGlobalsRange`;
	optionVar -intValue onlyUpdateParticles        `checkBoxGrp -q -v1 onlyUpdateParticles`;
	// radio buttons 1 = selected 2 = all
	optionVar -intValue cacheAllParticleSystems    (`radioButtonGrp -q -select cacheAllParticleSystems` - 1);

	if ($executeCmd)
	{
		int $useRenderGlobals = `optionVar -query cacheForRenderGlobalsRange`;
		int $onlyUpdateParticles = `optionVar -query onlyUpdateParticles`;
		int $cacheAllParticleSystems = `optionVar -query cacheAllParticleSystems`;
		int $minFrame;
		int $maxFrame;
		if (!$useRenderGlobals)
		{
			// Get current playback range for export.
			//
			$minFrame = `playbackOptions -query -min`;
			$maxFrame = `playbackOptions -query -max`;
		}
		else
		{
			// Get frame range from default render globals
			//
			$minFrame = `getAttr defaultRenderGlobals.startFrame`;
			$maxFrame = `getAttr defaultRenderGlobals.endFrame`;
		}

		dynCleanCacheDirectory( $path );

		// Issue the command.
		// The other callbacks go back through performDynamics,
		// we don't do this because that routine assumes a particular
		// structure and a particular way of using the selection list
		// which we are not doing here.
		//
		string $cmdString = "dynExport -path \""+ $path + 
							"\" -f cache -mnf " + $minFrame + 
							" -mxf "+$maxFrame + " -oup " + $onlyUpdateParticles +
							" -all " + $cacheAllParticleSystems;

		evalEcho $cmdString;
		addToRecentCommandQueue $cmdString "Create particle render cache";
	}

	// Save the path in dynGlobals.
	// Note: We also get here when $executeCmd is 0, 
	// which happens when the user hits the Save button.
	// So for this control, Save saves the value to dynGlobals.
	//
	// Get the dynGlobals node
	//
	string $theGlobal;
	if (!catch ($theGlobal = `dynGlobals -q -active`))
	{
		setAttr ($theGlobal + ".cacheDirectory") -type "string" $path;	
	}
}

global proc updateDynamicAttributeOptionVar( string $name )
{
	string $omName = $name + "OM";

    if ( `optionMenuGrp -q -exists $omName` == 1 )
	{
		optionVar -stringValue $omName `optionMenuGrp -q -v $omName`;
	}
}

global proc updateAllDynamicAttributeOptionVar()
{
    updateDynamicAttributeOptionVar( "Position" );
    updateDynamicAttributeOptionVar( "Rotation" );
    updateDynamicAttributeOptionVar( "Scale" );
    updateDynamicAttributeOptionVar( "Shear" );
    updateDynamicAttributeOptionVar( "AimDirection" );
    updateDynamicAttributeOptionVar( "AimPosition" );
    updateDynamicAttributeOptionVar( "AimAxis" );
    updateDynamicAttributeOptionVar( "AimWorldUp" );
    updateDynamicAttributeOptionVar( "RotationType" );
    updateDynamicAttributeOptionVar( "ObjectIndex" );
    updateDynamicAttributeOptionVar( "CycleStartObject" );
    updateDynamicAttributeOptionVar( "Age" );
    updateDynamicAttributeOptionVar( "Visibility" );
}

