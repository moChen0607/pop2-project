// Copyright (C) 1997-2014 Autodesk, Inc., and/or its licensors.
// All rights reserved.
//
// The coded instructions, statements, computer programs, and/or related
// material (collectively the "Data") in these files contain unpublished
// information proprietary to Autodesk, Inc. ("Autodesk") and/or its licensors,
// which is protected by U.S. and Canadian federal copyright law and by
// international treaties.
//
// The Data is provided for use exclusively by You. You have the right to use,
// modify, and incorporate this Data into other products for purposes authorized 
// by the Autodesk software license agreement, without fee.
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND. AUTODESK
// DOES NOT MAKE AND HEREBY DISCLAIMS ANY EXPRESS OR IMPLIED WARRANTIES
// INCLUDING, BUT NOT LIMITED TO, THE WARRANTIES OF NON-INFRINGEMENT,
// MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE, OR ARISING FROM A COURSE 
// OF DEALING, USAGE, OR TRADE PRACTICE. IN NO EVENT WILL AUTODESK AND/OR ITS
// LICENSORS BE LIABLE FOR ANY LOST REVENUES, DATA, OR PROFITS, OR SPECIAL,
// DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES, EVEN IF AUTODESK AND/OR ITS
// LICENSORS HAS BEEN ADVISED OF THE POSSIBILITY OR PROBABILITY OF SUCH DAMAGES.

//
//
//  Creation Date:  June 2000
//
//  Description:
//
//      Option tool property window for Artisan tools
//
//
//  Procedure Name:
//      artisanValues
//
//  Description:
//      Initialize the option values.
//
//  Input Arguments:
//
//  Return Value:
//      None.
//

// ===================================================
// Artisan Update prcedures.
// ===================================================
global proc  artisanBrushValues(
	string  $artCommand,
	string	$currTool
)
//
// Description:
//		Set the brush framelayout values.
//
{
	$cmd = ($artCommand + " -q -radius " + `currentCtx` );
	float $radius = `eval $cmd`;
	floatSliderGrp -e -v $radius upperRadiusSlider;

	$cmd = ($artCommand + " -q -lowerradius " + `currentCtx` );
	float $lowerRadius = `eval $cmd`;
	floatSliderGrp -e -v $lowerRadius lowerRadiusSlider;

	if ( $currTool != "artSelect" ) {
		$cmd = ($artCommand + " -q -opacity " + `currentCtx` );
		float $opacity = `eval $cmd`;
		floatSliderGrp -e -v $opacity opacitySlider;

		if ( isOpacityAccumulationRequired() ) {
			$cmd = ($artCommand + " -q -accopacity " + `currentCtx` );
			int $accopacity = `eval $cmd`;
			checkBoxGrp -e -v1 $accopacity accOpacityChkBox;
		}

		if ( `checkBoxGrp -exists artDrawTangentOutlineChkBox` ) {
			$cmd = ($artCommand + " -q -tangentOutline " + `currentCtx` );
			int $tangentOutline = `eval $cmd`;
			checkBoxGrp -e -v1 $tangentOutline artDrawTangentOutlineChkBox;
		}

		if ( isSurfaceConformedBrushAvailable() ) {
			/*
			$cmd = ($artCommand + " -q -surfaceConformedBrush " + `currentCtx` );
			int $surfConf = `eval $cmd`;
			checkBoxGrp -e -v1 $surfConf surfaceConformedChkBox;
			*/

			$cmd = ($artCommand + " -q -surfaceConformedBrushVertices " + `currentCtx` );
			int $surfConfVtx = `eval $cmd`;
			checkBoxGrp -e -v1 $surfConfVtx surfaceConformedVtxChkBox;
		}
	}

	$cmd = ($artCommand + " -q -stampProfile " + `currentCtx`);
	string $profile = `eval $cmd`;
	if ( $profile == "gaussian" ) {
		artUpdateStampProfile( "gaussian", $artCommand );
	} else if ( $profile == "solid" ) {
		artUpdateStampProfile( "solid", $artCommand ); 
	} else if ( $profile == "poly" ) {
		artUpdateStampProfile( "poly", $artCommand ); 
	} else if ( $profile == "square" ) {
		artUpdateStampProfile( "square", $artCommand ); 
	} else if ( $profile == "shape" ) {
		artUpdateStampProfile( "shape", $artCommand ); 
	}

	// Brush Alignment.
	if(`checkBoxGrp -exists artBrushAlignmentChkBox`)
	{
	    $cmd = ($artCommand + " -q -brushalignment " + `currentCtx`);
	    checkBoxGrp -e -v1 `eval $cmd` artBrushAlignmentChkBox;
	}
		
}


global proc artisanStrokeValues(
	string  $artCommand,
	string	$currTool
)
//
// Description:
//		Set Stroke framelayout values.
//
{
	// Paint Mode FrameLayout.
	string $cmd = ($artCommand + " -q -projective " + `currentCtx` );
	checkBoxGrp -e -v1 `eval $cmd` artProjectionModeChkBox;

	// Reflection Mode.
	$cmd = ($artCommand + " -q -reflection  " + `currentCtx` );
	checkBoxGrp -e -v1 `eval $cmd` artReflectionModeChkBox;
	artUpdatePaintMode( $artCommand );

	// Reflection About Origin Mode.
	$cmd = ($artCommand + " -q -reflectionaboutorigin  " + `currentCtx` );
	checkBoxGrp -e -v1 `eval $cmd` artReflectionModeAboutOriginChkBox;
	artUpdatePaintMode( $artCommand );

	// Reflection Axis
	$cmd = ($artCommand + " -q -reflectionaxis "+ `currentCtx`);
	string $refaxis = `eval $cmd`;
	if ( $refaxis == "x" ) {
	radioButtonGrp -e -sl 1 artReflectionRadBtn;
	} else if ( $refaxis == "y" ) {
	radioButtonGrp -e -sl 2 artReflectionRadBtn;
	} else if ( $refaxis == "z" ) {
	radioButtonGrp -e -sl 3 artReflectionRadBtn;
	}
	
	//Invert Reference Vector
	if ( $currTool == "artPutty" ) {
		$cmd = ($artCommand + " -q -irv " + `currentCtx`);
		checkBoxGrp -e -v1 `eval $cmd` invertVectorChkBox;
		artUpdateInvertReferenceMode $artCommand;
	}

	// Stamp Quality Sliders.
	$cmd = ($artCommand + " -q -stampSpacing " + `currentCtx`);
	floatSliderGrp -e -v `eval $cmd` artStampSpacingSlider;

	$cmd = ($artCommand + " -q -stampDepth " + `currentCtx`);
	floatSliderGrp -e -v `eval $cmd` artStampDepthSlider;

	// If this is Paint Select tool do also the stroke commanes.
	if ( $currTool == "artSelect" || $currTool == "artPutty") {
		$cmd = $artCommand + " -q -bsc " + `currentCtx`;
		textFieldGrp -e -text `eval $cmd` artPreStrokeTextField;
		$cmd = $artCommand + " -q -asc " + `currentCtx`;
		textFieldGrp -e -text `eval $cmd` artPostStrokeTextField;
	}

	if ( $currTool == "artAttr" ) {
		$cmd = $artCommand + " -q -interactiveUpdate " + `currentCtx`;
		checkBoxGrp -e -v1 `eval $cmd` artAttrInteractiveUpdate;
	}
}


global proc artisanPressureValues(
	string  $artCommand,
	string	$currTool
)
//
// Description:
//		Set stylus pressure framelayout values.
//
{
	if( !`exists stylusPressure_melToUI` ) {
        source "artisanProperties.mel";
    }
	// Tablet Pressure.
	$cmd = ($artCommand + " -q -usepressure " + `currentCtx`);
	checkBoxGrp -e -v1 `eval $cmd` artStylusPressureChkBox;

	artUpdateTabletPressure( $artCommand  );

	$cmd = ($artCommand + " -q -mappressure " + `currentCtx`);
	string $uiName = stylusPressure_melToUI(`eval $cmd`);
	optionMenuGrp -e -v $uiName artStylusPressureOpMenu;
}


global proc artisanAttrMapValues(
	string  $artCommand,
	string	$currTool
) 
// 
// Description:
//		Import/Export of attribute maps values.
//
{
	source "artisanToolConfigurations.mel" ;

	string $alpha     = (uiRes("m_artisanValues.kAlpha"));
	string $luminance = (uiRes("m_artisanValues.kLuminance"));
	string $rgb       = (uiRes("m_artisanValues.kRGB"));
	string $rgba      = (uiRes("m_artisanValues.kRGBA"));
	string $red       = (uiRes("m_artisanValues.kRed"));
	string $green     = (uiRes("m_artisanValues.kGreen"));
	string $blue      = (uiRes("m_artisanValues.kBlue"));
	
	// Current tool.
	string $currContext = `currentCtx`;
	string $currTool    = `contextInfo -c $currContext`;
	
	//  Import Map frameLayout
	$cmd = ($artCommand + " -q -importreassign " + `currentCtx` );
	checkBoxGrp -e -v1 `eval $cmd` reassignMapsChkBox;

	$cmd = ($artCommand + " -q -importfilemode " + `currentCtx` );
	string $importMode= `eval $cmd`;

	string $importMapMenu = $currTool + "importMapValueMenu";
	if ( $importMode == "alpha" ) {
		optionMenuGrp -e -v $alpha  $importMapMenu;
	} else if ( $importMode == "luminance" ) {
		optionMenuGrp -e -v $luminance  $importMapMenu;
	} else if ( $importMode == "red" ) {
		optionMenuGrp -e -v $red   $importMapMenu;
	} else if ( $importMode == "green" ) {
		optionMenuGrp -e -v $green  $importMapMenu;
	} else if ( $importMode == "blue" ) {
		optionMenuGrp -e -v $blue  $importMapMenu;
	}

	if ( $currTool == "artSelect" ) {
		$cmd = ($artCommand + " -q -importthreshold " + `currentCtx` );
		floatSliderGrp -e -v `eval $cmd` importThresholdSlider;
	}

	string $exportMapMenu = $currTool + "exportMapValueMenu";
	if ( isExportPanelUsed() ) 
	{
		$cmd = ($artCommand + " -q -exportfilemode " + `currentCtx` );
		string $exportVal = `eval $cmd`;
		if ( $exportVal == "alpha" ) {
			optionMenuGrp -e -v $alpha  $exportMapMenu;
		} else if ( $exportVal == "luminance" ) { // same as rgb in 3d
			optionMenuGrp -e -v $luminance  $exportMapMenu;
		} else if ( $exportVal == "rgb" ) {       // same as luminance in 1d
			optionMenuGrp -e -v $rgb  $exportMapMenu;
		} else if ( $exportVal == "rgba" ) {      // same as luminance in 1d
			optionMenuGrp -e -v $rgba  $exportMapMenu;
		}

		$cmd = ($artCommand + " -q -exportaspectratio " + `currentCtx` );
		checkBoxGrp -e -v1 `eval $cmd` exportKeepAspectChkBox;
	
		if( !`exists exportImageFormat_melToUI` ) {
            source "artisanProperties.mel";
        }
        
        $cmd = ($artCommand + " -q -exportfiletype " + `currentCtx` );
		string $uiName = exportImageFormat_melToUI(`eval $cmd`);
		optionMenuGrp -e -v $uiName exportImageFormat;
	
		$cmd = ($artCommand + " -q -exportfilesizex " + `currentCtx` );
		intSliderGrp -e -v `eval $cmd` exportMapSizeXSlider;

		$cmd = ($artCommand + " -q -exportfilesizey " + `currentCtx` );
		intSliderGrp -e -v `eval $cmd` exportMapSizeYSlider;
	}
}
		

global proc artisanDisplayValues(
	string  $artCommand,
	string	$currTool
) 
// 
// Description:
//		
//
{
	source "artisanNamedCommandSetup.mel" ;

	string $cmd = ($artCommand + " -q -outline " + `currentCtx`);
	checkBoxGrp -e -v1 `eval $cmd` artDrawOutlineChkBox;
	artUpdateDisplayValues( $artCommand );

	$cmd = ($artCommand + " -q -outwhilepaint " + `currentCtx`);
	checkBoxGrp -e -v1 `eval $cmd` artBrushWhilePaintingChkBox;

	$cmd = ($artCommand + " -q -brushfeedback " + `currentCtx`);
	checkBoxGrp -e -v1 `eval $cmd` artBrushFeedbackChkBox;

	$cmd = ($artCommand + " -q -showactive " + `currentCtx`);
	checkBoxGrp -e -v1 `eval $cmd` artShowActiveLinesChkBox;

	// CPV and Color Feedback are mutually exclusive.
	if ( isArtColorPerVertexCtx() )
	{
		// Support for color per vertex color clamping

		// Keep the enable settings consistent with all controls from the BEGINNING
		//
		$cmd = ($artCommand + " -q -vertexColorRange " + `currentCtx` );
		int $vertexColorRangeEnabled = eval($cmd);
		checkBoxGrp -e -v1 `optionVar -query polyAutoShowColorPerVertex` artAutoShowColorChkBox;
		checkBoxGrp -e -v1 $vertexColorRangeEnabled artVertexColorRangeChkBox;
		floatSliderGrp -e -enable $vertexColorRangeEnabled artVertexColorMinSlider;
		floatSliderGrp -e -enable $vertexColorRangeEnabled artVertexColorMaxSlider;

		$cmd = ($artCommand + " -q -vertexColorRangeLower " + `currentCtx` );
		floatSliderGrp -e -v `eval $cmd` artVertexColorMinSlider;
		
		$cmd = ($artCommand + " -q -vertexColorRangeUpper " + `currentCtx` );
		floatSliderGrp -e -v `eval $cmd` artVertexColorMaxSlider;
	}
	else if ( isArtColorFeedbackCtx() ) {
		// Support for color feedback
		$cmd = ($artCommand + " -q -colorfeedback " + `currentCtx` );
		checkBoxGrp -e -v1 `eval $cmd` artColorFeedbackChkBox;
		
		if( isArtSkinCtx() ) {
		    $cmd = ($artCommand + " -q -colorfeedbackOverride " + `currentCtx` );
		    int $colFeedback = `eval $cmd`;
		    checkBoxGrp -e -v1 $colFeedback artMultiColorFeedbackChkBox;
		    
		    $cmd = ($artCommand + " -q -xrayJoints " + `currentCtx` );
		    int $xrayJoints = `eval $cmd`;
		    checkBoxGrp -e -v1 $xrayJoints artXrayJointsChkBox;		    		     		    
		}

		$cmd = ($artCommand + " -q -colorrangelower " + `currentCtx` );
		floatSliderGrp -e -v `eval $cmd` artColorFeedbackMinSlider;
		
		$cmd = ($artCommand + " -q -colorrangeupper " + `currentCtx` );
		floatSliderGrp -e -v `eval $cmd` artColorFeedbackMaxSlider;
	}
	else if ( $currTool == "artSetPaint" )
	{
		// Support for color feedback
		$cmd = ($artCommand + " -q -setcolorfeedback " + `currentCtx` );
		checkBoxGrp -e -v1 `eval $cmd` artColorFeedbackChkBox;

		// Support for Display Active vertices
		$cmd = ($artCommand + " -q -setdisplaycvs " + `currentCtx` );
		checkBoxGrp -e -v1 `eval $cmd` artDisplayActiveCVsChkBox;
	}
}

global proc int isOnlyNurbsSelected()
{
// Description:
// Returns true if ONLY Nurbs is selected
//
	int		$ion ; 

	string $surfaces[] = `ls -objectsOnly -dag -allPaths -geometry -sl` ;

	for ($i=0; $i<size($surfaces); $i++){
		if (`nodeType $surfaces[$i]` == "nurbsSurface")
		{
			$ion=true;
		}
		else
		{
			$ion=false;
			return($ion);	
		}
	}

	return($ion);
}

global proc updateUandVSculptDirection(
string $jasperCommand
)
// 
// 	When polys are present, or we are in a mode that does not support
//	U/V/UVVector sculpt directions, grey out the U/V/UVVector directions
//	in sculpt tool 
//
{
	string $mode = eval($jasperCommand + " -q -mtm `currentCtx`");
	if ( isOnlyNurbsSelected()			&&
		 ($mode == "push" || $mode == "pull") ) {
		radioButtonGrp -e -enable true rv2Radio;
	}
	else {
		string $cmd1 = ($jasperCommand + " -q -refvector `currentCtx`");
		string $refvec = eval( $cmd1 );
		if ( ( $refvec == "visoparm" ) || ( $refvec == "uisoparm" ) ||
			 ( $refvec == "uvvector" ) ) {
			radioButtonGrp -e -sl 1 rv0Radio;
			eval( $jasperCommand + " -e -refvector \"normal\" `currentCtx`" );
		}
		radioButtonGrp -e -enable false rv2Radio;
		rowColumnLayout -e -vis false rvUVLayout;
	}
}
