// Copyright (C) 1997-2014 Autodesk, Inc., and/or its licensors.
// All rights reserved.
//
// The coded instructions, statements, computer programs, and/or related
// material (collectively the "Data") in these files contain unpublished
// information proprietary to Autodesk, Inc. ("Autodesk") and/or its licensors,
// which is protected by U.S. and Canadian federal copyright law and by
// international treaties.
//
// The Data is provided for use exclusively by You. You have the right to use,
// modify, and incorporate this Data into other products for purposes authorized 
// by the Autodesk software license agreement, without fee.
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND. AUTODESK
// DOES NOT MAKE AND HEREBY DISCLAIMS ANY EXPRESS OR IMPLIED WARRANTIES
// INCLUDING, BUT NOT LIMITED TO, THE WARRANTIES OF NON-INFRINGEMENT,
// MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE, OR ARISING FROM A COURSE 
// OF DEALING, USAGE, OR TRADE PRACTICE. IN NO EVENT WILL AUTODESK AND/OR ITS
// LICENSORS BE LIABLE FOR ANY LOST REVENUES, DATA, OR PROFITS, OR SPECIAL,
// DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES, EVEN IF AUTODESK AND/OR ITS
// LICENSORS HAS BEEN ADVISED OF THE POSSIBILITY OR PROBABILITY OF SUCH DAMAGES.

//
//
//  Creation Date:  Nov. 14, 1999
//
//  Description:
//      The smoothTangent() procedure smooths the tangent :-)
//
//  Input Arguments:
//      None.
//
//  Return Value:
//      None.
//

proc performSmoothTangentPreset( int $history,
								  int $whichDirection,
								  string $surfaces[],
								  string $results[] )
//
//	Description:
//		This proc takes the given surface isoparms and groups
//		them according to the surface, then executes an "smoothTangentSrf"
//		command on each surface.  eg. if the isoparms coming in are:
//			surface1.u[0.33] surface1.v[0.66] surface2.v[0.55]
//		this proc will execute these three commands:
//			smoothTangentSrf ... -d 1 -p 0.33 surface1;	// U direction
//			smoothTangentSrf ... -d 0 -p 0.33 -rpo 1 surface1;	// V direction
//			smoothTangentSrf ... -d 0 -p 0.55 surface2;	// V direction
//
// 		WARNING - assumes that the surfaces coming into this proc
// 		are isoparms, ie. they have the format:
//		<surfaceName>.u[<parameterValue>]
// 		or <surfaceName>.v[<parameterValue>]
//
//
//      whichDirection = 0 - whatever the selection is
//      whichDirection = 1 - if points selected, only smooth in U
//      whichDirection = 2 - if points selected, only smooth in V
{
	int $addOrComplement = true;
	int $multi = false;
	int $numKnots = 7;
	int $rpo = true;

	string $cmd = "smoothTangentSurface" + " -ch " + $history + 
		" -rpo " + $rpo + " ";

	string $smoothResults[];
	string $results[];

	// for each string returned from groupObjectsByName, put together
	// an insertKnotSurface cmd and execute it.
	//
	string $groupStrings[];
	$groupStrings = groupObjectsByName( $surfaces, "\\." );
	int $numStrings = size( $groupStrings );
	string $execCmd;

	for( $i = 0; $i < $numStrings; $i ++ ) {

		$execCmd = $cmd + " ";

		string $parms[];
		$numParms = `tokenize $groupStrings[$i] $parms`;
		string $foundUStr = `match "\\.u\\[" $groupStrings[$i]`;
		string $foundVStr = `match "\\.v\\[" $groupStrings[$i]`;
		string $foundUVStr = `match "\\.uv\\[" $groupStrings[$i]`;
		int $foundU = (size($foundUStr) > 0);
		int $foundV = (size($foundVStr) > 0);
		int $foundUV = (size($foundUVStr) > 0);

		if( $numParms > 1 || $foundUV ) {

			// Get the surface name
			//
			string $surfaceName[];
			tokenize $groupStrings[$i] "\\." $surfaceName;

			int $doneSome = false;

			// Format the parameter values with "-p" flag
			// Direction is set with "-d 1" flag
			//
			if( $foundU > 0 ||
				($foundUV > 0 && ((0 == $whichDirection) ||
								  (1 == $whichDirection)))) {
				$execCmd += " -d 1 ";

				$doneSome = true;

				int $p;
				for( $p = 0; $p < $numParms; $p ++ ) {
					string $regularExpr = "\\.u\\[.*\\]";
					string $parm = match($regularExpr, $parms[$p]);
					$strLen = size($parm);
					if( $strLen > 0 ) {

						// we could have an isoparam like .u[][a:b]
                        // so, we also do a tokenize filtering only the .u[]
                        // portion out.
						//
                        string $ucomp[] ;
                        int $nc ;
                        $nc = `tokenize $parm "]" $ucomp` ;
                        if( size($ucomp) > 0 )  {
	                        $parm = substring( $ucomp[0], 4, $strLen-1 );
   	                    	// append to $execCmd as a -p flag
							//
                        	$execCmd += " -p ";
                        	$execCmd += $parm;
                        }

					} else {
						string $regularExpr = "\\.uv\\[.*\\]\\[.*\\]";
						string $parm = match($regularExpr, $parms[$p]);
						$strLen = size($parm);
						if( $strLen > 0 ) {

							// change ".uv[0.444][0.66]" to ".uv[0.44"
							$parm = substitute( "\\]\\[.*\\]", $parm, "" );

							$strLen = size($parm);
							$parm = substring( $parm, 5, $strLen );
							$execCmd += " -p ";
							$execCmd += $parm;
						}
					}
				}

				// Add the surface name
				//
				$execCmd += " ";
				$execCmd += $surfaceName[0];

				// If V direction is also specified, then execute 
				// the U direction insert cmd right here
				//
				if( ($foundV > 0 || $foundUV > 0) ) {

					// Insert command returns the new surface and surface node.
					// Substitute the new surface as the surface name so if
					// inserting in the V direction too, it will be 
					// chained in sequence.
					// Also, copy the results for this insert commadn to
					// the results array.
					//
					string $tempResults[];
					$tempResults = evalEcho( $execCmd );
					int $numTempResults = size( $tempResults );
					if( $numTempResults == 2) {
						$surfaceName[0] = $tempResults[0];
						int $numResults = size( $results );
						for( $j = 0; $j < $numTempResults; $j ++, 
							$numResults ++ ) {
							$results[$numResults] = $tempResults[$j];
						}
					}
				}
			}

			if( $foundV > 0 ||
				($foundUV > 0 && ((0 == $whichDirection) ||
								  (2 == $whichDirection)))) {

				// If U direction was already executed, then make sure
				// we do "-rpo 1".  Otherwise, just set the direction.
				//
				if( ($history > 0) && $doneSome ) {
					$execCmd = "insertKnotSurface" + " -ch " + $history +
							" -rpo 1 -d 0 ";
				} else {
					$execCmd = $cmd + " -d 0 ";
				}

				int $p;
				for( $p = 0; $p < $numParms; $p ++ ) {
					string $regularExpr = "\\.v\\[.*\\]";
					string $parm = match($regularExpr, $parms[$p]);
					$strLen = size($parm);
					if( $strLen > 0 ) {

						// we could have an isoparam like .v[][a:b]
                        // so, we also do a tokenize filtering only the .v[]
                        // portion out. 
						//
                        string $vcomp[] ;
                        int $nc ;
                        $nc = `tokenize $parm "]" $vcomp` ;
                        if( size($vcomp) > 0 ) {
                            $parm = substring( $vcomp[0], 4, $strLen-1 );
                            // append to $execCmd as a -p flag
                            $execCmd += " -p ";
                            $execCmd += $parm;
						}

					} else {
						string $regularExpr = "\\.uv\\[.*\\]\\[.*\\]";
						string $parm = match($regularExpr, $parms[$p]);
						$strLen = size($parm);
						if( $strLen > 0 ) {

							// change ".uv[0.444][0.66]" to "0.66]"
							$parm = substitute( "\\.uv\\[.*\\]\\[",$parm,"");

							$strLen = size($parm);
							$parm = substring( $parm, 1, $strLen-1 );
							$execCmd += " -p ";
							$execCmd += $parm;
						}
					}
				}
				// Add the surface name
				//
				$execCmd += " ";
				$execCmd += $surfaceName[0];
			}

		}
		else {
			$execCmd += $groupStrings[$i];
		}

		// execute $cmd + $groupStrings[$i]	
		if( catch( $smoothResults = evalEcho( $execCmd))) {
			warning(`format -s $cmd -s $groupStrings[$i] (uiRes("m_smoothTangent.kWarningSmoothTangentFailed"))` );
		}
		else {
			int $j;
			int $numResults = size( $results );
			int $numsmoothResults = size( $smoothResults );
			for( $j = 0; $j < $numsmoothResults; $j ++, $numResults ++ ) {
				$results[$numResults] = $smoothResults[$j];
			}
		}
	}

	if( 0 == size($results) ) {
        error (uiRes("m_smoothTangent.kSmoothTangentFailed"));
	}
}

global proc smoothTangent()
{
    int $doHistory = `constructionHistory -q -tgl`;
	int $doHilite = false;

	// Get a list of each type of acceptable object type - surfaces and curves.
	//
	global int $gSelectSurfaceParmPointsBit;
	global int $gSelectEditPointsBit;
	global int $gSelectIsoparmsBit;

	string $surfaceIsoparmList[] = `filterExpand -ex true -sm $gSelectIsoparmsBit -sm $gSelectSurfaceParmPointsBit`;

	if( 0 == size($surfaceIsoparmList) ) {
		error (uiRes("m_smoothTangent.kSmoothTangentInvalSelection"));
		return;
	}

	string $curr = `currentCtx`;
	int $whichDirection = 0;
	if( `curveEditorCtx -exists $curr` ) {
		$whichDirection = `curveEditorCtx -q -dir $curr`;
	}


	string $surfaceResults[]; // 
	if( size($surfaceIsoparmList) > 0 ) {
		if( !$doHilite ) $doHilite = `shouldHiliteAfterCompute`;
		performSmoothTangentPreset( $doHistory, $whichDirection,
									$surfaceIsoparmList, $surfaceResults );
	}

	if( size($surfaceResults) == 0 ) {
		error (uiRes("m_smoothTangent.kSmoothTangentImproperSelection"));
	}
	else {
		// Select all the results with one select command.  
		//
		string $selectString;
		$selectString = "select -r ";
		int $i;

		int $numSurfaces = size($surfaceIsoparmList);
		for( $i = 0; $i < $numSurfaces; $i ++ ) {
			$selectString += $surfaceIsoparmList[$i];
			$selectString += " ";
		}
		$selectString += ";";
		if( $doHilite ) $selectString += "hilite;";

		eval($selectString);
	}
}

