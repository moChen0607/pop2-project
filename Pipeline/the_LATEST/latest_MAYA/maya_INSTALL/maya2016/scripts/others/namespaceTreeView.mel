// Copyright (C) 1997-2014 Autodesk, Inc., and/or its licensors.
// All rights reserved.
//
// The coded instructions, statements, computer programs, and/or related
// material (collectively the "Data") in these files contain unpublished
// information proprietary to Autodesk, Inc. ("Autodesk") and/or its licensors,
// which is protected by U.S. and Canadian federal copyright law and by
// international treaties.
//
// The Data is provided for use exclusively by You. You have the right to use,
// modify, and incorporate this Data into other products for purposes authorized 
// by the Autodesk software license agreement, without fee.
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND. AUTODESK
// DOES NOT MAKE AND HEREBY DISCLAIMS ANY EXPRESS OR IMPLIED WARRANTIES
// INCLUDING, BUT NOT LIMITED TO, THE WARRANTIES OF NON-INFRINGEMENT,
// MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE, OR ARISING FROM A COURSE 
// OF DEALING, USAGE, OR TRADE PRACTICE. IN NO EVENT WILL AUTODESK AND/OR ITS
// LICENSORS BE LIABLE FOR ANY LOST REVENUES, DATA, OR PROFITS, OR SPECIAL,
// DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES, EVEN IF AUTODESK AND/OR ITS
// LICENSORS HAS BEEN ADVISED OF THE POSSIBILITY OR PROBABILITY OF SUCH DAMAGES.

global string $gRegisteredTreeViewNames[];
global int $gRegisteredTreeViewModes[];

proc int addNamespaceTreeView(string $treeViewControl, int $mode)
//	Description:
//		Add treeView control to register list of $gRegisteredTreeViewNames[] && $gRegisteredTreeViewModes[]
{
		int $addIndex = -1; 
		global string $gRegisteredTreeViewNames[];
		global int $gRegisteredTreeViewModes[];
		int $count = size($gRegisteredTreeViewNames);
		int $i = 0;
		
		//If the treeView already exists, just update the type.
		//
		while( $i < $count )
		{
			if( $gRegisteredTreeViewNames[$i] == $treeViewControl)
			{
				$addIndex =  $i;
				break;
			}
			$i++;
		}

		if($addIndex < 0)
		{
			$addIndex = $count;
			$gRegisteredTreeViewNames[$addIndex] = $treeViewControl;
		}
		$gRegisteredTreeViewModes[$addIndex] = $mode;
		return $addIndex;
}

proc int getNamespaceTreeViewMode(string $treeViewControl)
//	Return 
//		If  $treeViewControl does not exist , return -1. 
//		else return the index.
//
{
	global string $gRegisteredTreeViewNames[];
	global int $gRegisteredTreeViewModes[];
	int $count = size($gRegisteredTreeViewNames);
	int $i = 0;
	while( $i < $count )
	{
		if( $gRegisteredTreeViewNames[$i] == $treeViewControl)
		{
			return $gRegisteredTreeViewModes[$i];
		}
		$i++;
	}
	return -1;
}

proc int isNamespaceTreeView(string $control, int $giveErrorMsg)
//	Return
//		false, not a namespaceTreeView
//		true  , is a namespaceTreeView;
{
	global string $gRegisteredTreeViewNames[];
	int $count = size($gRegisteredTreeViewNames);
	int $i = 0;
	while( $i < $count )
	{
		if( $gRegisteredTreeViewNames[$i] == $control && `treeView -exists $control`)
		{
			return true;
		}
		$i++;
	}

	if($giveErrorMsg)
	{
		error (uiRes("m_namespaceTreeView.kNamespaceTreeViewInvalidName"));
	}
	return false;
}


global proc string namespaceTreeView(int $mode, string $doubleClickCallback, string $selectionChangedCallback)
//  Procedure Name:
//		namespaceTreeView
//
//  Description:
//		Construct a namespaceTreeView with namespace treeView style and namespace information.
//		Verify the treeView exists and register it.
//		
//  Input Arguments:
//		$mode , 
//					0 for "read only", which means the treeView can only read namespace info 
//					1 for "read write", which means it can edit namespace info such as, delete, rename and set current.
//		$doubleClickCallback
//					double click callback, just used in "read write" mode
//		$selectionChangedCallback
//					selection changed callback
//  Return Value:
//      Return the the newly created treeView control name.
//
{

	string $name ;
	// Set multi selection off in read-only mode
	int $allowMultiSelection = $mode;
	$name = `treeView -numberOfButtons 1 -attachButtonRight true -flatButton 1 -allowDragAndDrop false -allowMultiSelection $allowMultiSelection`;

	addNamespaceTreeView( $name, $mode);

	if($mode == 0)
	{
		treeView -edit -itemDblClickCommand "namespaceTreeView_ReadOnlyDoubleClick" $name;
	}
	else if(size($doubleClickCallback))
	{
		treeView -edit -itemDblClickCommand $doubleClickCallback $name;
	}

	if(size($selectionChangedCallback))
	{
		treeView -edit -selectionChangedCommand $selectionChangedCallback $name;
	}
	return $name;
}


global proc namespaceTreeView_update(string $control, string $updateCallback)
//
//	Description:
//		fill namespace treeView by results of command namespaceInfo.
// Params:
//		$control, the name of the namespace TreeView
//		$updateCallback to update caller's status such as selecting status
{
	//Skip if not a valid namespaceTreeView
	if( !isNamespaceTreeView($control, true) )
	{
		return;
	}

	string $allNamespaces[] = `namespaceInfo -recurse -listOnlyNamespaces -absoluteName ":"`;
	

	//fill treeview content
	//
	if (`size $allNamespaces`)
	{
		float $namespaceTreeViewSelectColor[] = {0.255, 0.302, 0.353};
		treeView -edit -removeAll $control;
		string $rootNSitem =  ":"; 
		treeView -edit -addItem $rootNSitem "" $control;
		treeView -edit 
				-enableButton $rootNSitem 1 0 
				-buttonVisible   $rootNSitem 1 0 
				-ignoreButtonClick $rootNSitem 1 1
				-buttonErase $rootNSitem false
				-displayLabel $rootNSitem ":(root)"  
				//
				//TODO: Instead of hardcode color value here, we need a default color set to select from, 
				//
				-selectionColor $rootNSitem $namespaceTreeViewSelectColor[0]  $namespaceTreeViewSelectColor[1] $namespaceTreeViewSelectColor[2]
			$control;

		//Add item
		//
		string $curFullNS; 
		string $parentNS ;
		string $curHierarchyList[];
		for( $namespace in $allNamespaces )
		{
			if (isInternalNamespace($namespace))
			{
				// skip the default namespaces which cannot be manipulated
				//
				continue;
			}

			//loop the namespace and all parent, if not exist in treeView, add item
			$curHierarchyList = stringToStringArray($namespace, ":");
			int $sizeOfList = size($curHierarchyList);//const size for avoid "size" function every loop.
			int $i;
			for($i=0; $i<$sizeOfList; $i++)
			{
				if($i==0)
				//first element's parent is root
				{
					$parentNS = $rootNSitem;	
					$curFullNS = ":" + $curHierarchyList[$i];
				}
				else
				{
					$parentNS = $curFullNS;
					$curFullNS = $curFullNS + ":"+$curHierarchyList[$i];
				}

				if(!`treeView -q -itemExists $curFullNS $control`)
				{
					treeView -edit -addItem  $curFullNS $parentNS $control;
					treeView -edit -displayLabel $curFullNS $curHierarchyList[$i]  
								-enableButton $curFullNS 1 0 	-buttonVisible   $curFullNS 1 0
								-ignoreButtonClick $curFullNS 1 1
								-buttonErase $curFullNS false
								//
								//TODO: Instead of hardcode color value here, we need a default color set to select from, 
								//
								-selectionColor $curFullNS $namespaceTreeViewSelectColor[0]  $namespaceTreeViewSelectColor[1] $namespaceTreeViewSelectColor[2]
							$control;
				}
			}

			$curFullNS = "";
			$parentNS = "";
			clear $curHierarchyList;
		}
	}

	string $currentNamespace = `namespaceInfo -currentNamespace -absoluteName`;
	//Set current namespace and update the indicator
	//
	if(`treeView -q -itemExists $currentNamespace $control`)
	{
		treeView -edit   
				-buttonVisible $currentNamespace 1 1
				-enableButton $currentNamespace 1 1
				-buttonTransparencyColor $currentNamespace 1 0.18 0.18 0.18 
				-ignoreButtonClick $currentNamespace 1 1
				-buttonErase $currentNamespace false
				-image $currentNamespace 1 "currentNamespace.png"
				-buttonTooltip $currentNamespace 1 (uiRes("m_namespaceTreeView.kNamespaceEditorTipCurrentNS")) 
			$control;
	
		//Display all the parents of  current namspace's indicator button.
		string $parentItem = `treeView -q -itemParent $currentNamespace $control`;
		while(size($parentItem) && $parentItem != ":" )
		{
			treeView -edit   
					-buttonVisible   $parentItem 1 1
					-buttonTooltip $parentItem 1 (uiRes("m_namespaceTreeView.kNamespaceEditorTipCurrentNSParent")) 
					-buttonTransparencyColor $parentItem 1 0.18 0.18 0.18 
					-image $parentItem 1 "currentNamespaceParent.png"
					-ignoreButtonClick $parentItem 1 1
					-buttonErase $parentItem false
				$control;
			$parentItem = `treeView -q -itemParent $parentItem $control`;
		}
	}

	if(size($updateCallback))
	{
		eval($updateCallback + " " +$control);
	}
}

global proc string namespaceTreeView_rename(string $oldName, string $newName, string $treeViewName, string $renameCallback)
{
	if( isNamespaceTreeView($treeViewName, false) && ($oldName != $newName))
	{
		//Read Only namespace treeView is unrenamable
		if( !getNamespaceTreeViewMode($treeViewName) )
		{
			error (uiRes("m_namespaceTreeView.kReadOnlyNSTreeViewRenameWarning"));
			return "";
		}

		string $selectedNamespace[] = `treeView -q -si $treeViewName`;
		int		 $sizeOfSelect = size($selectedNamespace);
		
		string $ok = (uiRes("m_namespaceTreeView.kNamespaceEditorCannotRenameOK")) ;
		string $errMsg;
		if (containsMultibyte($newName))
		{
			$errMsg = (uiRes("m_namespaceTreeView.kNoMultibyteBaseNamespace"));
		}
		else	if( !isValidString($newName, "([a-zA-Z]+)([a-zA-Z0-9_])*") )
		//If valid namespace? 
		{
			$errMsg = (uiRes("m_namespaceTreeView.kInvalidCharNamespace"));
		}
		else if( $selectedNamespace[0] == ":" )
		{
			$errMsg = (uiRes("m_namespaceTreeView.kCannotRenameRoot"));
		}				
		else if( $sizeOfSelect >1 )
		{
			$errMsg = (uiRes("m_namespaceTreeView.kCannotMultiRename"));
		}		
		// success and do rename
		else
		{	
			//Do rename none root namespace
			//Only handle the first select and return if there is no item selected
			if( size($selectedNamespace[0])>0 )
			{
				// absolute name is the namespace start with ":"
				string $lastNamespace = `namespaceInfo -currentNamespace -absoluteName`;

				namespace -setNamespace $selectedNamespace[0];
				string $parentNamespace = `namespaceInfo -parent -absoluteName`;


				//Find if current namespace is selectedNamespace's offsprint, if yes, we need change current namespace when we set it back
				int $currentIsSelectedOffspring = 0;
				string $currentRelativeToSelected;
				if(size($selectedNamespace[0]) <= size($lastNamespace))
				{
					$currentIsSelectedOffspring = ($selectedNamespace[0] == startString($lastNamespace, size($selectedNamespace[0])));
					if( $currentIsSelectedOffspring )
					{
						$currentRelativeToSelected = endString($lastNamespace, size($lastNamespace) - size($selectedNamespace[0]));
					}
				}
				
				namespace -setNamespace $parentNamespace;
				// bug 376772
				// namespace editor should check the command result 
				// and display error message in dialog to user
				// because user does not often open the script editor, without 
				// dialog, they will miss the error message and do not 
				// know the reason of procedure breaking. 	
				if (catch (`namespace -rename $oldName $newName`)) {
					// there're some error in the command
					// show a dialog to user, let them check ther 
					// script editor
	      				$errMsg = (uiRes("m_namespaceTreeView.kCannotRename"));
	      			}		
		
				// reset the current namespace
				if($currentIsSelectedOffspring)
				{
					namespace -setNamespace ($newName + $currentRelativeToSelected);
				}
				else
				{
					namespace -setNamespace $lastNamespace;
				}
			}
			if(size($renameCallback))
			{
				eval($renameCallback);
			}
			
		}
		
		//Give warning when it is a invald rename
		if( size($errMsg )>0)
		{
			string $ok     = (uiRes("m_namespaceTreeView.kRenameOK")) ;
			string $cancel = (uiRes("m_namespaceTreeView.kRenameCancel"));
			confirmDialog -title (uiRes("m_namespaceTreeView.kRenameTitle")) 
					-message $errMsg
					-button $ok
					-defaultButton $ok
					-cancelButton $ok 
					-dismissString $ok;
		}	
	}

	//Since we change the item name and label respectively, 
	//so here we return "" in case of the default labal and item name changing rule.
	return "";
}

global proc namespaceTreeView_select(string $control, string $selSets[])
{
	//Skip if not a valid namespaceTreeView
	if( !isNamespaceTreeView($control, true) )
	{
		return;
	}

	int $mode = getNamespaceTreeViewMode($control);
	if( $mode >=0 && `treeView -exists $control`)
	{
		treeView -edit -clearSelection $control;
		for($i = 0; $i<size($selSets); $i++)
		{
			if(`treeView -q -itemExists $selSets[$i] $control`)
			{
				treeView -edit -selectItem $selSets[$i] true $control;
			}
		}
	}
}

global proc int isInternalNamespace(string $namespace) 
//	Description
//		Query if a name is a internal namespace which is not shown to user.
//	Return Value:
//		1 if is internal, 0 is not
//
{
	int $result = 0;
	$result =  ($namespace == ":shared" || $namespace == ":UI");
	return $result	;
}

global proc  namespaceTreeView_ReadOnlyDoubleClick(string $itemName)
//	Description 
//		Just prevent namespace treeView item's label being edited
//
{

}

global proc string[] namespaceTreeView_getSelectedItems(string $treeViewName)
{
	string $ret[];
	//Skip if not a valid namespaceTreeView
	if( !isNamespaceTreeView($treeViewName, true) )
	{
		return $ret;
	}

	$ret = `treeView -q -si $treeViewName`;

	return $ret;
}

