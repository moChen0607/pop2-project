// Copyright (C) 1997-2014 Autodesk, Inc., and/or its licensors.
// All rights reserved.
//
// The coded instructions, statements, computer programs, and/or related
// material (collectively the "Data") in these files contain unpublished
// information proprietary to Autodesk, Inc. ("Autodesk") and/or its licensors,
// which is protected by U.S. and Canadian federal copyright law and by
// international treaties.
//
// The Data is provided for use exclusively by You. You have the right to use,
// modify, and incorporate this Data into other products for purposes authorized 
// by the Autodesk software license agreement, without fee.
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND. AUTODESK
// DOES NOT MAKE AND HEREBY DISCLAIMS ANY EXPRESS OR IMPLIED WARRANTIES
// INCLUDING, BUT NOT LIMITED TO, THE WARRANTIES OF NON-INFRINGEMENT,
// MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE, OR ARISING FROM A COURSE 
// OF DEALING, USAGE, OR TRADE PRACTICE. IN NO EVENT WILL AUTODESK AND/OR ITS
// LICENSORS BE LIABLE FOR ANY LOST REVENUES, DATA, OR PROFITS, OR SPECIAL,
// DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES, EVEN IF AUTODESK AND/OR ITS
// LICENSORS HAS BEEN ADVISED OF THE POSSIBILITY OR PROBABILITY OF SUCH DAMAGES.

/*
global proc int isLastMenuInAllMenuSets(string $curMenuSet) {
	int $numMenuSets = 0;
	// this checks for number of valid menus (may be different than number of menus in menuSet);
	int $visibleMenuSets = 0;
	int $visibleMenusInCurrentMenuSet = 0;
	int $i = 0, $j = 0;
	string $menuSets[] = `menuSet -q -allMenuSets`;
	for ($i = 0; $i < size($menuSets); $i++) {
		string $setMenus[] = `menuSet -q -menuArray $curMenuSet`;			
		for ($j = 0; $j < size($setMenus); $j++) {
			if (`menu -q -exists $setMenus[$i]`) {
				$visibleMenuSets++;
				break;
			}
		}	
	}	

	if ($visibleMenuSets == 0) {
		return 1;
	}else if ($visibleMenuSets == 1) {
		string $setMenus[] = `menuSet -q -menuArray $curMenuSet`;			
		for ($j = 0; $j < size($setMenus); $j++) {
			if (`menu -q -exists $setMenus[$i]`) {
				$visibleMenusInCurrentMenuSet++;
			}
		}
		return ($visibleMenusInCurrentMenuSet > 0);
	}
	return 0;
}
*/


proc int isAlphaNumericName(string $name)
//
//	Description:
//		Determine if the given string is potentially a valid name.
//		Note that this procedure does not test to see if the name is
//		unique, it just tests the string characters.
//
//      Check to ensure that the string does not begin with a number and
//      is followed only by alphanumeric characters, underscores, and
//      semi-colons (used for namespace).
//
//	Arguments:
//		$name - The name.
//
//	Returns:
//		True if the name is valid, false otherwise.
//
{
	int $result = false;

	if ("" != $name) {
		//
		//	Begins with letter or underscore, followed by
		//	letters, digits, or underscores.
		//
        string $regExpr = "([:a-zA-Z_]+)([[:a-zA-Z0-9_ -])*";
		string $temp = match($regExpr, $name);
		if ($temp == $name) {
			$result = true;
		}
	}

	return $result;
}

proc int checkNameValidity(int $asConfirmDialog, string $name)
//
//	Description:
//		Determines whether we should continue with any change given 
//		a menuSet name which may or may not be valid.
//
//      This function will display an error if the name is either empty,
//      contains only whitespace, has non-alphanumeric characters, or is 
//      not unique. 
//
//	Arguments:
//		$asConfirmDialog - Whether to display the warning message as a confirmation
//							dialog, or as a MEL warning.
//		$name - The name of the menuSet.
//
//	Returns:
//		True if the name is valid, false otherwise.
//
{	
	string $strippedName = `strip $name`;
	int $commitChange = 1;
	string $cancelLabel = (uiRes("m_menuSetEditor.kCheckNameCancel")); 
	string $createLabel = (uiRes("m_menuSetEditor.kCheckNameCreate")); 
	string $warningLabel = (uiRes("m_menuSetEditor.kCheckNameWarning")); 
	string $okLabel = (uiRes("m_menuSetEditor.kCheckNameOK"));
	string $theName = (uiRes("m_menuSetEditor.kCheckNameTheName"));	

	// ensure that name is not empty
	if (size($strippedName) == 0) {
		$commitChange = 0;
		string $whitespaceInvalid = (uiRes("m_menuSetEditor.kCheckNameWhitespaceInvalidName"));
		if ($asConfirmDialog) {
			confirmDialog
					-title $warningLabel
					-button        $okLabel
					-defaultButton $okLabel
					-message (	$theName + 
								$name + 
								$whitespaceInvalid );
		}else {
			warning (	$theName + 
						$name + 
						$whitespaceInvalid );
		}
	}else if (size($strippedName) > 32) {
		// ensure that the name < 32 characteres
		$commitChange = 0;
		string $sizeInvalid = (uiRes("m_menuSetEditor.kInvalidSizeOfName"));
		if ($asConfirmDialog) {
			confirmDialog
					-title $warningLabel
					-button        $okLabel
					-defaultButton $okLabel
					-message (	$theName + 
								$name + 
								$sizeInvalid );
		}else {
			warning (	$theName + 
						$name + 
						$sizeInvalid );
		}
	}else {				
		// check if a menuSet exists with that name already
		if (`findMenuSetFromLabel $name` != "") {
			$commitChange = 0;
			string $aMenuSet = (uiRes("m_menuSetEditor.kNewAName"));
			string $nonUniqueInvalid = (uiRes("m_menuSetEditor.kNewNonUniqueInvalidName"));
			if ($asConfirmDialog) {
				confirmDialog
					-title $warningLabel
					-button        $okLabel
					-defaultButton $okLabel
					-message (	$aMenuSet + $name + $nonUniqueInvalid );
			}else {
				warning (	$aMenuSet + $name + $nonUniqueInvalid );
			}

		// check if the name is alpha numeric only (odd symbols not allowed)
        }else if (!isAlphaNumericName($name)) {			
			$commitChange = 0;
			string $nonAlphanumericInvalid = (uiRes("m_menuSetEditor.kNewNonAlphanumericInvalidName"));
			if ($asConfirmDialog) {
				confirmDialog
					-title $warningLabel
					-button        $okLabel
					-defaultButton $okLabel
					-message (	$theName + 
								$name + 
								$nonAlphanumericInvalid );
			}else {
				warning (	$theName + 
							$name + 
							$nonAlphanumericInvalid );
			}
		}
	}

	return $commitChange;
}



global proc buildMenuSetsEditorContextHelpItems(string $nameRoot, string $menuParent)
//
//  Description:
//		Build context sensitive menu items for the menu set editor.  
//		
//  Input Arguments:
//		$nameRoot - name to use as the root of all item names
//		$menuParent - the name of the parent of this menu
//
//  Return Value:
//      None
//
{
	menuItem 
		-label (uiRes("m_menuSetEditor.kHelpOnMenuSetsEditor"))
		-annotation (uiRes("m_menuSetEditor.kHelpOnMenuSetsEditorAnn"))
		-enableCommandRepeat false
		-command "showHelp MenuSetsEditor";
}

global proc updateCurrentWorkingMode()
{
	string $selected[] = `iconTextScrollList -query -selectItem tslMenuSets`;
	int $enable = (size($selected) != 0);

	if ($enable) {
		// set menu mode to it if there exists at least one visible menu in the set
		int $i = 0;
		string $menuSet = `findMenuSetFromLabel $selected[0]`;
		if (size($menuSet) > 0) {
			string $setMenus[] = `menuSet -q -menuArray $menuSet`;
			for ($i = 0; $i < size($setMenus); $i++) {
				if (`menu -q -exists $setMenus[$i]`) {			
					workingMode $menuSet;
					break;
				}
			}
		}
	}
}

global proc revertToDefaultMenuSets() 
{
	buildDefaultMenuSets("");
	rebuildMenuSetsList(); 
	rebuildMenusList();
}

global proc updateMenuSetsMenuItems()
{
	string $selected[] = `iconTextScrollList -query -selectItem tslMenuSets`;
	int $enable = (size($selected) != 0);
	string $set = ($enable ? `findMenuSetFromLabel $selected[0]` : "");
	
	menuItem -edit -enable $enable menuBarRenameMenuSet;
	menuItem -edit -enable $enable menuBarRemoveMenuSet;
	menuItem -edit -enable $enable tslMenuSetsRenameMenuSet;
	menuItem -edit -enable $enable tslMenuSetsRemoveMenuSet;
	// Do not allow removing of permanent menu set
	if(`menuSet -q -permanent $set`) {
		menuItem -edit -enable false tslMenuSetsRemoveMenuSet;
	}

	string $command = "buildDefaultMenuSets(\"\");";
	string $label = (uiRes("m_menuSetEditor.kSelectedMenuSetRevertLbl"));
	string $annotation = (uiRes("m_menuSetEditor.kSelectedMenuSetRevertAnn"));

	int $validSet = 1;
	if (`menuSet -q -exists $set`) {
		buildDefaultMenuSets($set);
	} else {		
		$validSet = 0;
	}

	if (size($selected) > 0) {
		$label =	(uiRes("m_menuSetEditor.kRevertSp")) + 
					$selected[0] + 
					(uiRes("m_menuSetEditor.kSpToDefault"));
		$annotation = $label;
	}

	if ($validSet) {		
		$command += " rebuildMenuSetsList(); rebuildMenusList();";
		menuItem -edit -enable true -label $label -command $command menuBarRevertMenuSet;
		menuItem -edit -enable true -label $label -command $command tslMenuSetsRevertMenuSet;

		updateMenuModeUI;
	}else {
		// disable the menu if it is not a defaultable set, or if no set is selected
		menuItem -edit -enable false -label $label menuBarRevertMenuSet;
		menuItem -edit -enable false -label $label tslMenuSetsRevertMenuSet;
	}
}

global proc updateMenusMenuItems()
{
	string $selected[] = `iconTextScrollList -query -selectItem tslMenus`;
	int $enable = (size($selected) != 0);
	
	menuItem -edit -enable $enable tslMenusRemoveMenus;

	updateMenuModeUI;
}

global proc updateAllMenusMenuItems()
{
	string $selected[] = `iconTextScrollList -query -selectItem tslAllMenus`;
	int $enable = (size($selected) != 0);
	
	menuItem -edit -enable $enable tslAllMenusAddMenus;

	updateMenuModeUI;
}

global proc createNewMenuSet()
{
	string $promptMessage = (uiRes("m_menuSetEditor.kNewEnterName"));
	string $createLabel = (uiRes("m_menuSetEditor.kNewCreate")); 
	string $cancelLabel = (uiRes("m_menuSetEditor.kNewCancel"));
	string $result = "";
	
	while ($result != $cancelLabel) {

		// Bring up the prompt dialog so user can specify the name
		$result = `promptDialog 
				-title (uiRes("m_menuSetEditor.kNewCreateNewMenuSet"))
				-message $promptMessage
				-button $createLabel -button $cancelLabel
				-defaultButton $createLabel -cancelButton $cancelLabel
				-dismissString $cancelLabel`;

		if ($result == $createLabel) {
			string $name = `promptDialog -query -text`;			
			int $commitChange = checkNameValidity(1, $name);
			
			if ($commitChange) {
				// create new menuSet with given label
				string $newSet = `menuSet`;
				menuSet -edit -label $name $newSet;

				rebuildMenuSetsList();
				// Select new menu set in the menu sets list
				iconTextScrollList -edit -deselectAll tslMenuSets;
				iconTextScrollList -edit -selectItem $name tslMenuSets;
				// Force update other two lists
				rebuildMenusList();
				break;
			}
		}
	}
}

global proc changeMenuSetName()
{
	// This proc is called when value of list entry was edited
	string $selected[] = `iconTextScrollList -query -selectItem tslMenuSets`;
	string $name = $selected[0];
	
	// if nothing is selected, no need to proceed
	if($name == "")
		return;
		
	int $index[] = `iconTextScrollList -query -selectIndexedItem tslMenuSets`;
	string $menuSets[] = `menuSet -query -allMenuSets`;
	string $menuSet = $menuSets[$index[0]-1];

	int $commitChange = checkNameValidity(0, $name);
	
	if ($commitChange) {
		menuSet -edit -label $name $menuSet;
	}

	rebuildMenuSetsList();
	updateMenuModeUI;
}

global proc renameSelectedMenuSet()
{
	string $selected[] = `iconTextScrollList -query -selectItem tslMenuSets`;
	string $menuSet = `findMenuSetFromLabel($selected[0])`;
	string $promptMessage = (uiRes("m_menuSetEditor.kRenEnterNewName"));
	string $result = "";
	string $initialText = $selected[0];

	string $renameLabel = (uiRes("m_menuSetEditor.kRenCreate")); 
	string $cancelLabel = (uiRes("m_menuSetEditor.kRenCancel"));

	while ($result != $cancelLabel) {

		// Bring up confirm dialog
		$result = `promptDialog 
			-title (uiRes("m_menuSetEditor.kRenRenameMenuSet")) 
			-message $promptMessage
			-text $initialText
			-button $renameLabel -button $cancelLabel
			-defaultButton $renameLabel -cancelButton $cancelLabel
			-dismissString $cancelLabel`;

		if ($result == $renameLabel) {
			string $name = `promptDialog -query -text`;		

			int $commitChange = checkNameValidity(1, $name);
			
			if ($commitChange) {
				// Replace empty lable with new label
				menuSet -edit -label $name $menuSet;

				rebuildMenuSetsList();
				// Select new menu set in the menu sets list
				iconTextScrollList -edit -deselectAll tslMenuSets;
				iconTextScrollList -edit -selectItem $name tslMenuSets;
				rebuildMenusList();
				break;
			}
		}
	}
}

global proc removeSelectedMenuSet()
{
	string $selectedSets[] = `iconTextScrollList -query -selectItem tslMenuSets`;

	if (size($selectedSets) > 0) {
		string $removeLabel = (uiRes("m_menuSetEditor.kRemRemove")); 
		string $cancelLabel = (uiRes("m_menuSetEditor.kRemCancel")); 

		// Bring up confirm dialog
		string $reply = `confirmDialog 
				-title (uiRes("m_menuSetEditor.kRemRemoveMenuSet"))
				-message (uiRes("m_menuSetEditor.kRemRemoveMenuSetPrompt"))
				-button $removeLabel
				-button $cancelLabel
				-cancelButton $cancelLabel
				-defaultButton $removeLabel
				-dismissString $cancelLabel`;
		
		if($reply == $removeLabel) {		
			// Get selected menu sets		
			string $set;
			int $setIndex[] = `iconTextScrollList -q -selectIndexedItem tslMenuSets`;
			
			for($set in $selectedSets) {
				menuSet -removeMenuSet `findMenuSetFromLabel($set)`;
			}

			// Rebuild menu sets list (do this before we select the mode)
			rebuildMenuSetsList();		
			
			// select the previous menu set
			int $numRows = `iconTextScrollList -q -numberOfRows tslMenuSets`;
			if ($numRows > 0) {
				int $toSelect = `min ($setIndex[0]) ($numRows)`;
				iconTextScrollList -e -deselectAll -selectIndexedItem $toSelect tslMenuSets;
			}

			// now rebuild rest of the lists based on selected set?
			rebuildMenusList();
		}
	}
}

global proc removeMenusFromMenuSet()
{
	string $selectedMenuSet[] = `iconTextScrollList -query -selectItem tslMenuSets`;

	if (size($selectedMenuSet) > 0) {
		string $ms = findMenuSetFromLabel($selectedMenuSet[0]);
		string $selectedMenus[] = `iconTextScrollList -query -selectItem tslMenus`;	
		string $menu;
		for($menu in $selectedMenus) {	
			string $m = findMenuFromMenuSet($ms, $menu);		
			//if (!isLastMenuInAllMenuSets($ms)) {
				menuSet -removeMenu $m $ms;			
			//}else {
			//	warning "You must have at least one visible Menu Set with at least one visible Menu.";
			//}
		}

		// Update UI
		rebuildMenusList();	

		// select the new menus in the all menus column
		for ($menu in $selectedMenus) {
			iconTextScrollList -e -selectItem $menu tslAllMenus;
		}
		// and show them if they are hidden
		// int $selIndices[] = `iconTextScrollList -q -selectIndexedItem tslAllMenus`;
		// iconTextScrollList -e -showIndexedItem $selIndices[0] tslAllMenus;
	}
}

global proc addMenusToMenuSet()
{
	global string $gMainWindow;

	string $selectedMenuSet[] = `iconTextScrollList -query -selectItem tslMenuSets`;	
	string $selectedAllMenus[] = `iconTextScrollList -query -selectItem tslAllMenus`;	
	if (size($selectedMenuSet) > 0) {
		string $ms = findMenuSetFromLabel($selectedMenuSet[0]);
		string $menu;

		//Get all the menus under main menu bar
		string $menuBarMenus[] = `window -query -menuArray $gMainWindow`;

		for($menu in $selectedAllMenus) {
			string $m, $mbMenu;
			for($mbMenu in $menuBarMenus) {
				if($menu == `menu -query -label $mbMenu`) {
					$m = $mbMenu;
					break;
				}
			}
			menuSet -addMenu $m $ms;
		}
		// Update UI
		rebuildMenusList();

		// select the new menus in the menu column
		iconTextScrollList -e -deselectAll tslMenus;
		for ($menu in $selectedAllMenus) {
			iconTextScrollList -e -selectItem $menu tslMenus;
		}
		// and show them if they are hidden
        // int $selIndices[] = `iconTextScrollList -q -selectIndexedItem tslMenus`;
		// iconTextScrollList -e -showIndexedItem $selIndices[0] tslMenus;
	}	
}

global proc rebuildMenuSetsList()
{
	// Preserve selection
//	string $currentSelection[] = `iconTextScrollList -query -selectItem tslMenuSets`;
	
	iconTextScrollList -edit -removeAll tslMenuSets;

	// Populate menu sets list
	string $menuSets[] = `menuSet -allMenuSets`;

	string $item;
	for($item in $menuSets) {
		iconTextScrollList -edit -append `menuSet -query -label $item` tslMenuSets;
	}
	
	//Restore selection
//	for($item in $currentSelection) {
//		iconTextScrollList -edit -selectItem $item tslMenuSets;
//	}

	updateMenuModeUI;
}

global proc rebuildMenusList()
{
	global string $gMainWindow;
	// These are the main common menus which are shown only in the common menuSet
	string $commonMenus[] = {
		// These are menus that appear in menu bar by default
		"mainFileMenu",
		"mainEditMenu",
		"mainModifyMenu",
		"mainCreateMenu",
		"mainDisplayMenu",
		"mainWindowMenu"
	};
	// This is a list of menus that will not appear in All Menus list
	string $filterMenus[] = {
		// These are menus that appear in menu bar by default
		"mainFileMenu",
		"mainEditMenu",
		"mainModifyMenu",
		"mainCreateMenu",
		"mainDisplayMenu",
		"mainWindowMenu",
		// These help/test/bonustools menus are always shown at the end
		"HelpMenu",
		"MainHelpMenu",
		"bonusToolsMenu",
		"repoTestMenu", 
		// These are Hotbox menus
		"HotboxNorth1", "HotboxNorth2", "HotboxNorth3", 
		"HotboxSouth1", "HotboxSouth2", "HotboxSouth3", 
		"HotboxEast1", "HotboxEast2", "HotboxEast3", 
		"HotboxWest1", "HotboxWest2", "HotboxWest3", 
		"HotboxCenter1", "HotboxCenter2", "HotboxCenter3",
		"HotBoxRecentCommandsMenu", 
		"HotBoxControlsMenu"
	};
	
	iconTextScrollList -edit -removeAll tslMenus;
	iconTextScrollList -edit -removeAll tslAllMenus;
	
	// Get currently selected menu set
	string $selectedMenuSet[] = `iconTextScrollList -query -selectItem tslMenuSets`;
	string $menus[];
	int	   $filterCommon = 0;
	
	if(size($selectedMenuSet) > 0) {
		// Populate menus list
		string $cms = `findMenuSetFromLabel($selectedMenuSet[0])`;
		$menus = `menuSet -query -menuArray $cms`;
		int $count = `size($menus)`;
		int $index;

		// for the common menu set, show the common menus
		if ($cms == "commonMenuSet") {
			$filterMenus = $commonMenus;
			$filterCommon = 1;
		}
		
		for($index = 0; $index < $count; $index++) {
			if(`menu -exists $menus[$index]`) {
				iconTextScrollList -edit -append `menu -query -label $menus[$index]` tslMenus;
			}
		}
	}

	// Populate all menus list
	string $allMenus[] = `window -query -menuArray $gMainWindow`;
	string $labels[];
	string $item;
	int $index = 0;
	
	for($item in $allMenus) {
		// Check if menu should be fitered out
		int $inFilter = 0;
		if ($filterCommon > 0) {			
			// for common menus, show ONLY the six common menus
			$inFilter = (stringArrayCount($item, $filterMenus) == 0);
		}else {
			$inFilter = stringArrayCount($item, $filterMenus);
		}
		// Check if menu is in current menu set already
		
		// FIXME: there is a terrible hack here! We need `menuSet -q -menuArray` to return short names!
		int $inMenuSet = stringArrayCount($item, $menus);
		$inMenuSet += stringArrayCount(($gMainWindow+"|"+$item), $menus);
		// ENDOF FIXME
		
		if($inFilter == 0 && $inMenuSet == 0) {
			$labels[$index++] = `menu -query -label $item`;
		}
	}
	
	// Sort the list
	$labels = `sort $labels`;
	for($item in $labels) {
		iconTextScrollList -edit -append $item tslAllMenus;
	}

	updateMenuModeUI;
}

global proc string [] menuSetEditorDragCB(
	string $dragControl,
	int    $x, 
	int    $y, 
	int    $mods)
//
//	Description:
//		This procedure is called whenever the user begins a drag from
//		an icon text list.
//
//		Set up a drag message so we can detect it on the drop callback.
//
//	Arguments:
//		$dragControl - Control where the drag occurred.
//
//		$x, $y       - Location of the drag event.
//
//		$mods        - State of the mouse modifiers.
//
//	Returns:
//		A string array value representing the type of drag message.
//
{
	global string $tslMenuSets, $tslMenus, $tslAllMenus;

	// If nothing selected/selected item does not equal the one under cursor, 
	// get the item under mouse pointer and select it.
	string $dragItems[] = `iconTextScrollList -q -itemAt $x $y $dragControl`;
	string $selItems[] = `iconTextScrollList -q -selectItem $dragControl`;
	int $dragItemInSelItems = 0;
	for ($item in $selItems) {
		if ($item == $dragItems[0]) {
			$dragItemInSelItems = 1;
		}
	}
	if ((size($selItems) == 0) || ((size($dragItems) > 0) && ($dragItemInSelItems == 0))) {		
		if(size($dragItems) > 0) {			
			iconTextScrollList -edit -deselectAll -selectItem $dragItems[0] $dragControl;
		}
	}

	// below we hide feedback on panes which do not accept drops from this drag control
	string $result[];
	// Set the dragFeedbackVisible states for all controls here instead of
	// attempting to reset them in the drop callback, since sometimes the
	// latter is not called, and the states can be incorrect. This way, the
	// states are always correct upon drag initiation.
	//
	if($dragControl == $tslMenuSets) {
		$result = {"menuSetEditorDragMessageMenuSets"};
		iconTextScrollList -edit -dragFeedbackVisible true	tslMenuSets;
		iconTextScrollList -edit -dragFeedbackVisible false	tslMenus;	
	} else if($dragControl == $tslMenus) {
		$result = {"menuSetEditorDragMessageMenus"};
		iconTextScrollList -edit -dragFeedbackVisible false	tslMenuSets;
		iconTextScrollList -edit -dragFeedbackVisible true	tslMenus;
	} else if($dragControl == $tslAllMenus) {
		$result = {"menuSetEditorDragMessageAllMenus"};
		iconTextScrollList -edit -dragFeedbackVisible false	tslMenus;
		iconTextScrollList -edit -dragFeedbackVisible false	tslMenuSets;
	}

	updateMenuModeUI;
	return $result;
}

global proc int[] menuSetEditorDropRectCB(
	string $dropControl, 
	int    $x, 
	int    $y)
//
//	Description:
//		This procedure is called whenever the user hovers over
//		an icon text list during a drag 'n drop operation.
//
//	Arguments:
//		$dropControl - The list where the drop would occur.
//
//		$x, $y       - Location of the drag event.
//
{
	if( `iconTextScrollList -q -dragFeedbackVisible $dropControl` ){
		int $rect[] = `iconTextScrollList -q -visualRectAt $x $y $dropControl`;
		if( size($rect) == 4 ){
			// We just want a highlight line at the top of the item, so set the
			// box height to 1.
			//
			$rect[3] = 1;
			return $rect;
		}
	}
	return( {0,0,0,0} );
}


global proc menuSetEditorDropCB(
	string $dragControl,
	string $dropControl, 
	string $messages[],
	int    $x, 
	int    $y, 
	int    $dragType)
//
//	Description:
//		This procedure is called whenever the user ends a drag from
//		to an icon text list.
//
//	Arguments:
//		$dragControl - The list where the drag occurred.
//
//		$dropControl - The list where the drop occurred.
//
//		$messages[]  - The drag messages corresponding to the event.
//
//		$x, $y       - Location of the drag event.
//
//		$dragType    - Type of drag event.
//
{
	global string $tslMenuSets, $tslMenus, $tslAllMenus;

	if ("menuSetEditorDragMessageMenus" == $messages[0]) {
		// Process dragging from Menus list

		if($dragControl == $tslMenus && $dropControl == $tslAllMenus) {
			// Dragging from Menus list to AllMenus list means removing menus from menu set
			removeMenusFromMenuSet();
		} else if($dragControl == $tslMenus && $dropControl == $tslMenus) {
			// Dragging from Menus list to itself means reordering menus in menu set
			string $selectedMenuSet[] = `iconTextScrollList -query -selectItem tslMenuSets`;
			string $ms = findMenuSetFromLabel($selectedMenuSet[0]);
			string $selectedMenus[] = `iconTextScrollList -query -selectItem tslMenus`;
			
			// Find new index
			int $index = 0;
			string $dropItem[] = `iconTextScrollList -q -itemAt $x $y $dropControl`;
			string $item;
			for($item in `menuSet -query -menuArray $ms`) {
				if($dropItem[0] == `menu -q -label $item`) {
					break;
				}
				$index++;
			}
			
			string $menu;
			for($menu in $selectedMenus) {
				string $m = findMenuFromMenuSet($ms, $menu);
				menuSet -moveMenu $m $index $ms;
				$index++;
			}
			// Update UI
			rebuildMenusList();
		}

	} else if ("menuSetEditorDragMessageAllMenus" == $messages[0]) {
		// Process dragging from AllMenus list
		
		if($dragControl == $tslAllMenus && $dropControl == $tslMenus) {
			// Dragging from AllMenus list to Menus list means adding menus to menu set
			addMenusToMenuSet();
		}
		
	} else if ("menuSetEditorDragMessageMenuSets" == $messages[0]) {
		// Process dragging from MenuSets list
		
		if($dragControl == $tslMenuSets && $dropControl == $tslMenuSets) {
			// Dragging from MenuSets list to itself means reordering menu sets
			string $selectedMenuSets[] = `iconTextScrollList -query -selectItem tslMenuSets`;
			
			// Find new index
			int $index = 0;
			string $dropItem[] = `iconTextScrollList -q -itemAt $x $y $dropControl`;
			string $item;
			for($item in `menuSet -query -allMenuSets`) {
				if($dropItem[0] == `menuSet -q -label $item`) {
					break;
				}
				$index++;
			}
			
			string $ms;
			for($item in $selectedMenuSets) {
				$ms = findMenuSetFromLabel($item);
				menuSet -moveMenuSet $ms $index;
				$index++;
			}
			
			// Refresh UI
			rebuildMenuSetsList();	
			// select the previous item
			for ($item in $selectedMenuSets) {
				iconTextScrollList -edit -selectItem $item tslMenuSets;
			}
			// reload menus for that item
			rebuildMenusList();
		}
	}

	updateMenuModeUI;
}


global proc buildMenuSetEditor()
{
	global string $tslMenuSets, $tslMenus, $tslAllMenus;

	string $newMenuSet = (uiRes("m_menuSetEditor.kBuildNewMenuSet"));
		string $newMenuSetAnn = (uiRes("m_menuSetEditor.kBuildNewMenuSetAnn"));
	string $removeMenuSet = (uiRes("m_menuSetEditor.kBuildRemoveMenuSet"));
		string $removeMenuSetAnn = (uiRes("m_menuSetEditor.kBuildRemoveMenuSetAnn"));
	string $closeWindow	= (uiRes("m_menuSetEditor.kBuildCloseWindow"));
		string $closeWindowAnn = (uiRes("m_menuSetEditor.kBuildCloseWindowAnn"));
	string $rename = (uiRes("m_menuSetEditor.kBuildRename"));
		string $renameAnn = (uiRes("m_menuSetEditor.kBuildRenameAnn"));
	string $remove = (uiRes("m_menuSetEditor.kBuildRemove"));
		string $removeAnn = (uiRes("m_menuSetEditor.kBuildRemoveAnn"));
	string $revert = (uiRes("m_menuSetEditor.kBuildRevert"));
		string $revertAnn = (uiRes("m_menuSetEditor.kBuildRevertAnn"));
	string $restoreDefaultMenuSets = (uiRes("m_menuSetEditor.kBuildRestoreDefaultMenuSets"));
		string $restoreDefaultMenuSetsAnn = (uiRes("m_menuSetEditor.kBuildRestoreDefaultMenuSetsAnn"));
	string $menus = (uiRes("m_menuSetEditor.kBuildMenus"));
		string $menusAnn = (uiRes("m_menuSetEditor.kBuildMenusAnn"));
	string $allMenus = (uiRes("m_menuSetEditor.kBuildAllMenus"));
		string $allMenusAnn = (uiRes("m_menuSetEditor.kBuildAllMenusAnn"));
	string $removeFromMenuSet = (uiRes("m_menuSetEditor.kBuildRemoveFromMenuSet"));
		string $removeFromMenuSetAnn = (uiRes("m_menuSetEditor.kBuildRemoveFromMenuSetAnn"));
	string $addToMenuSet = (uiRes("m_menuSetEditor.kBuildAddToMenuSet"));
		string $addToMenuSetAnn = (uiRes("m_menuSetEditor.kBuildAddToMenuSetAnn"));

	
	// Get the dialog's formLayout.
	//
	string $form = `setParent -q`;

	// Create menus
	menu -label (uiRes("m_menuSetEditor.kBuildMenuSet")) -parent menuSetEditorWindow -postMenuCommand "updateMenuSetsMenuItems()";
		menuItem 
			-label $newMenuSet
			-annotation $newMenuSetAnn
			-command "createNewMenuSet()" menuBarNewMenuSet;
		menuItem 
			-label $rename
			-annotation $renameAnn
			-command "renameSelectedMenuSet()" menuBarRenameMenuSet;
		menuItem 
			-label $remove
			-annotation $removeAnn
			-command "removeSelectedMenuSet()" menuBarRemoveMenuSet;
		menuItem 
			-label $revert
			-annotation $revertAnn
			menuBarRevertMenuSet;
		menuItem 
			-label $restoreDefaultMenuSets
			-annotation $restoreDefaultMenuSetsAnn
			-command "revertToDefaultMenuSets();" 
			menuBarRevertDefaultMenuSets;

	addContextHelpProc "menuSetEditorWindow" "buildMenuSetsEditorContextHelpItems";
	doHelpMenu "menuSetEditorWindow" "menuSetEditorWindow";

	setParent $form;

	text -label (uiRes("m_menuSetEditor.kBuildMenuSetsLabel"))  
		 -annotation (uiRes("m_menuSetEditor.kBuildMenuSetsLabelAnn"))  
		 -align "center" txtMenuSets;
	text -label (uiRes("m_menuSetEditor.kBuildMenusInMenuSetLabel"))  
		 -annotation (uiRes("m_menuSetEditor.kBuildMenusInMenuSetLabelAnn"))  
		 -align "center" txtMenus;
	text -label (uiRes("m_menuSetEditor.kBuildAllMenusLabel"))  
		 -annotation (uiRes("m_menuSetEditor.kBuildAllMenusLabelAnn"))  
		 -align "center" txtAllMenus;
	
	paneLayout -width 500 -height 260
		-configuration "vertical3"
		menuSetPaneLayout;

	// First pane contains list of all menu sets
	$tslMenuSets = `iconTextScrollList
		-allowMultiSelection off
		-editable on
		-selectCommand "rebuildMenusList(); updateCurrentWorkingMode();"
		-changeCommand "changeMenuSetName()"
		-dragCallback "menuSetEditorDragCB"
		-dropCallback "menuSetEditorDropCB"	
		tslMenuSets`;
	iconTextScrollList -e
		-dropRectCallback "menuSetEditorDropRectCB"	$tslMenuSets;
	// Second pane contains list of menus in selected menu set
	$tslMenus = `iconTextScrollList 
		-allowMultiSelection on
		-dragCallback "menuSetEditorDragCB"
		-dropCallback "menuSetEditorDropCB"
		-doubleClickCommand "removeMenusFromMenuSet();"
		tslMenus`;
	iconTextScrollList -e
		-dropRectCallback "menuSetEditorDropRectCB"	$tslMenus;
	// Third pane contains list af all menus
	$tslAllMenus = `iconTextScrollList 
		-allowMultiSelection on
		-dragCallback "menuSetEditorDragCB"
		-dropCallback "menuSetEditorDropCB"
		-doubleClickCommand "addMenusToMenuSet();"		
		-dragFeedbackVisible false
		tslAllMenus`;
	iconTextScrollList -e
		-dropRectCallback "menuSetEditorDropRectCB"	$tslAllMenus;

	setParent .. ;
	
	// Create popup menus
	popupMenu -parent tslMenuSets -postMenuCommand "updateMenuSetsMenuItems()";
		menuItem 
			-label $newMenuSet
			-annotation $newMenuSetAnn
			-command "createNewMenuSet()" tslMenuSetsNewMenuSet;
		menuItem 
			-label $rename
			-annotation $renameAnn
			-command "renameSelectedMenuSet()" tslMenuSetsRenameMenuSet;
		menuItem 
			-label $remove
			-annotation $removeAnn
			-command "removeSelectedMenuSet()" tslMenuSetsRemoveMenuSet;
		menuItem 
			-label $revert
			-annotation $revertAnn
			tslMenuSetsRevertMenuSet;

	popupMenu -parent tslMenus -postMenuCommand "updateMenusMenuItems()";
		menuItem 
			-label $removeFromMenuSet
			-annotation $removeFromMenuSetAnn
			-command "removeMenusFromMenuSet()" tslMenusRemoveMenus;

	popupMenu -parent tslAllMenus -postMenuCommand "updateAllMenusMenuItems()";
		menuItem 
			-label $addToMenuSet
			-annotation $addToMenuSetAnn
			-command "addMenusToMenuSet()" tslAllMenusAddMenus;

	rebuildMenuSetsList();
	// Select current menu set in the menu sets list
	if (`menuSet -q -numberOfMenuSets` > 0)
		iconTextScrollList -edit -selectItem `menuSet -query -label` tslMenuSets;
	// Force update other two lists
	rebuildMenusList();

	button -label $newMenuSet
		-annotation $newMenuSetAnn
		-command "createNewMenuSet()"
		menuSetNewButton;
	button -label $removeMenuSet
		-annotation $removeMenuSetAnn
		-command "removeSelectedMenuSet()"
		menuSetRemoveButton;
	button -label $closeWindow
		-annotation $closeWindowAnn
		-command "deleteUI menuSetEditorWindow"
		menuSetDoneButton;
	
	int $spacer = 5;
	int $top = 5;
	int $edge = 5;
	
	formLayout -edit
	
			-attachForm				txtMenuSets			"left"          $edge 
			-attachForm				txtMenuSets			"top"			$top
			-attachPosition			txtMenuSets			"right"         $spacer 33
	
			-attachPosition			txtMenus			"left"          $spacer 33
			-attachForm				txtMenus			"top"			$top
			-attachPosition			txtMenus			"right"         $spacer 66
	
			-attachPosition			txtAllMenus			"left"          $spacer 66
			-attachForm				txtAllMenus			"top"			$top
			-attachForm				txtAllMenus			"right"         $edge
	
			-attachControl			menuSetPaneLayout	"top"			1 txtMenuSets
			-attachForm				menuSetPaneLayout	"left"			$edge
			-attachForm				menuSetPaneLayout	"right"			$edge
			-attachControl			menuSetPaneLayout	"bottom"		$spacer menuSetNewButton
	
			-attachForm				menuSetNewButton	"left"          $edge 
			-attachForm				menuSetNewButton	"bottom"		$top
			-attachPosition			menuSetNewButton	"right"         $spacer 33
	
			-attachPosition			menuSetRemoveButton	"left"          $spacer 33
			-attachForm				menuSetRemoveButton	"bottom"		$top
			-attachPosition			menuSetRemoveButton	"right"         $spacer 66
	
			-attachPosition			menuSetDoneButton	"left"          $spacer 66
			-attachForm				menuSetDoneButton	"bottom"		$top
			-attachForm				menuSetDoneButton	"right"         $edge
	
	$form;
}

global proc menuSetEditor()
{
	// remove other instance of window if it exists
	if (`window -exists menuSetEditorWindow`) {
		deleteUI menuSetEditorWindow;
	}

	// build new window
	window 
		-title (uiRes("m_menuSetEditor.kMainMenuSetsEditorTitle"))
		-menuBar true
		-menuBarVisible true
		menuSetEditorWindow;
	formLayout
		menuSetEditorMainFormLayout;
    buildMenuSetEditor;
	showWindow menuSetEditorWindow;
		
	updateMenuModeUI();
}
