// Copyright (C) 1997-2014 Autodesk, Inc., and/or its licensors.
// All rights reserved.
//
// The coded instructions, statements, computer programs, and/or related
// material (collectively the "Data") in these files contain unpublished
// information proprietary to Autodesk, Inc. ("Autodesk") and/or its licensors,
// which is protected by U.S. and Canadian federal copyright law and by
// international treaties.
//
// The Data is provided for use exclusively by You. You have the right to use,
// modify, and incorporate this Data into other products for purposes authorized 
// by the Autodesk software license agreement, without fee.
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND. AUTODESK
// DOES NOT MAKE AND HEREBY DISCLAIMS ANY EXPRESS OR IMPLIED WARRANTIES
// INCLUDING, BUT NOT LIMITED TO, THE WARRANTIES OF NON-INFRINGEMENT,
// MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE, OR ARISING FROM A COURSE 
// OF DEALING, USAGE, OR TRADE PRACTICE. IN NO EVENT WILL AUTODESK AND/OR ITS
// LICENSORS BE LIABLE FOR ANY LOST REVENUES, DATA, OR PROFITS, OR SPECIAL,
// DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES, EVEN IF AUTODESK AND/OR ITS
// LICENSORS HAS BEEN ADVISED OF THE POSSIBILITY OR PROBABILITY OF SUCH DAMAGES.

//
//
//  Creation Date:  June 2000
//
//  Description:
//      Option tool callbacks for Artisan Select Paint tool.
//
//
//  Procedure Name:
//     	artAttrCallback 
//
//  Description:
//      Initialize the option values.
//
//  Input Arguments:
//
//  Return Value:
//      None.
//
// 
global proc artAttrPaintOperation(
	string $artCommand,
	string $operation
)
//
//	Description:
//		Set the correct paint operation flag on attribute paint context.
//
{
	string $cmd;
	if ( $operation == "Replace" ) {
		$cmd = ($artCommand + " -e -selectedattroper \"absolute\" `currentCtx`");
	} else if ( $operation == "Add" ) {
		$cmd = ($artCommand + " -e -selectedattroper \"additive\" `currentCtx`");
	} else if ( $operation == "Scale" ) {
		$cmd = ($artCommand + " -e -selectedattroper \"scale\" `currentCtx`");
	} else if ( $operation == "Smooth" ) {
		$cmd = ($artCommand + " -e -selectedattroper \"smooth\" `currentCtx`");
	} else if ( $operation == "Remove" ) {
		$cmd = ($artCommand + " -e -selectedattroper \"remove\" `currentCtx`");
	}

	eval( $cmd );

	//if the operation is smooth disable value options
	artAttrUpdateValueControls ( $operation != "smooth" );
}


global proc artAttrSetFiler(
	string $node,
	string $artCommand
)
{
	// Activate/Deactivate nodes.
	string $filterUILabel = uiRes("m_artAttrToolScript.kFilter");

	string $cmd; 
	if ( $node == "all" ) {
		makePaintable -activateAll true;
		makePaintable -activate false "mesh" "vertexColorRGB" ;
		makePaintable -activate false "mesh" "vertexFaceColorRGB" ;
		setArtAttrFilterLabel( (uiRes("m_artAttrToolScript.kFilterAll")) );
	}
	else {
		makePaintable -activateAll false;
		if ( $node == "cluster" ) {
			makePaintable -activate true "cluster" "weights";
			setArtAttrFilterLabel( `format -s "cluster" $filterUILabel` );
		} else if ( $node == "jiggle" ) {
			makePaintable -activate true "jiggle" "weights";
			setArtAttrFilterLabel( `format -s "jiggle" $filterUILabel` );
		} else if ( $node == "polyReduce" ) {
			makePaintable -activate true "polyReduce" "vertexWeights";
			setArtAttrFilterLabel( `format -s "polyReduce" $filterUILabel` );
		} else if ( $node == "particle" ) {
			makePaintable -activate true "particle" "*";
			setArtAttrFilterLabel( `format -s "particle" $filterUILabel` );
		} else if ( $node == "wire" ) {
			makePaintable -activate true "wire" "weights";
			setArtAttrFilterLabel( `format -s "wire" $filterUILabel` );
		} else if ( $node == "transferAttributes" ) {
			makePaintable -activate true "transferAttributes" "weights";
			setArtAttrFilterLabel( `format -s "transferAttributes" $filterUILabel` );
		} else if ( $node == "shrinkWrap" ) {
			makePaintable -activate true "shrinkWrap" "weights";
			setArtAttrFilterLabel( `format -s "shrinkWrap" $filterUILabel` );
		}
	}

	// Make sure that the menu is recreated.
	artAttrPaintMenu( "artAttrListPopupMenu" );

	// Update the UI.
	if (`button -q -ex artAttrListButton`) {
		 button -e -label (uiRes("m_artAttrCallback.kNoAttributeSelected")) artAttrListButton;	
	}
	if (`button -q -ex artAttrFilterButton`) {
		button -e -label `artAttrFilterLabel` artAttrFilterButton;
	}
}

// Sets the current attribute to "" if the node and/or attribute is invalid
// otherwise, retains existing value. Useful in case (the most recent) current
// attribute becomes invalid and a fallback attribute is needed.
//
global proc artAttrSyncCurrentAttribute()
{
	global string $gArtAttrCurrentAttr;
	string $buffer[];
	tokenize( $gArtAttrCurrentAttr, ".", $buffer );
	string $nodeName = $buffer[1];
	string $attributeName = $buffer[2];
	if ( !`objExists $nodeName` ) {
		$gArtAttrCurrentAttr="";
	}
	else if ( !`attributeQuery -node $nodeName -exists $attributeName` ) {
		$gArtAttrCurrentAttr="";
	}
}

global proc artAttrUpdateValueControls(int $enable)
{
	if(` floatSliderGrp -exists artAttrValueSlider `) 
	{
		floatSliderGrp -e -enable $enable artAttrValueSlider ;		
		symbolButton -e -enable $enable artAttrValuePick ;

        if(`floatFieldGrp -exists artAttrMinMaxValue`)
		    floatFieldGrp -e -enable $enable artAttrMinMaxValue ;
	}
}

global proc artAttrUpdatePaintValueSlider(
	string 	$artCommand
)
//
//	Description:
//		Min or Max value has changed. Update the value slider 
//		and send the new values to the attribtue context.
//
{
	string $cmd;

	float  $value  = `floatSliderGrp -q -value artAttrValueSlider`;
	float  $value1; 
	float  $value2; 
	
	if(`floatFieldGrp -exists artAttrMinMaxValue`)
	{
	    $value1 = `floatFieldGrp -q -value1 artAttrMinMaxValue`;
	    $value2 = `floatFieldGrp -q -value2 artAttrMinMaxValue`;
	}
	else
	{
	    $value1 = 0.0;
	    $value2 = 1.0;
	}

	// Clamp the value.
	$value = clamp( $value1, $value2, $value );

	// Send the new values to the context.
	$cmd = $artCommand + " -e -minvalue " + $value1 + " `currentCtx`";
	eval( $cmd );
	$cmd = $artCommand + " -e -maxvalue " + $value2 + " `currentCtx`";
	eval( $cmd );

	// Fix the paint value if necessary.
	$cmd = $artCommand + " -e -value " + $value + " `currentCtx`";
	eval( $cmd );

	// Update the value slider.
	floatSliderGrp -e 
		-min $value1 -max $value2 
		-value $value 
	artAttrValueSlider;
}

global proc artAttrUpdateClampLower(
	string 	$artCommand, int $clampLower
)
//
//	Description:
//		This is a callback procedure used when the "lower" RGB clamp checkbox is clicked
//		The correct clamp type flag is then set on the attribute paint context.
//
{
	// Clamp Options.
	string $cmd = $artCommand + " -q -clamp " + `currentCtx` ;
	int $clampUpper = 0 ;
	string $clampOpt = `eval $cmd`;
	if ( $clampOpt == "both" || $clampOpt == "upper" ) {
		$clampUpper = 1 ;
	}
	
	artAttrUpdateClampOptionsInPaintCtx( $artCommand, $clampLower, $clampUpper );
}

global proc artAttrUpdateClampUpper(
	string 	$artCommand, int $clampUpper
)
//
//	Description:
//		This is a callback procedure used when the "upper" RGB clamp checkbox is clicked
//		The correct clamp type flag is then set on the attribute paint context.
//
{
	string $cmd = $artCommand + " -q -clamp " + `currentCtx` ;
	int $clampLower = 0 ;
	string $clampOpt = `eval $cmd`;
	if ( $clampOpt == "both" || $clampOpt == "lower" ) {
		$clampLower = 1 ;
	}

	artAttrUpdateClampOptionsInPaintCtx( $artCommand, $clampLower, $clampUpper );

}


global proc artAttrUpdateClampOptionsInPaintCtx(
	string 	$artCommand, int $clampLowerEnabled, int $clampUpperEnabled
)
//
//	Description:
//		This procedure sets the RGB clamp type flag on the attribute paint context.
//		As well, numerical clamp fields are enabled/disabled accordingly
//		to match their check boxed status.
//
{
	string $cmd;
	if ( $clampLowerEnabled ) {
		if ( $clampUpperEnabled ) {
			$cmd = ($artCommand + " -e -clamp \"both\" `currentCtx`");
		}
		else {
			$cmd = ($artCommand + " -e -clamp \"lower\" `currentCtx`");
		} 
	} else {
		if ( $clampUpperEnabled ) {
			$cmd = ($artCommand + " -e -clamp \"upper\" `currentCtx`");
		}
		else {
			$cmd = ($artCommand + " -e -clamp \"none\" `currentCtx`");
		}
	}

	eval( $cmd );

	artAttrUpdateClampField($artCommand);

}


global proc artAttrUpdateClampField(
	string 	$artCommand
)
//
//	Description:
//		This procedure is invoked as a callback routine attached to the lower/upper RGB clamp
//		floating-point value fields. Thus, this procedure is triggered when the Min or Max
//		RGB clamp value has changed.
//		Note: The new Min/Max RGB clamp values are validated and updated when necessary
//		(i.e. if only one of "upper" or "lower" clamping is enabled, then its clamping bound
//		can be freely modified. If both "upper" and "lower" clamping is enabled, then the lower
//		bound will be modified such that it is less than or equal to the upper bound.)
//
{
	// Determine RGB clamp status
	//
	int $bMinClampEnabled;
	int $bMaxClampEnabled;
	
	if(`checkBoxGrp -exists artAttrClampChkBox`)
	{
	    $bMinClampEnabled =`checkBoxGrp -q -value1 artAttrClampChkBox`;
	    $bMaxClampEnabled =`checkBoxGrp -q -value2 artAttrClampChkBox`;
	}
	else
	{
	    $bMinClampEnabled = 0;
	    $bMaxClampEnabled = 0;
	}
	
	float $minClampedValue;
	float $maxClampedValue;
	
	if(`floatFieldGrp -exists artAttrClampField`)
	{
	    $minClampedValue = `floatFieldGrp -q -value1 artAttrClampField`;
	    $maxClampedValue = `floatFieldGrp -q -value2 artAttrClampField`;
	}
	else
	{
	    $minClampedValue = 0.0;
	    $maxClampedValue = 1.0;
	}

	// Ensure a correct min/max range
	//
	if ( $bMinClampEnabled && $bMaxClampEnabled ) {
		if ( $minClampedValue > $maxClampedValue ) {
			
			$msg = (uiRes("m_artAttrCallback.kClampMinExceedsRGBClampMax"));
			warning($msg);
			
			$minClampedValue=$maxClampedValue;

			// Update the NEW value on the UI
			//
			if(`floatFieldGrp -exists artAttrClampField`)
			{
			    floatFieldGrp -e -value1 $minClampedValue
				    -value2 $maxClampedValue
				    artAttrClampField;
		    }
		}
	}

	// Update Artisan's context w.r.t. active RGB clamp bounds
	//
	if ( $bMinClampEnabled ) {
		$cmd = ($artCommand + " -e -clamplower " + $minClampedValue + " `currentCtx`");
		eval( $cmd );
	}
	
	if ( $bMaxClampEnabled ) {
		$cmd = ($artCommand + " -e -clampupper " + $maxClampedValue + " `currentCtx`");
		eval( $cmd );
	}

}


global proc artAttrUpdateAlphaClampLower(
	string 	$artCommand, int $clampLower
)
//
//	Description:
//		This is a callback procedure used when the "lower" alpha clamp checkbox is clicked
//		The correct alpha clamp type flag is then set on the attribute paint context.
//
{
	// Clamp Options.
	string $cmd = $artCommand + " -q -alphaclamp " + `currentCtx` ;
	int $clampUpper = 0 ;
	string $clampOpt = `eval $cmd`;
	if ( $clampOpt == "both" || $clampOpt == "upper" ) {
		$clampUpper = 1 ;
	}
	
	artAttrUpdateAlphaClampOptionsInPaintCtx( $artCommand, $clampLower, $clampUpper );
}


global proc artAttrUpdateAlphaClampUpper(
	string 	$artCommand, int $clampUpper
)
//
//	Description:
//		This is a callback procedure used when the "upper" alpha clamp checkbox is clicked
//		The correct alpha clamp type flag is then set on the attribute paint context.
//
{
	string $cmd = $artCommand + " -q -alphaclamp " + `currentCtx` ;
	int $clampLower = 0 ;
	string $clampOpt = `eval $cmd`;
	if ( $clampOpt == "both" || $clampOpt == "lower" ) {
		$clampLower = 1 ;
	}

	artAttrUpdateAlphaClampOptionsInPaintCtx( $artCommand, $clampLower, $clampUpper );
}


global proc artAttrUpdateAlphaClampOptionsInPaintCtx(
	string 	$artCommand, int $clampLowerEnabled, int $clampUpperEnabled
)
//
//	Description:
//		This procedure sets the alpha clamp type flag on the attribute paint context.
//		As well, numerical clamp fields are enabled/disabled accordingly
//		to match their check boxed status.
//
{
	string $cmd;

	// Update Artisan's context w.r.t. active alpha clamp type
	//
	if ( $clampLowerEnabled ) {
		if ( $clampUpperEnabled ) {
			$cmd = ($artCommand + " -e -alphaclamp \"both\" `currentCtx`");
		}
		else {
			$cmd = ($artCommand + " -e -alphaclamp \"lower\" `currentCtx`");
		} 
	} else {
		if ( $clampUpperEnabled ) {
			$cmd = ($artCommand + " -e -alphaclamp \"upper\" `currentCtx`");
		}
		else {
			$cmd = ($artCommand + " -e -alphaclamp \"none\" `currentCtx`");
		}
	}
	eval( $cmd );

	artAttrUpdateAlphaClampField($artCommand);

	// This is needed particularly for the initial state of the clamp tool
	// so that the enabled state of float fields correspond with their check boxes
	floatFieldGrp -e -enable1 $clampLowerEnabled
		-enable2 $clampUpperEnabled
		artAttrAlphaClampField;
}


global proc artAttrUpdateAlphaClampField(
	string 	$artCommand
)
//
//	Description:
//		This procedure is invoked as a callback routine attached to the lower/upper alpha clamp
//		floating-point value fields. Thus, this procedure is triggered when the Min or Max
//		alpha clamp value has changed.
//		Note: The new Min/Max alpha clamp values are validated and updated when necessary
//		(i.e. if only one of "upper" or "lower" clamping is enabled, then its clamping bound
//		can be freely modified. If both "upper" and "lower" clamping is enabled, then the lower
//		bound will be modified such that it is less than or equal to the upper bound.)
//
{
	// Determine alpha clamp status
	//
	int $bMinClampEnabled=`checkBoxGrp -q -value1 artAttrAlphaClampChkBox`;
	int $bMaxClampEnabled=`checkBoxGrp -q -value2 artAttrAlphaClampChkBox`;
	float $minClampedAlphaValue=`floatFieldGrp -q -value1 artAttrAlphaClampField`;
	float $maxClampedAlphaValue=`floatFieldGrp -q -value2 artAttrAlphaClampField`;

	// Ensure a correct min/max range
	//
	if ( $bMinClampEnabled && $bMaxClampEnabled ) {
		if ( $minClampedAlphaValue > $maxClampedAlphaValue ) {
			$msg = (uiRes("m_artAttrCallback.kClampMinExceedsAlphaClampMax"));
			warning($msg);
			$minClampedAlphaValue=$maxClampedAlphaValue;

			// Update the NEW value on the UI
			//
			floatFieldGrp -e -value1 $minClampedAlphaValue
				-value2 $maxClampedAlphaValue
				artAttrAlphaClampField;
		}
	}

	// Update Artisan's context w.r.t. active alpha clamp bounds
	//
	if ( $bMinClampEnabled ) {
		$cmd = ($artCommand + " -e -alphaclamplower " + $minClampedAlphaValue + " `currentCtx`");
		eval( $cmd );
	}
	
	if ( $bMaxClampEnabled ) {
		$cmd = ($artCommand + " -e -alphaclampupper " + $maxClampedAlphaValue + " `currentCtx`");
		eval( $cmd );
	}
}


global proc artAttrVectorIdxCallback(
	string $artCommand
)
//
//	Description:
//		Set the correct vector index flag on attribute paint context.
//
{
	string $idx = `optionMenuGrp -q -v artAttrVectorIdxOptionMenu`;
	string $xR = (uiRes("m_artAttrCallback.kXr"));
	string $yG = (uiRes("m_artAttrCallback.kYg"));
	string $zB = (uiRes("m_artAttrCallback.kZb"));
	int $which;
	if ( $idx == $xR ) {
		$which = 1;
	} else if ( $idx == $yG ) {
		$which = 2;
	} else if ( $idx == $zB ) {
		$which = 3;
	}

	string $cmd = ($artCommand + " -e -dti " + $which + " `currentCtx` ");
	eval( $cmd );
}

global proc artAttrSelected(
	string 	$artCommand,
	string	$attribute
)
// 
//	Description:
//		New attribute has been selected.  
//		Update the context and update the UI.
//
{
	global string $gArtAttrCurrentAttr;

	source "artisanUtilities.mel" ;

	// Update the global value.
	$gArtAttrCurrentAttr = $attribute;

	string $buffer[];
	tokenize( $attribute, ".", $buffer );
	string $nodeType = $buffer[0];
	string $nodeName = $buffer[1];
	string $attributeName = $buffer[2];

	string $cmd = $artCommand;

	// When painting weights for polyReduce the default value
	// of interactiveUpdate is false.
	//
	if ( $nodeType == "polyReduce" ){
		if( !`optionVar -ex "artAttrturnOffUpdate"`){
			optionVar -intValue "artAttrturnOffUpdate" 1 ;
			$cmd = ($cmd + " -interactiveUpdate false ");
			if (`checkBoxGrp -q -ex artAttrInteractiveUpdate`) {
				checkBoxGrp -e -v1 false artAttrInteractiveUpdate;
			}
		} 
	} else {
		optionVar -remove "artAttrturnOffUpdate" ;
	}



	// Notify the context about the change.
	$cmd = ($cmd + " -e -pas \"" + $attribute + "\" `currentCtx`");
	eval( $cmd );	

	// Update the UI.
	if (`button -q -ex artAttrListButton`) {
		string $attrLabel = getNodeNameFromAbsolutePath( $nodeName ) + "." + $attributeName;

		string $listAttr[] = `ls ($nodeName + "." + $attributeName)`;
		if( size( $listAttr ) == 0 ) {
			string $msg;
			if( $attributeName == "rgbPP" || $attributeName == "opacityPP" )
			{
				$msg = (uiRes("m_artAttrCallback.kAddDynamicAttribute"));
				$msg = `format -s $attributeName -s $nodeName $msg`;
			}
			else if( $attributeName == "goalPP" )
			{
				$msg = (uiRes("m_artAttrCallback.kCreateWithGoalHeight"));
			}	
			else {
				// bug #189448
				// make one more check if the attribute happens to be a child attribute.
				// Ex : vertexColorRGB is child of vertexColor attribute of mesh.(Paint vertex color tool)
				// Ex : weights is child of weightsList attribute of mesh.
				// Create an intersector
				string $myIntersector = `stringArrayIntersector`;

				// create a list of leaf attributes of the node.
				// Intersect the list with attribute name.
				string $initialArray[] = `listAttr -leaf $nodeName` ;
				stringArrayIntersector -edit -intersect $initialArray $myIntersector;
				stringArrayIntersector -edit -intersect { $attributeName } $myIntersector;

				// Query the intersector to see what the intersection is so far
				string $found[] = `stringArrayIntersector -query $myIntersector` ;

				// if size is > 0 we found the attribute 
				if( size( $found ) == 0 ) {
					$msg = (uiRes("m_artAttrCallback.kAttributeMissing"));
					$msg = `format -s $nodeName -s $attributeName $msg`;
				}
			}
			
			if( size( $msg ) > 0 ) {
				warning($msg);
			}
		}

		if ( $attrLabel != "" ) 
			button -e -label $attrLabel artAttrListButton;
	}
}


// =======================================================
// Attribute Paint Specific callbacks.
// =======================================================
global proc artAttrCommonCallback(
	string 	$artCommand,
	string	$currTool
)
//
//	Description:
//		Common callbacks for all Attribute Paint tools.
//
{
	// Paint Operation frameLayout
	radioButtonGrp -e
		-on1 ("artAttrPaintOperation " + $artCommand + " Replace")
		-on2 ("artAttrPaintOperation " + $artCommand + " Add")
	artAttrOperRadioButton0;

	radioButtonGrp -e
		-on1 ("artAttrPaintOperation " + $artCommand + " Scale")
		-on2 ("artAttrPaintOperation " + $artCommand + " Smooth")
	artAttrOperRadioButton1;

	// Paint value. 
	floatSliderGrp -e
		-cc ($artCommand + " -e -value #1 `currentCtx`")
	artAttrValueSlider;

	symbolButton -e -command ($artCommand + " -e -pickValue `currentCtx`") artAttrValuePick;


    if(`floatFieldGrp -exists artAttrMinMaxValue`)
    {
	    floatFieldGrp -e
		    -cc ( "artAttrUpdatePaintValueSlider " + $artCommand )
	    artAttrMinMaxValue;
	}

	// Define callbacks for RGB clamp
	//
	string $cmd1 = "artAttrUpdateClampLower " +  $artCommand + " #1 " ;
	string $cmd2 = "artAttrUpdateClampUpper " +  $artCommand + " #1 " ;
	if(`checkBoxGrp -exists artAttrClampChkBox`)
	    checkBoxGrp -e -cc1 $cmd1 -cc2 $cmd2 artAttrClampChkBox; 

    if(`floatFieldGrp -exists artAttrClampField`)
    {
	    floatFieldGrp -e
		    -cc ( "artAttrUpdateClampField " + $artCommand )
	    artAttrClampField;
	}

	// Tools
	
    button -e 
	    -c ($artCommand + " -e -clear `currentCtx`")
    artAttrFloodButton;    
    
		
	
}


global proc artAttrPaintCallback(
	string 	$artCommand,
	string	$currTool
)
//
//	Description:
//		Attribute Paint tool callbacks.
//
{
	// Define the common callbacks.
	artAttrCommonCallback( $artCommand, $currTool );

	// Filter stuff.
	menuItem -e 
		-c ( "artAttrSetFiler \"cluster\" " + $artCommand )
		artAttrFilterMenu1;
	menuItem -e 
		-c ( "artAttrSetFiler \"jiggle\" " + $artCommand )
		artAttrFilterMenu2;
	menuItem -e 
		-c ( "artAttrSetFiler \"particle\" " + $artCommand )
		artAttrFilterMenu3;
	menuItem -e 
		-c ( "artAttrSetFiler \"polyReduce\" " + $artCommand )
		artAttrFilterMenu4;
	menuItem -e 
		-c ( "artAttrSetFiler \"wire\" " + $artCommand )
		artAttrFilterMenu5;
	menuItem -e 
		-c ( "artAttrSetFiler \"transferAttributes\" " + $artCommand )
		artAttrFilterMenu6;
	menuItem -e 
		-c ( "artAttrSetFiler \"shrinkWrap\" " + $artCommand )
		artAttrFilterMenu7;
	menuItem -e 
		-c ( "artAttrSetFiler \"all\" " + $artCommand )
		artAttrFilterMenu8;

	// Vector index.
	optionMenuGrp -e
		-cc ( "artAttrVectorIdxCallback " + $artCommand )
	artAttrVectorIdxOptionMenu;
}


// =======================================================
// Main Procedure.
// =======================================================

global proc artAttrCallback(
	string	$artCommand
)
{
	source "artisanCallback.mel";

	string $currContext = `currentCtx`;
	string $currTool	= `contextInfo -c $currContext`;

	// Basic Brush frameLayout.
	artisanBrushCallback( $artCommand, $currTool );

	// Attribute Paint frameLayout Callback.
	artAttrPaintCallback( $artCommand, $currTool );

	// Stroke frameLayout.
	artisanStrokeCallback( $artCommand, $currTool );

	// Pressure frameLayout.
	artisanPressureCallback( $artCommand, $currTool );

	// Attribute Maps frameLayout.
	artisanAttrMapCallback( $artCommand, $currTool );

	// Display frameLayout.
	artisanDisplayCallback( $artCommand, $currTool );
}
