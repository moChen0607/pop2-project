// Copyright (C) 1997-2014 Autodesk, Inc., and/or its licensors.
// All rights reserved.
//
// The coded instructions, statements, computer programs, and/or related
// material (collectively the "Data") in these files contain unpublished
// information proprietary to Autodesk, Inc. ("Autodesk") and/or its licensors,
// which is protected by U.S. and Canadian federal copyright law and by
// international treaties.
//
// The Data is provided for use exclusively by You. You have the right to use,
// modify, and incorporate this Data into other products for purposes authorized 
// by the Autodesk software license agreement, without fee.
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND. AUTODESK
// DOES NOT MAKE AND HEREBY DISCLAIMS ANY EXPRESS OR IMPLIED WARRANTIES
// INCLUDING, BUT NOT LIMITED TO, THE WARRANTIES OF NON-INFRINGEMENT,
// MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE, OR ARISING FROM A COURSE 
// OF DEALING, USAGE, OR TRADE PRACTICE. IN NO EVENT WILL AUTODESK AND/OR ITS
// LICENSORS BE LIABLE FOR ANY LOST REVENUES, DATA, OR PROFITS, OR SPECIAL,
// DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES, EVEN IF AUTODESK AND/OR ITS
// LICENSORS HAS BEEN ADVISED OF THE POSSIBILITY OR PROBABILITY OF SUCH DAMAGES.

proc string getShortName(string $name)
//
//	Description:
//		Given a full path name to an object return the short name.
//
//	Arguments:
//		$name - Full path name to an object.
//
//	Returns:
//		The short name.
//
{
	string $result = "", $tokenArray[];
	int    $tokenCount;

	//	To get the short name from a long name tokenize the long name
	//	using "|" as the split character because that is the path
	//	separator. The short name is simply the last token.
	//
	$tokenCount = `tokenize $name "|" $tokenArray`;
	if (0 < $tokenCount) $result = $tokenArray[$tokenCount - 1];

	return $result;
}

proc string getGridChildName(string $name, string $gridLayout)
//
//	Description:
//		Given a full path name to an object, if this object is 
//      under the $gridLayout, we return the child of the $gridLayout
//      along the path specified by the given object $name. 
//
//	Arguments:
//		$name - Full path name to an object.
//
//	Returns:
//		The short name of the child of the gridLayout.
//
{
    string $gridLayoutShortName = getShortName($gridLayout);

	string $result = "", $tokenArray[];
	int    $tokenCount;

	//	To get the short name of the gridLayout's child
    // from a long name tokenize the long name
	//	using "|" as the split character because that is the path
	//	separator. The short name of the gridLayout's child 
    //  is simply the token after the token for the gridLayout.
	//
	$tokenCount = `tokenize $name "|" $tokenArray`;
    int $i; 
    for ($i = 0; $i <= $tokenCount - 2; $i++)
    {
        if ($tokenArray[$i] == $gridLayoutShortName)
        {
            // The next token must be the child of the gridLayout.
            //
            $result = $tokenArray[$i+1];
            break;
        }
    }

	return $result;
}

// Description:  This procedure is called to drag the row of a 
//      gridLayout and drop it in a drop position in the gridLayout. 
//
global proc gridLayoutRowDragAndDrop(
    string $gridLayout, string $dragControl, string $dropControl)
{
     string $orderArray[];
     int    $index, $dragPosition = 0, $dropPosition = 0;

		//	Note that the drag and drop control arguments are long names and
		//	the items in the grid's array are short names (long names 
		//	contain the full path).
		//
		$dropControl = getGridChildName($dropControl, $gridLayout);
		$dragControl = getGridChildName($dragControl, $gridLayout);

		$orderArray = `gridLayout -query -gridOrder $gridLayout`;

		//	Determine the drag and drop positions.
		//
		for ($index = 0; $index < size($orderArray); $index++) {
			if ($dragControl == $orderArray[$index]) {
				$dragPosition = $index + 1;
			}
			if ($dropControl == $orderArray[$index]) {
				$dropPosition = $index + 1;
			}
		}

		if ($dragPosition < $dropPosition) {
			
			//	Put drag control at drop position.
			//
			gridLayout -edit -position $dragControl $dropPosition $gridLayout;

			//	Shuffle the items following the drop position.
			//
			for ($index = $dragPosition + 1; $index <= $dropPosition; $index++) {
				gridLayout -edit -position $orderArray[$index - 1] ($index - 1) $gridLayout;
			}

		} else if ($dragPosition > $dropPosition) {
		
			//	Put drag control at drop position.
			//
			gridLayout -edit -position $dragControl $dropPosition $gridLayout;

			//	Shuffle the items following the drop position.
			//
			for ($index = $dragPosition - 1; $index >= $dropPosition; $index--) {
				gridLayout -edit -position $orderArray[$index - 1] ($index + 1) $gridLayout;
			}

		} else {
			//
			//	Drag position is same as drop position. Nothing to do.
			//
		}
}
