// Copyright (C) 1997-2014 Autodesk, Inc., and/or its licensors.
// All rights reserved.
//
// The coded instructions, statements, computer programs, and/or related
// material (collectively the "Data") in these files contain unpublished
// information proprietary to Autodesk, Inc. ("Autodesk") and/or its licensors,
// which is protected by U.S. and Canadian federal copyright law and by
// international treaties.
//
// The Data is provided for use exclusively by You. You have the right to use,
// modify, and incorporate this Data into other products for purposes authorized 
// by the Autodesk software license agreement, without fee.
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND. AUTODESK
// DOES NOT MAKE AND HEREBY DISCLAIMS ANY EXPRESS OR IMPLIED WARRANTIES
// INCLUDING, BUT NOT LIMITED TO, THE WARRANTIES OF NON-INFRINGEMENT,
// MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE, OR ARISING FROM A COURSE 
// OF DEALING, USAGE, OR TRADE PRACTICE. IN NO EVENT WILL AUTODESK AND/OR ITS
// LICENSORS BE LIABLE FOR ANY LOST REVENUES, DATA, OR PROFITS, OR SPECIAL,
// DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES, EVEN IF AUTODESK AND/OR ITS
// LICENSORS HAS BEEN ADVISED OF THE POSSIBILITY OR PROBABILITY OF SUCH DAMAGES.

//
//
//
//
//
//
//  Creation Date:  Date
//
// Description:
//
//		This file contains procedures which can operate on a string
//		array to provide the functionality of a lookup table. 
//

proc int isEmptyRow(
	string $lookupTable[],
	int $numColumns,
	int $rowStart)
{
	//
	// Description:
	//	This procedure is called by lookupTableAddRow when it is looking for
	//	the best place to insert the new row.
	//	This procedure checks to see if all entries of the row are "".
	//	The $rowStart is an index into the string array, not into the table
	//	abstraction. As such, this procedure should not be exposed to users
	//	external to this file.
	//
	// Returns: 
	//	This procedure returns true if the row is empty, false if not.
	//

	int $i;
	int $isEmpty = true;

	for (
		$i = $rowStart; 
		($i < $rowStart + $numColumns) && $isEmpty; 
		$i++)
	{
		if ($lookupTable[$i] != "")
		{
			$isEmpty = false;
		}
	}

	return $isEmpty;
}

global proc lookupTablePrint(
	string $lookupTable[])
{
	//
	// Description:
	//	This procedure can be called at any time to output the contents of the
	//	lookup table in a somewhat coherent format.
	//

	int $i;

	print (uiRes("m_lookupTable.kBegin"));

	int $numColumns = $lookupTable[0];
	string $numColFmt = (uiRes("m_lookupTable.kNumCol"));
	print `format -s $numColumns $numColFmt`;

	print (uiRes("m_lookupTable.kColsAre"));
	for ($i = 0; $i < $numColumns; $i++)
	{
		print($lookupTable[$i + 1] + "\n");
	}
	print("\n");

	print (uiRes("m_lookupTable.kContentsAre"));
	for ($i = $numColumns + 1; $i < size($lookupTable); $i += $numColumns)
	{
		for ($j = $i; $j < $i + $numColumns; $j++)
		{
			print("\"" + $lookupTable[$j] + "\"\n");
		}
		print("\n");
	}
	print("\n");

	print (uiRes("m_lookupTable.kEnd"));
}

global proc lookupTableEdit(
	string $lookupTable[],
	string $keyColumnLabel,
	string $keyValue,
	string $editColumnLabel,
	string $editValue)
{
	//
	// Description:
	//	This procedure searches the lookup table for a rows containing
	//	$keyValue in the column labelled $keyColumnLabel. For each such row
	//	found, it then changes the value of the entry in the column labelled 
	//	$editColumnLabel to the value specified in $editValue.
	//
	//	If the $keyValue does not exist anywhere in the $keyColumnLabel column, 
	//	no changes are made to the lookup table, and no errors or warnings are
	//	produced. 
	//	

	// Verify that the key value is valid
	//
	if ($keyValue == "")
	{
		error -showLineNumber true (uiRes("m_lookupTable.kNonEmpty"));
	}

	int $numColumns = $lookupTable[0];
	int $keyColumnOffset = -1;
	int $editColumnOffset = -1;
	int $i;

	// Determine the offsets (from the start of the set of values which 
	// represent a row) at which we can find the key column and the lookup
	// column.
	//
	for ($i = 0; $i < $numColumns; $i++)
	{
		if ($lookupTable[$i + 1] == $keyColumnLabel)
		{
			$keyColumnOffset = $i;
		}
		else if ($lookupTable[$i + 1] == $editColumnLabel)
		{
			$editColumnOffset = $i;
		}
	}

	// Verify that valid key column and lookup column labels were specified
	//
	string $msg = (uiRes("m_lookupTable.kNoCol")); 

	if ($keyColumnOffset == -1)
	{
		error -showLineNumber true `format -s $keyColumnLabel $msg`;
	}
	else if ($editColumnOffset == -1)
	{
		error -showLineNumber true `format -s $editColumnLabel $msg`;
	}

	// Search through the lookup table string array looking for rows which
	// contain the key value in the key column. For each such row found, we 
	// change the value of the edit column in that row to the edit value.
	//
	for ($i = $numColumns + 1; $i < size($lookupTable); $i += $numColumns)
	{
		if ($lookupTable[$i + $keyColumnOffset] == $keyValue)
		{
			 $lookupTable[$i + $editColumnOffset] = $editValue;
		}
	}
}

global proc string lookupTableLookup(
	string $lookupTable[],
	string $keyColumnLabel,
	string $keyValue,
	string $lookupColumnLabel)
{
	//
	// Description:
	//	This procedure searches the lookup table for the first row containing
	//	$keyValue in the column labelled $keyColumnLabel. If such a row is
	//	found, it then returns the value of the entry in the column labelled
	//	$lookupColumnLabel of that row. 
	//
	// Returns: 
	//	This procedure returns the value of the entry in the $lookupColumnLabel
	//	column of the row whose $keyColumnLabel entry is $keyValue. 
	//
	//	If the $keyValue does not exist anywhere in the $keyColumnLabel column, 
	//	the return value is "".
	//

	// Verify that the key value is valid
	//
	if ($keyValue == "")
	{
		error -showLineNumber true (uiRes("m_lookupTable.kNonEmpty2"));
	}

	string $result = "";
	int $numColumns = $lookupTable[0];
	int $keyColumnOffset = -1;
	int $lookupColumnOffset = -1;
	int $i;

	// Determine the offsets (from the start of the set of values which 
	// represent a row) at which we can find the key column and the lookup
	// column.
	//
	for ($i = 0; $i < $numColumns; $i++)
	{
		if ($lookupTable[$i + 1] == $keyColumnLabel)
		{
			$keyColumnOffset = $i;
		}
		else if ($lookupTable[$i + 1] == $lookupColumnLabel)
		{
			$lookupColumnOffset = $i;
		}
	}

	// Verify that valid key column and lookup column labels were specified
	//
	string $msg = (uiRes("m_lookupTable.kNoCol2"));
	if ($keyColumnOffset == -1)
	{
		error -showLineNumber true `format -s $keyColumnLabel $msg`;
	}
	else if ($lookupColumnOffset == -1)
	{
		error -showLineNumber true `format -s $lookupColumnLabel $msg`; 
	}

	// Search through the lookup table string array looking for a row which
	// contains the key value in the key column. If such a row is found, we set
	// the result to be the value of the lookup column in that row.
	//
	for (
		$i = $numColumns + 1; 
		($i < size($lookupTable)) && ($result == ""); 
		$i += $numColumns)
	{
		if ($lookupTable[$i + $keyColumnOffset] == $keyValue)
		{
			$result = $lookupTable[$i + $lookupColumnOffset];
		}
	}

	return $result;
}

global proc int lookupTableRowExists(
	string $lookupTable[],
	string $keyColumnLabel,
	string $keyValue)
{
	//
	// Description:
	//	This procedure determines if there exists a row in the lookup table
	//	whose entry in column $keyColumnLabel is $keyValue.
	//
	// Returns: 
	//	This procedure returns true if such a row exists, and false if not.
	//

	// Because we are clever, we will use the lookupTableLookup() procedure to
	// perform this action. If there exists a row in which the value of the key
	// column is the key value, then a lookup of the value in the key column of
	// that row will be non-empty (because it will be the key value).
	//
	return (lookupTableLookup(
		$lookupTable, 
		$keyColumnLabel, 
		$keyValue,
		$keyColumnLabel) != "");
}

global proc lookupTableRemoveRow(
	string $lookupTable[],
	string $keyColumnLabel,
	string $keyValue)
{
	//
	// Description:
	//	This procedure removes all rows in the lookup table whose entry in the
	//	$keyColumnLabel column is $keyValue.
	//

	// Verify that the key value is valid
	//
	if ($keyValue == "")
	{
		error -showLineNumber true (uiRes("m_lookupTable.kNonEmpty3"));
	}

	int $numColumns = $lookupTable[0];
	int $keyColumnOffset = -1;
	int $i;

	// Determine the offsets (from the start of the set of values which 
	// represent a row) at which we can find the key column and the lookup
	// column.
	//
	for ($i = 0; $i < $numColumns; $i++)
	{
		if ($lookupTable[$i + 1] == $keyColumnLabel)
		{
			$keyColumnOffset = $i;
		}
	}

	// Verify that valid key column and lookup column labels were specified
	//
	if ($keyColumnOffset == -1)
	{
		string $msg = (uiRes("m_lookupTable.kNoCol3"));
		error -showLineNumber true `format -s $keyColumnLabel $msg`;
	}

	// Search through the lookup table string array looking for a row which
	// contains the key value in the key column. If such a row is found, we 
	// overwrite it with empty strings.
	// Rows which contain entirely empty strings are considered empty by the
	// procedures in this file. They are also candidates for being overwritten
	// when a new row is being added.
	//
	for ($i = $numColumns + 1; $i < size($lookupTable); $i += $numColumns)
	{
		if ($lookupTable[$i + $keyColumnOffset] == $keyValue)
		{
			int $j;

			for ($j = $i; $j < $i + $numColumns; $j++)
			{
				$lookupTable[$j] = "";
			}
		}
	}
}

global proc lookupTableAddRow(
	string $lookupTable[],
	string $row[])
{
	//
	// Description:
	//	This procedure adds a new row to the lookup table.
	//	The contents of the new row are specified by the $row[] string array.
	//

	int $numColumns = $lookupTable[0];

	// Verify that the row to be added has the proper number of entries
	//
	if (size($row) != $numColumns)
	{
		string $msg = (uiRes("m_lookupTable.kAttempted"));
		error -showLineNumber true `format -s (size($row)) -s $numColumns $msg`;
	}

	// Try to find an empty row in which we can place the values for the new 
	// row. 
	//
	int $i;
	int $j;

	for ($i = $numColumns + 1; $i < size($lookupTable); $i += $numColumns)
	{
		if (isEmptyRow($lookupTable, $numColumns, $i))
		{
			for ($j = 0; $j < $numColumns; $j++)
			{
				$lookupTable[$i + $j] = $row[$j];
			}
			return;
		}
	}

	// If we get to here, we could not find an empty row, we add new 
	// elements to the end of the lookup table string array.
	//
	for ($j = 0; $j < $numColumns; $j++)
	{
		$lookupTable[size($lookupTable)] = $row[$j];
	}
}

global proc lookupTableReset(
	string $table[])
{
	//
	// Description:
	//	This procedure is called when a script wants to clear the contents of
	//	a lookup table, without losing the structure (ie column labels).
	//	This method clears the lookup table of its contents, leaving the
	//	structure of the lookup table intact so that it can be used for further
	//	lookup table operations.
	//	The $table argument is expected to be a lookup table created using the
	//	lookupTable() procedure.
	//

	//
	// We will store the structure of the lookup table in a temporary string
	// arrary, then clear the lookup table string array and restore the
	// structure elements.
	//

	string $structure[];

	// The first entry of the table will be the number of columns, and we will
	// store it into the temporary structure array.
	//
	int $numColumns = $table[0];
	$structure[0] = $table[0];

	// The next $numColumns entries will be the column labels, which we will
	// also store into the temporary structure array.
	//
	for ($i = 0; $i < $numColumns; $i++)
	{
		$structure[$i + 1] = $table[$i + 1];
	}

	// Clear the lookup table array
	//
	clear($table);

	// Restore the structure of the lookup table to the lookup table
	// array
	//
	for ($i = 0; $i < size($structure); $i++)
	{
		$table[$i] = $structure[$i];
	}
}

global proc string[] lookupTableGetColumn(
	string $lookupTable[],
	string $columnLabel)
{
	//
	// Description:
	//	Retrieves the contents of a particular column in the 
	//	lookup table.  Useful for iterating over all entries
	//	in a lookup table.
	//

	if ($columnLabel == "")
	{
		error -showLineNumber true (uiRes("m_lookupTable.kNonEmpty4"));
	}

	string $result[];
	int $numColumns = $lookupTable[0];
	int $columnOffset = -1;
	int $i;

	// Determine the offsets (from the start of the set of values which 
	// represent a row) at which we can find the key column and the lookup
	// column.
	//
	for ($i = 0; $i < $numColumns; $i++)
	{
		if ($lookupTable[$i + 1] == $columnLabel)
		{
			$columnOffset = $i;
		}
	}

	// Verify that valid key column and lookup column labels were specified
	//
	if ($columnOffset == -1)
	{
		string $msg = (uiRes("m_lookupTable.kNoCol5"));
		error -showLineNumber true `format -s $columnLabel $msg`;
	}

	// Iterate through the table and extract all the entries
	// for the specified column.
	//
	for (
		$i = $numColumns + 1; 
		$i < size($lookupTable); 
		$i += $numColumns)
	{
		$result[size($result)] = $lookupTable[$i + $columnOffset];
	}

	return $result;
}

global proc lookupTable(
	string $table[],
	string $columnLabels[])
{
	//
	// Description:
	//	This procedure is called when a script wants to initialize a string
	//	array to be used as a lookup table.
	//	The $table[] argument to this procedure is a string array which is to
	//	be initialized for use as a lookup table. Typically a script will
	//	create a global string array for the purpose of using it as a lookup
	//	table. The same string array needs to be passed as the first argument
	//	to any of the other procedures in this file in order for them to
	//	operate on the lookup table.
	//	The $columnLabels[] argument is a string array containing the desired 
	// 	labels of the columns of the lookup table. These same labels will later
	// 	be used when performing operations on the table using other procedures 
	//	in this file.
	//
	//	This procedure initializes the string array so that it can be used as a
	//	lookup table. The details of this initialization are not meant to be
	//	known by the scripts which use the lookup table mechanism. You should
	//	only access the lookup table via the procedures provided in this file.
	//
	//	Any pre-existing contents of the $table[] string array will be
	//	destroyed.
	//

	// First, check to be sure the arguments are valid
	//
	if (size($columnLabels) < 2)
	{
		error -showLineNumber true (uiRes("m_lookupTable.kTwoCols"));
	}

	int $i;
	int $j;

	for ($i = 0; $i < size($columnLabels); $i++)
	{
		for ($j = $i + 1; $j < size($columnLabels); $j++)
		{
			if ($columnLabels[$i] == $columnLabels[$j])
			{
				string $msg = (uiRes("m_lookupTable.kDiffLabels"));
				error -showLineNumber true `format -s $columnLabels[$i] $msg`;
			}
		}
	}

	//
	// Now that we know the arguments are valid, we will set up the provided
	// array to be used as a lookup table.
	//

	// Clear out the contents of the table string array. For the lookup table
	// to work, it must be arranged in the proper format.
	//
	clear($table);

	// The first entry of the table will be the number of columns
	//
	$table[0] = size($columnLabels);

	// The next set of entries will be the column labels
	//
	for ($i = 0; $i < size($columnLabels); $i++)
	{
		$table[$i + 1] = $columnLabels[$i];
	}

	//
	// The rest of the string array will later be used to store the entries of
	// the rows of the lookup table.
	//
}
