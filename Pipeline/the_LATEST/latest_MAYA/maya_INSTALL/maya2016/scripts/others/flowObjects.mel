// Copyright (C) 1997-2014 Autodesk, Inc., and/or its licensors.
// All rights reserved.
//
// The coded instructions, statements, computer programs, and/or related
// material (collectively the "Data") in these files contain unpublished
// information proprietary to Autodesk, Inc. ("Autodesk") and/or its licensors,
// which is protected by U.S. and Canadian federal copyright law and by
// international treaties.
//
// The Data is provided for use exclusively by You. You have the right to use,
// modify, and incorporate this Data into other products for purposes authorized 
// by the Autodesk software license agreement, without fee.
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND. AUTODESK
// DOES NOT MAKE AND HEREBY DISCLAIMS ANY EXPRESS OR IMPLIED WARRANTIES
// INCLUDING, BUT NOT LIMITED TO, THE WARRANTIES OF NON-INFRINGEMENT,
// MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE, OR ARISING FROM A COURSE 
// OF DEALING, USAGE, OR TRADE PRACTICE. IN NO EVENT WILL AUTODESK AND/OR ITS
// LICENSORS BE LIABLE FOR ANY LOST REVENUES, DATA, OR PROFITS, OR SPECIAL,
// DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES, EVEN IF AUTODESK AND/OR ITS
// LICENSORS HAS BEEN ADVISED OF THE POSSIBILITY OR PROBABILITY OF SUCH DAMAGES.

//
//
//  Creation Date:  Dec. 4/96
//
//  Procedure Name:
//      flowObjects
//
//  Description:
//		Flows the objects on the selection list with the given
//	    command flags
//
//  Return Value:
//      int - number of objects flowed
//


//		Given the object, we first check to see if this object is already
//		animated by motion path animation with Follow On. It's a crude check:
//		we look to see if the 'rotate', 'rx', 'ry' or 'rz' attributes are
//		connected to a motion path node - if any of them are, then the object
//		is animated by a motion path, and the fact that
//		the rotate attribute is connected means that Follow is On.
//		If this is not true, we don't do the flow. The 'flow' command will do
//		more stringent checking.
//
//		Once we have found the motion path node, we look to see which of the
//		X, Y and Z local axes of the object is being used for the "Front" and
//		"Up" of the motion. Then we map the flowDivisions[Front,Up,Side]
//		accordingly to the X, Y and Z divisions for the flow command.
global proc int flowObject(string $object,
					int $front, int $up, int $side,
					int $aroundObject, int $localEffect,
					int $localFront, int $localUp, int $localSide)
{
	string $result[];
	string $resultX[];
	string $resultY[];
	string $resultZ[];

	// We're putting a 'catch' in here just in case the $object
	// does not have a "rotate" attribute and the 'listConnections'
	// would fail, so that we can exit gracefully.
	//
	if(catch ($result  = `listConnections ($object+".rotate")`)) {
		return 0;
	}
	if(catch ($resultX = `listConnections ($object+".rotateX")`)) {
		return 0;
	}
	if(catch ($resultY = `listConnections ($object+".rotateY")`)) {
		return 0;
	}
	if(catch ($resultZ = `listConnections ($object+".rotateZ")`))
	{
		return 0;
	}

	// Not animated by a motion path with follow
	//
	string $node;
	switch(0) {
	default:
		if( size($result) != 0 ) {
			$node = $result[0];
			$result = `ls -showType $node`;
			if ("motionPath" == $result[1])		break; 
		}
		// no motionPath node connected to the rotate attr

		if( size($resultX) != 0 ) {
			$node = $resultX[0];
			$result = `ls -showType $node`;
			if ("motionPath" == $result[1])	break;
		}
		// no motionPath node connected to the rotateX attr

		if( size($resultY) != 0 ) {
			$node = $resultY[0];
			$result = `ls -showType $node`;
			if ("motionPath" == $result[1])	break;
		}
		// no motionPath node connected to the rotateY attr

		if( size($resultZ) != 0 ) {
			$node = $resultZ[0];
			$result = `ls -showType $node`;
			if ("motionPath" == $result[1])		break;
		}
		// no motionPath node connected to the rotateZ attr

		return 0;
		break;
	}

	// Now that we have the motion path node, determine which of the
	// X, Y and Z are being used for the Front, Up and Side
	//
	int $frontAxis = `getAttr ($node+".frontAxis")`;
	int $upAxis = `getAttr ($node+".upAxis")`;
	int $Xdiv, $Ydiv, $Zdiv;
	int $Xeffect, $Yeffect, $Zeffect;

	switch ($frontAxis)
	{
		case 0:	// Front axis is X
			$Xdiv = $front;
			$Xeffect = $localFront;
			if ($upAxis == 1)
			{
				$Ydiv = $up;
				$Yeffect = $localUp;
				$Zdiv = $side;
				$Zeffect = $localSide;
			}
			else	// $upAxis is 2
			{
				$Zdiv = $up;
				$Zeffect = $localUp;
				$Ydiv = $side;
				$Yeffect = $localSide;
			}
			break;
		case 1: // Front axis is Y
			$Ydiv = $front;
			$Yeffect = $localFront;
			if ($upAxis == 0)
			{
				$Xdiv = $up;
				$Xeffect = $localUp;
				$Zdiv = $side;
				$Zeffect = $localSide;
			}
			else	// $up is 2
			{
				$Zdiv = $up;
				$Zeffect = $localUp;
				$Xdiv = $side;
				$Xeffect = $localSide;
			}
			break;
		case 2: // Front axis is Z
		default:
			$Zdiv = $front;
			$Zeffect = $localFront;
			if ($upAxis == 0)
			{
				$Xdiv = $up;
				$Xeffect = $localUp;
				$Ydiv = $side;
				$Yeffect = $localSide;
			}
			else	// $up is 1
			{
				$Ydiv = $up;
				$Yeffect = $localUp;
				$Xdiv = $side;
				$Xeffect = $localSide;
			}
			break;
	}

	evalEcho("flow -divisions "+$Xdiv+" "+$Ydiv+" "+$Zdiv+
		 " -objectCentered "+$aroundObject+
		 " -localCompute "+$localEffect+
		 " -localDivisions "+$Xeffect+" "+$Yeffect+" "+$Zeffect+" "+
		 $object);

	return 1;
}

global proc int flowObjects(int $front, int $up, int $side,
							int $aroundObject, int $localEffect,
							int $localFront, int $localUp, int $localSide)
{
	// For each object on the selection list, verify that it is
	// animated with a motion path with Follow on, and then do
	// the flow for that object.
	//
	int $processed = 0;
	string $result[] = `ls -sl -showType`;

	for ($i = 0; $i < size($result); $i += 2)
	{
		if ($result[$i+1] == "transform")
		{
			$processed +=
				flowObject($result[$i], $front, $up, $side, $aroundObject,
						   $localEffect, $localFront, $localUp, $localSide);
		}
	}

	if ($processed == 0)
	{
		warning( (uiRes("m_flowObjects.kNoneOfTheSel")));
	}

	return $processed;
}
