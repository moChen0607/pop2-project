// Copyright (C) 1997-2014 Autodesk, Inc., and/or its licensors.
// All rights reserved.
//
// The coded instructions, statements, computer programs, and/or related
// material (collectively the "Data") in these files contain unpublished
// information proprietary to Autodesk, Inc. ("Autodesk") and/or its licensors,
// which is protected by U.S. and Canadian federal copyright law and by
// international treaties.
//
// The Data is provided for use exclusively by You. You have the right to use,
// modify, and incorporate this Data into other products for purposes authorized 
// by the Autodesk software license agreement, without fee.
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND. AUTODESK
// DOES NOT MAKE AND HEREBY DISCLAIMS ANY EXPRESS OR IMPLIED WARRANTIES
// INCLUDING, BUT NOT LIMITED TO, THE WARRANTIES OF NON-INFRINGEMENT,
// MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE, OR ARISING FROM A COURSE 
// OF DEALING, USAGE, OR TRADE PRACTICE. IN NO EVENT WILL AUTODESK AND/OR ITS
// LICENSORS BE LIABLE FOR ANY LOST REVENUES, DATA, OR PROFITS, OR SPECIAL,
// DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES, EVEN IF AUTODESK AND/OR ITS
// LICENSORS HAS BEEN ADVISED OF THE POSSIBILITY OR PROBABILITY OF SUCH DAMAGES.

//
//
//  Creation Date:  November 25, 1996
//
//  Description:
//      This script provides an option box dialog for the softMod command.
//
//

//
//  Procedure Name:
//      setSoftModOptionVars
//
//  Description:
//		Initialize the option values. Because softMod is both a tool and
//      an action, we make this normally private function global so we
//      can share it between the tool and the action.
//
//  Input Arguments:
//		Whether to set the options to default values.
//
//  Return Value:
//      None.
//

global string $gSoftModFalloffModes[];

global proc setSoftModOptionVars(int $forceFactorySettings)
{
	if ( $forceFactorySettings || !`optionVar -exists softModToolMode` ) 
	{
		optionVar -intValue softModToolMode 1;
	}

	if ( $forceFactorySettings || !`optionVar -exists softModFalloffRadius` )
	{
		optionVar -floatValue softModFalloffRadius 5.0;
	}

	if ( $forceFactorySettings || !`optionVar -exists softModFalloffMode` )
	{
		optionVar -intValue softModFalloffMode 0;
	}

	if ( $forceFactorySettings || !`optionVar -exists softModPreserveHistory` )
	{
		optionVar -intValue softModPreserveHistory 0;
	}

	if ( $forceFactorySettings || !`optionVar -exists softModFalloffInX` )
	{
		optionVar -intValue softModFalloffInX 1;
	}

	if ( $forceFactorySettings || !`optionVar -exists softModFalloffInY` )
	{
		optionVar -intValue softModFalloffInY 1;
	}

	if ( $forceFactorySettings || !`optionVar -exists softModFalloffInZ` )
	{
		optionVar -intValue softModFalloffInZ 1;
	}

	if ( $forceFactorySettings || !`optionVar -exists softModFalloffAroundSelection` )
	{
		optionVar -intValue softModFalloffAroundSelection 0;
	}

	if ( $forceFactorySettings || !`optionVar -exists softModFalloffMasking` )
	{
		optionVar -intValue softModFalloffMasking 1;
	}

	if ( $forceFactorySettings || !`optionVar -exists softModFalloffCurveOptionVar` )
	{
		optionVar -rm "softModFalloffCurveOptionVar";
		optionVar -stringValueAppend "softModFalloffCurveOptionVar" "0,1,2";
		optionVar -stringValueAppend "softModFalloffCurveOptionVar" "1,0,2";
	}

	if ( $forceFactorySettings || !`optionVar -exists softModColorFeedback` )
	{
		optionVar -intValue softModColorFeedback 1;
	}

	global string $gSoftModFalloffModes[];
	if( size( $gSoftModFalloffModes ) == 0 )
		// These menu options MUST be in the same order as the enumerated 
		// values defined for TDNsoftMod::aFalloffMode
		$gSoftModFalloffModes = { uiRes("n_softMod.a_fom_enum_kVolumeFalloff"),
					  uiRes("n_softMod.a_fom_enum_kSurfaceFalloff") 
					};
}

//
//  Procedure Name:
//      softModSetup
//
//  Description:
//		Update the state of the option box UI to reflect the option values.
//
//  Input Arguments:
//      parent               - Top level parent layout of the option box UI.
//                             Required so that UI object names can be 
//                             successfully resolved.
//
//		forceFactorySettings - Whether the option values should be set to
//                             default values.
//
//  Return Value:
//      None.
//
global proc softModSetup( string $parent, int $forceFactorySettings )
{
	// Before we do anything, get any existing ramp widget to forget
	// about the optionVar it's using - or else it will just overwrite
	// the reset value we might try and assign in setSoftModOptionVars
	//
	gradientControlNoAttr -e -optionVar "" softModFalloffRamp;

	// Retrieve the option settings
	//
	setSoftModOptionVars ($forceFactorySettings);

	setParent $parent;

	float $radius = `optionVar -q softModFalloffRadius`;
	floatSliderGrp -e -value $radius softModFalloffRadiusWidget;

	int $falloffMode = `optionVar -q softModFalloffMode`;
	global string $gSoftModFalloffModes[];	
	optionMenuGrp -e -value $gSoftModFalloffModes[$falloffMode] softModFalloffModeWidget;
	
	int $falloffInX = `optionVar -q softModFalloffInX`;
	int $falloffInY = `optionVar -q softModFalloffInY`;
	int $falloffInZ = `optionVar -q softModFalloffInZ`;
	checkBoxGrp -e 
		-value1 $falloffInX
		-value2 $falloffInY
		-value3 $falloffInZ
		softModFalloffInWidget;

	int $colorFeedback = `optionVar -q softModColorFeedback`;
	checkBoxGrp -e -value1 $colorFeedback softModColorFeedbackWidget;

	int $history = `optionVar -q softModPreserveHistory`;
	checkBoxGrp -e -value1 $history softModPreserveHistoryWidget;

	int $hardMiddle = `optionVar -q softModFalloffAroundSelection`;
	checkBoxGrp -e -value1 $hardMiddle softModFalloffAroundSelectionWidget;

	int $masking = `optionVar -q softModFalloffMasking`;
	checkBoxGrp -e -value1 $masking softModFalloffMaskingWidget;

	gradientControlNoAttr -e
		-optionVar "softModFalloffCurveOptionVar"
		softModFalloffRamp;
}

//
//  Procedure Name:
//      SoftModCallback
//
//  Description:
//		Update the option values with the current state of the option box UI.
//
//  Input Arguments:
//      parent - Top level parent layout of the option box UI.  Required so
//               that UI object names can be successfully resolved.
//
//		doIt   - Whether the command should execute.
//
//  Return Value:
//      None.
//
global proc softModCallback( string $parent, int $doIt )
{
    setParent $parent;

	float $radius = `floatSliderGrp -q -value softModFalloffRadiusWidget`;
	optionVar -floatValue softModFalloffRadius $radius;

	string $falloffMode = `optionMenuGrp -q -value softModFalloffModeWidget`;
	global string $gSoftModFalloffModes[];
	int $falloffModeIdx = size( $gSoftModFalloffModes ) - 1;
	while( $falloffModeIdx > 0 )
	{
		if( $falloffMode == $gSoftModFalloffModes[ $falloffModeIdx ])
			break;
		$falloffModeIdx--;
	}
	optionVar -intValue softModFalloffMode $falloffModeIdx;

	int $colorFeedback = `checkBoxGrp -q -value1 softModColorFeedbackWidget`;
	optionVar -intValue softModColorFeedback $colorFeedback;

	int $preserveHistory = `checkBoxGrp -q -value1 softModPreserveHistoryWidget`;
	optionVar -intValue softModPreserveHistory $preserveHistory;

	int $hardMiddle = `checkBoxGrp -q -value1 softModFalloffAroundSelectionWidget`;
	optionVar -intValue softModFalloffAroundSelection $hardMiddle;

	int $masking = `checkBoxGrp -q -value1 softModFalloffMaskingWidget`;
	optionVar -intValue softModFalloffMasking $masking;
 
	int $falloffInX = `checkBoxGrp -q -value1 softModFalloffInWidget`;
	int $falloffInY = `checkBoxGrp -q -value2 softModFalloffInWidget`;
	int $falloffInZ = `checkBoxGrp -q -value3 softModFalloffInWidget`;
	optionVar -intValue softModFalloffInX $falloffInX;
	optionVar -intValue softModFalloffInY $falloffInY;
	optionVar -intValue softModFalloffInZ $falloffInZ;

	if ($doIt) 
	{
		performSoftMod 0 0 0 { 0.0, 0.0, 0.0 }; 
		addToRecentCommandQueue "performSoftMod 0 0 0 { 0.0, 0.0, 0.0 }" "SoftMod";
	}
}

//
//  Procedure Name:
//      SoftModTabUI
//
//  Description:
//		This is an example of how to delay the creation of the tab UI.
//		The contents of each tab is created only when it is required,
//		ie. if the tab is initially visible or if the tab is selected
//		by the user.
//
//  Input Arguments:
//      The name of the tab layout.
//
//  Return Value:
//      None.
//
global proc softModUI( string $layout )
{
	setParent $layout;

	//	Activate the default UI template so that the layout of this 
	//	option box is consistent with the layout of the rest of the 
	//	application.
	//
	setUITemplate -pushTemplate DefaultTemplate;

	//	Turn on the wait cursor.
	//
	waitCursor -state 1;

	// Linux Motif2.1 shrinks the checkBox, if the string is ""
	// NT would tab over the blank (" ") string label.
	// So...
	string $emptyLabel = "";
	if (`about -linux`) {
		$emptyLabel = " ";
	}

	floatSliderGrp
		-label (uiRes("m_performSoftMod.kFalloffRadius")) 
		-field true
		-min 0
		-max 100
		-pre 2
		softModFalloffRadiusWidget;

	rowLayout -nc 2;	
		text -label (uiRes("m_performSoftMod.kFalloffCurve"));			
		gradientControlNoAttr
			-h 90
			softModFalloffRamp;
	setParent ..;
			
	optionMenuGrp
		-label (uiRes("m_performSoftMod.kFalloffMode")) 
		softModFalloffModeWidget;
	int $i;
	global string $gSoftModFalloffModes[];
	for( $i = 0; $i < size( $gSoftModFalloffModes ); $i++)
		menuItem -label $gSoftModFalloffModes[ $i];
	
	checkBoxGrp
		-label (uiRes("m_performSoftMod.kColorFeedback"))
		-numberOfCheckBoxes 1
		-label1 $emptyLabel
		softModColorFeedbackWidget;

	checkBoxGrp
		-label (uiRes("m_performSoftMod.kPreserveHistory")) 
		-numberOfCheckBoxes 1
		-label1 $emptyLabel
		softModPreserveHistoryWidget;

	checkBoxGrp
		-label (uiRes("m_performSoftMod.kMaskUnselected")) 
		-numberOfCheckBoxes 1
		-label1 $emptyLabel
		softModFalloffMaskingWidget;

	checkBoxGrp
		-label (uiRes("m_performSoftMod.kFalloffAroundSelection")) 
		-numberOfCheckBoxes 1
		-label1 $emptyLabel
		softModFalloffAroundSelectionWidget;
			
	checkBoxGrp
		-label (uiRes("m_performSoftMod.kFalloffBasedOn")) 
		-label1 (uiRes("m_performSoftMod.kXAxis")) 
		-label2 (uiRes("m_performSoftMod.kYAxis")) 
		-label3 (uiRes("m_performSoftMod.kZAxis")) 
		-numberOfCheckBoxes 3
		softModFalloffInWidget;


	//	Update the control values to match the options.
	//
	eval ( ( "softModSetup " + $layout + " " + 0 ) );

	//	Turn off the wait cursor.
	//
	waitCursor -state 0;
	
	//	Deactivate the default UI template.
	//
	setUITemplate -popTemplate;
}

//
//  Procedure Name:
//      softModOptions
//
//  Description:
//		Construct the option box UI.  Involves accessing the standard option
//		box and customizing the UI accordingly.
//
//  Input Arguments:
//      None.
//
//  Return Value:
//      None.
//
proc softModOptions()
{
	//	Name of the command for this option box.
	//
	string $commandName = "softMod";

	//	Build the option box actions.
	//
	string $callback = ($commandName + "Callback");
	string $setup = ($commandName + "Setup");

	//	STEP 1:  Get the option box.
	//	============================
	//
	//  The value returned is the name of the layout to be used as
	//	the parent for the option box UI.
	//
	global string $gOptionBoxActionToolItem;
	$gOptionBoxActionToolItem = "softModToolMode";
	global string $gOptionBoxActionToolItemCB;
	$gOptionBoxActionToolItemCB = "performSoftMod 1 0 0 { 0.0, 0.0, 0.0 }";

	string $layout = getOptionBox();
	setParent $layout;
	
	//	STEP 2:  Pass the command name to the option box.
	//	=================================================
	//
	//	Any default option box behaviour based on the command name is set 
	//	up with this call.  For example, updating the 'Help' menu item with
	//	the name of the command.
	//
	setOptionBoxCommandName($commandName);

	//	STEP 3:  Activate the default UI template.
	//	==========================================
	//
	//	Activate the default UI template so that the layout of this 
	//	option box is consistent with the layout of the rest of the 
	//	application.
	//
	//	Note: this option box example delays the creation of the UI
	//	until it's required.  Therefore this step is moved to the
	//	procedure where the UI is actually created. 
	//
	//setUITemplate -pushTemplate DefaultTemplate;

	//	STEP 4: Create option box contents.
	//	===================================
	//	
	//	This, of course, will vary from option box to option box.	
	
	//	Demonstrate the delaying of UI creation via tab layouts.
	//	Instead of creating all of the option box UI initially, only
	//	create that which is initially visible.  Wait, until the 
	//	other tabs are selected to create the remaining UI.
	//
	string $scrollLayout = `scrollLayout`;
	string $columnLayout = `columnLayout -rowSpacing 5`;

	//	Create the UI
	//
	softModUI( $columnLayout );

	//	Step 5: Deactivate the default UI template.
	//  ===========================================
	//
	//	Note: this option box example delays the creation of the UI
	//	until it's required.  Therefore this step is moved to the
	//	procedure where the UI is actually created.
	//
	//	See also Step 2. 
	//
	//setUITemplate -popTemplate;

	//	Step 6: Customize the buttons.  
	//	==============================
	//
	//	Provide more descriptive labels for the buttons.  This is not 
	//	necessary, but in some cases, for example, a button labelled 
	//	'Create' may be more meaningful to the user than one labelled
	//	'Apply'.
	//
	//  Disable those buttons that are not applicable to the option box.
	//
	//	Attach actions to those buttons that are applicable to the option
	//	box.  Note that the 'Close' button has a default action attached 
	//	to it that will hide the window.  If a a custom action is
	//	attached to the 'Close' button then be sure to call the 'hide the
	//	option box' procedure within the custom action so that the option
	//	box is hidden properly.

	//	'Apply' button.
	//
	string $applyBtn = getOptionBoxApplyBtn();
	button -edit
		-label (uiRes("m_performSoftMod.kSoftModification")) 
		-command ($callback + " " + $columnLayout + " " + 1)
		$applyBtn;

	//	'Save' button.
	//
	string $saveBtn = getOptionBoxSaveBtn();
	button -edit 
		-command ($callback + " " + $columnLayout + " " + 0 + "; hideOptionBox")
		$saveBtn;

	//	'Reset' button.
	//
	string $resetBtn = getOptionBoxResetBtn();
	button -edit 
		-command ($setup + " " + $columnLayout + " " + 1)
		$resetBtn;

	//	Step 7: Set the option box title.
	//	=================================
	//
	setOptionBoxTitle (uiRes("m_performSoftMod.kSoftModificationOptions"));


	//	Step 8: Customize the 'Help' menu item text.
	//	============================================
	//
	setOptionBoxHelpTag( "CreateSoftModDeformer" );

	//	Step 9: Set the current values of the option box.
	//	=================================================
	//
	//	NOTE:  Can not do this here since we do not know what UI is
	//	currently visible.  This is moved to where the UI is created.
	//
	//eval (($setup + " " + $tabLayout + " " + 0));	
	
	//	Step 10: Show the option box.
	//	=============================
	//
	showOptionBox();
}

//
//  Procedure Name:
//      SoftModHelp
//
//  Description:
//		Return a short description about this command.
//
//  Input Arguments:
//      None.
//
//  Return Value:
//      string.
//
proc string softModHelp()
{

	return 
	"  Command: softMod";	
}

//
//  Procedure Name:
//      assembleCmd
//
//  Description:
//		Construct the command that will apply the option box values.
//
//  Input Arguments:
//      None.
//
//  Return Value:
//      string	cmd				: Assembled "SoftMod ..." command
//		string	""				: An error occured (and was reported to the user)
//
proc string assembleCmd( int $useSuppliedCenter, float $suppliedCenter[] )
{
	global string $gSoftMod;
	string $cmd;
	
	setSoftModOptionVars(false);

	if ( `currentCtx` != $gSoftMod )
	{
		int $softModToolMode = `optionVar -query softModToolMode`;
		if ( $softModToolMode )
		{
			$cmd = "setToolTo $gSoftMod";
			return $cmd;
		}
	}

	$cmd = "softMod ";

	$cmd += "-falloffRadius ";
	$cmd += `optionVar -q softModFalloffRadius`;
	$cmd += " ";

	$cmd += "-falloffMode ";
	$cmd += `optionVar -q softModFalloffMode`;
	$cmd += " ";

	string $ls[] = `ls -sl -type double3 -type float3`;
	if ( $useSuppliedCenter && `size $ls` == 0 )
	{
		$cmd += "-falloffCenter ";
		$cmd += $suppliedCenter[ 0 ];
		$cmd += " ";
		$cmd += $suppliedCenter[ 1 ];
		$cmd += " ";
		$cmd += $suppliedCenter[ 2 ];
		$cmd += " ";
	}
	else
	{
		float $bbox[] = `exactWorldBoundingBox`;
		float $center[] = { ( $bbox[ 0 ] + $bbox[ 3 ] ) / 2.0,
							( $bbox[ 1 ] + $bbox[ 4 ] ) / 2.0,
							( $bbox[ 2 ] + $bbox[ 5 ] ) / 2.0 };

		$cmd += "-falloffCenter ";
		$cmd += $center[ 0 ];
		$cmd += " ";
		$cmd += $center[ 1 ];
		$cmd += " ";
		$cmd += $center[ 2 ];
		$cmd += " ";
	}

	if ( `optionVar -exists softModFalloffCurveOptionVar` )
	{
		string $falloffPoints[] = `optionVar -q softModFalloffCurveOptionVar`;
		for ( $point in $falloffPoints )
		{
			string $values[];
			int $n = `tokenize $point "," $values`;
			if ( $n != 3 ) continue;

			$cmd += ( "-curveValue " + $values[0] + " " );
			$cmd += ( "-curvePoint " + $values[1] + " " );
			$cmd += ( "-curveInterpolation " + $values[2] + " " );
		}
	}

	$cmd += "-falloffBasedOnX ";
	$cmd += `optionVar -q softModFalloffInX`;
	$cmd += " ";
	$cmd += "-falloffBasedOnY ";
	$cmd += `optionVar -q softModFalloffInY`;
	$cmd += " ";
	$cmd += "-falloffBasedOnZ ";
	$cmd += `optionVar -q softModFalloffInZ`;
	$cmd += " ";
	$cmd += "-falloffAroundSelection ";
	$cmd += `optionVar -q softModFalloffAroundSelection`;
	$cmd += " ";
	$cmd += "-falloffMasking ";
	$cmd += `optionVar -q softModFalloffMasking`;
	$cmd += " ";

	return $cmd;
}


proc int reuseSoftMod( string $nodes[], int $useSuppliedCenter, float $suppliedCenter[] )
// 
// Description:
// Returns true if a softMod has the identity transform and is first in the
// history chain (i.e. closest to the selected shape).  If the return value
// is true then:
//		$nodes[0] = the softMod node name
//		$nodes[1] = the softModHandle tranfsorm node name
// If components are selected this function will always return false.
// 
{
	clear $nodes;

	int $components = 0;
	string $transforms[] = `ls -type transform -sl`;
	if ( `size $transforms` == 0 )
	{
		$lsComponents = `ls -sl -type double3 -type float3`;
		if ( `size $lsComponents` > 0 )
		{
			$components = 1;
		}
		$transforms = `ls -objectsOnly -sl`;
	}

	string $mainSoftMod = "";
	string $mainSoftModHandle = "";
	string $mainSoftModHandleShape = "";
	for ( $transform in $transforms )
	{
		string $ls[] = `listHistory $transform`;
		if ( `size $ls` > 1 )
		{
			// has history
			if ( `nodeType $ls[1]` == "softMod" )
			{
				// softMod first in history
				float $matrix[] = getAttr ( $ls[1] + ".matrix" );
				if ( $matrix[0] == 1 && $matrix[1] == 0 && $matrix[2] == 0 && $matrix[3] == 0 && 
					 $matrix[4] == 0 && $matrix[5] == 1 && $matrix[6] == 0 && $matrix[7] == 0 && 
					 $matrix[8] == 0 && $matrix[9] == 0 && $matrix[10] == 1 && $matrix[11] == 0 && 
					 $matrix[12] == 0 && $matrix[13] == 0 && $matrix[14] == 0 && $matrix[15] == 1 )
				{
					if ( $mainSoftMod == "" )
					{
						$mainSoftMod = $ls[1];
					}
					else if ( $mainSoftMod != $ls[1] )
					{
						return 0;
					}
					
					string $handle = `connectionInfo -sfd ( $ls[1] + ".matrix" )`;
					string $tokenizedList[];
					tokenize $handle "." $tokenizedList;
					if ( $mainSoftModHandle == "" )
					{
						$mainSoftModHandle = $tokenizedList[0];
					}
					else if ( $mainSoftModHandle != $tokenizedList[0] )
					{
						return 0;
					}

					string $handleShape = `connectionInfo -sfd ( $ls[1] + ".softModXforms" )`;
					tokenize $handleShape "." $tokenizedList;
					$mainSoftModHandleShape = $tokenizedList[0];
				}
				else
				{
					return 0;
				}
			}
			else
			{
				return 0;
			}
		}
		else
		{
			return 0;
		}
	}

	$nodes[0] = $mainSoftMod;
	$nodes[1] = $mainSoftModHandle;
	string $connections[] = `listConnections ( $mainSoftMod + ".message" )`;
	string $set[] = `ls -type objectSet $connections`;
	if ( `size $set` > 0 )
	{
		sets -clear $set[0];
		if ( $components )
		{
			sets -forceElement $set[0] `ls -sl -type double3 -type float3`;
		}
		else
		{
			sets -forceElement $set[0] `ls -sl`;
		}
	}
	string $ls[] = `ls -sl -type double3 -type float3`;
	if ( $useSuppliedCenter && `size $ls` == 0 )
	{
		softMod -e 
			-falloffCenter $suppliedCenter[0] $suppliedCenter[1] $suppliedCenter[2]
			$mainSoftMod;

		setAttr ( $mainSoftModHandleShape + ".origin" ) $suppliedCenter[0] $suppliedCenter[1] $suppliedCenter[2];
		setAttr ( $mainSoftModHandle + ".scalePivot" ) $suppliedCenter[0] $suppliedCenter[1] $suppliedCenter[2];
		setAttr ( $mainSoftModHandle + ".rotatePivot" ) $suppliedCenter[0] $suppliedCenter[1] $suppliedCenter[2];
	}
	else
	{
		float $bbox[] = `exactWorldBoundingBox`;
		float $center[] = { ( $bbox[ 0 ] + $bbox[ 3 ] ) / 2.0,
							( $bbox[ 1 ] + $bbox[ 4 ] ) / 2.0,
							( $bbox[ 2 ] + $bbox[ 5 ] ) / 2.0 };
		
		softMod -e 
			-falloffCenter $center[0] $center[1] $center[2]
			$mainSoftMod;

		setAttr ( $mainSoftModHandleShape + ".origin" ) $center[0] $center[1] $center[2];
		setAttr ( $mainSoftModHandle + ".scalePivot" ) $center[0] $center[1] $center[2];
		setAttr ( $mainSoftModHandle + ".rotatePivot" ) $center[0] $center[1] $center[2];
	}
	
	// Now, write the current UI settings into the node we're reusing ...
	//
	setAttr ( $mainSoftMod + ".falloffRadius" ) `optionVar -q softModFalloffRadius`;
	setAttr ( $mainSoftMod + ".falloffMode" ) `optionVar -q softModFalloffMode`;
	setAttr ( $mainSoftMod + ".falloffInX" ) `optionVar -q softModFalloffInX`;
	setAttr ( $mainSoftMod + ".falloffInY" ) `optionVar -q softModFalloffInY`;
	setAttr ( $mainSoftMod + ".falloffInZ" ) `optionVar -q softModFalloffInZ`;
	setAttr ( $mainSoftMod + ".falloffAroundSelection" ) `optionVar -q softModFalloffAroundSelection`;
	setAttr ( $mainSoftMod + ".falloffMasking" ) `optionVar -q softModFalloffMasking`;
	return 1;
}


//
//  Procedure Name:
//      performSoftMod
//
//  Description:
//		Perform the SoftMod command using the corresponding 
//		option values.  This procedure will also show the option box
//		window if necessary as well as construct the command string
//		that will invoke the SoftMod command with the current
//		option box values.
//
//  Input Arguments:
//      0 - Execute the command.
//      1 - Show the option box dialog.
//
//  Return Value:
//      None.
//
global proc string[] performSoftMod(int $action, int $tryToReuse, int $useSuppliedCenter, float $suppliedCenter[])
{
	string $cmd = "";
	string $result[];

	// If the user has selected individual components, convert the selection to vertices
	// in case user has selected some other components; non-poly selection (nurbs, 
	// particles etc. should be unharmed by this)
	//
	string $shapes[] = `ls -sl -typ "shape" -typ "transform"`;
	if( `size $shapes` == 0)
		ConvertSelectionToVertices;

	//	Retrieve the option settings
	//
	setSoftModOptionVars( false);
	
	switch ($action) {

		//	Execute the command.
		//
		case 0:			
			//	Get the command.
			//
			$cmd = `assembleCmd $useSuppliedCenter $suppliedCenter`;

			//	Execute the command with the option settings.
			//
			if ( $cmd != "" )
			{
				string $nodes[];
				if ( $tryToReuse )
				{
					int $reuseAvailable = `reuseSoftMod $result $useSuppliedCenter $suppliedCenter`;
					if ( !$reuseAvailable )
					{
						$result = eval($cmd);
					}
					else
					{
						select $result[1];
					}
				}
				else 
				{
					$result = eval($cmd);
				}
			}
			break;

		//	Show the option box.
		//
		case 1:
			softModOptions;
			break;

	}
	return $result;
}


