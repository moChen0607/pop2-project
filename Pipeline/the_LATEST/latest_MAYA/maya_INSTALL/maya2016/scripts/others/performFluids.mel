// Copyright (C) 1997-2014 Autodesk, Inc., and/or its licensors.
// All rights reserved.
//
// The coded instructions, statements, computer programs, and/or related
// material (collectively the "Data") in these files contain unpublished
// information proprietary to Autodesk, Inc. ("Autodesk") and/or its licensors,
// which is protected by U.S. and Canadian federal copyright law and by
// international treaties.
//
// The Data is provided for use exclusively by You. You have the right to use,
// modify, and incorporate this Data into other products for purposes authorized 
// by the Autodesk software license agreement, without fee.
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND. AUTODESK
// DOES NOT MAKE AND HEREBY DISCLAIMS ANY EXPRESS OR IMPLIED WARRANTIES
// INCLUDING, BUT NOT LIMITED TO, THE WARRANTIES OF NON-INFRINGEMENT,
// MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE, OR ARISING FROM A COURSE 
// OF DEALING, USAGE, OR TRADE PRACTICE. IN NO EVENT WILL AUTODESK AND/OR ITS
// LICENSORS BE LIABLE FOR ANY LOST REVENUES, DATA, OR PROFITS, OR SPECIAL,
// DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES, EVEN IF AUTODESK AND/OR ITS
// LICENSORS HAS BEEN ADVISED OF THE POSSIBILITY OR PROBABILITY OF SUCH DAMAGES.

//
//
//  Cloning Date:  Feb, 2001
//
//  Description:
//     This is one of five scripts used to implement menus and option boxes for
//  the Fluids menu.  The five scripts are:
//
//    dynCreateFluidLayout - makes the layout of the option boxes, declares the controls
//    dynFluidCallbacks- callback routines to set values of option vars from
//                      the option controls.
//    performFluids - generates command lines which are invoked when a menu item
//                      is selected or dragged to the shelf.
//    dynSetFluidOptionVars - sets default values of option variables (the variables which
//                      store the user's values for the option boxes)
//    dynSetFluidOptionControls - sets values of the option box controls from the option vars.
//                      Sort of the inverse of dynApplyCallback.
//
//    All the data is actually stored in option vars.  These routines basically pass
//    the option vars around.  The flow is:
//
//    User brings up option box: 
//        dynCreateLayout sets up the option controls. (Done only once.) 
//        dynSetOptionVars creates option vars and sets factory defaults,
//           if the variables don't already exist. (If the variables have been
//           saved with the user's prefs, they are automatically read from there.)
//		  dynSetOptionControls reads values from option vars, sets 
//           option box controls accordingly.
//
//    User changes control:  
//        dynApplyCallback stores values in option vars 
//
//    User hits Create:  
//        performFluids reads values from option vars, generates command
//      
//  
//  NOTE: There are frequent references in this script to "create" and "add."  These
//  are artifacts of this script's origin as part of performDynamics, and may not
//	be actually doing anything since the scripts diverged.
//
//  Input Arguments to performFluids():
//		$createFlag:	1 = create field/emitter 
//						0 = add field/emitter/collision/goal
//						2 = create/add not relevant
//						3 = do some fluids thing as disting from other dynamics
//
//		string $type      -- the command selected
//		int    $optionBox -- bring up the option box or not
//
//  Return Value:
//      None.
//
//

//  ========== createFluidsOptions ==========
//
//  SYNOPSIS
//      Create the Dynamics option box and option vars,
//		and set up the appropriate layout for the selected
//		command.
//
global proc createFluidsOptions (string $type, int $createFlag)
{
	// Title of the option box.
	//
	string $optionBoxTitle;
	string $optionBoxHelpTag;

	// Used in the setOptionsControls command to tell whether to reset
	// the option vars and controls to their default values if the
	// option vars already exist.
	//
	int $resetToDefaults;

	// Name and arguments of the call to set the values of the option
	// box controls.
	//
	string $setOptionControls = "dynSetFluidOptionControls ";

	// Name and arguments of the callback, called when the Create/Add
	// button is selected, that sets the option vars from the controls
	// and calls performFluids to execute the command.
	//
	string $applyCallback = "dynApplyCallback " + $type;

	// $type = name of the command (with initial capital letter)
	// for this option box 
	// For emitters, label according to whether we are creating
	// a positional or emitting from an object.
	//
	if ($type == "Emitter")
	{
		$optionBoxHelpTag = "AddContentsEmitter";
		if ($createFlag == 1) {
			$optionBoxTitle = (uiRes("m_performFluids.kCreateOptionTitle"));
		} else if ($createFlag == 0) {
			$optionBoxTitle = (uiRes("m_performFluids.kEmitFromObjectOptionTitle"));
		}
	} else {
		$setOptionControls = $setOptionControls + $type;

		// Set the option box title.  Note that option boxes
		// that don't get their titles set here are created
		// through their own perform* scripts.  (The FluidClear
		// option box, for instance, is created via 
		// performDeleteFluidsIC.mel.)
		//
		if ($type == "Create3DFluid") {
			$optionBoxTitle = (uiRes("m_performFluids.kCreate3DContainerOptions"));
			$optionBoxHelpTag = "CreateContainer";
		} else if ($type == "Create2DFluid") {
			$optionBoxTitle = (uiRes("m_performFluids.kCreate2DContainerOptions"));
			$optionBoxHelpTag = "CreateContainer";
		} else if ($type == "FluidEmitter") {
			$optionBoxTitle = (uiRes("m_performFluids.kEmitterOptions"));
			$optionBoxHelpTag = "AddContentsEmitter";
		} else if ($type == "FluidEmitFromObject") {
			$optionBoxTitle = (uiRes("m_performFluids.kEmitFromObjectOptions"));
			$optionBoxHelpTag = "EmitFluidFromObject";
		} else if ($type == "2DFluidAndEmitter") {
			$optionBoxTitle = (uiRes("m_performFluids.kCreate2DContainerEmitter"));
			$optionBoxHelpTag = "CreateContainerWithEmitter";
		} else if ($type == "3DFluidAndEmitter") {
			$optionBoxTitle = (uiRes("m_performFluids.kCreate3DContainerEmitter"));
			$optionBoxHelpTag = "CreateContainerWithEmitter";
		} else if ($type == "ExtendFluid") {
			$optionBoxTitle = (uiRes("m_performFluids.kExtendFluidOptions"));
			$optionBoxHelpTag = "ExtendFluid";
		} else if ($type == "ResampleFluid") {
			$optionBoxTitle = (uiRes("m_performFluids.kEditFluidResolutionOptions"));
			$optionBoxHelpTag = "EditFluidResolution";
		} else if ($type == "MakeCollideFluid") {
			$optionBoxTitle = (uiRes("m_performFluids.kMakeCollideOptions"));
			$optionBoxHelpTag = "MakeFluidCollide";
		} else {
			string $err = (uiRes("m_performFluids.kCreateFluidsOptionsError"));
			error(`format -s $type $err`);
		}
	}

	// Set the title for the apply button
	// 
	string $applyButtonTitle;
	$applyButtonTitle = (uiRes("m_performFluids.kApply"));
	
	// Get the parent option box layout and set to it.
	//
	string $layout = getOptionBox();
	setParent $layout;

	// Build the window, with a tab layout
	//
	setUITemplate -pushTemplate DefaultTemplate;
	waitCursor -state 1;

	tabLayout -scr true -tv false;
	string $parent = `columnLayout -adjustableColumn 1`;

	// Create the layout for this option box.
	//
	dynCreateLayout $parent $type $createFlag;

	waitCursor -state 0;
	setUITemplate -popTemplate;

	// Get and set the title and callback for the standard buttons.
	//
	int $executeCmd1;

    string $applyBtn = getOptionBoxApplyBtn();

	// Set up "apply" button with callback for executing the command.
	//
	$executeCmd = 1;
    button -edit
		-label $applyButtonTitle
        -command ($applyCallback + " " + $parent + " " + $executeCmd)
        $applyBtn;

    //  'Save' button.
    //
	// Set up "Save" button, to save the option vars, 
	// but not execute the command.
	//
	$executeCmd = 0;
    string $saveBtn = getOptionBoxSaveBtn();
    button -edit
        -command ($applyCallback + " " + $parent + " " + $executeCmd + "; hideOptionBox")
        $saveBtn;

    // Set up 'Reset' button to reset the option vars and controls 
	// to their default values.
    //
    string $resetBtn = getOptionBoxResetBtn();

	// The last arg means do reset the option controls and vars to their
	// default value.
	//
	$resetToDefaults = 1;
    button -edit
        -command ($setOptionControls + " " + $parent + " " + $resetToDefaults)
        $resetBtn;

	setOptionBoxTitle($optionBoxTitle);

    //  Set up for help
	//
	string $realCommandName = $type;

	//	Customize the 'Help' menu item text.
	//
	setOptionBoxHelpTag( $optionBoxHelpTag );

	switch ($type) 
	{
		case "ExtendFluid":
			$realCommandName = "extendFluid";
			break;		
		case "ResampleFluid":
			$realCommandName = "resampleFluid";
			break;
		case "FluidEmitFromObject":
			$realCommandName = "fluidEmitter";
			break;
		case "FluidEmitter":
			$realCommandName = "fluidEmitter";
			break;
		case "Emitter":
			if ($createFlag == 1) {
				setOptionBoxHelpTag( "CreateEmitter" );
			} else if ($createFlag == 0) {
				setOptionBoxHelpTag( "EmitfromObject" );
			}
			break;

	}	

	// Call the "method" to set the values of the option box controls.
	//
	// The last arg means do not reset the option controls and vars to their
	// default value if they already exist.  Just use the current values.
	//
	$resetToDefaults = 0;
	eval (($setOptionControls + " " + $parent + " " + $resetToDefaults));      

	showOptionBox();
}

//  ================== fluidSetName ==================
//
//  SYNOPSIS
//		Set the name (-n) command arg, if a name has been specified.
//		An ugly cone of dynSetName, could be put in a file of is own?
//
global proc string fluidSetName(string $theCmd)
{
	string $controlName = $theCmd+"Name";
	string $name = `optionVar -query $controlName`;

	// GG: strip out beginning spaces
	$name = match("[^ ].+", $name);
	if (size($name) > 0)
		$returnCmd = " -name \\\""+$name+"#\\\" ";

	return $returnCmd;
}

proc string flEmitterType_uiToMel(string $ui)
{
	string $mel = $ui;
	
	if( $ui == (uiRes("m_dynCreateFluidLayout.kOmni")) ) {
		$mel = "Omni";
	} else if( $ui == (uiRes("m_dynCreateFluidLayout.kVolume")) ) {
		$mel = "Volume";	
	} else if( $ui == (uiRes("m_dynCreateFluidLayout.kSurface")) ) {
		$mel = "Surface";
	} else if( $ui == (uiRes("m_dynCreateFluidLayout.kCurve")) ) {
		$mel = "Curve";	
	} else {
		uiToMelMsg( "flEmitterType_uiToMel", $ui, 1 );
	}
	
	return $mel;
}

//  ============== setFluidEmitterCmdString ==============
//
//  SYNOPSIS
//		Set the command and command args string for the emitter command.
//
global proc string setFluidEmitterCmdString()
{
	string $cmd = "fluidEmitter -pos 0 0 0 ";

	string $typeChoice = `optionVar -query flEmitterTypeOM`;
	$typeChoice = tolower( flEmitterType_uiToMel($typeChoice) );
	$cmd = $cmd + "-type " + $typeChoice + " ";
	$cmd = $cmd + fluidSetName("flEmitter");

	$cmd = $cmd + "-der "+`optionVar -query flEmitterDensityRate`+" ";
	$cmd = $cmd + "-her "+`optionVar -query flEmitterHeatRate`+" ";
	$cmd = $cmd + "-fer "+`optionVar -query flEmitterFuelRate`+" ";
	$cmd = $cmd + "-fdr "+`optionVar -query flEmitterFluidDropoff`+" ";
	$cmd = $cmd + "-r 100.0 ";

	int $cycleOption = `optionVar -query flEmitterCycleOM`;
	string $cycleString = "none";
	switch( $cycleOption )
	{
		case 1:
			$cycleString = "none";
			break;
		case 2:
			$cycleString = "frame";
			break;
		//case 3:
		//	$cycleString = "count";
		//	break;
	}

	$cmd = $cmd + "-cye "+ $cycleString + " ";
	$cmd = $cmd + "-cyi "+`optionVar -query flEmitterCycleInterval`+" ";

	$cmd = $cmd + "-mxd "+`optionVar -query flEmitterMaxDistance`+" ";
	$cmd = $cmd + "-mnd "+`optionVar -query flEmitterMinDistance`+" ";

	// Add in the volume parameters only if type is 5 (volume).
	//
	if ($typeChoice == "volume" )
	{
		int $volShapeChoice = `optionVar -query flEmitterVolumeShapeOM`;
		switch($volShapeChoice)
		{	
			case 1: $cmd = $cmd + "-vsh cube ";
				break;
			case 2: $cmd = $cmd + "-vsh sphere ";
				break;
			case 3: $cmd = $cmd + "-vsh cylinder ";
				break;
			case 4: $cmd = $cmd + "-vsh cone ";
				break;
			case 5: $cmd = $cmd + "-vsh torus ";
				break;
		}
		$cmd = $cmd + "-vof "+`optionVar -query flEmitterVolumeOffsetX`+" "
						 +`optionVar -query flEmitterVolumeOffsetY`+" "
						 +`optionVar -query flEmitterVolumeOffsetZ`+" ";
		$cmd = $cmd + "-vsw "+`optionVar -query flEmitterVolumeSweep`+" ";
		$cmd = $cmd + "-tsr "+`optionVar -query flEmitterTorusSectionRadius`+" ";
	}
	return $cmd;
}

//  ============== setFluidEmitObjectCmdString ==============
//
//  SYNOPSIS
//		Set the command and command args string for the emitter command.
//
global proc string setFluidEmitObjectCmdString()
{
	string $cmd = "fluidEmitter ";

	string $typeChoice = `optionVar -query flEmitObjectTypesOM`;
	$typeChoice = tolower( flEmitterType_uiToMel($typeChoice) );
	$cmd = $cmd + "-type " + $typeChoice + " ";
	$cmd = $cmd + fluidSetName("flEmitObject");

	$cmd = $cmd + "-der "+`optionVar -query flEmitObjectDensityRate`+" ";
	$cmd = $cmd + "-her "+`optionVar -query flEmitObjectHeatRate`+" ";
	$cmd = $cmd + "-fer "+`optionVar -query flEmitObjectFuelRate`+" ";
	$cmd = $cmd + "-fdr "+`optionVar -query flEmitObjectFluidDropoff`+" ";
	$cmd = $cmd + "-r 100.0 ";

	int $cycleOption = `optionVar -query flEmitObjectCycleOM`;
	string $cycleString = "none";
	switch( $cycleOption )
	{
		case 1:
			$cycleString = "none";
			break;
		case 2:
			$cycleString = "frame";
			break;
		//case 3:
		//	$cycleString = "count";
		//	break;
	}

	$cmd = $cmd + "-cye "+ $cycleString + " ";
	$cmd = $cmd + "-cyi "+`optionVar -query flEmitObjectCycleInterval`+" ";

	$cmd = $cmd + "-mxd "+`optionVar -query flEmitObjectMaxDistance`+" ";
	$cmd = $cmd + "-mnd "+`optionVar -query flEmitObjectMinDistance`+" ";

	return $cmd;
}

//  ============== set2DFluidEmitterCmdString ==============
//
//  SYNOPSIS
//		Set the command and command args string for the emitter command.
//
global proc string set2DFluidEmitterCmdString()
{
	string $cmd = "fluidEmitter -pos 0 0 0 ";

	string $typeChoice = `optionVar -query fl2DEmitterTypesOM`;
	$typeChoice = tolower( flEmitterType_uiToMel($typeChoice) );
	$cmd = $cmd + "-type " + $typeChoice + " ";
	$cmd = $cmd + fluidSetName("fl2DEmitter");

	$cmd = $cmd + "-der "+`optionVar -query fl2DEmitterDensityRate`+" ";
	$cmd = $cmd + "-her "+`optionVar -query fl2DEmitterHeatRate`+" ";
	$cmd = $cmd + "-fer "+`optionVar -query fl2DEmitterFuelRate`+" ";
	$cmd = $cmd + "-fdr "+`optionVar -query fl2DEmitterFluidDropoff`+" ";
	$cmd = $cmd + "-r 100.0 ";

	int $cycleOption = `optionVar -query fl2DEmitterCycleOM`;
	string $cycleString = "none";
	switch( $cycleOption )
	{
		case 1:
			$cycleString = "none";
			break;
		case 2:
			$cycleString = "frame";
			break;
		//case 3:
		//	$cycleString = "count";
		//	break;
	}

	$cmd = $cmd + "-cye "+ $cycleString + " ";
	$cmd = $cmd + "-cyi "+`optionVar -query fl2DEmitterCycleInterval`+" ";

	$cmd = $cmd + "-mxd "+`optionVar -query fl2DEmitterMaxDistance`+" ";
	$cmd = $cmd + "-mnd "+`optionVar -query fl2DEmitterMinDistance`+" ";

	// Add in the volume parameters only if type is 5 (volume).
	//
	if ($typeChoice == "volume" )
	{
		int $volShapeChoice = `optionVar -query fl2DEmitterVolumeShapeOM`;
		switch($volShapeChoice)
		{	
			case 1: $cmd = $cmd + "-vsh cube ";
				break;
			case 2: $cmd = $cmd + "-vsh sphere ";
				break;
			case 3: $cmd = $cmd + "-vsh cylinder ";
				break;
			case 4: $cmd = $cmd + "-vsh cone ";
				break;
			case 5: $cmd = $cmd + "-vsh torus ";
				break;
		}
		$cmd = $cmd + "-vof "+`optionVar -query fl2DEmitterVolumeOffsetX`+" "
						 +`optionVar -query fl2DEmitterVolumeOffsetY`+" "
						 +`optionVar -query fl2DEmitterVolumeOffsetZ`+" ";
		$cmd = $cmd + "-vsw "+`optionVar -query fl2DEmitterVolumeSweep`+" ";
		$cmd = $cmd + "-tsr "+`optionVar -query fl2DEmitterTorusSectionRadius`+" ";
	}
	return $cmd;
}

//  ============== set3DFluidEmitterCmdString ==============
//
//  SYNOPSIS
//		Set the command and command args string for the emitter command.
//
global proc string set3DFluidEmitterCmdString()
{
	string $cmd = "fluidEmitter -pos 0 0 0 ";

	string $typeChoice = `optionVar -query fl3DEmitterTypesOM`;
	$typeChoice = tolower( flEmitterType_uiToMel($typeChoice) );
	$cmd = $cmd + "-type " + $typeChoice + " ";
	$cmd = $cmd + fluidSetName("fl3DEmitter");

	$cmd = $cmd + "-der "+`optionVar -query fl3DEmitterDensityRate`+" ";
	$cmd = $cmd + "-her "+`optionVar -query fl3DEmitterHeatRate`+" ";
	$cmd = $cmd + "-fer "+`optionVar -query fl3DEmitterFuelRate`+" ";
	$cmd = $cmd + "-fdr "+`optionVar -query fl3DEmitterFluidDropoff`+" ";
	$cmd = $cmd + "-r 100.0 ";

	int $cycleOption = `optionVar -query fl3DEmitterCycleOM`;
	string $cycleString = "none";
	switch( $cycleOption )
	{
		case 1:
			$cycleString = "none";
			break;
		case 2:
			$cycleString = "frame";
			break;
		//case 3:
		//	$cycleString = "count";
		//	break;
	}

	$cmd = $cmd + "-cye "+ $cycleString + " ";
	$cmd = $cmd + "-cyi "+`optionVar -query fl3DEmitterCycleInterval`+" ";

	$cmd = $cmd + "-mxd "+`optionVar -query fl3DEmitterMaxDistance`+" ";
	$cmd = $cmd + "-mnd "+`optionVar -query fl3DEmitterMinDistance`+" ";

	// Add in the volume parameters only if type is 5 (volume).
	//
	if ($typeChoice == "volume" )
	{
		int $volShapeChoice = `optionVar -query fl3DEmitterVolumeShapeOM`;
		switch($volShapeChoice)
		{	
			case 1: $cmd = $cmd + "-vsh cube ";
				break;
			case 2: $cmd = $cmd + "-vsh sphere ";
				break;
			case 3: $cmd = $cmd + "-vsh cylinder ";
				break;
			case 4: $cmd = $cmd + "-vsh cone ";
				break;
			case 5: $cmd = $cmd + "-vsh torus ";
				break;
		}
		$cmd = $cmd + "-vof "+`optionVar -query fl3DEmitterVolumeOffsetX`+" "
						 +`optionVar -query fl3DEmitterVolumeOffsetY`+" "
						 +`optionVar -query fl3DEmitterVolumeOffsetZ`+" ";
		$cmd = $cmd + "-vsw "+`optionVar -query fl3DEmitterVolumeSweep`+" ";
		$cmd = $cmd + "-tsr "+`optionVar -query fl3DEmitterTorusSectionRadius`+" ";
	}
	return $cmd;
}

global proc string dynFluidEmitterCmdString( int $isCreate, 
											 string $theCmd, 
											 int $is2D )
{
	// This is just setting up the command to drag to the shelf.  
	// The return command is the mel script that will make the
	// emitter, make the particle to emit into, and connect the particle
	// to the emitters.
	//
	string $emitterCmd = "\"" + $theCmd + "\"";
	$emitterCmd = (	"dynExecFluidEmitterCommands 1 { \"" +
					$isCreate + "\", " +
					$emitterCmd + ", " + 
					$is2D + ", " + 
					`optionVar -query create2DFluidXRes` + ", " + 
					`optionVar -query create2DFluidYRes` + ", " + 
					`optionVar -query create2DFluidXSize` + ", " + 
					`optionVar -query create2DFluidYSize` + ", " + 
					`optionVar -query create2DFluidZSize` + ", " + 
					`optionVar -query create3DFluidXRes` + ", " + 
					`optionVar -query create3DFluidYRes` + ", " + 
					`optionVar -query create3DFluidZRes` + ", " + 
					`optionVar -query create3DFluidXSize` + ", " + 
					`optionVar -query create3DFluidYSize` + ", " + 
					`optionVar -query create3DFluidZSize` + ", " +
					`optionVar -query flEmitterParenting` + ", " +
					`optionVar -query fl2DEmitterParenting` + ", " +
					`optionVar -query fl3DEmitterParenting` + "} " );

	return $emitterCmd;

}	// dynSetEmitterShelfCommand

//  ============== setFluidCmdString ==============
//
//  SYNOPSIS
//		Set command and command args string for the fluid command.
//
global proc	string setCreate3DFluidCmdString(int $flag)
{
	// Create 3D fluid
	int $resX = `optionVar -query create3DFluidXRes`;
	int $resY = `optionVar -query create3DFluidYRes`;
	int $resZ = `optionVar -query create3DFluidZRes`;

	string $cmd = "";

	if( verifyFluidResolution( "", $resX, $resY, $resZ ) ) {
		float $dimX = `optionVar -query create3DFluidXSize`;
		float $dimY = `optionVar -query create3DFluidYSize`;
		float $dimZ = `optionVar -query create3DFluidZSize`;
		
		$cmd = ( "create3DFluid " + 
				 $resX + " " + $resY + " " + $resZ + " " +
				 $dimX + " " + $dimY + " " + $dimZ );
	}

	return $cmd;
}

global proc	string setCreate2DFluidCmdString(int $flag)
{
	// Create 2D fluid
	int $resX = `optionVar -query create2DFluidXRes`;
	int $resY = `optionVar -query create2DFluidYRes`;
	
	string $cmd = "";

	if( verifyFluidResolution( "", $resX, $resY, 1 ) ) {
		float $dimX = `optionVar -query create2DFluidXSize`;
		float $dimY = `optionVar -query create2DFluidYSize`;
		float $dimZ = `optionVar -query create2DFluidZSize`;

		$cmd = ( "create2DFluid " + 
				 $resX + " " + $resY + " " +
				 $dimX + " " + $dimY + " " + $dimZ );
	}

	return $cmd;
}

//  ============== setFluidClearCmdString ==============
//
//  SYNOPSIS
//		Set command and command args string for the command to
//		save the fluid initial conditions.
//
global proc	string setFluidClearCmdString(int $flag)
{
	return `performDeleteFluidsIC 0`;
}

global proc fluidTruncatePBC()
{
	if( !`exists fluidPlaybackCaches_disableUnselected` ) {
		source "fluidPlaybackCaches.mel";
	}

	int $oldEnable = `getAttr globalCacheControl.writeEnable`;

	string $disabledCaches[] = `fluidPlaybackCaches_disableUnselected`;
	setAttr globalCacheControl.writeEnable 1;
	truncateFluidCache;
	setAttr globalCacheControl.writeEnable $oldEnable;
	fluidPlaybackCaches_enable( $disabledCaches );
}

//  ============== setFluidTruncatePBCCmdString ==============
//
//  SYNOPSIS
//		Set command and command args string for the command to
//		truncate the fluid playback cache
//
global proc	string setFluidTruncatePBCCmdString(int $flag)
{
	// Make sure that we have a fluid selected
	// or warn the user and fail

	string $selectionList[] = `ls -sl`;
	int $numSelected = size($selectionList);

	if ($numSelected == 0)
	{
		warning( (uiRes("m_performFluids.kNoFluidsSelectedWarn")) );
		return "";
	}

	$fluidShape = getFluidShape($selectionList[0]);
	if (size($fluidShape) == 0)
	{
		warning( (uiRes("m_performFluids.kTheFirstItemWarn")) );
		return "";
	}

	// The cache could be either a fluid cache or a Maya cache.
	string $cmd;
	if((`connectionInfo -id ($fluidShape + ".diskCache")` > 0 ) ||
		(`connectionInfo -id ($fluidShape + ".playFromCache")` > 0 )) {
		$cmd = "fluidTruncatePBC";
	}
	return $cmd;
}


//  ============== setFluidDeletePBCCmdString ==============
//
//  SYNOPSIS
//		Set command and command args string for the command to
//		save the fluid initial conditions.
//
global proc	string setFluidDeletePBCCmdString(int $flag)
{
	return `performDeleteFluidsPB 0`;
}


//  ============== setFluidToPolyCmdString ==============
//
//  SYNOPSIS
//		Set command and command args string for the command to
//		save the fluid initial conditions.
//
global proc	string setFluidToPolyCmdString(int $flag)
{
	string $cmd =  "fluidToPoly";

	return $cmd;
}

global proc string extendFluidCmdString()
{
	return( "doExtendFluid 1 { \"" + 
			`optionVar -query extendFluidMinX` + "\", " +
			`optionVar -query extendFluidMaxX` + ", " + 
			`optionVar -query extendFluidMinY` + ", " + 
			`optionVar -query extendFluidMaxY` + ", " + 
			`optionVar -query extendFluidMinZ` + ", " +
			`optionVar -query extendFluidMaxZ` + "} " );
}

global proc string makeCollideFluidCmdString()
{
	return ( "doMakeCollideFluid 1 { \"" + 
			 `optionVar -query tessellationFactor` + "\" } " );
}

global proc string resampleFluidCmdString()
//
// Description:
//	
//	
{
	return( "doResampleFluid 1 { \"" + 
			`optionVar -query resampleFluidX` + "\", " + 
			`optionVar -query resampleFluidY` + ", " + 
			`optionVar -query resampleFluidZ` + "} " );
}


//  ========== performFluids ==========
//
//  SYNOPSIS
//		Called when a user selects a Dynamics menu item, or selects 
//		the "Create/Add" button in a Dynamics option box.
//
//		Arguments:
//			$createFlag:	1 = create field/emitter 
//							0 = add field/emitter/collision/goal
//							2 = create emitter and fluid
//
//			$type		command name (with initial Cap)
//			$flag		0 = execute the command
//						1 = bring up the option box
//						3 = bring up the option box for fluids
//						2 = dragging to shelf; just return the command string
//
global proc string performFluids( int $createFlag, string $type, int $flag)
{	
	if( !fluidEditLicenseFound() ) {
		error( (uiRes("m_performFluids.kFluidLicenseNotFound")) );
		return "";
	}

	if( !`exists setFluidOptionVars`) {
		source dynFluidCallbacks.mel;
		source dynSetFluidOptionVars.mel;
		source dynCreateFluidLayout.mel;
		source dynSetFluidOptionControls.mel;
	}
	string $selected[];
	string $cmd;

	if (($flag == 1) || ($flag == 3)) 
	{
		// Create the options box and set the values of the
		// controls based on the option vars.
		//
		createFluidsOptions($type, $createFlag);
	}
	else 
	{	
		// Create and set the option vars, if they don't exist already.
		// The second arg means don't reset the values to default if the
		// option vars already exsit.
		//
		dynSetOptionVars($type, 0);

		// Get the current selection list.
		//
		$selected = `ls -sl`;

		// Create the command args for the selected command, and
		// issue the command.
		//
		switch ($type) 
		{
			case "Create3DFluid":
				
				// FLUIDS_TODO this is currently not used, but should be
				// split up into a 2D and 3D case
				$cmd = setCreate3DFluidCmdString($createFlag);
				if (($flag == 0) && (size($cmd) > 0))
				{
					// execute the command.
					//
					evalEcho $cmd;
				}
				break;

			case "Create2DFluid":
				
				// FLUIDS_TODO this is currently not used, but should be
				// split up into a 2D and 3D case
				$cmd = setCreate2DFluidCmdString($createFlag);
				if (($flag == 0) && (size($cmd) > 0))
				{
					// execute the command.
					//
					evalEcho $cmd;
				}
				break;

			case "FluidEmitFromObject":
				// Geometry emitter or emit into existing fluid
				// we're attaching an emitter to something else so we ignore
				// the is2D flag, so just arbitrarily pass in false
				$cmd = setFluidEmitObjectCmdString();
				$cmd = dynFluidEmitterCmdString(0, $cmd, false);
				if(( $flag == 0 ) && ( size($cmd) > 0 )) {
					eval $cmd;
				}
				break;

			case "FluidEmitter":
				// Geometry emitter or emit into existing fluid
				// we're attaching an emitter to something else so we ignore
				// the is2D flag, so just arbitrarily pass in false
				$cmd = setFluidEmitterCmdString();
				$cmd = dynFluidEmitterCmdString(2, $cmd, false);
				if(( $flag == 0 ) && ( size($cmd) > 0 )) {
					eval $cmd;
				}
				break;

			case "2DFluidAndEmitter":
				// create 2D fluid and emit into it
				int $addEmitter = `optionVar -query create2DAddEmitter`;
				if ( $addEmitter == 1 )
				{
					$cmd = set2DFluidEmitterCmdString();
					$cmd = dynFluidEmitterCmdString(1, $cmd, true);
				}
				else
				{
					$cmd = setCreate2DFluidCmdString($createFlag);
				}
				if(( $flag == 0 ) && ( size($cmd) > 0 )) {
					evalEcho $cmd;
				}
				break;

			case "3DFluidAndEmitter":
				// create 3D fluid and emit into it
				int $addEmitter = `optionVar -query create3DAddEmitter`;
				if ( $addEmitter == 1 )
				{
					$cmd = set3DFluidEmitterCmdString();
					$cmd = dynFluidEmitterCmdString(1, $cmd, false);
				}
				else
				{
					$cmd = setCreate3DFluidCmdString($createFlag);
				}
				if(( $flag == 0 ) && ( size($cmd) > 0 )) {
					evalEcho $cmd;
				}
				break;

			case "FluidClear":
				
				$cmd = setFluidClearCmdString($createFlag);
				if (($flag == 0) && (size($cmd) > 0))
				{
					// execute the command.
					//
					evalEcho $cmd;
				}
				break;

			
			case "FluidTruncatePBC":
				
				$cmd = setFluidTruncatePBCCmdString($createFlag);
				if (($flag == 0) && (size($cmd) > 0))
				{
					// execute the command.
					//
					evalEcho $cmd;
				}
				break;

			case "FluidDeletePBC":
				
				$cmd = setFluidDeletePBCCmdString($createFlag);
				if (($flag == 0) && (size($cmd) > 0))
				{
					// execute the command.
					//
					evalEcho $cmd;
				}
				break;

			
			case "FluidToPoly":
				
				$cmd = setFluidToPolyCmdString($createFlag);
				if (($flag == 0) && (size($cmd) > 0))
				{
					// execute the command.
					//
					evalEcho $cmd;
				}
				break;

			
			case "ExtendFluid":
				
				$cmd = extendFluidCmdString();
				if (($flag == 0) && (size($cmd) > 0))
				{
					// execute the command.
					//
					evalEcho $cmd;
				}
				break;

			
			case "ResampleFluid":
				
				$cmd = resampleFluidCmdString();
				if (($flag == 0) && (size($cmd) > 0))
				{
					// execute the command.
					//
					evalEcho $cmd;
				}
				break;

			
			case "MakeCollideFluid":
				$cmd = makeCollideFluidCmdString();
				if(( $flag == 0 ) && ( size( $cmd ) > 0 )) {
					evalEcho $cmd;
				}
				break;

			default:			
				string $err = (uiRes("m_performFluids.kPerformFluidsError"));
				error(`format -s $type $err`);
				break;
		}	
	}
	return $cmd;
}

global proc deleteFluidCache( string $cacheNode, int $deleteCacheFile )
//
// Description:
//	When we clear the IC cache: 
//		* delete the IC diskCache node
//		* delete any hidden disk files associated with this node
//		* delete the real disk file only if $deleteCacheFile == true
//	
{
	string $rules[] = `workspace -q -fr`;
	string $dataDir = "";
	int $i = 0;
	for( ; $i < size($rules)-1; $i+=2 ) {
		if( $rules[$i] == "diskCache" ) {
			$dataDir = $rules[$i+1];
			break;
		}
	}

	string $realPath = (`workspace -q -rd` + $dataDir);
	string $realFile = `getAttr ( $cacheNode + ".cacheName" )`;
	string $hiddenPath = `diskCache -q -tmp`;
	string $hiddenFile = `getAttr ( $cacheNode + ".hiddenCacheName" )`;
		
	if( $hiddenFile != $realFile ) {
		eval ("sysFile -del \"" + $hiddenPath + "/" + $hiddenFile + "\"" );
	}

	if( $deleteCacheFile ) {
		eval ("sysFile -del \"" + $realPath + "/" + $realFile + "\"" );
	}

	delete $cacheNode;
}

//global proc string findFluidCache( string $object, string $cacheSuffix)
//{
//	string $dskC;
//	if(`connectionInfo -id ($object + ".diskCache" + $cacheSuffix)` > 0 ) {
//		string $src = `connectionInfo -sfd ($object + ".diskCache" + $cacheSuffix)`;
//		string $buffer[];
//		tokenize($src, ".", $buffer);
//		$dskC = $buffer[0];
//	}
//	return $dskC;
//}

//
// Find the cache file associated with the given fluid object.  The cache may be
// either a fluid cache or a Maya cache.  If the fluid object is connected to
// neither of these, return an empty string.  This may be the case, for example,
// if the cache is being blended with other caches.
//
global proc string findFluidCache( string $object )
{
	string $dskC;
	if(`connectionInfo -id ($object + ".diskCache")` > 0 ) {
		string $src = `connectionInfo -sfd ($object + ".diskCache")`;
		string $buffer[];
		tokenize($src, ".", $buffer);
		$dskC = $buffer[0];
	}
	else if (`connectionInfo -id ($object + ".playFromCache")` > 0 ) {
		string $src = `connectionInfo -sfd ($object + ".playFromCache")`;
		string $buffer[];
		tokenize($src, ".", $buffer);
		$dskC = $buffer[0];
        if (`nodeType $dskC` != "cacheFile")
			$dskC = "";
	}
	return $dskC;
}

