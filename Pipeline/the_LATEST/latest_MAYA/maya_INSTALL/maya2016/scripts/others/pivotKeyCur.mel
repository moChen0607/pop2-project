// Copyright (C) 1997-2014 Autodesk, Inc., and/or its licensors.
// All rights reserved.
//
// The coded instructions, statements, computer programs, and/or related
// material (collectively the "Data") in these files contain unpublished
// information proprietary to Autodesk, Inc. ("Autodesk") and/or its licensors,
// which is protected by U.S. and Canadian federal copyright law and by
// international treaties.
//
// The Data is provided for use exclusively by You. You have the right to use,
// modify, and incorporate this Data into other products for purposes authorized 
// by the Autodesk software license agreement, without fee.
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND. AUTODESK
// DOES NOT MAKE AND HEREBY DISCLAIMS ANY EXPRESS OR IMPLIED WARRANTIES
// INCLUDING, BUT NOT LIMITED TO, THE WARRANTIES OF NON-INFRINGEMENT,
// MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE, OR ARISING FROM A COURSE 
// OF DEALING, USAGE, OR TRADE PRACTICE. IN NO EVENT WILL AUTODESK AND/OR ITS
// LICENSORS BE LIABLE FOR ANY LOST REVENUES, DATA, OR PROFITS, OR SPECIAL,
// DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES, EVEN IF AUTODESK AND/OR ITS
// LICENSORS HAS BEEN ADVISED OF THE POSSIBILITY OR PROBABILITY OF SUCH DAMAGES.

//==========================================================
//
//	Rotate Pivot Animation Controls
//  -------------------------------
//
//	There are four MEL procedures provided for animating
//	the rotate pivot of an object in a way that prevents
//	the object from jumping suddenly each time the pivot 
//	moves.
//
//	The functions are:
//
//	1)	pivotKey(px,py,pz):	keys the rotate pivot to
//		position (px,py,pz) in local space at the 
//		current frame.
//
//	2)	pivotKeyCur(): keys the rotate pivot to its
//		current position in local space at the current
//		frame.
//
//	3)	pivotKeyUpdate(): runs through all pivot
//		keyframes and ensures that the object remains
//		stationary at the points where the pivot
//		moves.
//
//	The pivotKey() and pivotKeyCur() functions use 
//	stepped tangents, so the pivot point instantaneously
//	moves from one keyframed position to the next.  This
//	helps to avoid unpredictable behaviour that can result
//	from smoothly varying both the rotate and rotate pivot 
//	values at the same time.
//
//	The following is an example sequence of commands:
//
//	1) - create a poly cube and select it
//
//	2) - frame 1
//	   - run pivotKeyCur() to set a pivot key
//	   - keyframe object's rotation
//
//	3) - frame 20
//	   - rotate the object and key its rotation
//
//  4) - frame 21
//	   - run pivotKey( 0.5, 0.5, 0.5 ) to move the
//		 pivot to (0.5,0.5,0.5) in local space and
//		 set a key
//
//	5) - frame 40
//	   - rotate the object and key its rotation
//
//	The result will be:
//
//	- frames 1->20:  object rotates about its center
//	- frame 21:      pivot moves to object's corner
//	- frames 21->40: object rotates about corner
//
//  When you play the animation, the object will 
//  remain stationary at frame 21 when the pivot
//  changes.
//
//  If, however, you go and modify the object's
//	rotation at frame 20, you will find that 
//	a jump will occur when the pivot changes at frame
//	21.  To fix this, just run pivotKeyUpdate() with the
//	object selected.  This will run through all keyframes
//	and ensure that no jumps occur when the pivot changes.
//
//	The reason why pivotKeyUpdate() is necessary is that
//	in order to prevent the jumping when the pivot changes,
//	we are keying the rotatePivotTranslate attribute.  The
//	required value for that attribute is dependent on the
//	object's rotation at that point, so if the rotation 
//	changes, we need to update the rotatePivotTranslate
//	keys to avoid jumping.  This function automatically
//	updates those keys.
//
//==========================================================

global proc pivotKeyCur()
//
//	Description:
//
//		For the first selected transform, keys the rotate 
//		pivot to its current value at the current frame.
//
{
	//	get the first selected transform
	//
	string $sl[] = `ls -sl -transforms`;
	if( size($sl) == 0 )
	{
		error( (uiRes("m_pivotKeyCur.kPivotKeyCurErr")) );
	}
	string $o = $sl[0];

	//	key the pivot at its current position 
	//	(the pivot values have the scale factor in
	//	them, so we need to divide it out to get
	//	"local space" values.
	//
	float $px = `getAttr ($o + ".rotatePivotX")`;
	float $py = `getAttr ($o + ".rotatePivotY")`;
	float $pz = `getAttr ($o + ".rotatePivotZ")`;
	float $sx = `getAttr ($o + ".scaleX")`;
	float $sy = `getAttr ($o + ".scaleY")`;
	float $sz = `getAttr ($o + ".scaleZ")`;
	pivotKey( $px/$sx, $py/$sy, $pz/$sz );
}
