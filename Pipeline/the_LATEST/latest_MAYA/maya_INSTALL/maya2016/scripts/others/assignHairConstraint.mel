// Copyright (C) 1997-2014 Autodesk, Inc., and/or its licensors.
// All rights reserved.
//
// The coded instructions, statements, computer programs, and/or related
// material (collectively the "Data") in these files contain unpublished
// information proprietary to Autodesk, Inc. ("Autodesk") and/or its licensors,
// which is protected by U.S. and Canadian federal copyright law and by
// international treaties.
//
// The Data is provided for use exclusively by You. You have the right to use,
// modify, and incorporate this Data into other products for purposes authorized 
// by the Autodesk software license agreement, without fee.
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND. AUTODESK
// DOES NOT MAKE AND HEREBY DISCLAIMS ANY EXPRESS OR IMPLIED WARRANTIES
// INCLUDING, BUT NOT LIMITED TO, THE WARRANTIES OF NON-INFRINGEMENT,
// MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE, OR ARISING FROM A COURSE 
// OF DEALING, USAGE, OR TRADE PRACTICE. IN NO EVENT WILL AUTODESK AND/OR ITS
// LICENSORS BE LIABLE FOR ANY LOST REVENUES, DATA, OR PROFITS, OR SPECIAL,
// DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES, EVEN IF AUTODESK AND/OR ITS
// LICENSORS HAS BEEN ADVISED OF THE POSSIBILITY OR PROBABILITY OF SUCH DAMAGES.

//
//
//  Creation Date:  2005
//
// Description: assign selected follicles to selected hair constraint nodes 
//	

proc string getConstraintHairSystem( string $constraint )
{
	string $hsys[] = `listConnections -type hairSystem $constraint`;
	if( size( $hsys ) > 0 ){
		return $hsys[0];
	} else {
		return "";
	}
}

proc string getFollicleHairSystem( string $follicle )
{
	string $hsys[] = `listConnections -type hairSystem $follicle`;
	if( size( $hsys ) > 0 ){
		return $hsys[0];
	} else {
		return "";
	}
}

proc int getFollicleIndex( string $follicle )
{
	string $con[] = `connectionInfo -dfs ($follicle + ".outHair")`;
	if( size( $con ) > 0 ){
		string $buffer[];
		int $numTokens = `tokenize $con[0] ".[]" $buffer`;
		if( $numTokens == 3 ){
			return( $buffer[2] );
		}
	}
	return( -1 );
}


global proc assignHairConstraint(int $append)
{
	string $constraints[] = `ls -sl -dag -type hairConstraint`;
	if( size( $constraints ) < 1 ){
		warning( (uiRes("m_assignHairConstraint.kNoHairConstraint")) );
		return;
	}
	string $follicles[] = getSelectedHairCurves();
	if( size( $follicles ) < 1 ){
		warning( (uiRes("m_assignHairConstraint.kNoFolliclesSelected")) );
		return;
	}
	string $constraint, $follicle;
	for( $constraint in $constraints ){
		string $constraintHairSystem = getConstraintHairSystem( $constraint );
		string $inds = ($constraint  + ".curveIndices");
		int $numIndices = `getAttr -size $inds`;
		int $newIndice = 0;
		float $currentIndices[];
		if( $append ){
			$newIndice = $numIndices;
			// note that getAttr returns a float array,
			// even though curveIndices is an integer multi attribute
			$currentIndices = getAttr( $inds );
		}

		for( $follicle in $follicles ){
			string $follicleHairSystem = getFollicleHairSystem( $follicle );
			if( $follicleHairSystem != $constraintHairSystem ){
				string $fmt = (uiRes("m_assignHairConstraint.kDifferentHairSystem"));
				warning( `format -s $follicle -s $constraint $fmt` );
				continue;
			}
			
			int $follicleIndex = getFollicleIndex( $follicle );
			if( $follicleIndex == -1 ){
				string $fmt = (uiRes("m_assignHairConstraint.kBadFollicleConnection"));
				warning( `format -s $follicle $fmt` );
				continue;
			}
			if( $append ){
				// avoid adding duplicate indices
				int $matchFound = false;
				float $curInd;
				for( $curInd in $currentIndices ){
					if( $follicleIndex ==(int)$curInd ){
						$matchFound = true;
						break;
					}
				}
				if( $matchFound ){
					continue;
				}
			}
			setAttr ($inds + "[" + $newIndice + "]") $follicleIndex;
			$newIndice++;
		}
		if( !$append ){
			while ($newIndice < $numIndices){
				removeMultiInstance -b true ($inds + "[" + $newIndice + "]");
				$newIndice++;
			}
		} 
	}
	refresh -f; // force update
}

