// Copyright (C) 1997-2014 Autodesk, Inc., and/or its licensors.
// All rights reserved.
//
// The coded instructions, statements, computer programs, and/or related
// material (collectively the "Data") in these files contain unpublished
// information proprietary to Autodesk, Inc. ("Autodesk") and/or its licensors,
// which is protected by U.S. and Canadian federal copyright law and by
// international treaties.
//
// The Data is provided for use exclusively by You. You have the right to use,
// modify, and incorporate this Data into other products for purposes authorized 
// by the Autodesk software license agreement, without fee.
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND. AUTODESK
// DOES NOT MAKE AND HEREBY DISCLAIMS ANY EXPRESS OR IMPLIED WARRANTIES
// INCLUDING, BUT NOT LIMITED TO, THE WARRANTIES OF NON-INFRINGEMENT,
// MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE, OR ARISING FROM A COURSE 
// OF DEALING, USAGE, OR TRADE PRACTICE. IN NO EVENT WILL AUTODESK AND/OR ITS
// LICENSORS BE LIABLE FOR ANY LOST REVENUES, DATA, OR PROFITS, OR SPECIAL,
// DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES, EVEN IF AUTODESK AND/OR ITS
// LICENSORS HAS BEEN ADVISED OF THE POSSIBILITY OR PROBABILITY OF SUCH DAMAGES.

//
//
//  Creation Date:  26 Feb 1996
//
//  Description:
//      This procedure fills the history popup

global string $gHistoryWindowNode;
global int $gHistoryWindowShowingFuture;

proc int isDeformer( string $node )
//
//	Description:
//		Return 0 if the node is not a deformer, else return non-zero.
//
{
	string $defTest[];
	$defTest = `ls -type geometryFilter $node`;
	return (size($defTest));
}

proc int respectPassThrough( string $nt, string $item )
{
	if(   isDeformer($item) ||
		( "closeCurve" == $nt ) ||
		( "closeSurface" == $nt ) ||
		( "detachCurve" == $nt ) ||
		( "detachSurface" == $nt ) ||
		( "hardenPoint" == $nt ) ||
		( "insertKnotCurve" == $nt ) ||
		( "insertKnotSurface" == $nt ) ||
		( "rebuildCurve" == $nt ) ||
		( "rebuildSurface" == $nt ) ||
		( "reverseCurve" == $nt ) ||
		( "reverseSurface" == $nt ) ||
		( "stitchSrf" == $nt ) ||
		( "subCurve" == $nt ) ||
		( "trim" == $nt ) ||
		( "untrim" == $nt ) ) {
		return true;
	}
	return false;
}


proc int willDragDrop( string $item )
{
	
	if( isDeformer($item) ) {
		return true;
	}
	return false;
}

global proc buildHistoryContextHelpItems(string $nameRoot, string $menuParent)
//
//  Description:
//		Build context sensitive menu items
//		
//  Input Arguments:
//		$nameRoot - name to use as the root of all item names
//		$menuParent - the name of the parent of this menu
//
//  Return Value:
//      None
//
{
	menuItem -label (uiRes("m_detachHistoryTable.kHelp"))
		-enableCommandRepeat false
		-command "showHelp HistoryList";
}

global proc string getLeadSelectionItem()
//
//  Description:
//	Gets the item at the tail of the selection list
//		
//  Return Value:
//      The last node to be selected. Preference given to DAG nodes
//	if any are selected.
//
{
	string $result = "";
	string $all[] = `ls -l -sl -tail 1 -type dagNode`;
	if( size($all) > 0 ) {
		$result = $all[0];
	}
	else {
		$all = `ls -sl -tail 1`;
		if( size($all) > 0 ) {
			$result = $all[0];
		}
	}
	return $result;
}
global proc int[] historyTableDropRectCB(
	string $dropControl, 
	int    $x, 
	int    $y)
//
//	Description:
//		This procedure is called whenever the user hovers over
//		a text item during a drag 'n drop operation.
//
//	Arguments:
//		$dropControl - The list where the drop would occur.
//
//		$x, $y       - Location of the drag event.
//
{
	// Draw a line at the point where the deformer would be inserted.
	//
	int $width = `text -q -width $dropControl`;
	int $height = `text -q -height $dropControl`;
	return( {0,$height-1,$width,1} );
}


global proc detachHistoryTable( string $object, int $future,
								string $futureString, string $all )
//
//  Description:
//		Builds the controls for the history/future of the node specified by $object
//		
//  Input Arguments:
//		$object - full path to node that controls represent
//		$future - whether the list of operations represents future or past operations.
//		$futureString - the string to insert into the title of the window 
//		                (eg. "input" or "output")
//		$all - a space-delimited list of history/future nodes to create controls for.
//
//  Return Value:
//      None
//
{
	global string $gHistoryWindowNode;
	global int $gHistoryWindowShowingFuture;

	int $n, $i, $ihi, $nds;
	string $title, $nt;
	string $item, $one;
	string $list[];
	
	if($futureString == "input")
	{
		$futureString = (uiRes("m_detachHistoryTable.kInput"));
	}
	else 
	{
		$futureString = (uiRes("m_detachHistoryTable.kOutput"));
	}

	int $windowExists = `window -exists "showHistoryWindow"`;

	if( $windowExists ) {
		//
		//	The window already exists.
		//

		//	Find out if the history window is already using the object specified.
		//	If so, we shouldn't waste time rebuilding controls.
		//
		setParent showHistoryWindow;
		if( $gHistoryWindowNode == $object && $gHistoryWindowShowingFuture == $future) {
			return;
		}

	} else {
		//	The window doesn't exist yet, so create it.
		//
		window -menuBar true
			-widthHeight 460 500 
			-iconName (uiRes("m_detachHistoryTable.kListHistory"))
			showHistoryWindow;

		//	Adds support for the Context Sensitive Help Menu.
		//
		addContextHelpProc "showHistoryWindow" "buildHistoryContextHelpItems";

		doHelpMenu "showHistoryWindow" "showHistoryWindow";

		//	Create a scriptJob that updates the history window as long as it is visible.
		//	When the selection changes, this job will update the window.
		//
		scriptJob -protected
			-parent showHistoryWindow
			-event "SelectionChanged" ("historyPopupFill `getLeadSelectionItem` $gHistoryWindowShowingFuture 2");
	}

	tokenize( $all, $list );
	$n = size( $list );

	//	Grab the name of the object (removing any preceding slashes)
	//
	string $objectPath[];
	tokenize( $object, "|", $objectPath);
	
	$title = (uiRes("m_detachHistoryTable.kTitle"));

	window -e -t `format -s $futureString -s $objectPath[size($objectPath)-1] $title` showHistoryWindow;

	//	Push the UI template...
	//
	setUITemplate -pushTemplate DefaultTemplate;

	//	Update the global variable that represents the full path to the node
	//
	$gHistoryWindowNode = $object;
	$gHistoryWindowShowingFuture = $future;

	if (!$windowExists) {
		//
		//	Create the window UI.
		//
		string $form = `formLayout`;

		//	Create the header labels.
		//
		string $header = `rowLayout -numberOfColumns 3
			-adjustableColumn 1
			-columnAttach 2 "left" 0
			-columnAttach 3 "right" 30`;
			text -label "";
			text -label (uiRes("m_detachHistoryTable.kNodeState"));
			text -label (uiRes("m_detachHistoryTable.kFilter"));
			setParent ..;

		//	Create a tab layout so we can hide the creation of the 
		//	controls.  Controls will be created in a hidden tab and when
		//	they are all constructed that tab will be made current and
		//	the previous tab will be hidden.
		//
		string $body = `tabLayout 
			-scrollable true
			-tabsVisible false
			-childResizable true
			HistoryTableTabLayout`;
			//
			//	Create an inital dummy tab.  This is the first tab so it
			//	will be visible but empty, while the real contents of the
			//	window is created in a second hidden tab.
			//	
			columnLayout;
				setParent ..;
			// Create a second tab for the real contents
			//
			columnLayout -adj true;
				setParent ..;
			setParent ..;

		//	Create the close button that simply deletes the window.
		//
		string $closeBtn = `button -label (uiRes("m_detachHistoryTable.kClose")) 
			-command "deleteUI showHistoryWindow"`;

		//	Apply the window attachments.
		//
		formLayout -edit
			-attachForm    $header   top    7 
			-attachForm    $header   left   0
			-attachForm    $header   right  0
			-attachNone    $header   bottom

			-attachControl $body     top    2 $header
			-attachForm    $body     left   0
			-attachForm    $body     right  0
			-attachControl $body     bottom 5 $closeBtn

			-attachForm    $closeBtn left   5
			-attachForm    $closeBtn right  5
			-attachForm    $closeBtn bottom 5
			-attachNone    $closeBtn top
			$form;
	}

	//	Select the layout for the first (hidden) tab, while we (re)construct
	//	the second tab with the actual stuff
	//
	tabLayout -e -selectTabIndex 1 HistoryTableTabLayout;

	string $child[] = `tabLayout -query -childArray HistoryTableTabLayout`;
	string $colLayout = $child[1];
	setParent $colLayout;

	// Delete the children, if necessary
	//
	string $children[] = `columnLayout -query -childArray $colLayout`;
	int $numChildren = size($children);
	if( $numChildren > 0 ){
		string $cmd = "deleteUI ";
		int $childIndex = 0;
		while( $childIndex < $numChildren ){
			$cmd += $children[$childIndex];
			$cmd += " ";
			$childIndex++;
		}
		eval( $cmd );
	}

	//	Let the user know we're up to something...
	//
 	waitCursor -state on;

			////////////////////////////////////////////////////////////
			//
			//	Begin construction of row entries.
			//
			////////////////////////////////////////////////////////////
			if( ($n > 0) && ("" != $list[0]) ) {

				int $nodeStateColumnNeedsResize = false;
				
				for( $i=0; $i<$n; $i+=1 ) {
					$item = $list[$i];
					
					if( "" == $item ) {
						continue;
					}

					if( "SEPARATOR" == $item ) {
						separator -h 10;
						continue;
					}
		
					$ihi = `getAttr ($item + ".ihi")`;
					$nds = `getAttr ($item + ".nds")`;


					$nt = `nodeType $item`;
					
					rowLayout -nc 3 -adjustableColumn 1 -cat 2 "left" 0 -cat 3 "left" 0 ("row" + $i);

						if( willDragDrop( $item )) {
							string $fmt = "^1s (^2s) ";
							string $label = `format -s (nodeTypeNiceName($nt)) -s $item $fmt`;
							string $textControl = `text -al right
								-label $label
								-ann ($object + "|" + $futureString + "|" + $item)
								-dgc "dragDeformersReorder"
								-dpc "dropDeformersReorder"`;
							text -e -dropRectCallback "historyTableDropRectCB"
								$textControl;
						}
						else {
							string $fmt = "^1s ";
							text -al right -label `format -s (nodeTypeNiceName($nt)) $fmt`;
						}
		
							popupMenu;
								menuItem -l (uiRes("m_detachHistoryTable.kSelect")) -c ("select -add " + $item);
								menuItem -l (uiRes("m_detachHistoryTable.kDeselect")) -c ("select -d " + $item);
								menuItem -l (uiRes("m_detachHistoryTable.kExclusive")) -c ("select -r " + $item);
							setParent -m ..;

						if( respectPassThrough( $nt, $item )) {

							$one = `optionMenu -l "" ("option"+$i)`;
								menuItem -l (uiRes("m_detachHistoryTable.kNormal"))  -da 0 normalItem;
								menuItem -l (uiRes("m_detachHistoryTable.kNoEffect")) -da 1 passItem;
								menuItem -l (uiRes("m_detachHistoryTable.kBlocking")) -da 2 blockedItem;
								connectControl $one ($item+".nodeState");

							$nodeStateColumnNeedsResize = true;
						}
						else {
							$one = `optionMenu -l "" ("optionState"+$i)`;
								menuItem -l (uiRes("m_detachHistoryTable.kNormal"))  -da 0 normalItem;
								menuItem -l (uiRes("m_detachHistoryTable.kBlocking")) -da 2 blockedItem;
								connectControl $one ($item+".nodeState");
						}

						$one = `optionMenu -l "" ("optionShow"+$i)`;
							menuItem -l (uiRes("m_detachHistoryTable.kList"))       -da 2 normalItem;
							menuItem -l (uiRes("m_detachHistoryTable.kInclude")) -da 1 blockedItem;
							connectControl $one ($item+".ihi");
					setParent ..;
				}

				if($nodeStateColumnNeedsResize || `about -uiLanguageIsLocalized`) {
					for( $i=0; $i<$n; $i+=1 ) {
						$item = $list[$i];
					
						if( "" == $item  ||"SEPARATOR" == $item ) {
							continue;
						}

						if(`about -nt` || `about -uiLanguageIsLocalized`) {
							rowLayout -e -cw 2 96 ("row" + $i);
						} else {
							rowLayout -e -cw 2 102 ("row" + $i);
						}
					}
				}
			}
			else {
				string $noItems = (uiRes("m_detachHistoryTable.kNoItems"));
				text -l `format -s $futureString $noItems`
					-al "left" comment;
			}
			////////////////////////////////////////////////////////////
			//
			//	End construction of row entries.
			//
			////////////////////////////////////////////////////////////

	//	All done.
	//
 	waitCursor -state off;

	//	Pop the UI template.
	//
	setUITemplate -popTemplate;

	//	Select the real tab.
	//
	tabLayout -edit -selectTabIndex 2 HistoryTableTabLayout;
	
	if (!$windowExists) {
		showWindow showHistoryWindow;
	}
}
