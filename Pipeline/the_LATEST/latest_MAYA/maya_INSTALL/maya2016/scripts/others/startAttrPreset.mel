// Copyright (C) 1997-2014 Autodesk, Inc., and/or its licensors.
// All rights reserved.
//
// The coded instructions, statements, computer programs, and/or related
// material (collectively the "Data") in these files contain unpublished
// information proprietary to Autodesk, Inc. ("Autodesk") and/or its licensors,
// which is protected by U.S. and Canadian federal copyright law and by
// international treaties.
//
// The Data is provided for use exclusively by You. You have the right to use,
// modify, and incorporate this Data into other products for purposes authorized 
// by the Autodesk software license agreement, without fee.
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND. AUTODESK
// DOES NOT MAKE AND HEREBY DISCLAIMS ANY EXPRESS OR IMPLIED WARRANTIES
// INCLUDING, BUT NOT LIMITED TO, THE WARRANTIES OF NON-INFRINGEMENT,
// MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE, OR ARISING FROM A COURSE 
// OF DEALING, USAGE, OR TRADE PRACTICE. IN NO EVENT WILL AUTODESK AND/OR ITS
// LICENSORS BE LIABLE FOR ANY LOST REVENUES, DATA, OR PROFITS, OR SPECIAL,
// DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES, EVEN IF AUTODESK AND/OR ITS
// LICENSORS HAS BEEN ADVISED OF THE POSSIBILITY OR PROBABILITY OF SUCH DAMAGES.

//
//
//
//  Creation Date:  2001 
//


global string	$gAEAttrPresetCurrentTarget;
global float	$gAEAttrPresetBlend;
global string	$gAEAttrPresetCopyObj = "";
global string	$gAEAttrPresetSelList[];
global int		$gAEAttrPresetValidNotes;

//
//  handle string preset values  
//
global proc blendAttrStr( string $attr, string $str )
{
	global string $gAEAttrPresetCurrentTarget;
	global float	$gAEAttrPresetBlend;
	global int $gAEAttrPresetValidNotes;
	if( $gAEAttrPresetBlend > 0.5 ){
		if( size($gAEAttrPresetCurrentTarget) > 0){
			if( validAttrForCurrentPreset( $attr ) ){
				string $objAttr = $gAEAttrPresetCurrentTarget + "." + $attr;
				if($attr == "notes" || $attr == "nts") {
					$gAEAttrPresetValidNotes = 1;
					// we know what kind of dynamic attr notes has to be
					// so we can create it. A blatant special case if we ever saw one
					// in future we should write out a blendDynAttr command which
					// specifies the type info for dynamic attributes to be created
					if(!objExists( $objAttr )) {
						if( catch(`addAttr -dt "string" -ln "notes" -sn "nts"  $gAEAttrPresetCurrentTarget`)) {
							string $msgFormat = (uiRes("m_startAttrPreset.kCantCreateDynAttr"));
							error(`format -s $objAttr $msgFormat`);
						}
					}
				}
				if(objExists( $objAttr ) && `getAttr -settable $objAttr`) {
					setAttr -type "string" $objAttr $str;
				}
			}
		}
	}
}

//
//  handle scalar preset values  
//
global proc blendAttr( string $attr, float $val )
{
	global string $gAEAttrPresetCurrentTarget;
	global float	$gAEAttrPresetBlend;
	global string	$gAEAttrPresetCopyObj;

// print ("setting Attr " + $attr + "\n" );
	if( size($gAEAttrPresetCurrentTarget) > 0){
		if( validAttrForCurrentPreset( $attr ) ){
			string $objAttr = $gAEAttrPresetCurrentTarget + "." + $attr;
			if(objExists( $objAttr ) && `getAttr -se $objAttr`) {
				if( $gAEAttrPresetBlend < 0.999 ){
						$targAttr = $gAEAttrPresetCopyObj + "." + $attr;
						if( objExists( $targAttr ) ){
							string $attrType = `getAttr -type $targAttr`;
							switch ($attrType) {
								case "enum":
									if( $gAEAttrPresetBlend < 0.5 ){
										$val = getAttr( $targAttr );
									}
									setAttr ($gAEAttrPresetCurrentTarget + "." + $attr) $val;
									break;
								case "bool":
								case "short":
								case "long":
								case "byte":
								case "char":
									int $intVal = (int)($val * $gAEAttrPresetBlend 
										+ getAttr($targAttr) * (1-$gAEAttrPresetBlend));
									setAttr ($gAEAttrPresetCurrentTarget + "." + $attr) $intVal;
									break;

								// These cases are expected in default
								//
								//	case "float":
								//	case "floatLinear":
								//	case "double":
								//	case "doubleLinear":
								//	case "doubleAngle":
								//	case "time":
								//
								default:
									$val = $val * $gAEAttrPresetBlend 
										+ getAttr($targAttr) * (1-$gAEAttrPresetBlend);
									setAttr -c ($gAEAttrPresetCurrentTarget + "." + $attr) $val;
									break;
							}
						}
				} else {
					setAttr -c $objAttr $val;
				}
			}
		}
	}
}

//
// Clean up after setting preset values
//
global proc endAttrPreset()
{
// print ("endAttrPreset\n" );
	global float	$gAEAttrPresetBlend;
	global string	$gAEAttrPresetCopyObj;
	global string	$gAEAttrPresetSelList[];

	global string $gAEAttrPresetCurrentTarget;
	global int $gAEAttrPresetValidNotes;

	// if we didn't find any notes in the preset, and the node has
	// ols out of date notes, remove them
	if($gAEAttrPresetValidNotes == 0) {
		string $notesAttr =  $gAEAttrPresetCurrentTarget + ".notes";
		if(objExists( $notesAttr )) {
			if( catch(`deleteAttr -at "notes" $gAEAttrPresetCurrentTarget`)) {
				string $msgFormat = (uiRes("m_startAttrPreset.kCantDeleteDynAttr"));
				error(`format -s $notesAttr $msgFormat`);
			}
		}
	}
	$gAEAttrPresetCopyObj = "";
	$gAEAttrPresetSelList = {};
}

//
// Initialize for preset calls
//
global proc startAttrPreset( string $nodeType )
{
	global string $gAEAttrPresetCurrentTarget;
	global float	$gAEAttrPresetBlend;
	global string	$gAEAttrPresetSelList[];
	global string	$gAEAttrPresetCopyObj;
	global int      $gAEAttrPresetValidNotes;

	$gAEAttrPresetValidNotes = 1;
	if( objExists( $gAEAttrPresetCurrentTarget ) ){
		string $type = nodeType($gAEAttrPresetCurrentTarget);
		if( $type != $nodeType ){
			string $msgFormat = (uiRes("m_startAttrPreset.kPresetTypeDoesntMatch"));
			warning( `format -s $nodeType $msgFormat`);
			$gAEAttrPresetCurrentTarget = "";
		} else {
			$gAEAttrPresetCopyObj = $gAEAttrPresetCurrentTarget;

			if( $gAEAttrPresetBlend > 0.5 ){
				// mark current notes as invalid
				// we can delete the attr later if we don't get new notes from the preset
				$gAEAttrPresetValidNotes = 0;
			}

			if( $gAEAttrPresetBlend > 0.7 ){ 
				// Old presets may not have newer attributes that we wish to be set to
				// default values(or values that preserve old behavior). If these attributes
				// exist in the preset then they will still be set correct.
				setNodeDefaultsForOldPresets( $gAEAttrPresetCurrentTarget );
				// Delete relevant multi entries
				string $multies[] = `attributeInfo -m 1 -and -w 1 -and -h 0 $gAEAttrPresetCurrentTarget`;
				string $mult;
				for ($mult in $multies ){
					string $nodeName = $gAEAttrPresetCurrentTarget +"."+$mult;
					if( objExists( $nodeName ) ){
						int $i, $size;
						string $entries[] = `listAttr -m -st $mult $gAEAttrPresetCurrentTarget`;
						$size = size($entries);
						// do this in reverse order because the widget wants to
						// reconnect to the lowest index when its attr is deleted out
						// from under it, so we don't want it to keep reconnecting all the time
						for( $i = $size -1; $i >= 0; $i-- ){
							string $multiName = $gAEAttrPresetCurrentTarget + "." + $entries[$i];
							string $scalarAtrs[] = `listAttr -s $multiName`;
							string $atrs[] = `listAttr $multiName`;
							int $doDelete = 1;
							// we only care about applying presets on scalars, but there
							// might be connections on non-scalar siblings or parents
							if( size( $scalarAtrs ) > 0 ){
								for ($atr in $atrs) 
								{
									string $attrName = $gAEAttrPresetCurrentTarget + "." + $atr;
									if( !objExists( $attrName )
									|| `connectionInfo -id $attrName`
									|| `connectionInfo -is $attrName`
					 				|| `connectionInfo -il $attrName`){
									// only delete if no children are connected or
									// locked
										$doDelete = 0;
										break;
									}
								}
							} else {
								$doDelete = 0;
							}
							if( $doDelete ){
								removeMultiInstance $multiName;	
							} 
						}
					}
				}
			}
		}
	} else {
		$gAEAttrPresetCurrentTarget = "";
	}
}
