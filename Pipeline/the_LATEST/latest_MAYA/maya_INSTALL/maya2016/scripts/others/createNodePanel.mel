// Copyright (C) 1997-2014 Autodesk, Inc., and/or its licensors.
// All rights reserved.
//
// The coded instructions, statements, computer programs, and/or related
// material (collectively the "Data") in these files contain unpublished
// information proprietary to Autodesk, Inc. ("Autodesk") and/or its licensors,
// which is protected by U.S. and Canadian federal copyright law and by
// international treaties.
//
// The Data is provided for use exclusively by You. You have the right to use,
// modify, and incorporate this Data into other products for purposes authorized 
// by the Autodesk software license agreement, without fee.
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND. AUTODESK
// DOES NOT MAKE AND HEREBY DISCLAIMS ANY EXPRESS OR IMPLIED WARRANTIES
// INCLUDING, BUT NOT LIMITED TO, THE WARRANTIES OF NON-INFRINGEMENT,
// MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE, OR ARISING FROM A COURSE 
// OF DEALING, USAGE, OR TRADE PRACTICE. IN NO EVENT WILL AUTODESK AND/OR ITS
// LICENSORS BE LIABLE FOR ANY LOST REVENUES, DATA, OR PROFITS, OR SPECIAL,
// DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES, EVEN IF AUTODESK AND/OR ITS
// LICENSORS HAS BEEN ADVISED OF THE POSSIBILITY OR PROBABILITY OF SUCH DAMAGES.

//
//  Description:
//      Creation and manipulation of the createNode panel
//

global int $gCreateNodePanelInitDone = false;

global proc createNodePanel (string $panelName)
//
//  Description:
//		Create a new scripted createNodePanel.  If the scripted
//		panel hasn't yet been defined then define it.
//
{
	global string $gMainPane;

    if (!`scriptedPanelType -exists createNodePanel`) {
        //
        //  Define the callbacks for the createNode panel
        //
        scriptedPanelType
            -createCallback		"createNodeCreateCallback" 
            -initCallback		"createNodeInitCallback" 
            -addCallback		"createNodeAddCallback"
            -removeCallback		"createNodeRemoveCallback"
            -deleteCallback		"createNodeDeleteCallback"
            -saveStateCallback	"createNodeSaveStateCallback"
            createNodePanel;
    }

	//  instantiate a new createNodePanel
	//
	setParent $gMainPane;
	scriptedPanel 
        -unParent 
        -type createNodePanel 
        $panelName;
}

global proc createNodeCreateCallback(string $panelName) {
//
//  Description:
//      Create any editors unparented here and do
//      any other initialization required.
//
    addContextHelpProc $panelName "createNodeBuildContextHelpItems";
}


global proc createNodeInitCallback(string $panelName) {
//
//  Description:
//      Re-initialize the panel.
//
}

global proc createNodeSyncMenus(string $ned)
//
//  Description:
//     Sync the panel menu UI to current global state
//
{
    string $includeShadingGroupItem = ($ned + "ISGI");
    menuItem
        -edit
        -checkBox 
        `optionVar -query createMaterialsWithShadingGroup`
        $includeShadingGroupItem;

    string $createIncludePlacementItem = ($ned + "CIPI");
    menuItem
        -edit
        -checkBox 
        `optionVar -query createTexturesWithPlacement` 
        $createIncludePlacementItem;
}

proc createNodeAddMenus(string $ned)
//
//  Description:
//     Setup up the menu bar
//
{
    menu -label (uiRes("m_createNodePanel.kOptions")) 
        -pmc ("createNodeSyncMenus(\"" + $ned + "\")");

    string $includeShadingGroupItem = ($ned + "ISGI");
    menuItem 
        -label (uiRes("m_createNodePanel.kIncludeShadingGroupwithMaterials")) 
        -checkBox true
        -annotation 
        (uiRes("m_createNodePanel.kIncludeShadingGroupwithMaterialsAnnot"))
        $includeShadingGroupItem;

    menuItem
        -edit
        -checkBox 
        `optionVar -query createMaterialsWithShadingGroup` 
        -command 
        ("optionVar -intValue createMaterialsWithShadingGroup "
         + "`menuItem -query -checkBox " 
         + $includeShadingGroupItem
         + "`; refreshCreateNodeUI();")
        $includeShadingGroupItem;

    string $createIncludePlacementItem = ($ned + "CIPI");
    menuItem 
        -label (uiRes("m_createNodePanel.kIncludePlacementWithTextures")) 
        -checkBox true
        -annotation 
        (uiRes("m_createNodePanel.kIncludePlacementWithTexturesAnnot"))
        $createIncludePlacementItem;
    menuItem
        -edit
        -checkBox 
        `optionVar -query createTexturesWithPlacement` 
        -command 
        ("optionVar -intValue createTexturesWithPlacement "
         + "`menuItem -query -checkBox " 
         + $createIncludePlacementItem
         + "`; refreshCreateNodeUI();")
        $createIncludePlacementItem;
		
    setParent -m ..;  // from optionsMenu
}

global proc changeNodeLibrary(string $ned, string $library, int $force)
{
	// Something seriously went wrong if we can't find the nodeTreeLister.
	if (!`nodeTreeLister -q -ex $ned`)
		return;

	// First check to see if the nodeTreeLister is already viewing the input
	// library, so we don't needlessly destroy/re-create it.
	string $currLibrary = `nodeTreeLister -q -nodeLibrary $ned`;
	if (($currLibrary != "") && ($currLibrary == $library) && !$force) {
		return;
	}

	nodeTreeLister -e -clearContents $ned;

	// The default node library is "Hypershade"
	if (($library == uiRes("m_createNodePanel.kHypershade")) || ($library == "Hypershade"))
	{
		createNodeBuildListerContent($ned);

		// Set the node library type, so we can query it later.
		nodeTreeLister -e -nodeLibrary "Hypershade" $ned;
	}
	else
	{
		// Query VNN for the libraries from this runTime, where
		// $library = VNN runtime.
		string $runTime = $library;
		string $lib;
		string $libraries[] = `vnn -libraries $runTime`;
		for ($lib in $libraries)
		{
			// Then query VNN for each of the nodes in the library.
			string $node;
			string $nodes[] = `vnn -nodes $runTime $lib`;
			for ($node in $nodes)
			{
				string $itemPath = /*$runTime + "/" + */ $lib + "/" + $node;
				string $iconPath = "";	// We have no icons yet
				string $vnnStr = $runTime + "," + $lib + "," + $node;
				catch(`nodeTreeLister -e -addVnnItem $itemPath $iconPath $vnnStr $ned`);
			}
		}

		// Set the node library type, so we can query it later.
		nodeTreeLister -e -nodeLibrary $library $ned;
	}
}

global proc string createLibraryOptionMenu(string $ned)
//
//  Description:  If there are any VNN runTimes registered, then we need
//				  to create an optionMenu to allow user to choose between
//				  the default Hypershade nodes and these.
{
	// Get the array of runTimes registered with VNN.
	// If there aren't any then we don't need to create an option menu.
	string $runTimes[] = `vnn -runTimes`;
	if (size($runTimes) == 0)
		return "";

	string $opt = `optionMenu
		-annotation (uiRes("m_createNodePanel.kLibraryOptionMenuAnnot"))
		-changeCommand ("changeNodeLibrary " + $ned + " \"#1\" false")
		`;

		menuItem -label (uiRes("m_createNodePanel.kHypershade"));
		for ($i=0; $i < size($runTimes); $i++)
		{
			menuItem -label $runTimes[$i];
		}

	return $opt;
}

global proc refreshListerContent(string $ned)
{
	// Force the nodeTreeLister to update.
	string $library = `nodeTreeLister -q -nodeLibrary $ned`;
	if ($library != "")
		changeNodeLibrary($ned, $library, true);
}

global proc createNodeBuildListerContent(string $ned)
//
//  Description:  Fill the treeLister with the desired contents
//
{
	buildRenderNodeTreeListerContent($ned, "", "");
}

proc createNodeOneTimeInit()
//
//  Description:  Do one-time 'global' initialization for this panel type
//
{
	// Establish callbacks which will be called when a plugin is loaded/unloaded
	//
	global int $gCreateNodePanelInitDone;

	if (!$gCreateNodePanelInitDone)
	{
		loadPlugin -addCallback createNodeLoadPluginCallback;
		unloadPlugin -addCallback createNodeUnloadPluginCallback;
		$gCreateNodePanelInitDone = true;
	}
}

global proc createNodeAddCallback(string $panelName) {
//
//  Description:  Create UI and parent any editors.
//

	string $ned = ( $panelName + "CreateNodeEd" );

	waitCursor -state on;

	// Make sure that there is no template active
	setUITemplate -pushTemplate NONE;
    
    createNodeOneTimeInit();

    createNodeAddMenus($ned);

    string $baseForm = `formLayout`;

	// Create (if needed) the library option menu.
	string $optionMenu = createLibraryOptionMenu($ned);

	// Parent the editors to the editor layout
	//
    // We just create it here.
	// The default node library is "Hypershade" which we set on the nodeTreeLister
	// so we can query it later.
    //
	nodeTreeLister -nodeLibrary "Hypershade" $ned;
    createNodeBuildListerContent($ned);

	if ($optionMenu == "")
	{
		formLayout -edit
			-attachForm $ned left 0
			-attachForm $ned right 0
			-attachForm $ned bottom 0
			-attachForm $ned top 0
			$baseForm;
	}
	else
	{
		nodeTreeLister -e
			-refreshCommand ("refreshListerContent " + $ned)
			$ned;

		formLayout -edit
			-attachForm     $optionMenu top    5
			-attachForm     $optionMenu left   5
			-attachPosition $optionMenu right  5 50
			-attachNone     $optionMenu bottom

			-attachControl  $ned top    5 $optionMenu
			-attachForm     $ned left   0
			-attachForm     $ned right  0
			-attachForm     $ned bottom 0
			$baseForm;
	}
	setParent -top;

	setUITemplate -popTemplate;
	waitCursor -state off;
}

global proc createNodeRemoveCallback(string $panelName) {
//
//  Description:
//        Unparent any editors and save state if required.
//
	string $ned = ($panelName + "CreateNodeEd");
    callPython "maya.app.general.tlfavorites" "detachStore" {$ned};
    if (`nodeTreeLister -q -ex $ned`) {
        deleteUI -control $ned;
    }
}

global proc createNodeDeleteCallback(string $panelName) {
//
//  Description:
//        Delete any editors and do any other cleanup required.
	string $ned = ($panelName + "CreateNodeEd");
    if (`nodeTreeLister -q -ex $ned`) {
        deleteUI -control $ned;
    }
}

global proc string createNodeSaveStateCallback(string $panelName) {
//
//  Description:
//        Return a string that will restore the current state
//        when it is executed.
//
    return "";
}

global proc createNodeBuildContextHelpItems(string $nameRoot, string $menuParent)
//
//  Description:
//		Build context sensitive menu items for the create node panel.  
//		
//  Input Arguments:
//		$nameRoot - name to use as the root of all item names
//		$menuParent - the name of the parent of this menu
//
//  Return Value:
//      None
//
{
	menuItem -label (uiRes("m_createNodePanel.kHelpOnCreateNode"))
		-enableCommandRepeat false
		-command "showHelp CreateNodePanel";
}

proc createNodePluginChange(string $changeType, string $plugin)
{
	//
	// Description:
	//	This procedure is called from createNodeLoadPluginCallback() or 
	//	from createNodeUnloadPluginCallback(). If this method has been 
	//	called because a plugin has finished loading, $changeType should be
	//	"load". If it has been called because a plugin is about to be
	//	unloaded, $changeType should be "unload".
	//
    
    // if this plugin doesn't define nodes then we are good
    //
	string $pluginNodeTypeArray[] = `pluginInfo -query -dependNode $plugin`;
    if (`size $pluginNodeTypeArray` == 0) {
        return;
    }

    // Be safe and reload all instances of the panel.
    string $panels[] = `lsUI -panels`;
    string $panelName;
    for($panelName in $panels)
    {
        if (startsWith($panelName, "createNodePanel")) 
        {
            string $ned = ($panelName + "CreateNodeEd");
            if (`nodeTreeLister -q -ex $ned`) {
                // detach favorites store, and rebuild contents
                // the build procedure will re-attach the store
                //
                callPython "maya.app.general.tlfavorites" "detachStore" {$ned};
                nodeTreeLister -e -clearContents $ned;
                if ($changeType == "unload") {
                    // plugin is not yet unloaded - so don't rebuild contents until
                    // later
                    evalDeferred("createNodeBuildListerContent(\"" + $ned + "\")");
                } else {
                    createNodeBuildListerContent($ned);
                }
            }
        }
    }
}

global proc createNodeUnloadPluginCallback(string $plugin)
{
	//
	// Description:
	//	This procedure is called immediately before a plugin is unloaded.
	//
	createNodePluginChange("unload", $plugin);
}

global proc createNodeLoadPluginCallback(string $plugin)
{
	//
	// Description:
	//	This procedure is called immediately after a plugin is loaded.
	//
	createNodePluginChange("load", $plugin);
}

