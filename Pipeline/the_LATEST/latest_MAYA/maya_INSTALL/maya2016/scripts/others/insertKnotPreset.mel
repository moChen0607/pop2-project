// Copyright (C) 1997-2014 Autodesk, Inc., and/or its licensors.
// All rights reserved.
//
// The coded instructions, statements, computer programs, and/or related
// material (collectively the "Data") in these files contain unpublished
// information proprietary to Autodesk, Inc. ("Autodesk") and/or its licensors,
// which is protected by U.S. and Canadian federal copyright law and by
// international treaties.
//
// The Data is provided for use exclusively by You. You have the right to use,
// modify, and incorporate this Data into other products for purposes authorized 
// by the Autodesk software license agreement, without fee.
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND. AUTODESK
// DOES NOT MAKE AND HEREBY DISCLAIMS ANY EXPRESS OR IMPLIED WARRANTIES
// INCLUDING, BUT NOT LIMITED TO, THE WARRANTIES OF NON-INFRINGEMENT,
// MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE, OR ARISING FROM A COURSE 
// OF DEALING, USAGE, OR TRADE PRACTICE. IN NO EVENT WILL AUTODESK AND/OR ITS
// LICENSORS BE LIABLE FOR ANY LOST REVENUES, DATA, OR PROFITS, OR SPECIAL,
// DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES, EVEN IF AUTODESK AND/OR ITS
// LICENSORS HAS BEEN ADVISED OF THE POSSIBILITY OR PROBABILITY OF SUCH DAMAGES.

//
//
//
//
//
//
//  Creation Date:  Mar. 14, 1997
//
//  Description:
//      The insertKnotPreset() procedure executes a insertKnot operation 
//		on each selected object based on the insertKnot option vars.
//
//  Input Arguments:
//      None.
//
//  Return Value:
//      None.
//

proc string checkFirstAndLastKnot( string $crvPts )
//
//	Description:
//		This checks for whether or not the given curve pts 
//		really refer to the first and last edit pts of
//		a closed/periodic curve.  In this case, the first edit
//		point is converted to the last parameter value,
//		ie. curve1.ep[0] ---> curve1.u[8] so that
//		knots are really inserted between the last edit point and
//		the first one.
//
{
	// Check if the curve is periodic.  If not, then return
	//
	string $newStr = "";
	string $reg = ".";
	string $curveName[];
	int $num = tokenize( $crvPts, $reg, $curveName);
	if( (`getAttr ($curveName[0] + ".form")`) != 2 ) {
		return $newStr;
	}

	// Check if the first and last edit point are BOTH selected
	//
	string $firstEP = ($curveName[0] + "\\.ep\\[0\\]");
	int $numSpans = `getAttr ($curveName[0] + ".spans")` - 1;
	if( $numSpans < 3 ) return $newStr;

	string $lastEP = ($curveName[0] + "\\.ep\\[" + $numSpans + "\\]");

	int $foundFirst = 0;
	int $foundLast = 0;
	string $matchFirstStr = match( $firstEP, $crvPts );
	if( size($matchFirstStr) > 0 ) {
		$foundFirst = 1;
	}
	if( $foundFirst==1 ) {
		string $matchLastStr = match( $lastEP, $crvPts );
		if(size($matchLastStr) > 0 ) {
			$foundLast = 1;
		}
	}

	if( $foundFirst==1 && $foundLast==1 ) {
		// If only the first and last edit points are specified,
		// then convert the first edit point into the last parameter value
		// If there are other points specified as well, then
		// ADD the first edit point as the last parameter value.
		//
		float $maxParm = `getAttr ($curveName[0] + ".maxValue")`;
		string $crvResults[];
		int $numCrvPts = tokenize($crvPts, " ", $crvResults);
		if( $numCrvPts > 2 ) {
			// Add the first edit point as a curve pt
			float $maxParm = `getAttr ($curveName[0] + ".maxValue")`;
			$newStr = $crvPts +
					(" " + $curveName[0] + ".u[" + $maxParm + "]");
		} else {
			// Convert the first edit point into a curve pt
			string $replaced;
			$newStr = substitute( $firstEP, $crvPts, 
				($curveName[0] + ".u[" + $maxParm + "]"));
		}
	}
	return $newStr;
}

proc performInsertPresetCurves( int $history,
								int $rpo,
								int $numKnots,
								int $addOrComplement,
								int $multi,
								string $curves[],
								string $results[] )
//
//	Description:
//		This proc takes the given curve parm points and groups
//		them according to the curve, then executes an "insertKnotCurve"
//		command on each curve.  eg. if the curve points coming in are:
//		   curve1.u[0.4] curve1.u[0.66] curve2.u[0.67] curve1.u[0.9]
//		this proc will execute these two commands:
//			insertKnotCurve ... -p 0.4 -p 0.66 -p 0.9 curve1;
//			insertKnotCurve ... -p 0.67 curve2;
// 		WARNING - assumes that the curves coming into this proc
// 		are parm points, ie. they have the format:
// 		<curveName>.u[<parameterValue>]
//
{
	string $cmd = "insertKnotCurve" + " -ch " + $history + " -cos on" +
		" -nk " + $numKnots + " -add " + $addOrComplement + 
		" -ib " + $multi +
		" -rpo " + $rpo + " ";

	string $results[];
	string $insertResults[];

	// For each string returned from groupObjectsByName, put together
	// an insertKnotSurface cmd and execute it.
	//
	string $groupStrings[];
	$groupStrings = groupObjectsByName( $curves, "\\." );
	int $numStrings = size( $groupStrings );
	string $execCmd;
	string $changeStr;

	for( $i = 0; $i < $numStrings; $i ++ ) {

		$execCmd = $cmd + " ";
		$changeStr = "";
		$changeStr = checkFirstAndLastKnot( $groupStrings[$i] );
		if( size($changeStr) > 0 ) {
			 $execCmd += $changeStr;
		} else {
			$execCmd += $groupStrings[$i];
		}

		// Execute $cmd + $groupStrings[$i]	
		//
		if( catch( $insertResults = evalEcho( $execCmd))) {
			string $tmpWarning = (uiRes("m_insertKnotPreset.kWarningProblemEvalInsertKnot"));
			warning( `format -s $cmd -s	$groupStrings[$i] $tmpWarning` );
		}
		else {
			int $j;
			int $numResults = size( $results );
			int $numDetachResults = size( $insertResults );
			for( $j = 0; $j < $numDetachResults; $j ++, $numResults ++ ) {
				$results[$numResults] = $insertResults[$j];
			}
		}
	}

	if( 0 == size($results) ) {
        error (uiRes("m_insertKnotPreset.kInsertFailedOnCurves"));
	}
}

proc performInsertPresetSurfaces( int $history,
								  int $rpo,
								  int $numKnots,
								  int $addOrComplement,
								  int $multi,
								  string $surfaces[],
								  string $results[] )
//
//	Description:
//		This proc takes the given surface isoparms and groups
//		them according to the surface, then executes an "insertKnotSurface"
//		command on each curve.  eg. if the isoparms coming in are:
//			surface1.u[0.33] surface1.v[0.66] surface2.v[0.55]
//		this proc will execute these three commands:
//			insertKnotSurface ... -d 1 -p 0.33 surface1;	// U direction
//			insertKnotSurface ... -d 0 -p 0.33 -rpo 1 surface1;	// V direction
//			insertKnotSurface ... -d 0 -p 0.55 surface2;	// V direction
//
// 		WARNING - assumes that the surfaces coming into this proc
// 		are isoparms, ie. they have the format:
//		<surfaceName>.u[<parameterValue>]
// 		or <surfaceName>.v[<parameterValue>]
//
{
	string $cmd = "insertKnotSurface" + " -ch " + $history + 
		" -nk " + $numKnots + " -add " + $addOrComplement + 
		" -ib " + $multi;

	string $results[];
	string $insertResults[];

	// for each string returned from groupObjectsByName, put together
	// an insertKnotSurface cmd and execute it.
	//
	string $groupStrings[];
	$groupStrings = groupObjectsByName( $surfaces, "\\." );
	int $numStrings = size( $groupStrings );
	string $execCmd;

	for( $i = 0; $i < $numStrings; $i ++ ) {

		// append appropriate replaceOriginal flag here
		$execCmd = $cmd + " -rpo " + $rpo + " ";

		string $parms[];
		$numParms = `tokenize $groupStrings[$i] $parms`;
		string $foundUStr = `match "\\.u\\[" $groupStrings[$i]`;
		string $foundVStr = `match "\\.v\\[" $groupStrings[$i]`;
		string $foundUVStr = `match "\\.uv\\[" $groupStrings[$i]`;
		int $foundU = (size($foundUStr) > 0);
		int $foundV = (size($foundVStr) > 0);
		int $foundUV = (size($foundUVStr) > 0);

		if( $numParms > 1 || $foundUV ) {

			// Get the surface name
			//
			string $surfaceName[];
			tokenize $groupStrings[$i] "\\." $surfaceName;

			// Format the parameter values with "-p" flag
			// Direction is set with "-d 1" flag
			//
			if( $foundU > 0 || $foundUV > 0 ) {
				$execCmd += " -d 1 ";

				int $p;
				for( $p = 0; $p < $numParms; $p ++ ) {
					string $regularExpr = "\\.u\\[.*\\]";
					string $parm = match($regularExpr, $parms[$p]);
					$strLen = size($parm);
					if( $strLen > 0 ) {

						// we could have an isoparam like .u[][a:b]
                        // so, we also do a tokenize filtering only the .u[]
                        // portion out.
						//
                        string $ucomp[] ;
                        int $nc ;
                        $nc = `tokenize $parm "]" $ucomp` ;
                        if( size($ucomp) > 0 )  {
	                        $parm = substring( $ucomp[0], 4, $strLen-1 );
   	                    	// append to $execCmd as a -p flag
							//
                        	$execCmd += " -p ";
                        	$execCmd += $parm;
                        }

					} else {
						string $regularExpr = "\\.uv\\[.*\\]\\[.*\\]";
						string $parm = match($regularExpr, $parms[$p]);
						$strLen = size($parm);
						if( $strLen > 0 ) {

							// change ".uv[0.444][0.66]" to ".uv[0.44"
							$parm = substitute( "\\]\\[.*\\]", $parm, "" );

							$strLen = size($parm);
							$parm = substring( $parm, 5, $strLen );
							$execCmd += " -p ";
							$execCmd += $parm;
						}
					}
				}

				// Add the surface name
				//
				$execCmd += " ";
				$execCmd += $surfaceName[0];

				// If V direction is also specified, then execute 
				// the U direction insert cmd right here
				//
				if( ($history > 0) && ($foundV > 0 || $foundUV > 0) ) {

					// Insert command returns the new surface and surface node.
					// Substitute the new surface as the surface name so if
					// inserting in the V direction too, it will be 
					// chained in sequence.
					// Also, copy the results for this insert commadn to
					// the results array.
					//
					string $tempResults[];
					$tempResults = evalEcho( $execCmd );
					int $numTempResults = size( $tempResults );
					if( $numTempResults == 2) {
						$surfaceName[0] = $tempResults[0];
						int $numResults = size( $results );
						for( $j = 0; $j < $numTempResults; $j ++, 
							$numResults ++ ) {
							$results[$numResults] = $tempResults[$j];
						}
					}
				}
			}

			if( $foundV > 0 || $foundUV > 0 ) {

				// If U direction was already executed, then make sure
				// we do "-rpo 1".  Otherwise, just set the direction.
				//
				if( ($history > 0) && 
					($foundU > 0 || $foundUV > 0) ) {
					$execCmd = $cmd + " -rpo 1 -d 0";
				} else {
					$execCmd = $cmd + " -d 0 ";
					// append appropriate replaceOriginal flag here
					$execCmd += " -rpo " ;
					$execCmd += $rpo;
					$execCmd += " ";
				}
					
				int $p;
				for( $p = 0; $p < $numParms; $p ++ ) {
					string $regularExpr = "\\.v\\[.*\\]";
					string $parm = match($regularExpr, $parms[$p]);
					$strLen = size($parm);
					if( $strLen > 0 ) {

						// we could have an isoparam like .v[][a:b]
                        // so, we also do a tokenize filtering only the .v[]
                        // portion out. 
						//
                        string $vcomp[] ;
                        int $nc ;
                        $nc = `tokenize $parm "]" $vcomp` ;
                        if( size($vcomp) > 0 ) {
                            $parm = substring( $vcomp[0], 4, $strLen-1 );
                            // append to $execCmd as a -p flag
                            $execCmd += " -p ";
                            $execCmd += $parm;
						}

					} else {
						string $regularExpr = "\\.uv\\[.*\\]\\[.*\\]";
						string $parm = match($regularExpr, $parms[$p]);
						$strLen = size($parm);
						if( $strLen > 0 ) {

							// change ".uv[0.444][0.66]" to "0.66]"
							$parm = substitute( "\\.uv\\[.*\\]\\[",$parm,"");

							$strLen = size($parm);
							$parm = substring( $parm, 1, $strLen-1 );
							$execCmd += " -p ";
							$execCmd += $parm;
						}
					}
				}
				// Add the surface name
				//
				$execCmd += " ";
				$execCmd += $surfaceName[0];
			}

		}
		else {
			$execCmd += $groupStrings[$i];
		}

		// execute $cmd + $groupStrings[$i]	
		if( catch( $insertResults = evalEcho( $execCmd))) {
			warning(`format -s $cmd -s	$groupStrings[$i] (uiRes("m_insertKnotPreset.kWarningProblemEvalInsertKnot"))` );
		}
		else {
			int $j;
			int $numResults = size( $results );
			int $numInsertResults = size( $insertResults );
			for( $j = 0; $j < $numInsertResults; $j ++, $numResults ++ ) {
				$results[$numResults] = $insertResults[$j];
			}
		}
	}

	if( 0 == size($results) ) {
        error (uiRes("m_insertKnotPreset.kInsertFailedOnSurfaces"));
	}
}

global proc insertKnotPreset( int $doHistory, int $replaceOriginal,
							  int $addOrComplement, int $numKnots,
							  int $multi, int $UorV )
{
	int $doHilite = false;

	// If multi is on, turn add or complement off:
	if( $multi ) {
		$addOrComplement = false;
	}

	// Do not allow both:
	if( $UorV > 1 ) $UorV = 1;
	if( $UorV < 0 ) $UorV = 0;

	// Get a list of each type of acceptable object type - surfaces and curves.
	//
	global int $gSelectSurfaceParmPointsBit;
	global int $gSelectCurveParmPointsBit;
	global int $gSelectNurbsSurfacesBit;
	global int $gSelectNurbsCurvesBit;
	global int $gSelectEditPointsBit;
	global int $gSelectIsoparmsBit;

	string $surfaceIsoparmList[] = `filterExpand -ex true -sm $gSelectIsoparmsBit -sm $gSelectSurfaceParmPointsBit`;

	string $curvePointList[] = `filterExpand -ex true -sm $gSelectCurveParmPointsBit -sm $gSelectEditPointsBit`;
	string $surfaceList[] = `filterExpand -ex true -sm $gSelectNurbsSurfacesBit`;
	string $curveList[] = `filterExpand -ex true -sm $gSelectNurbsCurvesBit`;

	if( $multi && size($surfaceList) > 0 ) {
		int $ignoredTrims = selectVisibleSurfaceIsoparms( $surfaceList,
														  $surfaceIsoparmList,
													  size($surfaceIsoparmList),
														  $UorV );
		if( $ignoredTrims > 0 ) {
			string $warningMsg = (uiRes("m_insertKnotPreset.kWarningIgnoredTrimInfo"));
			warning( `format -s $ignoredTrims $warningMsg` );
		}
	}

	if( $multi && size($curveList) > 0 ) {
		selectAllCurveKnots($curveList,0,$curvePointList,size($curvePointList));
	}

	if( (0 == size($curvePointList)) && (0 == size($surfaceIsoparmList)) ) {
		error (uiRes("m_insertKnotPreset.kInsertInvalidSelection"));
		return;
	}

	string $surfaceResults[]; // 
	if( size($surfaceIsoparmList) > 0 ) {
		if( !$doHilite ) $doHilite = `shouldHiliteAfterCompute`;
		performInsertPresetSurfaces( $doHistory, $replaceOriginal, $numKnots,
									 $addOrComplement, $multi,
									 $surfaceIsoparmList, $surfaceResults );
	}

	string $curveResults[];
	if( size($curvePointList) > 0 ) {
		if( !$doHilite ) $doHilite = `shouldHiliteAfterCompute`;
		performInsertPresetCurves( $doHistory, $replaceOriginal, $numKnots,
								   $addOrComplement, $multi,
								   $curvePointList, $curveResults );
	}

	if( (size($surfaceResults)+size($curveResults)) == 0 ) {
		error (uiRes("m_insertKnotPreset.kInsertFailedOnSelection"));
	}
	else {
		// Select all the results with one select command.  
		//
		string $selectString;
		$selectString = "select ";
		int $i;

		int $numSurfaces = size($surfaceResults);
		for( $i = 0; $i < $numSurfaces; $i ++ ) {
			$selectString += $surfaceResults[$i];
			$selectString += " ";
		}

		int $numCurves = size($curveResults);
		for( $i = 0; $i < $numCurves; $i ++ ) {
			$selectString += $curveResults[$i];
			$selectString += " ";
		}
		$selectString += ";";
		if( $doHilite ) $selectString += "hilite;";

		select -cl;
		eval($selectString);
	}
}

