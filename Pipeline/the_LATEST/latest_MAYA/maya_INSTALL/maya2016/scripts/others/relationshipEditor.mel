// Copyright (C) 1997-2014 Autodesk, Inc., and/or its licensors.
// All rights reserved.
//
// The coded instructions, statements, computer programs, and/or related
// material (collectively the "Data") in these files contain unpublished
// information proprietary to Autodesk, Inc. ("Autodesk") and/or its licensors,
// which is protected by U.S. and Canadian federal copyright law and by
// international treaties.
//
// The Data is provided for use exclusively by You. You have the right to use,
// modify, and incorporate this Data into other products for purposes authorized 
// by the Autodesk software license agreement, without fee.
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND. AUTODESK
// DOES NOT MAKE AND HEREBY DISCLAIMS ANY EXPRESS OR IMPLIED WARRANTIES
// INCLUDING, BUT NOT LIMITED TO, THE WARRANTIES OF NON-INFRINGEMENT,
// MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE, OR ARISING FROM A COURSE 
// OF DEALING, USAGE, OR TRADE PRACTICE. IN NO EVENT WILL AUTODESK AND/OR ITS
// LICENSORS BE LIABLE FOR ANY LOST REVENUES, DATA, OR PROFITS, OR SPECIAL,
// DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES, EVEN IF AUTODESK AND/OR ITS
// LICENSORS HAS BEEN ADVISED OF THE POSSIBILITY OR PROBABILITY OF SUCH DAMAGES.

//
//
//  Creation Date:  September 16, 1998
//
// Description:
//
//		Implementation of the relationship editor. The relationship editor is
//		a generic editor that can be reconfigured to perform a variety of
//		tasks which make relationships between entities.
//
//		Usually the relationship editor should be used to make relationships 
//		by choosing a "key" entity on one side of the relationship editor,
//		then choosing several entities on the other side of the relationship
//		editor. This workflow would create relationships between the key and 
//		each of	the other entities. Generally, the key may be chosen from 
//		either side. This describes a one-to-many relationship creation task.
//
//		If a plugin writer wants to add relationships, also refer to
//      WindowMenu.mel for information and routines for adding/removing
//      to the main menu's relationship editor menu.
//

//
//	Create a shared selection list called setList.
//	This is used for deformer set editing and render shader groups editing.
//
if (!`selectionConnection -exists setList`)
	selectionConnection	-setList setList;


if (!`scriptedPanelType -exists relationshipPanel`) 
//
// If you change this, you must also change the one in 
// initScriptedPanels.mel
//
{
	//
	//  Define the callbacks for the relationship panel.
	//
	scriptedPanelType
		-createCallback		"createRelationshipPanel" 
		-initCallback		"initRelationshipPanel"
		-addCallback		"addRelationshipPanel"
		-removeCallback		"removeRelationshipPanel"
		-saveStateCallback	"saveStateRelationshipPanel"
		-deleteCallback		"deleteRelationshipPanel"
		relationshipPanel;

}


// ---------------------------------------------------------------------------
//	Utility procedures
//

proc int isObjectSet( string $thing )
{
	return	`objectType -isAType "objectSet" $thing` ||
			`nodeType -api $thing` == "kPluginObjectSet" ;
}

proc updateCameraSetAE( string $key )
//
// Description:
//	This procedure updates the attribute editor for the cameraSet node
//  defined by the given key.
//
{
	string $nodeTokens[];
	tokenize $key "." $nodeTokens;
	string $selNodes[] = `selectedNodes`;
	string $sel;
	for ($sel in $selNodes)
	{
		if ($sel == $nodeTokens[0])
			updateAE $nodeTokens[0];
	}
}

// ---------------------------------------------------------------------------
//	Drop down list procedures
//


//  Create mapping to enable conversion between localized names and unlocalized task names
global string $relationshipEditorNameListLocalized[];
global string $relationshipEditorNameList[];

proc clearLocalizedNamesMap()
{
	global string $relationshipEditorNameListLocalized[];
	global string $relationshipEditorNameList[];

	clear($relationshipEditorNameListLocalized);
	clear($relationshipEditorNameList);
}

proc addToLocalizedLookupMap(string $localizedName, string $internalName)
{
	global string $relationshipEditorNameListLocalized[];
	global string $relationshipEditorNameList[];

	$relationshipEditorNameListLocalized[ size($relationshipEditorNameListLocalized) ] = $localizedName;
	$relationshipEditorNameList[ size($relationshipEditorNameList) ] = $internalName;
}

proc string convertLocalizedNameToTaskName(string $localizedName)
//
// Description: Takes long localized task name and converts to short task name
//
{
	global string $relationshipEditorNameListLocalized[];
	global string $relationshipEditorNameList[];

	int $foundId = stringArrayFind($localizedName, 0, $relationshipEditorNameListLocalized);
	if ( $foundId != -1 )
	{
		return $relationshipEditorNameList[$foundId];
	}
	else
	{
		return "";
	}
}

proc string convertTaskNameToLocalizedName(string $taskName)
//
// Description: Takes short task name and converts to localized version
//
{
	global string $relationshipEditorNameListLocalized[];
	global string $relationshipEditorNameList[];

	int $foundId = stringArrayFind($taskName, 0, $relationshipEditorNameList);
	if ( $foundId != -1 )
	{
		return $relationshipEditorNameListLocalized[$foundId];
	}
	else
	{
		return "";
	}
}

proc int findOptionMenuIndexByLabel(string $findLabelText, string $optionMenu)
//
// Description: Searches drop down list for matching localized label
// returns 1 based index of found value
// returns -1 for not found
//
{
	int $uiIndex = 0;
	int $foundValue = -1;

	// List all items in given drop down list 
	//
	string $itemListLong[] = `optionMenu -query -itemListLong $optionMenu`;
	for($item in $itemListLong)
	{
		$uiIndex++;

		// Match displayed label of item
		//
		string $labelText = `menuItem -query -label $item`;
		if ( $findLabelText == $labelText )
		{
			$foundValue = $uiIndex;
			break;
		}
	}

	return $foundValue;
}

// ---------------------------------------------------------------------------
//	Tasks
//

proc string relationshipEditorTask()
//
// Description:
//	This procedure returns the current task of the relationship editor.
//	The current task is stored as an optionVar, so it persists between
//	sessions.
//
//	You should not have to modify this procedure to add new tasks.
//
{
	// Try query existing value
	//
	string $taskName = "";
	if (`optionVar -exists relationshipEditorTask`)
	{
		$taskName = `optionVar -query relationshipEditorTask`;
	}

	// Validate value by inspecting GUI
	// Note: Plugins or different versions of Maya can change items displayed
	//
	string $localizedTaskName = convertTaskNameToLocalizedName($taskName);
	if ( findOptionMenuIndexByLabel( convertTaskNameToLocalizedName($taskName), "taskPopup" ) == -1 )
	{
		// Stored task was not found, select first available task in list instead
		//
		string $textOfCurrentMenuItem = `optionMenu -q -v taskPopup`;
		if ( $textOfCurrentMenuItem != "" )
		{
			// Convert display name to task name
			//
			$taskName = convertLocalizedNameToTaskName($textOfCurrentMenuItem);

			// Store value
			//
			optionVar -stringValue relationshipEditorTask $taskName;
		}
		else
		{
			// Error: No tasks listed in UI to select
		}
	}
	
	return $taskName;
}

proc string relationshipEditorPanel()
//
// Description:
//	This procedure returns the name of the panel containing the 
//	relationship editor.
//	If there is no relationship editor in existence, the behaviour of this
//	procedure is undefined.
//
//	ASSUMPTION: This procedure assumes there is a maximum of one 
//	relationship editor open. 
//
//	You should not have to modify this procedure to add new tasks.
//
{
	string $relationshipEditorPanels[] = 
		`getPanel -scriptType "relationshipPanel"`;
	
	return $relationshipEditorPanels[0];
}

// ---------------------------------------------------------------------------
// Task specific things to be added to when creating new tasks in the 
// relationship editor
//

proc setTaskLabels(
	string $panel,
	string $leftLabel,
	string $rightLabel)
//
// Description:
//	This procedure sets the text of the labels in the relationship editor
//	which describe what the current task is, what is displayed in the left
//	outliner, and what is displayed in the right outliner.
//
//	You should not have to modify this procedure to add new tasks.
//
{
	string $topLayout = `panel -query -control $panel`;

	setParent $topLayout;

	text
		-edit 
		-label $leftLabel
		-manage true
		"leftDescription";
	text
		-edit 
		-label $rightLabel
		-manage true
		"rightDescription";
}

proc string[] relatedItems(
	string $panel,
	string $task,
	string $key)
//
// Description:
//	This procedure is called when a new key is selected in the relationship
//	editor. This procedure returns a string array of related items.
//	This procedure should return a list of items which are related to the key
//	item in the context of the current task. If the current task is light
//	linking, for example, the return value of this procedure should be a list
//	of entities which are lightlinked to the key.
//
//	If you are implementing a new task, you will have to add code here to
//	determine what items are related to the key in the context of your task.
//
{
	string 	$relatedItems[];

	if ($task == "lightCentricLightLinking")
	{
		catch( $relatedItems = 
			`lightlink 
				-query 
				-shapes false
				-transforms true
				-hierarchy false
				-sets true
				-light $key` );
	}
	else if ($task == "objectCentricLightLinking")
	{
		catch( $relatedItems = 
			`lightlink 
				-query 
				-shapes false
				-transforms true
				-hierarchy false
				-sets true
				-object $key` );
	}
	else
	if ( ($task == "setMembership") ||
			  ($task == "deformerSetEd") )
	{
		if ( isObjectSet( $key ) )
			catch( $relatedItems = `sets -query $key` );
	}
	else if ($task == "partitionMembership")
	{
		if (`nodeType $key` == "partition" )
			catch( $relatedItems = `partition -query $key` );
	}
	else if ($task == "characterMembership")
	{
		// Find the related attributes and nodes
		//
		if (`nodeType $key` == "character" )
		{
			catch( $relatedItems = `sets -query $key` );
			string $relatedNodes[];
			catch( $relatedNodes = `character -nodesOnly -query $key` );
			for( $node in $relatedNodes ) {
				$relatedItems[size($relatedItems)] = $node;
			}
		}
	}
	else if ($task == "displayLayers")
	{
		if (`nodeType $key` == "displayLayer" )
			catch( $relatedItems = `editDisplayLayerMembers -q -fullNames $key` );
	}
	else if ($task == "animLayers")
	{
	    if (`nodeType $key` == "animLayer" ) {
	        catch( $relatedItems = `animLayer -q -attribute $key` );
	    }		
	}
	else if ($task == "renderLayers")
	{
		if (`nodeType $key` == "renderLayer" )
			catch( $relatedItems = `editRenderLayerMembers -q -fullNames $key` );
	}
	else if($task == "renderPassSetEd")
	{
		if (`nodeType $key` == "renderPassSet")
			catch( $relatedItems = `listConnections -type "renderPass" ($key + ".renderPass")`);
	}
	else if ($task == "uvCentricUvLinking")
	{
		catch( $relatedItems = `uvLink -query -uvSet $key` );
	}
	else if ($task == "textureCentricUvLinking")
	{
		catch( $relatedItems = `uvLink -query -texture $key` );
	}
	else if ($task == "furUVLinking")
	{
		// Get Fur UV Set in which fur descriptions are connected
		if( `nodeType $key` == "FurDescription" )
		{
			global string $furUVLinkShapeNode;
			if( size($furUVLinkShapeNode) != 0 )
			{
				$relatedItems[0] = HfGetFurUVSetAttribute($furUVLinkShapeNode);
			}
		}
	}
	else if ($task == "hairFurLinking")
	{
		// Get Fur Descriptions in which Hair system is connected
		if( `nodeType $key` == "hairSystem" )
		{
			string $curveAttrs[] = `listConnections -shapes true -type "FurCurveAttractors" $key`;
			if( size($curveAttrs) == 1 )
			{
				string $furFeedback[] = `listConnections -shapes true -type "FurFeedback" ($curveAttrs[0]+".CurveAttractorModel")`;
				
				for($feedback in $furFeedback)
				{
					string $furDes[] = `listConnections -shapes true -type "FurDescription" ($feedback+".Length")`;
					$relatedItems[size($relatedItems)] = $furDes[0];
				}
			}
		}
	}
	else if ($task == "pfxUVLinking")
	{
		// Get Poly's UV Set, which the PFX strokes are using
		global string $pfxUVLinkShapeNode;

		if( `nodeType $key` == "stroke" )
		{
			string $relatedStr;
			$relatedStr = pfxGetUVNameOfStroke($key, $pfxUVLinkShapeNode);

			if(!size($relatedStr))
			{
				updateStrokePolyConnections($pfxUVLinkShapeNode, $key);
				$relatedStr = $pfxUVLinkShapeNode + ".uvSet[0].uvSetName";
			}
			$relatedItems[0] = $relatedStr;
		}
	}
	else if ($task == "hairUVLinking")
	{
		// Get Poly's UV Set, which the Hairsystems are using
		global string $hairUVLinkShapeNode;

		if( `nodeType $key` == "hairSystem" )
		{
			$relatedItems[0] = hairGetUVSetOfHairSystem($key, $hairUVLinkShapeNode);
		}
	}
	else if ($task == "eventCentricInteraction")
	{
		// Get the downstream connections from the event attribute.  In order
		// to insure that the item is highlighted in the outliner, the attribute
		// name without the brackets must also be added to the list of related
		// items.
		if (`connectionInfo -isExactSource $key`) {
		    string $connections[] = `connectionInfo -dfs $key`;
			for ($con in $connections) {
				string $attr[];
				tokenize $con ".[" $attr;
				string $elements[] = `listAttr -multi ($attr[0] + "." + $attr[1])`;
				$relatedItems[size($relatedItems)] = ($attr[0] + "." + $elements[0]);
				$relatedItems[size($relatedItems)] = ($attr[0] + "." + $attr[1]);
			}
		}
	}
	else if ($task == "actionCentricInteraction")
	{
		// Get the upsteam connections from the multi-attribute action.
		// Tokenize the attribute to get the name of the multi-attribute.
		string $attrTokens[];
		int $numTokens = `tokenize $key ".[" $attrTokens`;
		
		// Get all of the children of the multi-attribute and add their
		// upstream connections if any to the list of related items.
		string $attrName = $attrTokens[0] + "." + $attrTokens[1];
		string $plugs[] = `listAttr -multi $attrName`;
		int $i = 0;
		for ($p in $plugs) {
		    string $childAttr = $attrTokens[0] + "." + $p;
		    string $upstream = `connectionInfo -sfd $childAttr`;
			if ($upstream != "") {
		        $relatedItems[$i++] = $upstream;
			}
		}
	}
	else if ($task == "touchSensorAssociation")
	{
		if( `nodeType $key` == "miTouchSensor" )
		{
			string $cmd = ("miTouchSensor -q "+$key);
			$relatedItems = eval( $cmd );
		}
	}
	else if ($task == "cameraSets")
	{
		// Get the downstream connections from the Camera and SceneData attributes
		// if the key is either a particular camera pass or an explicit camera or
		// draw data.
		string $attrTokens[];
		int $numTokens = `tokenize $key "[" $attrTokens`;
		
		if (size($attrTokens) > 1)
		{
			int $i = 0;
			string $subTokens[];
			string $nodeTokens[];
			int $numSubTokens = `tokenize $attrTokens[1] "." $subTokens`;
			if (size($subTokens) > 1)
			{
				// The key refers to an explicit camera or sceneData attribute.  Get its
				// upstream connection.
		    	string $upstream = `connectionInfo -sfd $key`;
				if ($upstream != "")
				{
					tokenize $upstream "." $nodeTokens;
		       		$relatedItems[$i++] = $nodeTokens[0];
				}
			}
			else
			{
				// A selection was made on a cameraLayer attribute.  Fill in the
				// related items as the connections from both the camera and sceneData
				// attributes.
		    	string $attr = $key + ".camera";
		    	string $upstream = `connectionInfo -sfd $attr`;
				if ($upstream != "")
				{
					tokenize $upstream "." $nodeTokens;
		       		$relatedItems[$i++] = $nodeTokens[0];
				}
		    	$attr = $key + ".sceneData";
		    	$upstream = `connectionInfo -sfd $attr`;
				if ($upstream != "")
				{
					$nodeTokens = {};
					tokenize $upstream "." $nodeTokens;
		       		$relatedItems[$i++] = $nodeTokens[0];
				}
			}
		}
	}
	
	return $relatedItems;
}

proc selectKeys(
	string $panel,
	string $task,
	string $keys[])
//
// Description:
//	This method is called after the user has clicked on an item on the LHS.
//	This method determines which keys are valid and selects them. Essentially,
//	this method ensures that only items which are valid keys are selectable on
//	the LHS.
//
{
	string $selectionConnection = ($panel + "LeftSelection");

	selectionConnection 
		-edit
		-addScript ""
		$selectionConnection;

	selectionConnection 
		-edit
		-removeScript ""
		$selectionConnection;

	selectionConnection -edit -clear $selectionConnection;

	int $i;

	for ($i = 0; $i < size($keys); $i++)
	{
		selectionConnection -edit -select $keys[$i] $selectionConnection;
	}

	selectionConnection 
		-edit
		-addScript 
			("relationshipEditorSelectKey "
				+ $panel
				+ " "
				+ $task)
		$selectionConnection;

	selectionConnection 
		-edit
		-removeScript
			("relationshipEditorDeselectKey "
				+ $panel
				+ " "
				+ $task)
		$selectionConnection;
}

proc selectRelatedItems(
	string $panel,
	string $task,
	string $keys[])
{
	if (size($keys) == 0)
	{
		return;
	}

//	print("selectRelatedItems\n");
//	int $i;
//	print("keys: ");
//	for ($i = 0; $i < size($keys); $i++)
//	{
//		print($keys[$i] + " ");
//	}
//	print("\n");
	
	string $otherSelection;
	
	$otherSelection = ($panel + "RightSelection");

	// Take note of what scripts are currently attached to the selection
	// connection on the other side
	//
	string $otherAddScript;
	string $otherRemoveScript;

	$otherAddScript = 
		`selectionConnection -query -addScript $otherSelection`;
	$otherRemoveScript = 
		`selectionConnection -query -removeScript $otherSelection`;

	// Turn off the add and remove scripts on the other side
	//
	selectionConnection 
		-edit 
		-addScript "" 
		-removeScript "" 
		$otherSelection;

	// Clear the current selection on the other side
	//
	selectionConnection 
		-edit
		-clear
		$otherSelection;

	// Turn on the wait cursor because this could take a few seconds
	//
	waitCursor -state on;

	// Select items on the other side which are related to the key
	//
//	print("determining relatedItems... ");
//	float $time;
//	timer -on;
	string $relatedItems[];
	string $intersection[];
	int $i;

	if (size($keys) > 1)
	{
		if ( !`exists relationshipEditorIntersector` ) {
			stringArrayIntersector relationshipEditorIntersector;
		} else {
			stringArrayIntersector -edit -reset relationshipEditorIntersector;
		}

		// There is more than one key so it is necessary for us to find the
		// intersection of the related items of each individual key
		//
		for ($i = 0; $i < size($keys); $i++)
		{
			$relatedItems = relatedItems($panel, $task, $keys[$i]);

			stringArrayIntersector 
				-edit
				-intersect $relatedItems
				relationshipEditorIntersector;
		}

		$intersection = 
			`stringArrayIntersector -q relationshipEditorIntersector`;
	
		deleteUI relationshipEditorIntersector;
	}
	else if (size($keys) == 1)
	{
		// There is only one key, so the related items are simply the items
		// related to that one key.
		//
		$intersection = relatedItems($panel, $task, $keys[0]);
	}

//	$time = `timer -off`;
//	print("done. (" + $time + " seconds)\n");
//	print("size($intersection) = " + size($intersection) + "\n");
//	print("highlighting related items... ");
//	timer -on;

	// This approach for highlighting items goes through the $intersection
	// list and makes a selectionConnection command call for each item. In the
	// interests of efficiency, two other approaches were tried but found to
	// be less efficient than this approach. 
	// The first alternative approach was to make the -select flag a multi-use 
	// flag, build one long command, and issue the command once. The overhead
	// of constructing the long command in MEL outweighed the benefit of
	// only needing to call the command once.
	// The second alternative approach was to make the command take a string
	// array in the hopes that the entire $intersection could be processed at
	// once. However, the command engine requires string arrays to be
	// presented in a particular format ({"string1", "string2", "string3"}).
	// Again, the overhead of constructing the command in MEL outweighed the
	// benefit of only needing to call the command once.
	//
	for ($i = 0; $i < size($intersection); $i++)
	{
		selectionConnection
			-edit
			-select $intersection[$i]
			$otherSelection;
	}

	// Set uvset current on hilighting
	if ($task == "textureCentricUvLinking")
	{
		if (size($intersection))
		{
			string $uvset = $intersection[0];
			if (size($uvset))
			{
				// Set the current uvset
				string $uvSetName = `getAttr $uvset`;
				string $buffer[];
				string $objName = "";
				int $numTokens = `tokenize $uvset "." $buffer`;
				if ($numTokens > 0)
					$objName = $buffer[0];
				if (size($uvSetName) && size($objName))
				{
					$command = "polyUVSet -currentUVSet -uvSet \"" + 
						$uvSetName + "\" " + $objName;
					catch( eval ($command) );
				}
			}
		}
	}

	// Set uvset current on hilighting
	if ( false
		|| $task == "hairUVLinking"
		|| $task == "furUVLinking"
		|| $task == "pfxUVLinking"
		)
	{
		if (size($intersection))
		{
			string $uvset = $intersection[0];
			if (size($uvset))
			{
				// Set the current uvset
				string $uvSetName = `getAttr $uvset`;
				string $buffer[];
				string $objName = "";
				int $numTokens = `tokenize $uvset "." $buffer`;
				if ($numTokens > 0)
					$objName = $buffer[0];
				if (size($uvSetName) && size($objName))
				{
					$command = "polyUVSet -currentUVSet -uvSet \"" + 
						$uvSetName + "\" " + $objName;
					catch( eval ($command) );
				}
			}
		}
	}


//	$time = `timer -off`;
//	print("done. (" + $time + " seconds)\n");

	// Turn off the wait cursor
	//
	waitCursor -state off;

	// Turn add and remove scripts back on
	//
	selectionConnection 
		-edit 
		-addScript $otherAddScript 
		-removeScript $otherRemoveScript 
		$otherSelection;
}
	
proc string[] validKeys(
	string $panel,
	string $task,
	string $keys[])
//
// Description:
//	This procedure validates keys. If you have a task for which some of the
//	items which appear on the LHS outliner are not valid keys, and you don't
//	want users to be able to select them, you can use this method to specify
//	which keys are valid and which aren't. Invalid keys won't be selectable.
//
// Returns: 
//	The list of valid keys (a subset of the keys which are passed in).
//
{
	string $rKeys[];
	int $i;
	
	if ($task == "uvCentricUvLinking")
	{
		for ($i = 0; $i < size($keys); $i++)
		{
			if (`uvLink -isValid -uvSet $keys[$i]`)
			{
				$rKeys[size($rKeys)] = $keys[$i];
			}
		}

		return $rKeys;
	}
	else if ($task == "furUVLinking")
	{
		//Validate the keys that are selected on the left outlinear.
		for ($i = 0; $i < size($keys); $i++)
		{
			if (`nodeType $keys[$i]` == "FurDescription")
			{
				global string $furUVLinkShapeNode;
				
				$rKeys = HfGetFurDescription($furUVLinkShapeNode);
			}
		}
		return $rKeys;
	}
	else if ($task == "hairFurLinking")
	{
		//Validate the keys that are selected on the left outlinear.
		for ($i = 0; $i < size($keys); $i++)
		{
			if (`nodeType $keys[$i]` == "hairSystem")
			{
				$rKeys[size($rKeys)] = $keys[$i];
			}
		}
		return $rKeys;
	}
	else if ($task == "textureCentricUvLinking")
	{
		for ($i = 0; $i < size($keys); $i++)
		{
			if (`uvLink -isValid -texture $keys[$i]`)
			{
				$rKeys[size($rKeys)] = $keys[$i];
			}
		}

		return $rKeys;
	}
	else if (($task == "eventCentricInteraction") ||
			 ($task == "actionCentricInteraction"))
	{
		for ($key in $keys)
		{
			// Tokenize the attribute.  If the attribute does not contain
			// an attribute name, filter it out.
			string $attrTokens[];
			int $numTokens = `tokenize $key "." $attrTokens`;
			if ($numTokens > 1)
				$rKeys[size($rKeys)] = $key;
		}

		return $rKeys;
	}
	else if ($task == "pfxUVLinking")
	{
		//Validate the keys that are selected on the left outlinear.
		global string $pfxUVLinkShapeNode;

		if(size($keys))
			$rKeys = updateStrokePolyConnections($pfxUVLinkShapeNode, $keys[0]);

		return $rKeys;
	}
	else if ($task == "hairUVLinking")
	{
		//Validate the keys that are selected on the left outlinear.
		global string $hairUVLinkShapeNode;

		if(size($keys))
			$rKeys = hairGetAllHairSystems($hairUVLinkShapeNode);

		return $rKeys;
	}
	else if ($task == "cameraSets")
	{
		for ($key in $keys)
		{
			// Tokenize the attribute.  If the attribute contains
			// an attribute name, verify that it is connected before
			// adding it as a valid key.
			string $attrTokens[];
			int $numTokens = `tokenize $key "." $attrTokens`;
			if ($numTokens > 2)
			{
				string $conns[] = `listConnections $key`;
				if (size($conns) > 0)
					$rKeys[size($rKeys)] = $key;
			}
			else
				$rKeys[size($rKeys)] = $key;
		}
		return $rKeys;
	}
	else
	{
		return $keys;
	}
}

proc string[] validItems(
	string $panel,
	string $task,
	string $items[])
//
// Description:
//	This procedure validates items. If you have a task for which some of the
//	items which appear on the RHS outliner are not valid items, and you don't
//	want users to be able to select them, you can use this method to specify
//	which items are valid and which aren't. Invalid items won't be selectable.
//
// Returns: 
//	The list of valid items (a subset of the items which are passed in).
//
{
	string $rItems[];
	int $i;
	
	if ($task == "uvCentricUvLinking")
	{
		for ($i = 0; $i < size($items); $i++)
		{
			if (`uvLink -isValid -texture $items[$i]`)
			{
				$rItems[size($rItems)] = $items[$i];
			}
		}

		return $rItems;
	}
	else if ($task == "furUVLinking")
	{
		// validate the right outlinear items when user tries to select them.
		for ($i = 0; $i < size($items); $i++)
		{
			if (`uvLink -isValid -uvSet $items[$i]`)
			{
				$rItems[size($rItems)] = $items[$i];
			}
		}

		return $rItems;
	}
	else if ($task == "textureCentricUvLinking")
	{
		for ($i = 0; $i < size($items); $i++)
		{
			if (`uvLink -isValid -uvSet $items[$i]`)
			{
				$rItems[size($rItems)] = $items[$i];
			}
		}

		return $rItems;
	}
	else if (($task == "eventCentricInteraction") ||
			 ($task == "actionCentricInteraction"))
	{
		for ($item in $items)
		{
			// Tokenize the string.  If the string does not contain
			// an attribute name, filter it out.
			string $attrTokens[];
			int $numTokens = `tokenize $item "." $attrTokens`;
			if ($numTokens > 1)
				$rItems[size($rItems)] = $item;
		}

		return $rItems;
	}
	else if ( false
		|| $task == "pfxUVLinking"
		|| $task == "hairUVLinking" 
		)
	{
		// validate the right outlinear items when user tries to select them.
		for ($i = 0; $i < size($items); $i++)
		{
			if (`uvLink -isValid -uvSet $items[$i]`)
			{
				$rItems[size($rItems)] = $items[$i];
			}
		}

		return $rItems;
	}
	
	else
	{
		return $items;
	}
}
	
global int $gPrevNumKeys = 0;
	
global proc relationshipEditorSelectKey(
	string $panel,
	string $task,
	string $dummy[])
//
// Description:
//	This procedure is called when a previously unhighlighted item on the 
// 	key side becomes highlighted.
//
//	This procedure highlights items related to the new keys.
//
//  You should not have to modify this procedure *unless* you are implementing
//  a task which is not a one-to-many relationship editing task. If you are
//  implementing a one-to-one relationship editing task, you will need to
//  ensure the non-key outliner allows only single selections if your task is
//  the current task. There is a place for you to do so near the end of this
//  procedure.
//
{

	//print(
	//	"relationshipEditorSelectKey " 
	//	+ $panel 
	//	+ " " 
	//	+ $task 
	//	+ "\n");

	string $thisSelection = ($panel + "LeftSelection");
	string $otherSelection = ($panel + "RightSelection");

	// Find out what the new keys are.
	// 
	string $selection[];
	string $keys[];

	$selection = `selectionConnection -query -object $thisSelection`;
	$keys = validKeys($panel, $task, $selection);

	// If the task is an interaction task, there can be only one key selected.
	// If there is more than one, just use the last one.
	if (($task == "eventCentricInteraction") ||
		($task == "actionCentricInteraction") ||
		($task == "touchSensorAssociation") ||
		($task == "cameraSets")) {
		if (size($keys) > 1) {
			string $tmp = $keys[size($keys)-1];
			clear($keys);
			$keys[0] = $tmp;
		}
	}

	// Select the valid keys
	//
	selectKeys($panel, $task, $keys);

	if ($task == "cameraSets")
	{
		if (size($keys) > 0)
		{
			menuItem -e -enable true leftEditMenuSelectHighlightedCameraSetItem;
			menuItem -e -enable true leftEditMenuDeleteHighlightedCameraSetItem;
			menuItem -e -enable true leftEditMenuCreateCameraLayer;

			string $buffer[];
			int $numTokens = `tokenize $keys[0] "[" $buffer`;
			if ($numTokens > 1)
				menuItem -e -enable true leftEditMenuDeleteHighlightedCameraLayerItem;
		}
		else
		{
			menuItem -e -enable false leftEditMenuSelectHighlightedCameraSetItem;
			menuItem -e -enable false leftEditMenuDeleteHighlightedCameraSetItem;
			menuItem -e -enable false leftEditMenuCreateCameraLayer;
			menuItem -e -enable false leftEditMenuDeleteHighlightedCameraLayerItem;
		}
	}

	if (size($keys) == 0) return;

	// Set the current uvset for on uv set selection
	if ($task == "uvCentricUvLinking")
	{
		// Set the current uvset
		string $uvSetName = `getAttr $keys[0]`;
		string $buffer[];
		string $objName = "";
		int $numTokens = `tokenize $keys[0] "." $buffer`;
		if ($numTokens > 0)
			$objName = $buffer[0];
		if (size($uvSetName) && size($objName))
		{
			$command = "polyUVSet -currentUVSet -uvSet \"" + 
				$uvSetName + "\" " + $objName;
			catch( eval ($command) );
		}
	}

//	int $i;
//	print("keys: ");
//	for ($i = 0; $i < size($keys); $i++)
//	{
//		print($keys[$i] + " ");
//	}
//	print("\n");

	// We will remember the number of keys so that the next time the keys
	// change we can be optimally efficient about updating the related items
	//
	global int $gPrevNumKeys;
	$gPrevNumKeys = size($keys);

	// Clear the selection on the other side. The keys have changed so the
	// related items have changed.
	//
	// First we disconnect the scripts on the other selection connection so 
	// that we don't end up breaking any connections between the old keys
	// and the old related items.
	//
	selectionConnection
		-edit
		-addScript ""
		-removeScript ""
		$otherSelection;

	selectionConnection
		-edit
		-clear
		$otherSelection;

	// Select items on the other side which are related to the current keys
	//
	selectRelatedItems($panel, $task, $keys);

	// Attach new scripts to the other side, specifying all of the current
	// keys. These scripts will make and break relationships with the 
	// current keys.
	//
	string $addScript;
	string $removeScript;

	$addScript = 
		("relationshipEditorMakeRelationship "
			+ $panel
			+ " "
			+ $task);

	$removeScript = 
		("relationshipEditorBreakRelationship "
			+ $panel
			+ " "
			+ $task);

	selectionConnection
		-edit
		-addScript 		$addScript
		-removeScript 	$removeScript
		$otherSelection;
}

global proc relationshipEditorDeselectKey(
	string $panel,
	string $task,
	string $dummy[])
//
// Description:
//	This procedure is called when a previously highlighted item on the 
// 	key side becomes unhighlighted.
//
//	This procedure highlights items related to the new keys.
//
//  You should not have to modify this procedure *unless* you are implementing
//  a task which is not a one-to-many relationship editing task. If you are
//  implementing a one-to-one relationship editing task, you will need to
//  ensure the non-key outliner allows only single selections if your task is
//  the current task. There is a place for you to do so near the end of this
//  procedure.
//
{
	//print(
	//	"relationshipEditorDeselectKey " 
	//	+ $panel 
	//	+ " " 
	//	+ $task 
	//	+ "\n");

	string $thisSelection = ($panel + "LeftSelection");
	string $otherSelection = ($panel + "RightSelection");

	// Find out what the new keys are.
	// 
	string $selection[];
	string $keys[];

	$selection = `selectionConnection -query -object $thisSelection`;
	$keys = validKeys($panel, $task, $selection);

	//Fur/UV Linking behaves differently(like many-to-one relationship)
	//compared with other relationship editor
	if ($task == "cameraSets")
	{
		// If no keys are selected, disable the Create Camera Layer menu item
		if (size($keys) == 0)
		{
			menuItem -e -enable false leftEditMenuSelectHighlightedCameraSetItem;
			menuItem -e -enable false leftEditMenuDeleteHighlightedCameraSetItem;
			menuItem -e -enable false leftEditMenuCreateCameraLayer;
			menuItem -e -enable false leftEditMenuDeleteHighlightedCameraLayerItem;
		}
	}
	else if ($task == "furUVLinking") 	
	{
	   if( size($selection) != 0  && `nodeType $selection[0]` == "FurDescription" )
	   {
			relationshipEditorSelectKey($panel, $task, $selection);
			return;
	   }
	}
	else if ($task == "hairUVLinking") 	
	{
	   if( size($selection) != 0  && `nodeType $selection[0]` == "hairSystem" )
	   {
			relationshipEditorSelectKey($panel, $task, $selection);
			return;
	   }
	}
	else if ($task == "pfxUVLinking") 	
	{
	   if( size($selection) != 0  && `nodeType $selection[0]` == "stroke" )
	   {
			relationshipEditorSelectKey($panel, $task, $selection);
			return;
	   }
	}

	// Clear the selection on the other side. The keys have changed so the
	// related items have changed.
	//
	// First we disconnect the scripts on the other selection connection so 
	// that we don't end up breaking any connections between the old keys
	// and the old related items.
	//
	selectionConnection
		-edit
		-addScript ""
		-removeScript ""
		$otherSelection;

	selectionConnection
		-edit
		-clear
		$otherSelection;

	string $addScript;
	string $removeScript;
	global int $gPrevNumKeys;

	if (size($keys) > 0)
	{
		// Select items on the other side which are related to the current keys.
		// If there is currently only one key and there was previously only
		// one key, then we won't call selectRelatedItems here because it will
		// be called from relationshipEditorSelectKey. This optimization means
		// that when the user switches from one key to another key the related
		// items will only be updated once instead of twice.
		//
		if ((size($keys) != 1) || ($gPrevNumKeys != 1))
		{
			selectRelatedItems($panel, $task, $keys);
		}

		// Attach new scripts to the other side, specifying all of the current
		// keys. These scripts will make and break relationships with the 
		// current keys.
		//
		$addScript = 
			("relationshipEditorMakeRelationship "
				+ $panel
				+ " "
				+ $task);

		$removeScript = 
			("relationshipEditorBreakRelationship "
				+ $panel
				+ " "
				+ $task);
	}
	else
	{
		$addScript = 
			("relationshipEditorDisallowSelectItem "
				+ $panel
				+ " "
				+ $task);
		$removeScript = "";
	}

	// We will remember the number of keys so that the next time the keys
	// change we can be optimally efficient about updating the related items
	//
	$gPrevNumKeys = size($keys);

	selectionConnection
		-edit
		-addScript 		$addScript
		-removeScript 	$removeScript
		$otherSelection;
}

global proc relationshipEditorDisallowSelectItem(
	string $panel,
	string $task,
	string $items[])
{
	selectionConnection
		-edit
		-clear
		($panel + "RightSelection");
}

global proc disableRelationshipsChangedScript(
	string $panel,
	string $task)
//
// Description:
//	This procedure is called from relationshipEditorMakeRelationship and from
//	relationshipEditorBreakRelationship when a relationship is about to be
//	made or broken.
//	This procedure disables the callback script
//	relationshipEditorRelationshipsChanged so that the relationship editor
//	won't be notified of changes to relationships until the callback script is
//	reenabled.
//	The callback script is reenabled by a call to 
//	setRelationshipsChangedScript.
//
{
	global int $gRelationshipsChangedScriptJobNumber;

	if ($gRelationshipsChangedScriptJobNumber != -1)
	{
		scriptJob -force -kill $gRelationshipsChangedScriptJobNumber;
		$gRelationshipsChangedScriptJobNumber = -1;
	}
}

proc int isCameraObj( string $obj )
{
	if ( `objectType -isa "transform" $obj` ) { 
		string $camera[] = `ls -dag -type "camera"`;
		if ( size( $camera ) > 0 ) { 
			return 1; 
		}
	}
	python( "import maya.app.stereo.stereoCameraRig as stereoCameraRig" );
	int $result = python( "stereoCameraRig.isRigRoot('" + $obj + "')" ); 
	return $result; 
}

global proc relationshipEditorMakeRelationship(
	string $panel,
	string $task,
	string $unvalidatedItems[])
//
// Description:
//	This procedure is called when the user selects one or more items which were 
//	previously unselected on the non-key side. 
//	This procedure makes relationships between the key and the newly selected
//	items, in the context of the current task. For example, if the current task
//	is light linking, then a light link would be created between the key and
//	each of the newly selected items.
//
//	If you are implementing a new task, you will need to add code to this
//	procedure to make relationships in the context of your task.
//
//	Remember, there may be more than one newly selected item.
//
{
	disableRelationshipsChangedScript($panel, $task);

	string $leftSelection = ($panel + "LeftSelection");
	string $keys[] = `selectionConnection -query -object $leftSelection`;
	string $validItem[] = validItems($panel, $task, $unvalidatedItems);
	string $rightOutliner = ($panel + "RightOutliner");

	int $h;
	string $item[];
	string $parentItem[];

	for ($h = 0; $h < size($validItem); $h++)
	{
		if (	(	$task=="deformerSetEd" 
				 ||	$task=="lightCentricLightLinking"
				 ||	$task=="objectCentricLightLinking" 
				 )
			&& 	(`outlinerEditor -isChildSelected $validItem[$h] -query $rightOutliner`))
		{
			// The user has clicked on a node which is not itself linked, but
			// some of its descendants are. In this case we want to break the
			// links between the key and the descendants of the current
			// node, instead of making links with the descendants. 
			// Usually this situation occurs when the key item is linked to
			// items in a group or other hierarchy. The group or hierarchy
			// itself is not linked to the key item, but items in the group or
			// hierarchy are. The group or hierarchy is highlighted in a way
			// that indicates that its descendants are linked. We want to allow
			// the user to make/break all links in the hierarchy by clicking on
			// the top node.
			//
			// For 3.0.1 this functionality has been enabled strictly for light
			// linking tasks, but we may later choose to enable it for other
			// tasks in the relationship editor if deemed appropriate.
			//
			// Here we take note of the item which meets these particular
			// criteria, so that we can break links to it a bit further down.
			//
			$parentItem[size($parentItem)] = $validItem[$h];
		}
		else
		{
			$item[size($item)] = $validItem[$h];
		}
	}

	// Break relationships between the keys and any items the user clicked on 
	// whose descendants were already related. This functionality is only used
	// for light linking tasks as of 3.0.1
	//
	if (size($parentItem) != 0)
	{
		relationshipEditorBreakRelationship(
			$panel, 
			$task, 
			$parentItem);
	}

	// If there were no valid items in the user's selection, we don't make a
	// relationship.
	//
	if (size($item) > 0)
	{
		// Issue the appropriate command, according to the current task, to 
		// make relationships between the key and each item in $item
		//
//		print("Making relationship between ");
//		print($keys);
//		print(" and");

//		int $i;
//		for ($i = 0; $i < size($item); $i++)
//		{
//			print(" ");
//			print($item[$i]);
//		}
//		print("\n");

		int $i;
		int $numKeys = size($keys);

		// Turn on the wait cursor
		//
		waitCursor -state on;

		string $warn;
		string $warnMsg;
		
		if ($task == "lightCentricLightLinking")
		{
			string $keyType;
			string $itemType;

			$keyType = "light";
			$itemType = "object";

			string $command;
			$command = 
				("lightlink -make ");
			
			for ($i = 0; $i < size($keys); $i++)
			{
				$command = 
					($command 
						+ "-"
						+ $keyType
						+ " "
						+ $keys[$i]
						+ " ");
			}

			for ($i = 0; $i < size($item); $i++)
			{
				$command = 
					($command 
						+ "-"
						+ $itemType
						+ " "
						+ $item[$i] 
						+ " ");
			}

			catch( eval ($command) );
		}
		else if ($task == "objectCentricLightLinking")
		{
			string $keyType;
			string $itemType;

			$keyType = "object";
			$itemType = "light";

			string $command;
			$command = 
				("lightlink -make ");
			
			for ($i = 0; $i < size($keys); $i++)
			{
				$command = 
					($command 
						+ "-"
						+ $keyType
						+ " "
						+ $keys[$i]
						+ " ");
			}

			for ($i = 0; $i < size($item); $i++)
			{
				$command = 
					($command 
						+ "-"
						+ $itemType
						+ " "
						+ $item[$i] 
						+ " ");
			}

			catch( eval ($command) );
		}
		else
		if ($task == "displayLayers") 
		{
			// add the list of items to the layer (key)
			//
			for ($i = 0; $i < $numKeys; $i++)
			{
				if ( `nodeType $keys[$i]` == "displayLayer" ) {
					catch( `editDisplayLayerMembers -nr $keys[$i] $item` );
				}
				else {
					$warn = (uiRes("m_relationshipEditor.kInvalidDisplayLayerSelection"));
					$warnMsg = `format -s $keys[$i] $warn`;
					warning($warnMsg);
				}
			}
		}
		else if ($task == "renderLayers")
		{
			// add the list of items to the layer (key)
			//
			for ($i = 0; $i < $numKeys; $i++)
			{
				if ( `nodeType $keys[$i]` == "renderLayer" ) {
					catch( `editRenderLayerMembers -nr $keys[$i] $item` );
				}
				else {
					$warn = (uiRes("m_relationshipEditor.kInvalidRenderLayerSelection"));
					$warnMsg = `format -s $keys[$i] $warn`;
					warning($warnMsg);
				}
			}
		}
		else if ($task == "renderPassSetEd")
		{
			// add the list of items to the render pass set (key)
			//
			for ($i = 0; $i < $numKeys; $i++)
			{
				if ( `nodeType $keys[$i]` == "renderPassSet" ) {
					string $renderPassesConnected[] = `listConnections ($keys[$i] + ".renderPass")`;
					for($j = 0; $j < size( $item ); $j++)
						if(!stringArrayContains($item[$j], $renderPassesConnected))
							connectAttr -nextAvailable ($keys[$i] + ".renderPass") ($item[$j] + ".owner");
				}
				else {
					$warn = (uiRes("m_relationshipEditor.kInvalidRenderPassSetSelection"));
					$warnMsg = `format -s $keys[$i] $warn`;
					warning($warnMsg);
				}
			}			
		}
		else if ($task == "animLayers") 
		{
			// add the list of items to the layer (key)
			//
			for ($i = 0; $i < $numKeys; $i++)
			{
				if ( `nodeType $keys[$i]` == "animLayer" ) {
				    catch(`animLayer -edit -attribute $item $keys[$i]`);				    
				}
				else {
					$warn = (uiRes("m_relationshipEditor.kInvalidAnimLayerSelection"));
					$warnMsg = `format -s $keys[$i] $warn`;
					warning($warnMsg);
				}
			}
		}
		else if ( $task == "setMembership" )
		{
			// add the list of items to the set (key)
			//
			for ($i = 0; $i < $numKeys; $i++)
			{
				if ( `nodeType $keys[$i]` == "character" ) {
					// character node is an objectSet so the character test
					// must be ahead of the objectSet test
					//
					catch(	`character -forceElement $keys[$i] $item` );
				}
				else
				{
					if ( isObjectSet( $keys[$i] ) ) {
						catch(	`sets -edit -add $keys[$i] $item` );
					}
					else {
						$warn = (uiRes("m_relationshipEditor.kInvalidSetSelection"));
						$warnMsg = `format -s $keys[$i] $warn`;
						warning($warnMsg);
					}
				}
			}
		}
		else if ( $task == "deformerSetEd" )
		{
			// add the list of items to the set (key)
			//
			for ($i = 0; $i < $numKeys; $i++)
			{
				if ( isObjectSet( $keys[$i] )
				&& `nodeType $keys[$i]` != "character" 
				   ) {
					catch(	`sets -edit -add $keys[$i] $item` );
				}
				else {
					$warn = (uiRes("m_relationshipEditor.kInvalidDeformerSetSelection"));
					$warnMsg = `format -s $keys[$i] $warn`;
					warning($warnMsg);
				}
			}
		}
		else if ($task == "partitionMembership")
		{
			// add the list of items to the partition (key)
			//
			for ($i = 0; $i < $numKeys; $i++)
			{
				if ( `nodeType $keys[$i]` == "partition" ) {
					catch( `partition -addSet $keys[$i] $item` );
				}
				else {
					$warn = (uiRes("m_relationshipEditor.kInvalidPartitionSelection"));
					$warnMsg = `format -s $keys[$i] $warn`;
					warning($warnMsg);
				}
			}
		}
		else if ($task == "characterMembership") 
		{
			if ( $numKeys > 1 ) {
				// Characters are partitioned, so key can't allow multiple keys
				// here
				//
				warning (uiRes("m_relationshipEditor.kMakeRelationshipCannotAddSameAttribute"));
			} else if ( $numKeys == 1 ) {
				if ( `nodeType $keys[$i]` == "character" ) {
					// Add the item to the character, expanding it into the component
					// attributes
					//
					catch( `character -forceElement $keys[0] $item` );
				}
				else {
					$warn = (uiRes("m_relationshipEditor.kInvalidCharacterSelection"));
					$warnMsg = `format -s $keys[$i] $warn`;
					warning($warnMsg);
				}
			}
		}
		else if ($task == "uvCentricUvLinking") 
		{
			// Make the association between LHS UV set and RHS texture
			//
			string $keyType;
			string $itemType;

			$keyType = "uvSet";
			$itemType = "texture";

			string $command;
			$command = 
				("uvLink -make ");
			
			$command = ($command + "-" + $keyType + " " + $keys[0] + " ");

			for ($i = 0; $i < size($item); $i++)
			{
				$command = 
					($command 
						+ "-"
						+ $itemType
						+ " "
						+ $item[$i] 
						+ " ");
			}

			catch( eval ($command) );
		}
		else if ($task == "furUVLinking") 
		{
			// Make the association between LHS FurDescription and RHS uv Set
			//
			global string $furUVLinkShapeNode;
			string $furUVAttr = HfGetFurUVSetAttribute($furUVLinkShapeNode);

			if( $furUVAttr != $item[0] )
			{
				//get "uvSetName" attributes of $furUVLinkShapeNode
				string $allAttr[] = `listAttr -m -st "uvSetName" $furUVLinkShapeNode`;
				
				//Check the availability of connection between UV set and Fur Descriptions
				for( $nCount =0; $nCount < size($allAttr); $nCount++ )
				{
					string $strName = $furUVLinkShapeNode +"."+$allAttr[$nCount] ;
					string $allConnection[];
			
					if(size(`connectionInfo -dfs $strName`) > 0 )
					{
						$allConnection = `connectionInfo -dfs $strName`;
					}
					else
					{
						continue;
					}
			
					for($nIndex =0; $nIndex < size($allConnection); $nIndex++)
					{
						if(`nodeType $allConnection[$nIndex] ` == "FurDescription")
						{
							if(`isConnected $strName $allConnection[$nIndex]`)
							{
								disconnectAttr $strName $allConnection[$nIndex];
								connectAttr $item[0] $allConnection[$nIndex];  
							}
						}
					}
				}
			
				// Set current uvset on linkage
				string $uvSetName = `getAttr $item[0]`;
				string $buffer[];
				string $objName = "";
				int $numTokens = `tokenize $item[0] "." $buffer`;
				if ($numTokens > 0)
					$objName = $buffer[0];
				if (size($uvSetName) && size($objName))
				{
					$command = "polyUVSet -currentUVSet -uvSet \"" + 
						$uvSetName + "\" " + $objName;
					catch( eval ($command) );
				}
			}
		}
		else if ($task == "hairFurLinking") 
		{	
			string $command = "assignHStoFD ";
			for ($i = 0; $i < size($item); $i++)
			{
				$command = 
					($command 
						+ $item[$i] 
						+ " "
						+ $keys[0]
						+ " ;");
			}
			if($keys[0]!="")
				catch( eval ($command) );
		}
		else if ($task == "pfxUVLinking") 
		{
			// Make the association between LHS PFX Stroke and RHS uv Set
			//
			global string $pfxUVLinkShapeNode;

				string $allAttr[] = `listAttr -m -st "uvSetName" $pfxUVLinkShapeNode`;

				//Check the availability of connection between UV set and PFX strokes
				for( $nCount =0; $nCount < size($allAttr); $nCount++ )
				{
					string $strName = $pfxUVLinkShapeNode +"."+$allAttr[$nCount] ;
					string $allConnection[];

					if(size(`connectionInfo -dfs $strName`) > 0 )
					{
						$allConnection = `connectionInfo -dfs $strName`;
					}
					else
					{
						continue;
					}
			
					for($nIndex =0; $nIndex < size($allConnection); $nIndex++)
					{
						if(`nodeType $allConnection[$nIndex] ` == "stroke")
						{
							if(`isConnected $strName $allConnection[$nIndex]`)
							{

								disconnectAttr $strName $allConnection[$nIndex];
								connectAttr $item[0] $allConnection[$nIndex];  
							}
						}
					}
				}



			// Set current uvset on linkage
			string $uvSetName = `getAttr $item[0]`;

			string $buffer[];
			string $objName = "";
			int $numTokens = `tokenize $item[0] "." $buffer`;
			if ($numTokens > 0)
				$objName = $buffer[0];

			if (size($uvSetName) && size($objName))
			{
				$command = "polyUVSet -currentUVSet -uvSet \"" + 
					$uvSetName + "\" " + $objName;
				catch( eval ($command) );
			}
		}
		else if ($task == "hairUVLinking") 
		{
			// Make the association between LHS HairSystems' follicles and RHS uv Set
			//
			global string $hairUVLinkShapeNode;

			hairUpdateUVSets($hairUVLinkShapeNode, $item[0]);

			// Set current uvset on linkage
			string $uvSetName = `getAttr $item[0]`;

			string $buffer[];
			string $objName = "";
			int $numTokens = `tokenize $item[0] "." $buffer`;
			if ($numTokens > 0)
				$objName = $buffer[0];

			if (size($uvSetName) && size($objName))
			{
				$command = "polyUVSet -currentUVSet -uvSet \"" + 
					$uvSetName + "\" " + $objName;
				catch( eval ($command) );
			}
		}	
		else if ($task == "textureCentricUvLinking") 
		{
			// Make the association between LHS texture and RHS UV set
			//
			string $keyType;
			string $itemType;

			$keyType = "texture";
			$itemType = "uvSet";

			string $command;
			$command = 
				("uvLink -make ");
			
			for ($i = 0; $i < size($keys); $i++)
			{
				$command = 
					($command 
						+ "-"
						+ $keyType
						+ " "
						+ $keys[$i]
						+ " ");
			}

			$command = ($command + "-" + $itemType + " " + $item[0] + " ");

			catch( eval ($command) );

			// Set current uvset on linkage
			string $uvSetName = `getAttr $item[0]`;
			string $buffer[];
			string $objName = "";
			int $numTokens = `tokenize $item[0] "." $buffer`;
			if ($numTokens > 0)
				$objName = $buffer[0];
			if (size($uvSetName) && size($objName))
			{
				$command = "polyUVSet -currentUVSet -uvSet \"" + 
					$uvSetName + "\" " + $objName;
//				print( $command + "\n");
				catch( eval ($command) );
			}
		}
		else if ($task == "eventCentricInteraction") 
		{
			// If more than one key is selected, display a warning.
			if ( $numKeys > 1 )
				warning (uiRes("m_relationshipEditor.kSelectOneKey"));
				
			// Connect the key to each item.
			for ($it in $item) {
			
			    // Strip any bracket from the destination name and make
				// the connection.
				string $b[];
				int $numTokens = `tokenize $it "[" $b`;
				string $cmd = ("connectAttr -na " + $keys[0] + " " + $b[0]);
			    catch(eval($cmd));
			}
		}

		else if ($task == "actionCentricInteraction") 
		{
			// Strip any bracket from the destination name.  In case there is
			// more than one key selected, use the last key on the list.
			string $b[];
			int $numTokens = `tokenize $keys[size($keys)-1] ".[" $b`;
			
			// Connect the key to each item.
			for ($it in $item)
			    catch(eval("connectAttr -na " + $it + " " + ($b[0] + "." + $b[1])));
			
			// Prune the list of keys so that only the last key is on the list.
			string $tmp = $keys[size($keys)-1];
			clear($keys);
			$keys[0] = $tmp;
		}

		else if ($task == "touchSensorAssociation")
		{
			//
			// Add the selected object to the selected touch sensor using the
			// miTouchSensor command.
			//
			int $k;
			for( $k = 0; $k < size( $keys ); $k ++ )
			{
				if( `nodeType $keys[$k]` == "miTouchSensor" )
				{
					int $i;
					for( $i = 0; $i < size( $item ); $i ++ )
					{
						string $cmd = ("miTouchSensor -e -addObject "+$item[$i]+" "+$keys[$k]);
						$relatedItems = eval( $cmd );
					}
				}
			}
		}

		else if ($task == "cameraSets")
		{
			//
			// Create the connection to the selected camera or objectSet.
			//
			int $k;
			for( $k = 0; $k < size( $keys ); $k ++ )
			{
				// Get the key object name.  If it's invalid, skip it.
				string $buffer[];
				string $keyObjName = "";
				int $numTokens = `tokenize $keys[$k] "." $buffer`;
				if ($numTokens > 0)
					$keyObjName = $buffer[0];
				if (size($keyObjName) == 0)
					continue;

				string $attrTokens[];
				$numTokens = `tokenize $keys[$k] "." $attrTokens`;
				string $objName = $attrTokens[0];
				$numTokens = `tokenize $keys[$k] "[" $attrTokens`;
				if (size($attrTokens) > 1)
				{
					int $i = 0;
					string $subTokens[], $layerNumTokens[];
					int $numSubTokens = `tokenize $attrTokens[1] "." $subTokens`;
					int $numLayerNumTokens = `tokenize $attrTokens[1] "]" $layerNumTokens`;
					string $layerNum = $layerNumTokens[0];

					if (size($subTokens) > 1)
					{
						int $i;
						// The key refers to an explicit camera or sceneData attribute.  If the item
						// is a compatible type, connect it.
						if ($subTokens[1] == "camera")
						{
							for( $i = 0; $i < size( $item ); $i ++ )
							{
								int $isCam = isCameraObj( $item[$i] ); 
								if ($isCam)
								{
									eval ("cameraSet -e -l " + $layerNum + " -camera " + $item[$i] + " " + $keyObjName);
									break;
								}
							}
						}
						else if ($subTokens[1] == "sceneData")
						{
							for( $i = 0; $i < size( $item ); $i ++ )
							{
								if (`objectType $item[$i]` == "objectSet")
								{
									eval ("cameraSet -e -l " + $layerNum + " -objectSet " + $item[$i] + " " + $keyObjName);
									break;
								}
							}
						}
					}
					else
					{
						for( $i = 0; $i < size( $item ); $i ++ )
						{
							if (`objectType $item[$i]` == "objectSet") { 
								eval ("cameraSet -e -l " + $layerNum + " -objectSet " + $item[$i] + " " + $keyObjName);
							}
							else if (isCameraObj($item[$i])) { 
								eval ("cameraSet -e -l " + $layerNum + " -camera " + $item[$i] + " " + $keyObjName);
							}
						}
					}
				}
				updateCameraSetAE($keys[$k]);
			}
			refresh -f;
		}

		// Turn off the wait cursor
		//
		waitCursor -state off;
	}

	// Refresh the highlighting of items related to the key
	//
	selectRelatedItems($panel, $task, $keys);
	
	setRelationshipsChangedScript($panel, $task);
}

global proc relationshipEditorBreakRelationship(
	string $panel,
	string $task,
	string $item[])
//
// Description:
//	This procedure is called when the user deselects one or more items which 
//	were previously selected on the non-key side. 
//	This procedure breaks relationships between the key and the previously 
//	selected items, in the context of the current task. For example, if the 
//	current task is light linking, then this procedure would break existing 
//	light links between the key and	each of the previously selected items.
//
//	If you are implementing a new task, you will need to add code to this
//	procedure to break relationships in the context of your task.
//
//	Remember, there may be more than one previously selected item.
//
{
	disableRelationshipsChangedScript($panel, $task);

	string $leftSelection = ($panel + "LeftSelection");
	string $keys[] = `selectionConnection -query -object $leftSelection`;

	// Issue the appropriate command, according to the current task, to make 
	// relationships between the key and each item in $item
	//
//	print("Breaking relationship between ");
//	print($keys[0]);
//	print(" and");

//	int $i;
//	for ($i = 0; $i < size($item); $i++)
//	{
//		print(" ");
//		print($item[$i]);
//	}
//	print("\n");

	int $i;
	int $numKeys = size($keys);

	string $warn;
	string $warnMsg;
	
	// Turn on the wait cursor
	//
	waitCursor -state on;

	if ($task == "displayLayers")
	{
		string $command;
		$command = "editDisplayLayerMembers -nr defaultLayer";
		if( size( $item ) > 0 ){
			for( $i = 0; $i < size( $item ); ++$i ){
				$command = ($command + " " + $item[ $i ] );
			}
			eval( $command );
		}
	}
	else if ($task == "lightCentricLightLinking")
	{
		string $keyType;
		string $itemType;

		$keyType = "light";
		$itemType = "object";

		string $command;
		$command = 
			("lightlink -break "
				+ "-"
				+ $keyType
				+ " "
				+ $keys[0]
				+ " ");
		
		for ($i = 0; $i < size($item); $i++)
		{
			$command = 
				($command 
					+ "-"
					+ $itemType
					+ " "
					+ $item[$i] 
					+ " ");
		}

		eval ($command);
	}
	else if ($task == "hairFurLinking") 
	{	
		string $command ="";
		for ($i = 0; $i < size($item); $i++)
		{
			$command += 
				("detachHStoFD "
					+ $item[$i] 
					+ " "
					+ $keys[0]
					+ " ;");
		}
		if($keys[0]!="")
			catch( eval ($command) );
	}
	else if ($task == "objectCentricLightLinking")
	{
		string $keyType;
		string $itemType;

		$keyType = "object";
		$itemType = "light";

		string $command;
		$command = 
			("lightlink -break "
				+ "-"
				+ $keyType
				+ " "
				+ $keys[0]
				+ " ");
		
		for ($i = 0; $i < size($item); $i++)
		{
			$command = 
				($command 
					+ "-"
					+ $itemType
					+ " "
					+ $item[$i] 
					+ " ");
		}

		eval ($command);
	}
	else if ( ($task == "setMembership") ||
			  ($task == "deformerSetEd") )
	{
		// remove the list of items from the set (key)
		//
		for ($i = 0; $i < $numKeys; $i++)
		{
			if ( `nodeType $keys[$i]` == "character" ) {
				// character node is an objectSet so the character test
				// must be ahead of the objectSet test
				//
				character -edit -remove $keys[$i] $item;
			}
			else
			{
				if ( isObjectSet( $keys[$i] ) ) {
					sets -edit -remove $keys[$i] $item;
				}
				else {
					$warn = (uiRes("m_relationshipEditor.kBreakRelationshipInvalidSetSelection")); 
					$warnMsg = `format -s $keys[$i] $warn`;
					warning($warnMsg);
				}
			}
		}
	}
	else if ($task == "renderLayers")
	{
		for ($i = 0; $i < $numKeys; $i++)
		{
			if ( `nodeType $keys[$i]` == "renderLayer" ) {
                editRenderLayerMembers -remove -noRecurse $keys[$i] $item;
			}
			else {
				$warn = (uiRes("m_relationshipEditor.kBreakRelationshipInvalidRenderLayerSelection"));
				$warnMsg = `format -s $keys[$i] $warn`;
				warning($warnMsg);
			}
		}
	}
	else if ($task == "renderPassSetEd")
	{
		for ($i = 0; $i < $numKeys; $i++)
		{
			if ( `nodeType $keys[$i]` == "renderPassSet" ) {
				string $renderPassesConnected[] = `listConnections ($keys[$i] + ".renderPass")`;
				for($j = 0; $j < size($item); $j++)
					if(stringArrayContains($item[$j], $renderPassesConnected))
						disconnectAttr -nextAvailable ($keys[$i] + ".renderPass") ($item[$j] + ".owner");
			}
			else {
				$warn = (uiRes("m_relationshipEditor.kBreakRelationshipInvalidRenderPassSetSelection"));
				$warnMsg = `format -s $keys[$i] $warn`;
				warning($warnMsg);
			}
		}
	}
	else if ($task == "animLayers")
	{
		for ($i = 0; $i < $numKeys; $i++)
		{
			if ( `nodeType $keys[$i]` == "animLayer" ) {
			    animLayer -edit -removeAttribute $item $keys[$i];			    
			}
			else {
				$warn = (uiRes("m_relationshipEditor.kBreakRelationshipInvalidAnimLayerSelection"));
				$warnMsg = `format -s $keys[$i] $warn`;
				warning($warnMsg);
			}
		}
	}
	else if ($task == "partitionMembership")
	{
		// remove the list of items from the partition (key)
		//
		for ($i = 0; $i < $numKeys; $i++)
		{
			if ( `nodeType $keys[$i]` == "partition" )
				partition -removeSet $keys[$i] $item;
			else {
				$warn = (uiRes("m_relationshipEditor.kBreakRelationshipInvalidPartitionSelection"));
				$warnMsg = `format -s $keys[$i] $warn`;
				warning($warnMsg);
			}
		}
	}
	else if ($task == "characterMembership")
	{
		for ( $key in $keys ) {
			removeFromCharacter( $key, $item );
		}
	}
	else if ($task == "uvCentricUvLinking")
	{
		// Break the association between LHS UV set and RHS texture
		//
		string $keyType;
		string $itemType;

		$keyType = "uvSet";
		$itemType = "texture";

		string $command;
		$command = 
			("uvLink -break ");
		
		$command = ($command + "-" + $keyType + " " + $keys[0] + " ");

		for ($i = 0; $i < size($item); $i++)
		{
			$command = 
				($command 
					+ "-"
					+ $itemType
					+ " "
					+ $item[$i] 
					+ " ");
		}

		catch( eval ($command) );
	}
	else if ($task == "textureCentricUvLinking")
	{
		// Break the association between LHS texture and RHS UV set
		//
		string $keyType;
		string $itemType;

		$keyType = "texture";
		$itemType = "uvSet";

		string $command;
		$command = 
			("uvLink -break ");
		
		for ($i = 0; $i < size($keys); $i++)
		{
			$command = 
				($command 
					+ "-"
					+ $keyType
					+ " "
					+ $keys[$i]
					+ " ");
		}

		$command = ($command + "-" + $itemType + " " + $item[0] + " ");

		catch( eval ($command) );
	}
	else if ($task == "eventCentricInteraction") 
	{
		// Disconnect the key from each item.
		for ($it in $item) {
		
			// Make sure there is a bracket on the item, as it must be a
			// multi-attribute element.  Then delete the connection.
			string $b[];
			int $numTokens = `tokenize $it "[" $b`;
			if (size($b) > 1) {
			
			    // The item name may not point to the exact child location.
				// So get the downstream connect to the attribute and delete
				// the name returned which matches the attribute of the item.
				string $destinations[] = `connectionInfo -dfs $keys[0]`;
				for ($d in $destinations) {
					string $s[];
					$numTokens = `tokenize $d "[" $s`;
					if ($s[0] == $b[0]) {
			    		disconnectAttr $keys[0] $d;
						break;
					}
				}
			}
		}
	}
	else if ($task == "actionCentricInteraction") 
	{
		// Disconnect the key from each item.
		for ($it in $item) {
		
			// Strip off any bracket from the key attribute name.
			string $b[];
			int $numTokens = `tokenize $keys[size($keys)-1] "[" $b`;
			
			// The key name may not point to the exact child location.
			// So use the item name and look for the downstream connection
			// that matches the key attribute name.
			string $destinations[] = `connectionInfo -dfs $it`;
			for ($d in $destinations) {
				string $s[];
				$numTokens = `tokenize $d "[" $s`;
				if ($s[0] == $b[0]) {
					disconnectAttr $it $d;
					break;
				}
			}
		}
		
		// Make sure only one key is selected.
		string $tmp = $keys[size($keys)-1];
		clear($keys);
		$keys[0] = $tmp;
	}
	else if ($task == "touchSensorAssociation")
	{
		//
		// Remove the selected object from the selected touch sensor using the
		// miTouchSensor command, if it is associated with it.  If it is
		// not, then no action will be taken by the command.
		//
		int $k;
		for( $k = 0; $k < size( $keys ); $k ++ )
		{
			if( `nodeType $keys[$k]` == "miTouchSensor" )
			{
				int $i;
				for( $i = 0; $i < size( $item ); $i ++ )
				{
					string $cmd = ("miTouchSensor -e -deleteObject "+$item[$i]+" "+$keys[$k]);
					$relatedItems = eval( $cmd );
				}
			}
		}
	}

	else if ($task == "cameraSets")
	{
		int $k;
		for( $k = 0; $k < size( $keys ); $k ++ )
		{
			// Get the key object name.  If it's invalid, skip it.
			string $buffer[];
			string $keyObjName = "";
			int $numTokens = `tokenize $keys[$k] "." $buffer`;
			if ($numTokens > 0)
				$keyObjName = $buffer[0];
			if (size($keyObjName) == 0)
				continue;

			string $attrTokens[];
			$numTokens = `tokenize $keys[$k] "[" $attrTokens`;
			if (size($attrTokens) > 1)
			{
				// Get the layer number.
				int $i = 0;
				string $subTokens[], $layerNumTokens[];
				int $numSubTokens = `tokenize $attrTokens[1] "." $subTokens`;
				int $numLayerNumTokens = `tokenize $attrTokens[1] "]" $layerNumTokens`;
				string $layerNum = $layerNumTokens[0];

				if (size($subTokens) > 1)
				{
					int $i;
					// The key refers to an explicit camera or sceneData attribute.  If the item
					// is a compatible type, disconnect it.  If the attribute is the camera
					// attribute, don't disconnect it, as a camera is required for the pass.
					if ($subTokens[1] == "camera")
						break;
					else if ($subTokens[1] == "sceneData")
					{
						for( $i = 0; $i < size( $item ); $i ++ )
						{
							if (`objectType $item[$i]` == "objectSet")
							{
								eval ("cameraSet -e -l " + $layerNum + " -objectSet \"\" " + $keyObjName);
								break;
							}
						}
					}
				}
				else
				{
					for( $i = 0; $i < size( $item ); $i ++ )
					{
						if (`objectType $item[$i]` == "objectSet")
							eval ("cameraSet -e -l " + $layerNum + " -objectSet \"\" " + $keyObjName);
					}
				}
				updateCameraSetAE($keys[$k]);
			}
		}
		refresh -f;
	}

	// Turn off the wait cursor
	//
	waitCursor -state off;

	// Refresh the highlighting of items related to the key
	//
	selectRelatedItems($panel, $task, $keys);

	setRelationshipsChangedScript($panel, $task);
}

global proc relationshipEditorRelationshipsChanged(
	string $panel,
	string $task)
//
// Description:
//	This procedure is called whenever relationships being represented by the
//	relationship editor are changed externally.
//	This procedure causes the relationship editor to update its selection.
//
{
	int $i;
	
	if (
		($task == "uvCentricUvLinking") 
		|| ($task == "textureCentricUvLinking")
		|| ($task == "hairUVLinking")
		||($task == "furUVLinking")
		|| ($task == "pfxUVLinking")
		 )
	{
		// UV Linking hijacks the relationships changed callback mechanism in
		// order to update the main list connections of the outliners when 
		// the selection changes.
		//

		// First we clear the selection on the right and on the left
		//
		selectionConnection
			-edit
			-clear
			($panel + "LeftSelection");

		selectionConnection
			-edit
			-clear
			($panel + "RightSelection");

		// Next, we clear the main list connections of the outliners.
		//
		selectionConnection
			-edit
			-clear
			($panel + "LeftMainList");
		selectionConnection
			-edit
			-clear
			($panel + "RightMainList");

		string $uvMainListConnection;
		string $textureMainListConnection;
		string $furMainListConnection;
		string $pfxMainListConnection;
		string $hairMainListConnection;

		if ($task == "uvCentricUvLinking")
		{
			$uvMainListConnection = ($panel + "LeftMainList");
			$textureMainListConnection = ($panel + "RightMainList");
		}
		else if ($task == "hairUVLinking")
		{
			$uvMainListConnection = ($panel + "RightMainList");
			$hairMainListConnection = ($panel + "LeftMainList");
		}
		else if ($task == "furUVLinking")
		{
			$uvMainListConnection = ($panel + "RightMainList");
			$furMainListConnection = ($panel + "LeftMainList");
		}
		else if ($task == "pfxUVLinking")
		{
			$uvMainListConnection = ($panel + "RightMainList");
			$pfxMainListConnection = ($panel + "LeftMainList");
		}
		else
		{
			$uvMainListConnection = ($panel + "RightMainList");
			$textureMainListConnection = ($panel + "LeftMainList");
		}

		// Determine what the current selection is
		//
		string $selection[];
		$selection = `selectedNodes -do`;

		// There may be more than one item selected. We will only deal with
		// the lead item.
		// Find the shapes under the lead selection item, since the UV sets
		// and the shading group assignment are on a per shape basis.
		//
		string $shapes[];
		string $shape = "";
		if (size($selection) > 0)
		{
			for ($i = size($selection)-1; ($i >= 0) && ($shape == ""); $i--)
			{
				// For 3.0, multiple UV sets are only supported on poly mesh 
				// nodes
				// Todo: Shapes which support multiple UVs will soon have a 
				// flag to indicate it. I should be checking the flag instead 
				// of the node type.
				//
				if (`nodeType $selection[$i]` == "mesh")
				{
					$shape = $selection[$i];
				}
				else if (`nodeType $selection[$i]` == "transform")
				{
					$shapes = 
						`listRelatives -path $selection[size($selection)-1]`;

					if (size($shapes) > 0)
					{
						// There might be more than one shape if the user 
						// selected a hierarchy. We arbitrarily choose the 
						// first shape to work with since we can't work with 
						// more than one at a time.
						//
						$shape = $shapes[0];
					}
				}
			}

			if ($shape == "") return;
		}
		else
		{
			// There is no selection.
			//
			return;
		}

		// For 3.0, multiple UV sets are only supported on poly mesh 
		// nodes
		// Todo: Shapes which support multiple UVs will soon have a 
		// flag to indicate it. I should be checking the flag instead 
		// of the node type.
		//
		if (`nodeType $shape` != "mesh")
		{
			return;
		}

		
		// Put the shading group(s) assigned to the object into the texture
		// side mainListConnection
		//
		if ( true
			&& $task != "hairUVLinking" 
			&& $task != "furUVLinking"
			&& $task != "pfxUVLinking"
			)
		{
			string $sets[];
			$sets = `listSets -type 1 -object $shape`;

			string $shaderTypes[] = {	
				".surfaceShader",
				".miMaterialShader",
				".miShadowShader",
				".miVolumeShader",
				".miPhotonShader",
				".miPhotonVolumeShader",
				".miDisplacementShader",
				".miEnvironmentShader",
				".miLightMapShader",
				".miContourShader"
			};

			for ($i = 0; $i < size($sets); $i++)
			{
				if (`nodeType $sets[$i]` == "shadingEngine")
				{
					// Now that we have a shading group, we need to find the
					// material (if any) attached to the surface shader and mental ray shaders
					//
					for( $shader in $shaderTypes )
					{
						// This comparison is necessary because
						// mental ray attributes are dynamic, and not guarantted to exist.
						if( size(`ls ($sets[$i] + $shader)`) > 0 )
						{
							string $materials[] = `listConnections ($sets[$i] + $shader)`;
							for ($material in $materials) {
								selectionConnection
									-edit
									-select $material
									$textureMainListConnection;
							}
						}
					}
				}
			}
			// Put the UV sets of the object into the UV side mainListConnection
			//
			selectionConnection
				-edit
				-select $shape
				$uvMainListConnection;

			// Watch for changes to the shading group(s) assigned to the object
			// 
			// (todo)

		}
		else if($task == "furUVLinking")
		{
			string $allObj[];
			$allObj = HfGetFurDescription($shape);
			int $i;
			global string $furUVLinkShapeNode;
			$furUVLinkShapeNode = $shape;

			for($i=0; $i<size($allObj); $i++)
			{
				selectionConnection
					-edit
					-select $allObj[$i]
					$furMainListConnection;
			}
			
			selectionConnection
				-edit
				-select $shape
				$uvMainListConnection;
		}
		else if($task == "pfxUVLinking")
		{
			global string $pfxUVLinkShapeNode;
			$pfxUVLinkShapeNode = $shape;

			string $allObj[];
			string $shapeAttr = $shape + ".worldMesh";

			string $comObjects[];
			$comObjects = `listConnections $shapeAttr`;

			int $index = 0;

			// Get all the strokes
			for($i=0; $i<size($comObjects); $i++)
			{
				if(`nodeType $comObjects[$i]` == "curveFromMeshCoM")
				{
					string $opCurve = $comObjects[$i] + ".outputCurve";
					string $opCurveList[] = `listConnections -sh 1 $opCurve`;
					$allObj[$index] = $opCurveList[0];
					$index ++;
				}
			}

			for($i=0; $i<size($allObj); $i++)
			{
				selectionConnection
					-edit
					-select $allObj[$i]
					$pfxMainListConnection;
			}
			
			selectionConnection
				-edit
				-select $shape
				$uvMainListConnection;
		}
		else if($task == "hairUVLinking")
		{
			// Get all the hair systems on the selected poly 
			// to be displayed in LHS of relationshipEditor

			global string $hairUVLinkShapeNode;
			$hairUVLinkShapeNode = $shape;

			string $allObj[];
			$allObj = hairGetAllHairSystems($hairUVLinkShapeNode);

			for($i=0; $i<size($allObj); $i++)
			{
				selectionConnection
					-edit
					-select $allObj[$i]
					$hairMainListConnection;
			}
			
			selectionConnection
				-edit
				-select $shape
				$uvMainListConnection;
		}
	}
	else if ($task == "hairFurLinking")
	{
		//
		selectionConnection
			-edit
			-clear
			($panel + "LeftSelection");

		selectionConnection
			-edit
			-clear
			($panel + "RightSelection");

		// Next, we clear the main list connections of the outliners.
		//
		selectionConnection
			-edit
			-clear
			($panel + "LeftMainList");
		selectionConnection
			-edit
			-clear
			($panel + "RightMainList");

		string $furDesMainListConnection;
		string $hairSysMainListConnection;
		
		$furDesMainListConnection = ($panel + "RightMainList");
		$hairSysMainListConnection = ($panel + "LeftMainList");

		string $hairSystems[] = `ls -type hairSystem`;
		for($i=0; $i<size($hairSystems); $i++)
		{
			selectionConnection
				-edit
				-select $hairSystems[$i]
				$hairSysMainListConnection;
		}
				
		string $furDescriptions[];
		string $furDes[] = `ls -type FurDescription`;
		for($fur in $furDes)
		{
			string $a[] = `listConnections -shapes true -type mesh ($fur+".dsm")`;
			string $b[] = `listConnections -shapes true -type nurbsSurface ($fur+".dsm")`;
			string $c[] = `listConnections -shapes true -type subdiv ($fur+".dsm")`;
			if( !(size($a)==0 && size($b)==0 && size($c)==0 ))
			{
				$furDescriptions[size($furDescriptions)] = $fur;
			}
		}
	
		for($i=0; $i<size($furDescriptions); $i++)
		{
			selectionConnection
				-edit
				-select $furDescriptions[$i]
				$furDesMainListConnection;
		}
	}

	string $leftSelection = ($panel + "LeftSelection");
	string $keys[] = `selectionConnection -query -object $leftSelection`;

	// Refresh the highlighting of items related to the key
	//
	selectRelatedItems($panel, $task, $keys);
}


proc configureLayout(
	string $panel, 
	string $task)
//
// Description:
//	This procedure is called when the current task changes, in case changes to
//	the UI are *necessary* for usable workflow with the new task.
//
//	This procedure could show or hide various controls, buttons, or other 
//	pieces of UI. 
//	
//	You should think twice about adding any code here. Do you *really* need to
//	add extra UI to the relationship editor in order for the user to use it to
//	do the task? One of the big advantages of the relationship editor is
//	simplicity. The normal workflow in the relationship editor is as simple as
//	it can get. The UI in the relationship editor is uncluttered. A second big
//	advantage to the relationship editor is that all tasks are done the same
//	way. Once you know how to do one, you know how to do them all.
//
//	Don't modify this unless you are prepared to justify your changes. :)
//
{
	string $topLayout = `panel -query -control $panel`;

	setParent $topLayout;

	// Unmanage the main form to prevent flicker as UI is rearranged
	//
	formLayout
		-edit
		-manage 	false
		mainForm;

	//
	// Configure the UI according to the current task
	//
	// (no tasks currently do this)

	// Remanage the main form now that UI rearrangement is complete
	//
	formLayout
		-edit
		-manage 	true
		mainForm;

}

proc manualLoadCommand(
	string $panel, 
	string $task,
	string $side,
	string $command)
{
	string $mainList;

	if ($side == "left")
	{
		$mainList = ($panel + "LeftMainListManual");
	}
	else // ($side == "right")
	{
		$mainList = ($panel + "RightMainListManual");
	}

	if ($command == "loadListFromSelection")
	{
		// Clear the selection connection of any old selections
		//
		selectionConnection 
			-edit 
			-clear 
			$mainList;
	}

	// Clear the highlighting on both sides because the items contained in one
	// of the sides may have just changed completely.
	// We clear the highlighting of the left side first to be sure the
	// relationships between items aren't affected.
	//
	selectionConnection
		-edit   
		-clear  
		($panel + "LeftSelection");

	selectionConnection
		-edit   
		-clear  
		($panel + "RightSelection");

	// Determine the current selection and add or remove it from the
	// manually loaded list.
	//
	string $activeObjects[];

	$activeObjects = `selectionConnection -query -object activeList`;

	int $i;

	if (size($activeObjects) == 0)
	{
		warning (uiRes("m_relationshipEditor.kNothingSelected"));
	}

	for ($i = 0; $i < size($activeObjects); $i++)
	{
	    //FIXME: anything to be added here for anim layers??
		if( $task != "displayLayers" 
			&& $task != "renderLayers"
			)
		{
			if (($command == "loadListFromSelection") ||
				($command == "addSelectionToList"))
			{
				selectionConnection
					-edit
					-select $activeObjects[$i]
					$mainList;
			}
			else
			{
				selectionConnection
					-edit
					-deselect $activeObjects[$i]
					$mainList;
			}
		}
		
		if ($side == "left" &&
			(	($task == "setMembership") ||
				($task == "deformerSetEd") ||
				($task == "displayLayers") ||
				($task == "renderLayers") ||
				($task == "renderPassSetEd") ||
				($task == "partitionMembership")))
		{
			string $activeSets[];

			// For these set editing tasks, we also want to load sets whose 
			// members are in the active list.
			//
			if ($task == "setMembership")
			{
				$activeSets = `listSets -object $activeObjects[$i]`;
			}
			else if ($task == "deformerSetEd")
			{
				$activeSets=`listSets -type 2 -ets -object $activeObjects[$i]`;
				if (0 == size($activeSets)) {
					$activeSets = `findDeformerSet`;
				}
			}
			else if ( $task == "partitionMembership" && `attributeExists "partition" $activeObjects[$i]`)
			{
				$activeSets = 
					`listConnections ($activeObjects[$i] + ".partition")`;
			}
			else if ( $task == "displayLayers" && `attributeExists "drawOverride" $activeObjects[$i]`)
			{
				$activeSets = 
					`listConnections ($activeObjects[$i] + ".drawOverride")`;
			}
			else if ( $task == "renderLayers" && `attributeExists "renderLayerInfo" $activeObjects[$i]`)
			{
				$activeSets = 
					`listConnections ($activeObjects[$i] + ".renderLayerInfo")`;
			}
			else if ( $task == "renderPassSetEd" && `attributeExists "owner" $activeObjects[$i]`)
			{
				$activeSets = 
					`listConnections ($activeObjects[$i] + ".owner")`;
			}

			int $numSets;
			int $j;

			$numSets = size($activeSets);

			if ( $numSets == 0 ) continue;

			// Select/deselect the sets/partitions in the selection 
			// connection so that the main list connection on the outliner 
			// can be used to update the display to these sets/partitions
			//
			for ( $j = 0; $j < $numSets; $j++ )
			{
				if (($command == "loadListFromSelection") ||
					($command == "addSelectionToList"))
				{
					selectionConnection 
						-edit 
						-select $activeSets[$j] 
						$mainList;
				}
				else // ($command == "removeSelectionFromList")
				{
					selectionConnection 
						-edit 
						-deselect $activeSets[$j] 
						$mainList;
				}
			}
		}
	}
}

proc setMembershipEditorMenuCommand( 
	string $panel,
	string $task,
	string $command )
//
//	Description:
//		Do the appropriate command for the set membership task.
//
//	Dev Notes:
//		This may need to move into a more general command.
//
{
//	print("panel = " + $panel + "\n");
	int $updateRHS = 0;
	if ( $command == "leftOptionsMenuAutoExpand" )
	{
		int $checkedOn = `menuItem -query -checkBox leftOptionsMenuAutoExpandItem`;
		outlinerEditor -edit -expandObjects $checkedOn ($panel + "LeftOutliner");
	}
	else if ( $command == "leftEditMenuAddToSet" )
	{
		// get the objects/sets to add from the active list
		//
		string $activeObjects[] = `ls -sl`;
		if ( size($activeObjects) == 0 )
		{
			if ( $task == "setMembership" )
				warning (uiRes("m_relationshipEditor.kNoActiveObjectsToAddToSet"));
			else if ( $task == "deformerSetEd" )
				warning (uiRes("m_relationshipEditor.kNoActiveObjectsToAddToDeformerSet"));
			else if ( $task == "partitionMembership" )
				warning (uiRes("m_relationshipEditor.kNoActiveObjectsToAddToPartition"));
			else if ( $task == "characterMembership" )
				warning (uiRes("m_relationshipEditor.kNoActiveObjectsToAddToCharacterSet"));
		}
		else
		{
			// get the sets/partitions to contain the active objects
			//
			string $selections[] = `selectionConnection -query -object ($panel + "LeftSelection")`;
			
			// add the active objects/sets to each selected set/partition
			//
			int $i;
			int $numSets = size($selections);
			if ( $numSets == 0 )
			{
				if ( $task == "setMembership" )
					warning (uiRes("m_relationshipEditor.kNoSetsSelected"));
				else if ( $task == "deformerSetEd" )
					warning (uiRes("m_relationshipEditor.kNoDeformerSetsSelected"));
				else if ( $task == "partitionMembership" )
					warning (uiRes("m_relationshipEditor.kNoPartitionsSelected"));
				else if ( $task == "characterMembership" )
					warning (uiRes("m_relationshipEditor.kNoCharacterSetsSelected"));
			}
			else if ( ( $task == "characterMembership" ) && ( $numSets > 1 ) )
			{
				warning (uiRes("m_relationshipEditor.kCannotAddSameAttribute"));
			}
			else
			{
				for ( $i = 0; $i < $numSets; $i++ )
				{
					// the selected item in the outliner must be a 
					// set/partition!
					//
					string $warning;
					string $warningMsg;
					if ( $task == "setMembership" ) 
					{
						if (`nodeType $selections[$i]` == "character") 
							character -forceElement $selections[$i] $activeObjects;
						else
						{
							if ( isObjectSet( $selections[$i] ) )
								sets -edit -add $selections[$i] $activeObjects;
							else
							{
								$warning = (uiRes("m_relationshipEditor.kSelectionIsNotSet"));
								$warningMsg = `format -s $selections[$i] $warning`;
								warning($warningMsg);
							}
						}
					}
					else if ( $task == "deformerSetEd" )
					{
						if ( isObjectSet( $selections[$i] ) )
							sets -edit -add $selections[$i] $activeObjects;
						else
						{
							$warning = (uiRes("m_relationshipEditor.kSelectionIsNotDeformerSet"));
							$warningMsg = `format -s $selections[$i] $warning`;
							warning($warningMsg);
						}	
					}
					else if ( $task == "partitionMembership" )
					{
						if ( `nodeType $selections[$i]` == "partition" )
							partition -addSet $selections[$i] $activeObjects;
						else
						{
							$warning = (uiRes("m_relationshipEditor.kSelectionIsNotPartition"));
							$warningMsg = `format -s $selections[$i] $warning`;
							warning($warningMsg);
						}	
					}
					else if ( $task == "characterMembership" ) 
					{
						if (`nodeType $selections[$i]` == "character")
							character -forceElement $selections[$i] $activeObjects;
						else
						{
							$warning = (uiRes("m_relationshipEditor.kSelectionIsNotCharacter"));
							$warningMsg = `format -s $selections[$i] $warning`;
							warning($warningMsg);
						}	
					}
				}
			}
		}

		$updateRHS = 1;	// need to update the right-hand-side list
	}
	else if ( $command == "leftEditMenuRemoveFromSet" )
	{
		// remove the selected item from the set/partition
		//
		string $selections[] = `ls -sl`;
		int $numToRemove = size($selections);
		if ( $numToRemove == 0 )
		{
			if ( $task == "setMembership" )
				warning (uiRes("m_relationshipEditor.kNoSetMembersSelectedToRemoveFromSet"));
			else if ( $task == "displayLayers" )
				warning (uiRes("m_relationshipEditor.kNoLayerMembersSelectedToRemoveFromDisplayLayer"));
			else if ( $task == "renderLayers" )
				warning (uiRes("m_relationshipEditor.kNoLayerMembersSelectedToRemoveFromRenderLayer"));            
			else if ( $task == "deformerSetEd" )
				warning (uiRes("m_relationshipEditor.kNoDeformerSetMembersSelectedToRemoveFromDeformerSet"));
			else if ( $task == "partitionMembership" )
				warning (uiRes("m_relationshipEditor.kNoPartitionMembersSelectedToRemoveFromPartition"));
			else if ( $task == "characterMembership" ) {
				warning (uiRes("m_relationshipEditor.kNoCharacterMembersSelectedToRemove"));
			}
		}
		else
		{
			// remove each selected item from each set/partition
			//
			int $i, $j;
			string $setNames[] = `selectionConnection -query -object ($panel + "LeftSelection")`;
			int $numSets = size($setNames);
			if ( $numSets == 0 ) warning (uiRes("m_relationshipEditor.kNoSetsSelectedInOutliner"));
			for ( $i = 0; $i < $numToRemove; $i++ )
			{
				for ( $j = 0; $j < $numSets; $j++ )
				{
					if ( ($task == "setMembership")		||
						 ($task == "deformerSetEd"))
					{
						if ( `sets -isMember $setNames[$j] $selections[$i]` )
							sets -edit -remove $setNames[$j] $selections[$i];
						else
						{
							string $warn = (uiRes("m_relationshipEditor.kNotAMember"));
							string $warnMsg = `format -s $selections[$i] -s $setNames[$j] $warn`;
							warning($warnMsg);
						}	
					} else if ( $task == "characterMembership" ) {
						removeFromCharacter( $setNames[$j], {$selections[$i]} );
					} else if ( $task == "partitionMembership" ) {
						partition -removeSet $setNames[$j] $selections[$i];
					}

				}
			}
		}

		$updateRHS = 1;	// need to update the right-hand-side list
	}
	else if ( $command == "leftEditMenuHighlightCurrentCharacters" ) {
		string $selectionConnection = ($panel + "LeftSelection");
		string $currentCharacters[] = currentCharacters();
		selectionConnection -edit -clear $selectionConnection;
		for ( $character in $currentCharacters ) {
			selectionConnection -edit -select $character $selectionConnection;
		}
	}
	else if ( $command == "leftEditMenuMakeHighlightedCharactersCurrent" ) {
		string $selectionConnection = ($panel + "LeftSelection");
		string $highlightedCharacters[] = 
			`selectionConnection -query -obj $selectionConnection`;
		string $newCurrent[];
		for ( $item in $highlightedCharacters ) {
			if ( `nodeType( $item )` == "character" ) {
				$newCurrent[size($newCurrent)] = $item;
			}
		}
		setCurrentCharacters( $newCurrent );
		if ( size( $newCurrent ) == 0 ) {
			warning (uiRes("m_relationshipEditor.kNoCharactersHighlighted"));
		}
	}
	
	if ( $updateRHS == 1 )
	{
		// after the menu item is completed, we need to update
		// the contents of the RHS to reflect the changes.
		//
		relationshipEditorSelectKey $panel $task {};
	}
}

proc refreshLeftListMenu(
	string $panel,
	string $task)
{
	string $topLayout = `panel -query -control $panel`;

	setParent $topLayout;

	if (	($task == "uvCentricUvLinking") 
		|| ($task == "furUVLinking") || ($task == "hairFurLinking")
		||	($task == "textureCentricUvLinking"))
	{
		// Disable the List menu because the UV linking tasks do things
		// differently from all the other tasks
		//
		menu -edit -enable false leftListMenu;
	}
	else
	{
		// Enable the List menu
		//
		menu -edit -enable true leftListMenu;
	}

	setParent -menu leftListMenu;

	if (`menuItem -query -radioButton leftListMenuManualLoadItem`)
	{
		menuItem
			-edit
			-enable		true
			leftListMenuLoadListFromSelectionItem;
		menuItem
			-edit
			-enable		true
			leftListMenuAddSelectionToListItem;
		menuItem
			-edit
			-enable		true
			leftListMenuRemoveSelectionFromListItem;
	}
	else
	{
		menuItem
			-edit
			-enable		false
			leftListMenuLoadListFromSelectionItem;
		menuItem
			-edit
			-enable		false
			leftListMenuAddSelectionToListItem;
		menuItem
			-edit
			-enable		false
			leftListMenuRemoveSelectionFromListItem;
	}
}

proc refreshRightListMenu(
	string $panel,
	string $task)
{
	string $topLayout = `panel -query -control $panel`;

	setParent $topLayout;

	if (	($task == "uvCentricUvLinking") 
		|| ($task == "hairUVLinking")
		|| ($task == "furUVLinking") || ($task == "hairFurLinking")
		|| ($task == "pfxUVLinking")
		||	($task == "textureCentricUvLinking") 
		)
	{
		// Disable the List menu because the UV linking tasks do things
		// differently from all the other tasks
		//
		menu -edit -enable false rightListMenu;
	}
	else
	{
		// Enable the List menu
		//
		menu -edit -enable true rightListMenu;
	}

	setParent -menu rightListMenu;

	if (`menuItem -query -radioButton rightListMenuManualLoadItem`)
	{
		menuItem
			-edit
			-enable		true
			rightListMenuLoadListFromSelectionItem;
		menuItem
			-edit
			-enable		true
			rightListMenuAddSelectionToListItem;
		menuItem
			-edit
			-enable		true
			rightListMenuRemoveSelectionFromListItem;
	}
	else
	{
		menuItem
			-edit
			-enable		false
			rightListMenuLoadListFromSelectionItem;
		menuItem
			-edit
			-enable		false
			rightListMenuAddSelectionToListItem;
		menuItem
			-edit
			-enable		false
			rightListMenuRemoveSelectionFromListItem;
	}
}


proc displayLayerEditorMenuCommand(
string $panel,
string $task,
string $command )
//
//	Description:
//		Do the appropriate command for the display layer task.
{
	if( $command == "leftEditMenuRemoveFromDisplayLayer" ){
		// get the objects/sets to remove from the active list
		//
		string $activeObjects[] = `ls -sl`;
		if( size( $activeObjects ) == 0 ){
			warning (uiRes("m_relationshipEditor.kNoActiveObjectsToRemoveFromDisplayLayer"));
		}else{
			// It really doesn't matter what layer the active objects are
			// in we just assign all the selected items to the
			// defaultLayer
			//
			editDisplayLayerMembers -nr "defaultLayer" $activeObjects;
		}
	}else if( $command == "leftEditMenuAddToDisplayLayer" ){
		// get the objects/sets to add from the active list
		//
		string $activeObjects[] = `ls -sl`;
		if(  size( $activeObjects ) == 0  ){
			warning (uiRes("m_relationshipEditor.kNoActiveObjectsToAddToDisplayLayer"));
		}else{
			// get the display layer to contain the active objects
			//
			string $selections[] = `selectionConnection -query -object ($panel + "LeftSelection")`;
			
			// add the active objects/sets to each selected display layer
			//
			int $i;
			int $numLayers = size( $selections );
			if( $numLayers == 1 ){
//				print( "adding to layer " + $selections[ 0 ] + "\n" );
				if( `nodeType $selections[ 0 ]` == "displayLayer" ){
					editDisplayLayerMembers -nr $selections[ 0 ] $activeObjects;
				}else{
					string $warn = (uiRes("m_relationshipEditor.kNotDisplayLayer"));
					string $warnMsg = `format -s $selections[ 0 ] $warn`;
					warning($warnMsg);
				}
			}else{
				warning (uiRes("m_relationshipEditor.kAddMembersWarn"));
			}
		}
	}
	// And update the RHS of the editor
	//
	relationshipEditorSelectKey $panel $task {};
}

proc animLayerEditorMenuCommand(
string $panel,
string $task,
string $command )
//
//	Description:
//		Do the appropriate command for the anim layer task.
{
    //FIXME: Currently there aren't any tasks.    
}
proc renderLayerEditorMenuCommand(
string $panel,
string $task,
string $command )
//
//	Description:
//		Do the appropriate command for the render layer task.
{
	string $warning = (uiRes("m_relationshipEditor.kNotRenderLayer"));
	if( $command == "leftEditMenuRemoveFromRenderLayer" ){
		// get the objects/sets to remove from the active list
		//
		string $activeObjects[] = `ls -sl`;
		if( size( $activeObjects ) == 0 ){
			warning (uiRes("m_relationshipEditor.kNoActiveObjectsToRemoveFromRenderLayer"));
		}else{
			// get the render layer to contain the active objects
			//
			string $selections[] = `selectionConnection -query -object ($panel + "LeftSelection")`;

			// remove the active objects/sets from each selected render layer
			//
            for ($node in $selections) {
                if (`nodeType $node` == "renderLayer" ){
                    editRenderLayerMembers -remove -noRecurse $node $activeObjects;
                }
                else {
					string $warnMsg = `format -s $node $warning`;
					warning($warnMsg);
                }
            }
		}
	}else if( $command == "leftEditMenuAddToRenderLayer" ){
		// get the objects/sets to add from the active list
		//
		string $activeObjects[] = `ls -sl`;
		if(  size( $activeObjects ) == 0  ){
			warning (uiRes("m_relationshipEditor.kNoActiveObjectsToAddToRenderLayer"));
		}else{
			// get the render layer to contain the active objects
			//
			string $selections[] = `selectionConnection -query -object ($panel + "LeftSelection")`;

			// add the active objects/sets to each selected render layer
			//
            for ($node in $selections) {
                if (`nodeType $node` == "renderLayer" ){
                    editRenderLayerMembers -noRecurse $node $activeObjects;
                }
                else {
					string $warnMsg = `format -s $node $warning`;
					warning($warnMsg);
                }
            }
		}
	}
	// And update the RHS of the editor
	//
	relationshipEditorSelectKey $panel $task {};
}

proc renderPassSetEditorMenuCommand(
string $panel,
string $task,
string $command )
//
//	Description:
//		Do the appropriate command for the render pass set task.
{
	string $warning = (uiRes("m_relationshipEditor.kNotRenderPassSet"));
	if( $command == "leftEditMenuRemoveFromRenderPassSet" ){
		// get the render passes to remove from the active list
		//
		string $activeRenderPasses[] = `ls -sl -type "renderPass"`;
		if( size( $activeRenderPasses ) == 0 ){
			warning (uiRes("m_relationshipEditor.kNoActiveRenderPassesToRemoveFromRenderPassSet"));
		}else{
			// get the render pass set to contain the active render passes
			//
			string $selections[] = `selectionConnection -query -object ($panel + "LeftSelection")`;

			// remove the active render passes from each selected render pass set
			//
            for ($node in $selections) {
				string $renderPasses[] = `listConnections ($node + ".renderPass")`;
                if (`nodeType $node` == "renderPassSet" ){
					for($i = 0; $i < size( $activeRenderPasses ); $i++) {
						if(stringArrayContains($activeRenderPasses[$i], $renderPasses))
							disconnectAttr -nextAvailable ($node + ".renderPass") ($activeRenderPasses[$i] + ".owner");
					}
                }
                else {
					string $warnMsg = `format -s $node $warning`;
					warning($warnMsg);
                }
            }
		}
	}else if( $command == "leftEditMenuAddToRenderPassSet" ){
		// get the render passes to add from the active list
		//
		string $activeRenderPasses[] = `ls -sl -type "renderPass"`;
		if(  size( $activeRenderPasses ) == 0  ){
			warning (uiRes("m_relationshipEditor.kNoActiveRenderPassesToAddToRenderPassSet"));
		}else{
			// get the render pass set to contain the active render passes
			//
			string $selections[] = `selectionConnection -query -object ($panel + "LeftSelection")`;

			// add the active render passes to each selected render pass set
			//
            for ($node in $selections) {
				string $renderPasses[] = `listConnections ($node + ".renderPass")`;
                if (`nodeType $node` == "renderPassSet" ){
					for($i = 0; $i < size( $activeRenderPasses ); $i++) {
						if(!stringArrayContains($activeRenderPasses[$i], $renderPasses))
							connectAttr -nextAvailable ($node + ".renderPass") ($activeRenderPasses[$i] + ".owner");
					}
                }
                else {
					string $warnMsg = `format -s $node $warning`;
					warning($warnMsg);
                }
            }
		}
	}
	// And update the RHS of the editor
	//
	relationshipEditorSelectKey $panel $task {};
}

proc configureLeftOutliner(
	string $panel, 
	string $task)
//
// Description:
//	This procedure is called every time the current task changes, and is also
//	called when the user changes the filtering of the left outliner by using 
//	the left menu.
//	This procedure modifies the filtering of items on the left outliner.
//	Filtering may be accomplished through use of filters, or through use of a
//	different mainListConnection, both, or even through some other mechanism.
//
//	It is "safe" to examine the left menu to determine what filter the user
//	has chosen.
//
//	If you are implementing a new task, you will want to add code to this
//	procedure to support the various filtering presets that are appropriate
//	for your task.
//
{
	//
	// Change the filter on the left outliner to show the
	// entities appropriate to this task.
	//

	string $outlinerEditor = ($panel + "LeftOutliner");
	
	string $topLayout = `panel -query -control $panel`;
	setParent $topLayout;

	if (`menuItem -query -radioButton leftListMenuAutoLoadAllItem`)
	{
		// Define what mainListConnection to use
		//
		if ( 
			($task == "setMembership") || 
			($task == "deformerSetEd"))
		{
			outlinerEditor
				-edit
				-mainListConnection		setList
				$outlinerEditor;
		}
		else if ($task == "renderPassSetEd")
		{
			outlinerEditor
				-edit
				-mainListConnection worldList
				$outlinerEditor;
		}
	    else if ($task == "characterMembership")
	    {
			outlinerEditor
				-edit
				-mainListConnection characterList
				$outlinerEditor;
	    }
		else if ($task == "uvCentricUvLinking")
		{
			// The UV Linking tasks make use of the LeftMainList
			// selectionConnection as the mainListConnection. They do this so 
			// that they can specify exactly what appears in the relationship 
			// editor based on the current selection.
			//
			outlinerEditor
				-edit
				-mainListConnection ($panel + "LeftMainList")
				$outlinerEditor;
		}
		else if ( false
			|| ($task == "hairUVLinking")
			|| ($task == "furUVLinking") || ($task == "hairFurLinking")
			|| ($task == "pfxUVLinking")
			)
		{
			// The UV Linking tasks make use of the LeftMainList
			// selectionConnection as the mainListConnection. They do this so 
			// that they can specify exactly what appears in the relationship 
			// editor based on the current selection.
			//
			outlinerEditor
				-edit
				-mainListConnection ($panel + "LeftMainList")
				$outlinerEditor;
		}
		else if ($task == "textureCentricUvLinking")
		{
			// The UV Linking tasks make use of the LeftMainList
			// selectionConnection as the mainListConnection. They do this so 
			// that they can specify exactly what appears in the relationship 
			// editor based on the current selection.
			//
			outlinerEditor
				-edit
				-mainListConnection ($panel + "LeftMainList")
				$outlinerEditor;
		}
	    else if (($task == "eventCentricInteraction") ||
				 ($task == "actionCentricInteraction"))
	    {
			outlinerEditor
				-edit
				-mainListConnection worldList
				$outlinerEditor;
	    }
	    else if ($task == "touchSensorAssociation")
	    {
			outlinerEditor
				-edit
				-mainListConnection worldList
				$outlinerEditor;
	    }
		else
		{
			outlinerEditor
				-edit
				-mainListConnection		worldList
				$outlinerEditor;
		}
	}
	else if (`menuItem -query -radioButton leftListMenuManualLoadItem`)
	{
		outlinerEditor
			-edit
			-mainListConnection			($panel + "LeftMainListManual")
			$outlinerEditor;

		relationshipEditorMenuCommand(
			$panel, 
			$task,
			"leftListMenuLoadListFromSelection");
	}
	else
	{
		// If neither the auto load all option nor the manual load option
		// is set, either the List menu is disabled (UV linking tasks) or
		// there was no default option set (Deformer set editing, Paint
		// Effects/UV linking, and Hair/UV linking). Accommodate for these
		// tasks by giving them mainListConnections based on the auto load
		// all option.
		if ($task == "deformerSetEd")
		{
			outlinerEditor
				-edit
				-mainListConnection		setList
				$outlinerEditor;
		}
		else if ($task == "uvCentricUvLinking")
		{
			// The UV Linking tasks make use of the LeftMainList
			// selectionConnection as the mainListConnection. They do this so 
			// that they can specify exactly what appears in the relationship 
			// editor based on the current selection.
			//
			outlinerEditor
				-edit
				-mainListConnection ($panel + "LeftMainList")
				$outlinerEditor;
		}
		else if ( false
			|| ($task == "hairUVLinking")
			|| ($task == "furUVLinking") || ($task == "hairFurLinking")
			 || ($task == "pfxUVLinking")
			 )
		{
			// The UV Linking tasks make use of the LeftMainList
			// selectionConnection as the mainListConnection. They do this so 
			// that they can specify exactly what appears in the relationship 
			// editor based on the current selection.
			//
			outlinerEditor
				-edit
				-mainListConnection ($panel + "LeftMainList")
				$outlinerEditor;
		}
		else if ($task == "textureCentricUvLinking")
		{
			// The UV Linking tasks make use of the LeftMainList
			// selectionConnection as the mainListConnection. They do this so 
			// that they can specify exactly what appears in the relationship 
			// editor based on the current selection.
			//
			outlinerEditor
				-edit
				-mainListConnection ($panel + "LeftMainList")
				$outlinerEditor;
		}
		else
		{
			outlinerEditor
				-edit
				-mainListConnection		worldList
				$outlinerEditor;
		}
	}

	// Setup the outliner with a base configuration so that one task can't
	// leave the outliner in a bad state for other tasks.
	//
	outlinerEditor
		-edit
		-directSelect			true
		-ignoreDagHierarchy		false
		-showShapes 			false
		-showAttributes 		false
		-showConnected 			false
		-showSetMembers 		true
		-showDagOnly 			true
		-showReferenceNodes		false
		-showReferenceMembers	false
		-doNotSelectNewObjects 	true
		-autoSelectNewObjects 	false
		-setFilter				0
		-filter					0
		-autoExpand				false
		-expandConnections		false
		-showCompounds			true
		-showLeafs				true
		-showTextureNodesOnly	false
		-showUVAttrsOnly		false
		-highlightSecondary		false
		-showAttrValues			false
		-organizeByLayer        false
		-showContainedOnly		true
		$outlinerEditor;

	// Further configure the left outliner to show the
	// entities appropriate to this task.
	//

	if ($task == "lightCentricLightLinking")
	{
		outlinerEditor
			-edit
			-directSelect			true
			-ignoreDagHierarchy		false
			-showShapes 			false
			-showAttributes 		false
			-showConnected 			false
			-showSetMembers 		true
			-showDagOnly 			true
			-doNotSelectNewObjects 	true
			-autoSelectNewObjects 	false
			-setFilter				0
			-filter					0
			$outlinerEditor;
	}
	else if ($task == "objectCentricLightLinking")
	{
		outlinerEditor
			-edit
			-directSelect			true
			-ignoreDagHierarchy		false
			-showShapes 			false
			-showAttributes 		false
			-showConnected 			false
			-showDagOnly 			true
			-showSetMembers 		true
			-doNotSelectNewObjects 	true
			-autoSelectNewObjects 	false
			-setFilter				0
			-filter					0
			$outlinerEditor;
	}
	else
	if ($task == "setMembership") 
	{
		outlinerEditor
			-edit
			-directSelect			true
			-ignoreDagHierarchy		false
			-showShapes 			true
			-showAttributes 		false
			-showConnected 			false
			-showDagOnly 			false
			-showSetMembers 		true
			-doNotSelectNewObjects 	true
			-autoSelectNewObjects 	false
			-setFilter				0
			$outlinerEditor;
	}
	else if ($task == "partitionMembership") 
	{
		outlinerEditor
			-edit
			-directSelect			true
			-ignoreDagHierarchy		false
			-showShapes 			true
			-showAttributes 		false
			-showConnected 			false
			-showDagOnly 			false
			-showSetMembers 		true
			-doNotSelectNewObjects 	true
			-autoSelectNewObjects 	false
			-setFilter				0
			$outlinerEditor;
	}
	else if ($task == "displayLayers" 
		|| $task == "renderLayers"
		)
	{
		outlinerEditor
			-edit
			-directSelect			true
			-ignoreDagHierarchy		false
			-showShapes 			true
			-showAttributes 		false
			-showConnected 			false
			-showDagOnly 			false
			-showSetMembers 		true
			-doNotSelectNewObjects 	true
			-autoSelectNewObjects 	false
			-setFilter				0
			$outlinerEditor;
	}
	else if ($task == "animLayers")
	{
		outlinerEditor
			-edit
			-directSelect			true
			-ignoreDagHierarchy		false
			-showShapes 			true
			-showAttributes 		true
			-showConnected 			false
			-showDagOnly 			false
			-showSetMembers 		true
			-doNotSelectNewObjects 	true
			-autoSelectNewObjects 	false
			-setFilter				0
			$outlinerEditor;
	}
	else if ($task == "characterMembership") 
	{
		outlinerEditor
			-edit
			-directSelect			true
			-ignoreDagHierarchy		false
			-showShapes 			true
			-showAttributes 		false
			-showConnected 			false
			-showDagOnly 			false
			-showSetMembers 		true
			-doNotSelectNewObjects 	true
			-autoSelectNewObjects 	false
			-setFilter				0
			-filter				    0
			$outlinerEditor;
	}
	else if ($task == "deformerSetEd")
	{
		outlinerEditor
			-edit
			-directSelect			true
			-ignoreDagHierarchy		false
			-showShapes 			true
			-showAttributes 		false
			-showConnected 			false
			-showDagOnly 			false
			-showSetMembers 		true
			-doNotSelectNewObjects 	true
			-autoSelectNewObjects 	false
			-setFilter				deformerSetsFilter
			$outlinerEditor;
	}
	else if ($task == "renderPassSetEd")
	{
		outlinerEditor
			-edit
			-directSelect			true
			-ignoreDagHierarchy		false
			-showShapes 			true
			-showAttributes 		false
			-showConnected 			false
			-showDagOnly 			false
			-showSetMembers 		true
			-doNotSelectNewObjects 	true
			-autoSelectNewObjects 	false
			-setFilter				0
			$outlinerEditor;
	}
	else if ($task == "uvCentricUvLinking")
	{
		outlinerEditor
			-edit
			-directSelect			true
			-ignoreDagHierarchy		false
			-showShapes 			true
			-showAttributes 		true
			-showConnected 			false
			-showDagOnly 			false
			-showSetMembers 		true
			-doNotSelectNewObjects 	true
			-autoSelectNewObjects 	false
			-setFilter 				0
			-filter					0
			-showCompounds			false
			-autoExpand				true
			-showTextureNodesOnly	false
			-showUVAttrsOnly		true
			-highlightSecondary		false
			-showAttrValues			true
			-allowMultiSelection	false
			$outlinerEditor;
	}
	else if ($task == "furUVLinking")
	{
		outlinerEditor
			-edit
			-directSelect			true
			-ignoreDagHierarchy		false
			-showShapes 			false
			-showAttributes 		false
			-showConnected 			false
			-showDagOnly 			false
			-showSetMembers 		false
			-doNotSelectNewObjects 	true
			-autoSelectNewObjects 	false
			-setFilter				0
			$outlinerEditor;
	}
	else if ($task == "hairFurLinking")
	{
		outlinerEditor
			-edit
			-directSelect			true
			-ignoreDagHierarchy		false
			-showShapes 			true
			-showAttributes 		false
			-showConnected 			false
			-showDagOnly 			false
			-showSetMembers 		false
			-doNotSelectNewObjects 	true
			-autoSelectNewObjects 	false
			-setFilter				0
			$outlinerEditor;
	}
	else if ( false 
		|| $task == "pfxUVLinking"
		|| $task == "hairUVLinking"
		)
	{
		outlinerEditor
			-edit
			-directSelect			true
			-ignoreDagHierarchy		false
			-showShapes 			true
			-showAttributes 		false
			-showConnected 			false
			-showDagOnly 			false
			-showSetMembers 		false
			-doNotSelectNewObjects 	true
			-autoSelectNewObjects 	false
			-setFilter				0
			$outlinerEditor;
	}
	else if ($task == "textureCentricUvLinking")
	{
		outlinerEditor
			-edit
			-directSelect			true
			-ignoreDagHierarchy		false
			-showShapes 			true
			-showAttributes 		true
			-showConnected 			true
			-showDagOnly 			false
			-showSetMembers 		true
			-doNotSelectNewObjects 	true
			-autoSelectNewObjects 	false
			-setFilter 				0
			-filter					0
			-showCompounds			true
			-showLeafs				false
			-autoExpand				true
			-expandConnections		true
			-showTextureNodesOnly	true
			-showUVAttrsOnly		false
			-highlightSecondary		true
			-showAttrValues			false
			$outlinerEditor;
	}
	else if ($task == "eventCentricInteraction") 
	{
		outlinerEditor
			-edit
			-ignoreDagHierarchy		true
			-showAttributes 		true
			-showDagOnly 			false
			-showSetMembers 		false
			-showCompounds			false
			-autoExpand				true
			-expandObjects			true
			-highlightSecondary		true
			-allowMultiSelection	false
			$outlinerEditor;
			
		// Set the outliner to filter only event attributes.
	    string $filters[]  = miCreateOutlinerFilters(true);
	    miSetOutlinerFilters($outlinerEditor, $filters[0], $filters[1]);
	}
	else if ($task == "actionCentricInteraction") 
	{
		outlinerEditor
			-edit
			-ignoreDagHierarchy		true
			-showAttributes 		true
			-showDagOnly 			false
			-showSetMembers 		false
			-showCompounds			false
			-autoExpand				true
			-expandObjects			true
			-highlightSecondary		true
			-allowMultiSelection	false
			$outlinerEditor;
			
		// Set the outliner to filter only action attributes.
	    string $filters[]  = miCreateOutlinerFilters(false);
	    miSetOutlinerFilters($outlinerEditor, $filters[0], $filters[1]);
	}
	else if ($task == "touchSensorAssociation") 
	{
		string $filter = `itemFilter -classification "builtIn" -byType miTouchSensor`;

		outlinerEditor
			-edit
			-dag false
			-showAttributes false
			-filter $filter
			$outlinerEditor;
	}
	else if ($task == "cameraSets")
	{
		outlinerEditor
			-edit
			-directSelect			true
			-ignoreDagHierarchy		true
			-showShapes 			false
			-showAttributes 		true
			-showConnected 			true
			-showDagOnly 			false
			-showSetMembers 		false
			-doNotSelectNewObjects 	true
			-autoSelectNewObjects 	false
			-setFilter 				0
			-showCompounds			true
			-showLeafs				true
			-autoExpand				true
			-expandConnections		true
			-expandObjects			true
			-showTextureNodesOnly	false
			-showUVAttrsOnly		false
			-highlightSecondary		true
			-showAttrValues			true
			$outlinerEditor;
	}
}

proc configureRightOutliner(
	string $panel, 
	string $task)
//
// Description:
//	This procedure is called every time the current task changes, and is also
//	called when the user changes the filtering of the right outliner by using 
//	the right menu.
//	This procedure modifies the filtering of items on the right outliner.
//	Filtering may be accomplished through use of filters, or through use of a
//	different mainListConnection, both, or even through some other mechanism.
//
//	It is "safe" to examine the right menu to determine what filter the user
//	has chosen.
//
//	If you are implementing a new task, you will want to add code to this
//	procedure to support the various filtering presets that are appropriate
//	for your task.
//
{
	string $outlinerEditor = ($panel + "RightOutliner");

	// Define what mainListConnection to use
	//
	if ($task == "uvCentricUvLinking")
	{
		// The UV Linking tasks make use of the RightMainList
		// selectionConnection as the mainListConnection. They do this so that
		// they can specify exactly what appears in the relationship editor
		// based on the current selection.
		//
		outlinerEditor
			-edit
			-mainListConnection ($panel + "RightMainList")
			$outlinerEditor;
	}
	else if ( false
		|| ($task == "hairUVLinking")
		|| ($task == "furUVLinking") || ($task == "hairFurLinking")
		|| ($task == "pfxUVLinking")
		)
	{
		// The UV Linking tasks make use of the RightMainList
		// selectionConnection as the mainListConnection. They do this so that
		// they can specify exactly what appears in the relationship editor
		// based on the current selection.
		//
		outlinerEditor
			-edit
			-mainListConnection ($panel + "RightMainList")
			$outlinerEditor;
	}
	else if ($task == "textureCentricUvLinking")
	{
		// The UV Linking tasks make use of the RightMainList
		// selectionConnection as the mainListConnection. They do this so that
		// they can specify exactly what appears in the relationship editor
		// based on the current selection.
		//
		outlinerEditor
			-edit
			-mainListConnection ($panel + "RightMainList")
			$outlinerEditor;
	}
	else if (`menuItem -query -radioButton rightListMenuAutoLoadAllItem`)
	{
		outlinerEditor
			-edit
			-mainListConnection		worldList
			$outlinerEditor;
	}
	else if (`menuItem -query -radioButton rightListMenuAutoLoadSelectionItem`)
	{
		outlinerEditor
			-edit
			-mainListConnection		activeList
			$outlinerEditor;
	}
	else if (`menuItem -query -radioButton rightListMenuManualLoadItem`)
	{
		outlinerEditor
			-edit
			-mainListConnection			($panel + "RightMainListManual")
			$outlinerEditor;

		relationshipEditorMenuCommand(
			$panel, 
			$task,
			"rightListMenuLoadListFromSelection");
	}
	else
	{
		outlinerEditor
			-edit
			-mainListConnection		worldList
			$outlinerEditor;
	}

	// Setup the outliner with a base configuration so that one task can't
	// leave the outliner in a bad state for other tasks.
	//
	outlinerEditor
		-edit
		-directSelect			true
		-ignoreDagHierarchy		false
		-showShapes 			false
		-showAttributes 		false
		-showConnected 			false
		-showSetMembers 		true
		-showDagOnly 			true
		-doNotSelectNewObjects 	true
		-autoSelectNewObjects 	false
		-setFilter				0
		-filter					0
		-autoExpand				false
		-expandConnections		false
		-showCompounds			true
		-showLeafs				true
		-showTextureNodesOnly	false
		-showUVAttrsOnly		false
		-highlightSecondary		false
		-showAttrValues			false
		-organizeByLayer        false
		$outlinerEditor;

	// Change the filter on the right outliner to show the
	// entities appropriate to this task.
	//

	if ($task == "lightCentricLightLinking")
	{
		outlinerEditor
			-edit
			-directSelect			true
			-ignoreDagHierarchy		false
			-showShapes 			false
			-showAttributes 		false
			-showConnected 			false
			-showDagOnly 			true
			-doNotSelectNewObjects 	true
			-autoSelectNewObjects 	false
			-showNumericAttrsOnly   false
			-showCompounds			true
			$outlinerEditor;
	}
	else if ($task == "objectCentricLightLinking")
	{
		outlinerEditor
			-edit
			-directSelect			true
			-ignoreDagHierarchy		false
			-showShapes 			false
			-showAttributes 		false
			-showConnected 			false
			-showDagOnly 			true
			-doNotSelectNewObjects 	true
			-autoSelectNewObjects 	false
			-showNumericAttrsOnly   false
			-showCompounds			true
			$outlinerEditor;
	}
	else
	if ($task == "displayLayers" 
		|| $task == "renderLayers"
		)
	{
		outlinerEditor
			-edit
			-directSelect			true
			-ignoreDagHierarchy		false
			-showShapes 			true
			-showAttributes 		false
			-showConnected 			false
			-showDagOnly 			true
			-showSetMembers 		false
			-doNotSelectNewObjects 	true
			-autoSelectNewObjects 	false
			-showNumericAttrsOnly   false
			-showCompounds			true
			$outlinerEditor;
	}
	else if ($task == "cameraSets")
	{
		outlinerEditor
			-edit
			-directSelect			true
			-ignoreDagHierarchy		false
			-showShapes 			false
			-showAttributes 		false
			-showConnected 			false
			-showDagOnly 			false
			-showSetMembers 		false
			-doNotSelectNewObjects 	true
			-autoSelectNewObjects 	false
			-showNumericAttrsOnly   false
			-showCompounds			false
			-expandConnections		false
			$outlinerEditor;
	}
	else if ($task == "animLayers")
	{
		outlinerEditor
			-edit
			-directSelect			true
			-ignoreDagHierarchy		false
			-showShapes 			true
			-showAttributes 		true
			-showConnected 			false
			-showDagOnly 			false
			-showSetMembers 		true
			-doNotSelectNewObjects 	true
			-autoSelectNewObjects 	false
			-showNumericAttrsOnly   true
			-showCompounds			false
			$outlinerEditor;
	}
	else if ( 
		($task == "setMembership") || 
		($task == "deformerSetEd") )
	{
		outlinerEditor
			-edit
			-directSelect			true
			-ignoreDagHierarchy		false
			-showShapes 			true
			-showAttributes 		false
			-showConnected 			false
			-showDagOnly 			false
			-showSetMembers 		true
			-doNotSelectNewObjects 	true
			-autoSelectNewObjects 	false
			-showNumericAttrsOnly   false
			-showCompounds			true
			$outlinerEditor;
	}
	else if ($task == "renderPassSetEd")
	{
		outlinerEditor
			-edit
			-directSelect			true
			-ignoreDagHierarchy		false
			-showShapes 			true
			-showAttributes 		false
			-showConnected 			false
			-showDagOnly 			false
			-showSetMembers 		true
			-doNotSelectNewObjects 	true
			-autoSelectNewObjects 	false
			-showNumericAttrsOnly   false
			-showCompounds			true
			$outlinerEditor;
	}
	else if ( $task == "partitionMembership" )
	{
		outlinerEditor
			-edit
			-directSelect			true
			-ignoreDagHierarchy		false
			-showShapes 			false
			-showAttributes 		false
			-showConnected 			false
			-showDagOnly 			false
			-showSetMembers 		true
			-doNotSelectNewObjects 	true
			-autoSelectNewObjects 	false
			-showNumericAttrsOnly   false
			-showCompounds			true
			$outlinerEditor;
	}
	else if ($task == "characterMembership")
	{
		outlinerEditor
			-edit
			-directSelect			true
			-ignoreDagHierarchy		false
			-showShapes 			true
			-showAttributes 		true
			-showConnected 			false
			-showDagOnly 			false
			-showSetMembers 		true
			-doNotSelectNewObjects 	true
			-autoSelectNewObjects 	false
			-showNumericAttrsOnly   true
			-showCompounds			false
			$outlinerEditor;
	}
	else if ($task == "uvCentricUvLinking")
	{
		outlinerEditor
			-edit
			-directSelect			true
			-ignoreDagHierarchy		false
			-showShapes 			true
			-showAttributes 		true
			-showConnected 			true
			-showDagOnly 			false
			-showSetMembers 		true
			-doNotSelectNewObjects 	true
			-autoSelectNewObjects 	false
			-setFilter 				0
			-filter					0
			-autoExpand				true
			-expandConnections		true
			-showCompounds			true
			-showLeafs				false
			-showTextureNodesOnly	true
			-showUVAttrsOnly		false
			-highlightSecondary		false
			-showAttrValues			false
			$outlinerEditor;
	}
	else if ($task == "furUVLinking")
	{
		outlinerEditor
			-edit
			-directSelect			true
			-ignoreDagHierarchy		false
			-showShapes 			true
			-showAttributes 		true
			-showConnected 			false
			-showDagOnly 			false
			-showSetMembers 		true
			-doNotSelectNewObjects 	true
			-autoSelectNewObjects 	false
			-setFilter 				0
			-filter					0
			-autoExpand				true
			-showCompounds			false
			-showTextureNodesOnly	false
			-showUVAttrsOnly		true
			-highlightSecondary		false
			-showAttrValues			true
			-allowMultiSelection	false
			$outlinerEditor;
	}
	else if ($task == "hairFurLinking")
	{
		outlinerEditor
			-edit
			-directSelect			true
			-ignoreDagHierarchy		false
			-showShapes 			true
			-showAttributes 		false
			-showConnected 			false
			-showDagOnly 			false
			-showSetMembers 		false
			-doNotSelectNewObjects 	true
			-autoSelectNewObjects 	false
			-setFilter 				0
			-filter					0
			-autoExpand				false
			-showCompounds			false
			-showTextureNodesOnly	false
			-showUVAttrsOnly		false
			-highlightSecondary		false
			-showAttrValues			false
			-allowMultiSelection	false
			$outlinerEditor;
	}
	else if ( false
		|| $task == "pfxUVLinking"
		|| $task == "hairUVLinking"
		)
	{
		outlinerEditor
			-edit
			-directSelect			true
			-ignoreDagHierarchy		false
			-showShapes 			true
			-showAttributes 		true
			-showConnected 			false
			-showDagOnly 			false
			-showSetMembers 		true
			-doNotSelectNewObjects 	true
			-autoSelectNewObjects 	false
			-setFilter 				0
			-filter					0
			-autoExpand				true
			-showCompounds			false
			-showTextureNodesOnly	false
			-showUVAttrsOnly		true
			-highlightSecondary		false
			-showAttrValues			true
			-allowMultiSelection	false
			-showLeafs				false
			-su						false
			$outlinerEditor;
	}
	else if ($task == "textureCentricUvLinking")
	{
		outlinerEditor
			-edit
			-directSelect			true
			-ignoreDagHierarchy		false
			-showShapes 			true
			-showAttributes 		true
			-showConnected 			false
			-showDagOnly 			false
			-showSetMembers 		true
			-doNotSelectNewObjects 	true
			-autoSelectNewObjects 	false
			-setFilter 				0
			-filter					0
			-autoExpand				true
			-showCompounds			false
			-showTextureNodesOnly	false
			-showUVAttrsOnly		true
			-highlightSecondary		false
			-showAttrValues			true
			-allowMultiSelection	false
			$outlinerEditor;
	}
	else if ($task == "eventCentricInteraction") 
	{
		outlinerEditor
			-edit
			-ignoreDagHierarchy		true
			-showAttributes 		true
			-showDagOnly 			false
			-showSetMembers 		false
			-showCompounds			false
			-showLeafs				false
			-autoExpand				true
			-expandObjects			true
			-highlightSecondary		true
			$outlinerEditor;
			
		// Set the outliner to filter only action attributes.
	    string $filters[]  = miCreateOutlinerFilters(false);
	    miSetOutlinerFilters($outlinerEditor, $filters[0], $filters[1]);
	}
	else if ($task == "actionCentricInteraction") 
	{
		outlinerEditor
			-edit
			-ignoreDagHierarchy		true
			-showAttributes 		true
			-showDagOnly 			false
			-showSetMembers 		false
			-showCompounds			false
			-showLeafs				false
			-autoExpand				true
			-expandObjects			true
			-highlightSecondary		true
			$outlinerEditor;
			
		// Set the outliner to filter only event attributes.
	    string $filters[]  = miCreateOutlinerFilters(true);
	    miSetOutlinerFilters($outlinerEditor, $filters[0], $filters[1]);
	}
	else if ($task == "touchSensorAssociation") 
	{
		string $filter = `itemFilter -classification "builtIn" -byType mesh`;

		outlinerEditor
			-edit
			-dag true
			-ignoreDagHierarchy false
			-showAttributes false
			-filter $filter
			$outlinerEditor;
	}
}

proc configureLeftImplicitFilter(
	string $panel, 
	string $task)
//
//	Description:
//		These are the implied filters used by the outliner on the left side.
//
{
	string $implicitFilterName = "";
	string $outlinerEditor = ($panel + "LeftOutliner");

	// Determine the name of the implicit filter to be used for this task.
	//
	if ($task == "lightCentricLightLinking")
	{
		$implicitFilterName = "DefaultLightLinkingLightFilter";
	}
	else if ($task == "objectCentricLightLinking")
	{
		$implicitFilterName = "lightLinkingObjectFilter";
	}
	else
	if ($task == "setMembership")
	{
		$implicitFilterName = "defaultSetFilter";
	}
	else if ($task == "partitionMembership")
	{
		$implicitFilterName = "partitionFilter";
	}
	else if ($task == "deformerSetEd")
	{
		$implicitFilterName = "deformerSetsFilter";
	}
	else if ($task == "displayLayers")
	{
		$implicitFilterName = "layersFilter";
	}
	else if ($task == "renderLayers")
	{
		$implicitFilterName = "renderLayerFilter";
	}
	else if ($task == "renderPassSetEd")
	{
		$implicitFilterName = "renderPassSetsFilter";
	}
	else if ($task == "animLayers")
	{
		$implicitFilterName = "animLayersFilter";
	}
	else if ($task == "uvCentricUvLinking")
	{
		// Todo: is there an implicit filter?
	}
	else if ($task == "furUVLinking")
	{
		// Todo: is there an implicit filter?
	}
	else if ($task == "hairFurLinking")
	{
		// Todo: is there an implicit filter?
	}
	else if ($task == "textureCentricUvLinking")
	{
		// Todo: is there an implicit filter?
	}

	if ($implicitFilterName != "")
	{
		if (`itemFilter -exists $implicitFilterName` ||
			`itemFilterAttr -exists $implicitFilterName` ||
			`itemFilterRender -exists $implicitFilterName`)
		{
			filterUISetImplicitFilter($outlinerEditor, $implicitFilterName);
		}
		else
		{
			string $warn = (uiRes("m_relationshipEditor.kLeftImplicitFilterNotFound"));
			string $warnMsg = `format -s $implicitFilterName $warn`;
			warning($warnMsg);
			filterUISetImplicitFilter($outlinerEditor, "");
		}
	}
	else
	{
		filterUISetImplicitFilter($outlinerEditor, "");
	}
	
	// If the task is an interaction task, just set the filters here.
	if ($task == "eventCentricInteraction")
	{
		string $filters[]  = miCreateOutlinerFilters(true);
		miSetOutlinerFilters($outlinerEditor, $filters[0], $filters[1]);
	}
	else if ($task == "actionCentricInteraction")
	{
		string $filters[]  = miCreateOutlinerFilters(false);
		miSetOutlinerFilters($outlinerEditor, $filters[0], $filters[1]);
	}
	else if ($task == "touchSensorAssociation") 
	{
		string $filter = `itemFilter -classification "builtIn" -byType miTouchSensor`;

		outlinerEditor
			-edit
			-dag false
			-showAttributes false
			-filter $filter
			$outlinerEditor;
	}
	else if ($task == "cameraSets") 
	{
		string $filter = `itemFilter -classification "builtIn" -byType cameraSet`;

		outlinerEditor
			-edit
			-filter $filter
			$outlinerEditor;
	}
}

proc configureRightImplicitFilter(
	string $panel, 
	string $task)
//
//	Description:
//		These are the implied filters used by the outliner on the right side.
//
{
	string $implicitFilterName = "";
	string $outlinerEditor = ($panel + "RightOutliner");

	// Determine the name of the implicit filter to be used for this task.
	//
	if ($task == "lightCentricLightLinking")
	{
		$implicitFilterName = "lightLinkingObjectFilter";
	}
	else if ($task == "objectCentricLightLinking")
	{
		$implicitFilterName = "DefaultLightLinkingLightFilter";
	}
	else if ($task == "renderPassSetEd")
	{
		$implicitFilterName = "renderPassesFilter";
	}
    else
	if ($task == "animLayers")
	{
		$implicitFilterName = "notAnimLayersFilter";
	}
	else
	if ($task == "partitionMembership")
	{
		$implicitFilterName = "DefaultSetsFilter";
	}
	else if ($task == "uvCentricUvLinking")
	{
		// Todo: is there an implicit filter?
	}
	else if ($task == "textureCentricUvLinking")
	{
		// Todo: is there an implicit filter?
	}
	else if ($task == "furUVLinking")
	{
		// Todo: is there an implicit filter?
	}
	else if ($task == "hairFurLinking")
	{
		// Todo: is there an implicit filter?
	}

	if ($implicitFilterName != "")
	{
		if (`itemFilter -exists $implicitFilterName` ||
			`itemFilterAttr -exists $implicitFilterName` ||
			`itemFilterRender -exists $implicitFilterName`)
		{
			filterUISetImplicitFilter($outlinerEditor, $implicitFilterName);
		}
		else
		{
			string $warn = (uiRes("m_relationshipEditor.kRightImplicitFilterNotFound"));
			string $warnMsg = `format -s $implicitFilterName $warn`;
			warning($warnMsg);
			filterUISetImplicitFilter($outlinerEditor, "");
		}
	}
	else
	{
		filterUISetImplicitFilter($outlinerEditor, "");
	}
	
	// If the task is an interaction task, just set the filters here.
	if ($task == "eventCentricInteraction")
	{
		string $filters[]  = miCreateOutlinerFilters(false);
		miSetOutlinerFilters($outlinerEditor, $filters[0], $filters[1]);
	}
	else if($task == "animLayers")
	{	            
		string $keyableFilter = `itemFilterAttr -keyable true`;
		outlinerEditor -edit -attrFilter $keyableFilter $outlinerEditor;	    
	}
	else if ($task == "actionCentricInteraction")
	{
		string $filters[]  = miCreateOutlinerFilters(true);
		miSetOutlinerFilters($outlinerEditor, $filters[0], $filters[1]);
	}
	else if ($task == "touchSensorAssociation") 
	{
		string $filter = `itemFilter -classification "builtIn" -byType mesh`;

		outlinerEditor
			-edit
			-dag true
			-showAttributes false
			-ignoreDagHierarchy false
			-filter $filter
			$outlinerEditor;
	}
	else if ($task == "cameraSets") 
	{
		string $setFilter = `itemFilter -classification "builtIn" -byType camera -byType objectSet`;
		string $seFilter = `itemFilter -classification "builtIn" -byType shadingEngine`;
		string $filter = `itemFilter  -classification "builtIn" -difference $setFilter $seFilter`;
		outlinerEditor
			-edit
			-filter $filter
			$outlinerEditor;
	}
}

proc lightLinkingEditorMenuCommand(
	string $panel,
	string $task,
	string $command)
{
	if (($command == "makeHighlightedLightsExclusive") ||
		($command == "makeHighlightedLightsNonExclusive")) 
	{
		string $action;

		if ($command == "makeHighlightedLightsExclusive")
		{
			if (!`objExists defaultLightSet`)
			{
				warning (uiRes("m_relationshipEditor.kLightsAlreadyExclusive"));
				return;
			}

			$action = "sets -remove defaultLightSet ";
		}
		else if ($command == "makeHighlightedLightsNonExclusive")
		{
			if (!`objExists defaultLightSet`)
			{
				warning (uiRes("m_relationshipEditor.kCannotMakeLightsNonExclusive"));
				return;
			}

			$action = "sets -addElement defaultLightSet ";
		}

		string $keyArray[] = 
			`selectionConnection 
				-query 
				-object 
				($panel + "LeftSelection")`;

		int $i;
		int $j;

		for ($i = 0; $i < size($keyArray); $i++)
		{
			string $keyShapeArray[];

			$keyShapeArray = `listRelatives -shapes $keyArray[$i]`;

			if (size($keyShapeArray) > 0)
			{
				for ($j = 0; $j < size($keyShapeArray); $j++)
				{
					string $parent[] = `listRelatives -parent $keyShapeArray[$j]`;
					$action = ($action + $parent[0] + " ");
				}

				eval($action);
			}
		}

		selectRelatedItems($panel, $task, $keyArray);
	}
	else if (
		($command == "createLightSet") ||
		($command == "createObjectSet"))
	{
		string $keySet;

		if ($command == "createLightSet")
		{
			$keySet = `sets -name "lightSet" -empty`;
		}
		else // ($command == "createObjectSet")
		{
			$keySet = `sets -name "objectSet" -empty`;
		}

		string $keyArray[] = 
			`selectionConnection 
				-query 
				-object 
				($panel + "LeftSelection")`;

		int $i;

		if (size($keyArray) > 0)
		{
			string $command;

			$command = ("sets -addElement " + $keySet + " ");

			for ($i = 0; $i < size($keyArray); $i++)
			{
				$command = ($command + $keyArray[$i] + " ");
			}

			eval($command);
		}
	}
}

proc setTextureVisibility(
	string 	$texture,
	int		$isVisible)
{
	string 	$colorDstArray[];
	string 	$alphaDstArray[];
	int 	$i;
	string 	$tokenArray[];
	string 	$dstNode;
	string 	$dstAttr;
	int		$success;

	$colorDstArray = 
		`listConnections 
			-source false 
			-destination true 
			-plugs true 
			($texture + ".outColor")`;
	$alphaDstArray = 
		`listConnections 
			-source false 
			-destination true 
			-plugs true 
			($texture + ".outAlpha")`;
	
	for ($i = 0; $i < size($colorDstArray); $i++)
	{
		$success = false;

		// If the destination is the color of a layer of a layered texture,
		// we'll toggle the visibility of that layer. Otherwise, we'll change 
		// whether the destination ignores the texture.
		//
		tokenize($colorDstArray[$i], ".", $tokenArray);
		$dstNode = $tokenArray[0];
		$inputsAttr = $tokenArray[1];
		$dstAttr = $tokenArray[2];

		if ((`nodeType $dstNode` == "layeredTexture") && ($dstAttr == "color"))
		{
			string	$regExp;
			string	$index;

			$regExp = "\\[.*\\]";
			$index = match($regExp, $inputsAttr);

			if ($index != "")
			{
				setAttr 
					($dstNode + ".inputs" + $index + ".isVisible") 
					$isVisible;
				$success = true;
			}
		}

		if (!$success)
		{
			// The destination wasn't the color of a layer of a layered
			// texture, so we change whether the texture is ignored.
			//
			shadingConnection 
				-edit 
				-connectionState $isVisible 
				$colorDstArray[$i];
		}
	}

	for ($i = 0; $i < size($alphaDstArray); $i++)
	{
		$success = false;

		// If the destination is the alpha of a layer of a layered texture,
		// we'll change the visibility of that layer. Otherwise, we'll change 
		// whether the destination ignores the texture.
		//
		tokenize($alphaDstArray[$i], ".", $tokenArray);
		$dstNode = $tokenArray[0];
		$inputsAttr = $tokenArray[1];
		$dstAttr = $tokenArray[2];

		if ((`nodeType $dstNode` == "layeredTexture") && ($dstAttr == "alpha"))
		{
			string	$regExp;
			string	$index;

			$regExp = "\\[.*\\]";
			$index = match($regExp, $tokenArray[1]);

			if ($index != "")
			{
				setAttr 
					($dstNode + ".inputs" + $index + ".isVisible")
					$isVisible;
				$success = true;
			}
		}

		if (!$success)
		{
			// The destination wasn't the alpha of a layer of a layered
			// texture, so we change whether the texture is ignored.
			//
			shadingConnection 
				-edit 
				-connectionState $isVisible 
				$alphaDstArray[$i];
		}
	}
}

proc ignoreTexture(
	string 	$texture)
{
	setTextureVisibility($texture, false);
}

proc unignoreTexture(
	string 	$texture)
{
	setTextureVisibility($texture, true);
}

proc getUpstreamTextures(string $node, string $upstreamTextureArray[])
{
	string $history[] = `listHistory $node`;

	int $i;

	for ($i = 0; $i < size($history); $i++)
	{
		if (size(`ls ($history[$i] + ".uvCoord")`) > 0)
		{
			if (`nodeType $history[$i]` != "place2dTexture")
			{
				$upstreamTextureArray[size($upstreamTextureArray)] 
					= $history[$i];
			}
		}
	}
}

proc uvLinkingEditorMenuCommand(
	string $panel,
	string $task,
	string $command)
{
	string $uvMainListConnection;
	string $uvSelection;
	string $textureMainListConnection;
	string $textureSelection;

	if ($task == "uvCentricUvLinking")
	{
		$uvMainListConnection = ($panel + "LeftMainList");
		$textureMainListConnection = ($panel + "RightMainList");
		$uvSelection = ($panel + "LeftSelection");
		$textureSelection = ($panel + "RightSelection");
	}
	else
	{
		$uvMainListConnection = ($panel + "RightMainList");
		$textureMainListConnection = ($panel + "LeftMainList");
		$uvSelection = ($panel + "RightSelection");
		$textureSelection = ($panel + "LeftSelection");
	}

	if (($command == "leftEditRemoveUvSet") ||
		($command == "rightEditRemoveUvSet"))
	{
		// Remove the UV set(s) (should automatically be removed from the 
		// mainListConnection)
		// 
		string $uvSetArray[];
		$uvSetArray = `selectionConnection -q -object $uvSelection`;
		for ($i =0; $i < size($uvSetArray); $i++)
		{
			string $uvSetName = `getAttr $uvSetArray[$i]`;
			string $buffer[];
			string $objName = "";
			int $numTokens = `tokenize $uvSetArray[$i] "." $buffer`;
			if ($numTokens > 0)
				$objName = $buffer[0];
			if (size($uvSetName) && size($objName))
			{
				polyUVSet -delete -uvSet $uvSetName $objName;
			}
		}
	}
	else if (
		($command == "leftEditRenameUvSet") ||
		($command == "rightEditRenameUvSet"))
	{
		// Rename the UV set(s).
		string $uvSetArray[];
		$uvSetArray = `selectionConnection -q -object $uvSelection`;
		int $numItems = size($uvSetArray);
		if ($numItems)
		{
			string $attrName = $uvSetArray[$numItems-1];
			string $uvSetName = `getAttr $attrName`;
			string $buffer[];
			string $objName = "";
			int $numTokens = `tokenize $attrName "." $buffer`;
			if ($numTokens > 0)
				$objName = $buffer[0];
			if (size($uvSetName) && size($objName))
			{
				performRenameUVSet 1 $uvSetName $objName;
			}
		}
	}
	else if (
		($command == "leftEditIgnoreTexture") ||
		($command == "rightEditIgnoreTexture"))
	{
		// Ignore the textures
		// 
		string 	$texturesToIgnoreArray[];  
		int		$i;

		$texturesToIgnoreArray = 
			`selectionConnection -q -object $textureSelection`;

		for ($i = 0; $i < size($texturesToIgnoreArray); $i++)
		{
			ignoreTexture($texturesToIgnoreArray[$i]);
		}
	}
	else if (
		($command == "leftEditUnignoreTexture") ||
		($command == "rightEditUnignoreTexture"))
	{
		// Unignore the textures
		// 
		string 	$texturesToUnignoreArray[];  
		int		$i;

		$texturesToUnignoreArray = 
			`selectionConnection -q -object $textureSelection`;

		for ($i = 0; $i < size($texturesToUnignoreArray); $i++)
		{
			unignoreTexture($texturesToUnignoreArray[$i]);
		}
	}
	else if (
		($command == "leftEditIsolateTexture") ||
		($command == "rightEditIsolateTexture"))
	{
		// Isolate the textures
		//
		string 	$texturesToIsolateArray[];
		string 	$allTexturesArray[];
		string 	$downstreamNodes[];
		int 	$i; 

		$texturesToIsolateArray = 
			`selectionConnection -q -object $textureSelection`;
		$downstreamNodes =
			`selectionConnection -q -object $textureMainListConnection`;

		for ($i = 0; $i < size($downstreamNodes); $i++)
		{
			getUpstreamTextures($downstreamNodes[$i], $allTexturesArray);
		}

		for ($i = 0; $i < size($allTexturesArray); $i++)
		{
			ignoreTexture($allTexturesArray[$i]);
		}

		for ($i = 0; $i < size($texturesToIsolateArray); $i++)
		{
			unignoreTexture($texturesToIsolateArray[$i]);
		}
	}
	else if (
		($command == "leftEditUnignoreAllTextures") ||
		($command == "rightEditUnignoreAllTextures"))
	{
		// Unignore all textures
		// 
		string 	$allTexturesArray[];
		string 	$downstreamNodes[];
		int 	$i; 

		$downstreamNodes =
			`selectionConnection -q -object $textureMainListConnection`;

		for ($i = 0; $i < size($downstreamNodes); $i++)
		{
			getUpstreamTextures($downstreamNodes[$i], $allTexturesArray);
		}

		for ($i = 0; $i < size($allTexturesArray); $i++)
		{
			unignoreTexture($allTexturesArray[$i]);
		}
	}
	else if (
		($command == "leftEditAttributeEditor") ||
		($command == "rightEditAttributeEditor"))
	{
		// Open the attribute editor for the highlighted texture. If there is
		// more than one texture highlighted, issue a warning and don't open
		// any attribute editor.
		//
		string $highlighted[];

		$highlighted = `selectionConnection -q -object $textureSelection`;

		if (size($highlighted) > 1)
		{
			warning (uiRes("m_relationshipEditor.kCannotOpenAttributeEditor"));
			return;
		}
		else if (size($highlighted) == 0)
		{
			warning (uiRes("m_relationshipEditor.kNoItemHighlighted"));
			return;
		}
		else
		{
			showEditor $highlighted[0];
		}
	}
}

proc hairFurLinkingEditorMenuCommand(
	string $panel,
	string $task,
	string $command)
{
	string $hairSysMainListConnection;
	string $hairSysSelection;
	string $furDesMainListConnection;
	string $furDesSelection;

	$furDesMainListConnection = ($panel + "RightMainList");
	$hairSysMainListConnection = ($panel + "LeftMainList");
	$furDesSelection = ($panel + "RightSelection");
	$hairSysSelection = ($panel + "LeftSelection");

	if ( $command == "leftEditAttributeEditor" )
	{
		// Open the attribute editor for the highlighted FurDescription. If there is
		// more than one fur descriptions highlighted, issue a warning and don't open
		// any attribute editor.
		//
		string $highlighted[];
		$highlighted = `selectionConnection -q -object $hairSysSelection`;
		if (size($highlighted) > 1)
		{
			warning (uiRes("m_relationshipEditor.kCannotOpenAttributeEditor"));
			return;
		}
		else if (size($highlighted) == 0)
		{
			warning (uiRes("m_relationshipEditor.kHairFurLinkingNoItemHighlighted"));
			return;
		}
		else
		{
			showEditor $highlighted[0];
		}
	}	
}
proc uvFurLinkingEditorMenuCommand(
	string $panel,
	string $task,
	string $command)
{
	string $uvMainListConnection;
	string $uvSelection;
	string $furMainListConnection;
	string $furSelection;

	$uvMainListConnection = ($panel + "RightMainList");
	$furMainListConnection = ($panel + "LeftMainList");
	$uvSelection = ($panel + "RightSelection");
	$furSelection = ($panel + "LeftSelection");

	if ( $command == "rightEditRenameUvSet" )
	{
		// Rename the UV set(s).
		string $uvSetArray[];
		$uvSetArray = `selectionConnection -q -object $uvSelection`;
		for ($i =0; $i < size($uvSetArray); $i++)
		{
			if(!`uvLink -isValid -uvSet $uvSetArray[$i]`)
			{
				warning (uiRes("m_relationshipEditor.kSelectUVSet"));
				return;
			}
		}
		int $numItems = size($uvSetArray);
		if ($numItems)
		{
			string $attrName = $uvSetArray[$numItems-1];
			string $uvSetName = `getAttr $attrName`;
			string $buffer[];
			string $objName = "";
			int $numTokens = `tokenize $attrName "." $buffer`;
			if ($numTokens > 0)
				$objName = $buffer[0];
			if (size($uvSetName) && size($objName))
			{
				performRenameUVSet 1 $uvSetName $objName;
			}
		}
	}
	else if ( $command == "leftEditAttributeEditor" )
	{
		// Open the attribute editor for the highlighted FurDescription. If there is
		// more than one fur descriptions highlighted, issue a warning and don't open
		// any attribute editor.
		//
		string $highlighted[];

		$highlighted = `selectionConnection -q -object $furSelection`;

		if (size($highlighted) > 1)
		{
			warning (uiRes("m_relationshipEditor.kCannotOpenAttributeEditor"));
			return;
		}
		else if (size($highlighted) == 0)
		{
			warning (uiRes("m_relationshipEditor.kLeftEditAttributeEditorNoItemHighlighted"));
			return;
		}
		else
		{
			showEditor $highlighted[0];
		}
	}
	else if ( $command == "leftEditDeleteFur" ) 
	{
		// Delete all highlighted fur descriptions. If nothing is
		// highlighted, issue a warning.
		//
		string $highlighted[];

		$highlighted = `selectionConnection -q -object $furSelection`;

		if (size($highlighted) == 0)
		{
			warning (uiRes("m_relationshipEditor.kLeftEditDeleteFurNoItemHighlighted"));
			return;
		}
		else
		{
			int $nCount;
			for($nCount=0; $nCount < size($highlighted); $nCount++)
			{
				HfDeleteHD $highlighted[$nCount];
			}
			relationshipEditorRelationshipsChanged($panel, $task);
		}
	}
	else if ( $command == "leftEditDuplicateFur" )
	{
		// Duplicate all highlighted fur descriptions. If nothing is
		// highlighted, issue a warning.
		//
		string $highlighted[];

		$highlighted = `selectionConnection -q -object $furSelection`;

		if (size($highlighted) == 0)
		{
			warning (uiRes("m_relationshipEditor.kLeftEditDuplicateFurNoItemHighlighted"));
			return;
		}
		else
		{
			int $nCount;
			for($nCount=0; $nCount < size($highlighted); $nCount++)
			{
				HfCopyHD $highlighted[$nCount];
			}
			relationshipEditorRelationshipsChanged($panel, $task);
		}
	}
}

proc uvPfxLinkingEditorMenuCommand(
	string $panel,
	string $task,
	string $command)
{
	string $uvMainListConnection;
	string $uvSelection;
	string $pfxMainListConnection;
	string $pfxSelection;

	$uvMainListConnection = ($panel + "RightMainList");
	$pfxMainListConnection = ($panel + "LeftMainList");
	$uvSelection = ($panel + "RightSelection");
	$pfxSelection = ($panel + "LeftSelection");

	if ( $command == "rightEditRenameUvSet" )
	{
		// Rename the UV set(s).
		string $uvSetArray[];
		$uvSetArray = `selectionConnection -q -object $uvSelection`;
		for ($i =0; $i < size($uvSetArray); $i++)
		{
			if(!`uvLink -isValid -uvSet $uvSetArray[$i]`)
			{
				warning (uiRes("m_relationshipEditor.kSelectUVSetToRename"));
				return;
			}
		}
		int $numItems = size($uvSetArray);
		if ($numItems)
		{
			string $attrName = $uvSetArray[$numItems-1];
			string $uvSetName = `getAttr $attrName`;
			string $buffer[];
			string $objName = "";
			int $numTokens = `tokenize $attrName "." $buffer`;
			if ($numTokens > 0)
				$objName = $buffer[0];
			if (size($uvSetName) && size($objName))
			{
				performRenameUVSet 1 $uvSetName $objName;
			}
		}
	}
}

proc uvHairLinkingEditorMenuCommand(
	string $panel,
	string $task,
	string $command)
{
	string $uvMainListConnection;
	string $uvSelection;
	string $hairMainListConnection;
	string $hairSelection;

	$uvMainListConnection = ($panel + "RightMainList");
	$hairMainListConnection = ($panel + "LeftMainList");
	$uvSelection = ($panel + "RightSelection");
	$hairSelection = ($panel + "LeftSelection");

	if ( $command == "rightEditRenameUvSet" )
	{
		// Rename the UV set(s).
		string $uvSetArray[];
		$uvSetArray = `selectionConnection -q -object $uvSelection`;
		for ($i =0; $i < size($uvSetArray); $i++)
		{
			if(!`uvLink -isValid -uvSet $uvSetArray[$i]`)
			{
				warning (uiRes("m_relationshipEditor.kUVHairLinkingSelectUVSetToRename"));
				return;
			}
		}
		int $numItems = size($uvSetArray);
		if ($numItems)
		{
			string $attrName = $uvSetArray[$numItems-1];
			string $uvSetName = `getAttr $attrName`;
			string $buffer[];
			string $objName = "";
			int $numTokens = `tokenize $attrName "." $buffer`;
			if ($numTokens > 0)
				$objName = $buffer[0];
			if (size($uvSetName) && size($objName))
			{
				performRenameUVSet 1 $uvSetName $objName;
			}
		}
	}
}

proc cameraSetEditorMenuCommand(
	string $panel,
	string $task,
	string $command)
{
	string $cameraSetSelection = ($panel + "LeftSelection");
	string $selection[] = `selectionConnection -query -object $cameraSetSelection`;
	string $keys[] = validKeys($panel, $task, $selection);
	if (size($keys) == 0)
		return;

	if ($command == "leftEditMenuDeleteHighlightedCameraLayer")
	{
		// Get the key object name.  If it's invalid, just return.
		string $buffer[];
		string $keyObjName = "";
		int $numTokens = `tokenize $keys[0] "." $buffer`;
		if ($numTokens > 0)
			$keyObjName = $buffer[0];
		if (size($keyObjName) == 0)
			return;

		// Get the selection and see if it contains a camera layer.
		string $attr = "";
		if ($numTokens == 2)
			$attr = $keys[0];
		else if ($numTokens == 3)
			$attr = ($buffer[0] + "." + $buffer[1]);
		if ($attr == "")
			return;

		// Get the layer number.
		string $attrTokens[];
		$numTokens = `tokenize $keys[0] "[" $attrTokens`;
		if (size($attrTokens) <= 1)
			return;
			
		string $layerNumTokens[];
		int $numLayerNumTokens = `tokenize $attrTokens[1] "]" $layerNumTokens`;
		string $layerNum = $layerNumTokens[0];
		
		eval("cameraSet -e -layer " + $layerNum + "-deleteLayer " + $keyObjName);

		selectionConnection -e -clear $cameraSetSelection;

		refresh -f;
	}
	else if ($command == "leftEditMenuDeleteHighlightedCameraSet")
	{
		// Get the selection and delete the node it refers to.
		string $buffer[];
		int $numTokens = `tokenize $keys[0] "." $buffer`;

		// Clear the selection, which will update the enabled state of the
		// Edit menu items.  This must be done before the node is deleted,
		// or the selection callback will not be called.
		selectionConnection -e -clear $cameraSetSelection;
		delete $buffer[0];
	}
	else if ($command == "leftEditMenuCreateCameraLayer")
	{
		// Get the selected cameraSet create a camera pass for it.
		string $buffer[];
		int $numTokens = `tokenize $keys[0] "." $buffer`;
		performCreateCameraLayer $buffer[0] 1;
	}
}

global proc relationshipEditorMenuCommand(
	string $panel,
	string $task,
	string $command)
//
// Description:
//	This procedure is intended to be used as a global point of entry to this
//	file, to be called by menu items in the relationship editor.
//	This procedure (globally accessible) will call other procedures (only
//	locally accessible) in this same file in order to carry out the behaviour
//	expected by the user.
//	You may need to modify this procedure if you are implementing a new task.
//	Note that changes of filter are already handled for all tasks.
//
{
	// Menu commands common to all tasks
	//
	if (($command == "leftListMenuManualLoad") ||
		($command == "leftListMenuAutoLoadAll"))
	{
		// Refresh the menu to enable or disable the manual load action
		// items.
		//
		refreshLeftListMenu($panel, $task);

		// Configure the filtering of the left side
		//
		configureLeftOutliner($panel, $task);
		configureLeftImplicitFilter($panel, $task);
	}
	else if (
		($command == "rightListMenuAutoLoadAll") || 
		($command == "rightListMenuAutoLoadSelection") ||
		($command == "rightListMenuManualLoad"))
	{
		// Refresh the menu to enable or disable the manual load action
		// items.
		//
		refreshRightListMenu($panel, $task);

		// Configure the filtering of the right side
		//
		configureRightOutliner($panel, $task);
		configureRightImplicitFilter($panel, $task);
	}
	else if ($command == "leftListMenuLoadListFromSelection")
	{
		manualLoadCommand($panel, $task, "left", "loadListFromSelection");
	}
	else if ($command == "rightListMenuLoadListFromSelection")
	{
		manualLoadCommand($panel, $task, "right", "loadListFromSelection");
	}
	else if ($command == "leftListMenuAddSelectionToList")
	{
		manualLoadCommand($panel, $task, "left", "addSelectionToList");
	}
	else if ($command == "rightListMenuAddSelectionToList")
	{
		manualLoadCommand($panel, $task, "right", "addSelectionToList");
	}
	else if ($command == "leftListMenuRemoveSelectionFromList")
	{
		manualLoadCommand($panel, $task, "left", "removeSelectionFromList");
	}
	else if ($command == "rightListMenuRemoveSelectionFromList")
	{
		manualLoadCommand($panel, $task, "right", "removeSelectionFromList");
	}
	else if ($command == "leftEditMenuSelectHighlighted")
	{
		// put all the selected items from the left pane on the active list
		//
		string $selectedItems[] = 
			`selectionConnection -q -object ($panel + "LeftSelection")`;
		select -r -ne $selectedItems;
	}
	else if ($command == "leftEditMenuDeleteHighlighted")
	{
		// remove from the model all the selected items from the left pane
		//
		string $selectedItems[] = 
			`selectionConnection -q -object ($panel + "LeftSelection")`;
		delete $selectedItems;

		// clear the selection list so the highlighted items won't remain
		// on it
		//
		selectionConnection -edit -clear ($panel + "LeftSelection");

		// also clear the non-key side selection list because the key is 
		// already deleted
		//
		selectionConnection -edit -clear ($panel + "RightSelection");
	}
	else if ($command == "leftEditMenuRemoveHighlightedFromSet")
	{
		// remove the selected item on the left pane from it's set
		//
		string $selections[] = 
			`selectionConnection -q -object ($panel + "LeftSelection")`;
		int $numToRemove = size($selections);
		if ( $numToRemove == 0 ) 
			warning (uiRes("m_relationshipEditor.kNoMembersHighlighted"));
		else
		{
			// remove each highlighted item from each set
			//
			int $i, $j;
			string $setNames[];
			int $numSets;
			for ( $i = 0; $i < $numToRemove; $i++ )
			{
				$setNames = `outlinerEditor -object $selections[$i] -query -parentObject ($panel + "LeftOutliner")`;
				$numSets = size($setNames);
				for ( $j = 0; $j < $numSets; $j++ )
				{
					int $character = (nodeType($setNames[$j]) == "character");
					if ( !$character &&
						 (($task == "setMembership") || 
						  ($task == "deformerSetEd")) ) {
						sets -edit -remove $setNames[$j] $selections[$i];
					}
					else if ( $character || ($task == "characterMembership") )
					{
						removeFromCharacter( $setNames[$j], {$selections[$i]} );
					}
					else if ( $task == "partitionMembership" )
						partition -removeSet $setNames[$j] $selections[$i];
					else if ( $task == "displayLayers" )
						editDisplayLayerMembers -nr "defaultLayer" $selections[$i];
					else if ( $task == "renderLayers" )
						editRenderLayerMembers -remove -noRecurse $setNames[$j] $selections[$i];
				}
			}

			// clear the selection list so the highlighted items won't remain
			// on it
			//
			selectionConnection -edit -clear ($panel + "LeftSelection");
		}
	}
	else if ($command == "rightEditMenuSelectHighlighted")
	{
		// put all the selected items from the right pane on the active list
		//
		string $selectedItems[] = 
			`selectionConnection -q -object ($panel + "RightSelection")`;
		select -r -ne $selectedItems;
	}
	else if ($command == "leftEditSelectMembersOfHighlighted")
	{
		// put all the members of the selected items from the left pane on 
		// the active list
		//
		string $selectedItems[] = 
			`selectionConnection -q -object ($panel + "LeftSelection")`;
		int $numSel = size($selectedItems);
		int $i;
		string $members[];
		select -cl;		// clear the active list first
		for ( $i = 0; $i < $numSel; $i++ )
		{
			clear $members;		// clear the list from previous loop

			// get the members of the highlighted item
			//
			if ( $task == "characterMembership" ) {
				selectNodesInCharacter( $selectedItems[$i] );
			} 
			else
			{
				if ( $task == "setMembership" ) 
					$members = `sets -q $selectedItems[$i]`;
				else if ( $task == "partitionMembership" ) 
					$members = `partition -q $selectedItems[$i]`;
				else if ( $task == "displayLayers" ) 
					$members = `editDisplayLayerMembers -q $selectedItems[$i]`;
				else if ( $task == "renderLayers" )
					$members = `editRenderLayerMembers -q $selectedItems[$i]`;
				else if ( $task == "renderPassSetEd")
					$members = `listConnections -type "renderPass" ($selectedItems[$i] + ".renderPass")`;
				else if ( $task == "deformerSetEd" )
					$members = `sets -q $selectedItems[$i]`;

				select -tgl $members;	// add to active list
			}
		}
	}

	// Menu commands specific to a particular task
	//
	if ($task == "setMembership" || $task == "deformerSetEd")
	{
		setMembershipEditorMenuCommand($panel, $task, $command);
	}
	else if ($task == "partitionMembership")
	{
		setMembershipEditorMenuCommand($panel, $task, $command);
	}
	else if ($task == "displayLayers")
	{
		displayLayerEditorMenuCommand( $panel, $task, $command );
	}
	else if ($task == "renderPassSetEd")
	{
		renderPassSetEditorMenuCommand($panel, $task, $command);
	}
	else if ($task == "renderLayers")
	{
		renderLayerEditorMenuCommand( $panel, $task, $command );
	}
	else if ($task == "animLayers")
	{
		animLayerEditorMenuCommand( $panel, $task, $command );
	}
	else if (
		($task == "lightCentricLightLinking") ||
		($task == "objectCentricLightLinking"))
	{
		lightLinkingEditorMenuCommand($panel, $task, $command);
	}
	else if ($task == "hairUVLinking")
	{
		uvHairLinkingEditorMenuCommand($panel, $task, $command);
	}
	else if ($task == "furUVLinking")
	{
		uvFurLinkingEditorMenuCommand($panel, $task, $command);
	}
	else if ($task == "hairFurLinking")
	{
		hairFurLinkingEditorMenuCommand($panel, $task, $command);
	}
	else if ($task == "pfxUVLinking")
	{
		uvPfxLinkingEditorMenuCommand($panel, $task, $command);
	}
	else if ($task == "characterMembership")
	{
		setMembershipEditorMenuCommand($panel, $task, $command);
	}
	else if (
		($task == "uvCentricUvLinking") || 
		($task == "textureCentricUvLinking"))
	{
		uvLinkingEditorMenuCommand($panel, $task, $command);
	}
	else if ($task == "cameraSets")
	{
		cameraSetEditorMenuCommand($panel, $task, $command);
	}
}

proc configureOptionsMenu(
	string $panel, 
	string $task)
//
// Description:
//	This procedure is called after the current task changes.
//	This procedure configures the Options menu at the top of the relationship 
//	editor according to the current task.
//
//	If you are implementing a new task, you will want to add code to this
//	procedure to configure the top menu as appropriate for your task.
//
{
	string $topLayout = `panel -query -control $panel`;

	setParent $topLayout;

	menu
		-edit
		-deleteAllItems
		optionsMenu;

	setParent -menu optionsMenu;


	// Fill the Options menu with items appropriate for this task
	//
	
	string $autoExpandFrames = (uiRes("m_relationshipEditor.kAutoExpandFrames"));
	if ($task == "setMembership")
	{
		menuItem
			-label			$autoExpandFrames
			-checkBox		false
			-annotation (uiRes("m_relationshipEditor.kSetMembershipOptionsAnnot"))
			-command
				("relationshipEditorMenuCommand "
					+ $panel
					+ " "
					+ $task
					+ " "
					+ "leftOptionsMenuAutoExpand")
			leftOptionsMenuAutoExpandItem;
	}
	else if ( $task == "deformerSetEd" )
	{
		menuItem
			-label			$autoExpandFrames
			-checkBox		false
			-annotation (uiRes("m_relationshipEditor.kDeformerSetOptionsAnnot"))
			-command
				("relationshipEditorMenuCommand "
					+ $panel
					+ " "
					+ $task
					+ " "
					+ "leftOptionsMenuAutoExpand")
			leftOptionsMenuAutoExpandItem;
	}
	else if ($task == "partitionMembership")
	{
		menuItem
			-label			$autoExpandFrames
			-checkBox		false
			-annotation (uiRes("m_relationshipEditor.kPartitionsOptionsAnnot"))
			-command
				("relationshipEditorMenuCommand "
					+ $panel
					+ " "
					+ $task
					+ " "
					+ "leftOptionsMenuAutoExpand")
			leftOptionsMenuAutoExpandItem;
	}
	else if ($task == "characterMembership")
	{
		menuItem
			-label			$autoExpandFrames
			-checkBox		false
			-annotation (uiRes("m_relationshipEditor.kCharacterMembershipOptionsAnnot"))
			-command
				("relationshipEditorMenuCommand "
					+ $panel
					+ " "
					+ $task
					+ " "
					+ "leftOptionsMenuAutoExpand")
			leftOptionsMenuAutoExpandItem;
	}
	else
	{
		menuItem 
			-label 			(uiRes("m_relationshipEditor.kNoOptions"))
			-enable			false
			optionsNoOptionsForThisTaskItem;
	}

	setParent -menu ..;
}

global proc relationshipEditorRefreshMenu(
	string $panel,
	string $task,
	string $menu)
{
	if ($menu == "leftListMenu")
	{
		refreshLeftListMenu($panel, $task);
	}
	else if ($menu == "rightListMenu")
	{
		refreshRightListMenu($panel, $task);
	}
}

proc configureLeftListMenu(
	string $panel, 
	string $task)
//
// Description:
//	This procedure is called after the current task changes.
//	This procedure configures the List menu at the top of the outliner on the 
//	left side of the relationship editor according to the current task.
//
//	If you are implementing a new task, you will want to add code to this
//	procedure to configure the left menu as appropriate for your task.
//
{
	string $topLayout = `panel -query -control $panel`;

	setParent $topLayout;

	menu 
		-edit 
		-deleteAllItems 
		leftListMenu;

	// Create a radio menu item collection for the list menu because the
	// previous one would have been deleted by the -deleteAllItems above.
	//
	radioMenuItemCollection 
		-parent 		"leftListMenu"
		leftListCollection;

	// Add items to the list menu.
	// Initially these menu items will be given default labels, which
	// can be overwritten by more task specific labels.
	//
	setParent -menu leftListMenu;

	menuItem
		-label			(uiRes("m_relationshipEditor.kAutoLoadLeft"))
		-radioButton	false
		-collection		"leftListCollection"
		-command ("relationshipEditorMenuCommand "
				+ $panel
				+ " "
				+ $task
				+ " "
				+ "leftListMenuAutoLoadAll")
		leftListMenuAutoLoadAllItem;

	menuItem
		-label			(uiRes("m_relationshipEditor.kManualLoadLeft"))
		-radioButton	false
		-collection		"leftListCollection"
		-command ("relationshipEditorMenuCommand "
				+ $panel
				+ " "
				+ $task
				+ " "
				+ "leftListMenuManualLoad")
		leftListMenuManualLoadItem;

	menuItem -divider true;

	menuItem
		-label			(uiRes("m_relationshipEditor.kLoadSelectionLeft"))
		-enable			false
		-command ("relationshipEditorMenuCommand "
				+ $panel
				+ " "
				+ $task
				+ " "
				+ "leftListMenuLoadListFromSelection")
		leftListMenuLoadListFromSelectionItem;

	menuItem
		-label			(uiRes("m_relationshipEditor.kAddSelectionLeft"))
		-enable			false
		-command ("relationshipEditorMenuCommand "
				+ $panel
				+ " "
				+ $task
				+ " "
				+ "leftListMenuAddSelectionToList")
		leftListMenuAddSelectionToListItem;

	menuItem
		-label			(uiRes("m_relationshipEditor.kRemoveSelectionLeft"))
		-enable			false
		-command ("relationshipEditorMenuCommand "
				+ $panel
				+ " "
				+ $task
				+ " "
				+ "leftListMenuRemoveSelectionFromList")
		leftListMenuRemoveSelectionFromListItem;

	// Modify the names of the above menu items to be task specific, if
	// appropriate.
	//
	if ( $task == "setMembership" )
	{
		menuItem
			-edit
			 -label (uiRes("m_relationshipEditor.kAutoLoadSets"))
			-annotation (uiRes("m_relationshipEditor.kAutoLoadSetsAnnot"))
			leftListMenuAutoLoadAllItem;
		menuItem
			-edit
			 -label (uiRes("m_relationshipEditor.kManualLoadSets"))
			-annotation (uiRes("m_relationshipEditor.kManualLoadSetsAnnot"))
			leftListMenuManualLoadItem;
		menuItem
			-edit
			 -label (uiRes("m_relationshipEditor.kLoadSetSelection"))
			-annotation (uiRes("m_relationshipEditor.kLoadSetSelectionAnnot"))
			leftListMenuLoadListFromSelectionItem;
		menuItem
			-edit 
			-label (uiRes("m_relationshipEditor.kAddSetSelection"))
			-annotation (uiRes("m_relationshipEditor.kAddSetSelectionAnnot"))
			leftListMenuAddSelectionToListItem;
		menuItem
			-edit 
			-label (uiRes("m_relationshipEditor.kRemoveSetSelection"))
			-annotation (uiRes("m_relationshipEditor.kRemoveSetSelectionAnnot"))
			leftListMenuRemoveSelectionFromListItem;
	}
	else if ( $task == "deformerSetEd" )
	{
		menuItem
			-edit
			 -label (uiRes("m_relationshipEditor.kAutoLoadDeformerSets"))
			-annotation (uiRes("m_relationshipEditor.kAutoLoadDeformerSetsAnnot"))
			leftListMenuAutoLoadAllItem;
		menuItem
			-edit
			 -label (uiRes("m_relationshipEditor.kManualLoadDeformerSets"))
			-annotation (uiRes("m_relationshipEditor.kManualLoadDeformerSetsAnnot"))
			leftListMenuManualLoadItem;
		menuItem
			-edit
			 -label (uiRes("m_relationshipEditor.kLoadDeformerSetSelection"))
			-annotation (uiRes("m_relationshipEditor.kLoadDeformerSetSelectionAnnot"))
			leftListMenuLoadListFromSelectionItem;
		menuItem
			-edit 
			-label (uiRes("m_relationshipEditor.kAddDeformerSetSelection"))
			-annotation (uiRes("m_relationshipEditor.kAddDeformerSetSelectionAnnot"))
			leftListMenuAddSelectionToListItem;
		menuItem
			-edit 
			-label (uiRes("m_relationshipEditor.kRemoveDeformerSetSelection"))
			-annotation (uiRes("m_relationshipEditor.kRemoveDeformerSetSelectionAnnot"))
			leftListMenuRemoveSelectionFromListItem;
	}
	else if ( $task == "partitionMembership" )
	{
		menuItem
			-edit
			 -label (uiRes("m_relationshipEditor.kAutoLoadPartitions"))
			-annotation (uiRes("m_relationshipEditor.kAutoLoadPartitionsAnnot"))
			leftListMenuAutoLoadAllItem;
		menuItem
			-edit
			 -label (uiRes("m_relationshipEditor.kManualLoadPartitions"))
			-annotation (uiRes("m_relationshipEditor.kManualLoadPartitionsAnnot"))
			leftListMenuManualLoadItem;
		menuItem
			-edit
			 -label (uiRes("m_relationshipEditor.kLoadPartitionSelection"))
			-annotation (uiRes("m_relationshipEditor.kLoadPartitionSelectionAnnot"))
			leftListMenuLoadListFromSelectionItem;
		menuItem
			-edit 
			-label (uiRes("m_relationshipEditor.kAddPartitionSelection"))
			-annotation (uiRes("m_relationshipEditor.kAddPartitionSelectionAnnot"))
			leftListMenuAddSelectionToListItem;
		menuItem
			-edit 
			-label (uiRes("m_relationshipEditor.kRemovePartitionSelection"))
			-annotation (uiRes("m_relationshipEditor.kRemovePartitionSelectionAnnot"))
			leftListMenuRemoveSelectionFromListItem;
	}
	else if ( $task == "characterMembership" )
	{
		menuItem
			-edit
			 -label (uiRes("m_relationshipEditor.kAutoLoadCharacterSets"))
			-annotation (uiRes("m_relationshipEditor.kAutoLoadCharacterSetsAnnot"))
			leftListMenuAutoLoadAllItem;
		menuItem
			-edit
			 -label (uiRes("m_relationshipEditor.kManualLoadCharacterSets"))
			-annotation (uiRes("m_relationshipEditor.kManualLoadCharacterSetsAnnot"))
			leftListMenuManualLoadItem;
		menuItem
			-edit
			 -label (uiRes("m_relationshipEditor.kLoadCharacterSetsSelection"))
			-annotation (uiRes("m_relationshipEditor.kLoadCharacterSetsSelectionAnnot"))
			leftListMenuLoadListFromSelectionItem;
		menuItem
			-edit 
			-label (uiRes("m_relationshipEditor.kAddCharacterSetsSelection"))
			-annotation (uiRes("m_relationshipEditor.kAddCharacterSetsSelectionAnnot"))
			leftListMenuAddSelectionToListItem;
		menuItem
			-edit 
			-label (uiRes("m_relationshipEditor.kRemoveCharacterSetsSelection"))
			-annotation (uiRes("m_relationshipEditor.kRemoveCharacterSetsSelectionAnnot"))
			leftListMenuRemoveSelectionFromListItem;
	}
	else if ( $task == "displayLayers" )
	{
		menuItem
			-edit
			 -label (uiRes("m_relationshipEditor.kAutoLoadDisplayLayers"))
			-annotation (uiRes("m_relationshipEditor.kAutoLoadDisplayLayersAnnot"))
			leftListMenuAutoLoadAllItem;
		menuItem
			-edit
			 -label (uiRes("m_relationshipEditor.kManualLoadDisplayLayers"))
			-annotation (uiRes("m_relationshipEditor.kManualLoadDisplayLayersAnnot"))
			leftListMenuManualLoadItem;
		menuItem
			-edit
			 -label (uiRes("m_relationshipEditor.kLoadDisplayLayersSelection"))
			-annotation (uiRes("m_relationshipEditor.kLoadDisplayLayersSelectionAnnot"))
			leftListMenuLoadListFromSelectionItem;
		menuItem
			-edit
			-label (uiRes("m_relationshipEditor.kAddDisplayLayersSelection"))
			-annotation (uiRes("m_relationshipEditor.kAddDisplayLayersSelectionAnnot"))
			leftListMenuAddSelectionToListItem;
		menuItem
			-edit
			-label (uiRes("m_relationshipEditor.kRemoveDisplayLayersSelection"))
			-annotation (uiRes("m_relationshipEditor.kRemoveDisplayLayersSelectionAnnot"))
			leftListMenuRemoveSelectionFromListItem;
	}
	else if ( $task == "renderLayers" )
	{
		menuItem
			-edit
			 -label (uiRes("m_relationshipEditor.kAutoLoadRenderLayers"))
			-annotation (uiRes("m_relationshipEditor.kAutoLoadRenderLayersAnnot"))
			leftListMenuAutoLoadAllItem;
		menuItem
			-edit
			 -label (uiRes("m_relationshipEditor.kManualLoadRenderLayers"))
			-annotation (uiRes("m_relationshipEditor.kManualLoadRenderLayersAnnot"))
			leftListMenuManualLoadItem;
		menuItem
			-edit
			 -label (uiRes("m_relationshipEditor.kLoadRenderLayersSelection"))
			-annotation (uiRes("m_relationshipEditor.kLoadRenderLayersSelectionAnnot"))
			leftListMenuLoadListFromSelectionItem;
		menuItem
			-edit
			-label (uiRes("m_relationshipEditor.kAddRenderLayersSelection"))
			-annotation (uiRes("m_relationshipEditor.kAddRenderLayersSelectionAnnot"))
			leftListMenuAddSelectionToListItem;
		menuItem
			-edit 
			-label (uiRes("m_relationshipEditor.kRemoveRenderLayersSelection"))
			-annotation (uiRes("m_relationshipEditor.kRemoveRenderLayersSelectionAnnot"))
			leftListMenuRemoveSelectionFromListItem;
	}
	else if ( $task == "renderPassSetEd" )
	{
		menuItem
			-edit
			 -label (uiRes("m_relationshipEditor.kAutoLoadRenderPassSets"))
			-annotation (uiRes("m_relationshipEditor.kAutoLoadRenderPassSetsAnnot"))
			leftListMenuAutoLoadAllItem;
		menuItem
			-edit
			 -label (uiRes("m_relationshipEditor.kManualLoadRenderPassSets"))
			-annotation (uiRes("m_relationshipEditor.kManualLoadRenderPassSetsAnnot"))
			leftListMenuManualLoadItem;
		menuItem
			-edit
			 -label (uiRes("m_relationshipEditor.kLoadRenderPassSetSelection"))
			-annotation (uiRes("m_relationshipEditor.kLoadRenderPassSetSelectionAnnot"))
			leftListMenuLoadListFromSelectionItem;
		menuItem
			-edit 
			-label (uiRes("m_relationshipEditor.kAddRenderPassSetSelection"))
			-annotation (uiRes("m_relationshipEditor.kAddRenderPassSetSelectionAnnot"))
			leftListMenuAddSelectionToListItem;
		menuItem
			-edit 
			-label (uiRes("m_relationshipEditor.kRemoveRenderPassSetSelection"))
			-annotation (uiRes("m_relationshipEditor.kRemoveRenderPassSetSelectionAnnot"))
			leftListMenuRemoveSelectionFromListItem;
	}
	else if ( $task == "animLayers" )
	{
		menuItem
			-edit
			 -label (uiRes("m_relationshipEditor.kAutoLoadAnimLayers"))
			-annotation (uiRes("m_relationshipEditor.kAutoLoadAnimLayersAnnot"))
			leftListMenuAutoLoadAllItem;
		menuItem
			-edit
			 -label (uiRes("m_relationshipEditor.kManualLoadAnimLayers"))
			-annotation (uiRes("m_relationshipEditor.kManualLoadAnimLayersAnnot"))
			leftListMenuManualLoadItem;
		menuItem
			-edit
			 -label (uiRes("m_relationshipEditor.kLoadAnimLayersSelection"))
			-annotation (uiRes("m_relationshipEditor.kLoadAnimLayersSelectionAnnot"))
			leftListMenuLoadListFromSelectionItem;
		menuItem
			-edit
			-label (uiRes("m_relationshipEditor.kAddAnimLayersSelection"))
			-annotation (uiRes("m_relationshipEditor.kAddAnimLayersSelectionAnnot"))
			leftListMenuAddSelectionToListItem;
		menuItem
			-edit 
			-label (uiRes("m_relationshipEditor.kRemoveAnimLayersSelection"))
			-annotation (uiRes("m_relationshipEditor.kRemoveAnimLayersSelectionAnnot"))
			leftListMenuRemoveSelectionFromListItem;
	}

	// Select the menu item which should be selected by default, according
	// to the current task.
	//
	if ($task == "lightCentricLightLinking")
	{
		menuItem
			-edit
			-radioButton	true
			leftListMenuAutoLoadAllItem;
	}
	else if ($task == "objectCentricLightLinking")
	{
		menuItem
			-edit
			-radioButton	true
			leftListMenuAutoLoadAllItem;
	}
	else
	if ($task == "setMembership")
	{
		menuItem
			-edit
			-radioButton	true
			leftListMenuAutoLoadAllItem;
	}
	else if ($task == "displayLayers")
	{
		menuItem
			-edit
			-radioButton	true
			leftListMenuAutoLoadAllItem;
	}
	else if ($task == "renderLayers")
	{
		menuItem
			-edit
			-radioButton	true
			leftListMenuAutoLoadAllItem;
	}
	else if ($task == "renderPassSetEd")
	{
		menuItem
			-edit
			-radioButton	true
			leftListMenuAutoLoadAllItem;
	}
	else if ($task == "animLayers")
	{
		menuItem
			-edit
			-radioButton	true
			leftListMenuAutoLoadAllItem;
	}	
	else if ($task == "partitionMembership")
	{
		menuItem
			-edit
			-radioButton	true
			leftListMenuAutoLoadAllItem;
	}
	else if ($task == "characterMembership")
	{
		menuItem
			-edit
			-radioButton	true
			leftListMenuAutoLoadAllItem;
	}
	else if (($task == "eventCentricInteraction") ||
		     ($task == "actionCentricInteraction") ||
		     ($task == "touchSensorAssociation"))
	{
		menuItem
			-edit
			-radioButton	true
			leftListMenuAutoLoadAllItem;
	}
	setParent -menu ..;

	relationshipEditorRefreshMenu($panel, $task, "leftListMenu");
}

proc configureLeftEditMenu(
	string $panel, 
	string $task)
//
// Description:
//	This procedure is called after the current task changes.
//	This procedure configures the Edit menu at the top of the outliner on the 
//	left side of the relationship editor according to the current task.
//
//	If you are implementing a new task, you will want to add code to this
//	procedure to configure the left menu as appropriate for your task.
//
{
	string $topLayout = `panel -query -control $panel`;
	string $attrEditorMenuItemName = `format -s (localizedUIComponentLabel("Attribute Editor")) (uiRes("m_relationshipEditor.kAttrEditorMenuItemFormat"))`;
	
	setParent $topLayout;

	menu 
		-edit 
		-deleteAllItems 
		leftEditMenu;

	// Add items to the edit menu
	//
	setParent -menu leftEditMenu;

	if( ($task != "uvCentricUvLinking") 
		&& ($task != "furUVLinking") 
		&& ($task != "hairFurLinking") 
		&& ($task != "cameraSets"))
	{
		menuItem
			-label		(uiRes("m_relationshipEditor.kDeleteHighlighted"))
			-command	
				("relationshipEditorMenuCommand "
					+ $panel
					+ " "
					+ $task
					+ " "
					+ "leftEditMenuDeleteHighlighted")
			leftEditMenuDeleteHighlightedItem;
	}

	if ($task == "setMembership" ||
		$task == "displayLayers" ||
		$task == "renderLayers" ||
		$task == "characterMembership" ||
		$task == "deformerSetEd" ||
		$task == "partitionMembership")
	{
		menuItem
			-label		(uiRes("m_relationshipEditor.kRemoveHighlighted"))
			-command	
				("relationshipEditorMenuCommand "
					+ $panel
					+ " "
					+ $task
					+ " "
					+ "leftEditMenuRemoveHighlightedFromSet")
			leftEditMenuRemoveHighlightedFromSetItem;
	}

	if( ($task != "uvCentricUvLinking") && ($task != "cameraSets") )
	{
		menuItem
			-label		(uiRes("m_relationshipEditor.kSelectHighlighted"))
			-command	
				("relationshipEditorMenuCommand "
					+ $panel
					+ " "
					+ $task
					+ " "
					+ "leftEditMenuSelectHighlighted")
			leftEditMenuSelectHighlightedItem;
	}

	// Add task-specific items to the edit menu and edit the labels of 
	// non-task-specific items if it is good to do so.
	//
	if ($task == "lightCentricLightLinking")
	{
		menuItem -divider true;

		menuItem
			-label		(uiRes("m_relationshipEditor.kHighlightedLightsIlluminatedByDefault"))
			-command 
				("relationshipEditorMenuCommand "
					+ $panel
					+ " "
					+ $task
					+ " "
					+ "makeHighlightedLightsNonExclusive")
			leftEditMenuMakeNonExclusiveItem;

		menuItem
			-label		(uiRes("m_relationshipEditor.kHighlightedLightsNotIlluminatedByDefault"))
			-command 
				("relationshipEditorMenuCommand "
					+ $panel
					+ " "
					+ $task
					+ " "
					+ "makeHighlightedLightsExclusive")
			leftEditMenuMakeExclusiveItem;

		menuItem -divider true;

		menuItem
			-label		(uiRes("m_relationshipEditor.kCreateLightSet"))
			-command 
				("relationshipEditorMenuCommand "
					+ $panel
					+ " "
					+ $task
					+ " "
					+ "createLightSet")
			leftEditMenuCreateSetItem;
	}
	else if ($task == "objectCentricLightLinking")
	{
		menuItem -divider true;

		menuItem
			-label		(uiRes("m_relationshipEditor.kCreateObjectSet"))
			-command 
				("relationshipEditorMenuCommand "
					+ $panel
					+ " "
					+ $task
					+ " "
					+ "createObjectSet")
			leftEditMenuCreateSetItem;
	}
	else
	if ($task == "setMembership")
	{
		menuItem
			-edit
			-annotation (uiRes("m_relationshipEditor.kSetMembershipDeleteHighlightedAnnot"))
			leftEditMenuDeleteHighlightedItem;

		menuItem
			-edit
			-label (uiRes("m_relationshipEditor.kSetMembershipRemoveHighlighted"))
			-annotation (uiRes("m_relationshipEditor.kRemoveHighlightedFromSetAnnot"))
			leftEditMenuRemoveHighlightedFromSetItem;

		menuItem 
			-edit
			-annotation (uiRes("m_relationshipEditor.kSetMembershipSelectHighlightedAnnot"))
			leftEditMenuSelectHighlightedItem;

		menuItem
			-label		(uiRes("m_relationshipEditor.kSelectSetMembers"))
			-annotation (uiRes("m_relationshipEditor.kSelectSetMembersAnnot"))
			-command ("relationshipEditorMenuCommand "
					+ $panel
					+ " "
					+ $task
					+ " "
					+ "leftEditSelectMembersOfHighlighted")
			leftEditSelectMembersOfHighlightedItem;

		menuItem -divider true;

		menuItem -label (uiRes("m_relationshipEditor.kSetMembershipAddSelectedItems"))
			-annotation (uiRes("m_relationshipEditor.kSetMembershipAddSelectedItemsAnnot"))
			-command ("relationshipEditorMenuCommand "
					+ $panel
					+ " "
					+ $task
					+ " "
					+ "leftEditMenuAddToSet")
			leftEditMenuAddToSetItem;

		menuItem -label (uiRes("m_relationshipEditor.kSetMembershipRemoveSelectedItems"))
			-annotation (uiRes("m_relationshipEditor.kSetMembershipRemoveSelectedItemsAnnot"))
			-command ("relationshipEditorMenuCommand "
					+ $panel
					+ " "
					+ $task
					+ " "
					+ "leftEditMenuRemoveFromSet")
			leftEditMenuRemoveFromSetItem;

		menuItem -label (uiRes("m_relationshipEditor.kCreateSet"))
			-annotation (uiRes("m_relationshipEditor.kCreateSetAnnot"))
			-c "performCreateSet false";
		menuItem -optionBox true 
			-label (uiRes("m_relationshipEditor.kCreateSetOptionBox"))
			-c "performCreateSet true";
	}
	else if ($task == "displayLayers")
	{
		menuItem
			-edit
			-annotation (uiRes("m_relationshipEditor.kDisplayLayersDeleteHighlightedAnnot"))
			leftEditMenuDeleteHighlightedItem;

		menuItem
			-edit
			-label (uiRes("m_relationshipEditor.kDisplayLayersRemoveHighlighted"))
			-annotation (uiRes("m_relationshipEditor.kDisplayLayersRemoveHighlightedAnnot"))
			leftEditMenuRemoveHighlightedFromSetItem;

		menuItem 
			-edit
			-annotation (uiRes("m_relationshipEditor.kDisplayLayersSelectHighlightedAnnot"))
			leftEditMenuSelectHighlightedItem;

		menuItem
			-label		(uiRes("m_relationshipEditor.kSelectDisplayLayerMembers"))
			-annotation (uiRes("m_relationshipEditor.kSelectDisplayLayerMembersAnnot"))
			-command ("relationshipEditorMenuCommand "
					+ $panel
					+ " "
					+ $task
					+ " "
					+ "leftEditSelectMembersOfHighlighted")
			leftEditSelectMembersOfHighlightedItem;

		menuItem -divider true;

		menuItem -label (uiRes("m_relationshipEditor.kDisplayLayersAddSelectedItems"))
			-annotation (uiRes("m_relationshipEditor.kDisplayLayersAddSelectedItemsAnnot"))
			-command ("relationshipEditorMenuCommand "
					+ $panel
					+ " "
					+ $task
					+ " "
					+ "leftEditMenuAddToDisplayLayer")
			leftEditMenuAddToDisplayLayerItem;

		menuItem -label (uiRes("m_relationshipEditor.kDisplayLayersRemoveSelectedItems"))
			-annotation (uiRes("m_relationshipEditor.kDisplayLayersRemoveSelectedItemsAnnot"))
			-command ("relationshipEditorMenuCommand "
					+ $panel
					+ " "
					+ $task
					+ " "
					+ "leftEditMenuRemoveFromDisplayLayer")
			leftEditMenuRemoveFromLayerItem;

		menuItem -label (uiRes("m_relationshipEditor.kCreateDisplayLayer"))
			-annotation (uiRes("m_relationshipEditor.kCreateDisplayLayerAnnot"))
			-c "performCreateDisplayLayer false";
	}
	else if ($task == "renderLayers")
	{
		menuItem
			-edit
			-annotation (uiRes("m_relationshipEditor.kRenderLayersDeleteHighlightedAnnot"))
			leftEditMenuDeleteHighlightedItem;

		menuItem
			-edit
			-label (uiRes("m_relationshipEditor.kRenderLayersRemoveHighlighted"))
			-annotation (uiRes("m_relationshipEditor.kRenderLayersRemoveHighlightedAnnot"))
			leftEditMenuRemoveHighlightedFromSetItem;

		menuItem
			-edit
			-annotation (uiRes("m_relationshipEditor.kRenderLayersSelectHighlighted"))
			leftEditMenuSelectHighlightedItem;

		menuItem
			-label		(uiRes("m_relationshipEditor.kSelectRenderLayerMembers"))
			-annotation (uiRes("m_relationshipEditor.kSelectRenderLayerMembersAnnot"))
			-command ("relationshipEditorMenuCommand "
					+ $panel
					+ " "
					+ $task
					+ " "
					+ "leftEditSelectMembersOfHighlighted")
			leftEditSelectMembersOfHighlightedItem;

		menuItem -divider true;

		menuItem -label (uiRes("m_relationshipEditor.kRenderLayersAddSelectedItems"))
			-annotation (uiRes("m_relationshipEditor.kRenderLayersAddSelectedItemsAnnot"))
			-command ("relationshipEditorMenuCommand "
					+ $panel
					+ " "
					+ $task
					+ " "
					+ "leftEditMenuAddToRenderLayer")
			leftEditMenuAddToRenderLayerItem;

		menuItem -label (uiRes("m_relationshipEditor.kRenderLayersRemoveSelectedItems"))
			-annotation (uiRes("m_relationshipEditor.kRenderLayersRemoveSelectedItemsAnnot"))
			-command ("relationshipEditorMenuCommand "
					+ $panel
					+ " "
					+ $task
					+ " "
					+ "leftEditMenuRemoveFromRenderLayer")
			leftEditMenuRemoveFromLayerItem;

		menuItem -label (uiRes("m_relationshipEditor.kCreateRenderLayer"))
			-annotation (uiRes("m_relationshipEditor.kCreateRenderLayerAnnot"))
			-c "performCreateRenderLayer false";
	}
	else if ($task == "renderPassSetEd")
	{
		menuItem
			-edit
			-annotation (uiRes("m_relationshipEditor.kRenderPassSetDeleteHighlightedAnnot"))
			leftEditMenuDeleteHighlightedItem;

		menuItem
			-edit
			-annotation (uiRes("m_relationshipEditor.kRenderPassSetSelectHighlighted"))
			leftEditMenuSelectHighlightedItem;

		menuItem
			-label		(uiRes("m_relationshipEditor.kRenderPassSetSelectMembers"))
			-annotation (uiRes("m_relationshipEditor.kRenderPassSetSelectMembersAnnot"))
			-command ("relationshipEditorMenuCommand "
					+ $panel
					+ " "
					+ $task
					+ " "
					+ "leftEditSelectMembersOfHighlighted")
			leftEditSelectMembersOfHighlightedItem;

		menuItem -divider true;

		menuItem -label (uiRes("m_relationshipEditor.kRenderPassSetAddSelectedItems"))
			-annotation (uiRes("m_relationshipEditor.kRenderPassSetAddSelectedItemsAnnot"))
			-command ("relationshipEditorMenuCommand "
					+ $panel
					+ " "
					+ $task
					+ " "
					+ "leftEditMenuAddToRenderPassSet")
			leftEditMenuAddToSetItem;

		menuItem -label (uiRes("m_relationshipEditor.kRenderPassSetRemoveSelectedItems"))
			-annotation (uiRes("m_relationshipEditor.kRenderPassSetRemoveSelectedItemsAnnot"))
			-command ("relationshipEditorMenuCommand "
					+ $panel
					+ " "
					+ $task
					+ " "
					+ "leftEditMenuRemoveFromRenderPassSet")
			leftEditMenuRemoveFromSetItem;

		menuItem -label (uiRes("m_relationshipEditor.kCreateRenderPassSet"))
			-annotation (uiRes("m_relationshipEditor.kCreateRenderPassSetAnnot"))
			-c ("string $renderPassesSel[] = `ls -sl -type \"renderPass\"`;" + 
				"string $newRenderPassSet = `createNode -ss renderPassSet`;"+ 
				"for($i = 0; $i < size($renderPassesSel); $i++)" +
				"connectAttr -nextAvailable ($newRenderPassSet + \".renderPass\") ($renderPassesSel[$i] + \".owner\");");
	}
	else if ($task == "animLayers")
	{	    
		//FIXME: add any anim layer specific edit menu items here.
		
    }
	else if ($task == "partitionMembership")
	{
		menuItem
			-edit
			-annotation (uiRes("m_relationshipEditor.kPartitionMembershipDeleteHighlightedAnnot"))
			leftEditMenuDeleteHighlightedItem;

		menuItem
			-edit
			-label (uiRes("m_relationshipEditor.kPartitionMembershipRemoveHighlighted"))
			-annotation (uiRes("m_relationshipEditor.kPartitionMembershipRemoveHighlightedAnnot"))
			leftEditMenuRemoveHighlightedFromSetItem;

		menuItem 
			-edit
			-annotation (uiRes("m_relationshipEditor.kPartitionMembershipSelectHighlightedAnnot"))
			leftEditMenuSelectHighlightedItem;

		menuItem
			-label		(uiRes("m_relationshipEditor.kSelectPartitionMembers"))
			-annotation (uiRes("m_relationshipEditor.kSelectPartitionMembersAnnot"))
			-command ("relationshipEditorMenuCommand "
					+ $panel
					+ " "
					+ $task
					+ " "
					+ "leftEditSelectMembersOfHighlighted")
			leftEditSelectMembersOfHighlightedItem;

		menuItem -divider true;

		menuItem -label (uiRes("m_relationshipEditor.kPartitionMembershipAddSelectedItems"))
			-annotation (uiRes("m_relationshipEditor.kPartitionMembershipAddSelectedItemsAnnot"))
			-command ("relationshipEditorMenuCommand "
					+ $panel
					+ " "
					+ $task
					+ " "
					+ "leftEditMenuAddToSet")
			leftEditMenuAddToSetItem;

		menuItem -label (uiRes("m_relationshipEditor.kPartitionMembershipRemoveSelectedItems"))
			-annotation (uiRes("m_relationshipEditor.kPartitionMembershipRemoveSelectedItemsAnnot"))
			-command ("relationshipEditorMenuCommand "
					+ $panel
					+ " "
					+ $task
					+ " "
					+ "leftEditMenuRemoveFromSet")
			leftEditMenuRemoveFromSetItem;

		menuItem -label (uiRes("m_relationshipEditor.kCreatePartition"))
			-annotation (uiRes("m_relationshipEditor.kCreatePartitionAnnot"))
			-c "performCreatePartition false";
		menuItem -optionBox true 
			-label (uiRes("m_relationshipEditor.kCreatePartitionOptionBox"))
			-c "performCreatePartition true";
	}
    else if ($task == "characterMembership")
	{
		menuItem
			-edit
			-label (uiRes("m_relationshipEditor.kCharacterMembershipDeleteHighlighted"))
			-annotation (uiRes("m_relationshipEditor.kCharacterMembershipDeleteHighlightedAnnot"))
			leftEditMenuDeleteHighlightedItem;

		menuItem
			-edit
			-label (uiRes("m_relationshipEditor.kCharacterMembershipRemoveHighlighted"))
			-annotation (uiRes("m_relationshipEditor.kCharacterMembershipRemoveHighlightedAnnot"))
			leftEditMenuRemoveHighlightedFromSetItem;

		menuItem -divider true;
		
		menuItem 
			-edit
			-label (uiRes("m_relationshipEditor.kCharacterMembershipSelectCharacterSet"))
			-annotation (uiRes("m_relationshipEditor.kCharacterMembershipSelectCharacterSetAnnot"))
			leftEditMenuSelectHighlightedItem;

		menuItem
			-label		(uiRes("m_relationshipEditor.kSelectCharacterSetMembers"))
			-annotation (uiRes("m_relationshipEditor.kSelectCharacterSetMembersAnnot"))
			-command ("relationshipEditorMenuCommand "
					+ $panel
					+ " "
					+ $task
					+ " "
					+ "leftEditSelectMembersOfHighlighted")
			leftEditSelectMembersOfHighlightedItem;

		menuItem -divider true;

		menuItem -label (uiRes("m_relationshipEditor.kAddObjectsToCharacterSet"))
			-annotation (uiRes("m_relationshipEditor.kAddObjectsToCharacterSetAnnot"))
			-command ("relationshipEditorMenuCommand "
					+ $panel
					+ " "
					+ $task
					+ " "
					+ "leftEditMenuAddToSet")
			leftEditMenuAddToSetItem;

		menuItem -label (uiRes("m_relationshipEditor.kRemoveObjectsFromCharacterSet"))
			-annotation (uiRes("m_relationshipEditor.kRemoveObjectsFromCharacterSetAnnot"))
			-command ("relationshipEditorMenuCommand "
					+ $panel
					+ " "
					+ $task
					+ " "
					+ "leftEditMenuRemoveFromSet")
			leftEditMenuRemoveFromSetItem;

		menuItem -label (uiRes("m_relationshipEditor.kCreateCharacterSet"))
			-annotation (uiRes("m_relationshipEditor.kCreateCharacterSetAnnot"))
			-c "performCreateCharacter 0";
		menuItem -optionBox true 
			-label (uiRes("m_relationshipEditor.kCreateCharacterSetOptionBox"))
			-c "performCreateCharacter 1";

		// Add extra menu items for editing the current character list
		//
		menuItem -d true;
	
		menuItem
			-label			(uiRes("m_relationshipEditor.kHighlightCurrentCharacterSets"))
			-command ("relationshipEditorMenuCommand "
					+ $panel
					+ " "
					+ $task
					+ " "
					+ "leftEditMenuHighlightCurrentCharacters")
			leftEditMenuHighlightCurrentCharactersItem;

		menuItem
			-label			(uiRes("m_relationshipEditor.kMakeHighlightedCharacterSetsCurrent"))
			-command ("relationshipEditorMenuCommand "
					+ $panel
					+ " "
					+ $task
					+ " "
					+ "leftEditMenuMakeHighlightedCharactersCurrent")
			leftEditMenuMakeHighlightedCharacterCurrentItem;
	}
	else if ($task == "deformerSetEd")
	{
		menuItem
			-edit
			-annotation (uiRes("m_relationshipEditor.kDeformerSetDeleteHighlightedAnnot"))
			leftEditMenuDeleteHighlightedItem;

		menuItem
			-edit
			-label (uiRes("m_relationshipEditor.kDeformerSetRemoveHighlighted"))
			-annotation (uiRes("m_relationshipEditor.kDeformerSetRemoveHighlightedAnnot"))
			leftEditMenuRemoveHighlightedFromSetItem;

		menuItem 
			-edit
			-annotation (uiRes("m_relationshipEditor.kDeformerSetSelectHighlightedAnnot"))
			leftEditMenuSelectHighlightedItem;

		menuItem
			-label		(uiRes("m_relationshipEditor.kDeformerSetSelectMembers"))
			-annotation (uiRes("m_relationshipEditor.kDeformerSetSelectMembersAnnot"))
			-command ("relationshipEditorMenuCommand "
					+ $panel
					+ " "
					+ $task
					+ " "
					+ "leftEditSelectMembersOfHighlighted")
			leftEditSelectMembersOfHighlightedItem;

		menuItem -divider true;

		menuItem -label (uiRes("m_relationshipEditor.kDeformerSetAddSelectedItems"))
			-annotation (uiRes("m_relationshipEditor.kDeformerSetAddSelectedItemsAnnot"))
			-command ("relationshipEditorMenuCommand "
					+ $panel
					+ " "
					+ $task
					+ " "
					+ "leftEditMenuAddToSet")
			leftEditMenuAddToSetItem;

		menuItem -label (uiRes("m_relationshipEditor.kDeformerSetRemoveSelectedItems"))
			-annotation (uiRes("m_relationshipEditor.kDeformerSetRemoveSelectedItemsAnnot"))
			-command ("relationshipEditorMenuCommand "
					+ $panel
					+ " "
					+ $task
					+ " "
					+ "leftEditMenuRemoveFromSet")
			leftEditMenuRemoveFromSetItem;
	}
	else if ($task == "uvCentricUvLinking")
	{
		string $menuItemLabel = (uiRes("m_relationshipEditor.kCreateUVSet"));
		string $textItem=`menuItem -label $menuItemLabel -sm 1 -to 1 -aob true leftEditMenuCreateUvSetItem`;
			PolyTextureMenu $textItem 1 ("selectionConnection -query -object " + $panel + "LeftMainList");
			setParent -m ..;
		menuItem 
			-label (uiRes("m_relationshipEditor.kRemoveUVSet"))
			-annotation 
				(uiRes("m_relationshipEditor.kRemoveUVSetAnnot"))
			-command ("relationshipEditorMenuCommand "
					+ $panel
					+ " "
					+ $task
					+ " "
					+ "leftEditRemoveUvSet")
			leftEditMenuRemoveUvSetItem;
		menuItem 
			-label (uiRes("m_relationshipEditor.kRenameUVSet"))
			-annotation 
				(uiRes("m_relationshipEditor.kRenameUVSetAnnot"))
			-command ("relationshipEditorMenuCommand "
					+ $panel
					+ " "
					+ $task
					+ " "
					+ "leftEditRenameUvSet")
			leftEditMenuRenameUvSetItem;
	}
	else if ($task == "textureCentricUvLinking")
	{
		menuItem
			-label (uiRes("m_relationshipEditor.kIgnoreTexture"))
			-annotation
				(uiRes("m_relationshipEditor.kIgnoreTextureAnnot"))
			-command ("relationshipEditorMenuCommand "
					+ $panel
					+ " "
					+ $task
					+ " "
					+ "leftEditIgnoreTexture")
			leftEditMenuIgnoreTextureItem;
		menuItem
			-label (uiRes("m_relationshipEditor.kUseTextureWhenRendering"))
			-annotation
				(uiRes("m_relationshipEditor.kUseTextureWhenRenderingAnnot"))
			-command ("relationshipEditorMenuCommand "
					+ $panel
					+ " "
					+ $task
					+ " "
					+ "leftEditUnignoreTexture")
			leftEditMenuUnignoreTextureItem;
		menuItem
			-label (uiRes("m_relationshipEditor.kIsolateTexture"))
			-annotation
				(uiRes("m_relationshipEditor.kIsolateTextureAnnot"))
			-command ("relationshipEditorMenuCommand "
					+ $panel
					+ " "
					+ $task
					+ " "
					+ "leftEditIsolateTexture")
			leftEditMenuIsolateTextureItem;
		menuItem
			-label (uiRes("m_relationshipEditor.kUseAllTextures"))
			-annotation
				(uiRes("m_relationshipEditor.kUseAllTexturesAnnot"))
			-command ("relationshipEditorMenuCommand "
					+ $panel
					+ " "
					+ $task
					+ " "
					+ "leftEditUnignoreAllTextures")
			leftEditMenuUnignoreAllTexturesItem;
			
		menuItem
			-label $attrEditorMenuItemName
			-annotation
				(uiRes("m_relationshipEditor.kTextureCentricUvLinkingAttributeEditorAnnot"))
			-command ("relationshipEditorMenuCommand "
					+ $panel
					+ " "
					+ $task
					+ " "
					+ "leftEditAttributeEditor")
			leftEditMenuAttributeEditorItem;
	}
    else if (($task == "eventCentricInteraction") ||
			 ($task == "actionCentricInteraction"))
	{
		menuItem
			-edit
			-label (uiRes("m_relationshipEditor.kActionEventInteractionDeleteHighlighted"))
			-annotation (uiRes("m_relationshipEditor.kActionEventInteractionDeleteHighlightedAnnot"))
			leftEditMenuDeleteHighlightedItem;

		menuItem -divider true;
		
		menuItem 
			-edit
			-label (uiRes("m_relationshipEditor.kActionEventInteractionSelectNode"))
			-annotation (uiRes("m_relationshipEditor.kActionEventInteractionSelectNodeAnnot"))
			leftEditMenuSelectHighlightedItem;
	}
    else if ($task == "touchSensorInteraction")
	{
		menuItem
			-edit
			-label (uiRes("m_relationshipEditor.kTouchSensorInteractionDeleteHighlighted"))
			-annotation (uiRes("m_relationshipEditor.kTouchSensorInteractionDeleteHighlightedAnnot"))
			leftEditMenuDeleteHighlightedItem;

		menuItem -divider true;
		
		menuItem 
			-edit
			-label (uiRes("m_relationshipEditor.kSelectNode"))
			-annotation (uiRes("m_relationshipEditor.kSelectHighlightObj"))
			leftEditMenuSelectHighlightedItem;
	}
	else if ($task == "furUVLinking")
	{
		menuItem
			-label (uiRes("m_relationshipEditor.kCreateUnattachedFur"))
			-annotation
				(uiRes("m_relationshipEditor.kCreateUnattachedFurAnnot"))
			-command ("HfPerformCreateHD 0");
		
		menuItem
			-label (uiRes("m_relationshipEditor.kDuplicateAllHighlightedFur"))
			-annotation
				(uiRes("m_relationshipEditor.kDuplicateAllHighlightedFurAnnot"))
			-command ("relationshipEditorMenuCommand "
					+ $panel
					+ " "
					+ $task
					+ " "
					+ "leftEditDuplicateFur");

		menuItem
			-label (uiRes("m_relationshipEditor.kDeleteAllHighlightedFur"))
			-annotation
				(uiRes("m_relationshipEditor.kDeleteAllHighlightedFurAnnot"))
			-command ("relationshipEditorMenuCommand "
					+ $panel
					+ " "
					+ $task
					+ " "
					+ "leftEditDeleteFur");

		menuItem
			-label $attrEditorMenuItemName
			-annotation
				(uiRes("m_relationshipEditor.kFurUVLinkingAttributeEditorAnnot"))
			-command ("relationshipEditorMenuCommand "
					+ $panel
					+ " "
					+ $task
					+ " "
					+ "leftEditAttributeEditor");
	}
	else if ($task == "hairFurLinking")
	{
		menuItem
			-label (uiRes("m_relationshipEditor.kCreateHair"))
			-annotation
				(uiRes("m_relationshipEditor.kCreateHairAnnot"))
			-command ("CreateHairOptions");
		
		menuItem
			-label $attrEditorMenuItemName
			-annotation
				(uiRes("m_relationshipEditor.kHairFurLinkingAttributeEditorAnnot"))
			-command ("relationshipEditorMenuCommand "
					+ $panel
					+ " "
					+ $task
					+ " "
					+ "leftEditAttributeEditor");
	}
	else if ($task == "cameraSets")
	{
		menuItem
			-label		(uiRes("m_relationshipEditor.kDeleteHighlightedCameraSet"))
			-enable false
			-command	
				("relationshipEditorMenuCommand "
					+ $panel
					+ " "
					+ $task
					+ " "
					+ "leftEditMenuDeleteHighlightedCameraSet")
			leftEditMenuDeleteHighlightedCameraSetItem;

		menuItem
			-label		(uiRes("m_relationshipEditor.kSelectHighlightedCameraSet"))
			-enable false
			-command	
				("relationshipEditorMenuCommand "
					+ $panel
					+ " "
					+ $task
					+ " "
					+ "leftEditMenuSelectHighlighted")
			leftEditMenuSelectHighlightedCameraSetItem;

		menuItem
			-label		(uiRes("m_relationshipEditor.kDeleteHighlightedCameraLayer"))
			-enable false
			-command	
				("relationshipEditorMenuCommand "
					+ $panel
					+ " "
					+ $task
					+ " "
					+ "leftEditMenuDeleteHighlightedCameraLayer")
			leftEditMenuDeleteHighlightedCameraLayerItem;

		menuItem -divider true;

		menuItem -label (uiRes("m_relationshipEditor.kCreateCameraSet"))
			-annotation (uiRes("m_relationshipEditor.kCreateCameraSetAnnot"))
			-c "performCreateCameraSet false";
		menuItem -optionBox true 
			-label (uiRes("m_relationshipEditor.kCreateCameraSetOptionBox"))
			-c "performCreateCameraSet true";
		menuItem -label (uiRes("m_relationshipEditor.kCreateCameraLayer")) -enable false
			-annotation (uiRes("m_relationshipEditor.kCreateCameraLayerAnnot"))
			-command	
				("relationshipEditorMenuCommand "
					+ $panel
					+ " "
					+ $task
					+ " "
					+ "leftEditMenuCreateCameraLayer")
			leftEditMenuCreateCameraLayer;
	}

	setParent -menu ..;
}

proc configureRightListMenu(
	string $panel, 
	string $task)
//
// Description:
//	This procedure is called after the current task changes.
//	This procedure configures the menu at the top of the outliner on the right
//	side of the relationship editor according to the current task.
//
//	If you are implementing a new task, you will want to add code to this
//	procedure to configure the right menu as appropriate for your task.
//
{
	string $topLayout = `panel -query -control $panel`;

	setParent $topLayout;

	menu
		-edit
		-deleteAllItems
		rightListMenu;

	// Create a radio menu item collection for the list menu because the
	// previous one would have been deleted by the -deleteAllItems above.
	//
	radioMenuItemCollection 
		-parent 		"rightListMenu"
		rightListCollection;

	// add items to the list menu
	//
	setParent -menu rightListMenu;

	menuItem -label (uiRes("m_relationshipEditor.kAutoLoadAllRight"))
		-annotation (uiRes("m_relationshipEditor.kAutoLoadAllRightAnnot"))
		-radioButton	false
		-collection		"rightListCollection"
		-command ("relationshipEditorMenuCommand "
				+ $panel
				+ " "
				+ $task
				+ " "
				+ "rightListMenuAutoLoadAll")
		rightListMenuAutoLoadAllItem;

	menuItem -label (uiRes("m_relationshipEditor.kAutoLoadSelectionRight"))
		-radioButton	false
		-collection		"rightListCollection"
		-command ("relationshipEditorMenuCommand "
				+ $panel
				+ " "
				+ $task
				+ " "
				+ "rightListMenuAutoLoadSelection")
		rightListMenuAutoLoadSelectionItem;

	menuItem -label (uiRes("m_relationshipEditor.kManualLoadRight"))
		-annotation (uiRes("m_relationshipEditor.kManualLoadRightAnnot"))
		-radioButton	false
		-collection		"rightListCollection"
		-command ("relationshipEditorMenuCommand "
				+ $panel
				+ " "
				+ $task
				+ " "
				+ "rightListMenuManualLoad")
		rightListMenuManualLoadItem;

	menuItem -d true;

	menuItem -label (uiRes("m_relationshipEditor.kLoadSelectionRight"))
		-enable			false
		-annotation (uiRes("m_relationshipEditor.kLoadSelectionRightAnnot"))
		-command ("relationshipEditorMenuCommand "
				+ $panel
				+ " "
				+ $task
				+ " "
				+ "rightListMenuLoadListFromSelection")
		rightListMenuLoadListFromSelectionItem;

	menuItem -label (uiRes("m_relationshipEditor.kAddSelectionRight"))
		-enable			false
		-annotation (uiRes("m_relationshipEditor.kAddSelectionRightAnnot"))
		-command ("relationshipEditorMenuCommand "
				+ $panel
				+ " "
				+ $task
				+ " "
				+ "rightListMenuAddSelectionToList")
		rightListMenuAddSelectionToListItem;

	menuItem -label (uiRes("m_relationshipEditor.kRemoveSelectionRight"))
		-enable			false
		-annotation (uiRes("m_relationshipEditor.kRemoveSelectionRightAnnot"))
		-command ("relationshipEditorMenuCommand "
				+ $panel
				+ " "
				+ $task
				+ " "
				+ "rightListMenuRemoveSelectionFromList")
		rightListMenuRemoveSelectionFromListItem;

	setParent -menu ..;

	// NOTE: this is now in addRelationshipPanel
	// show the filter UI menu items
	//
//	string $filterUIMenu = filterUIGetMenu( ($panel + "RightOutliner") );
//	if ( size($filterUIMenu) == 0 )
//	{
//		filterUICreateMenu( ($panel + "RightOutliner"), "rightMenuBarLayout" );
//	}


	// change the annotation for the menu item depending on the current task
	//
	if ( $task == "setMembership" )
	{
		menuItem
			-edit
			-annotation (uiRes("m_relationshipEditor.kSetMembershipListAnnot"))
			rightListMenuAutoLoadSelectionItem;
	}
	else if ($task == "animLayers") 
	{
	    menuItem -edit	-radioButton true rightListMenuAutoLoadSelectionItem;	    
	}
	else if ( $task == "deformerSetEd" )
	{
		menuItem
			-edit
			-annotation (uiRes("m_relationshipEditor.kDeformerSetListAnnot"))
			rightListMenuAutoLoadSelectionItem;
	}
	else if ( $task == "partitionMembership" )
	{
		menuItem
			-edit
			-annotation (uiRes("m_relationshipEditor.kPartitionMembershipListAnnot"))
			rightListMenuAutoLoadSelectionItem;
	}
	else if ( $task == "characterMembership" )
	{
		menuItem
			-edit
			-annotation (uiRes("m_relationshipEditor.kCharacterMembershipListAnnot"))
			rightListMenuAutoLoadSelectionItem;
	}
	else if ( $task == "renderPassSetEd" )
	{
		menuItem
			-edit
			-label (uiRes("m_relationshipEditor.kRenderPassAutoLoadAll"))
			-annotation (uiRes("m_relationshipEditor.kRenderPassAutoLoadAllAnnot"))
			rightListMenuAutoLoadAllItem;
		menuItem
			-edit
			-label (uiRes("m_relationshipEditor.kRenderPassAutoLoadSelection"))
			-annotation (uiRes("m_relationshipEditor.kRenderPassAutoLoadSelectionAnnot"))
			rightListMenuAutoLoadSelectionItem;
		menuItem
			-edit
			-label (uiRes("m_relationshipEditor.kRenderPassManualLoad"))
			-annotation (uiRes("m_relationshipEditor.kRenderPassManualLoadAnnot"))
			rightListMenuManualLoadItem;
		menuItem
			-edit
			-label (uiRes("m_relationshipEditor.kRenderPassLoadSelection"))
			-annotation (uiRes("m_relationshipEditor.kRenderPassLoadSelectionAnnot"))
			rightListMenuLoadListFromSelectionItem;
		menuItem
			-edit
			-label (uiRes("m_relationshipEditor.kRenderPassAddSelection"))
			-annotation (uiRes("m_relationshipEditor.kRenderPassAddSelectionAnnot"))
			rightListMenuAddSelectionToListItem;
		menuItem
			-edit
			-label (uiRes("m_relationshipEditor.kRenderPassRemoveSelection"))
			-annotation (uiRes("m_relationshipEditor.kRenderPassRemoveSelectionAnnot"))
			rightListMenuRemoveSelectionFromListItem;
	}
	else if (( $task == "eventCentricInteraction" ) ||
			 ( $task == "actionCentricInteraction" ))
	{
		menuItem
			-edit
			-annotation (uiRes("m_relationshipEditor.kActionEventCentricInteractionListAnnot"))
			rightListMenuAutoLoadSelectionItem;
	}
	else if ( $task == "touchSensorInteraction" )
	{
		menuItem
			-edit
			-annotation (uiRes("m_relationshipEditor.kTouchSensorInteractionListAnnot"))
			rightListMenuAutoLoadSelectionItem;
	}

	relationshipEditorRefreshMenu($panel, $task, "rightListMenu");
}

proc configureRightEditMenu(
	string $panel, 
	string $task)
//
// Description:
//	This procedure is called after the current task changes.
//	This procedure configures the menu at the top of the outliner on the right
//	side of the relationship editor according to the current task.
//
//	If you are implementing a new task, you will want to add code to this
//	procedure to configure the right menu as appropriate for your task.
//
{
	string $topLayout = `panel -query -control $panel`;

	setParent $topLayout;

	menu
		-edit
		-deleteAllItems
		rightEditMenu;
	
	setParent -menu rightEditMenu;

	// Add non-task-specific items to the edit menu
	//
	menuItem
		-label		(uiRes("m_relationshipEditor.kRightEditMenuSelectHighlighted"))
		-command	
			("relationshipEditorMenuCommand "
				+ $panel
				+ " "
				+ $task
				+ " "
				+ "rightEditMenuSelectHighlighted")
		rightEditMenuSelectHighlightedItem;

	// Add task-specific items to the edit menu and edit the labels of 
	// non-task-specific items if it is good to do so.
	//
	// NOTE: There probably shouldn't be any task-specific items in the 
	// edit menu on the right. If you're considering adding one, talk
	// it over with other people from a design standpoint. If you do
	// need to add one, maybe it might apply to other tasks as well in which
	// case it should be non-task specific.

	if ($task == "textureCentricUvLinking")
	{
		string $createUVSet = (uiRes("m_relationshipEditor.kRightEditMenuTextureCentricUvLinkingCreateUVSet"));
		string $textItem=`menuItem -label $createUVSet -sm 1 -to 1 -aob true rightEditMenuCreateUvSetItem`;
			PolyTextureMenu $textItem 1 ("selectionConnection -query -object " + $panel + "RightMainList");
			setParent -m ..;
		menuItem 
			-label (uiRes("m_relationshipEditor.kRightEditMenuRemoveUVSet"))
			-annotation 
				(uiRes("m_relationshipEditor.kRightEditMenuRemoveUVSetAnnot"))
			-command ("relationshipEditorMenuCommand "
					+ $panel
					+ " "
					+ $task
					+ " "
					+ "rightEditRemoveUvSet")
			rightEditMenuRemoveUvSetItem;
		menuItem 
			-label (uiRes("m_relationshipEditor.kRightEditMenuTextureCentricUvLinkingRenameUVSet"))
			-annotation 
				(uiRes("m_relationshipEditor.kRightEditMenuTextureCentricUvLinkingRenameUVSetAnnot"))
			-command ("relationshipEditorMenuCommand "
					+ $panel
					+ " "
					+ $task
					+ " "
					+ "rightEditRenameUvSet")
			rightEditMenuRenameUvSetItem;
	}
	else if( false
		|| ($task == "hairUVLinking")
		|| ( $task == "furUVLinking" )
		|| ($task == "pfxUVLinking")
		)
	{
		string $createUVSet = (uiRes("m_relationshipEditor.kRightEditMenuCreateUVSet"));
		string $textItem=`menuItem -label $createUVSet -sm 1 -to 1 -aob true rightEditMenuCreateUvSetItem`;
			PolyTextureMenu $textItem 1 ("selectionConnection -query -object " + $panel + "RightMainList");
			setParent -m ..;
		menuItem 
			-label (uiRes("m_relationshipEditor.kRightEditMenuRenameUVSet"))
			-annotation 
				(uiRes("m_relationshipEditor.kRightEditMenuRenameUVSetAnnot"))
			-command ("relationshipEditorMenuCommand "
					+ $panel
					+ " "
					+ $task
					+ " "
					+ "rightEditRenameUvSet");
	}
	else if ($task == "uvCentricUvLinking")
	{
		menuItem
			-label (uiRes("m_relationshipEditor.kRightEditMenuIgnoreTexture"))
			-annotation
				(uiRes("m_relationshipEditor.kRightEditMenuIgnoreTextureAnnot"))
			-command ("relationshipEditorMenuCommand "
					+ $panel
					+ " "
					+ $task
					+ " "
					+ "rightEditIgnoreTexture")
			rightEditMenuIgnoreTextureItem;
		menuItem
			-label (uiRes("m_relationshipEditor.kRightEditMenuUseTextureWhenRendering"))
			-annotation
				(uiRes("m_relationshipEditor.kRightEditMenuUseTextureWhenRenderingAnnot"))
			-command ("relationshipEditorMenuCommand "
					+ $panel
					+ " "
					+ $task
					+ " "
					+ "rightEditUnignoreTexture")
			rightEditMenuUnignoreTextureItem;
		menuItem
			-label (uiRes("m_relationshipEditor.kRightEditMenuIsolateTexture"))
			-annotation
				(uiRes("m_relationshipEditor.kRightEditMenuIsolateTextureAnnot"))
			-command ("relationshipEditorMenuCommand "
					+ $panel
					+ " "
					+ $task
					+ " "
					+ "rightEditIsolateTexture")
			rightEditMenuIsolateTextureItem;
		menuItem
			-label (uiRes("m_relationshipEditor.kRightEditMenuUseAllTextures"))
			-annotation
				(uiRes("m_relationshipEditor.kRightEditMenuUseAllTexturesAnnot"))
			-command ("relationshipEditorMenuCommand "
					+ $panel
					+ " "
					+ $task
					+ " "
					+ "rightEditUnignoreAllTextures")
			rightEditMenuUnignoreAllTexturesItem;
			
		string $attrEditorMenuItemName = `format -s (localizedUIComponentLabel("Attribute Editor")) (uiRes("m_relationshipEditor.kAttrEditorMenuItemFormat"))`;
		menuItem
			-label $attrEditorMenuItemName
			-annotation
				(uiRes("m_relationshipEditor.kRightEditMenuUvCentricUvLinkingAttributeEditorAnnot"))
			-command ("relationshipEditorMenuCommand "
					+ $panel
					+ " "
					+ $task
					+ " "
					+ "rightEditAttributeEditor")
			rightEditMenuAttributeEditorItem;
	}
}

proc configureLabels(
	string $panel, 
	string $task)
//
// Description:
//	This procedure is called after the current task changes.
//	This procedure configures the labels in the relationship editor which
//	describe the current task and the items being displayed in the left and
//	right outliners.
//
//	If you are implementing a new task, you will want to add code to this
//	procedure to set the labels as appropriate for your task.
//
{
	string $labelLightSources       = (uiRes("m_relationshipEditor.kLightSources"));
	string $labelIlluminatedObjects = (uiRes("m_relationshipEditor.kIlluminatedObjects"));
	string $labelFurDescriptions    = (uiRes("m_relationshipEditor.kFurDescriptions"));
	string $labelHairSystems        = (uiRes("m_relationshipEditor.kHairSystems"));
	string $labelObjects            = (uiRes("m_relationshipEditor.kObjects"));
	string $labelLayers             = (uiRes("m_relationshipEditor.kLayers"));
	string $labelUVSets             = (uiRes("m_relationshipEditor.kUVSets"));
	string $labelTextures           = (uiRes("m_relationshipEditor.kTextures"));
	string $labelActions            = (uiRes("m_relationshipEditor.kActions"));
	string $labelEvents             = (uiRes("m_relationshipEditor.kEvents"));
	
	if ($task == "lightCentricLightLinking")
	{
		setTaskLabels(
			$panel, 
			$labelLightSources, 
			$labelIlluminatedObjects);
	}
	else if ($task == "objectCentricLightLinking")
	{
		setTaskLabels(
			$panel, 
			$labelIlluminatedObjects,
			$labelLightSources); 
	}
	else
	if ($task == "setMembership")
	{
		// there is no task label for this case - call it anyway to set the
		// task description text
		//
		string $labelSets = (uiRes("m_relationshipEditor.kSets"));
		setTaskLabels(
			$panel, 
			$labelSets, 
			$labelObjects);
	}
	else if ($task == "displayLayers")
	{
		// there is no task label for this case - call it anyway to set the
		// task description text
		//
		setTaskLabels(
			$panel,
			$labelLayers,
			$labelObjects);
	}
	else if ($task == "renderLayers")
	{
		// there is no task label for this case - call it anyway to set the
		// task description text
		//
		setTaskLabels(
			$panel,
			$labelLayers,
			$labelObjects);
	}
	else if ($task == "animLayers")
	{
		// there is no task label for this case - call it anyway to set the
		// task description text
		//
		setTaskLabels(
			$panel,
			$labelLayers,
			$labelObjects);
	}
	else if ($task == "partitionMembership")
	{
		// there is no task label for this case - call it anyway to set the
		// task description text
		//
		string $labelPartitions = (uiRes("m_relationshipEditor.kPartitions"));
		setTaskLabels(
			$panel, 
			$labelPartitions, 
			$labelObjects);
	}
	else if ($task == "characterMembership")
	{
		// there is no task label for this case - call it anyway to set the
		// task description text
		//
		string $labelCharacterSets = (uiRes("m_relationshipEditor.kCharacterSets"));
		setTaskLabels(
			$panel, 
			$labelCharacterSets, 
			$labelObjects);
	}
	else if ($task == "deformerSetEd")
	{
		string $labelDeformerSets = (uiRes("m_relationshipEditor.kDeformerSets"));
		setTaskLabels(
			$panel, 
			$labelDeformerSets, 
			$labelObjects);
	}
	else if ($task == "uvCentricUvLinking")
	{
		setTaskLabels(
			$panel, 
			$labelUVSets, 
			$labelTextures);
	}
	else if ($task == "renderPassSetEd")
	{
		string $labelRenderPassSets = (uiRes("m_relationshipEditor.kRenderPassSets"));
		string $labelRenderPasses = (uiRes("m_relationshipEditor.kRenderPassed"));
		setTaskLabels(
			$panel, 
			$labelRenderPassSets, 
			$labelRenderPasses);
	}
	else if ($task == "hairUVLinking")
	{
		setTaskLabels(
			$panel, 
			$labelHairSystems, 
			$labelUVSets);
	}
	else if ($task == "furUVLinking")
	{
		setTaskLabels(
			$panel, 
			$labelFurDescriptions, 
			$labelUVSets);
	}
	else if ($task == "hairFurLinking")
	{
		setTaskLabels(
			$panel, 
			$labelHairSystems, 
			$labelFurDescriptions);
	}
	else if ($task == "pfxUVLinking")
	{
		string $labelPFXStrokes = (uiRes("m_relationshipEditor.kPFXStrokes"));
		setTaskLabels(
			$panel, 
			$labelPFXStrokes, 
			$labelUVSets);
	}
	else if ($task == "textureCentricUvLinking")
	{
		setTaskLabels(
			$panel, 
			$labelTextures, 
			$labelUVSets);
	}
	else if ($task == "eventCentricInteraction")
	{
		setTaskLabels(
			$panel, 
			$labelEvents,
			$labelActions);
	}
	else if ($task == "actionCentricInteraction")
	{
		setTaskLabels(
			$panel, 
			$labelActions,
			$labelEvents);
	}
	else if ($task == "touchSensorAssociation")
	{
		string $labelTouchSensors = (uiRes("m_relationshipEditor.kTouchSensors"));
		string $labelTouchableObjects = (uiRes("m_relationshipEditor.kTouchableObjects"));
		setTaskLabels(
			$panel, 
			$labelTouchSensors,
			$labelTouchableObjects);
	}
	else if ($task == "cameraSets")
	{
		string $labelCameraSets = (uiRes("m_relationshipEditor.kLabelCameraSets"));
		string $labelCamerasAndSets	= (uiRes("m_relationshipEditor.kLabelCamerasAndSets"));
		setTaskLabels(
			$panel, 
			$labelCameraSets,
			$labelCamerasAndSets);
	}
}

proc configureLeftSelection(
	string $panel,
	string $task)
//
// Description:
//	This procedure is called every time the current task changes. 
//	This procedure clears the selections in the left outliner, and configures 
//	the	select scripts on the outliner to perform key selection.
//
//	You should not need to modify this procedure to implement a new task.
//
{
	string $selectionConnection = ($panel + "LeftSelection");

	// Disconnect scripts so they don't get called when the list is cleared
	// 
	selectionConnection
		-edit
		-addScript ""
		-removeScript ""
		$selectionConnection;

	selectionConnection
		-edit
		-clear
		 $selectionConnection;

	// Configure the "item selected"/"item deselected" scripts on selection
	// connections.
	// 
	selectionConnection 
		-edit
		-addScript 
			("relationshipEditorSelectKey "
				+ $panel
				+ " "
				+ $task)
		$selectionConnection;

	selectionConnection 
		-edit
		-removeScript
			("relationshipEditorDeselectKey "
				+ $panel
				+ " "
				+ $task)
		$selectionConnection;

	// Also configure the outliner itself to do single selection or multi
	// selection (for the set editors), and always toggle select or not (for
	// the set editors).
	//
	string $outliner = ($panel + "LeftOutliner");

	// Right now, all tasks allow multi selection on the left.
	//
	outlinerEditor
		-edit
		-allowMultiSelection true
		-alwaysToggleSelect false
		$outliner;
}

proc configureRightSelection(
	string $panel,
	string $task)
//
// Description:
//	This procedure is called every time the current task changes. 
//	This procedure clears the selections in the right outliner, and configures 
//	the	select scripts on the outliner to perform key selection.
//
//	You should not need to modify this procedure to implement a new task.
//
{
	string $selectionConnection = ($panel + "RightSelection");

	// Disconnect scripts so they don't get called when the list is cleared
	// 
	selectionConnection
		-edit
		-addScript ""
		-removeScript ""
		$selectionConnection;

	selectionConnection
		-edit
		-clear
		 $selectionConnection;

	// Configure the "item selected"/"item deselected" scripts on selection
	// connections.
	// 
	selectionConnection 
		-edit
		-addScript 
			("relationshipEditorDisallowSelectItem "
				+ $panel
				+ " "
				+ $task)
		$selectionConnection;

	// Also configure the outliner itself to do multi selection, and always
	// toggle select
	//
	string $outliner = ($panel + "RightOutliner");

	outlinerEditor
		-edit
		-allowMultiSelection true
		-alwaysToggleSelect true
		$outliner;
}


global proc string[] relationshipEditorLeftExplicitFilters(
	string $panel,
	string $task)
//
//	Description:
//		These are the filters that will appear in the left Filter menu for
//		the current task.
//
{
	string $explicitFilterArray[];

	if ($task == "lightCentricLightLinking")
	{
		$explicitFilterArray[0] = "Lighting";
	}
	else if ($task == "objectCentricLightLinking")
	{
		$explicitFilterArray[0] = "Modeling";
		$explicitFilterArray[1] = "Render";
	}
	else if ($task == "renderPassSetEd")
	{
		$explicitFilterArray[0] = "None";
	}
    else
	if ($task == "animLayers")
	{
	    //FIXME: anything to put here for anim layers??
	}
	else
	if ($task == "setMembership")
	{
		$explicitFilterArray[0] = "Sets";
	}
	else if ($task == "deformerSetEd")
	{
		$explicitFilterArray[0] = "Modeling";
		$explicitFilterArray[1] = "Animating";

	}
	else if ($task == "displayLayers" 
		|| $task == "renderLayers"
		)
	{
		$explicitFilterArray[0] = "Modeling";
		$explicitFilterArray[1] = "Camera";
		$explicitFilterArray[2] = "Animating";
		$explicitFilterArray[3] = "Lighting";
		$explicitFilterArray[4] = "Texturing";
	
	}
	else if ($task == "partitionMembership") {
		$explicitFilterArray[0] = "None";

	} else if ($task == "characterMembership") {
		$explicitFilterArray[0] = "None";

	} else if (($task == "eventCentricInteraction") ||
			   ($task == "actionCentricInteraction") ||
			   ($task == "touchSensorAssociation")) {
		$explicitFilterArray[0] = "None";
	}
	else if ($task == "furUVLinking" )
	{
		$explicitFilterArray[0] = "None";
	}
	else if ($task == "hairFurLinking" )
	{
		$explicitFilterArray[0] = "None";
	}
	return $explicitFilterArray;
}

global proc string[] relationshipEditorRightExplicitFilters(
	string $panel,
	string $task)
//
//	Description:
//		These are the filters that will appear in the right Filter menu for
//		the current task.
//
{
	string $explicitFilterArray[];

	if ($task == "lightCentricLightLinking") {
		$explicitFilterArray[0] = "Modeling";
		$explicitFilterArray[1] = "Render";

	} else if ($task == "objectCentricLightLinking") {
		$explicitFilterArray[0] = "Lighting";
	
	}
	else
	 if ($task == "setMembership") {
		$explicitFilterArray[0] = "Modeling";
		$explicitFilterArray[1] = "Camera";
		$explicitFilterArray[2] = "Animating";
		$explicitFilterArray[3] = "Sets";
		$explicitFilterArray[4] = "Lighting";
		$explicitFilterArray[5] = "Texturing";

	} else if ($task == "deformerSetEd") {
		$explicitFilterArray[0] = "Modeling";
		$explicitFilterArray[1] = "Animating";

	} else if ($task == "displayLayers" 
		|| $task == "renderLayers"
		) {
		$explicitFilterArray[0] = "Modeling";
		$explicitFilterArray[1] = "Camera";
		$explicitFilterArray[2] = "Animating";
		$explicitFilterArray[3] = "Lighting";
		$explicitFilterArray[4] = "Texturing";

	} else if ($task == "renderPassSetEd") {
		$explicitFilterArray[0] = "None";
	} else if ($task == "animLayers") {
		// FIXME: anything needed here for animLayers??

	} else if ($task == "partitionMembership") {
		$explicitFilterArray[0] = "Sets";

	} else if ($task == "characterMembership") {
		$explicitFilterArray[0] = "Modeling";
		$explicitFilterArray[1] = "Animating";

	} else if (($task == "eventCentricInteraction") ||
			   ($task == "actionCentricInteraction") ||
			   ($task == "touchSensorAssociation")) {
		$explicitFilterArray[0] = "None";
	}

	return $explicitFilterArray;
}

proc configureLeftItems(
	string $panel,
	string $task,
	string $leftItemsArray[])
//
// Description:
//	This procedure is called every time the current task changes.
//	This procedure initializes the left outliner based on the list of items
//	given as arguments and the current task. For example, if the current task
//	is attribute connection, the list of items would be a list of nodes which
//	should be shown in the left outliner (source nodes).
//
//	If you are implementing a new task, and your task requires a list of items
//	for initialization, you will want to add code here to perform the
//	appropriate initialization.
//
{
	// (todo) I don't think this code does what its author thought it would do
	// - jdc rendering
	//
	if (
		($task == "setMembership") ||
		($task == "deformerSetEd") ||
		($task == "displayLayers") ||
		($task == "animLayers") ||
		($task == "renderLayers") ||
		($task == "renderPassSetEd") ||
		($task == "characterMembership") ||
		($task == "partitionMembership") 
		)
	{
		selectionConnection
			-edit
			-clear
			($panel + "LeftMainList");

		int $i;

		for ($i = 0; $i < size($leftItemsArray); $i++)
		{
			selectionConnection
				-edit
				-select $leftItemsArray[$i]
				($panel + "LeftMainList");
		}
	}
	if ( ($task == "uvCentricUvLinking") || ($task == "textureCentricUvLinking")  
		|| ($task == "hairUVLinking")
		|| ($task == "furUVLinking") || ($task == "hairFurLinking")
		|| ($task == "pfxUVLinking")
		)
	{
		// Initialize the main list for the relationship editor from the
		// current selection
		//
		relationshipEditorRelationshipsChanged($panel, $task);
	}
}

proc configureRightItems(
	string $panel,
	string $task,
	string $rightItemsArray[])
//
// Description:
//	This procedure is called every time the current task changes.
//	This procedure initializes the right outliner based on the list of items
//	given as arguments and the current task. For example, if the current task
//	is attribute connection, the list of items would be a list of nodes which
//	should be shown in the right outliner (destination nodes).
//
//	If you are implementing a new task, and your task requires a list of items
//	for initialization, you will want to add code here to perform the
//	appropriate initialization.
//
{
}

global int $gRelationshipsChangedScriptJobNumber = -1;
global int $gDisplayLayerManagerChangedScriptJobNumber = -1;
global int $gRenderLayerManagerChangedScriptJobNumber = -1;
global int $gAnimLayerChangedScriptJobNumber = -1;

global proc setRelationshipsChangedScript(
	string $panel,
	string $task)
{
	global int $gRelationshipsChangedScriptJobNumber;
	global int $gDisplayLayerManagerChangedScriptJobNumber;
	global int $gRenderLayerManagerChangedScriptJobNumber;
	global int $gAnimLayerChangedScriptJobNumber;

	if ($gRelationshipsChangedScriptJobNumber != -1)
	{
		scriptJob -force -kill $gRelationshipsChangedScriptJobNumber;
		$gRelationshipsChangedScriptJobNumber = -1;
	}
	if( ($task != "displayLayers")
	&&  ($gDisplayLayerManagerChangedScriptJobNumber != -1) )
	{
		scriptJob -force -kill $gDisplayLayerManagerChangedScriptJobNumber;
		$gDisplayLayerManagerChangedScriptJobNumber = -1;
	}

	if( ($task != "renderLayers")
	&&  ($gRenderLayerManagerChangedScriptJobNumber != -1) )
	{
		scriptJob -force -kill $gRenderLayerManagerChangedScriptJobNumber;
		$gRenderLayerManagerChangedScriptJobNumber = -1;
	}
	if( ($task != "animLayers")
	&&  ($gAnimLayerChangedScriptJobNumber != -1) )
	{
		scriptJob -force -kill $gAnimLayerChangedScriptJobNumber;
		$gAnimLayerChangedScriptJobNumber = -1;
	}
	if (($task == "lightCentricLightLinking") ||
		($task == "objectCentricLightLinking"))
	{
		$gRelationshipsChangedScriptJobNumber = 
			`scriptJob -protected
				-parent $panel
				-event 	("lightLinkingChanged") 
					("relationshipEditorRelationshipsChanged "
						+ $panel
						+ " " 
						+ $task)`;
	}
	else
	if( $task == "setMembership" ||
			 $task == "deformerSetEd" )
	{		 
		$gRelationshipsChangedScriptJobNumber = 
			`scriptJob -protected
				-parent $panel
				-event 	("SetModified") 
					("relationshipEditorRelationshipsChanged "
						+ $panel
						+ " " 
						+ $task)`;
						
	}
	else if( $task == "displayLayers" )
	{
		// Call back to here if the current display layer changed so
		// that the watcher can update himself.  No need to recreate this
		// job if it's already running.
		//
		if ($gDisplayLayerManagerChangedScriptJobNumber == -1)
		{
			$gDisplayLayerManagerChangedScriptJobNumber =
				`scriptJob -protected
					-parent $panel
					-event ("displayLayerManagerChange")
						("setRelationshipsChangedScript "
							+ $panel
							+ " " 
							+ $task)`;
		}

		// Rebuild the relationships if the current display layer was
		// used to implicitly add objects to itself.
		//
		string $cdl = `editDisplayLayerGlobals -q -cdl`;
		$gRelationshipsChangedScriptJobNumber =
			`scriptJob -protected
				-parent $panel
				-allChildren
				-disregardIndex
				-connectionChange ($cdl + ".di")
					("relationshipEditorRelationshipsChanged "
						+ $panel
						+ " "
						+ $task)`;
	}
	else if( $task == "renderLayers" )
	{
		// Call back to here if the current render layer changed so
		// that the watcher can update himself.  No need to recreate this
		// job if it's already running.
		//
		if ($gRenderLayerManagerChangedScriptJobNumber == -1)
		{
			$gRenderLayerManagerChangedScriptJobNumber =
				`scriptJob -protected
					-parent $panel
					-event ("renderLayerManagerChange")
						("setRelationshipsChangedScript "
							+ $panel
							+ " "
							+ $task)`;
		}

		// Rebuild the relationships if the current render layer was
		// used to implicitly add objects to itself.
		//
		string $cdl = `editRenderLayerGlobals -q -currentRenderLayer`;
		$gRelationshipsChangedScriptJobNumber =
			`scriptJob -protected
				-parent $panel
				-allChildren
				-disregardIndex
				-connectionChange ($cdl + ".ri")
					("relationshipEditorRelationshipsChanged "
						+ $panel
						+ " "
						+ $task)`;
	}
	else if( $task == "renderPassSetEd")
	{
		$gRelationshipsChangedScriptJobNumber = 
			`scriptJob -protected
				-parent $panel
				-event 	("renderPassSetMembershipChange") 
					("relationshipEditorRelationshipsChanged "
						+ $panel
						+ " " 
						+ $task)`;
	}
	else if( $task == "animLayers" )
	{
		// Call back to here if the current render layer changed so
		// that the watcher can update himself.  No need to recreate this
		// job if it's already running.
		//
		if ($gAnimLayerChangedScriptJobNumber == -1)
		{
			$gAnimLayerChangedScriptJobNumber =
				`scriptJob -protected
					-parent $panel
					-event ("animLayerRefresh")
						("setRelationshipsChangedScript "
							+ $panel
							+ " "
							+ $task)`;
		}

		
	}
	else if ( ($task == "uvCentricUvLinking") || ($task == "textureCentricUvLinking")
		|| ($task == "hairUVLinking")
		|| ($task == "furUVLinking") || ( $task == "hairFurLinking" )
		|| ($task == "pfxUVLinking")
		 )
	{
		$gRelationshipsChangedScriptJobNumber = 
			`scriptJob -protected
				-parent $panel
				-event 	("SelectionChanged") 
					("relationshipEditorRelationshipsChanged "
						+ $panel
						+ " " 
						+ $task)`;
	}
}

global proc editIconCommands(
	string $panel,
	string $task )
//
//	Description:
//		This proc is called when the current task changes. It updates the 
//		command associated with the icons in the relationship editor.
//
{
	if (    ($task == "uvCentricUvLinking")
		||	($task == "lightCentricLightLinking" )
		||	($task == "objectCentricLightLinking")
		||	($task == "hairUVLinking")
		||	($task == "furUVLinking")
		||	($task == "hairFurLinking")
		||	($task == "pfxUVLinking")
		||	($task == "textureCentricUvLinking")
		||	($task == "eventCentricInteraction")
		||	($task == "actionCentricInteraction")
		||	($task == "touchSensorAssociation")
		)
	{
		// the buttons don't apply to this task
		//
		symbolButton 
			-edit 
			-command ""
			-manage false
			addItemsBtn;
		symbolButton 
			-edit 
			-command ""
			-manage false
			removeItemsBtn;			
	}
	else if ( ($task == "setMembership") || 
			  ($task == "partitionMembership") ||
			  ($task == "characterMembership") ||
			  ($task == "deformerSetEd") )
	{
		string $target = ($task == "setMembership" ? "set" :
						 ($task == "partitionMembership" ? "partition" :
						 ($task == "characterMembership" ? "character" :
						 "deformer set" )));
		
		string $addItem;
		string $removeItem;
		
		if ($target== "set" )
		{
			$addItem = (uiRes("m_relationshipEditor.kEditIconSetAddAnnot"));
			$removeItem = (uiRes("m_relationshipEditor.kEditIconSetRemoveAnnot"));
		}
		else if ($target== "partition" )
		{
			$addItem = (uiRes("m_relationshipEditor.kEditIconPartitionAddAnnot"));
			$removeItem = (uiRes("m_relationshipEditor.kEditIconPartitionRemoveAnnot"));
		}
		else if ($target== "character" )
		{
			$addItem = (uiRes("m_relationshipEditor.kEditIconCharacterAddAnnot"));
			$removeItem = (uiRes("m_relationshipEditor.kEditIconCharacterRemoveAnnot"));
		}
		else if ($target== "deformer set" )
		{
			$addItem = (uiRes("m_relationshipEditor.kEditIconDeformerSetAddAnnot"));
			$removeItem = (uiRes("m_relationshipEditor.kEditIconDeformerSetRemoveAnnot"));
		}
		
		symbolButton 
			-edit 
			-command ("relationshipEditorMenuCommand "
					+ $panel
					+ " "
					+ $task
					+ " "
					+ "leftEditMenuAddToSet")
			-manage true
			-annotation $addItem
			addItemsBtn;
		symbolButton 
			-edit 
			-command ("relationshipEditorMenuCommand "
					+ $panel
					+ " "
					+ $task
					+ " "
					+ "leftEditMenuRemoveFromSet")
			-manage true
			-annotation $removeItem
			removeItemsBtn;
	}
	else if ( $task == "displayLayers" )
	{
		symbolButton 
			-edit 
			-command ("relationshipEditorMenuCommand "
					+ $panel
					+ " "
					+ $task
					+ " "
					+ "leftEditMenuAddToDisplayLayer")
			-manage true
			-annotation (uiRes("m_relationshipEditor.kMoveItemsToDisplayLayer"))
			addItemsBtn;
		symbolButton 
			-edit 
			-command ("relationshipEditorMenuCommand "
					+ $panel
					+ " "
					+ $task
					+ " "
					+ "leftEditMenuRemoveFromDisplayLayer")
			-manage true
			-annotation (uiRes("m_relationshipEditor.kMoveItemsOutofDisplayLayer"))
			removeItemsBtn;
	}
	else if ( $task == "renderLayers" )
	{
		symbolButton
			-edit
			-command ("relationshipEditorMenuCommand "
					+ $panel
					+ " "
					+ $task
					+ " "
					+ "leftEditMenuAddToRenderLayer")
			-manage true
			-annotation (uiRes("m_relationshipEditor.kMoveItemsToRenderLayer"))
			addItemsBtn;
		symbolButton
			-edit
			-command ("relationshipEditorMenuCommand "
					+ $panel
					+ " "
					+ $task
					+ " "
					+ "leftEditMenuRemoveFromRenderLayer")
			-manage true
			-annotation (uiRes("m_relationshipEditor.kMoveItemsOutofRenderLayer"))
			removeItemsBtn;
	}
	else if ( $task == "renderPassSetEd" )
	{
		symbolButton
			-edit
			-command ("relationshipEditorMenuCommand "
					+ $panel
					+ " "
					+ $task
					+ " "
					+ "leftEditMenuAddToRenderPassSet")
			-manage true
			-annotation (uiRes("m_relationshipEditor.kMoveItemsToRenderPassSet"))
			addItemsBtn;
		symbolButton
			-edit
			-command ("relationshipEditorMenuCommand "
					+ $panel
					+ " "
					+ $task
					+ " "
					+ "leftEditMenuRemoveFromRenderPassSet")
			-manage true
			-annotation (uiRes("m_relationshipEditor.kMoveItemsOutofRenderPassSet"))
			removeItemsBtn;
	}
	else if ( $task == "animLayers" )
	{
		symbolButton
			-edit
			-command ("relationshipEditorMenuCommand "
					+ $panel
					+ " "
					+ $task
					+ " "
					+ "leftEditMenuAddToAnimLayer")
			-manage true
			-annotation (uiRes("m_relationshipEditor.kMoveItemsToAnimLayer"))
			addItemsBtn;
		symbolButton
			-edit
			-command ("relationshipEditorMenuCommand "
					+ $panel
					+ " "
					+ $task
					+ " "
					+ "leftEditMenuRemoveFromAnimLayer")
			-manage true
			-annotation (uiRes("m_relationshipEditor.kMoveItemsOutofAnimLayer"))
			removeItemsBtn;
	}
}

proc beginTask(
	string $panel,
	string $task,
	string $leftItemsArray[],
	string $rightItemsArray[])
//
// Description:
//	This procedure is called every time the current task changes.
//	This procedure calls other procedures, each of which configures some
//	aspect of the relationship editor for the new task.
//
//	You should not have to modify this procedure in order to implement a new
//	task.
//
{

	optionVar -stringValue "relationshipEditorTask" $task;

	// put the string from the popup menu into the text field to identify
	// the current task
	//
	string $localizedTaskName = convertTaskNameToLocalizedName($task);
	int $taskValue = findOptionMenuIndexByLabel($localizedTaskName, "taskPopup");
	optionMenu -e -select $taskValue taskPopup;
	filterUISetRelatedFiltersProcedure(
		($panel + "LeftOutliner"), 
		("relationshipEditorLeftExplicitFilters "
			+ $panel
			+ " "
			+ $task));

	filterUISetRelatedFiltersProcedure(
		($panel + "RightOutliner"), 
		("relationshipEditorRightExplicitFilters "
			+ $panel
			+ " "
			+ $task));

	configureLayout($panel, $task);
	configureOptionsMenu($panel, $task);
	configureLabels($panel, $task);
	configureLeftListMenu($panel, $task);
	configureRightListMenu($panel, $task);
	configureLeftEditMenu($panel, $task);
	configureRightEditMenu($panel, $task);
	configureLeftOutliner($panel, $task);
	configureRightOutliner($panel, $task);
	configureLeftImplicitFilter($panel, $task);
	configureRightImplicitFilter($panel, $task);
	configureLeftSelection($panel, $task);
	configureRightSelection($panel, $task);
	configureLeftItems($panel, $task, $leftItemsArray);
	configureRightItems($panel, $task, $rightItemsArray);


	// display the icons if appropriate for the current task
	//
	editIconCommands( $panel, $task );

	// Set the relationships changed script
	//
	setRelationshipsChangedScript($panel, $task);
}

global proc relationshipEditorBeginTask(
	string $panel,
	string $task )
{
	beginTask($panel, $task, {}, {});
}

// ---------------------------------------------------------------------------
// 	UI creation procedures
// 

global proc switchTask( 
	string $panel )
//
// Description:
//		Switch to a different task based on what was selected in the 
//		optionMenu. The menu items are 1-based so the taskValue represents
//		each item in the order they appear in the popup.
//
{
    string $currentTaskName = `optionMenu -q -v taskPopup`;
	string $task = convertLocalizedNameToTaskName($currentTaskName);
	relationshipEditorBeginTask( $panel, $task );


	// since the task has changed filterUI needs to know this so
	// set the procedures again with the new task
	//
	filterUISetRelatedFiltersProcedure(
		($panel + "LeftOutliner"), 
		("relationshipEditorLeftExplicitFilters "
			+ $panel
			+ " "
			+ $task));
	filterUISetRelatedFiltersProcedure(
		($panel + "RightOutliner"), 
		("relationshipEditorRightExplicitFilters "
			+ $panel
			+ " "
			+ $task));
}

global proc createRelEdTaskMenuItem(string $label, string $annotation, string $itemName, string $codeName)
{
	// Create ui drop down list element
	//
	menuItem 
		-label $label
		-annotation $annotation
		$itemName;

	// Place in mapping to enable conversion between localized names and unlocalized task names
	//
	addToLocalizedLookupMap $label $codeName;
}

global proc createRelEdTaskMenuItems( 
	string $panel )
{
	clearLocalizedNamesMap();

		createRelEdTaskMenuItem
			(uiRes("m_relationshipEditor.kLightCentricLightLinking")) 
			(uiRes("m_relationshipEditor.kLightCentricLightLinkingAnnot"))
			taskLightCentricLightLinkingItem
			"lightCentricLightLinking";

		createRelEdTaskMenuItem 
			(uiRes("m_relationshipEditor.kObjectCentricLightLinking"))
			(uiRes("m_relationshipEditor.kObjectCentricLightLinkingAnnot"))
			taskObjectCentricLightLinkingItem
			"objectCentricLightLinking";

		createRelEdTaskMenuItem 
			(uiRes("m_relationshipEditor.kSetEditing"))
			(uiRes("m_relationshipEditor.kSetEditingAnnot"))
			taskSetEditingItem
			"setMembership";

		createRelEdTaskMenuItem 
			(uiRes("m_relationshipEditor.kPartitionEditing"))
			(uiRes("m_relationshipEditor.kPartitionEditingAnnot"))
			taskPartitionEditingItem
			"partitionMembership";

		createRelEdTaskMenuItem 
			(uiRes("m_relationshipEditor.kCharacterEditing"))
			(uiRes("m_relationshipEditor.kCharacterEditingAnnot"))
			taskCharacterEditingItem
			"characterMembership";
		createRelEdTaskMenuItem 
			(uiRes("m_relationshipEditor.kDeformerSetEditing"))
			(uiRes("m_relationshipEditor.kDeformerSetEditingAnnot"))
			taskDeformerSetEditingItem
			"deformerSetEd";

		createRelEdTaskMenuItem 
			(uiRes("m_relationshipEditor.kDisplayLayers"))
			(uiRes("m_relationshipEditor.kDisplayLayersAnnot"))
			taskDisplayLayerItem
			"displayLayers";

		createRelEdTaskMenuItem
			(uiRes("m_relationshipEditor.kRenderLayers"))
			(uiRes("m_relationshipEditor.kRenderLayersAnnot"))
			taskRenderLayerItem
			"renderLayers";

		createRelEdTaskMenuItem 
			(uiRes("m_relationshipEditor.kTextureCentricUVLinking"))
			(uiRes("m_relationshipEditor.kTextureCentricUVLinkingAnnot"))
			taskTextureCentricUvLinkingItem
			"textureCentricUvLinking";

		createRelEdTaskMenuItem 
			(uiRes("m_relationshipEditor.kUVCentricUVLinking"))
			(uiRes("m_relationshipEditor.kUVCentricUVLinkingAnnot"))
			taskUvCentricUvLinkingItem
			"uvCentricUvLinking";

		createRelEdTaskMenuItem 
			(uiRes("m_relationshipEditor.kPaintEffectsUVLinking"))
			(uiRes("m_relationshipEditor.kPaintEffectsUVLinkingAnnot"))
			taskUvPfxLinkingItem
			"pfxUVLinking";

		createRelEdTaskMenuItem 
			(uiRes("m_relationshipEditor.kHairUVLinking"))
			(uiRes("m_relationshipEditor.kHairUVLinkingAnnot"))
			taskUvHairLinkingItem
			"hairUVLinking";
		
		createRelEdTaskMenuItem 
			(uiRes("m_relationshipEditor.kCameraSets"))
			(uiRes("m_relationshipEditor.kCameraSetsAnnot"))
			taskCameraSetItem
			"cameraSets";

		createRelEdTaskMenuItem
			(uiRes("m_relationshipEditor.kAnimLayers"))
			(uiRes("m_relationshipEditor.kAnimLayersAnnot"))
			taskAnimLayerItem
			"animLayers";
		createRelEdTaskMenuItem 
			(uiRes("m_relationshipEditor.kRenderPassSets"))
			(uiRes("m_relationshipEditor.kRenderPassSetsAnnot"))
			taskRenderPassSetItem
			"renderPassSetEd";

		if(`pluginInfo -q -l Fur`)
		{
			createRelEdTaskMenuItem 
				(uiRes("m_relationshipEditor.kFurUVLinking"))
				(uiRes("m_relationshipEditor.kFurUVLinkingAnnot"))
				taskUvFurLinkingItem
				"furUVLinking";
			createRelEdTaskMenuItem 
				(uiRes("m_relationshipEditor.kHairFurLinking"))
				(uiRes("m_relationshipEditor.kHairFurLinkingAnnot"))
				taskHairFurLinkingItem
				"hairFurLinking";
		}				
		// Add the tasks for any registered plugins.
		addRelationshipEdPluginItems($panel);

	// Add support for a few known plugins
	addToLocalizedLookupMap "Event-centric Interaction" "eventCentricInteraction";
	addToLocalizedLookupMap "Action-centric Interaction" "actionCentricInteraction";
	addToLocalizedLookupMap "Touch Sensor Associations" "touchSensorAssociation";
}

proc createTaskPopup(
	string $panel )
//
// Description:
//	This procedure is called when the relationship editor is first opened.
//	This procedure creates the Task popup menu under the top menubar of 
//  the relationship editor. 
//	
//	If you are implementing a new task, you will want to add your task to the
//	task menu, otherwise people won't be able to use it!
//
{
	// Create the task setting widget, that allows a user to change the
	// current task in the relationship editor.
	//
	string $relationshipEditorTaskPopup = `optionMenu
		-cc ("switchTask " + $panel)
		taskPopup`;

		if(`about -mac`) {
			// Fixes Bug #161411
			optionMenu -e -l " " taskPopup;
		}
		// fill in the menu items for the optionMenu
		//
		createRelEdTaskMenuItems($relationshipEditorTaskPopup);

	setParent -m ..;	// from taskMenuLayout
}

global proc buildREContextHelpItems(string $nameRoot, string $menuParent)
//
//  Description:
//		Build context sensitive menu items for this window.  
//		
//  Input Arguments:
//		$nameRoot - name to use as the root of all item names
//		$menuParent - the name of the parent of this menu
//
//  Return Value:
//      None
//
{
	menuItem -label (uiRes("m_relationshipEditor.kHelpRelationshipEditor"))
		-enableCommandRepeat false
		-command "showHelp RelationshipEditor";
}

proc createTopMenu(string $panel)
//
// Description:
//	This procedure is called when the relationship editor is first opened.
//	This procedure creates the Task and Options menus in the top menubar of 
//  the relationship editor. 
//	
//	If you are implementing a new task, you will want to add your task to the
//	task menu, otherwise people won't be able to use it!
//
{
    global string $relationshipEditorRegisterCB[] = {};

	// The Options menu
	//
	string $optionsMenu = 
		`menu
			-label (uiRes("m_relationshipEditor.kOptions"))
			-tearOff true
			optionsMenu`;

	//	Add support for the Context Sensitive Help Menu.
	//
	addContextHelpProc $panel "buildREContextHelpItems";
			
	// set the menu bar visibility
	//
	int $menusOkayInPanels = `optionVar -q allowMenusInPanels`;
	panel -e -mbv $menusOkayInPanels $panel;

	// Fill in any additional items from plugins.
	for ($cb in $relationshipEditorRegisterCB) {
		string $taskPopups[] = getRelationshipEdPopups();
		for ($popup in $taskPopups)
			eval($cb + " " + $popup);
    }
}

proc string createPane(
	string 	$side,
	string 	$outlinerName)
//
// Description:
//	This procedure is called when the relationship editor is first opened.
//	This procedure creates the UI for one of the two sides of the relationship
//	editor. 
//
//	You should not have to modify this procedure to implement a new task.
//
{
	string $task = relationshipEditorTask();

	string $paneLayout = `formLayout ($side + "PaneLayout")`;

		string $description = ($side + "Description");
		text 
			-label 		(uiRes("m_relationshipEditor.kPaneDescription"))
			-height 	25
			-align 		"center"
			$description;

		string $menuBarLayout = `menuBarLayout ($side + "MenuBarLayout")`;

			menu
				-label (uiRes("m_relationshipEditor.kList"))
				($side + "ListMenu");
			setParent -menu; // from ListMenu

			menu
				-label (uiRes("m_relationshipEditor.kEdit"))
				-allowOptionBoxes true
				($side + "EditMenu");
			setParent -menu; // from EditMenu

			string $outlinerLayout = `formLayout ($side + "OutlinerLayout")`;

				string $outlinerLayoutName = addSharedOutlinerEditor ($outlinerLayout, $outlinerName);

				// add the filter UI field to the outliner
				//
				string $filterField = filterUICreateField( $outlinerName, $outlinerLayout );

				formLayout
					-edit
					-attachForm $filterField "left"		0
					-attachForm $filterField "right"	0
					-attachForm $filterField "top" 		0
					-attachNone $filterField "bottom"

					-attachControl $outlinerLayoutName "top" 	  0 $filterField
					-attachForm    $outlinerLayoutName "left"   0 
					-attachForm    $outlinerLayoutName "right"  0 
					-attachForm    $outlinerLayoutName "bottom" 0 
					$outlinerLayout;

			setParent ..; // from $outlinerLayout

		setParent ..; // from $menuBarLayout

		formLayout
			-edit

			-attachForm $description "top" 		0 
			-attachForm $description "left" 	0 
			-attachForm $description "right" 	0 
			-attachNone $description "bottom" 

			-attachControl 	$menuBarLayout "top" 	0 $description
			-attachForm 	$menuBarLayout "left" 	0
			-attachForm 	$menuBarLayout "right" 	0
			-attachForm 	$menuBarLayout "bottom" 0

			$paneLayout;

	setParent ..; // from $paneLayout
	
	return $paneLayout;
}

// ---------------------------------------------------------------------------
// 	Scripted panel support
// 

global proc createRelationshipPanel(string $panel) 
//
// Description:
//	This procedure is called the first time the relationship editor is opened.
//	This procedure creates the various UI entities that the relationship
//	editor will use, except for those UI entities which are controls.
//
//	If you are implementing a new task, you may want to add code here to
//	create filters your task will use.
//
//	Note that some filters are already created which you can later reconfigure 
//	to suit your task (ie LeftAttrFilter, RightAttrFilter).
//
{
	// Create the combination left and right outliners for the editor
	//
	createSharedOutlinerEditor ($panel + "LeftOutliner");
	createSharedOutlinerEditor ($panel + "RightOutliner");

	// Create the selection connections to be used by the outliners
	// Mark main lists as global so they don't get deleted when cleaning up in
	// the outlinerEditor when cleaning up old main connection list (see
	// changeset #751850).
	//
	selectionConnection -global true ($panel + "LeftMainList");
	selectionConnection -global true ($panel + "RightMainList");
	selectionConnection ($panel + "LeftSelection");
	selectionConnection ($panel + "RightSelection");
	selectionConnection -global true ($panel + "LeftMainListManual");
	selectionConnection -global true ($panel + "RightMainListManual");

	// Hook up the selection connections to the outliners. Use the flag
	// -setsIgnoreFilters so that items on the left outliner can be expanded
	// (it means the outliner will ignore its filter when expanding)
	//
	outlinerEditor
		-edit
		-setsIgnoreFilters true
		-selectionConnection ($panel + "LeftSelection")
		($panel + "LeftOutliner");
	outlinerEditor
		-edit
		-setsIgnoreFilters true
		-selectionConnection ($panel + "RightSelection")
		($panel + "RightOutliner");
}


global proc initRelationshipPanel(string $panel)
//
// This is called when the file changes to make sure that everything
// is up-to-date with the new file.  At this point, we need to create
// any filters we need, since they will have been deleted with the
// previous file.
//
{
	// Create itemFilters which may be used
	//
	if (!`itemFilter -exists layersFilter`)
	{
		itemFilter
			-byType		"displayLayer"
			-classification "builtIn"
			layersFilter;
	}
	
	if (!`itemFilter -exists animLayersFilter`)
	{
		itemFilter
			-byType		"animLayer"
			-classification "builtIn"
			animLayersFilter;
	}
	
	if (!`itemFilter -exists notAnimLayersFilter`)
	{
		itemFilter
			-byType		"animLayer"
			-negate     true
			-classification "builtIn"
			notAnimLayersFilter;
	}
    //
    // Create renderLayerFilter if it does not already exist.
    createRenderLayerFilters();

    //
	if (!`itemFilter -exists renderingSetsFilter`)
	{
		itemFilter
			-byType		"shadingEngine"
			-classification "builtIn"
			renderingSetsFilter;
	}
	if (!`itemFilterAttr -exists ($panel + "LeftAttrFilter")`)
	{
		itemFilterAttr -classification "builtIn" ($panel + "LeftAttrFilter");
	}
	if (!`itemFilterAttr -exists ($panel + "RightAttrFilter")`)
	{
		itemFilterAttr -classification "builtIn" ($panel + "RightAttrFilter");
	}
	
	// if the window is open, we need to call switchTask to
	// set up the filters properly.
	//
	if ( `optionMenu -exists taskPopup` ){
		switchTask $panel;
	}
}


global proc addRelationshipPanel(string $panel) 
//
// Description:
//	This procedure is called when the relationship editor is first opened. 
//	This procedure creates all of the UI for the relationship editor.
//	You should not need to modify this procedure to implement a new task,
//	unless you need to create additional UI specific to your task. If you are
//	thinking of doing so, please read the comments on configureLayout before
//	proceeding.
//
{
	createTopMenu($panel);

	string $mainForm = `formLayout mainForm`;

		createTaskPopup($panel);

		separator
			-height 	5
			-style 		"out"
			taskMenuSeparator;

		int $height = 24;

		// these buttons relate to Add Items and Remove Items options from
		// the Edit menu
		//
		symbolButton -image "setEdAddCmd.png" 
			-height $height -width $height
			addItemsBtn;
		symbolButton -image "setEdRemoveCmd.png" 
			-height $height -width $height
			removeItemsBtn;

		string $leftRightForm = `formLayout leftRightForm`;
			paneLayout
				-configuration 		"vertical2"
				-separatorThickness 5
				leftRightLayout;
				
				string $leftPaneLayout = createPane(
					"left",
					($panel + "LeftOutliner")); 
				string $rightPaneLayout = createPane(
					"right",
					($panel + "RightOutliner")); 

			// add the filter UI menu items to each side
			//
			filterUICreateMenu( ($panel + "LeftOutliner"), "leftMenuBarLayout" );
			filterUICreateMenu( ($panel + "RightOutliner"), "rightMenuBarLayout" );

			//	Get the popup menu attached to each outliner and add an item
			//	to access the filter menu.
			//
			string $popupMenuParent, $popupMenu, $popupMenuList[];
			int    $button;
			$popupMenuParent = `editor -query -control ($panel + "LeftOutliner")`;
			if ("" != $popupMenuParent && "NONE" != $popupMenuParent) {
				$popupMenuList = `control -query -popupMenuArray $popupMenuParent`;
				for ($popupMenu in $popupMenuList) {
					$button = `popupMenu -query -button $popupMenu`;
					if (3 == $button) {
						$popupMenu = $popupMenuParent + "|" + $popupMenu;
						filterUICreateMenu (($panel + "LeftOutliner"), $popupMenu);
						break;
					}
				}
			}
			$popupMenuParent = `editor -query -control ($panel + "RightOutliner")`;
			if ("" != $popupMenuParent && "NONE" != $popupMenuParent) {
				$popupMenuList = `control -query -popupMenuArray $popupMenuParent`;
				for ($popupMenu in $popupMenuList) {
					$button = `popupMenu -query -button $popupMenu`;
					if (3 == $button) {
						$popupMenu = $popupMenuParent + "|" + $popupMenu;
						filterUICreateMenu (($panel + "RightOutliner"), $popupMenu);
						break;
					}
				}
			}

			setParent $leftRightForm; // from leftRightLayout

			formLayout
				-edit
				-attachForm		"leftRightLayout" "left" 	0
				-attachForm		"leftRightLayout" "right" 	0
				-attachForm		"leftRightLayout" "top" 	0
				-attachForm		"leftRightLayout" "bottom" 	0
				$leftRightForm;

		setParent $mainForm; // from leftRightForm

		formLayout
			-edit

			-attachControl	"addItemsBtn" "left"		0 "taskPopup"
			-attachNone		"addItemsBtn" "right"
			-attachForm		"addItemsBtn" "top" 		1
			-attachNone		"addItemsBtn" "bottom"

			-attachControl	"removeItemsBtn" "left"		0 "addItemsBtn"
			-attachNone		"removeItemsBtn" "right"
			-attachForm		"removeItemsBtn" "top" 		1
			-attachNone		"removeItemsBtn" "bottom"

			-attachForm		"taskMenuSeparator" "left" 	0
			-attachForm		"taskMenuSeparator" "right"	0
			-attachControl	"taskMenuSeparator" "top" 	0 "taskPopup"
			-attachNone		"taskMenuSeparator" "bottom"

			-attachForm		"leftRightForm" "left"		0
			-attachForm		"leftRightForm" "right"		0
			-attachControl	"leftRightForm" "top"		0 "taskMenuSeparator"
			-attachForm		"leftRightForm" "bottom" 	0

			$mainForm;

	setParent ..; // from mainForm

	// need to do this here so that files saved with the relationship editor
	// will load again with the proper task
	//
	string $task = relationshipEditorTask();
	beginTask( $panel, $task, {}, {} );
}

global proc removeRelationshipPanel(string $panel) 
//
//  Description:
//    Being unparented, so unparent editors.  Controls will
//	  be deleted automatically.
//
//
// Description:
//	This procedure is called when the relationship editor is being destroyed
//	or reparented. 
//	This procedure unparents the outlinerEditors of the relationship editor.
//	Other controls are deleted automatically.
//
{
	removeSharedOutlinerEditor ($panel+"LeftOutliner");
	removeSharedOutlinerEditor ($panel+"RightOutliner");

	filterUIRemoveView($panel+"LeftOutliner");
	filterUIRemoveView($panel+"RightOutliner");
}

global proc string saveStateRelationshipPanel(string $panel) 
//
//  Description:
//    Return a string that when executed will set the panel's state.
//
{
	string $stateStr = "";
	return $stateStr;
}

global proc deleteRelationshipPanel(string $panel) 
//
//  Description:
//    Final deletion of the panel.  Clean up any resources that need to be
//    freed.
//
{
	// Delete the selectionConnections created in createRelationshipPanel.
	//
	if(`selectionConnection -exists ($panel + "LeftMainList")`) {
		deleteUI ($panel + "LeftMainList");
	}
	if(`selectionConnection -exists ($panel + "RightMainList")`) {
		deleteUI ($panel + "RightMainList");
	}
	if(`selectionConnection -exists ($panel + "LeftSelection")`) {
		deleteUI ($panel + "LeftSelection");
	}
	if(`selectionConnection -exists ($panel + "RightSelection")`) {
		deleteUI ($panel + "RightSelection");
	}
	if(`selectionConnection -exists ($panel + "LeftMainListManual")`) {
		deleteUI ($panel + "LeftMainListManual");
	}
	if(`selectionConnection -exists ($panel + "RightMainListManual")`) {
		deleteUI ($panel + "RightMainListManual");
	}
}

// ---------------------------------------------------------------------------
// 	Procedures which the user uses to invoke the relationship editor
// 

global proc relationshipEditor(
	string $task,
	string $leftItemsArray[],
	string $rightItemsArray[])
//
// Description:
//	This procedure is called when the user wants to open the relationship
//	editor for some task. This procedure may be called by wrapper procedures
//	which provide an interface to the particular tasks.
//	This procedure ensures that the relationship editor is open, visible, and
//	configured for the user's task.
//	
//	You should not need to modify this procedure to implement a new task.
//	However, you may be interested in writing a wrapper procedure for your
//	task, similar to the wrapper procedures which follow this procedure.
//
{
	// Reset the globals for the scriptJobs 
	// The scriptJobs are deleted when the window is deleted
	//
	global int $gRelationshipsChangedScriptJobNumber;
	global int $gDisplayLayerManagerChangedScriptJobNumber;
	global int $gRenderLayerManagerChangedScriptJobNumber;
	global int $gAnimLayerChangedScriptJobNumber;
	$gRelationshipsChangedScriptJobNumber = -1;
	$gDisplayLayerManagerChangedScriptJobNumber = -1;
	$gRenderLayerManagerChangedScriptJobNumber = -1;
	$gAnimLayerChangedScriptJobNumber = -1;

	tearOffPanel (localizedPanelLabel( "Relationship Editor" )) "relationshipPanel" true;

	// Determine if the relationship editor exists
	//
	string $panel;
	$panel = relationshipEditorPanel();

	// If the relationship editor does not exist in a panel or window, create
	// it in a window.
	//
//	tearOffPanel "Relationship Editor" "relationshipPanel" true;

	// If the relationship editor is in a window, bring it to the front
	//

	// End the current task of the relationship editor
	//

	// Begin the new task of the relationship editor
	//
	beginTask(
		$panel, 
		$task, 
		$leftItemsArray, 
		$rightItemsArray);

//	scriptedPanel -e -label "Relationship Editor" $panel;
}

global proc lightLinkingEditor()
//
// Description:
//	This procedure is called when the user chooses light centric light linking
//  from a menu or other access point in the UI.
//	This procedure is a wrapper around the relationshipEditor procedure above,
//	and causes the relationship editor to be opened and configured for light
//	linking.
//
{
	relationshipEditor("lightCentricLightLinking", {}, {});
}

global proc objectLightLinkingEditor()
//
// Description:
//	This procedure is called when the user chooses object centric light 
//  linking from a menu or other access point in the UI.
//	This procedure is a wrapper around the relationshipEditor procedure above,
//	and causes the relationship editor to be opened and configured for light
//	linking.
//
{
	relationshipEditor("objectCentricLightLinking", {}, {});
}

global proc setMembershipEditor()
//
// Description:
//	This procedure is called when the user chooses set membership editing from 
//	a menu or other access point in the UI.
//	This procedure is a wrapper around the relationshipEditor procedure above,
//	and causes the relationship editor to be opened and configured for set
//	membership editing.
//
{
	relationshipEditor("setMembership", {}, {});
}

global proc partitionEditor()
//
// Description:
//	This procedure is called when the user chooses partition editing from 
//	a menu or other access point in the UI.
//	This procedure is a wrapper around the relationshipEditor procedure above,
//	and causes the relationship editor to be opened and configured for 
//  partition editing.
//
{
	relationshipEditor("partitionMembership", {}, {});
}

global proc characterEditor( int $higlightCurrent )
//
// Description:
//	This procedure is called when the user chooses character editing from 
//	a menu or other access point in the UI.
//	This procedure is a wrapper around the relationshipEditor procedure above,
//	and causes the relationship editor to be opened and configured for 
//  character editing.
//
{
	relationshipEditor("characterMembership", {}, {});
	string $panel = relationshipEditorPanel();
	if ( $higlightCurrent ) {
		evalDeferred("relationshipEditorMenuCommand " + $panel + 
			" characterMembership leftEditMenuHighlightCurrentCharacters");
	}
}

global proc deformerSetEditor()
//
// Description:
//	This procedure is called when the user chooses set membership editing from 
//	a menu or other access point in the UI.
//	This procedure is a wrapper around the relationshipEditor procedure above,
//	and causes the relationship editor to be opened and configured for set
//	membership editing.
//
{
	relationshipEditor("deformerSetEd", {}, {});
}

global proc displayLayerEditor()
//
// Description:
//	This procedure is called when the user chooses display layer editing
//	from a menu or other access point in the UI.
//	This procedure is a wrapper around the relationshipEditor procedure above,
//	and causes the relationship editor to be opened and configured for
//	display layer editing.
//
{
	relationshipEditor( "displayLayers", {}, {} );
}

global proc renderLayerEditor()
//
// Description:
//	This procedure is called when the user chooses render layer editing
//	from a menu or other access point in the UI.
//	This procedure is a wrapper around the relationshipEditor procedure above,
//	and causes the relationship editor to be opened and configured for
//	render layer editing.
//
{
	relationshipEditor( "renderLayers", {}, {} );
}

global proc renderPassSetEditor()
//
// Description:
//	This procedure is called when the user chooses render pass set membership
//	editing from a menu or other access point in the UI.
//	This procedure is a wrapper around the relationshipEditor procedure above,
//	and causes the relationship editor to be opened and configured for render
//	pass set membership editing.
//
{
	relationshipEditor("renderPassSetEd", {}, {});
}
global proc animLayerEditor()
//
// Description:
//	This procedure is called when the user chooses animation layer editing
//	from a menu or other access point in the UI.
//	This procedure is a wrapper around the relationshipEditor procedure above,
//	and causes the relationship editor to be opened and configured for
//	anim layer editing.
//
{
	relationshipEditor( "animLayers", {}, {} );
}

global proc textureCentricUvLinkingEditor()
//
// Description:
//	This procedure is called when the user chooses texture-centric UV linking
//  from a menu or other access point in the UI.
//	This procedure is a wrapper around the relationshipEditor procedure above,
//	and causes the relationship editor to be opened and configured for texture
//	centric UV linking.
//
{
	relationshipEditor("textureCentricUvLinking", {}, {});
}

global proc uvCentricUvLinkingEditor()
//
// Description:
//	This procedure is called when the user chooses UV-centric UV linking
//  from a menu or other access point in the UI.
//	This procedure is a wrapper around the relationshipEditor procedure above,
//	and causes the relationship editor to be opened and configured for UV
//	centric UV linking.
//
{
	relationshipEditor("uvCentricUvLinking", {}, {});
}

global proc pfxUVLinkingEditor()
//
// Description:
//	This procedure is called when the user chooses Paint Effects/UV linking
//  from a menu or other access point in the UI.
//	This procedure is a wrapper around the relationshipEditor procedure above,
//	and causes the relationship editor to be opened and configured for
//	Paint Effects/UV linking.
//
{
	relationshipEditor("pfxUVLinking", {}, {});
}

global proc hairUVLinkingEditor()
//
// Description:
//	This procedure is called when the user chooses Hair/UV linking
//  from a menu or other access point in the UI.
//	This procedure is a wrapper around the relationshipEditor procedure above,
//	and causes the relationship editor to be opened and configured for
//	Hair/UV linking.
//
{
	relationshipEditor("hairUVLinking", {}, {});
}

global proc cameraSetEditor()
//
// Description:
//	This procedure is called when the user chooses cameraSet editing
//	from a menu or other access point in the UI.
//	This procedure is a wrapper around the relationshipEditor procedure above,
//	and causes the relationship editor to be opened and configured for
//	cameraSet editing.
//
{
	relationshipEditor("cameraSets", {}, {});
}

global proc eventCentricInteractionEditor()
//
// Description:
//	This procedure is called when the user chooses event centric interaction
//  editing from a menu or other access point in the UI.
//	This procedure is a wrapper around the relationshipEditor procedure above,
//	and causes the relationship editor to be opened and configured for event
//	centric interaction editing.
//
{
    global string $MiInteractionFilterNodes[];
	$MiInteractionFilterNodes[0] = "";
	$MiInteractionFilterNodes[1] = "";
	relationshipEditor("eventCentricInteraction", {}, {});
}

global proc eventCentricSingleNodeRelationship(
	string $eventName,
	string $actionName)
//
// Description:
//	This procedure creates an eventCentric relationship editor which only
//  displays the given event and action nodes.
//
{
    global string $MiInteractionFilterNodes[];
	$MiInteractionFilterNodes[0] = $eventName;
	$MiInteractionFilterNodes[1] = $actionName;
	relationshipEditor("eventCentricInteraction", {}, {});
	$MiInteractionFilterNodes[0] = "";
	$MiInteractionFilterNodes[1] = "";
}

global proc actionCentricInteractionEditor()
//
// Description:
//	This procedure is called when the user chooses action centric interaction
//  editing from a menu or other access point in the UI.
//	This procedure is a wrapper around the relationshipEditor procedure above,
//	and causes the relationship editor to be opened and configured for action
//	centric interaction editing.
//
{
    global string $MiInteractionFilterNodes[];
	$MiInteractionFilterNodes[0] = "";
	$MiInteractionFilterNodes[1] = "";
	relationshipEditor("actionCentricInteraction", {}, {});
}

global proc actionCentricSingleNodeRelationship(
	string $actionName,
	string $eventName)
//
// Description:
//	This procedure creates an actionCentric relationship editor which only
//  displays the given action and event nodes.
//
{
    global string $MiInteractionFilterNodes[];
	$MiInteractionFilterNodes[0] = $eventName;
	$MiInteractionFilterNodes[1] = $actionName;
	relationshipEditor("actionCentricInteraction", {}, {});
	$MiInteractionFilterNodes[0] = "";
	$MiInteractionFilterNodes[1] = "";
}

global proc touchSensorAssociationEditor()
//
// Description:
//	This procedure is called when the user chooses touch sensor associations
//  editing from a menu or other access point in the UI.
//	This procedure is a wrapper around the relationshipEditor procedure above,
//	and causes the relationship editor to be opened and configured for editting
//	the list of objects that are controlled by the touch sensor.
//
{
	relationshipEditor("touchSensorAssociation", {}, {});
}

global proc furUVLinkingEditor()
//
// Description:
//	This procedure is called when the user chooses Fur/UV linking
//  from a menu or other access point in the UI.
//	This procedure is a wrapper around the relationshipEditor procedure above,
//	and causes the relationship editor to be opened and configured for
//	Fur/UV linking.
//
{
	relationshipEditor("furUVLinking", {}, {});
}

global proc hairFurLinkingEditor()
//
// Description:
//	This procedure is called when the user chooses Hair/Fur linking
//	from a menu or other access point in the UI.
//	This procedure is a wrapper around the relationshipEditor procedure above,
//	and causes the relationship editor to be opened and configured for
//	Fur/UV linking.
//
{
	relationshipEditor("hairFurLinking", {}, {});
}

global proc shadingGroupsEditor()
//
// Description:
//
{
	warning (uiRes("m_relationshipEditor.kShadingGroupsEditorObsolete"));
}
