// Copyright (C) 1997-2014 Autodesk, Inc., and/or its licensors.
// All rights reserved.
//
// The coded instructions, statements, computer programs, and/or related
// material (collectively the "Data") in these files contain unpublished
// information proprietary to Autodesk, Inc. ("Autodesk") and/or its licensors,
// which is protected by U.S. and Canadian federal copyright law and by
// international treaties.
//
// The Data is provided for use exclusively by You. You have the right to use,
// modify, and incorporate this Data into other products for purposes authorized 
// by the Autodesk software license agreement, without fee.
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND. AUTODESK
// DOES NOT MAKE AND HEREBY DISCLAIMS ANY EXPRESS OR IMPLIED WARRANTIES
// INCLUDING, BUT NOT LIMITED TO, THE WARRANTIES OF NON-INFRINGEMENT,
// MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE, OR ARISING FROM A COURSE 
// OF DEALING, USAGE, OR TRADE PRACTICE. IN NO EVENT WILL AUTODESK AND/OR ITS
// LICENSORS BE LIABLE FOR ANY LOST REVENUES, DATA, OR PROFITS, OR SPECIAL,
// DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES, EVEN IF AUTODESK AND/OR ITS
// LICENSORS HAS BEEN ADVISED OF THE POSSIBILITY OR PROBABILITY OF SUCH DAMAGES.

//
// Script:    nurbsToggleEditUVMode.mel
//
// Description:
//		Toggles between the use of implicit and explicit UVs on NURBS objects.
//

global proc nurbsToggleEditUVMode()
{
	string $shapes[];
	txtWndShapesFromSelList( $shapes );
	int $nShapes = size($shapes);

	// Rather than toggle each NURBS object individually, we should keep the
	// final state consistent across all selected objects. To do so, use
	// queryNurbsEditUVMode() to determine current state and toggle that for
	// final state.
	//
	// queryNurbsEditUVMode will return true if any selected NURBS object has
	// useExplicitUVs enabled.
	//
	int $currentState = queryNurbsEditUVMode();
	int $finalState = !$currentState;

	// Create a list of shapes we've already processed, so we don't toggle back
	// and forth over the same shape when we should only do it once.
	//
	string $processedShapes[];
	int $nProcessedShapes = size($processedShapes);

	int $i;
	string $shape;
	for( $i = 0; $i < $nShapes; $i++ )
	{
		$shape = $shapes[$i];
		$type = `objectType $shape`;

		// Firewall: Only do each shape once.
		//
		int $k;
		int $skipObject = 0;
		for( $k = 0; $k < $nProcessedShapes; $k++ )
		{
			if( $shape == $processedShapes[$k] )
			{
				$skipObject = 1;
			}
		}

		if( $skipObject )
		{
			continue;
		}

		string $cmd;
		if( $type == "nurbsSurface" )
		{
			int $hasExplicitUVs[] = `nurbsUVSet -q -c $shape`;

			// If the object does not have a nurbs UV set on it yet, create one.
			//
			if( !$hasExplicitUVs[0] )
			{
				catch(`nurbsUVSet -c $shape`);
			}

			// Now toggle the use explicit flag.
			//
			$hasExplicitUVs = `nurbsUVSet -q -c $shape`;
			if( $hasExplicitUVs[0] )
			{
				nurbsUVSet -ue $finalState $shape;
			}

			$processedShapes[$nProcessedShapes] = $shape;
			$nProcessedShapes = size($processedShapes);
		}
	}
}