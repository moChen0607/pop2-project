// Copyright (C) 1997-2014 Autodesk, Inc., and/or its licensors.
// All rights reserved.
//
// The coded instructions, statements, computer programs, and/or related
// material (collectively the "Data") in these files contain unpublished
// information proprietary to Autodesk, Inc. ("Autodesk") and/or its licensors,
// which is protected by U.S. and Canadian federal copyright law and by
// international treaties.
//
// The Data is provided for use exclusively by You. You have the right to use,
// modify, and incorporate this Data into other products for purposes authorized 
// by the Autodesk software license agreement, without fee.
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND. AUTODESK
// DOES NOT MAKE AND HEREBY DISCLAIMS ANY EXPRESS OR IMPLIED WARRANTIES
// INCLUDING, BUT NOT LIMITED TO, THE WARRANTIES OF NON-INFRINGEMENT,
// MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE, OR ARISING FROM A COURSE 
// OF DEALING, USAGE, OR TRADE PRACTICE. IN NO EVENT WILL AUTODESK AND/OR ITS
// LICENSORS BE LIABLE FOR ANY LOST REVENUES, DATA, OR PROFITS, OR SPECIAL,
// DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES, EVEN IF AUTODESK AND/OR ITS
// LICENSORS HAS BEEN ADVISED OF THE POSSIBILITY OR PROBABILITY OF SUCH DAMAGES.

//
//
//  Creation Date:  Mar, 2006
//
//	Procedure Name:
//		doSplitCacheArgList
//
//	Description:
//		Split a cache clip
//
//	Input Arguments:
//	$version: The version of this option box.  Used to know how to 
//	interpret the $args array.
//
//	$args
//	Version 1
//	[0]     $timeMethod : method to set time
//				"currTimeMethod" = use current time
//				"specifyMethod" = use $time
//  [1] 	$time : time to split clip
//  [2] 	$editor : used by doSplitClipArgList, ignored here
//  [3] 	$notUsed: used by doSplitClipArgList, ignored here
//  [4] 	$clipName : clip to split or "" to act on selection
//

global proc string[]
doSplitCacheArgList( string $version, string $args[] )
{
	int $versionNo			= $version;
	string $timeMethod	 	= $args[0];
	float $stime			= $args[1];
	source "clipTrimAfter.mel";
	source "clipTrimBefore.mel";

	string $initialSel[] = `ls -sl -dag`;
	string $selClips[];
	if (size($args) > 4 && size($args[4]) != "") {
		$selClips[0] = $args[4];
	} else {
		$selClips = getSelectedClips("includeCache");
	}
	
	if ($timeMethod == "currTimeMethod") {
		$stime = `currentTime -q`;
	}

	string $splitClips[];

	int $nclips = size($selClips);
	if ($nclips == 0) {
		error((uiRes("m_doSplitCacheArgList.kSelectClips")));
	} else {
		string $clip;
		for ($clip in $selClips)
		{
			if (nodeType($clip) != "cacheFile") {
				continue;
			}
			float $clipStart = `getAttr ($clip+".startFrame")`;
			float $clipPreCycle = `getAttr ($clip+".preCycle")`;
			float $clipPostCycle = `getAttr ($clip+".postCycle")`;
			float $clipScale = `getAttr ($clip+".scale")`;
			float $clipOrigStart = `getAttr ($clip+".sourceStart")`;
			float $clipOrigEnd = `getAttr ($clip+".sourceEnd")`;
			float $clipDuration = ($clipOrigEnd - $clipOrigStart);

			float $startLength = $stime - $clipStart;
			float $startCycle = $startLength / ($clipDuration*$clipScale);
			int $clipTrack = `getAttr ($clip+".track")`;

			// verify that the time is within the range of the clip
			//
			if ($startLength <= 0.0) {
				string $format = (uiRes("m_doSplitCacheArgList.kInvalidTime"));
				string $errMsg = `format -stringArg $stime $format`;
				error($errMsg);
			}

			if ($clipPreCycle > 0.0 || $clipPostCycle > 0.0) {
				error((uiRes("m_doSplitCacheArgList.kCycledClip")));
			}

			if ($startCycle < 1.0) {
				string $geom[] = `cacheFile -q -geometry $clip`;

				string $newClip[] = `duplicate $clip`;
				cacheClipTrimAfter($clip,$stime);
				cacheClipTrimBefore($newClip[0],$stime);
				string $readOnly[] = `ls -readOnly $clip`;
				if (size($readOnly) == 0) {
					rename $clip ($clip+"Start");
				}
				
				string $newClipName = `rename $newClip[0] ($clip+"End")`;
				connectAttr time1.outTime ($newClipName+".time");

				// attach the new clip to the geom
				//
				string $blend[] = `getCacheBlend $geom "add"`;
				if (size($blend) > 0) {
					string $channelAttrs[] = `listAttr -m ($newClipName+".channel")`;
					string $channelNames[];
					int $ii, $geomCount = size($geom);
					for ($ii = 0; $ii < $geomCount; $ii++) {
						string $obj = $geom[$ii];
						int $geomIndex = `cacheFileCombine -object $obj -q -oi $blend[0]`;
						string $channelName = ($ii < size($channelAttrs)) ?
							`getAttr ($newClipName+"."+$channelAttrs[$ii])` : $obj;
						$channelNames[$ii] = $channelName;
					}
					doCacheConnect($blend[0],$newClipName,$geom,$channelNames);
					setAttr ($newClipName+".track") $clipTrack;
				}
			} else {
				error((uiRes("m_doSplitCacheArgList.kSplitTime")));
			}
		}
	}

	// restore the initial selection so that the clips don't get unloaded
	// from the trax editor if the user has "List -> Autoload" enabled.
	//
	select -add $initialSel;
	return $splitClips;
}
