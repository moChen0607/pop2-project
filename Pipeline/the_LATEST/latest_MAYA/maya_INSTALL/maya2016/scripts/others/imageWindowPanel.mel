// Copyright (C) 1997-2014 Autodesk, Inc., and/or its licensors.
// All rights reserved.
//
// The coded instructions, statements, computer programs, and/or related
// material (collectively the "Data") in these files contain unpublished
// information proprietary to Autodesk, Inc. ("Autodesk") and/or its licensors,
// which is protected by U.S. and Canadian federal copyright law and by
// international treaties.
//
// The Data is provided for use exclusively by You. You have the right to use,
// modify, and incorporate this Data into other products for purposes authorized 
// by the Autodesk software license agreement, without fee.
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND. AUTODESK
// DOES NOT MAKE AND HEREBY DISCLAIMS ANY EXPRESS OR IMPLIED WARRANTIES
// INCLUDING, BUT NOT LIMITED TO, THE WARRANTIES OF NON-INFRINGEMENT,
// MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE, OR ARISING FROM A COURSE 
// OF DEALING, USAGE, OR TRADE PRACTICE. IN NO EVENT WILL AUTODESK AND/OR ITS
// LICENSORS BE LIABLE FOR ANY LOST REVENUES, DATA, OR PROFITS, OR SPECIAL,
// DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES, EVEN IF AUTODESK AND/OR ITS
// LICENSORS HAS BEEN ADVISED OF THE POSSIBILITY OR PROBABILITY OF SUCH DAMAGES.

//
// Script:    imageWindowPanel.mel
//
// SYNOPSIS
//
//		Creates a panel that contains the imaging window.
//		This file also contains a bunch of helper procedures related to the
//		imaging window.
//

//---------------------------------------------------------------------------//


global proc imageWindowPanel(string $panelName) 
//
//  Description:
//		This proc defines the image window panel type and instantiates
//		one.
//
{
	global string $gMainPane;

	//  define the type of panel
	//
	if (!`scriptedPanelType -exists imageWindowPanel`) {
		scriptedPanelType
			-unique true
			-createCallback "createImageWindowPanel" 
			-addCallback "addImageWindowPanel" 
			-removeCallback "removeImageWindowPanel" 
			imageWindowPanel;

		//
	    //  create an instance of the image window panel
		//
		setParent $gMainPane;
		scriptedPanel -unParent -type "imageWindowPanel" $panelName;
	}
}

//---------------------------------------------------------------------------//

//
// Description:
//		Sets all the option var specific to the image view.
//	- imageViewTestResolution: 0 => panel resolution.
//								1 => image globals.
//								2 => 50% image globals.
//								3 => 25% image globals.
//								4 => 10% image globals.
//	- imageViewAutoResize: boolean
//	- imageViewAutoImageRegion: boolean.
//
global proc setImageOptionVars()
{
	if( !`optionVar -exists imageViewTestResolution` )
	{
		optionVar -intValue imageViewTestResolution 1;
	}
	if( !`optionVar -exists imageViewAutoResize` )
	{
		optionVar -intValue imageViewAutoResize 1;
	}
	if( !`optionVar -exists imageViewAutoImageRegion` )
	{
		optionVar -intValue imageViewAutoImageRegion 0;
	}
}

global proc switchAutoImageRegionVar()
{
	if( `optionVar -exists imageViewAutoImageRegion` )
	{
		if( `optionVar -query imageViewAutoImageRegion` != 0 )
		{
			optionVar -intValue imageViewAutoImageRegion 0;
		}
		else
		{
			optionVar -intValue imageViewAutoImageRegion 1;
		}
	}
	else
	{
		optionVar -intValue imageViewAutoImageRegion 0;
	}
}

proc switchImageAutoResizeVar( string $editor )
{
	if( `optionVar -exists imageViewAutoResize` )
	{
		if( `optionVar -query imageViewAutoResize` != 0 )
		{
			optionVar -intValue imageViewAutoResize 0;
		}
		else
		{
			optionVar -intValue imageViewAutoResize 1;
		}
	}
	else
	{
		optionVar -intValue imageViewAutoResize 1;
	}

	$var = `optionVar -q imageViewAutoResize`;

	imageWindowEditor -e -ar $var $editor;
}

global proc setImageTestResolutionVar( int $choice )
{
	if( `optionVar -exists imageViewTestResolution` &&
		$choice >= 0 && $choice <= 4 )
	{
		optionVar -intValue imageViewTestResolution $choice;
	}
	else
	{
		//
		//	Default is panel resolution.
		//
		optionVar -intValue imageViewTestResolution 1;
	}
}

//---------------------------------------------------------------------------//
// Callbacks for the panel
//---------------------------------------------------------------------------//

global proc createImageWindowPanel(string $whichPanel)
{
    imageWindowEditor  -unParent  $whichPanel ;

	//
	//	Set the options variables.
	//
	setImageOptionVars;
}

global proc addImageWindowPanel(string $whichPanel)
{		
	//
	//  Build Menubar.
	//
	imageWindowCreateMenubar($whichPanel, "imageWindowEditor");

	//
	//	Create the image view.
	//
	iiWindowEditor( $whichPanel , "imageWindowEditor",
								  "imageWindowCreatePopup",
								  "updateImageWindow");

	//
	//	Tells the imageWindowEditor what the imageViewAutoResize value
	//	is.
	//
	$var = `optionVar -q imageViewAutoResize`;
	imageWindowEditor -e -ar $var $whichPanel;
}

global proc removeImageWindowPanel(string $whichPanel)
{
	imageWindowEditor -e -unParent $whichPanel ;
}

global proc updateImageWindow(int $reason)
{;}

//---------------------------------------------------------------------------//
//	Main image view menu.
//---------------------------------------------------------------------------//

//
//	Description:
//		Image view specific items.
//
global proc imageWindowCreateMenubar(string $editor, string $editorCmd)
{
	string $image = (uiRes("m_imageWindowPanel.kImage"));
	menu -label $image  
		-to 1
		-postMenuCommandOnce true
		-familyImage "menuIconImage.xpm";

	//
	//	Redo last image tries to image with the last camera used.
	//
	menuItem -label (uiRes("m_imageWindowPanel.kRedoPreviousImage"))  -c "redoLastImage(0)"
			 ($editor + "redoLastImageItem");

	menuItem -label (uiRes("m_imageWindowPanel.kImageRegion"))  -c "redoLastImage(1)"
			 ($editor + "imageRegionItem");

	//
	//	Dynamic image menu, it contains the list of cameras to image
	//	from.
	//
	string	$subName = `menuItem -subMenu true -label $image `;
	menuItem -e 
			 -pmc ("imageWindowMakeCameraAction "+$subName+" "+$editor+" image")
			 $subName;
	setParent -m ..;

	//
	//	Dynamic snapshot image menu, it contains the list of visible
	//	camera panels to image from.
	//
	$subName = `menuItem -subMenu true -label (uiRes("m_imageWindowPanel.kSnapshot")) `;
	menuItem -e
			 -pmc ("imageWindowMakeCameraAction "+$subName+" "+$editor+" snapshot")
			 $subName;
	setParent -m ..;

	menuItem -divider true;

	//
	//	Show the image globals.
	//
	menuItem -label (uiRes("m_imageWindowPanel.kImageGlobals"))  -c "showImageGlobals"
		($editor+"renderGlobalsItem");
	setParent -m ..;

	//
	//	Make the dynamic 'test settings' sub menu.
	//
	$subName = `menu -label (uiRes("m_imageWindowPanel.kSettings")) 
			-familyImage "menuIconImageSettings.xpm"`;
 	imageWindowMakeTestSettings $subName $editor;
	setParent -m ..;

	//
	//	Make the View sub menu.
	//
	$subName = `menu -label (uiRes("m_imageWindowPanel.kView")) 
					 -to 1
					 -familyImage "menuIconView.xpm"
					 ($editor+"ViewMenu")`;
	setParent -m $subName;

	menuItem -label (uiRes("m_imageWindowPanel.kFrameImage")) 
			 -c ($editorCmd+" -e -frameImage "+$editor)
			 ($editor+"frameImageItem");
	menuItem -label (uiRes("m_imageWindowPanel.kFrameRegion")) 
			 -c ($editorCmd+" -e -frameRegion "+$editor)
			 ($editor+"frameRegionItem");
	menuItem -label (uiRes("m_imageWindowPanel.kRealSize")) 
			 -c ($editorCmd+" -e -realSize "+$editor)
			 ($editor+"realSizeItem");

    setParent -m ..;

	//
	//	Create the common tools of the menuBar.
	//
	iiWindowEditorMenuBar( $editor, $editorCmd );
}

//
//	Description:
//		Image view specific items.
//
global proc imageWindowCreatePopup(string $editor, string $editorCmd)
{
	//
	//	Redo last image tries to image with the last camera used.
	//
	menuItem -label (uiRes("m_imageWindowPanel.kRedoPreviousImage"))  -c "redoLastImage(0)"
			 ($editor + "redoLastImageItem");

	menuItem -label (uiRes("m_imageWindowPanel.kImageRegion"))  -c "redoLastImage(1)"
			 ($editor + "imageRegionItem");

	//
	//	Dynamic image menu, it contains the list of cameras to image
	//	from.
	//
	string	$subName = `menuItem -subMenu true -label (uiRes("m_imageWindowPanel.kImage")) `;
    menuItem -e 
			 -pmc ("imageWindowMakeCameraAction "+$subName+" "+$editor+" image")
			 $subName;
    setParent -m ..;

	//
	//	Dynamic snapshot image menu, it contains the list of visible
	//	camera panels to image from.
	//
	$subName = `menuItem -subMenu true -label (uiRes("m_imageWindowPanel.kSnapshot"))`;
	menuItem -e
			 -pmc ("imageWindowMakeCameraAction "+$subName+" "+$editor+" snapshot")
			 $subName;
	setParent -m ..;

	menuItem -divider true;

	//
	//	Make the dynamic 'test settings' sub menu.
	//
	$subName = `menuItem -subMenu true -label (uiRes("m_imageWindowPanel.kImageViewSettings")) `;
	menuItem -e
			 -pmc ("imageWindowMakeTestSettings " + $subName + " " + $editor)
			 $subName;
    setParent -m ..;

	//
	//	Show the image globals.
	//
	menuItem -label (uiRes("m_imageWindowPanel.kImageGlobals"))  -c "showImageGlobals"
			 ($editor+"renderGlobalsItem");

	menuItem -divider true;

	//
	//	Make the View sub menu.
	//
	$subName = `menuItem -label (uiRes("m_imageWindowPanel.kView"))  -sm 1 -to 1 ($editor+"ViewMenu")`;
	setParent -m $subName;

	menuItem -label (uiRes("m_imageWindowPanel.kFrameImage")) 
			 -c ($editorCmd+" -e -frameImage "+$editor)
			 ($editor+"frameImageItem");
	menuItem -label (uiRes("m_imageWindowPanel.kFrameRegion"))
			 -c ($editorCmd+" -e -frameRegion "+$editor)
			 ($editor+"frameRegionItem");
	menuItem -label (uiRes("m_imageWindowPanel.kRealSize"))
			 -c ($editorCmd+" -e -realSize "+$editor)
			 ($editor+"realSizeItem");

    setParent -m ..;
}

//---------------------------------------------------------------------------//
//							SUB MENUS PROCEDURES
//---------------------------------------------------------------------------//

//
// Description:
//		This procedure is called by TimageWindowSelectCtx.cc that defines
//	a region. It checks if a region can be imageed.
//
global proc imageWindowCheckAndImageRegion
 ( float	$top,
   float	$left,
   float	$bottom,
   float	$right )
{
	//
	//	If there's no current camera (first image), do what has to be
	//	done...
	//
	string	$imagePanel = `getImageWindowPanel`;
	int		$snaped = 0;

	//
	//	Otherwise, set the region and image if the imageViewAutoImageRegion
	//	is set to true.
	//
	if( $snaped )
	{
		imageWindowEditor -e -mq $top $left $bottom $right $imagePanel;

		if( `optionVar -exists imageViewAutoImageRegion` &&
			`optionVar -query imageViewAutoImageRegion` != 0 )
			redoLastImage(1);
	}
}

//
// Description:
//
//
global proc imageWindowMakeResolutionItem
 ( string $subMenuName,
   string $panelName )
{
	popupMenu -e -deleteAllItems $subMenuName;
	setParent -m $subMenuName;

	//
	//	Use panel resolution item.
	//
	int $testRes	= `optionVar -q imageViewTestResolution`;
	int	$panelBool	= ( $testRes == 0 );
	int $fullBool	= ( $testRes == 1 );
	int $halfBool	= ( $testRes == 2 );
	int $quaterBool	= ( $testRes == 3 );
	int $tenthBool	= ( $testRes == 4 );
	int $res[]		= `getGlobalsResolution`;

	menuItem -label (uiRes("m_imageWindowPanel.kCameraPanel")) 
			 -checkBox  $panelBool
			 -c "setImageTestResolutionVar(0)"
			 ($panelName + "panelResolutionItem");
	string $imageGlobals = (uiRes("m_imageWindowPanel.kImageGlobalsResolution"));	
	$imageGlobals = `format -s $res[0] -s $res[1] $imageGlobals`;

	menuItem -label $imageGlobals
			 -checkBox $fullBool
			 -c "setImageTestResolutionVar(1)"
			 ($panelName + "fullResolutionItem");

	$x = $res[0] / 2;
	$y = $res[1] / 2;
	string $globals = (uiRes("m_imageWindowPanel.kHalfofGlobalsResolution"));	
	$globals = `format -s $x -s $y $globals`;
	
	menuItem -label $globals
			 -checkBox $halfBool
			 -c "setImageTestResolutionVar(2)"
			 ($panelName + "halfResolutionItem");


	$x = $res[0] / 4;
	$y = $res[1] / 4;
	$globals = (uiRes("m_imageWindowPanel.kQuarterofGlobalsResolution"));	
	$globals = `format -s $x -s $y $globals`;
	
	menuItem -label $globals
			 -checkBox $quaterBool
			 -c "setImageTestResolutionVar(3)"
			 ($panelName + "quaterResolutionItem");

	$x = $res[0] / 10;
	$y = $res[1] / 10;
	$globals = (uiRes("m_imageWindowPanel.kOneTenthofGlobalsResolution"));	
	$globals = `format -s $x -s $y $globals`;
	
	menuItem -label $globals
			 -checkBox $tenthBool
			 -c "setImageTestResolutionVar(4)"
			 ($panelName + "tenthResolutionItem");
}

//
// Description:
//
//
global proc imageWindowMakeTestSettings
 ( string $subMenuName,
   string $panelName )
{
	popupMenu -e -deleteAllItems $subMenuName;
	setParent -m $subMenuName;

	//
	//	Resolution used for tests.
	//
	$subName = `menuItem -subMenu true -label (uiRes("m_imageWindowPanel.kResolution")) `;
	menuItem -e
			 -pmc ("imageWindowMakeResolutionItem " + $subName + " " + $panelName)
			 $subName;
    setParent -m ..;

	$var = `optionVar -q imageViewAutoResize`;
	menuItem -label (uiRes("m_imageWindowPanel.kAutoResize")) 
			 -checkBox $var
			 -c ("switchImageAutoResizeVar " + $panelName)
			 ($panelName + "autoResizeItem");

	$var = `optionVar -q imageViewAutoImageRegion`;
	menuItem -label (uiRes("m_imageWindowPanel.kAutoImageRegion")) 
			 -checkBox $var
			 -c "switchAutoImageRegionVar"
			 ($panelName + "autoImageRegionItem");

	string	$camera = `getCurrentCamera`;
	string	$panel = `getCameraPanel( $camera )`;
	int		$res[] = `getTestResolution( $panel )`;

	menuItem -label (uiRes("m_imageWindowPanel.kShowRegion")) 
			 -c ("imageWindowEditor -e -showRegion " +
				 $res[0] + " " + $res[1] + " " + $panelName)
			 ($panelName + "showRegionItem");
}

//
// Description:
//		Take a snapshot by creating a temporary model editor whithin the
//	image view window.
//
global proc imageWindowTakeSnapshot
 ( int		$resX,
   int		$resY,
   string	$camera )
{
	//
	//	Raise the image view in case it's partially covered.
	//
	raiseImageViewWindow;

	string	$prevParent = `setParent -q`;
	string	$mainForm = `getImageWindowPanelFormLayout`;

	setParent $mainForm;

	int		$formX = `formLayout -q -w $mainForm`;
	int		$formY = `formLayout -q -h $mainForm`;
	float	$snapX = $resX;
	float	$snapY = $resY;

	//
	//	TODO: Not very clean, to be improved.
	//
	while( $snapX > $formX )
	{
		$snapX *= 0.8;
		$snapY *= 0.8;
	}

	while( $snapY > $formY )
	{
		$snapX *= 0.8;
		$snapY *= 0.8;
	}

	int	$right = ($formX - $snapX);
	int	$bottom = ($formY - $snapY);

	//
	//	Create the model editor at the right size and take a snapshot.
	//
	modelEditor imageWindowTMPModelEditor;

	formLayout -e -af imageWindowTMPModelEditor left 0 $mainForm;
	formLayout -e -af imageWindowTMPModelEditor right $right $mainForm;
	formLayout -e -af imageWindowTMPModelEditor top 0 $mainForm;
	formLayout -e -af imageWindowTMPModelEditor bottom $bottom $mainForm;

	//
	//	Unset camera gates and reset overscan to 1.
	//
	int		$dfg = `camera -q -displayFilmGate $camera`;
	int		$dr = `camera -q -displayResolution $camera`;
	float	$os = `camera -q -overscan $camera`;
	int		$dgm = `camera -q -displayGateMask $camera`;

	camera -e -displayFilmGate off -displayResolution off -displayGateMask off -overscan 1.0 $camera;

	//
	//	Set the right camera to the model editor.
	//
	modelEditor -e -cam $camera imageWindowTMPModelEditor;

	//
	//	Ask the image window editor to take the snapshot of the given
	//	modelEditor at the given resolution.
	//
	string	$imagePanel = `getImageWindowPanel`;

	// GG: need to make sure tmp window is on top. Otherwise, we keep
	// capturing the imageview.
	imageWindowEditor -e -unParent $imagePanel;
	imageWindowEditor -e -snp imageWindowTMPModelEditor $resX $resY $imagePanel;
	imageWindowEditor -e -parent imageViewWindowPanelLayout_mainForm $imagePanel;

	setParent $mainForm;
	deleteUI -ed imageWindowTMPModelEditor;

	//
	//	Restore camera settings.
	//
	camera -e -displayFilmGate $dfg -displayResolution $dr -displayGateMask $dgm -overscan $os $camera;

	//
	//	Restore parent state.
	//
	setParent $prevParent;
}

//
// Description:
//		Generic procedure to create menus with commands taking cameras
//	into account.
//
global proc imageWindowMakeCameraAction
 ( string	$subMenuName,
   string	$panelName,
   string	$commandeName )
{
	popupMenu -e -deleteAllItems $subMenuName;
	setParent -m $subMenuName;

	//
	//	Get the current model panel and then get the image view resolution.
	//
	string	$camera = `getCurrentCamera`;
	string	$currentPanel = `getCameraPanel( $camera )`;
	int		$res[];

	$res = `getTestResolution( $currentPanel )`;

	//
	//	Build the command.
	//
	string	$command;

	if( $commandeName == "image" )
		$command = ($commandeName+" -x "+$res[0]+" -y "+$res[1]+" ");
	else if( $commandeName == "snapshot" )
		$command = ("imageWindowTakeSnapshot "+$res[0]+" "+$res[1]+" ");

	//
	//	Build items.
	//
	if( size($currentPanel) != 0 )
	{
		string $cameraLabel = (uiRes("m_imageWindowPanel.kCurrentCamera"));
		$cameraLabel = `format -s $camera $cameraLabel`;
		menuItem -label $cameraLabel -c ($command+$camera);
		menuItem -divider true ;
	}

	int		$testRes = `optionVar -query imageViewTestResolution`;

	//
	//	List all perspective cameras
    //
    string	$persps[] = `listCameras -perspective`;

	//
	//	Then we have to use panel resolutions....
	//
	if( $testRes == 0 )
	{
		string	$panel;

		for( $i in $persps )
		{
			$panel = `getCameraPanel( $i )`;
			$res = `getTestResolution( $panel )`;
			if( $commandeName == "image" )
				$command = ($commandeName+" -x "+$res[0]+" -y "+$res[1]+" ");
			else if( $commandeName == "snapshot" )
				$command = ("imageWindowTakeSnapshot "+$res[0]+" "+$res[1]+" ");
			menuItem -label $i -c ($command+$i);
		}
	}
	else
	{
		for( $i in $persps )
			menuItem -label $i -c ($command+$i);
	}

	menuItem -divider true;

	//
	//	List all orthographic cameras
    //
    string	$orthos[] = `listCameras -orthographic`;

	//
	//	Then we have to use panel resolutions....
	//
	if( $testRes == 0 )
	{
		string	$panel;

		for( $i in $orthos )
		{
			$panel = `getCameraPanel( $i )`;
			$res = `getTestResolution( $panel )`;
			if( $commandeName == "image" )
				$command = ($commandeName+" -x "+$res[0]+" -y "+$res[1]+" ");
			else if( $commandeName == "snapshot" )
				$command = ("imageWindowTakeSnapshot "+$res[0]+" "+$res[1]+" ");
			menuItem -label $i -c ($command+$i);
		}
	}
	else
	{
		for( $i in $orthos )
			menuItem -label $i -c ($command+$i);
	}
}

//
// Description:
//
//
global proc showImageGlobals()
{
    string $globals[] = `ls -renderGlobals`;
    showEditor $globals[0];
}

//---------------------------------------------------------------------------//
//							HELPER PROCEDURES
//---------------------------------------------------------------------------//

//
//	This procedure tears (if needed) the imageView panel off
//	and sets the size of the current modelView.
//	When this is done, a image is launch with the size
//	of the imageView panel
//
global proc launchImageOutside()
{
	//
	// get the current 3d panel
	//
	string $currentPanel = `getPanel -wf`;

	//
	//	Checks whether the current panel is a model panel...
	//
	if( `getPanel -to $currentPanel` != "modelPanel" )
	{
		string $ok = (uiRes("m_imageWindowPanel.kOk"));
		confirmDialog -message (uiRes("m_imageWindowPanel.kSelectImageMessage")) -button $ok -defaultButton $ok;
		return;
	}

	//
	// Get the image window panel.
	//
	string $imagePanel = `getImageWindowPanel`;

	//
	// If not tore off, do It !
	//
	if( !`scriptedPanel -q -tearOff $imagePanel` )
	{
		scriptedPanel -e -tearOff $imagePanel;
	}

	//
	//	Now gets the right resolution.
	//
	int		$res[] = `getTestResolution( $currentPanel )`;

	//
	//	If the image view is too small, resize it.
	//
	string	$imageWindowControl = `scriptedPanel -q -control $imagePanel`;
	string	$imageWindow;
	string	$buffer[];

	tokenize( $imageWindowControl, "|", $buffer );
	$imageWindow = $buffer[0];

	int		$width = `control -q -w $imageWindowControl`;
	int		$height = `control -q -h $imageWindowControl`;

	$width -= 40;
	$height -= 60;

	if( $width < $res[0] || $height < $res[1] )
	{
		$width = $res[0] + 40;
		$height = $res[1] + 60;
		window -e -w $width -h $height -retain $imageWindow;
	}

	//
	//	Image the current camera panel at the test resolution...
	//
	showWindow $imageWindow;
	image -x $res[0] -y $res[1];
}

//---------------------------------------------------------------------------//
//
//	Redo last image.
//
global proc redoLastImage( int $forceRegion )
{
	//
	//	Get the current camera of the image window panel.
	//
	string	$camera = `getCurrentCamera`;
	string	$panel = `getCameraPanel( $camera )`;
	int		$res[] = `getTestResolution( $panel )`;
	string	$globals[] = `ls -renderGlobals`;

	//
	//	Check whether we have to take the region into account.
	//
	if( $forceRegion )
	{
		if( size($globals[0]) > 0 )
		{
			$forceRegion = 1;
			setAttr ($globals[0] + ".urr") true;

			//
			//	Show the region.
			//
			$imagePanel = `getImageWindowPanel`;
			imageWindowEditor -e -showRegion $res[0] $res[1] $imagePanel;
		}
		else
		{
			$forceRegion = 0;
		}
	}
	//
	//	Force the urr flag to be set to false.
	//
	else if( size($globals[0]) > 0 )
		setAttr ($globals[0] + ".urr") false;

	//
	//	GO...
	//
	image -x $res[0] -y $res[1] $camera;

	//
	//	Unset region flag if needed.
	//
	if( $forceRegion )
	{
		setAttr ($globals[0] + ".urr") false;
	}
}

//
//	This one can be used by hotkeys to check whether the image view is
//	visible or not before calling redoLastImage procedure.
//
global proc checkAndRedoLastImage( int $forceRegion )
{
	if( `raiseImageViewWindow` == 1 )
	{
		redoLastImage( $forceRegion );
		return;
	}

	//
	//	Then it may be nested in the main maya panel...
	//
	$imagePanel = `getImageWindowPanel`;

	for( $i in `getPanel -vis` )
	{
		if( $i == $imagePanel )
		{
			redoLastImage( $forceRegion );
			return;
		}
	}

	//
	//	Otherwise, make it appear...
	//
	scriptedPanel -e -tearOff $imagePanel;

	redoLastImage( $forceRegion );
}

//---------------------------------------------------------------------------//
//						Low level helper procedures
//---------------------------------------------------------------------------//

//
// Description:
//
//
global proc int[] getGlobalsResolution()
{
	//
	//	Image globals item.
	//
	string	$globals[] = `ls -renderGlobals`;
	int		$res[2] = { 320, 240 };

	if( size($globals[0]) > 0 )
	{
		string	$connect[] = `listConnections ($globals[0] + ".resolution")`;

		if( size($connect[0]) > 0 )
		{
			$res[0] = `getAttr ($connect[0] + ".width" )`;
			$res[1] = `getAttr ($connect[0] + ".height" )`;
		}
	}

	return $res;
}

//
// Description:
//
//
global proc int[] getTestResolution( string $panel )
{
	int		$res[2] = { 320, 240 };

	if( `optionVar -exists imageViewTestResolution` )
	{
		$testRes = `optionVar -query imageViewTestResolution`;

		if( $testRes == 0 )
		{
			if( size($panel) )
			{
				string	$modelViewControl = `modelEditor -q -control $panel`;

				if( size($modelViewControl) && `control -ex $modelViewControl` )
				{
					$res[0] = `control -q -w $modelViewControl`;
					$res[1] = `control -q -h $modelViewControl`;
				}
			}
		}
		else
		{
			string	$globals[] = `ls -renderGlobals`;

			if( size($globals[0]) > 0 )
			{
				string	$connect[] = `listConnections ($globals[0] + ".resolution")`;

				if( size($connect[0]) > 0 )
				{
					$res[0] = `getAttr ($connect[0] + ".width" )`;
					$res[1] = `getAttr ($connect[0] + ".height" )`;

					if( $testRes == 2 )
					{
						$res[0] /= 2;
						$res[1] /= 2;
					}
					else if( $testRes == 3 )
					{
						$res[0] /= 4;
						$res[1] /= 4;
					}
					else if( $testRes == 4 )
					{
						$res[0] /= 10;
						$res[1] /= 10;
					}
				}
			}
		}
	}

	return $res;
}

//
// Description:
//		Returns the image window editor, creates it if needed.
//
global proc string getImageWindowPanel()
{
	string $imagePanel;
	string $imagePanels[] = `getPanel -scriptType "imageWindowPanel"`;

	if( size($imagePanels) == 0 )
	{
		$imagePanel = `scriptedPanel -type "imageWindowPanel" -unParent`;
		scriptedPanel -e -lable `interToUI $imagePanel` $imagePanel;
	}
	else
	{
		$imagePanel = $imagePanels[0];
	}

	return $imagePanel;
}

//
// Description:
//
//
global proc string getImageWindowPanelFormLayout()
{
	string	$form, $sub, $child;
	string	$panel = `getImageWindowPanel`;
	int		$size = size($panel);

	for( $form in `lsUI -cl` )
	{
		$sub = substring($form,1,$size);

		if( $sub == $panel && `formLayout -exists $form` )
		{
			for( $child in `formLayout -q -ca $form` )
			{
				if( $child == $panel )
					return $form;
			}
		}
	}

	return ($panel+"WindowPanelLayout_mainForm");
}

//
// Description:
//		Returns the current camera stored by the image window editor.
//	returns the current camera view if nothing stored in the image view or
//	the first camera.
//
global proc string getCurrentCamera()
{
	string	$null = "";
	return $null;
}

//
// Description:
//
//
global proc string getCameraPanel( string $camera )
{
	string	$null = "";
	return $null;
}

//
// Description:
//	Raise the image view window if exists, then return 1.
//	Return 0 otherwise.
//
global proc int raiseImageViewWindow()
{
	//
	//	Look for the imageViewWindow and pop it up if it exists.
	//
	for( $i in `lsUI -windows` )
	{
		if( $i == "imageViewWindow" )
		{
			showWindow $i;
			return 1;
		}
	}

	return 0;
}
