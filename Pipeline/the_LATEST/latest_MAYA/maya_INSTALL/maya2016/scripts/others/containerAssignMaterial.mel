// Copyright (C) 1997-2014 Autodesk, Inc., and/or its licensors.
// All rights reserved.
//
// The coded instructions, statements, computer programs, and/or related
// material (collectively the "Data") in these files contain unpublished
// information proprietary to Autodesk, Inc. ("Autodesk") and/or its licensors,
// which is protected by U.S. and Canadian federal copyright law and by
// international treaties.
//
// The Data is provided for use exclusively by You. You have the right to use,
// modify, and incorporate this Data into other products for purposes authorized 
// by the Autodesk software license agreement, without fee.
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND. AUTODESK
// DOES NOT MAKE AND HEREBY DISCLAIMS ANY EXPRESS OR IMPLIED WARRANTIES
// INCLUDING, BUT NOT LIMITED TO, THE WARRANTIES OF NON-INFRINGEMENT,
// MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE, OR ARISING FROM A COURSE 
// OF DEALING, USAGE, OR TRADE PRACTICE. IN NO EVENT WILL AUTODESK AND/OR ITS
// LICENSORS BE LIABLE FOR ANY LOST REVENUES, DATA, OR PROFITS, OR SPECIAL,
// DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES, EVEN IF AUTODESK AND/OR ITS
// LICENSORS HAS BEEN ADVISED OF THE POSSIBILITY OR PROBABILITY OF SUCH DAMAGES.

//
//<doc>
//<name containerAssignMaterial>
//
//<synopsis>
//		containerAssignMaterial(string $container, string $object)
//
//<description>
//	This command assigns the object to the shading group found in the
//  container. If there is more than one shading group in the container,
//	the user can control which shading group is used by publishing
//  the shading group as a published node with the name "mainSG".
//
//  If no object is specified, the command will work on the selection.
//
//<returns>
//		none
//
// <flags>
//	string $container the container with the shader
//  string $object the object to associate with the shader, or an empty string to act on selection
//
//<examples>
//		// Associate the selection to the shading group of $containerName
//		containerAssignMaterial $containerName "";
//
//		// Associate the a mesh to the shading group of $containerName
//		containerAssignMaterial $containerName $mesh;
//
//</doc>
//

global
proc containerAssignMaterial(string $container, string $object)
{
	string $shadingGroup;

	// First, see if a shading group is published
	//
	string $boundNodes[] = `containerPublish -q -bn $container`;
	int $ii, $nodeCount = size($boundNodes);
	for ($ii = 0; $ii < $nodeCount; $ii+=2) {
		if ($boundNodes[$ii] == "mainSG") {
			$shadingGroup = $boundNodes[$ii+1];
			break;
		}
	}

	if (size($shadingGroup) == 0) {
		string $members[] = `container -q -nodeList $container`;
		string $sets[] = `ls -type objectSet $members`;
		$nodeCount = size($sets);
		int $shadingGroupCount = 0;
		for ($ii = 0; $ii < $nodeCount; $ii++) {
			string $materialInfo[] = `listConnections -type "materialInfo" ($sets[$ii]+".msg")`;
			if (size($materialInfo) > 0) {
				if ($shadingGroupCount == 0) {
					$shadingGroup = $sets[$ii];
				}
				$shadingGroupCount++;
			}
		}
		if ($shadingGroupCount > 1) {
			string $warnMsg = (uiRes("m_containerAssignMaterial.kMoreThanOneSG"));
			warning($warnMsg);
		}
	}

	if (size($shadingGroup) > 0) {
		string $cmd = ("sets -forceElement \""+$shadingGroup+"\" ");
		if (size($object) > 0) {
			$cmd += $object;
		}
		eval $cmd;
	} else {
		error((uiRes("m_containerAssignMaterial.kFoundNoShadingGroup")));
	}
}
