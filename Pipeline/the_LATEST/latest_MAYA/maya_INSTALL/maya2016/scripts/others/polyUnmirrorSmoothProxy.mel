// Copyright (C) 1997-2014 Autodesk, Inc., and/or its licensors.
// All rights reserved.
//
// The coded instructions, statements, computer programs, and/or related
// material (collectively the "Data") in these files contain unpublished
// information proprietary to Autodesk, Inc. ("Autodesk") and/or its licensors,
// which is protected by U.S. and Canadian federal copyright law and by
// international treaties.
//
// The Data is provided for use exclusively by You. You have the right to use,
// modify, and incorporate this Data into other products for purposes authorized 
// by the Autodesk software license agreement, without fee.
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND. AUTODESK
// DOES NOT MAKE AND HEREBY DISCLAIMS ANY EXPRESS OR IMPLIED WARRANTIES
// INCLUDING, BUT NOT LIMITED TO, THE WARRANTIES OF NON-INFRINGEMENT,
// MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE, OR ARISING FROM A COURSE 
// OF DEALING, USAGE, OR TRADE PRACTICE. IN NO EVENT WILL AUTODESK AND/OR ITS
// LICENSORS BE LIABLE FOR ANY LOST REVENUES, DATA, OR PROFITS, OR SPECIAL,
// DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES, EVEN IF AUTODESK AND/OR ITS
// LICENSORS HAS BEEN ADVISED OF THE POSSIBILITY OR PROBABILITY OF SUCH DAMAGES.

//	Procedure Name:
//		polyUnmirrorSmoothProxy 
//
//	Description:
//		this is the main proc which checks the 
//		selection and calls the appropriate sub proc
//
//	Input Arguments
//
//		These arguments match polyMirror.mel which this script calls
//
//		int $x -1,0,1 mirror axis
//		int $y -1,0,1
//		int $z -1,0,1
//		int $stitch
//			
global proc polyUnmirrorSmoothProxy(int $x, int $y, int $z, int $stitch){
	
	// find selected objects
	// most likely user will have transform node(s) selected
	string $objects[] = `listRelatives -children -type "mesh"`;
	
	// if this is not the case, check if they have components selected
	if (`size $objects` == 0){
		$objects = `listRelatives -parent -type "mesh"`;
		
		// and lastly, is $objects is still 0, they may have selected the shape
		if (`size $objects` == 0){
			$objects = `ls -sl -type "mesh"`;
			
			if (`size $objects` == 0){
				// if still nothing, look for any hilited objects 
				string $hiliteObjects[] = `ls -hl`;
				$objects = `listRelatives -children -type "mesh" $hiliteObjects`;
				 
				// At last, error
				//
				if (`size $objects` == 0){					string $msg = (uiRes("m_polyUnmirrorSmoothProxy.kSelectSmoothProxyError"));
					error ($msg);
				}
			}
		}
	}
	
	// find smoothNode 
	string $smoothNode[] = `listConnections -type "polySmoothProxy" $objects[0]`;
	
	// error if no smooth node connected
	if (`size $smoothNode` == 0){		string $msg = (uiRes("m_polyUnmirrorSmoothProxy.kNoSmoothNodeError"));
		error ($msg); 
	}
	
	//get connections - looking for lo res
	string $lores[] = `listConnections -s 1 -d 0 -sh 1 -type "mesh" $smoothNode[0]`;
	
	//get connections - looking for hi res
	string $hires[] = `listConnections -s 0 -d 1 -sh 0 $smoothNode[0]`;
	
	//delete contruction history from hires and then delete hires
	delete -constructionHistory $hires;
	delete $hires;
	
	//mirror lores
	select -replace $lores[0];
	polyMirror $x $y $z $stitch;
	
	//and delete history
	delete -constructionHistory $lores[0];
	
	//delete other parents if they exist
	//if the user used the full mirror option from smoothProxy 
	//there will be an instance
	string $parents[] = `listRelatives -allParents $lores[0]`;
	if (`size $parents` > 1 ){
		select -replace $parents;
		select -toggle $parents[0];
		delete;
		select -replace $parents[0];
	}
	
	
}