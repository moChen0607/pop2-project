// Copyright (C) 1997-2014 Autodesk, Inc., and/or its licensors.
// All rights reserved.
//
// The coded instructions, statements, computer programs, and/or related
// material (collectively the "Data") in these files contain unpublished
// information proprietary to Autodesk, Inc. ("Autodesk") and/or its licensors,
// which is protected by U.S. and Canadian federal copyright law and by
// international treaties.
//
// The Data is provided for use exclusively by You. You have the right to use,
// modify, and incorporate this Data into other products for purposes authorized 
// by the Autodesk software license agreement, without fee.
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND. AUTODESK
// DOES NOT MAKE AND HEREBY DISCLAIMS ANY EXPRESS OR IMPLIED WARRANTIES
// INCLUDING, BUT NOT LIMITED TO, THE WARRANTIES OF NON-INFRINGEMENT,
// MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE, OR ARISING FROM A COURSE 
// OF DEALING, USAGE, OR TRADE PRACTICE. IN NO EVENT WILL AUTODESK AND/OR ITS
// LICENSORS BE LIABLE FOR ANY LOST REVENUES, DATA, OR PROFITS, OR SPECIAL,
// DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES, EVEN IF AUTODESK AND/OR ITS
// LICENSORS HAS BEEN ADVISED OF THE POSSIBILITY OR PROBABILITY OF SUCH DAMAGES.

//
//
//  ==================== setRigidKeyframe.mel ==========
//
//  SYNOPSIS
//      Create keyframes for the active/passive attribute
//      of rigid bodies.
//
global proc setRigidKeyframe( int $type )
//
//  Description:
//
//    This proc creates keyframes for the active/passive attribute
//    of rigid bodies.  
//
{
	string $selObj[] = `ls -sl`;
    string $parentName;
	int    $isRigid = 0; 
	int    $currentType;
	float  $x, $y, $z;
	float  $rx, $ry, $rz;


	// For each object in the selection list, check to see if
	// and rigid bodies are present.
	//
	for ($i = 0; $i < size( $selObj ); $i++)
	{
		// Get a list of selected items and thier children.
		//
	    string $kids[] = `ls -dag -leaf -showType $selObj[$i]`;

		// Check to see if we have any rigid bodies.
		//
	    for ($j = 0; $j < size( $kids ); $j += 2)
	    {
			// If a rigid body is found process it.
			//
		    if ($kids[$j+1] == "rigidBody")
		    {
				// Indicate that a rigid body has been found.
				//
				$isRigid = 1;

			    string $parentList[] = `listRelatives -p -path $kids[$j]`;

			    $parentName = $parentList[0];

				// Store the translate and rotate of the rigid body.
				// We need to set this value back if we change the rigid body to
				// active.
				//
				string $getAttrString = $parentName + ".translate";
				float $xyz[]    = `getAttr $getAttrString`;
				$getAttrString  = $parentName + ".rotate";
				float $rotate[] = `getAttr $getAttrString`;

				// If we are setting a passive keyframe then we want to set the
				// attribute before we keyframe the position and rotation.  You
				// cannot set a keyframe if the rigid body is active.
				//
				string  $acitveString = $kids[$j] + ".active";
				setAttr $acitveString 0;
				
				// Set the keyframe for the group.
				//
				setKeyframe -at translateX -itt linear -ott linear -v $xyz[0]    $parentName;
				setKeyframe -at translateY -itt linear -ott linear -v $xyz[1]    $parentName;
				setKeyframe -at translateZ -itt linear -ott linear -v $xyz[2]    $parentName;
				setKeyframe -at rotateX    -itt linear -ott linear -v $rotate[0] $parentName;
				setKeyframe -at rotateY    -itt linear -ott linear -v $rotate[1] $parentName;
				setKeyframe -at rotateZ    -itt linear -ott linear -v $rotate[2] $parentName;
				
				// Set the active/passive keyframe.  We want to set the keyframe
				// for the active attribute after we set the translate/rotate 
				// keyframe.  You cannot set a keyframe if the rigid body is
				// active.
				//
				if ( $type == 1 )
				{
					setAttr $acitveString 1;

					// Get the solver for this rigid body.
					//
		    		string $solverName  = `rigidBody -q -solver $kids[$j]`;
					string $getSolverID = $kids[$j] + ".solverId";
					int    $solverID    = `getAttr $getSolverID`;

					// Make sure the active rigid body is set to the correct
					// position and rotation.  We need to set this in the solver
					// else the rigid body will get a new initial state.
					//
					string  $setAttrString = $solverName + ".translate[" + $solverID + "]";
					setAttr $setAttrString $xyz[0] $xyz[1] $xyz[2];
					$setAttrString = $solverName + ".rotate[" + $solverID + "]";
					setAttr $setAttrString $rotate[0] $rotate[1] $rotate[2] ;
				}

		    	setKeyframe -attribute active -ott step -v $type $kids[$j];
				
				break;
			}
		}
	}

	// If no rigid bodies are found then create rigid bodies
	// out of the selected shapes and call this proc again.
	//
	if ($isRigid == 0)
	{
		int $created;

		$created = makeRigidActive( $type );

		if ( $created == 1 )
		{
			setRigidKeyframe( $type );
		}
	}
}



