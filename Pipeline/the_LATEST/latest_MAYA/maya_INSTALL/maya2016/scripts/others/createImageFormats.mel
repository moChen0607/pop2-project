// Copyright (C) 1997-2014 Autodesk, Inc., and/or its licensors.
// All rights reserved.
//
// The coded instructions, statements, computer programs, and/or related
// material (collectively the "Data") in these files contain unpublished
// information proprietary to Autodesk, Inc. ("Autodesk") and/or its licensors,
// which is protected by U.S. and Canadian federal copyright law and by
// international treaties.
//
// The Data is provided for use exclusively by You. You have the right to use,
// modify, and incorporate this Data into other products for purposes authorized 
// by the Autodesk software license agreement, without fee.
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND. AUTODESK
// DOES NOT MAKE AND HEREBY DISCLAIMS ANY EXPRESS OR IMPLIED WARRANTIES
// INCLUDING, BUT NOT LIMITED TO, THE WARRANTIES OF NON-INFRINGEMENT,
// MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE, OR ARISING FROM A COURSE 
// OF DEALING, USAGE, OR TRADE PRACTICE. IN NO EVENT WILL AUTODESK AND/OR ITS
// LICENSORS BE LIABLE FOR ANY LOST REVENUES, DATA, OR PROFITS, OR SPECIAL,
// DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES, EVEN IF AUTODESK AND/OR ITS
// LICENSORS HAS BEEN ADVISED OF THE POSSIBILITY OR PROBABILITY OF SUCH DAMAGES.

//==================================================================
//
// Set up the global arrays that contain the image format extensions.
// This has to be separated from the Menu building
// code, because other areas of Maya need to access these arrays and if
// this is tied into the building of the menus, they can't do this.
//
// NOTE !!!! WARNING !!!!
// If you make a change to the code in this procedure, you also need
// to make the corresponding change in the 'buildImageFormatsMenu' procedure
// of buildImageFormatsMenu.mel.
//
// This code is also called from dynPaintMenus.mel since it may
// be required for PFX canvas saving.
//
//==================================================================
global string $imgExt[];  // This is the actual file extension
global string $imfKey[];  // This is the unique imf keyword

// ADSK_CLR_MGT_BEGIN
global string $imgEXRCompression[]; // This is the compression type for EXR image
global string $imgEXRPixelType[];   // This is the pixel type for EXR image
// ADSK_CLR_MGT_END

// Custom formats, handled though user defined IMF plug-ins
global string $imfPlugInExt[];
global string $imfPlugInKey[];

global proc createImageFormats()
{
	global string $imgExt[];  // This is the actual file extension
	global string $imfKey[];  // This is the unique imf keyword
	global string $imfPlugInExt[];
	global string $imfPlugInKey[];
	
	int $i;

	// These are the default formats that ship with Maya.
	$i =  0; $imgExt[$i] = "gif";  $imfKey[$i] = "gif";
	$i =  1; $imgExt[$i] = "pic";  $imfKey[$i] = "si";
	$i =  2; $imgExt[$i] = "rla";  $imfKey[$i] = "rla";
	$i =  3; $imgExt[$i] = "tif";  $imfKey[$i] = "tif";
	$i =  4; $imgExt[$i] = "tif";  $imfKey[$i] = "tif";
	$i =  5; $imgExt[$i] = "sgi";  $imfKey[$i] = "sgi";
	$i =  6; $imgExt[$i] = "als";  $imfKey[$i] = "als";
	$i =  7; $imgExt[$i] = "iff";  $imfKey[$i] = "maya";
	$i =  8; $imgExt[$i] = "jpeg"; $imfKey[$i] = "jpg";
	$i =  9; $imgExt[$i] = "eps";  $imfKey[$i] = "eps";
	$i = 10; $imgExt[$i] = "iff";  $imfKey[$i] = "maya";
	$i = 11; $imgExt[$i] = "cin";  $imfKey[$i] = "cin";
	$i = 12; $imgExt[$i] = "yuv";  $imfKey[$i] = "yuv";
	// 14-18 are not used any more
	$i = 19; $imgExt[$i] = "tga";  $imfKey[$i] = "tga";
	$i = 20; $imgExt[$i] = "bmp";  $imfKey[$i] = "bmp";
	$i = 22; $imgExt[$i] = "mov";  $imfKey[$i] = "qt";
	$i = 31; $imgExt[$i] = "psd";  $imfKey[$i] = "psd";
	$i = 32; $imgExt[$i] = "png";  $imfKey[$i] = "png";
	$i = 35; $imgExt[$i] = "dds";  $imfKey[$i] = "dds";
	$i = 36; $imgExt[$i] = "psd";  $imfKey[$i] = "psdLayered";
	
	// ADSK_CLR_MGT_BEGIN
	$i = 40; $imgExt[$i] = "exr";  $imfKey[$i] = "exr";

	global string $imgEXRCompression[]; // This is the compression type for EXR image
	global string $imgEXRPixelType[];   // This is the pixel type for EXR image
	
	$imgEXRCompression[0] = (uiRes("m_createImageFormats.kEXRCompressionNone"));
	$imgEXRCompression[1] = "RLE";
	$imgEXRCompression[2] = "ZIPS";
	$imgEXRCompression[3] = "ZIP";	
	$imgEXRCompression[4] = "PIZ";
	$imgEXRCompression[5] = "PXR24";
	$imgEXRCompression[6] = "B44";
	
	$imgEXRPixelType[0] = (uiRes("m_createImageFormats.kEXRPixelTypeFloat"));
	$imgEXRPixelType[1] = (uiRes("m_createImageFormats.kEXRPixelTypeHalf"));
	// ADSK_CLR_MGT_END

	if (`about -mac`)	{
		$i = 30; $imgExt[$i] = "pntg"; $imfKey[$i] = "pntg";
		$i = 33; $imgExt[$i] = "pict"; $imfKey[$i] = "pict";
		$i = 34; $imgExt[$i] = "qtif"; $imfKey[$i] = "qtif";
	}
	$i = 13; $imgExt[$i] = "sgi";  $imfKey[$i] = "sgi";
	if (`about -nt`) {
		$i = 23; $imgExt[$i] = "avi"; $imfKey[$i]  = "avi";
	}

	// Now register the formats found in IMF plug-ins
	string $ext, $key;
	int $size;
	int $last = 0;
	global string $imfPlugins[];
 	$size = size($imfKey);
	$imfPlugins = sort(`imfPlugins -q`);

	for ($i=0; $i<size($imfPlugins); $i++) {
		$key = `imfPlugins -q -key $imfPlugins[$i]`;
		if (($key == "") || (!(`imfPlugins -q -writeSupport $key`))) {
			continue;
		}

		$found = 0;
		for ($j=0; $j<$size; $j++) {
			if ($key == $imfKey[$j]) { $found = 1; break; }
		}
		if (!$found) {
			for ($j=0; $j<$last; $j++) {
				if ($key == $imfPlugInKey[$j]) { $found = 1; break; }
			}
		}

		if (! $found) { 
			// imf info is not present in the above hardcoded $imfKey 
			// array.  Hence append imf values to $imgExt, $imfKey and 
			// $imfExtNum arrays.
			//
			$ext = `imfPlugins -q -ext $imfPlugins[$i]`;
			int $sizeOfExt = size($ext);
			$imfPlugInExt[$last] = `substring $ext 2 $sizeOfExt`; // remove leading .
			$imfPlugInKey[$last] = $key;
			$last++;
		}
	}
}
