// Copyright (C) 1997-2014 Autodesk, Inc., and/or its licensors.
// All rights reserved.
//
// The coded instructions, statements, computer programs, and/or related
// material (collectively the "Data") in these files contain unpublished
// information proprietary to Autodesk, Inc. ("Autodesk") and/or its licensors,
// which is protected by U.S. and Canadian federal copyright law and by
// international treaties.
//
// The Data is provided for use exclusively by You. You have the right to use,
// modify, and incorporate this Data into other products for purposes authorized 
// by the Autodesk software license agreement, without fee.
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND. AUTODESK
// DOES NOT MAKE AND HEREBY DISCLAIMS ANY EXPRESS OR IMPLIED WARRANTIES
// INCLUDING, BUT NOT LIMITED TO, THE WARRANTIES OF NON-INFRINGEMENT,
// MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE, OR ARISING FROM A COURSE 
// OF DEALING, USAGE, OR TRADE PRACTICE. IN NO EVENT WILL AUTODESK AND/OR ITS
// LICENSORS BE LIABLE FOR ANY LOST REVENUES, DATA, OR PROFITS, OR SPECIAL,
// DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES, EVEN IF AUTODESK AND/OR ITS
// LICENSORS HAS BEEN ADVISED OF THE POSSIBILITY OR PROBABILITY OF SUCH DAMAGES.

//
//
//  Creation Date:  3 April 1997
//
//  Description:
//      Implement and provide access to the common elements of the 
//		option box window.
//

//	NOTE:
//		If you plan on modifying this file be aware that there are
//		still the following option boxes that rely on the incredibly 
//		old getStandardWindow() interface.
//
//		As of Maya3.0 28jan00:
//			performShowResults.mel      Graph Editor Panel: View->Show Results[]
//			performBakeResults.mel      Graph Editor Panel: Curves->Bake Channel[]
//			performSimplify.mel         Graph Editor Panel: Curves->Simplify Curve[]
//			performPlayblast.mel        Window->Playblast...[]
//			performDetachSkin.mel       Skin->Detach Skin[]
//			performCutKeyArgList.mel    Edit->Keys->Cut Keys[]
//			performCopyKeyArgList.mel   Edit->Keys->Copy Keys[]
//			performPasteKeyArgList.mel  Edit->Keys->Paste Keys[]
//			performClearKeyArgList.mel  Edit->Keys->Delete Keys[]
//			performScaleKeyArgList.mel  Edit->Keys->Scale Keys[]
//			performSnapKeyArgList.mel   Edit->Keys->Snap Keys[]
//			fileOptions.mel             File->Open Scene...[]
//			                            File->Save Scene As...[]
//			                            File->Import...[]
//			                            File->Export All...[]
//			                            File->Export Selection...[]
//			                            File->Create Reference...[]
//
//		getStandardWindow() does end up calling into getOptionBox(),
//		however the set up of the UI for these option boxes is a little
//		different so be sure to test that these options boxes still
//		look and work as expected.
//
//		-bwk 28jan00
//

//
//  Procedure Name:
//      updateOptionBoxEditMenu
//
//  Description:
//      Update the option box's Edit menu.
//
//		This situation arises when the Option Box is already created and
//		the user selects another command's or tool's option box menu item.
//
//		Take this opportunity to update the enable state of the Edit menu
//		items.
//
//  Input Arguments:
//      The option box window name.
//
//  Return Value:
//      None
//
proc updateOptionBoxEditMenu(string $parent) {

	//	Global variables...
	//
	global string $gOptionBoxActionToolItem;
	global string $gOptionBoxActionToolItemCB;

	global string $gOptionBoxEditMenu;
	global string $gOptionBoxEditMenuToolItem;
	global string $gOptionBoxEditMenuActionItem;
	
	//	Make sure the menu and its menu items exist before trying to
	//	edit them.
	//
	if (!`menu -exists $gOptionBoxEditMenu` ||
		!`menuItem -exists $gOptionBoxEditMenuToolItem` ||
		!`menuItem -exists $gOptionBoxEditMenuActionItem`) {
		return;
	}
	
	if ("" != $gOptionBoxActionToolItem) {
		//
		//	Enable the menu and items, also attach the appropriate commands
		//	to the menu items.
		//
		menuItem -edit -enable true
			-radioButton `optionVar -q $gOptionBoxActionToolItem`
			-command ("optionVar -iv " + $gOptionBoxActionToolItem + " 1; " +
				$gOptionBoxActionToolItemCB)
			$gOptionBoxEditMenuToolItem;
		menuItem -edit -enable true
			-radioButton (!`optionVar -q $gOptionBoxActionToolItem`)
			-command ("optionVar -iv " + $gOptionBoxActionToolItem + " 0; " +
				$gOptionBoxActionToolItemCB)
			$gOptionBoxEditMenuActionItem;
		
		$gOptionBoxActionToolItem = "";
		
	} else {
		//
		//	Disable the menu and items.
		//
		menuItem -edit -enable false $gOptionBoxEditMenuToolItem;
		menuItem -edit -enable false $gOptionBoxEditMenuActionItem;
	}
}

//
//  Procedure Name:
//      updateOptionBox
//
//  Description:
//      Update the option box content (controls, menus, etc...) to reflect
//		the new command/tool.
//
//		This situation arises when the Option Box is already created and
//		the user selects another command's or tool's option box menu item.
//
//		Take this opportunity to update (for example enable/disable controls
//		or menu items).
//
//  Input Arguments:
//      The option box window name.
//
//  Return Value:
//      None
//
proc updateOptionBox(string $optionBox)
{
	//	No controls to update.  Just update the enable state of the "Edit"
	//	menu.
	//
	updateOptionBoxEditMenu($optionBox);
}

//
//  Procedure Name:
//      createOptionBoxEditMenu
//
//  Description:
//      Creates the option box 'Edit' menu.
//
//  Input Arguments:
//      The option box window name.
//
//  Return Value:
//      None
//
proc createOptionBoxEditMenu(string $parent) {

	//	Global variables...
	//
	global string $gOptionBoxEditMenu;
	global string $gOptionBoxEditMenuSaveItem;
	global string $gOptionBoxEditMenuResetItem;
	global string $gOptionBoxEditMenuToolItem;
	global string $gOptionBoxEditMenuActionItem;
	
	setParent $parent;

	//	Create the 'Edit' menu.
	//
	$gOptionBoxEditMenu = `menu -label (uiRes("m_getOptionBox.kCreateEditMenu"))`;

	//	Create the menu items.
	//
	$gOptionBoxEditMenuSaveItem = `menuItem -label (uiRes("m_getOptionBox.kCreateSaveSettings"))`;
	$gOptionBoxEditMenuResetItem = `menuItem -label (uiRes("m_getOptionBox.kCreateResetSettings"))`;
	menuItem -divider true;

	radioMenuItemCollection;
	$gOptionBoxEditMenuToolItem = `menuItem 
		-radioButton true -label (uiRes("m_getOptionBox.kCreateAsTool"))`;
	$gOptionBoxEditMenuActionItem = `menuItem 
		-radioButton true -label (uiRes("m_getOptionBox.kCreateAsAction"))`;

	updateOptionBoxEditMenu($parent);
}

//
//  Procedure Name:
//      createOptionBoxHelpMenu
//
//  Description:
//      Creates the option box 'Help' menu.
//
//  Input Arguments:
//      The option box window name.
//
//  Return Value:
//      None
//
proc createOptionBoxHelpMenu(string $parent) {

	//	Global variables...
	//
	global string $gOptionBoxHelpItem;

	setParent $parent;

	//	Create the 'Help' menu.  Be sure to indicate that this is
	//	the 'Help' menu so that it appears right justified in the
	//	menu bar.
	//
	menu -label (uiRes("m_getOptionBox.kCreateHelpMenu")) -helpMenu 1;

	//	Create the 'Help' menu items.
	//
	$gOptionBoxHelpItem = `menuItem -label (uiRes("m_getOptionBox.kCreateNoHelpCurrentlyAvailable")) -enableCommandRepeat false`;
}

//
//  Procedure Name:
//      createOptionBoxMenus
//
//  Description:
//      Creates the option box menus.
//
//  Input Arguments:
//      The option box window name.
//
//  Return Value:
//      None.
//
proc createOptionBoxMenus(string $parent) {

	//	Create the option box menus.  For additional menus add
	//	similar procedure calls, for example:
	//
	//	createOptionBoxFileMenu($parent);
	//	createOptionBoxEditMenu($parent);
	//
	createOptionBoxEditMenu($parent);
	createOptionBoxHelpMenu($parent);
}

//
//  Procedure Name:
//      createOptionBox
//
//  Description:
//      Creates the common UI elements for the option box window.
//
//  Input Arguments:
//      None.
//
//  Return Value:
//      The name of the option box window.
//
proc string createOptionBox() 
{
    global string $gOptionBox;    
    if (`window -exists $gOptionBox`) 
    {
        deleteUI -window $gOptionBox;
    }

	//	Global variables...
	//
	global string $gOptionBoxTabLayout;
	global string $gOptionBoxApplyAndCloseBtn;
	global string $gOptionBoxApplyBtn;
	global string $gOptionBoxResetBtn;
	global string $gOptionBoxCloseBtn;
	global string $gOptionBoxSaveBtn;
	global string $gOptionBoxOptions;

	//	Create the option box window.
	//
	$gOptionBox = `window -menuBar 1 -iconName (uiRes("m_getOptionBox.kCreateOptions")) -widthHeight 546 350 OptionBoxWindow`;
	
	// Create a script job, so every time window is closed, we save its size
	scriptJob -uiDeleted $gOptionBox "saveOptionBoxSize()";

	//	Create the menu bar.
	//
	createOptionBoxMenus($gOptionBox);

	//	Create the common UI elements.
	//
	string $form = `formLayout`;

	//	To reduce flicker when changing the option box contents
	//	use a tab layout.  Create new UI in the hidden tab, leaving
	//	the current option box contents visible until the new UI is
	//	created.  When creation of the new UI is complete then the 
	//	hidden tab will become the current one and the old option box
	//	UI will be deleted.
	//
	$gOptionBoxTabLayout = `tabLayout -tabsVisible 0`;

	// Make the minimum height of the tab layout as small as possible
	// so that when the window is scaled down, the common option box
	// buttons do not overlap the contents of the option box.
	tabLayout -e -height 1 $gOptionBoxTabLayout;

		//	Create two children for the tab layout.
		//	
		formLayout;
			setParent ..;
		formLayout;
			setParent ..;
		setParent ..;

	//	Create a layout containing the common option box buttons.
	//	Force the buttons to have a common width, this will not only
	//	look better but also allow the buttons to be centred in the
	//	window.
	//
	string $buttonForm = `formLayout`;
	int $buttonHeight = 26;
	$gOptionBoxApplyBtn = `button -recomputeSize 0 -height $buttonHeight`;
	$gOptionBoxResetBtn = `button -recomputeSize 0 -height $buttonHeight`;
	$gOptionBoxCloseBtn = `button -recomputeSize 0 -height $buttonHeight`;
	$gOptionBoxSaveBtn = `button -recomputeSize 0 -height $buttonHeight`;

	if ("" == match ("noApplyAndClose", $gOptionBoxOptions))
	{
		$gOptionBoxApplyAndCloseBtn = `button -recomputeSize 0 -height $buttonHeight`;
	}
	else
	{
		$gOptionBoxApplyAndCloseBtn = "";
	}

	//	Apply attachments to the buttons so that they appear centred 
	//	in the window.
	//
	int $space = 4; // Space between buttons.
	if ("" != $gOptionBoxApplyAndCloseBtn)
	{
		formLayout -edit
			-numberOfDivisions 100

			-attachForm     $gOptionBoxApplyAndCloseBtn "top"    0
			-attachForm     $gOptionBoxApplyAndCloseBtn "left"	 0
			-attachForm     $gOptionBoxApplyAndCloseBtn "bottom" 0
			-attachPosition $gOptionBoxApplyAndCloseBtn "right"  ($space/2) 33

			-attachForm     $gOptionBoxApplyBtn         "top"    0
			-attachPosition $gOptionBoxApplyBtn         "left"	 ($space/2) 33
			-attachForm     $gOptionBoxApplyBtn         "bottom" 0
			-attachPosition $gOptionBoxApplyBtn         "right"  ($space/2) 67

			-attachForm     $gOptionBoxCloseBtn         "top"    0
			-attachPosition $gOptionBoxCloseBtn         "left"   ($space/2) 67
			-attachForm     $gOptionBoxCloseBtn         "bottom" 0
			-attachForm     $gOptionBoxCloseBtn         "right"  0
			$buttonForm;
	}
	else
	{
		formLayout -edit
			-numberOfDivisions 100

			-attachForm     $gOptionBoxApplyBtn         "top"    0
			-attachForm     $gOptionBoxApplyBtn         "left"	 0
			-attachForm     $gOptionBoxApplyBtn         "bottom" 0
			-attachPosition $gOptionBoxApplyBtn         "right"  ($space/2) 50

			-attachForm     $gOptionBoxCloseBtn         "top"    0
			-attachPosition $gOptionBoxCloseBtn         "left"   ($space/2) 50
			-attachForm     $gOptionBoxCloseBtn         "bottom" 0
			-attachForm     $gOptionBoxCloseBtn         "right"  0
			$buttonForm;
	}

	//	Apply attachments to the tab layout containing the option box
	//	UI, the separator and the button layout.
	//
	$space = 5; // Space between tabs, separator and button layout.
	formLayout -edit
		-attachForm    $gOptionBoxTabLayout "top"    0
		-attachForm    $gOptionBoxTabLayout "left"   0
		-attachControl $gOptionBoxTabLayout "bottom" $space $buttonForm
		-attachForm    $gOptionBoxTabLayout "right"  0

		-attachNone    $buttonForm          "top"
		-attachForm    $buttonForm          "left"   $space
		-attachForm    $buttonForm          "bottom" $space
		-attachForm    $buttonForm          "right"  $space
		$form;

	return $gOptionBox;
}

//
//  Procedure Name:
//      saveOptionBoxSize
//
//  Description:
//      Saves current option box width and height.
//
//  Input Arguments:
//      None.
//
//  Return Value:
//      None.
//
global proc saveOptionBoxSize()
{
	global string $gOptionBox;
	global string $gOptionBoxHelpTag;
	
	//  Use help tag to save dimensions of current option box,
	//	so we have a unique option var per option box.
	//
	if($gOptionBoxHelpTag != "" ) {
		if(`window -exists $gOptionBox`) {
			// This is the case when option box switches "on fly" - new option box selected without closing window for previous one.
			int $width, $height;
			$width = `window -query -width $gOptionBox`;
			$height = `window -query -height $gOptionBox`;
			// For windows and linux,
			// If there is dpi scaling, querying the width and height will be multiplied
			// by dpi scaling value. So we need to divide the width and height by dpi 
			// scaling value to get the right size for creating new window.
			// IMPORTANT: In the future, if the behavior changes (if querying
			// width and height returns non-scaled value), then this script has
			// to be updated accordingly. 
			if (!`about -mac`){
				float $scaling = `mayaDpiSetting -q -rsv`;
				$width = $width / $scaling;
				$height = $height / $scaling;
			}
			optionVar 
				-intValue 		("optionBoxDimensions" + $gOptionBoxHelpTag)	$width
				-intValueAppend	("optionBoxDimensions" + $gOptionBoxHelpTag)	$height;
		} else {
			// This is the case when we called from script job, meaning window is gone, so get it's size from window preferences.
			// check whether the windowPref exists 
			if(`windowPref -exists $gOptionBox`)
			{
				int $width, $height;
				$width = `windowPref -query -width $gOptionBox`;
				$height = `windowPref -query -height $gOptionBox`;
				// Dpi scaling, the same as above.
				if (!`about -mac`){
					float $scaling = `mayaDpiSetting -q -rsv`;
					$width = $width / $scaling;
					$height = $height / $scaling;
				}
			   optionVar -intValue			("optionBoxDimensions" + $gOptionBoxHelpTag) $width
					  -intValueAppend	("optionBoxDimensions" + $gOptionBoxHelpTag) $height;
			}
			
		}
	}
}

//
//  Procedure Name:
//      restoreOptionBoxSize
//
//  Description:
//      Sets current option box width and height to saved values.
//		If values are not saved, then use the default ones.
//
//  Input Arguments:
//      None.
//
//  Return Value:
//      None.
//
proc restoreOptionBoxSize()
{
	global string $gOptionBox;
	global string $gOptionBoxHelpTag;
	
	if(`window -exists $gOptionBox`) {
		if($gOptionBoxHelpTag != "" && `optionVar -exists ("optionBoxDimensions" + $gOptionBoxHelpTag)` ){
			int $dim[] = `optionVar -query ("optionBoxDimensions" + $gOptionBoxHelpTag)`;
			window -edit -widthHeight $dim[0] $dim[1] $gOptionBox; 
		} else {
			window -edit -widthHeight 546 350 $gOptionBox;
		}
	}
}

//
//  Procedure Name:
//      getOptionBox
//
//  Description:
//      Create, if necessary, and return the option box window.
//		More specifically, this procedure returns the name of the 
//		control layout that additional UI may be added to for the
//		purpose of customizing the option box.
//
//  Input Arguments:
//      None.
//
//  Return Value:
//      The name of control layout to which additional UI may be
//		added.
//
global proc string getOptionBox() {

	//	Global variables...
	//
	global string $gOptionBox;
	global string $gOptionBoxTabLayout;
	global string $gOptionBoxApplyAndCloseBtn;
	global string $gOptionBoxApplyBtn;
	global string $gOptionBoxResetBtn;
	global string $gOptionBoxCloseBtn;
	global string $gOptionBoxSaveBtn;
	global string $gOptionBoxHelpTag;
	global string $gOptionBoxOptions;
    global string $gLastUsedOptionBoxOptions;

	//	Create the option box window if necessary.
	//
	if (`window -exists $gOptionBox` &&
        $gLastUsedOptionBoxOptions == $gOptionBoxOptions) 
    {
	
		// Save current window size for future use
		saveOptionBoxSize();

		//	Option box already exists.  Update the option box content 
		//	(controls and menus) to reflect the new command/tool.
		//
		updateOptionBox($gOptionBox);
    }
	else 
    {
		//	Option box doesn't exist yet, create it.
		//
		createOptionBox(); 
	}

	//	Reset the default state of the buttons.
	//
	button	-edit -enable 1 -visible 1 
			-label (uiRes("m_getOptionBox.kGetApply")) 
			$gOptionBoxApplyBtn;
	button	-edit -enable 1 -visible 0 
			-label (uiRes("m_getOptionBox.kGetReset")) 
			$gOptionBoxResetBtn;
	button	-edit -enable 1 -visible 1 
			-label (uiRes("m_getOptionBox.kGetClose"))
			-command "hideOptionBox" $gOptionBoxCloseBtn;
	button	-edit -enable 1 -visible 0 
			-label (uiRes("m_getOptionBox.kGetSave")) 
			$gOptionBoxSaveBtn;

	//	Remove any dim conditions set on these buttons.
	//
	dimWhen -clear $gOptionBoxApplyBtn;
	dimWhen -clear $gOptionBoxResetBtn;
	dimWhen -clear $gOptionBoxCloseBtn;
	dimWhen -clear $gOptionBoxSaveBtn;

	if ("" != $gOptionBoxApplyAndCloseBtn)
	{
		button -edit -enable 1 -visible 1 -label "" -command ("") 
			$gOptionBoxApplyAndCloseBtn;
		dimWhen -clear $gOptionBoxApplyAndCloseBtn;
	}

	//  Reset the help tag
	//
	$gOptionBoxHelpTag = "";

	//	Get the children of the tab layout.
	//
	string $tab[] = `tabLayout -query -childArray $gOptionBoxTabLayout`;
	string $returnTab = "";

	//	Determine the hidden tab.  Return the hidden tab so that the user
	//	does not see the option box UI being created.  Once the UI is created
	//	the hidden tab will become the active one.
	//
	int $currentTabIndex = `tabLayout -query -selectTabIndex $gOptionBoxTabLayout`;

	//	Be sure to constuct the layout's long name to avoid a possible
	//	naming conflict.
	//
	if ($currentTabIndex == 1) {
		$returnTab = ($gOptionBoxTabLayout + "|" + $tab[1]);
	} else {
		$returnTab = ($gOptionBoxTabLayout + "|" + $tab[0]);
	}

    $gLastUsedOptionBoxOptions = $gOptionBoxOptions;
	$gOptionBoxOptions = "";

	return $returnTab;
}

//
//  Procedure Name:
//      showOptionBox
//
//  Description:
//      Make the option box visible to the user.
//
//  Input Arguments:
//      None.
//
//  Return Value:
//      None.
//
global proc showOptionBox() {

	//	Global variables...
	//
	global string $gOptionBox;
	global string $gOptionBoxTabLayout;
	global string $gOptionBoxApplyAndCloseBtn;
	global string $gOptionBoxApplyBtn;
	global string $gOptionBoxSaveBtn;
	global string $gOptionBoxResetBtn;
	global string $gOptionBoxEditMenuSaveItem;
	global string $gOptionBoxEditMenuResetItem;
	global string $gOptionBoxHelpTag;

	if (`window -exists $gOptionBox`) {

		//	Get the children of the tab layout.
		//
		string $tab[] = `tabLayout -query -childArray $gOptionBoxTabLayout`;

		//	Determine the hidden tab containing the new option box UI, and
		//	the current tab whose UI is no longer required and may be deleted.
		//
		int $currentTabIndex = `tabLayout -query -selectTabIndex $gOptionBoxTabLayout`;

		//	Construct the long name of the tabs to ensure there is no naming
		//	conflict.
		//
		string $newTab = ($gOptionBoxTabLayout + "|");
		string $oldTab = ($gOptionBoxTabLayout + "|");
		if ($currentTabIndex == 1) {
			$oldTab = $oldTab + $tab[0];
			$newTab = $newTab + $tab[1];
		} else {
			$oldTab = $oldTab + $tab[1];
			$newTab = $newTab + $tab[0];
		}

		//	Get the child of the hidden tab and apply the attachments...
		//
		string $contents[] = `formLayout -query -childArray $newTab`;
		formLayout -edit
			-attachForm $contents[0] "top"    0
			-attachForm $contents[0] "left"   0
			-attachForm $contents[0] "bottom" 0
			-attachForm $contents[0] "right"  0
			$newTab;

		//	Make visible the tab containing the new option box UI.
		//
		tabLayout -edit -selectTab $newTab $gOptionBoxTabLayout;
		
		//	Now delete the contents, if any, of the old tab...
		//
		if (`formLayout -query -numberOfChildren $oldTab` > 0) {
			string $child[] = `formLayout -query -childArray $oldTab`;
			int $count = `formLayout -query -numberOfChildren $oldTab`;
			int $index;
			for ($index = 0; $index < $count; $index++) {
				deleteUI ($oldTab + "|" + $child[$index]);
			}
		}

		//	Check the label attached to the "Apply & Close" button.
		//	If it is empty then apply a default label.  Otherwise,
		//	leave it alone because that means it was customized by
		//	a specific option box.
		//
		//	Assume that if someone has actually customized the 
		//	label of the "Apply and Close" button then they also
		//	made sure that the "Apply" button says something
		//	appropriate.
		//
		string $command;
		if ("" != $gOptionBoxApplyAndCloseBtn)
		{
			string $label = `button -query -label $gOptionBoxApplyAndCloseBtn`;
			if ("" == $label) {
				//
				//	The default label of the "Apply and Close" button will
				//	be the label for the "Apply" button.  The "Apply"
				//	button will then be set to say "Apply".
				//
				//	If the "Apply" button already says "Apply" then the
				//	"Apply and Close" will say "Apply and Close".
				//
				$label = `button -query -label $gOptionBoxApplyBtn`;
				string $applyLabel = (uiRes("m_getOptionBox.kShowApply"));
				if ($applyLabel == $label) {
					button -edit -label (uiRes("m_getOptionBox.kShowApplyAndClose")) $gOptionBoxApplyAndCloseBtn;
				} else {
					button -edit -label $applyLabel $gOptionBoxApplyBtn;
					button -edit -label $label $gOptionBoxApplyAndCloseBtn;
				}
			}

			//	Check the command attached to the "Apply & Close" button.
			//	If it is empty then apply a default action.  Otherwise,
			//	leave it alone because that means it was customized by
			//	a specific option box.
			//
			$command = `button -query -command $gOptionBoxApplyAndCloseBtn`;
			if ("" == $command) {
				//
				//	The default action will consist of the command attached
				//	to the "Apply" button plus the action to hide the 
				//	option box.
				//
				$command = `button -query -command $gOptionBoxApplyBtn`;
				$command += ("; hideOptionBox");
				button -edit -command $command $gOptionBoxApplyAndCloseBtn;
			}
		}

		//	For 3.0 we removed the "Save" and "Reset" buttons and replaced
		//	them with menu items.
		//
		//	Note that we didn't want to change every option box script 
		//	so the buttons are still being created and the functions that
		//	access them still exist.  The user however cannot see the
		//	buttons.
		//
		//	To solve the problem, simply query the commands attached
		//	to the buttons and apply them to the corresponding
		//	menu items.
		//
		$command = `button -query -command $gOptionBoxSaveBtn`;
		//
		//	Bug fix #131958. We don't want the "Save Settings" menu item
		//	closing the window like the "Save Settings" button used to do.
		//	Remove the call to hide the option box.
		//
		$command = `substitute "hideOptionBox" $command "fauxHideOptionBox"`;
		menuItem -edit -command $command $gOptionBoxEditMenuSaveItem;

		$command = `button -query -command $gOptionBoxResetBtn`;
		menuItem -edit -command $command $gOptionBoxEditMenuResetItem;

		showWindow $gOptionBox;

		restoreOptionBoxSize();

	} else {
		error ( (uiRes("m_getOptionBox.kNoOptionBoxWin")));
	}
}

//
//  Procedure Name:
//      hideOptionBox
//
//  Description:
//      Make the option box invisible to the user.  By default, this
//		procedure is attached to the option box's 'Close' button.  If an
//		alternate action is attached to the 'Close' button then be sure
//		to call this procedure explicity so that the option box is 
//		dismissed properly.
//
//  Input Arguments:
//      None.
//
//  Return Value:
//      None.
//
global proc hideOptionBox() {

	//	Global variables...
	//
	global string $gOptionBox;

	if (`window -exists $gOptionBox`) {
	
		//	Currently, the option box window is made invisible by
		//	deleting it.
		//
		evalDeferred ("if (`window -exists " + $gOptionBox + "`) deleteUI -window " + $gOptionBox);
	}
}

//
//  Procedure Name:
//      hideOptionBoxNow
//
//  Description:
//	Same as above, but deletes the window immediately instead of using evalDeferred.
//
//  Input Arguments:
//      None.
//
//  Return Value:
//      None.
//
global proc hideOptionBoxNow() {

	//	Global variables...
	//
	global string $gOptionBox;

	if (`window -exists $gOptionBox`) {
	
		//	Currently, the option box window is made invisible by
		//	deleting it.
		//
		deleteUI -window $gOptionBox;
	}
}

//
//  Procedure Name:
//      fauxHideOptionBox
// 
//  Description:
//      Do nothing. This proc exists so that we can 
//		substitute "hideOptionBox" with "fauxHideOptionBox" in
//		commands attached to the "Save Settings" menu item.
//
//		See bug #131958.
//
//  Input Arguments:
//      None.
//
//  Return Value:
//      None.
//
global proc fauxHideOptionBox() {
	//
	//	Do absolutely nothing.
	//
}

//
//  Procedure Name:
//      setOptionBoxTitle
//
//  Description:
//      Set the title of the option box window.
//
//  Input Arguments:
//      The title of the option box window.
//
//  Return Value:
//      None.
//
global proc setOptionBoxTitle(string $title) {

	//	Global variables...
	//
	global string $gOptionBox;

	if (`window -exists $gOptionBox`) {

		//	Set the title of the option box window.
		//
		window -edit -title $title $gOptionBox;

	} else {
		error (uiRes("m_getOptionBox.kSetTitleWindowDoesNotExist"));
	}
}

//
//  Procedure Name:
//      getOptionBoxHelpMenuItem
//
//  Description:
//      Return the name of the option box's 'Help' menu item.
//
//  Input Arguments: 
//      None.
//
//  Return Value:
//      The name of the option box's 'Help' menu item.
//
global proc string getOptionBoxHelpItem() {

	//	Global variables...
	//
	global string $gOptionBoxHelpItem;

	if (`menuItem -exists $gOptionBoxHelpItem`) {
		if ( `menuItem -exists aboutBakeNormalMapping` )
		{
			deleteUI aboutBakeNormalMapping;
		}
	} else {
		error (uiRes("m_getOptionBox.kGetHelpWindowDoesNotExist"));
	}

	return $gOptionBoxHelpItem;
}

//
//  Procedure Name:
//      setOptionBoxCommandName
//
//  Description:
//      Set the command name of the option box window.  The command name
//		is required to set up some common option box behaviour, for 
//		example the label of the help menu item.
//
//	Note:
//		If setOptionBoxHelpTag() is used then this method has
//		no effect.
//
//  Input Arguments:
//      The name of the command.
//
//  Return Value:
//      None.
//
global proc setOptionBoxCommandName(string $commandName) {

	string $helpItem = getOptionBoxHelpItem();
	menuItem -edit
		-label ((uiRes("m_getOptionBox.kSetHelpWith")) + $commandName)
		-command ("help -doc " + $commandName)
		$helpItem;
}

//
//  Procedure Name:
//      setOptionBoxHelpTag
//
//  Description:
//      Set the help tag to use to look up the correct documentation
//		page for this option box.  The text string in the help menu
//		will be the Option Box title.  If this is set then the command
//	 	in setOptionBoxCommandName() has no effect.
//
//  Input Arguments:
//      The name of the help tag.
//
//  Return Value:
//      None.
//
global proc setOptionBoxHelpTag(string $helpTag) {

	global string $gOptionBox;
	global string $gOptionBoxHelpTag;
	if (`window -exists $gOptionBox`) {

		//	Get the title of the option box window to use for help.
		//
		string $title = `window -query -title $gOptionBox`;
		string $helpItem = getOptionBoxHelpItem();
		if ($helpTag != "") {
			string $msg = (uiRes("m_getOptionBox.kHelpOn"));
			menuItem -edit
				-label `format -s $title $msg`
				-command ("showHelp " + $helpTag)
				$helpItem;				
			$gOptionBoxHelpTag = $helpTag;
		} else {
			menuItem -edit
				-label (uiRes("m_getOptionBox.kSetNoHelp"))
				-command ""
				$helpItem;
			$gOptionBoxHelpTag = "";
		}
	} else {
		error (uiRes("m_getOptionBox.kSetHelpWindowDoesNotExist"));
	}
}

//
//  Procedure Name:
//      getOptionBoxApplyAndCloseBtn
//
//  Description:
//      Return the name of the option box's 'Apply & Close' button.
//
//  Input Arguments: 
//      None.
//
//  Return Value:
//      The name of the option box's 'Apply & Close' button.
//
global proc string getOptionBoxApplyAndCloseBtn() {

	//	Global variables...
	//
	global string $gOptionBoxApplyAndCloseBtn;

	if (`button -exists $gOptionBoxApplyAndCloseBtn`) {
	} else {
		error (uiRes("m_getOptionBox.kGetApplyCloseWindowDoesNotExist"));
	}

	return $gOptionBoxApplyAndCloseBtn;
}

//
//  Procedure Name:
//      getOptionBoxApplyBtn
//
//  Description:
//      Return the name of the option box's 'Apply' button.
//
//  Input Arguments: 
//      None.
//
//  Return Value:
//      The name of the option box's 'Apply' button.
//
global proc string getOptionBoxApplyBtn() {

	//	Global variables...
	//
	global string $gOptionBoxApplyBtn;

	if (`button -exists $gOptionBoxApplyBtn`) {
	} else {
		error (uiRes("m_getOptionBox.kGetApplyWindowDoesNotExist"));
	}

	return $gOptionBoxApplyBtn;
}

//
//  Procedure Name:
//      getOptionBoxResetBtn
//
//  Description:
//      Return the name of the option box's 'Reset' button.
//
//  Input Arguments: 
//      None.
//
//  Return Value:
//      The name of the option box's 'Reset' button.
//
global proc string getOptionBoxResetBtn() {

	//	Global variables...
	//
	global string $gOptionBoxResetBtn;

	if (`button -exists $gOptionBoxResetBtn`) {
	} else {
		error (uiRes("m_getOptionBox.kGetResetWindowDoesNotExist"));
	}

	return $gOptionBoxResetBtn;
}

//
//  Procedure Name:
//      getOptionBoxCloseBtn
//
//  Description:
//      Return the name of the option box's 'Close' button.
//
//  Input Arguments: 
//      None.
//
//  Return Value:
//      The name of the option box's 'Close' button.
//
global proc string getOptionBoxCloseBtn() {

	//	Global variables...
	//
	global string $gOptionBoxCloseBtn;

	if (`button -exists $gOptionBoxCloseBtn`) {
	} else {
		error (uiRes("m_getOptionBox.kGetCloseWindowDoesNotExist"));
	}

	return $gOptionBoxCloseBtn;
}

//
//  Procedure Name:
//      getOptionBoxSaveBtn
//
//  Description:
//      Return the name of the option box's 'Save' button.
//
//  Input Arguments: 
//      None.
//
//  Return Value:
//      The name of the option box's 'Save' button.
//
global proc string getOptionBoxSaveBtn() {

	//	Global variables...
	//
	global string $gOptionBoxSaveBtn;

	if (`button -exists $gOptionBoxSaveBtn`) {
	} else {
		error (uiRes("m_getOptionBox.kGetSaveWindowDoesNotExist"));
	}

	return $gOptionBoxSaveBtn;
}

