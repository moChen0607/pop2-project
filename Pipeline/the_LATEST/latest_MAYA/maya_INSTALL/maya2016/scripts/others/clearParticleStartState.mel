// Copyright (C) 1997-2014 Autodesk, Inc., and/or its licensors.
// All rights reserved.
//
// The coded instructions, statements, computer programs, and/or related
// material (collectively the "Data") in these files contain unpublished
// information proprietary to Autodesk, Inc. ("Autodesk") and/or its licensors,
// which is protected by U.S. and Canadian federal copyright law and by
// international treaties.
//
// The Data is provided for use exclusively by You. You have the right to use,
// modify, and incorporate this Data into other products for purposes authorized 
// by the Autodesk software license agreement, without fee.
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND. AUTODESK
// DOES NOT MAKE AND HEREBY DISCLAIMS ANY EXPRESS OR IMPLIED WARRANTIES
// INCLUDING, BUT NOT LIMITED TO, THE WARRANTIES OF NON-INFRINGEMENT,
// MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE, OR ARISING FROM A COURSE 
// OF DEALING, USAGE, OR TRADE PRACTICE. IN NO EVENT WILL AUTODESK AND/OR ITS
// LICENSORS BE LIABLE FOR ANY LOST REVENUES, DATA, OR PROFITS, OR SPECIAL,
// DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES, EVEN IF AUTODESK AND/OR ITS
// LICENSORS HAS BEEN ADVISED OF THE POSSIBILITY OR PROBABILITY OF SUCH DAMAGES.


//<doc>
//<name clearParticleStartState>
//<owner "Unsupported">
//
//<synopsis>
//      clearParticleStartState particleNode
//
//<returns>
//      None.
//
//<description>
// This mel procedure resets the initial state of the particle system to empty, 
// or no particles. To do this it clears all the initial state attribute arrays
// on the particle or nParticle node. (these are all the arrays whose name ends in "0")
//
//<flags>
//  None.
//
//<examples>
//
// clearParticleStartState particleShape1;
//
//</doc>

global proc clearParticleStartState(string $part) {

		string $type = `nodeType $part`;
		if( $type == "transform"){
			string $sh[] = `ls -dag -leaf $part`;
			if( size($sh) > 0 ){
				$part = $sh[0];	
				$type = `nodeType $part`;
			}
		}
		if ( $type != "particle" && $type != "nParticle" ){
			warning( $part + (uiRes("m_clearParticleStartState.kNotParticle")));
			return;
		}

		// clear out all of the double arrays
		$attrs = `particle -q -ppd $part`;
		for ($attr in $attrs) {
			if (`attributeQuery -exists -n $part ($attr + "0")`){
				setAttr ($part+"."+$attr+"0") -type "doubleArray" 0;
			}
        }
        // clear out all of the vector arrays
		$attrs = `particle -q -ppv $part`;
		for ($attr in $attrs) {
			if (`attributeQuery -exists -n $part ($attr + "0")`){
				setAttr ($part+"."+$attr+"0") -type "vectorArray" 0;
			}
		}

		// other attributes that need to be cleared
		setAttr ($part+".nid0") 0;
		setAttr ($part+".particleId0") -type "doubleArray" 0;
		setAttr ($part+".age0") -type "doubleArray" 0;
		
		// Update the particle system if at or before start frame
		// Currently this is a bit tedious... we force it to evaluate
		// a frame then set it back to the current frame.
		string $curTime = ($part + ".currentTime");
		float $t = getAttr( $curTime );
		float $sf = getAttr( $part + ".startFrame" );
		if( $t <= $sf ){
			string $timeCon = `connectionInfo -sfd $curTime`;
			disconnectAttr $timeCon $curTime;
			setAttr $curTime ($sf+1.0);
			getAttr ($part + ".forceDynamics");
			connectAttr $timeCon $curTime;
		}
		
}
