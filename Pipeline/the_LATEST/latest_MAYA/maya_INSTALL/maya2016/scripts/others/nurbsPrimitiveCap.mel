// Copyright (C) 1997-2014 Autodesk, Inc., and/or its licensors.
// All rights reserved.
//
// The coded instructions, statements, computer programs, and/or related
// material (collectively the "Data") in these files contain unpublished
// information proprietary to Autodesk, Inc. ("Autodesk") and/or its licensors,
// which is protected by U.S. and Canadian federal copyright law and by
// international treaties.
//
// The Data is provided for use exclusively by You. You have the right to use,
// modify, and incorporate this Data into other products for purposes authorized 
// by the Autodesk software license agreement, without fee.
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND. AUTODESK
// DOES NOT MAKE AND HEREBY DISCLAIMS ANY EXPRESS OR IMPLIED WARRANTIES
// INCLUDING, BUT NOT LIMITED TO, THE WARRANTIES OF NON-INFRINGEMENT,
// MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE, OR ARISING FROM A COURSE 
// OF DEALING, USAGE, OR TRADE PRACTICE. IN NO EVENT WILL AUTODESK AND/OR ITS
// LICENSORS BE LIABLE FOR ANY LOST REVENUES, DATA, OR PROFITS, OR SPECIAL,
// DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES, EVEN IF AUTODESK AND/OR ITS
// LICENSORS HAS BEEN ADVISED OF THE POSSIBILITY OR PROBABILITY OF SUCH DAMAGES.

//
//
//  Creation Date:  Nov. 18, 1997
//
//  Description:
//      Main routine is nurbsPrimitiveCap.
//
//      Given a selected surface that has nurbs primitive as its immediate
//      creator, cap it with a degenerate surface (one with a pole.)
//      The argument will control how many (and which) caps nurbs cylinder
//      gets or whether nurbs cone gets a cap or not.
//
//             cylinder              cone
//
//      0 -    no caps              no caps
//      1 -    bottom cap only      bottom cap
//      2 -    top cap only         bottom cap
//      3 -    both caps            bottom cap
//

proc string capSurface( string $maker, string $curvela, string $parent,
						string $shading, string $appendName,
						int $extraTransform )
{
	// Now revolve
	string $suggest = "revolve" + $appendName + "#";
	string $revNode = `createNode revolve -n $suggest`;
	setAttr ($revNode + ".ssw") 0.0;
	setAttr ($revNode + ".ihi") 1;

	connectAttr ($curvela) ($revNode + ".ic");
	connectAttr ($maker + ".p") ($revNode + ".p");
	connectAttr ($maker + ".ax") ($revNode + ".ax");
	connectAttr ($maker + ".asd") ($revNode + ".esw");

	connectAttr ($maker + ".s") ($revNode + ".s");
	connectAttr ($maker + ".d") ($revNode + ".d");
	connectAttr ($maker + ".ut") ($revNode + ".ut");
	connectAttr ($maker + ".tol") ($revNode + ".tol");

	string $cap, $full;

	if( $extraTransform ) {
		$suggest = $appendName + "#";
		string $trans = `createNode transform -n $suggest -p $parent`;

		$suggest = $appendName + "Shape#";
		$cap = `createNode nurbsSurface -n $suggest -p $trans`;
		$full = $parent + "|" + $trans + "|" + $cap;
	}
	else {
		$cap = `createNode nurbsSurface -n $suggest -p $parent`;
		$full = $parent + "|" + $cap;
	}

	connectAttr ($revNode + ".os") ($full + ".cr");
	connectAttr ($cap + ".iog") $shading -na;

	return $cap;
}

proc string capCone( string $parent, string $shading, string $cone,
					 int $extraTransform )
{
	string $cap = `capSurface $cone ($cone + ".bcc") $parent $shading "bottomCap" $extraTransform`;
	return $cap;
}

proc string capCylinder( int $whichones, string $parent,
						 string $shading, string $cylinder,
						 int $extraTransform )
{
	string $cap1 = "";
	string $cap2 = "";

	if( $whichones == 1 || $whichones == 3 ) {
		$cap1 = `capSurface $cylinder ($cylinder + ".bcc") $parent $shading "bottomCap" $extraTransform`;
	}
	if( $whichones == 2 || $whichones == 3 ) {
		$cap2 = `capSurface $cylinder ($cylinder + ".tcc") $parent $shading "topCap" $extraTransform`;
	}
	return ($cap1 + " " + $cap2);
}

proc string getShading( string $shape )
//
// Description:
//     Find out what shader the shape is connected to so that we can
//     hook the caps to it as well.
{
	string $res[] = `listConnections -s off -d on ($shape + ".iog")`;
	string $result = "";
	if( size($res) > 0 ) {
		$result = $res[0] + ".dsm";
	}
	else {
		warning( (uiRes("m_nurbsPrimitiveCap.kWarningDefaultShadingGroup")) );
		$result = "initialShadingGroup.dsm";
	}
	return $result;
}

global proc int nurbsPrimitiveCap( int $whichones, int $history,
								   int $extraTransform )
//
// Description:
//     For the cone 0 means no caps, anything else means a bottom cap.
//     For the cylinder 0 means no caps, 1 means bottom only,
//     2 means top only, 3 means both.
{
	if( 0 == $whichones ) return 1;

	string $all[] = `ls -sl`;
	string $objs[] = `ls -sl -type dagNode`;
	string $chain[];
	string $nt, $parent[];

	int $n = size($objs);
	int $i;
	for( $i=0; $i<$n; $i+=1 ) {
		$chain = `listHistory -lf 1 -f 0 $objs[$i]`;
		if( size($chain) > 1 ) {
			$nt = `nodeType $chain[1]`;
			// $chain[1] is the "maker" node
			// $chain[0] is the shape

			if( "makeNurbCylinder" == $nt ) {
				$shading = getShading( $chain[0] );
				$parent = `listRelatives -p $chain[0]`;
				capCylinder $whichones $parent[0] $shading $chain[1] $extraTransform;
			}
			else if( "makeNurbCone" == $nt ) {
				$shading = getShading( $chain[0] );
				$parent = `listRelatives -p $chain[0]`;
				capCone $parent[0] $shading $chain[1] $extraTransform;
			}
		}
	}

	// If there were caps, we would have created with history even if
	// we didn't need it.  So, delete history here if we don't want it.
	select -r $all;
	if( ! $history ) {
		delete -ch;
	}
	return 1;
}

