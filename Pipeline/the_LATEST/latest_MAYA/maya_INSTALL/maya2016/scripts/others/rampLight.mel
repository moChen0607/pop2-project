// Copyright (C) 1997-2014 Autodesk, Inc., and/or its licensors.
// All rights reserved.
//
// The coded instructions, statements, computer programs, and/or related
// material (collectively the "Data") in these files contain unpublished
// information proprietary to Autodesk, Inc. ("Autodesk") and/or its licensors,
// which is protected by U.S. and Canadian federal copyright law and by
// international treaties.
//
// The Data is provided for use exclusively by You. You have the right to use,
// modify, and incorporate this Data into other products for purposes authorized 
// by the Autodesk software license agreement, without fee.
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND. AUTODESK
// DOES NOT MAKE AND HEREBY DISCLAIMS ANY EXPRESS OR IMPLIED WARRANTIES
// INCLUDING, BUT NOT LIMITED TO, THE WARRANTIES OF NON-INFRINGEMENT,
// MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE, OR ARISING FROM A COURSE 
// OF DEALING, USAGE, OR TRADE PRACTICE. IN NO EVENT WILL AUTODESK AND/OR ITS
// LICENSORS BE LIABLE FOR ANY LOST REVENUES, DATA, OR PROFITS, OR SPECIAL,
// DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES, EVEN IF AUTODESK AND/OR ITS
// LICENSORS HAS BEEN ADVISED OF THE POSSIBILITY OR PROBABILITY OF SUCH DAMAGES.

//
// rampLight()
// This function creates a pointlight with a sphere
// that defines the illumination region.
// The decay and color within this region is
// controlled by a ramp texture. The top of the
// ramp represents the edge of the sphere and
// the bottom the center of the sphere. The sphere
// may be non proportionatly scaled to control
// the influence of the light. By changing the lighttype
// to ambient, one can create an ambient light with
// decay.
// We use the matrix from the sphere to transform the point
// being shaded into the local or object space of the sphere.
// The dot and root operation gives the distance of this point
// from the center of the sphere( a distance of 1 is on the edge
// of the sphere ). The result is clamped so that points outside
// the sphere get the same effect as if they were on the sphere edge.
// The value(0-1) is then used to index the ramp texture which controls
// the light color.


global proc rampLight()
{
	string $light    = `shadingNode -asLight pointLight -name rampLight`;
	string $range	 = `createNode renderSphere -p $light`;
	string $ramp     = `shadingNode -asTexture ramp -name ($light+"Decay")`;
	string $sampler  = `shadingNode -asTexture -asUtility samplerInfo`;
	string $matMult  = `shadingNode -asTexture -asUtility vectorProduct -name matrixMult`;
	string $dot      = `shadingNode -asTexture -asUtility vectorProduct -name dot`;
	string $root  	 = `shadingNode -asTexture -asUtility multiplyDivide -name squareRoot`;
	string $clamp    = `shadingNode -asTexture -asUtility clamp`;

	setAttr	( $matMult + ".operation" ) 4;
	setAttr	( $dot + ".operation" ) 1;
	setAttr	( $root + ".operation" ) 3;
	setAttr	( $root  + ".input2X" ) 0.5;
	setAttr	( $clamp + ".maxR" ) 1.0;

	// make the ramp a simple black to white smooth ramp
	removeMultiInstance -break true ($ramp + ".colorEntryList[2]");
	setAttr ( $ramp + ".colorEntryList[0].color") -type double3 1 1 1;
	setAttr ( $ramp + ".colorEntryList[0].position") 0;
	setAttr ( $ramp + ".colorEntryList[1].color") -type double3 0 0 0;
	setAttr ( $ramp + ".colorEntryList[1].position") 1;
	setAttr ( $ramp + ".interpolation") 4;

	connectAttr -f ($sampler + ".pointWorld") ($matMult + ".input1");
	connectAttr -f ($range   + ".worldInverseMatrix[0]") ($matMult + ".matrix");
	connectAttr -f ($matMult + ".output")     ($dot + ".input1");
	connectAttr -f ($matMult + ".output")     ($dot + ".input2");
	connectAttr -f ($dot  + ".outputX")       ($root + ".input1X");
	connectAttr -f ($root + ".outputX")       ($clamp + ".inputR");
	connectAttr -f ($clamp + ".outputR")      ($ramp + ".vCoord");
	connectAttr -f ($ramp  + ".outColor")	  ($light + ".color" );

	select -r $light;
}

