// Copyright (C) 1997-2014 Autodesk, Inc., and/or its licensors.
// All rights reserved.
//
// The coded instructions, statements, computer programs, and/or related
// material (collectively the "Data") in these files contain unpublished
// information proprietary to Autodesk, Inc. ("Autodesk") and/or its licensors,
// which is protected by U.S. and Canadian federal copyright law and by
// international treaties.
//
// The Data is provided for use exclusively by You. You have the right to use,
// modify, and incorporate this Data into other products for purposes authorized 
// by the Autodesk software license agreement, without fee.
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND. AUTODESK
// DOES NOT MAKE AND HEREBY DISCLAIMS ANY EXPRESS OR IMPLIED WARRANTIES
// INCLUDING, BUT NOT LIMITED TO, THE WARRANTIES OF NON-INFRINGEMENT,
// MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE, OR ARISING FROM A COURSE 
// OF DEALING, USAGE, OR TRADE PRACTICE. IN NO EVENT WILL AUTODESK AND/OR ITS
// LICENSORS BE LIABLE FOR ANY LOST REVENUES, DATA, OR PROFITS, OR SPECIAL,
// DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES, EVEN IF AUTODESK AND/OR ITS
// LICENSORS HAS BEEN ADVISED OF THE POSSIBILITY OR PROBABILITY OF SUCH DAMAGES.

//
//
//  Creation Date:  April 30, 1997
//
//


proc printCommand( string $command, string $objects[] )
// 
//	Description:
//		Utility procedure for printing out a command and its objects
//
{
	print( " " + $command );
	string $objStr;
	for ( $obj in $objects ) {
		$objStr += ( " " + $obj );
	}
	print $objStr;
	print(";");
}

//
//  Procedure Name:
//      duplicatePreset
//
//  Description:
//	Performs one or more duplications.
//
//  Return Value:
//      None.
//
global proc duplicatePreset(
	int $count,
	int $copy,
	int $group,
	int $smart,
	int $upstream,
	int $inputConn,
	int $renameChild,
	int $instanceLeaf,
	float $transX, float $transY, float $transZ,
	float $rotatX, float $rotatY, float $rotatZ,
	float $scaleX, float $scaleY, float $scaleZ
) 
{
	//	*NOTE*	This command is a complex script and therefore the command
	//			echoing cannot be performed using evalEcho because 1) it is
	//			too slow when duplicating large numbers of objects and
	//			generates too many echoed commands 2) many of the commands
	//			involve local variables so the echoed commands are incorrect
	//
	//			Therefore, this command uses print to generate its output
	//			so you must ensure changes to the script are consistent with
	//			the generated output.
	//
	string $cmd = "duplicate -rr";
	string $objects[];
	string $result[];
	string $resultTemplateStr = (uiRes("m_duplicatePreset.kResult"));

	if ($renameChild) {
		$cmd += " -renameChildren";
	}

	if (!$upstream && !$inputConn && !$copy)
	{
		$cmd = "instance";
	}
	else
	{	
		if( $instanceLeaf )
		{
			$cmd += " -instanceLeaf";
		}
	}

	if ($upstream) {
		//	Create duplicates of upstream nodes also.
		//
		$cmd += " -un";
		for ($i = 0; $i < $count; ++$i) {
			$result = eval($cmd);
			for ($obj in $result) $objects[size($objects)] = $obj;
		}
		if ($count == 1) print($cmd+";");
		else {
			string $loopMsg = "for ($i=0; $i<"+$count+"; ++$i) "+$cmd+";" ;
			print($loopMsg);
		}
		
	}
	else if ($inputConn) {
		//	Create duplicates of upstream connections (not nodes) also.
		//
		$cmd += " -ic";
		for ($i = 0; $i < $count; ++$i) {
			$result = eval($cmd);
			for ($obj in $result) $objects[size($objects)] = $obj;
		}
		if ($count == 1) print($cmd+";");
		else{
			string $loopMsg = "for ($i=0; $i<"+$count+"; ++$i) "+$cmd+";" ;
			print($loopMsg);
		}
	}
	else if ($smart) {
		//	Create duplicates
		//
		$cmd += " -st";
		$result = eval($cmd);
		for ($obj in $result) $objects[size($objects)] = $obj;
		print($cmd+";");
	}
	else if ($count > 0) {
		//	Create first duplicate
		//
		if ($count > 1) select `ls -sl`; // reset smart transform info

		$result = eval($cmd);
		for ($obj in $result) $objects[size($objects)] = $obj;
		print($cmd+";");

		if (size($objects) > 0) {
			//	Transform it
			//
			if ($scaleX != 1.0 || $scaleY != 1.0 || $scaleZ != 1.0) {
				scale -r $scaleX $scaleY $scaleZ;
				string $scaleMsg = " scale -r "+$scaleX+" "+$scaleY+" "+$scaleZ+";" ;
				print($scaleMsg);
			}

			if ($rotatX != 0.0 || $rotatY != 0.0 || $rotatZ != 0.0) {
				rotate -r $rotatX $rotatY $rotatZ;
				string $rotateMsg = " rotate -r "+$rotatX+" "+$rotatY+" "+$rotatZ+";" ;
				print($rotateMsg);
			}

			if ($transX != 0.0 || $transY != 0.0 || $transZ != 0.0) {
				move -r $transX $transY $transZ;
				string $transMsg = " move -r "+$transX+" "+$transY+" "+$transZ+";" ;
				print($transMsg);
			}

			//	Create remaining duplicates
			//
			$cmd += " -st";
			for ($i = 1; $i < $count; ++$i) {
				$result = eval($cmd);
				for ($obj in $result) $objects[size($objects)] = $obj;
			}
			if ($count>1){
				string $loopMsg = " for ($i=1; $i<"+$count+"; ++$i) "+$cmd+";" ;
				print($loopMsg);
			}
		}
	}
	
	if (size($objects) > 0) {
		if ($group == 3) {
			string $resultString;
			$resultString = `group $objects`;

			//	Echo command and result
			printCommand( "group", $objects );
			print("\n");
			$resultString = " " + $resultString;
			$resultString = `format -s $resultString $resultTemplateStr`;
			print($resultString + "\n");
		} else if ($group == 2) {
			string $objectsUnderWorld[];
			string $parentableObjects[];
			int $i = 0;
			int $j = 0;
			// filter out objects which are already under the world.
			for ($obj in $objects) {
				string $parents[] = `listRelatives -p $obj`;
				if ( size($parents) == 0 ) {
					$objectsUnderWorld[$i] = $obj;
					++$i;
				}
				else {
					$parentableObjects[$j] = $obj;
					++$j;
				}
			}

			// parent the objects which are not already under the world
			if ( size($parentableObjects) > 0 ) {
				$result = `parent -w $parentableObjects`;
			}

			// add the objects already under the world to the list of
			// objects that were parented.
			$i = size($result);
			for ($obj in $objectsUnderWorld) {
				$result[$i] = $obj;
				++$i;
			}

			//	Echo parent command 
			//
			if ( size($parentableObjects) > 0 ) {
				printCommand( "parent -w", $parentableObjects );
				print("\n");
			}

			if ($count > 1) {
				select $result;

				if (size($result) > 0) {
					//	Echo command and result
					printCommand( "select", $result );
				}
			}
			print("\n");

			string $resultStr = "";
			for ($obj in $result) $resultStr = $resultStr+" "+$obj; 
			$resultStr = `format -s $resultStr $resultTemplateStr`;
			print($resultStr + "\n");
		} else {
			if ($count > 1) {
				select $objects;

				//	Echo command and result
				printCommand( "select", $objects );
			}
			print("\n");
			
			// print out the result, making sure it stays in the
			// commandLine output area but using a single print.
			//
			string $resultStr = "";
			for ($obj in $objects) $resultStr = $resultStr+" "+$obj; 
			$resultStr = `format -s $resultStr $resultTemplateStr`;
			print ($resultStr + "\n");
		}
	}
}
