// Copyright (C) 1997-2014 Autodesk, Inc., and/or its licensors.
// All rights reserved.
//
// The coded instructions, statements, computer programs, and/or related
// material (collectively the "Data") in these files contain unpublished
// information proprietary to Autodesk, Inc. ("Autodesk") and/or its licensors,
// which is protected by U.S. and Canadian federal copyright law and by
// international treaties.
//
// The Data is provided for use exclusively by You. You have the right to use,
// modify, and incorporate this Data into other products for purposes authorized 
// by the Autodesk software license agreement, without fee.
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND. AUTODESK
// DOES NOT MAKE AND HEREBY DISCLAIMS ANY EXPRESS OR IMPLIED WARRANTIES
// INCLUDING, BUT NOT LIMITED TO, THE WARRANTIES OF NON-INFRINGEMENT,
// MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE, OR ARISING FROM A COURSE 
// OF DEALING, USAGE, OR TRADE PRACTICE. IN NO EVENT WILL AUTODESK AND/OR ITS
// LICENSORS BE LIABLE FOR ANY LOST REVENUES, DATA, OR PROFITS, OR SPECIAL,
// DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES, EVEN IF AUTODESK AND/OR ITS
// LICENSORS HAS BEEN ADVISED OF THE POSSIBILITY OR PROBABILITY OF SUCH DAMAGES.

proc string [] getNComponentsForItem( string $item, int $matchComponentType )
{
	string $components[];
	string $info[];
	$info[0] = $item;
	$info[1] = 0;
	int $compType = itemComponentInfo( $item, $info );
	if( $compType == 7 ){
		$compType = 2; // particle components are defined as vertices on component node
	}
	if ( $compType != 0 ) { 
		string $mesh = $info[0];
		string $nObj = findTypeInHistory( $mesh, "nBase", 1,1 );
		if( $nObj != "" ){
			int $index = $info[1];
			string $cons[] = `listConnections -type nComponent ($nObj + ".nucleusId")`; 	
			string $component;
			for( $component in $cons ){
				int $currCompType = getAttr( $component + ".componentType");
				if ($matchComponentType && ( $compType != $currCompType )) {
					continue;
				}
	/*
				if( $compType != 6 ){
					int $elements = getAttr( $component + ".elements");
					if( $elements != 2 ){ // ALL Elements
						if( !inComponentList( $component, $index ) ){
							continue;
						}
					}
				}
	*/
				$components[size($components)] = $component;
			}
		}
	}
	
	return( $components );
}

proc string [] getNConstraintsForItem( string $item, int $matchComponentType )
{
	string $comps[] = getNComponentsForItem( $item, $matchComponentType );
	string $constraints[];
	string $comp;
	for( $comp in $comps ){
		string $cons[] = `listConnections -type dynamicConstraint ($comp + ".outComponent")`;
		if( size( $cons ) > 0 ){
			$constraints[size($constraints)] = $cons[0];
		}
	}
	return $constraints;
}

global proc string getNConstraintToEdit( string $action, int $matchComponentType )
//
//	Description:
//	  Get the constraint to be edited. Give an error message if too many
//    constraints or no constraints are found.
//
// Arguments:	
//    $action: string specifying the edit operation such as: add, replace, paint and
//    is used solely for error messages.
//
//    $matchComponentType: only allow matches to constraints containing components
//  	of appropriate type
//
{
	string $constraint;

	// Get the selection( including cvs )
	//
	string $obj;
	string $selected[] = `ls -sl -flatten`;
	for ($obj in $selected) {
		if (nodeType($obj) == "transform") {
			string $children[] = `listRelatives -shapes -path -noIntermediate`;
			for ($child in $children) {
				$selected[size($selected)] = $child;
			}
		}
	}
	
	$selected = stringArrayRemoveDuplicates( $selected );
	if (0 == size($selected)) {
		error( (uiRes("m_getNConstraintToEdit.kNothingSelected")));
		return $constraint;
	}

	// Get the selected constraint
	int $multipleConstraints = false;
	for ( $obj in $selected ){
		string $type = nodeType( $obj );
		if ( $type == "dynamicConstraint" || $type == "transform" ){
			continue;
		}
		string $cons[] = getNConstraintsForItem( $obj, $matchComponentType );
		if ( size($cons) < 1 ) {
			if ( $action == "remove" || $action == "paint" ){
				string $format = (uiRes("m_getNConstraintToEdit.kDoesNotBelong"));
				string $warnStr = `format -stringArg $obj $format`;
				warning( $warnStr );
			}
			continue;	
		} else if ( size($cons) > 1 ) {
			$multipleConstraints = true;
			$constraint = $cons[0];
		} else {
			if ( size($constraint) == 0 ) {
				$constraint = $cons[0];
			} else if ( $constraint != $cons[0] ){
				$multipleConstraints = true;
			}
		}
	}
	if ( size($constraint) == 0 || $multipleConstraints ){
		// need exactly one constraint selection to disambiguate
		//
		string $constraints[] = `ls -sl -dag -type dynamicConstraint`;
		if( size($constraints)==1 ){
			$constraint = $constraints[0];
		} else {
			if( size($constraints) > 1 ){
				error( (uiRes("m_getNConstraintToEdit.kSelectJustOne")));
			} else {
				if( $multipleConstraints ){
					error( (uiRes("m_getNConstraintToEdit.kMultipleConstraints")));
				} else {
					if( $action == "remove" ){
						error( (uiRes("m_getNConstraintToEdit.kSelectedItemsNot"))); 
					} else if( $action == "replace" ){
						error( (uiRes("m_getNConstraintToEdit.kAdditionallyReplace"))); 
					} else if( $action == "add" ){
						error( (uiRes("m_getNConstraintToEdit.kAdditionallyAdd"))); 
					}
				}
			}
		}
	}
	return $constraint;
}
