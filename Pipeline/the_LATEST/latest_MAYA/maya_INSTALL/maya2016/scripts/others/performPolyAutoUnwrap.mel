// Copyright (C) 1997-2014 Autodesk, Inc., and/or its licensors.
// All rights reserved.
//
// The coded instructions, statements, computer programs, and/or related
// material (collectively the "Data") in these files contain unpublished
// information proprietary to Autodesk, Inc. ("Autodesk") and/or its licensors,
// which is protected by U.S. and Canadian federal copyright law and by
// international treaties.
//
// The Data is provided for use exclusively by You. You have the right to use,
// modify, and incorporate this Data into other products for purposes authorized 
// by the Autodesk software license agreement, without fee.
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND. AUTODESK
// DOES NOT MAKE AND HEREBY DISCLAIMS ANY EXPRESS OR IMPLIED WARRANTIES
// INCLUDING, BUT NOT LIMITED TO, THE WARRANTIES OF NON-INFRINGEMENT,
// MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE, OR ARISING FROM A COURSE 
// OF DEALING, USAGE, OR TRADE PRACTICE. IN NO EVENT WILL AUTODESK AND/OR ITS
// LICENSORS BE LIABLE FOR ANY LOST REVENUES, DATA, OR PROFITS, OR SPECIAL,
// DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES, EVEN IF AUTODESK AND/OR ITS
// LICENSORS HAS BEEN ADVISED OF THE POSSIBILITY OR PROBABILITY OF SUCH DAMAGES.

//
//  Procedure Name:
//      performPolyAutoUnwrap
//
//  Description:
//
//  Input Arguments:
//        $option : Whether to set the options to default values.
//  Return Value:
//        command string iff $option==2
//

//
// Initialize optionVars for polyAutoUnwrap:
// 
proc setOptionVars (
	string		$prefix, 
	int			$forceFactorySettings,
	string		$vars[]
)
{
	string $varName;
	// Must match $vars
	int $intValues[]= { 0, 2, 0, 0, 0, 0 };
	float $borderColor[] = {1.0, 0.0, 0.0};
	float $anchorColor[] = {1.0, 1.0, 0.0};

	for ( $i = 0 ; $i < 8; $i++ )
	{
		$varName = ($prefix + $vars[$i]);
		if ($forceFactorySettings || !`optionVar -exists $varName`)
		{
			if ($i < 6)
				optionVar -intValue $varName $intValues[$i];
			else if($i == 6)
			{
				optionVar -fv $varName $borderColor[0];
				optionVar -fva $varName $borderColor[1];
				optionVar -fva $varName $borderColor[2];
			}
			else if($i == 7)
			{
				optionVar -fv $varName $anchorColor[0];
				optionVar -fva $varName $anchorColor[1];
				optionVar -fva $varName $anchorColor[2];
			}
		}
	}

	// Also add the map name
	$varName = ($prefix + "uvSetName");
	if ($forceFactorySettings || !`optionVar -exists $varName`)
		optionVar -stringValue $varName "uvSet1";
}

global proc performPolyAutoUnwrapSetup(string $parent, int $forceFactorySettings)
{
	string $prefix = "polyAutoUnwrap";
	string $intVars[] ={"c", "i", "l", "ut", "is", "cm", "borderColor", "anchorColor"};
	string $varName;
	
	setOptionVars($prefix, $forceFactorySettings, $intVars);

	setParent $parent;

	$varName = ($prefix + $intVars[0]);
	int $val = `optionVar -query $varName`+1;
	radioButtonGrp -e -sl $val $varName;

	$varName = ($prefix + $intVars[1]);
	radioButtonGrp -e -en ($val == 2) -sl (`optionVar -query $varName`+1) $varName;

	$varName = ($prefix + $intVars[2]);
	radioButtonGrp -e -sl (`optionVar -query $varName`+1) $varName;

	$varName = ($prefix + $intVars[3]);
	checkBoxGrp -e -value1 `optionVar -query $varName` $varName;

	$varName = ($prefix + $intVars[4]);
	checkBoxGrp -e -value1 `optionVar -query $varName` $varName;

	$varName = ($prefix + $intVars[5]);
	checkBoxGrp -e -value1 `optionVar -query $varName` $varName;

	$val = `optionVar -query $varName`;
	$varName = ($prefix + "uvSetName");
	textFieldGrp -e -en $val -tx `optionVar -q $varName` $varName;
}

global proc performPolyAutoUnwrapCallback (string $parent, int $doIt)
{
	string $prefix = "polyAutoUnwrap";
	string $intVars[] ={"c", "i", "l", "ut", "is", "cm", "borderColor", "anchorColor"};
	string $varName;

	setParent $parent;
	
	$varName = ($prefix + $intVars[0]);
	optionVar -intValue $varName (`radioButtonGrp -q -sl $varName`-1);

	$varName = ($prefix + $intVars[1]);
	optionVar -intValue $varName (`radioButtonGrp -q -sl $varName`-1);
	
	$varName = ($prefix + $intVars[2]);
	optionVar -intValue $varName (`radioButtonGrp -q -sl $varName`-1);
	
	$varName = ($prefix + $intVars[3]);
	optionVar -intValue $varName `checkBoxGrp -q -v1 $varName`;
	
	$varName = ($prefix + $intVars[4]);
	optionVar -intValue $varName `checkBoxGrp -q -v1 $varName`;

	$varName = ($prefix + $intVars[5]);
	optionVar -intValue $varName `checkBoxGrp -q -v1 $varName`;

	$varName = ($prefix + "uvSetName");
	optionVar -stringValue $varName `textFieldGrp -q -tx $varName`; 

	if ($doIt) 
	{
		performPolyAutoUnwrap 0;
		addToRecentCommandQueue "performPolyAutoUnwrap 0" "PolyAutoUnwrap";
	}
}

proc polyAutoSetupLoadButtonTemplate() {
	if (!`uiTemplate -exists LoadButtonTemplate`) {
			uiTemplate LoadButtonTemplate;
		}

	int $kOffsetText = (`about -mac` ? 8 : 5);
	int $kSingleWidgetWidthIndex = 62;
	rowLayout
		-defineTemplate LoadButtonTemplate 
		-columnAlign2  "left" "center"
		-columnAttach2 "both" "both"
		-columnOffset2 $kOffsetText 0
		-columnWidth2  170 (3 * $kSingleWidgetWidthIndex);
}

proc polyAutoUnwrapOptions (string $prefix, string $intVars[])
{
	// Global template variables for form spacing
	global int $gOptionBoxTemplateFrameSpacing;
	
	polyAutoSetupLoadButtonTemplate();

	string $commandName = "performPolyAutoUnwrap";
	string $callback = ($commandName + "Callback");
	string $setup = ($commandName + "Setup");
	string $varName;

	string $layout = getOptionBox();
	setParent $layout;
	setUITemplate -pushTemplate OptionBoxTemplate;
	waitCursor -state 1;

	// Form layout
	scrollLayout;
	string $parent = `formLayout polyAutoUnwrapOptions`;
			
		// Mapping settings frame
		string $mappingFrame = 
		`frameLayout -label (uiRes("m_performPolyAutoUnwrap.kMappingFrame"))`;

			columnLayout;

			$varName = ($prefix + $intVars[0]);
			string $varName2 = ($prefix + $intVars[1]);
			radioButtonGrp -label (uiRes("m_performPolyAutoUnwrap.kUVShellCreationMethod")) 
							-nrb 2
							-label1 (uiRes("m_performPolyAutoUnwrap.kBasicUnfold"))
							-label2 (uiRes("m_performPolyAutoUnwrap.kAdvancedUnfold"))
							-on1 ("disable "+$varName2)
							-of1 ("disable -v false "+$varName2)
							-on2 ("disable -v false "+$varName2)
							-of2 ("disable "+$varName2)
							-vr $varName;

			separator -style "none";

			$varName = ($prefix + $intVars[1]);
			radioButtonGrp -label (uiRes("m_performPolyAutoUnwrap.kInitialProjection")) 
				-nrb 3
				-label1 (uiRes("m_performPolyAutoUnwrap.kFacingX"))
				-label2 (uiRes("m_performPolyAutoUnwrap.kFacingY"))
				-label3 (uiRes("m_performPolyAutoUnwrap.kFacingZ"))
				-vr $varName;

			separator -style "none";
			
			$varName = ($prefix + $intVars[2]);
			radioButtonGrp -label (uiRes("m_performPolyAutoUnwrap.kUVShellLayout")) 
							-nrb 4
							-label1 (uiRes("m_performPolyAutoUnwrap.kUniformFit"))
							-label2 (uiRes("m_performPolyAutoUnwrap.kStretchFit"))
							-label3 (uiRes("m_performPolyAutoUnwrap.kProportionalFit"))
							-label4 (uiRes("m_performPolyAutoUnwrap.kNoneFit"))
							-vr $varName;

			separator -style "none";
			
			$varName = ($prefix + $intVars[3]);
			checkBoxGrp -label1 (uiRes("m_performPolyAutoUnwrap.kUseTestPatternShader")) $varName;
			
			$varName = ($prefix + $intVars[4]);
			checkBoxGrp -label1 (uiRes("m_performPolyAutoUnwrap.kIsolate")) $varName;

			setParent ..;

		setParent $parent;

		// UV set frame
		string $uvSetFrame = 
		`frameLayout -label (uiRes("m_performPolyAutoUnwrap.kUVSetFrame"))`;

			columnLayout;

			$varName = ($prefix + $intVars[5]);
			$textName = ($prefix + "uvSetName");
			string $grayCmd = 
				"{ int $tmp = `checkBoxGrp -q -v1 "+$varName + "`;" +
				"  textFieldGrp -e -en $tmp "+$textName+";}";
			checkBoxGrp -label1 (uiRes("m_performPolyAutoUnwrap.kCreateNewUVSet")) -cc $grayCmd $varName;
			textFieldGrp -label (uiRes("m_performPolyAutoUnwrap.kUVSetName")) $textName;

		setParent $parent;

	setParent ..;

	// Attach frames to form layout
	formLayout -e
		-af $mappingFrame "top" $gOptionBoxTemplateFrameSpacing
		-af $mappingFrame "left" $gOptionBoxTemplateFrameSpacing
		-af $mappingFrame "right" $gOptionBoxTemplateFrameSpacing
		-an $mappingFrame "bottom"

		-ac $uvSetFrame "top" $gOptionBoxTemplateFrameSpacing  $mappingFrame
		-af $uvSetFrame "left" $gOptionBoxTemplateFrameSpacing
		-af $uvSetFrame "right" $gOptionBoxTemplateFrameSpacing
		-an $uvSetFrame "bottom" 

	$parent;

	waitCursor -state 0;
	setUITemplate -popTemplate;

	string $applyBtn = getOptionBoxApplyBtn();
	button -edit -label (uiRes("m_performPolyAutoUnwrap.kEnterTool"))
	       -command ($callback + " " + $parent + " " + 1)
		   $applyBtn;

	string $applyAndCloseBtn = getOptionBoxApplyAndCloseBtn();
	button -edit -label (uiRes("m_performPolyAutoUnwrap.kEnterToolAndClose"))
	       -command ($callback + " " + $parent + " " + 1 +";hideOptionBox")
		   $applyAndCloseBtn;

	string $saveBtn = getOptionBoxSaveBtn();
	button -edit 
		-command ($callback + " " + $parent + " " + 0 + "; hideOptionBox")
		$saveBtn;

	string $resetBtn = getOptionBoxResetBtn();
	button -edit 
		-command ($setup + " " + $parent + " " + 1)
		 $resetBtn;

	setOptionBoxTitle (uiRes("m_performPolyAutoUnwrap.kAutoUnwrapMappingOptions")) ;

	setOptionBoxHelpTag( "AutoUnwrapMapping" );

	eval (($setup + " " + $parent + " " + 0));

	showOptionBox();
}

global proc borderColorCallback()
{
	float $values[] = `colorSliderGrp -query -rgbValue AutoUnwrapBorderColorButton`;
	if (!`optionVar -exists polyAutoUnwrapborderColor`)
	{
		optionVar -fv polyAutoUnwrapborderColor $values[0];
		optionVar -fva polyAutoUnwrapborderColor $values[1];
		optionVar -fva polyAutoUnwrapborderColor $values[2];
	}
	else
	{
		optionVar -clearArray polyAutoUnwrapborderColor;
		optionVar -fv polyAutoUnwrapborderColor $values[0];
		optionVar -fva polyAutoUnwrapborderColor $values[1];
		optionVar -fva polyAutoUnwrapborderColor $values[2];
	}
}

global proc createSelectMeshOrFacesWindow()
	
{
	// TODO£º If need some window input options, put it here.
	
	string $msgNoObjectOrFaces = (uiRes("m_performPolyAutoUnwrap.kNoSelectedObjectOrFacesError"));
	cleanUpAfterUnwrap();
	error $msgNoObjectOrFaces;
}

global proc getBorderEdgesInfoFromAutoUnwrapNode()
{
	// Find an polyAutoUnwrap kind node to edit.
	string $unwrap = `polyAutoUnwrap -q -een`;

	// If no existing editable polyAutoUnwrap node, create a new one.
	if ("" == $unwrap)
	{
		string $unwrapNew[] = `polyAutoUnwrap -ch on`;
		$unwrap = $unwrapNew[0];
	}

	// If no editable polyAutoUnwrap node, kick an error.
	if ("" == $unwrap)
		createSelectMeshOrFacesWindow;

	// Edit the method attribute to -1.
	polyAutoUnwrap -e -scm -1 $unwrap;

	// Record this node name as preference string, so other place can know this node name.
	if (`optionVar -ex polyAutoUnwrapNode` == 0)
		optionVar -stringValue polyAutoUnwrapNode $unwrap;
	else
	{
		optionVar -rm polyAutoUnwrapNode;
		optionVar -stringValue polyAutoUnwrapNode $unwrap;
	}

	// Add the border edges from polyAutoUnwrap node to set wrapMapBorderEdges.
	string $existingBorderEdges = `polyAutoUnwrap -q -be $unwrap`;
	if ("" != $existingBorderEdges)
	{
		select -cl;
		select -r $existingBorderEdges;
		if (`objExists "wrapMapBorderEdges"` == 0)
			sets -name "wrapMapBorderEdges";
		else
			sets -add "wrapMapBorderEdges";
	}
	// TODO:  border colors are put here.
}

global proc getAnchorsInfoFromAutoUnwrapNode()
{
	if (`optionVar -ex polyAutoUnwrapNode` == 0)
		createSelectMeshOrFacesWindow;
	string $unwrap = `optionVar -q polyAutoUnwrapNode`;
	if ("" == $unwrap)
		createSelectMeshOrFacesWindow;

	// Add the anchor vertices from polyAutoUnwrap node to set wrapMapAnchors.
	string $existingAnchorVertices = `polyAutoUnwrap -q -av $unwrap`;
	if ("" == $existingAnchorVertices)
	{
		select -cl;
		select -r $existingAnchorVertices;
		if (`objExists "wrapMapAnchors"` == 0)
			sets -name "wrapMapAnchors";
		else
			sets -add "wrapMapAnchors";
	}
	// TODO: anchor colors are put here.
}

global proc updateAutoUnwrapNodeBorderEdges()
{
	// Update the border edges attribute for the node.
	select -r wrapMapBorderEdges;
	string $newSelectedEdgesArray[] = `filterExpand -sm 32`;
	string $newBorderEdges = stringArrayToString($newSelectedEdgesArray, ",");
	string $unwrap = `optionVar -q polyAutoUnwrapNode`;
	if ("" == $unwrap)
		createSelectMeshOrFacesWindow;
	if ("" != $newBorderEdges)
		polyAutoUnwrap -e -be $newBorderEdges $unwrap;
}

global proc updateAutoUnwrapNodeAnchorVertices()
{
	// Update the border edges attribute for the node.
	select -r wrapMapAnchors;
	string $newSelectedAnchorsArray[] = `filterExpand -sm 31`;
	string $newAnchors = stringArrayToString($newSelectedAnchorsArray, ",");
	string $unwrap = `optionVar -q polyAutoUnwrapNode`;
	if ("" == $unwrap)
		createSelectMeshOrFacesWindow;
	if ("" != $newAnchors)
		polyAutoUnwrap -e -av $newAnchors $unwrap;
}

global proc updateAutoUnwrapMethodAndInitProjection()
{
	// Edit the method attribute and initial projection attribute of the autoUnwrap node.
	int $method = `optionVar -q polyAutoUnwrapc`;
	int $initialProjection = `optionVar -q polyAutoUnwrapi`;
	string $unwrap = `optionVar -q polyAutoUnwrapNode`;
	if ("" == $unwrap)
		createSelectMeshOrFacesWindow;
	polyAutoUnwrap -e -scm $method -ip $initialProjection $unwrap;
}

global proc createSelectBorderEdgesWindow()
{
	// Get border edges, anchor vertices and colors.
	getBorderEdgesInfoFromAutoUnwrapNode();

	//clear selection and switch to edge selection mode
    //
    select -cl;
    SelectEdgeMask;

	if (`window -exists autoUnwrapSBEWindow`)
		deleteUI -window autoUnwrapSBEWindow;

	string $window = `window -title (uiRes("m_performPolyAutoUnwrap.kSBETitle")) 
							 -w 260
							 -h 200
							 -titleBar 1 
							 -titleBarMenu 1
							 -sizeable false
							 -minimizeButton false
							 -maximizeButton false
							 autoUnwrapSBEWindow` ;
	
	// Adjust top left corner.
	int $xy[] = `window -q -topLeftCorner autoUnwrapSBEWindow`;
	window -e -topLeftCorner (100) ($xy[1]) autoUnwrapSBEWindow;

	rowColumnLayout
		-numberOfRows 5
		-width 260
		-rowHeight 1 50
		-rowHeight 2 50
		-rowHeight 3 50
		-rowHeight 4 50
		-rowHeight 5 50
		-rowSpacing 1 10;

		formLayout;
		button -label (uiRes("m_performPolyAutoUnwrap.kAutoUnwrapAddBorders")) 
				-width 130
				-height 40
				-command  ("defineWrapMapEdges;" ) 
				AutoUnwrapAddBordersButton;
		setParent ..;

		formLayout;
		button -label (uiRes("m_performPolyAutoUnwrap.kAutoUnwrapRemoveBorders"))
				-width 130
				-height 40
				-command  ("removeWrapMapEdges;" )
				AutoUnwrapRemoveBordersButton;
		setParent ..;

		formLayout;
		button -label (uiRes("m_performPolyAutoUnwrap.kAutoUnwrapSBEContinue"))
				-width 130
				-height 40
				-command ("deleteUI -window autoUnwrapSBEWindow;defineWrapMapEdges; if (`optionVar -q polyAutoUnwrapc` == 1) {createAddAnchorsWindow; if (`objExists \"wrapMapAnchors\"`) defineWrapMapAnchors ;}else{autoUnwrapMapImp;createCheckUVResultWindow;cleanUpAfterUnwrap;textureWindowBakeEditorImage;}")
				AutoUnwrapBorderContinueButton;
		setParent ..;

		formLayout;
		text -label (uiRes("m_performPolyAutoUnwrap.kAutoUnwrapSBEEmpty")) 				
				-width 130
				-height 40;
		setParent ..;

		formLayout;
		button -label (uiRes("m_performPolyAutoUnwrap.kAutoUnwrapSBECancel"))
				-width 130
				-height 40
				-command  ("cleanUpAfterUnwrap; warning \""+(uiRes("m_performPolyAutoUnwrap.kCancellingUnwrap2"))+"\";" )
				AutoUnwrapBorderCancelButton;
		setParent ..;

		formLayout;
		colorSliderGrp -columnWidth3 80 80 0 -label (uiRes("m_performPolyAutoUnwrap.kAutoUnwrapBorderColorButtonName"))
				-width 160
				-height 40		
				-annotation (uiRes("m_performPolyAutoUnwrap.kAutoUnwrapBorderColorButtonTooltip"))
				-rgbValue 1.0 0.0 0.0
				-changeCommand ("borderColorCallback")
				AutoUnwrapBorderColorButton;
		setParent ..;

	showWindow $window;

	headsUpMessage -time 4.0 (uiRes("m_performPolyAutoUnwrap.kHUDBorderEdges"));
}

global proc createAddAnchorsWindow()
{
	getAnchorsInfoFromAutoUnwrapNode();

    //clear selection and switch to vert selection mode
    select -cl;
    SelectVertexMask;

	if (`window -exists autoUnwrapAAWindow`)
		deleteUI -window autoUnwrapAAWindow;

	string $window = `window -title (uiRes("m_performPolyAutoUnwrap.kAATitle")) 
							 -w 260
							 -h 250
							 -titleBar 1 
							 -titleBarMenu 1
							 -sizeable false
							 -minimizeButton false	
							 -maximizeButton false
							 autoUnwrapAAWindow` ;
	
	// Adjust top left corner.
	int $xy[] = `window -q -topLeftCorner autoUnwrapAAWindow`;
	window -e -topLeftCorner (100) ($xy[1]) autoUnwrapAAWindow;

	string $buttonGoback = (uiRes("m_performPolyAutoUnwrap.kAutoUnwrapGoBack1"));

	rowColumnLayout -numberOfRows 5
	    -width 260
		-rowHeight 1 50
		-rowHeight 2 50
		-rowHeight 3 50
		-rowHeight 4 50
		-rowHeight 5 50
		-rowSpacing 1 10;

		formLayout;
		button -label (uiRes("m_performPolyAutoUnwrap.kAutoUnwrapAddAnchors"))
				-width 130
				-height 40
				-command  ("defineWrapMapAnchors;" ) 
				AutoUnwrapAddAnchorsButton;
		setParent ..;

		formLayout;
		button -label (uiRes("m_performPolyAutoUnwrap.kAutoUnwrapRemoveAnchors"))
				-width 130
				-height 40
				-command  ("removeWrapMapAnchors;" )
				AutoUnwrapRemoveAnchorsButton;
		setParent ..;

		formLayout;
		button -label (uiRes("m_performPolyAutoUnwrap.kAutoUnwrapAAContinue"))
				-width 130
				-height 40
				-command  ("deleteUI -window autoUnwrapAAWindow; defineWrapMapAnchors; autoUnwrapMapImp; createCheckUVResultWindow; textureWindowBakeEditorImage;" )
				AutoUnwrapAnchorContinueButton;
		setParent ..;

		formLayout;
		button -label $buttonGoback
				-width 130
				-height 40
				-command  ("deleteUI -window autoUnwrapAAWindow; if (`objExists \"wrapMapAnchors\"`) delete wrapMapAnchors ; goBack;" )
				AutoUnwrapGoBackButton;
		setParent ..;
		
		formLayout;
		button -label (uiRes("m_performPolyAutoUnwrap.kAutoUnwrapAACancel"))
				-width 130
				-height 40
				-command  ("cleanUpAfterUnwrap; warning \""+(uiRes("m_performPolyAutoUnwrap.kCancellingUnwrap3"))+"\";" )
				AutoUnwrapAnchorCancelButton;
		setParent ..;

		formLayout;
		colorSliderGrp -columnWidth3 80 80 0 -label (uiRes("m_performPolyAutoUnwrap.kAutoUnwrapAnchorColorButtonName"))
				-width 160
				-height 40
				-annotation (uiRes("m_performPolyAutoUnwrap.kAutoUnwrapAnchorColorButtonTooltip"))
				-rgbValue 1.0 1.0 0.0
				-changeCommand ("\n")
				AutoUnwrapAnchorColorButton;
		setParent ..;

	showWindow $window;

	headsUpMessage -time 4.0 (uiRes("m_performPolyAutoUnwrap.kAnchorMessage"));
}

global proc createCheckUVResultWindow()
{
    if (`objExists "wrapMapOrigSelection"`)
        select -r wrapMapOrigSelection;

	string $finishMessage = (uiRes("m_performPolyAutoUnwrap.kHUDCheckResult"));
	headsUpMessage -time 4.0 $finishMessage;
}

global proc defineWrapMapFaces(){
    string $wrapMapOrigSelection[] = `ls -sl`;
    string $selectedMesh[] = `filterExpand -sm 12`;
    string $selectedFaces[] = `filterExpand -sm 34`;
    global string $gSelect;

    //create set for original selection
    if (`objExists "wrapMapOrigSelection"`)
        delete "wrapMapOrigSelection"; //start over
    sets -name "wrapMapOrigSelection";


    //Make sure either object of faces are selected not both
    if ((`size $selectedMesh` >= 1) && (`size $selectedFaces` >= 1))
        {
        select -r $wrapMapOrigSelection;
        string $wrapMapFacesMessage1 = (uiRes("m_performPolyAutoUnwrap.kWrapMapFacesMessage1"));
		string $wrapMapFacesMessage2 = (uiRes("m_performPolyAutoUnwrap.kWrapMapFacesMessage2"));
		error $wrapMapFacesMessage1 $wrapMapFacesMessage2;
        }
    select -r $selectedMesh $selectedFaces;
    ConvertSelectionToFaces;
    string $faceObjects[] = `listRelatives -parent`;

    //Make sure only one object is being used
    if ((`size $faceObjects`) > 1)
        {
        select -r $wrapMapOrigSelection;
        error (uiRes("m_performPolyAutoUnwrap.kSelectMoreThanOneObjectError"));
        }

    if ((size($selectedMesh) == 0) && (size($selectedFaces) == 0))
        {
        select -r $wrapMapOrigSelection;
		createSelectMeshOrFacesWindow;
        }

    else 
        {
        //select -r $selectedMesh $selectedFaces;
    	//ConvertSelectionToFaces;
    	string $facesToMap[] = `ls -selection -flatten`;
        //create set of faces
        if (`objExists "wrapMapFaces"` == 0)
            sets -name "wrapMapFaces";
        else
            sets -add "wrapMapFaces";


        setToolTo $gSelect;  //disable transform tools

        //Isolate select object or faces in 3d views
        if (`optionVar -q polyAutoUnwrapis`)
            {
        	$panels = `getPanel -type "modelPanel"`;
  	
        	for ($panel in $panels)
                {
                isolateSelect -state 1 $panel;
                select -r $facesToMap;
                isolateSelect -addSelected $panel;
                }
            }

        if (`optionVar -q polyAutoUnwraput`)
            {
            select -r $facesToMap;
            assignBaseShader;
            }

        //launch border edge selection window
        createSelectBorderEdgesWindow;

        //set edge color if necessary
        checkEdgeColorSetting;
        }
}

global proc defineWrapMapEdges(){

    string $selectedEdges[] = `filterExpand -sm 32`;
    string $hiddenEdges[];
    global string $gSelect;

    //check first for faces to map
    if (`objExists "wrapMapFaces"` == 0)
		createSelectMeshOrFacesWindow;

    if (size($selectedEdges) == 0)
        {
		warning (uiRes("m_performPolyAutoUnwrap.kNoSelectedEdges1"));
        if (`objExists "wrapMapBorderEdges"`) select -r wrapMapBorderEdges;
        }
    else {

	 //first check for hidden faces/edges in isolate select set to avoide accidental selection from edge loops
        if (`optionVar -q polyAutoUnwrapis`)
            {
		select -r "*ViewSelectedSet";
		InvertSelection ;
		ConvertSelectionToContainedEdges;
		$hiddenEdges = `ls -sl`;
            }


        select -r $selectedEdges;
	    select -d $hiddenEdges;
        //create set of edges
        if (`objExists "wrapMapBorderEdges"` == 0)
            sets -name "wrapMapBorderEdges";
        else
            sets -add "wrapMapBorderEdges";

		updateAutoUnwrapNodeBorderEdges();

		select -r $selectedEdges;
	    select -d $hiddenEdges;

        setToolTo $gSelect;  //disable transform tools
        }
}

global proc removeWrapMapEdges(){

    string $selectedEdges[] = `filterExpand -sm 32`;
    global string $gSelect;

    //check first for faces to map
    if (`objExists "wrapMapFaces"` == 0)
		createSelectMeshOrFacesWindow;

    if (size($selectedEdges) == 0)
		warning (uiRes("m_performPolyAutoUnwrap.kNoSelectedEdges2"));
    else {
        select -r $selectedEdges;
        //create set of edges
        if (`objExists "wrapMapBorderEdges"` == 0)
            warning (uiRes("m_performPolyAutoUnwrap.kNoWrapMapBorderEdges"));    
        else
            {
            sets -rm "wrapMapBorderEdges";
            }

		updateAutoUnwrapNodeBorderEdges();

		select -r $selectedEdges;

        setToolTo $gSelect;  //disable transform tools
        }
}

global proc defineWrapMapAnchors(){

    global string $gSelect;

	ConvertSelectionToVertices;
    string $selectedVerts[] = `filterExpand -sm 31`;

    //check first for faces to map
    if (`objExists "wrapMapFaces"` == 0)
		createSelectMeshOrFacesWindow;

    if (size($selectedVerts) == 0)
        {
		warning (uiRes("m_performPolyAutoUnwrap.kAnchorsMessage1"));
        if (`objExists "wrapMapAnchors"`) select -r wrapMapAnchors;
        }
    else {
        select -r $selectedVerts;

        //create set of verts
        if (`objExists "wrapMapAnchors"` == 0)
            sets -name "wrapMapAnchors";
        else
            sets -add "wrapMapAnchors";
        
		updateAutoUnwrapNodeAnchorVertices();

        select -r wrapMapAnchors;
        }

    setToolTo $gSelect;  //disable transform tools
}

global proc removeWrapMapAnchors(){

    global string $gSelect;

    //check first for faces to map
    if (`objExists "wrapMapFaces"` == 0)     
		createSelectMeshOrFacesWindow;

	ConvertSelectionToVertices;
    string $selectedVerts[] = `filterExpand -sm 31`;

    if (size($selectedVerts) == 0)
		warning (uiRes("m_performPolyAutoUnwrap.kAnchorMessage2"));
    else {
        select -r $selectedVerts;

        //create set of verts
        if (`objExists "wrapMapAnchors"` == 0)
            warning (uiRes("m_performPolyAutoUnwrap.kAnchorMessage3"));    
        else
            {
            sets -rm "wrapMapAnchors";
            }

		updateAutoUnwrapNodeAnchorVertices();

        select -r wrapMapAnchors;
        }

    setToolTo $gSelect;  //disable transform tools
}

global proc cleanUpAfterUnwrap(){

    //Un-Isolate select object or faces in 3d views
    if (`optionVar -q polyAutoUnwrapis`)
        {
    	$panels = `getPanel -type "modelPanel"`;
	
    	for ($panel in $panels)
            isolateSelect -state 0 $panel;
        }

    //Cleanup selection sets
    //
    if (`objExists "wrapMapFaces"`)
        {
        //select -r wrapMapFaces;
        delete wrapMapFaces;
        }
    if (`objExists "wrapMapBorderEdges"`)
        delete wrapMapBorderEdges;
    if (`objExists "wrapMapAnchors"`)
        delete wrapMapAnchors;
    if (`objExists "wrapMapOrigSelection"`)
        {
        select -r wrapMapOrigSelection;
        delete wrapMapOrigSelection;
        }

    //Reset selected edge color to user defined
    if (`optionVar -ex autoWrapUserEdgeColor`)
        {
        displayColor polyEdge -active `optionVar -q autoWrapUserEdgeColor`;
        optionVar -rm autoWrapUserEdgeColor;
        }

    //Kill scriptJob related to edge color setting
    killEdgeColorScriptJob;

	// Remove All the windows if exist.
	if (`window -exists autoUnwrapSBEWindow`)
		deleteUI -window autoUnwrapSBEWindow;

	if (`window -exists autoUnwrapAAWindow`)
		deleteUI -window autoUnwrapAAWindow;

	if (`window -exists autoUnwrapCUVRWindow`)
		deleteUI -window autoUnwrapCUVRWindow;

}

global proc goBack(){

    //Go back one step or start over
    //
    if (`objExists "wrapMapAnchors"`)
        {
        createAddAnchorsWindow;
        if (`objExists "wrapMapFaces"`) 
            {
            select -r wrapMapFaces;  
            if (`optionVar -q polyAutoUnwraput`) 
                assignBaseShader;
            }  
        select -r wrapMapAnchors;
        }

    else if (`objExists "wrapMapBorderEdges"`)
        {
        createSelectBorderEdgesWindow;
        if (`objExists "wrapMapFaces"`) 
            {
            select -r wrapMapFaces;  
            if (`optionVar -q polyAutoUnwraput`) 
                assignBaseShader;
            }  
        select -r wrapMapBorderEdges;
        }

    else if (`objExists "wrapMapFaces"`)
        {
        select -r wrapMapFaces;
		createSelectMeshOrFacesWindow;
        }

    else
        {
		createSelectMeshOrFacesWindow;
        } 
}

global proc setTextureResolution(int $resolution){

	string $nodes[] = `ls -sl`;
	
	for ($node in $nodes){
			catch (`addAttr -ln resolution $node`);
			setAttr ($node + ".resolution") $resolution;
		}
}


global proc assignCheckerShader(){
	
    string $shader;
	string $selection[] = `ls -selection`;

    if (`size $selection` == 0)
        warning (uiRes("m_performPolyAutoUnwrap.kCheckShaderMessage"));
    else
        {
        //turn on texture caching for better display
        string $texWinName[] = `getPanel -sty polyTexturePlacementPanel`;
        textureWindow -e -viewPortImage 1 $texWinName[0];


        if (`objExists "unwrapChekcerShader"`)
            {
            $shader = "unwrapChekcerShader";
            if ((`optionVar -q polyAutoUnwrapl` == 3)  && (`objExists "unwrapTestPattern"`))
                if (`attributeExists resolution unwrapTestPattern`)  deleteAttr ("unwrapTestPattern.resolution");
            else
                {
                if (`attributeExists resolution unwrapTestPattern` == 0) 
          			catch (`addAttr -ln resolution unwrapTestPattern`);
    			setAttr ("unwrapTestPattern.resolution") 512;
                }
                
            }
        else
            {	
        	string $shader = `shadingNode -asShader lambert -name "unwrapChekcerShader"`;
        	string $texture = `shadingNode -asTexture checker -name "unwrapTestPattern"`;
        
        	//change shader colour	
        	setAttr ($texture + ".color1") -type double3 0.3 0.3 0.3;
        	setAttr ($texture + ".color2") -type double3 0.7 0.7 0.7;
            
            //set higher resolution and turn off texture caching
            if (`optionVar -q polyAutoUnwrapl` != 3)
                {
                catch (`addAttr -ln resolution $texture`);
    			setAttr ($texture + ".resolution") 512;
                }
    	
        	//adjust 2d texture
        	string $placement = `shadingNode -asUtility place2dTexture`;
        	connectAttr -f ($placement + ".outUV") ($texture + ".uvCoord");
        	connectAttr -f ($placement + ".outUvFilterSize") ($texture + ".uvFilterSize");
        	setAttr ($placement + ".repeatU") 13.5;
        	setAttr ($placement + ".repeatV") 13.5;
        
        
        	//connect to shader
        	connectAttr -force ($texture + ".outColor") ($shader + ".color");
            }


        //select object
    	select -replace $selection;
    	hyperShade -assign unwrapChekcerShader;
        }
	
}


global proc checkEdgeColorSetting(){

    global int $edgeColorScriptJobID = -1;

    //set selected edge color to red
	//Because the new UI containing a Border Color button group to setup border colors, no need to check whether the color is setup.
    //if (`optionVar -q polyAutoUnwrapborderColor`) 
    {
        warning (uiRes("m_performPolyAutoUnwrap.kCheckEdgeColorWarning"));
        if (`optionVar -ex autoWrapUserEdgeColor` == 0)
            optionVar -iv autoWrapUserEdgeColor `displayColor -q  polyEdge -active`;  //keep track of current user defined color
        displayColor polyEdge -active 13;  //Red
        //set scriptJob to reset color on new scene or file open
        $edgeColorScriptJobID = `scriptJob -runOnce true  -event "SceneOpened"  "if (`optionVar -ex autoWrapUserEdgeColor`) { displayColor polyEdge -active `optionVar -q autoWrapUserEdgeColor`; optionVar -rm autoWrapUserEdgeColor;}"`;
    }
}


global proc killEdgeColorScriptJob(){

    global int $edgeColorScriptJobID;

    if ($edgeColorScriptJobID != -1)
        scriptJob -k $edgeColorScriptJobID;
    $edgeColorScriptJobID = -1;
}


global proc assignBaseShader(){
	
    string $shader;
	string $selection[] = `ls -selection`;

    if (`size $selection` == 0)
        warning (uiRes("m_performPolyAutoUnwrap.kNothingSelectedForShaderWarning"));
    else
        {
        //turn on texture caching for better display
        string $texWinName[] = `getPanel -sty polyTexturePlacementPanel`;
        textureWindow -e -viewPortImage 1 $texWinName[0];


        if (`objExists "unwrapBaseShader"`)
            $shader = "unwrapBaseShader";
    
        else
            {	
        	string $shader = `shadingNode -asShader lambert -name "unwrapBaseShader"`;
            setAttr ($shader+".colorR") 0;
            setAttr ($shader+".colorG") 0.6;
            setAttr ($shader+".colorB") 0.4;
            setAttr ($shader+".diffuse") 1;
            }

        //select object
    	select -replace $selection;
    	hyperShade -assign unwrapBaseShader;
        }
	
}

global proc autoUnwrapMapImp(){

	// Method: Unfold=0, Advanced Unfold=1
	// Fit: 0=UniformFit 1=StretchFit 2=NoFit

    string $method = `optionVar -q polyAutoUnwrapc` ;
    string $initialProjection = `optionVar -q polyAutoUnwrapi` ;
    string $Layout = `optionVar -q polyAutoUnwrapl` ;

    string $facesToMap[];
    string $borderEdges[];
    string $anchorVerts[];
    string $anchorUVs[];

    global string $gSelect;
	string $noAdditionEdgesWarning = (uiRes("m_performPolyAutoUnwrap.kAutoUnwrapImpMessage1"));
	string $cancellingUnwrap = (uiRes("m_performPolyAutoUnwrap.kCancellingUnwrap"));

    //check for user-defined faces to map
    //
    if (`objExists "wrapMapFaces"`)
        select -r wrapMapFaces;
    else 
        {
        cleanUpAfterUnwrap;
		createSelectMeshOrFacesWindow;
        }
 
    //double check to make sure set actually contains faces
	string $facesToMap[] = `ls -selection -flatten`;
	if (size($facesToMap) == 0){
		createSelectMeshOrFacesWindow;
	}


    //check for user-defined faces to map
    //
    if (`objExists "wrapMapBorderEdges"`)
        select -r wrapMapBorderEdges;
    else 
        {
        select -cl;
		warning $noAdditionEdgesWarning;
	    }

    //double check to make sure set actually contains edges
	string $borderEdges[] = `ls -selection -flatten`;
	if (size($borderEdges) == 0){
		warning $noAdditionEdgesWarning;
	}

    
	// Create UVs
    //
    select -r $facesToMap;
 
	updateAutoUnwrapMethodAndInitProjection();

    //Unfold if necessary
    //check for user-defined verts to use as unfold anchors
    //
    if (`objExists "wrapMapAnchors"`) 
        {
        select -r wrapMapAnchors;
        setToolTo $gSelect;  //disable transform tools to prevent warning
        ConvertSelectionToUVs;
        $anchorUVs = `ls -sl -flatten`;
        //warning "Using anchors\n";
        }
    else 
        {
    	warning( (uiRes("m_performPolyAutoUnwrap.kAutoUnwrapImpMessage3")) );
        select -cl;
    $anchorUVs = `ls -sl`;
    }


    //do unfold with or without anchors
    select -r $facesToMap;
    setToolTo $gSelect;  //disable transform tools to prevent warning
    ConvertSelectionToUVs;
    if ($method == 0) //basic
         Unfold3D -u -ite 1 -p 1 -bi 1 -tf 1 -ms 1024 -rs 2;
    else if ($method == 1)  //symmetry
        {
        select -d $anchorUVs;
        Unfold3D -u -ite 1 -p 1 -bi 1 -tf 1 -ms 1024 -rs 2;
        }
	

	//Layout or fit to texture space accordingly
	//
	select -r $facesToMap;
    
	if ($method == 0) //unfold
        {
    	if ($Layout == 0) //uniform fit and rotate
            //polyMultiLayoutUV -lm 1 -sc 1 -rbf 2 -fr 1 -ps 0.2 -l 2 -psc 2 -su 1 -sv 1 -ou 0 -ov 0;
            polyLayoutUV -lm 1 -sc 1 -se 0 -rbf 2 -fr 1 -ps 0.2 -l 2 -ch 1;
        else if ($Layout == 1) //Stretch fit and rotate
            //polyMultiLayoutUV -lm 1 -sc 2 -rbf 2 -fr 1 -ps 0.2 -l 2 -psc 2 -su 1 -sv 1 -ou 0 -ov 0;
            polyLayoutUV -lm 1 -sc 2 -se 0 -rbf 2 -fr 1 -ps 0.2 -l 2 -ch 1;
        else if ($Layout == 2) //Prop fit and rotate
            polyMultiLayoutUV -lm 1 -sc 1 -rbf 2 -fr 1 -ps 0.2 -l 2 -psc 2 -su 1 -sv 1 -ou 0 -ov 0;
            //polyLayoutUV -lm 1 -sc 2 -se 0 -rbf 2 -fr 1 -ps 0.2 -l 2 -ch 1;
        else // none
            //print "No layout\n";
            //polyMultiLayoutUV -lm 1 -sc 0 -rbf 0 -fr 1 -ps 0.2 -l 2 -psc 2 -su 1 -sv 1 -ou 0 -ov 0;
            polyLayoutUV -lm 1 -sc 0 -se 0 -rbf 0 -fr 1 -ps 0.2 -l 2 -ch 1;
        }

	else if ($method == 1) //unfold symmetrical
        {

    	if ($Layout == 0) //Uniform fit no rotate
            //polyMultiLayoutUV -lm 1 -sc 1 -rbf 0 -fr 1 -ps 0.2 -l 2 -psc 2 -su 1 -sv 1 -ou 0 -ov 0;
            polyLayoutUV -lm 1 -sc 1 -se 0 -rbf 0 -fr 1 -ps 0.2 -l 2 -ch 1;
        else if ($Layout == 1) //Stretch fit no rotate
            //polyMultiLayoutUV -lm 1 -sc 2 -rbf 0 -fr 1 -ps 0.2 -l 2 -psc 2 -su 1 -sv 1 -ou 0 -ov 0;
            polyLayoutUV -lm 1 -sc 2 -se 0 -rbf 0 -fr 1 -ps 0.2 -l 2 -ch 1;
        else if ($Layout == 2) //Prop fit no rotate
            polyMultiLayoutUV -lm 1 -sc 1 -rbf 0 -fr 1 -ps 0.2 -l 2 -psc 2 -su 1 -sv 1 -ou 0 -ov 0;
            //polyLayoutUV -lm 1 -sc 2 -se 0 -rbf 0 -fr 1 -ps 0.2 -l 2 -ch 1;
        else // none
            //print "No layout\n";
            //polyMultiLayoutUV -lm 1 -sc 0 -rbf 0 -fr 1 -ps 0.2 -l 2 -psc 2 -su 1 -sv 1 -ou 0 -ov 0;
            polyLayoutUV -lm 1 -sc 0 -se 0 -rbf 0 -fr 1 -ps 0.2 -l 2 -ch 1;
        }


    if (`optionVar -q polyAutoUnwraput`)
        assignCheckerShader;


    //update cached texture in Texture Editor just in case
    textureWindowBakeEditorImage;


    //cleanup
    //cleanUpAfterUnwrap;
    select -cl;
}

global proc string performPolyAutoUnwrap (int $option)
{
	string $prefix = "polyAutoUnwrap";
	string $intVars[] ={"c", "i", "l", "ut", "is", "cm", "borderColor", "anchorColor"};
	string $cmd="";

	switch ($option) 
	{
		case 0:
			// Method, Intial Projecion, Layout, Test Shader, Isolate. 
			setOptionVars($prefix, false, $intVars);
			cleanUpAfterUnwrap();
			defineWrapMapFaces;
		break;
		case 1:
			polyAutoUnwrapOptions($prefix, $intVars);
			break;
		case 2:
			$cmd="performPolyAutoUnwrap 0";
			break;
	}
	return $cmd;
}
