// Copyright (C) 1997-2014 Autodesk, Inc., and/or its licensors.
// All rights reserved.
//
// The coded instructions, statements, computer programs, and/or related
// material (collectively the "Data") in these files contain unpublished
// information proprietary to Autodesk, Inc. ("Autodesk") and/or its licensors,
// which is protected by U.S. and Canadian federal copyright law and by
// international treaties.
//
// The Data is provided for use exclusively by You. You have the right to use,
// modify, and incorporate this Data into other products for purposes authorized 
// by the Autodesk software license agreement, without fee.
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND. AUTODESK
// DOES NOT MAKE AND HEREBY DISCLAIMS ANY EXPRESS OR IMPLIED WARRANTIES
// INCLUDING, BUT NOT LIMITED TO, THE WARRANTIES OF NON-INFRINGEMENT,
// MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE, OR ARISING FROM A COURSE 
// OF DEALING, USAGE, OR TRADE PRACTICE. IN NO EVENT WILL AUTODESK AND/OR ITS
// LICENSORS BE LIABLE FOR ANY LOST REVENUES, DATA, OR PROFITS, OR SPECIAL,
// DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES, EVEN IF AUTODESK AND/OR ITS
// LICENSORS HAS BEEN ADVISED OF THE POSSIBILITY OR PROBABILITY OF SUCH DAMAGES.

//
//
//  Creation Date:  2002
//
// Description: Create a pond, or fluid with a water surface simulation texturing the ocean shader
//				if it does not exist already, and then create wake and foam emitters for selected objects.
//	

proc string createWaterSurfaceFluidTexture( string $oceanShader, float $pondSize )
{
	// create a 3d fluid texture, make it a 2d simulation 
	// and texture the waveHeightOffset
	// of the ocean shader with it's outAlpha.
	string $fluidShape = `shadingNode -asTexture fluidTexture3D -n "OceanWakeTexture#"`;
	connectAttr time1.outTime ($fluidShape + ".currentTime");
	string $tforms[] = `listTransforms $fluidShape`;
	string $fluid = $tforms[0];
	setAttr ($fluidShape + ".shadedDisplay") 0;
	setAttr ($fluidShape + ".solver") 2;
	setAttr ($fluidShape + ".is2d") 1;
	setAttr ($fluidShape + ".velocityDamp") 0.02;
	setAttr ($fluidShape + ".wireframeDisplay") 0;
	setAttr ($fluidShape + ".resolution") 100 100 1;
	setAttr ($fluidShape + ".dimensions") $pondSize $pondSize ($pondSize*0.4);
	setAttr ($fluidShape + ".densityScale") 1.0;

	setAttr ($fluidShape + ".boundaryDraw") 4;
	setAttr ($fluidShape + ".dropoffShape") 2;
	setAttr ($fluidShape + ".boundaryX") 0;
	setAttr ($fluidShape + ".boundaryY") 0;
	setAttr ($fluidShape + ".boundaryZ") 0;
	setAttr ($fluidShape + ".renderInterpolator") 3;
	setAttr ($fluidShape + ".alphaGain") 4.0;
	setAttr ($fluid + ".rx") -90;
	connectAttr -f ($fluidShape + ".outAlpha") ($oceanShader + ".waveHeightOffset");

	return( $fluidShape );
}
proc string createFoamFluidTexture( string $oceanShader, float $pondSize )
{
	// create a 3d fluid texture, make it a 2d simulation and texture the foamOffset
	// of the ocean shader with it's outAlpha.
	string $fluidShape = `shadingNode -asTexture fluidTexture3D -n "OceanWakeFoamTexture#"`;
	connectAttr time1.outTime ($fluidShape + ".currentTime");

	string $tforms[] = `listTransforms $fluidShape`;
	string $fluid = $tforms[0];
	setAttr ($fluidShape + ".shadedDisplay") 0;
	setAttr ($fluidShape + ".solver") 1; // a normal ns fluid
	setAttr ($fluidShape + ".is2d") 1;
	setAttr ($fluidShape + ".wireframeDisplay") 0;
	setAttr ($fluidShape + ".resolution") 50 50 1;
	setAttr ($fluidShape + ".dimensions") $pondSize $pondSize ($pondSize*0.4);
	setAttr ($fluidShape + ".densityMethod") 0;
	setAttr ($fluidShape + ".densityScale") 1.0;
	setAttr ($fluidShape + ".velocityMethod") 0;
	setAttr ($fluidShape + ".temperatureMethod") 2;
	setAttr ($fluidShape + ".boundaryDraw") 4;
	setAttr ($fluidShape + ".dropoffShape") 2;
	setAttr ($fluidShape + ".boundaryX") 0;
	setAttr ($fluidShape + ".boundaryY") 0;
	setAttr ($fluidShape + ".boundaryZ") 0;
	setAttr ($fluidShape + ".temperatureDissipation") 1.0;
	setAttr ($fluidShape + ".temperatureDiffusion") 0.08;
	setAttr ($fluidShape + ".turbulenceStrength") 0.7;
	setAttr ($fluidShape + ".turbulenceFrequency") 2.0;
	setAttr ($fluidShape + ".turbulenceSpeed") 1.5;
	setAttr ($fluidShape + ".opacityInput") 6.0;
	setAttr ($fluidShape + ".alphaGain") 1.0;
	setAttr ($fluidShape + ".opacityTexture") 1;
	setAttr ($fluidShape + ".textureType") 4;
	setAttr ($fluidShape + ".invertTexture") 1;
	setAttr ($fluidShape + ".inflection") 1;
	setAttr ($fluidShape + ".frequency") 10;
	setAttr ($fluidShape + ".opacityTexGain") 0.3;
	setAttr ($fluidShape + ".depthMax") 3;
	setAttr ($fluidShape + ".renderInterpolator") 3;
	setAttr ($fluid + ".rx") -90;

	connectAttr -f ($fluidShape + ".outAlpha") ($oceanShader + ".foamOffset");
	expression -s ("float $foamSpeed = 1.0;\n"
				  + $fluidShape + ".textureTime = time * $foamSpeed;\n" );

	return( $fluidShape );
}

proc string createOceanWakeEmitter(string $wakeFluid, string $foamFluid, float $wakeIntensity, float $foamIntensity)
{
	// Create a fluid emitter for the passed in fluids and set the density 
	// emission rates
	string $emitter[] = `fluidEmitter -n "OceanWakeEmitter#" -pos 0 0 0 -type volume -vsh sphere -der $wakeIntensity -her $foamIntensity -fer 1 -fdr 2 -r 100.0 -cye none -cyi 1 -mxd 1 -mnd 0 `;
	setAttr ($emitter[0] + ".fluidDropoff") 0.5;
	setAttr ($emitter[0] + ".fluidJitter") 0;
	if( $wakeIntensity > 0 ){
		connectDynamic -em $emitter[0] $wakeFluid;
	}
	if( $foamIntensity > 0 ){
		connectDynamic -em $emitter[0] $foamFluid;
	}
	string $emitNotes = ("The following emitter attributes control wake behavior:\n"
						+"Density/Voxel/Sec controls the wake intensity.\n"
						+"Heat/Voxel/Sec controls foam creation if the Temperature Method "
						+"on the OceanWakeFoamTexture is set to Dynamic Grid.");
	addAttr -sn nts -ln notes -dt "string" $emitter[0];
	setAttr -type "string" ($emitter[0] + ".notes") $emitNotes;

	return($emitter[0]);
}


global proc createOceanWake( float $pondSize, float $wakeIntensity, float $foamIntensity)
{
	if( !fluidEditLicenseFound() ) {	
		error(uiRes("m_create2DFluid.kNoFluidLicense"));
		return;
	}

	// we use createOceanWake as the front end for ocean and pond wakes now
	string $oceanShader = getCurrentOceanOrPond();
	if( $oceanShader == "" ){
		return;
	}
	if( nodeType($oceanShader) == "fluidShape" ) {
		createWake($wakeIntensity, $foamIntensity);
		return;
	}


	string $wakeFluid = getCurrentOceanWake();
	string $foamFluid = getCurrentOceanFoam();

	// get objects to create wakes for
	string $sel[] = `ls -sl`; // restrict to transforms??
	int $numSel = size($sel);
	string $errorStr = (uiRes("m_createOceanWake.kCouldNotCreateWake"));
	if( ($wakeIntensity > 0.0) && $wakeFluid == "" ){
		$wakeFluid = createWaterSurfaceFluidTexture( $oceanShader, $pondSize );
		if( $wakeFluid != "" ){
			string $shapeHelp = ("This 3D fluid texture uses a 2D spring mesh height model to"
				+" model a water surface. One can generate wakes into it by using fluid"
				+" emitters. Negative density emission will push the surface down"
				+" while positive values will push the surface up. This surface"
				+" renders as a raytraced volumetric surface. Waves that are larger"
				+" than the vertical fluid bounds will be clipped. The size parameter"
				+" can be increased to provide a larger range of travel, although the"
				+" volume rendering may be a bit slower. Note that this fluid texture is"
				+" technically a fluidTexture3D, which automatically projects the texture"
				+" in worldspace, however it uses a 2D simulation. This is handled by the"
				+" setting of the hidden fluid parameter is2D to 1.");

			addAttr -sn nts -ln notes -dt "string" $wakeFluid;
			setAttr -type "string" ($wakeFluid + ".notes") $shapeHelp;
		}
		if( $wakeFluid == "" ){
			error($errorStr);
			return;
		}
	}
	if( ($foamIntensity > 0.0) && $foamFluid == "" ){
		$foamFluid = createFoamFluidTexture( $oceanShader, $pondSize );
		if( $foamFluid != "" ){
			string $shapeHelp = ("This 3D fluid texture uses simple dissipation and diffusion"
				+" and turbulence on a 2D grid to model foam propagation on water. One can"
				+" generate foam by using fluid emitters. "
				+" Note that this fluid texture is"
				+" technically a fluidTexture3D, which automatically projects the texture"
				+" in worldspace, however it uses a 2D simulation. This is handled by the"
				+" setting of the hidden fluid parameter is2D to 1.");

			addAttr -sn nts -ln notes -dt "string" $foamFluid;
			setAttr -type "string" ($foamFluid + ".notes") $shapeHelp;
		}
		if( $foamFluid == "" ){
			error($errorStr);
			return;
		}
	}

	int $foundActualBoat = false;
	if( $numSel > 0 ){
		for( $i = 0; $i < $numSel; $i++ ){
			string $boatObj = $sel[$i];
			if( isValidBoatObject( $boatObj ) ){
				string $emitter = createOceanWakeEmitter($wakeFluid, $foamFluid, $wakeIntensity, $foamIntensity);
				// parent the emitter under the boat
				parent -r $emitter $boatObj;
				$foundActualBoat = true;
			}
		}
	}

	if(!$foundActualBoat) {
		// create wake without an object if nothing boatlike is selected
		createOceanWakeEmitter($wakeFluid, $foamFluid, $wakeIntensity, $foamIntensity);
	}
}
