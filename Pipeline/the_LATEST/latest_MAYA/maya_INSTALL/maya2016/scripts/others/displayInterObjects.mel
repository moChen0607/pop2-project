// Copyright (C) 1997-2014 Autodesk, Inc., and/or its licensors.
// All rights reserved.
//
// The coded instructions, statements, computer programs, and/or related
// material (collectively the "Data") in these files contain unpublished
// information proprietary to Autodesk, Inc. ("Autodesk") and/or its licensors,
// which is protected by U.S. and Canadian federal copyright law and by
// international treaties.
//
// The Data is provided for use exclusively by You. You have the right to use,
// modify, and incorporate this Data into other products for purposes authorized 
// by the Autodesk software license agreement, without fee.
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND. AUTODESK
// DOES NOT MAKE AND HEREBY DISCLAIMS ANY EXPRESS OR IMPLIED WARRANTIES
// INCLUDING, BUT NOT LIMITED TO, THE WARRANTIES OF NON-INFRINGEMENT,
// MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE, OR ARISING FROM A COURSE 
// OF DEALING, USAGE, OR TRADE PRACTICE. IN NO EVENT WILL AUTODESK AND/OR ITS
// LICENSORS BE LIABLE FOR ANY LOST REVENUES, DATA, OR PROFITS, OR SPECIAL,
// DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES, EVEN IF AUTODESK AND/OR ITS
// LICENSORS HAS BEEN ADVISED OF THE POSSIBILITY OR PROBABILITY OF SUCH DAMAGES.

//
//
//  Creation Date:  July, 1997
//
//  Description:
//      This script allows toggling the display of intermediate objects
//		such as those created by deformers to store the pre-deformed shape.
//
//  Input Arguments:
//		int $state: whether to turn display on or off
//
//  Return Value:
//      None.
//
//
//  Method: futurePlug(string $node, string $plug)
//
//  Description:
//  Given a $node and a $plug ($plug is optional on all
//  nodes except deformers), this method returns the name
//  of the plug that inputs the shape data from this
//  node.
//
//  If it does not recognize the node type of the given
//  node, it returns "".
//
//  Currently supported node types:
//   lattice, nurbsSurface, nurbsCurve, mesh, groupParts, deformers,
//   stitchSrf, trim, polyModifier, deleteComponent, makeGroup,
//	 detachSurface
//
global proc int plugMultiIndex(string $plug)
//
//  Method:   int plugMultiIndex(string $plug)
//
//  Description:
//    Given a plug that contains a multiIndex, return the index
//
//    If no multiIndex is found, returns -1.
//	  If plug is a multi multi, returns the first multiIndex only.
//
{
	string $buffer[], $buffer2[];
	tokenize($plug,"[",$buffer);
	if (size($buffer) != 2) {
		return(-1);
	}
	tokenize($buffer[1],"]",$buffer2);
	return $buffer2[0];
}




global proc string futurePlug(string $node, string $plug)
{
	string $nt = nodeType($node);
	string $futureAttr = "";

	string $testSel[]= `ls -type geometryFilter $node`;
	string $testMM[]= `ls -type polyBase $node`;
	string $testAPI[]= `ls -type THsurfaceShape $node`;	
	
	if      ($nt == "lattice")		{ $futureAttr = ".wl[0]"; }
	else if ($nt == "nurbsSurface")	{ $futureAttr = ".ws[0]"; }
	else if ($nt == "nurbsCurve") 	{ $futureAttr = ".ws[0]"; }
	else if ($nt == "stitchSrf") 	{ $futureAttr = ".os"; }
	else if ($nt == "closeSurface")	{ $futureAttr = ".os"; }
	else if ($nt == "reverseSurface")	{ $futureAttr = ".os"; }		
	else if ($nt == "smoothCurve") 	{ $futureAttr = ".oc"; }
	else if ($nt == "rebuildCurve")	{ $futureAttr = ".oc"; }
	else if ($nt == "reverseCurve")	{ $futureAttr = ".oc"; }			
	else if ($nt == "trim") 		{ $futureAttr = ".os"; }
	else if ($nt == "untrim") 		{ $futureAttr = ".os"; }	
	else if ($nt == "transformGeometry")   { $historyAttr = ".og"; }
	else if ($nt == "mesh") 		{ $futureAttr = ".w[0]";  }
	else if ($nt == "detachSurface") { $futureAttr = ".os[0]";  }	
	else if ($nt == "groupParts")   { $futureAttr = ".og"; }
	else if ($nt == "makeGroup")    { $futureAttr = ".og"; }
	else if ($nt == "deleteComponent") { $futureAttr = ".og"; }	
	else if (size($testSel)) {
		int $index = plugMultiIndex($plug);
		if ($index == -1) {
			return("");
		}
		$futureAttr = (".og["+$index+"]");
	} else if (size($testMM)) {
		// TdnpolyBase
		//
		$futureAttr = ".output";
	} else if (size($testAPI)) {
		// plugin mesh
		//
		$futureAttr = ".outputSurface";
	} else {		
		return("");
	}

	return ($node+$futureAttr);
}

global proc string historyPlug(string $node, string $plug)
//
//  Method: historyPlug(string $node, string $plug)
//
//  Description:
//  Given a $node and a $plug ($plug is optional on all
//  nodes except deformers), this method returns the name
//  of the plug that inputs the shape data into this
//  node.
//
//  If it does not recognize the node type of the given
//  node, it returns "".
//
//  Currently supported node types:
//   lattice, nurbsSurface, nurbsCurve, mesh, groupParts, deformers,
//   stitchSrf, trim, polyModifier, deleteComponent, makeGroup,
//	 detachSurface
//
{
	string $nt = nodeType($node);
	string $historyAttr = "";

	string $testSel[]= `ls -type geometryFilter $node`;
	string $testMM[]= `ls -type polyModifier $node`;
	string $testAPI[]= `ls -type THsurfaceShape $node`;		

	if      ($nt == "lattice")		{ $historyAttr = ".li"; }
	else if ($nt == "nurbsSurface")	{ $historyAttr = ".cr"; }
	else if ($nt == "nurbsCurve") 	{ $historyAttr = ".cr"; }
	else if ($nt == "stitchSrf") 	{ $historyAttr = ".is"; }
	else if ($nt == "closeSurface")	{ $historyAttr = ".is"; }
	else if ($nt == "reverseSurface")	{ $historyAttr = ".is"; }	
	else if ($nt == "smoothCurve") 	{ $historyAttr = ".ic"; }
	else if ($nt == "rebuildCurve") { $historyAttr = ".ic"; }
	else if ($nt == "reverseCurve") { $historyAttr = ".ic"; }				
	else if ($nt == "trim")		 	{ $historyAttr = ".is"; }
	else if ($nt == "untrim")		{ $historyAttr = ".is"; }	
	else if ($nt == "transformGeometry")   { $historyAttr = ".ig"; }
	else if ($nt == "mesh") 		{ $historyAttr = ".i";  }
	else if ($nt == "groupParts")   { $historyAttr = ".ig"; }
	else if ($nt == "makeGroup")    { $historyAttr = ".ig"; }
	else if ($nt == "deleteComponent") { $historyAttr = ".ig"; }		
	else if ($nt == "insertKnotSurface") { $historyAttr = ".is"; }		
	else if ($nt == "detachSurface")   { $historyAttr = ".is"; }	
	else if (size($testSel)) {
		int $index = plugMultiIndex($plug);
		if ($index == -1) {
			return("");
		}
		$historyAttr = (".input["+$index+"].inputGeometry");		
	} else if (size($testMM)) {
		$historyAttr = ".inputPolymesh";
	} else if (size($testAPI)) {
		// plugin mesh
		//
		$historyAttr = ".inputSurface";
	} else {		
		return("");
	}

	return ($node+$historyAttr);
}

proc string historyOrFuturePlug(string $node, string $plug, int $history)
{
	string $histPlug = "";
	if ($history) $histPlug = historyPlug($node, $plug);
	else          $histPlug = futurePlug($node, $plug);
	return $histPlug;
}

proc int connIsHistoryPlug(string $conns[])
//
// Return true if one of the strings in $conns is a history plug.
//
{
	int $ii;
	for ($ii = 0; $ii < size($conns); $ii++) {
		string $buffer[];
		tokenize($conns[$ii],".",$buffer);
		string $node = $buffer[0];
		string $hplug = historyPlug($node,$conns[$ii]);
		string $shortName[] = `listAttr -sn $conns[$ii]`;
		if ($hplug == ($node+"."+$shortName[0])) {
			return 1;
		}
	}
	return 0;
}

proc string findOtherObject(string $shape, int $history)
{
	string $testInput[] = `ls -type controlPoint $shape`;
	if (0 == size($testInput)) {
		error( (uiRes("m_displayInterObjects.kMustSelectDeformable")));
		return 0;
	}

	string $histPlug = historyOrFuturePlug($shape,"",$history);

	// make sure the object has history before starting the loop
	//
	string $conns[];
	int $result = 0;

	while(true) {
		$conns = `listConnections -p true $histPlug`;
		if (! size($conns)) {
			return "";
		}
		
		// listConnections returns transform name for shapes, so make
		// sure we get the node name and not the transform
		//
		string $buffer[];
		tokenize($conns[0],".",$buffer);
		$obj = $buffer[0];

		string $shapeCheck[] = `ls -type controlPoint $obj`;
		if (size($shapeCheck)) {
			return $obj;
		}
		
		// get the name of the plug feeding the shape into this node
		//
		$histPlug = historyOrFuturePlug($obj,$conns[0],$history);
		if ($histPlug == "") {
			// stop, we can't find any more history
			//
			return "";
		}
	}
	return "";
}


global proc displayInterObjects(int $state)
//
// Display ($state = 0) or Hide ($state = 1) intermediate objects.
//
{

	int $ii;
	string $cmd;
	string $selectCmd = "select -r "; 	// for selection when toggling on
	int $toggleCounter = 0; 			// for error reporting
	int $alreadyCounter = 0;			// for error reporting

	string $selObjs[5] = `ls -sl`;
	if (0 == size($selObjs)) {
		error( (uiRes("m_displayInterObjects.kNoDeformableSelected")));
		return;
	}

	string $currSel[5] = `ls -sl -type controlPoint -type particle`;
	if (size($currSel)) {
		// find transform above selected shape
		//
		string $parents[] = `listRelatives -path -parent $currSel[0]`;
		$selObjs = `listRelatives -path $parents[0]`;
	} else {
		// find shapes below the selected object
		//
		$selObjs = `listRelatives -path`;
		if (1 == size($selObjs)) {
			string $other = findOtherObject($selObjs[0],0);
			if ("" == $other) {
				$other = findOtherObject($selObjs[0],1);
			}
			if ("" != $other) {
				$selObjs[1] = $other;
			}
		}
	}
	
	// loop through the selected shapes
	//
	int $nsel = size($selObjs);
	for ($ii = 0; $ii < $nsel; $ii++) {

		$cmd = "";
		string $obj = $selObjs[$ii];
		string $nt = nodeType($obj);
		string $testAPI[]= `ls -type THsurfaceShape $obj`;	
		string $futureAttr;
		string $historyAttr;		
		int    $hasHistory = 1;

		if      ($nt == "lattice")		{ $historyAttr = ".li"; }
		else if ($nt == "nurbsSurface")	{ $historyAttr = ".cr"; }
		else if ($nt == "nurbsCurve") 	{ $historyAttr = ".cr"; }
		else if ($nt == "mesh") 		{ $historyAttr = ".i";  }
		else if ($nt == "subdiv") 		{ $historyAttr = ".cr";  }
		else if (size($testAPI) > 0)	{ $historyAttr = ".is"; }
		else if ($nt == "particle")     { $hasHistory = 0; }
		else continue;		

		if      ($nt == "lattice")		{ $futureAttr = ".wl[0]"; }
		else if ($nt == "nurbsSurface")	{ $futureAttr = ".ws[0]"; }
		else if ($nt == "nurbsCurve") 	{ $futureAttr = ".ws[0]"; }
		else if ($nt == "mesh") 		{ $futureAttr = ".w[0]";  }
		else if ($nt == "subdiv") 		{ $futureAttr = ".ws[0]";  }
		else if (size($testAPI) > 0)	{ $futureAttr = ".ws[0]";  }		
		else if ($nt == "particle")     { $futureAttr = ".pos";    }

		if( $hasHistory ) {
			// $selFuture contains nodes in the future of the selected
			//
			string $selFuture[10] = `listConnections -p true ($obj+$futureAttr)`;
			if (! $state && size($selFuture) == 0) {
				continue;
			}

			// $selHist contains nodes in the history of the selected
			// shape. Continue if the node does not have history.
			//
			string $selHist[10] = `listConnections -p true ($obj+$historyAttr)`;
			if (   $state
				   && (size($selFuture) == 0 || !connIsHistoryPlug($selFuture))
				   && size($selHist) > 0 ) {
				$selectCmd += $obj + " ";
				continue;
			}
		} else {
			// $selFuture contains nodes in the future of the selected
			//
			string $selFuture[10] = `listConnections -p true ($obj+$futureAttr)`;
			if( $state && (size($selFuture) == 0) ) {
				continue;
			}
		}

		// get the current state of the intermediate object attr
		//
		int $currentState = `getAttr ($obj+".io")`;

		if ($state) {
			// toggle on the display of all except the final object in
			// the history
			//
			if (! $currentState) {
				// construct the setAttr command
				//
				$cmd = "setAttr "+$obj+".io 1";
			} else {
				$alreadyCounter++; // for error reporting
			}
		} else {
			
			if ($currentState) {
				// construct the setAttr command
				//
				$cmd = "setAttr "+$obj+".io 0";
				$selectCmd += $obj + " ";
			} else {
				$alreadyCounter++; // for error reporting
			}
		}
		if ($cmd != "") {
			evalEcho $cmd;
			$toggleCounter++;

			// If we're making subdivs visible, they need 
			// to have a shader.
			//
			if( !$state && ( $nt == "subdiv" ) ) {
				subdAssignDefaultShader( $obj );
			}
		}
	}

	// error reporting
	//
	if (0 == $toggleCounter) {
		if ($alreadyCounter) {
			if ($state) {
				error( (uiRes("m_displayInterObjects.kDisplayAlreadyOff")));
			} else {
				error( (uiRes("m_displayInterObjects.kDisplayAlreadyOn")));
			}
		} else {
			error( (uiRes("m_displayInterObjects.kFoundNoInt")));
		}
	} else if ($state) {
		// result reporting and select command to select deformed objects
		//
		evalEcho $selectCmd;
		string $resultFormat = (uiRes("m_displayInterObjects.kToggledOff"));
		string $resultMsg = `format -stringArg $toggleCounter $resultFormat`;
		print $resultMsg;
	} else {
		// result reporting and select command to select inter objects
		//
		evalEcho $selectCmd;
		string $resultFormat = (uiRes("m_displayInterObjects.kToggledOn"));
		string $resultMsg = `format -stringArg $toggleCounter $resultFormat`;
		print $resultMsg;
	}
}
