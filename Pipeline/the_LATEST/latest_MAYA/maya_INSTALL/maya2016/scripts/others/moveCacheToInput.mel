// Copyright (C) 1997-2014 Autodesk, Inc., and/or its licensors.
// All rights reserved.
//
// The coded instructions, statements, computer programs, and/or related
// material (collectively the "Data") in these files contain unpublished
// information proprietary to Autodesk, Inc. ("Autodesk") and/or its licensors,
// which is protected by U.S. and Canadian federal copyright law and by
// international treaties.
//
// The Data is provided for use exclusively by You. You have the right to use,
// modify, and incorporate this Data into other products for purposes authorized 
// by the Autodesk software license agreement, without fee.
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND. AUTODESK
// DOES NOT MAKE AND HEREBY DISCLAIMS ANY EXPRESS OR IMPLIED WARRANTIES
// INCLUDING, BUT NOT LIMITED TO, THE WARRANTIES OF NON-INFRINGEMENT,
// MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE, OR ARISING FROM A COURSE 
// OF DEALING, USAGE, OR TRADE PRACTICE. IN NO EVENT WILL AUTODESK AND/OR ITS
// LICENSORS BE LIABLE FOR ANY LOST REVENUES, DATA, OR PROFITS, OR SPECIAL,
// DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES, EVEN IF AUTODESK AND/OR ITS
// LICENSORS HAS BEEN ADVISED OF THE POSSIBILITY OR PROBABILITY OF SUCH DAMAGES.


//<doc>
//<name moveCacheToInput>
//<owner "Autodesk">
//
//<synopsis>
//		moveCacheToInput( int $displayInput )
//
//<returns>
//		None.	
//
//<description>
//	This command moves the cache for the selected nCloth object to a geometry cache on the
//  input mesh of the nCloth. It also enables inputMeshAttract so that the cloth simulation
//  is attracted to its input. One could map or modify the inputMeshAttract to allow for
//  local modifications of the cached simulation. Or the nCloth could be deleted so that one
//  would only have the input mesh with the cached simualtion.
//
//<flags>
//	$displayInput  If true then display the input cloth mesh instead of the output.
//
//<examples>
//  moveCacheToInput false;
//</doc>


global proc moveCacheToInput(int $displayInput)
{
	string $sel[] = `ls -sl`;
	if (size($sel) == 0) {
		error( (uiRes("m_moveCacheToInput.kMustSelectACloth")));
	}
	string $upstreamSel[] = `listHistory`;
	string $nCloths[] = `ls -type nCloth $upstreamSel`;
	if( size( $nCloths ) < 1 ){
		warning( (uiRes("m_moveCacheToInput.kNoClothSelected")));
		return;
	}

	string $noCacheString = (uiRes("m_moveCacheToInput.kNoCache"));
	for( $cloth in $nCloths )
	{
		string $con[] = `listConnections ($cloth + ".playFromCache")`;
		if( size( $con ) < 1 ){
			string $warnMsg = `format -stringArg $cloth $noCacheString`;
			warning $warnMsg;
			continue;
		}
		string $currentCache = $con[0];
		$con = `listConnections -shapes 1 ($cloth + ".inputMesh")`;		
		if( size( $con ) < 1 ){
			string $warnFormat = (uiRes("m_moveCacheToInput.kNoInputMesh"));
			string $warnMsg = `format -stringArg $cloth $warnFormat`;
			warning $warnMsg;
			continue;
		}

		string $inputMesh = $con[0];
		// If the output mesh and the input mesh have a different parent, warn
		// the user.
		//
		string $outConns[] = `listConnections -shapes 1 ($cloth + ".outputMesh")`;
		if( size($outConns) >= 1 ){
			string $outputMesh = $outConns[0];
			string $inputParents[] = `listRelatives -parent $inputMesh`;
			string $outputParents[] = `listRelatives -parent $outputMesh`;
			if( size($inputParents) > 0 ){
				if( size($outputParents) > 0 ){
					if( $inputParents[0] != $outputParents[0] ){
						string $wrnFormat = (uiRes("m_moveCacheToInput.kNotSibling"));
						string $wrnMsg = `format -s $inputMesh -s $outputMesh $wrnFormat`;
						warning $wrnMsg;
					}
				}
			}
		}
		setAttr	($inputMesh + ".visibility") true;
		setAttr	($inputMesh + ".intermediateObject") false;

		string $switch = createHistorySwitch( $inputMesh, false );
		$switch = `rename $switch "cacheSwitch#"`;
	    setAttr ($switch + ".ihi") 0;

		string $outCacheDataPlug[] = `listConnections -p on ($cloth + ".positions")`;
		if( size($outCacheDataPlug) != 1 ) {
			warning `format -stringArg $cloth $noCacheString`;
			continue;
		}

		connectAttr -f $outCacheDataPlug ($switch + ".inPositions[0]");
		connectAttr -f ($currentCache + ".inRange") ($switch + ".playFromCache");

		disconnectAttr $outCacheDataPlug ($cloth + ".positions");
		disconnectAttr ($currentCache + ".inRange") ($cloth + ".playFromCache");

		if( $displayInput ){
			setAttr ($inputMesh + ".overrideEnabled") 1;
			setAttr ($inputMesh + ".overrideShading") 0;
			setAttr ($inputMesh + ".primaryVisibility") 0;
			setAttr ($inputMesh + ".castsShadows") 0;
			setAttr ($inputMesh + ".visibleInReflections") 0;
			setAttr ($inputMesh + ".visibleInRefractions") 0;
		} else {
			setAttr	($inputMesh + ".intermediateObject") true;
		}
		setAttr ($cloth + ".inputMeshAttract") 1.0;
	}//end for nCloth
}
