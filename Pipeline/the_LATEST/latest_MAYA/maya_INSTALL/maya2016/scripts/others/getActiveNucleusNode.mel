// Copyright (C) 1997-2014 Autodesk, Inc., and/or its licensors.
// All rights reserved.
//
// The coded instructions, statements, computer programs, and/or related
// material (collectively the "Data") in these files contain unpublished
// information proprietary to Autodesk, Inc. ("Autodesk") and/or its licensors,
// which is protected by U.S. and Canadian federal copyright law and by
// international treaties.
//
// The Data is provided for use exclusively by You. You have the right to use,
// modify, and incorporate this Data into other products for purposes authorized 
// by the Autodesk software license agreement, without fee.
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND. AUTODESK
// DOES NOT MAKE AND HEREBY DISCLAIMS ANY EXPRESS OR IMPLIED WARRANTIES
// INCLUDING, BUT NOT LIMITED TO, THE WARRANTIES OF NON-INFRINGEMENT,
// MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE, OR ARISING FROM A COURSE 
// OF DEALING, USAGE, OR TRADE PRACTICE. IN NO EVENT WILL AUTODESK AND/OR ITS
// LICENSORS BE LIABLE FOR ANY LOST REVENUES, DATA, OR PROFITS, OR SPECIAL,
// DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES, EVEN IF AUTODESK AND/OR ITS
// LICENSORS HAS BEEN ADVISED OF THE POSSIBILITY OR PROBABILITY OF SUCH DAMAGES.

//
//	getActiveNucleusNode.mel
//
//	Description:
//	    Returns a nucleus node based
//		on current selection, last referenced,
//		last created, or dag order.	
//
//		Arguments:
//			None.
//
//
global string $gActiveNucleusNode = "_not_set";

global proc setActiveNucleusNode( string $node )
{
	global string $gActiveNucleusNode;
	$gActiveNucleusNode = $node;
}

proc string pickBestNucleus( string $nucleusNodes[] )
{
	global string $gActiveNucleusNode;
	if( size( $nucleusNodes ) == 0 ){
		$gActiveNucleusNode = "";
		return( $gActiveNucleusNode );	
	}

	$nucleusNodes = stringArrayRemoveDuplicates( $nucleusNodes );
	if( size( $nucleusNodes ) == 1 ){
		$gActiveNucleusNode = $nucleusNodes[0];
		return( $gActiveNucleusNode );	
	}

	string $nucleus = "";
	string $multipleSelected = (uiRes("m_getActiveNucleusNode.kMultipleNucleusNodes"));
	if( $gActiveNucleusNode != "" ){
		for( $nucleus in $nucleusNodes ){
			if( $nucleus == $gActiveNucleusNode ){
				warning( $multipleSelected+$gActiveNucleusNode );
				return $gActiveNucleusNode;
			}
		} 
	}
	$gActiveNucleusNode = $nucleusNodes[0];
	warning( $multipleSelected +$gActiveNucleusNode );
	return $gActiveNucleusNode;
}

proc string findActiveNucleusNode()
{
	global string $gActiveNucleusNode;

	// We follow this order of checking for an active nucleus node 
	// 1. expicitly selected nucleus
	// 2. expicitly selected nBase
	// 3. expicitly selected input or output mesh 
	// 4. if active nucleus(global variable) use that 
	// 5. use first nucleus in dag 

	// First check to see if there are any nucleus nodes.
	string $allNucleusNodes[] = `ls -type nucleus`;
	if( size( $allNucleusNodes ) == 0 ){
		$gActiveNucleusNode = "";
		return $gActiveNucleusNode;
	}
	if( $gActiveNucleusNode == "_not_set" ){
		// For the above condition to be true one must have 
		// loaded a file containing nucleus nodes, yet not yet
		// created any new ones or opened the createCloth options.
		// We make the first one active.
		$gActiveNucleusNode = $allNucleusNodes[0];
		return $gActiveNucleusNode;
	}


	// Check to see if any nucleus nodes are directly selected
	string $nucleusNodes[] = 	`ls -sl -type nucleus`;
	int $numNucleus = size( $nucleusNodes );
	if( $numNucleus > 0 ){
		return pickBestNucleus( $nucleusNodes );
	}

	// Check selected cloth nodes
	string $nBases[] = `ls -sl -type nBase`;
	int $numNBases = size($nBases);
	if( $numNBases == 0 ){
		// look for cloth nodes indirectly selected through meshes
		string $meshes[] = `ls -sl -dag -type mesh`;
		string $mesh;
		for( $mesh in $meshes ){
			string $nBase = findTypeInHistory( $mesh, "nBase",1,1 );
			if( $nBase != "" ){
				$nBases[$numNBases] = $nBase;
				$numNBases++;
			}
		}
	}
	if( $numNBases > 0 ){
		$nBases = stringArrayRemoveDuplicates( $nBases );
		string $nBase;
		for( $nBase in $nBases ){
			string $startCon[] = `listConnections -type nucleus ($nBase + ".startState")`;
			$nucleusNodes[$numNucleus] = $startCon[0]; 
			$numNucleus++;
		}
		if( $numNucleus > 0 ){
			return pickBestNucleus( $nucleusNodes );
		}
	}

	// Look at nucleus nodes in dag	
	if( $gActiveNucleusNode != "" ){
		// Pick active if it still exists
		//
		if( !objExists( $gActiveNucleusNode )){
			$gActiveNucleusNode = "";
		}
	}
	return $gActiveNucleusNode;
}

global proc string getActiveNucleusNode( int $selectExisting,
										 int $createNew )
//
//	Description:
//		Find the currently active nucleus node. If none is found:
//	(1) If $selectExisting is true, select the first existing one, if any
//	(2) If $createNew is true, force the creation of a new one.
//
{
	global string $gActiveNucleusNode;
	if( findActiveNucleusNode() == "" ){
		if( $selectExisting ){
			// Select an existing nucleus node, if there is one.
			//
			string $nodes[] = `ls -type nucleus`;
			if( size($nodes) > 0 ){
				$gActiveNucleusNode = $nodes[0];
				return $gActiveNucleusNode;
			}
		}
		if( $createNew ){
			// Force the creation of a new node
			//
			$gActiveNucleusNode = `createNSystem`;
		}

	}
	return $gActiveNucleusNode;
}
	

