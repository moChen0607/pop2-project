// Copyright (C) 1997-2014 Autodesk, Inc., and/or its licensors.
// All rights reserved.
//
// The coded instructions, statements, computer programs, and/or related
// material (collectively the "Data") in these files contain unpublished
// information proprietary to Autodesk, Inc. ("Autodesk") and/or its licensors,
// which is protected by U.S. and Canadian federal copyright law and by
// international treaties.
//
// The Data is provided for use exclusively by You. You have the right to use,
// modify, and incorporate this Data into other products for purposes authorized 
// by the Autodesk software license agreement, without fee.
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND. AUTODESK
// DOES NOT MAKE AND HEREBY DISCLAIMS ANY EXPRESS OR IMPLIED WARRANTIES
// INCLUDING, BUT NOT LIMITED TO, THE WARRANTIES OF NON-INFRINGEMENT,
// MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE, OR ARISING FROM A COURSE 
// OF DEALING, USAGE, OR TRADE PRACTICE. IN NO EVENT WILL AUTODESK AND/OR ITS
// LICENSORS BE LIABLE FOR ANY LOST REVENUES, DATA, OR PROFITS, OR SPECIAL,
// DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES, EVEN IF AUTODESK AND/OR ITS
// LICENSORS HAS BEEN ADVISED OF THE POSSIBILITY OR PROBABILITY OF SUCH DAMAGES.

//
//
//  Date:  	March 2004
//
// Description:
//		Procedure to create a fluid from the specified cache
//		file.  The resulting fluid's resolution is determined
//		by the data in the cache file, and its size 
//		by whichever Create 2D/3D Container settings are
//		appropriate for the new fluid's dimensions.
// 	
// 	Steps: 
// 		* Create a temporary 2D (could also be 3D, it
// 		  doesn't matter) container to connect to the cache
//		  so we can read it.	
// 		* Create a diskCache node and hook it up to the fluid.
//		* Now use fluidCacheInfo to obtain information about
//		  the resolution of the fluid that the cache was
//		  originally created for.
//		* Delete the temporary 2D fluid and create a real one
//		  that matches the data in the cache file.
//		  based on incompatibilities with the cachefile.
//
global proc string fluidFromDiskCache( string $cacheFilePath ) {

	// Create the temporary container
	//
	Create2DContainer;
	string $selection[] = `ls -sl -dag -shapes`;
	if( size( $selection ) == 0 ) {
		error((uiRes("m_fluidFromDiskCache.kCouldNotCreateIntermediateShape")));
		return "";
	}

	string $fluid = $selection[0];

	// Create a diskCache node and hook it up to the temp
	// fluid container.
	//
	string $diskCache = createAndAttachFluidDiskCache( $fluid, $cacheFilePath );
	if( size( $diskCache ) == 0 ) {
		string $fmt = (uiRes("m_fluidFromDiskCache.kCouldNotCreateDiskCache"));
		error( `format -s $cacheFilePath $fmt` );
		return "";
	}

	// Query the newly connected temporary cache for the
	// resolution of the data in the physical file.
	//
	string $cmd = "fluidCacheInfo -q -resolution";
	string $type = `getAttr ($diskCache + ".cacheType")`;

	string $whichOne;
	if( $type == "mcfi" ) {
		$whichOne = "-initialConditions";
	} else if ($type == "mcfp" ) {
		$whichOne += "-playback";
	} else {
		error((uiRes("m_fluidFromDiskCache.kUnknownCacheType")));
		return "";
	}
	$cmd += ( " " + $whichOne + " " + $fluid );

	currentTime 1;
	refresh;
	currentTime 2;
	refresh;

	int $res[];
	catch( $res = `eval $cmd` );
	if( size( $res ) != 3 ) {
		error( (uiRes("m_fluidFromDiskCache.kFluidResMissing")) );
		return "" ;
	}
	
	// Delete the temporary fluid (and its hidden temporary
	// cache file!) ...
	//
	sysFile -delete (`diskCache -tmp` + "/" + `getAttr ($diskCache+".hiddenCacheName")`);
	delete $fluid;

	// ... and create the real fluid with of the required
	// dimension and resolution.
	//
	float $dimX, $dimY, $dimZ;
	if( $res[2] == 1 ) {
		// Not calling this before querying the optionVars
		// might result in 0-values getting returned.
		//
		setCreate2DFluidOptionVars false;

		$dimX = `optionVar -query create2DFluidXSize`;
		$dimY = `optionVar -query create2DFluidYSize`;
		$dimZ = `optionVar -query create2DFluidZSize`;

		$fluid = create2DFluid( $res[0], $res[1], $dimX, $dimY, $dimZ );
	} else {
		// Not calling this before querying the optionVars
		// might result in 0-values getting returned.
		//
		setCreate3DFluidOptionVars false;

		$dimX = `optionVar -query create3DFluidXSize`;
		$dimY = `optionVar -query create3DFluidYSize`;
		$dimZ = `optionVar -query create3DFluidZSize`;

		$fluid = create3DFluid( $res[0], $res[1], $res[2], $dimX, $dimY, $dimZ );
	}
	setAttr ($fluid + ".squareVoxels") false;
	createAndAttachFluidDiskCache( $fluid, $cacheFilePath );

	// Especially for initial state caches, the user won't see
	// anything interesting unless we view the start frame.
	//
	float $startFrame = `fluidCacheInfo -query -startFrame $whichOne $fluid`;
	currentTime $startFrame;

	select $fluid;
	return $fluid;
}
