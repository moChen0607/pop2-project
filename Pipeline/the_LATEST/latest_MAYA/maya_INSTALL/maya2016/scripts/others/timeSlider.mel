// Copyright (C) 1997-2014 Autodesk, Inc., and/or its licensors.
// All rights reserved.
//
// The coded instructions, statements, computer programs, and/or related
// material (collectively the "Data") in these files contain unpublished
// information proprietary to Autodesk, Inc. ("Autodesk") and/or its licensors,
// which is protected by U.S. and Canadian federal copyright law and by
// international treaties.
//
// The Data is provided for use exclusively by You. You have the right to use,
// modify, and incorporate this Data into other products for purposes authorized 
// by the Autodesk software license agreement, without fee.
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND. AUTODESK
// DOES NOT MAKE AND HEREBY DISCLAIMS ANY EXPRESS OR IMPLIED WARRANTIES
// INCLUDING, BUT NOT LIMITED TO, THE WARRANTIES OF NON-INFRINGEMENT,
// MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE, OR ARISING FROM A COURSE 
// OF DEALING, USAGE, OR TRADE PRACTICE. IN NO EVENT WILL AUTODESK AND/OR ITS
// LICENSORS BE LIABLE FOR ANY LOST REVENUES, DATA, OR PROFITS, OR SPECIAL,
// DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES, EVEN IF AUTODESK AND/OR ITS
// LICENSORS HAS BEEN ADVISED OF THE POSSIBILITY OR PROBABILITY OF SUCH DAMAGES.

//
//
// Creation Date:  20 Februrary 1996
//
    
//
//  Procedure Name:
//		playButtonStart, playButtonStepBackward, playButtonBackward
//		playButtonStop, playButtonRecord, playButtonForward
//		playButtonStepForward, playButtonEnd
//
//  Description:
//      Procs that update the current time according to which
//		playback control is pressed.
//
//  Input Arguments:
//      None.
//
//  Return Value:
//      None.
//
global proc playButtonStart() {
	currentTime -edit `playbackOptions -query -min`;
}

global proc playButtonStepBackward() {
	float $by = `playbackOptions -query -by`;
	float $curr = `currentTime -query`;
	float $min = `playbackOptions -query -min`;
	float $max = `playbackOptions -query -max`;

	if(( $curr != $min )
	&&(( $curr - $by ) >= $min )
	&&(( $curr - $by ) < $max ))
	{
		currentTime -edit ( $curr - $by );
	}
	else {
		currentTime -edit $max;
	}
}

global proc playButtonBackward() {
	int $isOscillate = (`playbackOptions -q -loop` == "oscillate");

	if(( `play -query -state` == 1 ) 
	&&(( `play -query -forward` == 0 ) || $isOscillate ))
	{
		play -state off;
	}
	else {
		float $by = `playbackOptions -query -by`;	
		if( `currentTime -q` - $by < `playbackOptions -q -min` ) {
			currentTime -e `playbackOptions -q -max`;
		}

		global string $gTimeSliderTimeField;
		global string $gPlayBackForwardButton;
		global string $gPlayBackReverseButton;

		// We do this here since the callback that sets up the 
		// images on the buttons won't get called if we're already
		// playing back (forward) and hit the "backward" button;
		// The "playingBack" condition will not have been changed!
		// 
		symbolButton -edit 
			-image "timeplay.png" 
			-annotation (uiRes("m_timeSlider.kPlayForwardsAnnot"))  $gPlayBackForwardButton; 
		symbolButton -edit 
			-image "timestop.png" 
			-annotation (uiRes("m_timeSlider.kStopPlaybackAnnot"))  $gPlayBackReverseButton; 
		floatField -e -enable false $gTimeSliderTimeField;
		
		play -forward off;
	}
}
global proc playButtonForward() {
	global string $gTimeSliderTimeField;

	int $isOscillate = (`playbackOptions -q -loop` == "oscillate");

	if(( `play -query -state` == 1 ) 
	&&(( `play -query -forward` == 1 ) || $isOscillate ))
	{
		play -state off;
	}
	else {
		float $by = `playbackOptions -query -by`;	
		if( `currentTime -q` + $by > `playbackOptions -q -max` ) {
			currentTime -e `playbackOptions -q -min`;
		}

		global string $gPlayBackForwardButton;
		global string $gPlayBackReverseButton;
		global string $gPlayBackSlider;

		// We do this here since the callback that sets up the 
		// images on the buttons won't get called if we're already
		// playing back (forward) and hit the "backward" button;
		// The "playingBack" condition will not have been changed!
		// 
		symbolButton -edit 
			-image "timestop.png" 
			-annotation (uiRes("m_timeSlider.kStopPlaybackAnnot"))  $gPlayBackForwardButton; 
		symbolButton -edit 
			-image "timerev.png" 
			-annotation (uiRes("m_timeSlider.kPlayBackwardsAnnot"))  $gPlayBackReverseButton; 
		floatField -e -enable false $gTimeSliderTimeField;
		
		play -forward on -sound `timeControl -q -s $gPlayBackSlider` -playSound `timeControl -query -displaySound $gPlayBackSlider`;
	}
}

global proc playButtonStepForward() {
	float $by = `playbackOptions -query -by`;
	float $curr = `currentTime -query`;
	float $min = `playbackOptions -query -min`;
	float $max = `playbackOptions -query -max`;

	if(( $curr != $max ) 
	&&(( $curr + $by ) <= $max )
	&&(( $curr + $by ) > $min ))
	{
		currentTime -edit ( $curr + $by );
	}
	else {
		currentTime -edit $min;
	}
}

global proc playButtonEnd() {
	currentTime -edit `playbackOptions -query -max`;
}

global proc int playbackStateChanged() {
	global string $gPlayBackForwardButton;
	global string $gPlayBackReverseButton;
	global string $gTimeSliderTimeField;

	if( `isTrue playingBack` ) {
		if(( `play -query -st` == 0) || `play -query -forward` == 1 ) {

			if( `symbolButton -exists $gPlayBackForwardButton` ) {
				symbolButton -edit 
					-image "timestop.png" 
					-annotation (uiRes("m_timeSlider.kStopPlaybackAnnot"))  $gPlayBackForwardButton; 
			}

			if( `symbolButton -exists $gPlayBackReverseButton` ) {
				symbolButton -edit 
					-image "timerev.png" 
					-annotation (uiRes("m_timeSlider.kPlayBackwardsAnnot"))  $gPlayBackReverseButton; 
			}
		}
		else {
			if( `symbolButton -exists $gPlayBackForwardButton` ) {
				symbolButton -edit 
					-image "timeplay.png" 
					-annotation (uiRes("m_timeSlider.kPlayForwardsAnnot"))  $gPlayBackForwardButton; 
			}

			if( `symbolButton -exists $gPlayBackReverseButton` ) {
				symbolButton -edit 
					-image "timestop.png" 
					-annotation (uiRes("m_timeSlider.kStopPlaybackAnnot"))  $gPlayBackReverseButton; 
			}
		}

		if( `floatField -exists $gTimeSliderTimeField` ) {
			floatField -e -enable false $gTimeSliderTimeField;
		}
	}
	else {
		if( `symbolButton -exists $gPlayBackForwardButton` ) {
			symbolButton -edit 
				-image "timeplay.png" 
				-annotation (uiRes("m_timeSlider.kPlayForwardsAnnot"))  $gPlayBackForwardButton; 
		}

		if( `symbolButton -exists $gPlayBackReverseButton` ) {
			symbolButton -edit 
				-image "timerev.png" 
				-annotation (uiRes("m_timeSlider.kPlayBackwardsAnnot"))  $gPlayBackReverseButton; 
		}

		if( `floatField -exists $gTimeSliderTimeField` ) {
			floatField -e -enable true $gTimeSliderTimeField;
		}
	}

	// Scripts attached to the "condition" command
	// must return an int.
	//
	return 1;
}

// Procedure Name: 
//		timeSlider
//	
// Description:
//		This implements the group of controls that represents the
//		timeSlider.  The timeSlider can either be part of a window
//		or in a window of its own.
//
// Input Arguments:
//		The name of the layout that the timeSlider should add itself
//		to.  If empty, then this script will create a window.
//
// Return Value:
//		The name of the top level layout control.
//			(Used for embedding within another window)
//
//global proc string timeSlider(string $parentName)
{
	global string $gTimeSliderForm;
	global string $gPlayBackForwardButton;
	global string $gPlayBackReverseButton;
	global string $gPlayBackSlider;
	global string $gTimeSliderTimeField;
	
	//	Create a layout appropriate for the Time slider.
	//
	string $timeSlider = `formLayout -parent $gTimeSliderForm`;

	//	Create a frame layout for the Time slider control.
	//
	string $timeFrame = `frameLayout
		-parent         $timeSlider
		-borderVisible  false
		-labelVisible   false
		-collapse       false
		-collapsable    false`;

	//	Create the Time slider control.
	//	
	$gPlayBackSlider = `timeControl -parent $timeFrame -height 26`;
	
	setParent $timeSlider;

	//	Create the Time field.
	//
	$gTimeSliderTimeField = `floatField
		-annotation (uiRes("m_timeSlider.kCurrentTimeSetAnnot")) 
		-width      70
		-precision  2
		-showTrailingZeros false`;
	floatField -edit
		$gTimeSliderTimeField; 

	//	Create a grid layout for the play back buttons.
	//
	int $nbCols = 8;
	int $iconSize = 22;	// Real size = 20x20, but with padding for down/hover = 22x22
	int $cellWidth = $iconSize + 1;
	int $gridWidth = $nbCols * $cellWidth;

	string $grid = `gridLayout 
		-width               $gridWidth 
		-numberOfRowsColumns 1 $nbCols 
		-cellWidthHeight     $cellWidth $iconSize`;

	//	Create the play back buttons...
	//
	string $startButton = `symbolButton
		-image       "timerew.png"
		-annotation (uiRes("m_timeSlider.kStartPlaybackRangeAnnot")) 
		-command     "playButtonStart"`;

	string $stepBackButton = `symbolButton
		-image       "timeend.png"
		-annotation (uiRes("m_timeSlider.kStepBackFrameAnnot")) 
		-command     "playButtonStepBackward"`;

	string $prevCmd = "currentTime -edit `findKeyframe -timeSlider -which previous`";
	string $prevButton = `symbolButton
		-image       "timeprev.png"
		-annotation (uiRes("m_timeSlider.kStepBackOneKeyAnnot")) 
		-command     $prevCmd`;

	$gPlayBackReverseButton = `symbolButton
		-image       "timerev.png" 
		-annotation  (uiRes("m_timeSlider.kPlayBackwardsAnnot")) 
		-command     "playButtonBackward"`;

	$gPlayBackForwardButton = `symbolButton
		-image       "timeplay.png" 
		-annotation  (uiRes("m_timeSlider.kPlayForwardsAnnot")) 
		-command     "playButtonForward"`;

	string $nextCmd = "currentTime -edit `findKeyframe -timeSlider -which next`";
	string $nextButton = `symbolButton
		-image       "timenext.png" 
		-annotation (uiRes("m_timeSlider.kStepForwardOneKeyAnnot")) 
		-command     $nextCmd`;

	string $stepFwdButton = `symbolButton
		-image       "timestart.png"
		-annotation (uiRes("m_timeSlider.kStepForwardFrameAnnot")) 
		-command     "playButtonStepForward"`;

	string $endButton = `symbolButton
		-image       "timefwd.png" 
		-annotation (uiRes("m_timeSlider.kEndPlaybackRangeAnnot")) 
		-command     "playButtonEnd"`;

	//	Make attachments for contents of Time slider.
	//
	formLayout -edit
		-attachForm    $timeFrame  "top"    0
		-attachForm    $timeFrame  "left"   1
		-attachNone    $timeFrame  "bottom"
		-attachControl $timeFrame  "right"  6 $gTimeSliderTimeField

		-attachForm    $gTimeSliderTimeField  "top"    5
		-attachNone    $gTimeSliderTimeField  "left"
		-attachNone    $gTimeSliderTimeField  "bottom"
		-attachControl $gTimeSliderTimeField  "right"  6 $grid

		-attachForm    $grid       "top"    3
		-attachNone    $grid       "left"
		-attachNone    $grid       "bottom"
		-attachForm    $grid       "right"  0
		$timeSlider;

	//	Attach Time slider to parent.
	//
	formLayout -edit
		-attachForm    $timeSlider "top"    2
		-attachForm    $timeSlider "bottom" 2
		-attachForm    $timeSlider "right"  7
		-attachForm    $timeSlider "left"   0		
		$gTimeSliderForm;

	//	Add call back to current time changes...
	//
	scriptJob -permanent -parent $timeSlider -event "timeChanged" 
		( "floatField -edit -value `currentTime -query` " 
			+ $gTimeSliderTimeField );
	
	//	Add callbacks playback controls...
	floatField -edit -value `currentTime -query` 
		-changeCommand ("currentTime " + 
						"`floatField -query -value " 
						+ $gTimeSliderTimeField + "`; " 
						)
		$gTimeSliderTimeField;

	//  Register sound scrub callbacks on the timeControl widget.
	//
	timeControl -e -pc "timeControl -e -beginScrub $gPlayBackSlider" 
		-rc "timeControl -e -endScrub $gPlayBackSlider" $gPlayBackSlider;

	// Make sure the play controls are in synch with playback
	//
	condition -dependency playingBack 
		      -script playbackStateChanged playbackIconsCondition;

	// Attach a popup menu to the timeslider area
	//
	TimeSliderMenu($timeSlider);

	setUIComponentStateCallback(
		"Time Slider", "timeSliderVisibilityStateChange");
}

global proc int timeSliderVisibilityStateChange(
	int    $newState,
	string $layout)
//
//	Description:
//		This procedure is called whenever the visibility state of the 
//		Time Slider is changed.
//
//	Arguments:
//		newState - The new visibile state of the Time Slider.
//
//		layout - The parent layout for the Time Slider.
//
//	Returns:
//		true - If the change of state is to be allowed.
//
//		false - If the state change is rejected.
//
{
	int $result = true;

	//	Defer these commands because this proc is called when the visibility
	//	state is about to change. This proc must return true to accept 
	//	the state change. After this proc returns then restore the
	//	panel focus and update the pref menu.
	//
	evalDeferred("restoreLastPanelWithFocus(); updatePrefsMenu();");

	return $result;
}

// Utility method for returning the frame times of a sequence
//
proc float[] getGreasePencilFrameTimeArray( string $sequenceNodeName  )
{
	float $result[];
	clear($result);

	if ( size($sequenceNodeName) < 1 )
			return $result;

	string $keyPlug = ( $sequenceNodeName + ".frame" );
	int $indexArray[] = `getAttr -multiIndices $keyPlug`;
	if ( size($indexArray) < 0 )
			return $result;

	int $i;
	for ( $i in $indexArray )
	{
		string $timePlug = ( $sequenceNodeName + ".frame[" + string($i) + "]" + ".frameTime" );
		$result[size($result)] = `getAttr $timePlug`;
	}
	return sort($result);
}

// Utility method to figure out which is the next or previous grease pencil
// frame.  We may need to convert this method to c++ if we find it is too slow.
//
proc float goto_greasePencilFrame( int $prev )
{
	global string $gPlayBackSlider;

	float $currTime = `currentTime -query`;
	float $newTime = $currTime;
	string $newSequence;

	float $minDiff = maxfloat();
	string $sequences[] = `timeControl -q -greasePencilSequenceNames $gPlayBackSlider`;
	for ( $seq in $sequences )
	{
		float $farray[] = getGreasePencilFrameTimeArray( $seq );
		for ( $f in $farray )
		{
			if ( $prev )
			{
				if ( $f < $currTime )
				{
					float $m = abs( $currTime - $f );
					if (  $m < $minDiff )
					{
						$newTime = $f;
						$newSequence = $seq;
						$minDiff = $m;
					}
				}
				else
				{
					break;
				}
			}
			else if ( !$prev )
			{
				if ( $f > $currTime )
				{
					float $m = abs( $currTime - $f );
					if ( $m < $minDiff )
					{
						$newTime = $f;
						$newSequence = $seq;
						$minDiff = $m;
					}
					break;
				}
			}
		}
	}
	return $newTime;
}

// Hotkey call for previous grease frame
global proc TimeSliderPrevGreaseFrame()
{
	float $newTime = goto_greasePencilFrame( true );
	currentTime -edit $newTime;
}

// Hotkey call for next grease frame
global proc TimeSliderNextGreaseFrame()
{
	float $newTime = goto_greasePencilFrame( false );
	currentTime -edit $newTime;
}
