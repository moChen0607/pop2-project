// Copyright (C) 1997-2014 Autodesk, Inc., and/or its licensors.
// All rights reserved.
//
// The coded instructions, statements, computer programs, and/or related
// material (collectively the "Data") in these files contain unpublished
// information proprietary to Autodesk, Inc. ("Autodesk") and/or its licensors,
// which is protected by U.S. and Canadian federal copyright law and by
// international treaties.
//
// The Data is provided for use exclusively by You. You have the right to use,
// modify, and incorporate this Data into other products for purposes authorized 
// by the Autodesk software license agreement, without fee.
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND. AUTODESK
// DOES NOT MAKE AND HEREBY DISCLAIMS ANY EXPRESS OR IMPLIED WARRANTIES
// INCLUDING, BUT NOT LIMITED TO, THE WARRANTIES OF NON-INFRINGEMENT,
// MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE, OR ARISING FROM A COURSE 
// OF DEALING, USAGE, OR TRADE PRACTICE. IN NO EVENT WILL AUTODESK AND/OR ITS
// LICENSORS BE LIABLE FOR ANY LOST REVENUES, DATA, OR PROFITS, OR SPECIAL,
// DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES, EVEN IF AUTODESK AND/OR ITS
// LICENSORS HAS BEEN ADVISED OF THE POSSIBILITY OR PROBABILITY OF SUCH DAMAGES.

//
// hikControlRigUI.mel
//
// Description:
//		Methods for creating and updating the control rig UI
//


///////////////////////////////////////////////////////////////////////
// Local methodes...
///////////////////////////////////////////////////////////////////////


proc string getDrivingPlug( string $property )
{
	if( size( $property ) == 0 )
		return "";

	string $prop2StateNode = hikGetProperty2StateFromCharacter( hikGetCurrentCharacter() );

	string $connections[] = `listConnections -p true -d false -t "hikIKEffector" ( $prop2StateNode + "." + $property )`;
	if( size( $connections ) )
		return $connections[0];
	else
		return ( $prop2StateNode + "." + $property );
}

proc buildControlRigSchematicWidget( )
{
	global int $gHIKSchematicWidgetMinWidth;

	string $defConfigFilename = hikGetDefaultResourcesDir();
	$defConfigFilename        = $defConfigFilename + "CharacterControlsConfig.xml";
	string $configFilename    = $defConfigFilename;

	if( `optionVar -exists hikControlRigUIPath` == false )
		optionVar -stringValue hikControlRigUIPath $defConfigFilename;

	$configFilename = `optionVar -q hikControlRigUIPath`;

	string $parent = `columnLayout -adjustableColumn true hikControlRigResizableLayout`;

	if( catch( `hikCharacterToolWidget
				-configFilename $configFilename
				-layoutParentName $parent
				-minimumSize $gHIKSchematicWidgetMinWidth 0
				-navigationPostCallback "hikSchematicWidgetNavigationPost"
				-refreshCallback "hikUpdateControlRigSliders(); hikUpdateControlRigButtonState();"
	` ) )
	{
		if( $configFilename != $defConfigFilename )
			hikControlRigSetDefaultUIConfig( );
		else
			hikControlRigWidgetFatalError( $defConfigFilename );
	}

	setParent ..;
}

proc buildControlRigSliders( )
{
	string $commonCmd =
		"{ global int $gHIKControlRigAuxHeight; " +
		"global int $gHIKControlRigCollapseExpandHeightDiff; " +
		"$gHIKControlRigAuxHeight = $gHIKControlRigAuxHeight + ";
	string $collapseCmd =
		$commonCmd +
		"(-1*$gHIKControlRigCollapseExpandHeightDiff); " +
		"hikResizeContextualTabRelative (-1*$gHIKControlRigCollapseExpandHeightDiff); }";
	string $expandCmd =
		$commonCmd +
		"$gHIKControlRigCollapseExpandHeightDiff; " +
		"hikResizeContextualTabRelative $gHIKControlRigCollapseExpandHeightDiff; }";
	frameLayout
		-label (uiRes("m_hikControlRigUI.kHIKCharacterToolEAHIKControls"))
		-collapsable true
		-collapseCommand $collapseCmd
		-expandCommand $expandCmd;

		columnLayout -adjustableColumn true;

			attrFieldSliderGrp
				-label         (uiRes("m_hikControlRigUI.kHIKCharacterToolEAReachT"))
				-annotation    (uiRes("m_hikControlRigUI.kReachT"))
				-minValue      0.0
				-maxValue      1.0
				-step          0.01
				-precision     2
				-columnWidth   2 30
				-columnWidth   3 70
				hikControlRigSliderReachT;

			attrFieldSliderGrp
				-label         (uiRes("m_hikControlRigUI.kHIKCharacterToolEAReachR"))
				-annotation    (uiRes("m_hikControlRigUI.kReachR"))
				-minValue      0.0
				-maxValue      1.0
				-step          0.01
				-precision     2
				-columnWidth   2 30
				-columnWidth   3 70
				hikControlRigSliderReachR;

			attrFieldSliderGrp
				-label         (uiRes("m_hikControlRigUI.kHIKCharacterToolEAPull"))
				-annotation    (uiRes("m_hikControlRigUI.kPull"))
				-minValue      0.0
				-maxValue      1.0
				-precision     2
				-columnWidth   2 30
				-columnWidth   3 70
				hikControlRigSliderPull;

		setParent ..;
	setParent ..;

	scriptJob -event "SelectionChanged" "hikControlRigSelectionChangedCallback";
}



///////////////////////////////////////////////////////////////////////
// Global methodes...
///////////////////////////////////////////////////////////////////////


global proc hikBuildControlRigUI()
{
	global int $gHIKControlRigAuxHeight;
	global int $gHIKControlRigFrameLayoutHeight;
	$gHIKControlRigAuxHeight = $gHIKControlRigFrameLayoutHeight;

	columnLayout -adjustableColumn true;
		buildControlRigSchematicWidget();
		buildControlRigSliders();
	setParent ..;
}

global proc hikBuildControlRigButtons()
{
	rowLayout -numberOfColumns 13 hikControlRigButtons;
		
		iconTextCheckBox
			-image "HIKCharacterToolIK.png"
			-style "iconOnly"
			-value false
			-changeCommand "hikShowHide(\"IK\");"
			-annotation (uiRes("m_hikControlRigUI.kHIKCharacterControlOptIK"))
			hikControlRigIKToggle;
		
		iconTextCheckBox
			-image "HIKCharacterToolFK.png"
			-style "iconOnly"
			-value false
			-changeCommand "hikShowHideRigFkNodes( hikGetCurrentCharacter(), hikIsRigFKVisible( hikGetCurrentCharacter( ) ) ? 0 : 1 )"
			-annotation (uiRes("m_hikControlRigUI.kHIKCharacterControlOptFK"))
			hikControlRigFKToggle;
		
		iconTextCheckBox
			-image "HIKCharacterToolSkeleton.png"
			-style "iconOnly"
			-changeCommand "hikShowHideSkeletonNodes( hikGetCurrentCharacter(), hikIsCharacterSkeletonVisible( hikGetCurrentCharacter( ) ) ? 0 : 1 )"
			-annotation (uiRes("m_hikControlRigUI.kHIKCharacterControlOptSk"))
			hikControlRigSkToggle;
		
		separator -height 12 -horizontal false;
		
		iconTextCheckBox
			-image "HIKCharacterToolFullBody.png"
			-value false
			-style "iconOnly"
			-changeCommand "optionVar -intValue keyFullBody 1; hikSetKeyingMode( ); hikUpdateControlRigButtonState;"
			-annotation (uiRes("m_hikControlRigUI.kHIKCharacterControlOptFullBody"))
			hikControlRigFBToggle;
		
		iconTextCheckBox
			-image "HIKCharacterToolBodyPart.png"
			-value false
			-style "iconOnly"
			-changeCommand "optionVar -intValue keyFullBody 2; hikSetKeyingMode( ); hikUpdateControlRigButtonState;"
			-annotation (uiRes("m_hikControlRigUI.kHIKCharacterControlOptBodyPart"))
			hikControlRigBPToggle;
		
		iconTextCheckBox
			-image "HIKCharacterToolSelection.png"
			-value false
			-style "iconOnly"
			-changeCommand "optionVar -intValue keyFullBody 3; hikSetKeyingMode( ); hikUpdateControlRigButtonState;"
			-annotation (uiRes("m_hikControlRigUI.kHIKCharacterControlOptSelected"))
			hikControlRigSelToggle;
		
		separator -height 12 -horizontal false;
		
		iconTextCheckBox
			-image "HIKCharacterToolPinT.png"
			-value false
			-style "iconOnly"
			-changeCommand "hikDoHIKCharacterToolEffectorPinTState( hikGetCurrentCharacter( ), `iconTextCheckBox -query -value hikControlRigTPinToggle` )"
			-annotation (uiRes("m_hikControlRigUI.kHIKCharacterControlOptPinT"))
			hikControlRigTPinToggle;
		
		iconTextCheckBox
			-image "HIKCharacterToolPinR.png"
			-value false
			-style "iconOnly"
			-changeCommand "hikDoHIKCharacterToolEffectorPinRState( hikGetCurrentCharacter( ), `iconTextCheckBox -query -value hikControlRigRPinToggle` )"
			-annotation (uiRes("m_hikControlRigUI.kHIKCharacterControlOptPinR"))
			hikControlRigRPinToggle;
			
		iconTextCheckBox
			-image          "HIKCharacterToolReleaseAll.png"
			-selectionImage "HIKCharacterToolReleaseAllPressed.png"
			-value          false
			-style          "iconOnly"
			-changeCommand  "HIKToggleReleasePinning"
			-annotation     (uiRes("m_hikControlRigUI.kHIKCharacterControlOptReleaseAll"))
			hikControlRigReleaseAllToggle;

		separator -height 12 -horizontal false;

		iconTextButton
			-image          "HIKCharacterToolStancePose.png"
			-style          "iconOnly"
			-command  "hikStancePose"
			-annotation     (uiRes("m_hikControlRigUI.kHIKStancePose"))
			hikControlRigStancePose;

		setParent ..;

	rowLayout -e -manage false hikControlRigButtons;
}

global proc hikUpdateControlRigUI()
{
	if( !hikIsControlRigTabSelected() )
		return;

//	print _NOL10N("---> hikUpdateControlRigUI\n");

	// Setup and update the character to the current selection
	//
	string $currCharacter = hikGetCurrentCharacter( );
	hikCharacterToolWidget -edit -setupCharacter $currCharacter;

	// MAYA-11906
	// Disabling calls to hikSetKeyingMode as this is causing a jarring
	// flash in the viewport. This "flash" arises from a call to
	// fbikDoSelectionChanged that first deselect then re-selects all
	// items in the selection list.
	/*
		hikSetKeyingMode;
	*/

	hikUpdateControlRigSliders();
	hikUpdateControlRigButtonState();
}

global proc hikOnSwitchControlRig()
{
	global int $gHIKRigTabsAuxWidth;
	global int $gHIKDockMinWidth;
	global int $gHIKSchematicWidgetMinWidth;

	int $maxDockSize[] = `hikCharacterToolWidget -q -backgroundSize`;
	int $maxDockWidth;

	// If the background width is equal to our minimum width (250) we want to disable resizing
	//
	if( $maxDockSize[0] == $gHIKSchematicWidgetMinWidth )
		$maxDockWidth = $gHIKDockMinWidth+1;
	else
		$maxDockWidth = $maxDockSize[0] + $gHIKRigTabsAuxWidth;
	
	
	if( !`optionVar -exists hikControlsTabWidth` )
		optionVar -iv hikControlsTabWidth $maxDockWidth;

	// clamp the controls tab width between min and max value
	// 
	$dockWidth = `optionVar -q hikControlsTabWidth`;
	if ( $dockWidth > $maxDockWidth )
	{
		$dockWidth = $maxDockWidth;
		optionVar -iv hikControlsTabWidth $dockWidth;
	}
	else if ( $dockWidth < $gHIKDockMinWidth )
	{
		$dockWidth = $gHIKDockMinWidth;
		optionVar -iv hikControlsTabWidth $dockWidth;
	}

	dockControl -e -width $dockWidth hikCharacterControlsDock;
	HIKUiControl -edit -maxWidth $maxDockWidth -minWidth $gHIKDockMinWidth -ctrlName "hikCharacterControlsDock";
}

global proc hikUpdateControlRigButtonState()
{
	iconTextCheckBox -edit -enable 0 hikControlRigIKToggle;
	iconTextCheckBox -edit -enable 0 hikControlRigFKToggle;
	iconTextCheckBox -edit -enable 0 hikControlRigSkToggle;
	iconTextCheckBox -edit -enable 0 hikControlRigRPinToggle;
	iconTextCheckBox -edit -enable 0 hikControlRigTPinToggle;

	// Verify if we can use the stance pose button
	string $currCharacter  = hikGetCurrentCharacter();
	string $currentRig     = hikGetControlRig( $currCharacter );
	int    $hasControlRig  = (size( $currentRig ) > 0);
	int    $enableStance   = ($hasControlRig && `optionVar -q keyFullBody` != 3 /* != selection */);

	iconTextButton -edit -enable $enableStance hikControlRigStancePose;
	iconTextCheckBox -edit -enable $hasControlRig hikControlRigSelToggle;
	iconTextCheckBox -edit -enable $hasControlRig hikControlRigBPToggle;
	iconTextCheckBox -edit -enable $hasControlRig hikControlRigFBToggle;

	if( $currCharacter == "" )
		return;

	string $label;
	int $checked;
	int $isWidgetIKVisible = false;
	int $isWidgetFKVisible = false;

	int $hasRig = hikHasControlRig($currCharacter);
	iconTextCheckBox -edit -enable $hasRig hikControlRigIKToggle;
	iconTextCheckBox -edit -enable $hasRig hikControlRigFKToggle;
	iconTextCheckBox -edit -enable 1       hikControlRigSkToggle;

	if( !hikIsDefinitionLocked( $currCharacter ) )
	{
		$label = (uiRes("m_hikControlRigUI.kHIKCharacterToolSourceLock"));
		$checked = false;
	}
	else
	{
		$checked = hikIsCharacterEnabled( $currCharacter );
		int $inputType = hikGetInputType( $currCharacter );

		switch( $inputType )
		{
			case 1: // Control Rig Input
				$label = (uiRes("m_hikControlRigUI.kHIKCharacterToolSourceRig"));
				$isWidgetIKVisible = $checked;
				$isWidgetFKVisible = $checked;
					
				iconTextCheckBox -edit -enable $checked hikControlRigRPinToggle;
				iconTextCheckBox -edit -enable $checked hikControlRigTPinToggle;
				break;

			case 2: // Character Input on Hidden Rig (Legacy mode)
				$label = (uiRes("m_hikControlRigUI.kHIKCharacterToolSourceCharacter"));
				$isWidgetIKVisible = $checked;
					
				iconTextCheckBox -edit -enable $checked hikControlRigRPinToggle;
				iconTextCheckBox -edit -enable $checked hikControlRigTPinToggle;
				break;

			case 3: // Character Input Direct from Retargeter to Skeleton or CustomRig
				$label = (uiRes("m_hikControlRigUI.kHIKCharacterToolSourceCharacterDirect"));
				$isWidgetIKVisible = $checked;
				break;

			case 4: // Live Character Input
				$label = (uiRes("m_hikControlRigUI.kHIKCharacterToolSourceLive"));
				break;

			default: // Stance
				$label = (uiRes("m_hikControlRigUI.kHIKCharacterToolSourceStance"));
		}
	}

	// Update visibility buttons
	//
	iconTextCheckBox -edit -value ( hikIsRigIKVisible( $currCharacter ) ) hikControlRigIKToggle;
	iconTextCheckBox -edit -value ( hikIsRigFKVisible( $currCharacter ) ) hikControlRigFKToggle;
	iconTextCheckBox -edit -value ( hikIsCharacterSkeletonVisible( $currCharacter ) ) hikControlRigSkToggle;

	hikCharacterToolWidget -edit -ikVisible $isWidgetIKVisible -fkVisible $isWidgetFKVisible -updateCharacter;

	
	// Update keying mode buttons
	//

	// If the hik keying mode has not been initialized, set it to "BodyPart" mode
	// TODO: rename the optionVar to hikKeyFullBody
	if( !`optionVar -exists keyFullBody` )
		optionVar -intValue keyFullBody 2;

	int $mode = `optionVar -query keyFullBody`;
	iconTextCheckBox -edit -value ($mode == 1) hikControlRigFBToggle;
	iconTextCheckBox -edit -value ($mode == 2) hikControlRigBPToggle;
	iconTextCheckBox -edit -value ($mode == 3) hikControlRigSelToggle;

	hikCharacterToolWidget -edit -keyingMode ($mode - 1);

	// Update the pinning buttons
	//
	hikUpdateControlRigPinningButtons();
}

global proc hikUpdateRigLookMenu()
{
	int $lastRigStyle = hikGetLastSelectedRigStyle();
	menuItem -e -checkBox ($lastRigStyle == 0) hikWireMenuItem;
	menuItem -e -checkBox ($lastRigStyle == 1) hikStickMenuItem;
	menuItem -e -checkBox ($lastRigStyle == 2) hikBoxMenuItem;
}

global proc hikUpdateEditControlRigMenu()
// Description:
//		Update the character button's Edit > Control Rig sub-menu
{
	string $currentCharacter    = hikGetCurrentCharacter();
	string $currentRig          = hikGetControlRig( $currentCharacter );
	int    $hasControlRig       = (size( $currentRig ) > 0);
	int    $enableStance        = ($hasControlRig && `optionVar -q keyFullBody` != 3 /* != selection */); 
	int    $isRigAlignEnable    = $hasControlRig?`hikRigAlign -q -enable $currentRig`:0;   

	menuItem -e -enable $hasControlRig hikDeleteControlRigMenuItem;
	menuItem -e -enable $enableStance hikStancePoseMenuItem;
	menuItem -e	-enable   $hasControlRig
				-checkBox $isRigAlignEnable 
				-command  ("hikRigAlign -enable "+!$isRigAlignEnable+" "+$currentRig)
				hikRigAlignMenuItem;

}



global proc hikUpdateControlRigSliders()
{
	// Disable all sliders
	//
	attrFieldSliderGrp -edit -enable false hikControlRigSliderReachT;
	attrFieldSliderGrp -edit -enable false hikControlRigSliderReachR;
	attrFieldSliderGrp -edit -enable false hikControlRigSliderPull;

	string $currCharacter =  hikGetCurrentCharacter( );
	if( hikIsDefinitionLocked( $currCharacter ) )
	{
		int $inputType = hikGetInputType( $currCharacter );

		string $reachTAttrs;
		string $reachRAttrs;
		string $pullAttrs;

		// If in rig source input
		//
		if( $inputType == 1 )
		{
			string $effectors[ ] = hikGetSelectedEffectorsFromCharacter( $currCharacter, 0 );
			if( size( $effectors ) )
			{
				for( $effector in $effectors )
				{
					$reachTAttrs += ( $effector + ".reachTranslation " );
					$reachRAttrs += ( $effector + ".reachRotation "    );

					// Append the effector if it is not the ChestOriginEffector
					//
					if( hikGetEffectorID( $effector ) != 9 )
						$pullAttrs += ( hikGetBaseEffector( $effector ) + ".pull " );
				}
			}
		}
		// If in character source input
		//
		else if( $inputType == 2 || $inputType == 3 )
		{
			int $ids[] = `hikCharacterToolWidget -q -selectedIDs`;

			for( $id in $ids )
			{
				string $drivingReachT = getDrivingPlug( `GetProperty2StateAttrNameFromHIKEffectorId -reachT $id` );
				string $drivingReachR = getDrivingPlug( `GetProperty2StateAttrNameFromHIKEffectorId -reachR $id` );
				string $drivingPull   = getDrivingPlug( `GetProperty2StateAttrNameFromHIKEffectorId -pull   $id` );
				if( $drivingReachT != "" )
					$reachTAttrs += $drivingReachT + " ";
				if( $drivingReachR != "" )
					$reachRAttrs += $drivingReachR + " ";
				if( $drivingPull != "" )
					$pullAttrs   += $drivingPull   + " ";
			}
		}

		// Activate and connect sliders if they have any attributes
		//
		if( size( $reachTAttrs ) )
		{
			attrFieldSliderGrp -edit -enable true hikControlRigSliderReachT;
			eval connectControl hikControlRigSliderReachT $reachTAttrs;
		}

		if( size( $reachRAttrs ) )
		{
			attrFieldSliderGrp -edit -enable true hikControlRigSliderReachR;
			eval connectControl hikControlRigSliderReachR $reachRAttrs;
		}

		if( size( $pullAttrs ) )
		{
			attrFieldSliderGrp -edit -enable true hikControlRigSliderPull;
			eval connectControl hikControlRigSliderPull $pullAttrs;
		}
	}
}

global proc hikUpdateControlRigPinningButtons()
{
	int $pinRState = 0;
	int $pinTState = 0;

	string $currCharacter = hikGetCurrentCharacter( );
	if( size( $currCharacter ) )
	{
		string $effectors[ ] = hikGetSelectedEffectorsFromCharacter( $currCharacter, 1 );
		int $count = size( $effectors );
		if( $count > 0 )
		{
			$pinTState = `getAttr ( $effectors[ 0 ] + ".pinT" )`;
			$pinRState = `getAttr ( $effectors[ 0 ] + ".pinR" )`;
				
			for( $i = 1; $i < $count; ++$i )
			{
				if( $pinTState != `getAttr ( $effectors[ $i ] + ".pinT" )` )
					$pinTState = false;
					
				if( $pinRState != `getAttr ( $effectors[ $i ] + ".pinR" )` )
					$pinRState = false;
			}
				
		}
	}
		
	iconTextCheckBox -edit -value $pinTState hikControlRigTPinToggle;
	iconTextCheckBox -edit -value $pinRState hikControlRigRPinToggle;

	iconTextCheckBox 
		-edit
		-value ( `hikGlobals -query -releaseAllPinning` )
		hikControlRigReleaseAllToggle;
}

// Select IK Nodes of a Rig, from a Character
global proc hikSelectRigIKNodes(string $pCharacter)
{
	string $lIKNodes[] = hikGetRigIKNodes($pCharacter);
	for($lIKNode in $lIKNodes)
		select -add $lIKNode;
}

// Select FK Nodes of a Rig
global proc hikSelectRigFKNodes(string $pCharacter, int $includeRefNode)
{
	string $lFKNodes[] = hikGetRigFKNodes($pCharacter, $includeRefNode);
	for($lFKNode in $lFKNodes)
		select -add $lFKNode;
}


