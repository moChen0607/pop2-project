// Copyright (C) 1997-2014 Autodesk, Inc., and/or its licensors.
// All rights reserved.
//
// The coded instructions, statements, computer programs, and/or related
// material (collectively the "Data") in these files contain unpublished
// information proprietary to Autodesk, Inc. ("Autodesk") and/or its licensors,
// which is protected by U.S. and Canadian federal copyright law and by
// international treaties.
//
// The Data is provided for use exclusively by You. You have the right to use,
// modify, and incorporate this Data into other products for purposes authorized 
// by the Autodesk software license agreement, without fee.
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND. AUTODESK
// DOES NOT MAKE AND HEREBY DISCLAIMS ANY EXPRESS OR IMPLIED WARRANTIES
// INCLUDING, BUT NOT LIMITED TO, THE WARRANTIES OF NON-INFRINGEMENT,
// MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE, OR ARISING FROM A COURSE 
// OF DEALING, USAGE, OR TRADE PRACTICE. IN NO EVENT WILL AUTODESK AND/OR ITS
// LICENSORS BE LIABLE FOR ANY LOST REVENUES, DATA, OR PROFITS, OR SPECIAL,
// DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES, EVEN IF AUTODESK AND/OR ITS
// LICENSORS HAS BEEN ADVISED OF THE POSSIBILITY OR PROBABILITY OF SUCH DAMAGES.

// dynParticleValues.mel 
// This script fills the Dynamics particle tool property sheet with
// values and sets the control callbacks.
// property sheet.
// The property sheet is set up in  dynParticleProperties.mel
//
global proc dynParticleGridMinCB (string $toolName, 
                                  string $minControl, string $maxControl,
                                  string $minFlag, string $maxFlag)
{
    global float $dynMaxFloatField;
    global float $dynMinFloatField;

	dynFloatMinMax ($toolName, " dynParticleCtx",  $minControl, 
                    $minFlag, $dynMinFloatField, $dynMaxFloatField);

    // If the user sets the min greater than max, reset max to be 
    // the same as min;
    //
    float $min = `floatSliderGrp -q -v  $minControl`;
    float $max = `floatSliderGrp -q -v  $maxControl`;

    if ($min > $max)
    {
        floatSliderGrp -e -v $min $maxControl;
		dynFloatMinMax ($toolName, " dynParticleCtx", $maxControl,
                         $maxFlag, $dynMinFloatField, $dynMaxFloatField);
    }
}


global proc dynParticleGridMaxCB (string $toolName, 
                                  string $minControl, string $maxControl,
                                  string $minFlag, string $maxFlag)
{
    global float $dynMaxFloatField;
    global float $dynMinFloatField;

	dynFloatMinMax ($toolName, " dynParticleCtx",  $maxControl, 
                    $maxFlag, $dynMinFloatField, $dynMaxFloatField);

    // If the user sets max less than min, reset min to be the
	// same as max;
    //
    float $min = `floatSliderGrp -q -v  $minControl`;
    float $max = `floatSliderGrp -q -v  $maxControl`;

    if ($min > $max)
    {
        floatSliderGrp -e -v $max $minControl;
		dynFloatMinMax ($toolName, " dynParticleCtx", $minControl,
                         $minFlag, $dynMinFloatField, $dynMaxFloatField);
    }
}


global proc dynDimSketch(int $isSketchOn)
{

    // Dim or undim the widgets connected with particle sketch
    //
    if ($isSketchOn)
    {
        intSliderGrp -e -enable true sketchInterval;
		checkBoxGrp -e -v1 off particleGrid;
		checkBoxGrp -e -v1 on particleSketch;
    }
    else
    {
        intSliderGrp -e -enable false sketchInterval;
		checkBoxGrp -e -v1 off particleSketch;
    }
}

global proc dynEnableGridPositions(int $enable)
{
    // Show or hide the widgets connected with particle grid.
    //
	floatSliderGrp -edit -enable $enable pGridLLX;
	floatSliderGrp -edit -enable $enable pGridLLY;
	floatSliderGrp -edit -enable $enable pGridLLZ;

	floatSliderGrp -edit -enable $enable pGridURX;
	floatSliderGrp -edit -enable $enable pGridURY;
	floatSliderGrp -edit -enable $enable pGridURZ;
}

global proc dynDimGrid(string $toolName, int $isGridOn)
{

    // Dim or undim the widgets connected with particle grid
    //
    if ($isGridOn)
    {
        floatSliderGrp -e -enable 1 pGridSpacing;
        intSliderGrp -e -enable 0 pNumJitters;
        floatSliderGrp -e -enable 0 pJitterRadius;
		checkBoxGrp -e -v1 off particleSketch;
		checkBoxGrp -e -v1 on particleGrid;
		radioButtonGrp -e -enable true pGridPlacement1;
		radioButtonGrp -e -enable true pGridPlacement2;

        if (`dynParticleCtx -q -cp $toolName`)
        {
            radioButtonGrp -e -sl 1 pGridPlacement1;
            dynEnableGridPositions(0);
        }
        else
        {
            radioButtonGrp -e -sl 1 pGridPlacement2;
            dynEnableGridPositions(1);
        }
    }
    else
    {
        floatSliderGrp -e -enable false pGridSpacing;
        intSliderGrp -e -enable true pNumJitters;
		checkBoxGrp -e -v1 off particleGrid;
		if (`intSliderGrp -q -v pNumJitters` <= 1) {
			floatSliderGrp -e -enable false pJitterRadius;
		} else {
			floatSliderGrp -e -enable true pJitterRadius;
		}
		radioButtonGrp -e -enable false pGridPlacement1;
		radioButtonGrp -e -enable false pGridPlacement2;
        dynEnableGridPositions(0);
    }
}

global proc dynSketchCB(string $toolName, int $isSketchOn)
{

    // Let the context know the change in state of the
    // Sketch checkbox, and activate/dim necessary widgets.

    dynParticleCtx -e -sk $isSketchOn $toolName;

    dynDimSketch($isSketchOn);
}

global proc dynGridCB(string $toolName, int $isGridOn)
{

    // Let the context know the change in state of the
    // grid checkbox, and activate/dim necessary widgets.

    dynParticleCtx -e -gr $isGridOn $toolName;

    dynDimGrid($toolName, $isGridOn);
}


global proc dynParticleValues (string $toolName) 
{
    // These globals contain the lowest min and highest max for the
    // dynamics float fields.
    //
    global float $dynMaxFloatField;
    global float $dynMinFloatField;

    // Set the top layout to be the current parent
    //
    string $parent = (`toolPropertyWindow -q -location` + "|dynParticle");
    setParent $parent;

	string $helpTag = "Particle";
	toolPropertySetCommon $toolName "particle.png" $helpTag;

	if( exists( "nucleusSolverButton")  ){
		int $nucleusMode = `dynParticleCtx -q -nucleus dynParticleContext`;
		
		optionMenuGrp -e -visible $nucleusMode "particleToolNucleusMenu";
		updateNucleusSolverMenu 0 "particleToolNucleusMenu";
		
	}
	// Get the values from the context and put them into the contols.
	//
    textFieldGrp -e 
		-tx `dynParticleCtx -q -pn $toolName` 
		-cc ("dynParticleCtx -e -pn \"#1\" "+$toolName)
		particleName;

    floatSliderGrp -e
        -v `dynParticleCtx -q -c $toolName`
        -cc ("dynParticleCtx -e -c #1 "+$toolName)
        particleConserve;

    intSliderGrp -e 
		-v `dynParticleCtx -q -nj $toolName` 
		-cc ("dynIntMinMax "+$toolName+" dynParticleCtx pNumJitters -nj 0 "+$dynMaxFloatField)
		pNumJitters;

	if (`intSliderGrp -q -v pNumJitters` == 0) 
	{
		checkBoxGrp -e -enable false particleSketch;
        intSliderGrp -e -enable false sketchInterval;
		checkBoxGrp -e -enable false particleGrid;
	}
	else
	{
		checkBoxGrp -e -enable true particleSketch;
		checkBoxGrp -e -enable true particleGrid;
	}

	if (`intSliderGrp -q -v pNumJitters` <= 1) {
    	floatSliderGrp -e 
			-v `dynParticleCtx -q -jr $toolName` 
			-cc ("dynFloatMinMax " +
					$toolName +
					" dynParticleCtx pJitterRadius -jr 0 " +
					$dynMaxFloatField)
			-enable false
			pJitterRadius;
	} else {
    	floatSliderGrp -e 
			-v `dynParticleCtx -q -jr $toolName` 
			-cc ("dynFloatMinMax " +
					$toolName +
					" dynParticleCtx pJitterRadius -jr 0 " +
					$dynMaxFloatField)
			-enable true
			pJitterRadius;
	}

    checkBoxGrp -e
        -on1 ("dynSketchCB "+$toolName+" 1")
        -of1 ("dynSketchCB "+$toolName+" 0")
        particleSketch;

	if (`dynParticleCtx -q -sk $toolName`) 
	{
		dynDimSketch(1);
	}
	else
	{
		dynDimSketch(0);
	}

    intSliderGrp -e 
		-v `dynParticleCtx -q -ski $toolName` 
		-cc ("dynIntMinMax "+$toolName+" dynParticleCtx sketchInterval -ski 0 "+$dynMaxFloatField)
		sketchInterval;

    checkBoxGrp -e
        -on1 ("dynGridCB "+$toolName+" 1")
        -of1 ("dynGridCB "+$toolName+" 0")
        particleGrid;

	if (`dynParticleCtx -q -gr $toolName`) 
	{
		dynDimGrid($toolName, 1);
	}
	else
	{
		dynDimGrid($toolName, 0);
	}

    floatSliderGrp -e 
		-v `dynParticleCtx -q -grs $toolName` 
		-cc ("dynFloatMinMax "+$toolName+" dynParticleCtx pGridSpacing -grs 0 "+$dynMaxFloatField)
		pGridSpacing;

    radioButtonGrp -e
        -on1 ("dynParticleCtx -e -cp "+$toolName+"; dynEnableGridPositions(0)")
        pGridPlacement1;

    radioButtonGrp -e
        -on1 ("dynParticleCtx -e -tp "+$toolName+"; dynEnableGridPositions(1)")
        pGridPlacement2;

    if (`dynParticleCtx -q -cp $toolName`) 
	{
        radioButtonGrp -e -sl 1 pGridPlacement1;
 		dynEnableGridPositions(0);
	}
	else 
	{
		radioButtonGrp -e -sl 1 pGridPlacement2;
		if(`dynParticleCtx -q -gr $toolName`) 
		{
			dynEnableGridPositions(1);
		}
		else 
		{
			dynEnableGridPositions(0);
		}
	}

    floatSliderGrp -e 
		-v `dynParticleCtx -q -llx $toolName` 
		-cc ("dynParticleGridMinCB "+$toolName+" pGridLLX pGridURX -llx -urx")
		pGridLLX;

    floatSliderGrp -e 
		-v `dynParticleCtx -q -lly $toolName` 
		-cc ("dynParticleGridMinCB "+$toolName+" pGridLLY pGridURY -lly -ury")
		pGridLLY;

    floatSliderGrp -e 
		-v `dynParticleCtx -q -llz $toolName` 
		-cc ("dynParticleGridMinCB "+$toolName+" pGridLLZ pGridURZ -llz -urz")
		pGridLLZ;

    floatSliderGrp -e 
		-v `dynParticleCtx -q -urx $toolName` 
		-cc ("dynParticleGridMaxCB "+$toolName+" pGridLLX pGridURX -llx -urx")
		pGridURX;

    floatSliderGrp -e 
		-v `dynParticleCtx -q -ury $toolName` 
		-cc ("dynParticleGridMaxCB "+$toolName+" pGridLLY pGridURY -lly -ury")
		pGridURY;

    floatSliderGrp -e 
		-v `dynParticleCtx -q -urz $toolName` 
		-cc ("dynParticleGridMaxCB "+$toolName+" pGridLLZ pGridURZ -llz -urz")
		pGridURZ;

	toolPropertySelect dynParticle;
}


