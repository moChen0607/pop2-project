// Copyright (C) 1997-2014 Autodesk, Inc., and/or its licensors.
// All rights reserved.
//
// The coded instructions, statements, computer programs, and/or related
// material (collectively the "Data") in these files contain unpublished
// information proprietary to Autodesk, Inc. ("Autodesk") and/or its licensors,
// which is protected by U.S. and Canadian federal copyright law and by
// international treaties.
//
// The Data is provided for use exclusively by You. You have the right to use,
// modify, and incorporate this Data into other products for purposes authorized 
// by the Autodesk software license agreement, without fee.
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND. AUTODESK
// DOES NOT MAKE AND HEREBY DISCLAIMS ANY EXPRESS OR IMPLIED WARRANTIES
// INCLUDING, BUT NOT LIMITED TO, THE WARRANTIES OF NON-INFRINGEMENT,
// MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE, OR ARISING FROM A COURSE 
// OF DEALING, USAGE, OR TRADE PRACTICE. IN NO EVENT WILL AUTODESK AND/OR ITS
// LICENSORS BE LIABLE FOR ANY LOST REVENUES, DATA, OR PROFITS, OR SPECIAL,
// DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES, EVEN IF AUTODESK AND/OR ITS
// LICENSORS HAS BEEN ADVISED OF THE POSSIBILITY OR PROBABILITY OF SUCH DAMAGES.

//
//  Creation Date:  November 20, 1996
//
//  Description:
//      This script contains common menu definition routines shared
//	between the Graph Editor and the Dope Sheet.
//
//		A call to the proc 'loadAnimMenuLibrary' will make sure that
//	all the other helper procs defined in here are loaded and available
//
//	Procs defined within this script:
//
//	defineEditMenu (string $editor, string $animEditor, string $parentMenu, string $buildMenuCommand)
//		Define the elements of the Edit subMenu
//
//	defineCurvesMenu(string $editor, string $animEditor,
//		string $parentMenu, string $options, string $buildMenuCommand)
//		Define the elements of the Curves subMenu
//
//	defineListMenu (string $editor, string $animEditor, string $parentMenu)
//		Define the elements of the List subMenu
//
//	defineTangentsMenu (string $editor, string $animEditor, string $parentMenu)
//		Define the elements of the Tangents subMenu
//
//

global string $gEditorList[];
global string $gDefaultConnection[];

// Remember the tangent menu creation information so that plugin buttons
// can be managed as plugins are loaded and unloaded.
global string $gTangentParentEditor = "";
global string $gTangentAnimEditor = "";
global string $gTangentParentMenu = "";
global string $gTangentInParentMenu = "";
global string $gTangentOutParentMenu = "";
global string $gTangentMenuOptions = "";
global string $gTangentPluginItemList[];
global string $gTangentInPluginItemList[];
global string $gTangentOutPluginItemList[];

global proc performEulerFilter(string $selectionConnection) 
{
	string $objs[] = `findAnimCurves $selectionConnection`;
	int $nObjs = size($objs);
	int $i = 0;
	string $cmd = "filterCurve ";
	for ($i = 0; $i < $nObjs ; $i++) {
		$cmd += (" " + $objs[$i]);
	}

	if ($nObjs > 0) {
		evalEcho ($cmd);
	}
}

global proc performRotationInterpolation( string $mode, string $selectionConnection ) 
{
	// Query the curves which are selected in the graph editor viewport
	// and append the selected names to a rotationInterpolation command
	// string.
	//
	string $viewportSel[];
	if ( `isTrue SomethingSelected` != 0 ) {
		catch( $viewportSel = `keyframe -an keys -query -name` );
	}
	string $cmd = "rotationInterpolation -c " + $mode;
	int $i;
	int $viewportCount = size( $viewportSel );
	for ( $i = 0; $i < $viewportCount; $i++ ) {
	 	$cmd += (" " + $viewportSel[$i]);
	}

	// Query the curves which are selected in the graph editor outliner
	// and append the selected names to the command string.
	//
	string $outlinerSel[] = `selectionConnection -q -object $selectionConnection`;
	int $outlinerCount = size( $outlinerSel );
	for ( $i = 0; $i < $outlinerCount; $i++ ) {
	 	$cmd += (" " + $outlinerSel[$i]);
	}

	// If any curves were selected, execute the command string which we
	// built up.
	//
	if ( $viewportCount + $outlinerCount > 0 ) {
		evalEcho( $cmd );
	}
	animCurveEditor -e -upd graphEditor1GraphEd;
}

proc int
findEditorEntry (string $editor)
//
//	Procedure Name:
//		findEditorEntry
//
//	Description:
//		Helper method to find the index entry of a registered editor
//
//  Input Arguments:
//	string $editor		The name of the editor that is registered
//
//  Return Value:
//      int the index entry in $editorList (-1 if it is not registered)
//
{
	global string $gEditorList[];
	int $length = size ($gEditorList);
	for ($i = 0; $i < $length; $i++) {
		if ($gEditorList[$i] == $editor) {
			return ($i);
		}
	}
	return (-1);
}

global proc string
getDefaultConnection (string $editor)
//
//	Procedure Name:
//		getDefaultConnection
//
//	Description:
//		Helper method to find the name of the default selection connection
//	for a registered editor
//
//  Input Arguments:
//		string $editor			The name of the editor that is registered
//
//  Return Value:
//      string the name of the default selection connection, "animationList"
//	if the editor is not registered
//
{
	global string $gDefaultConnection[];

	int $entry = findEditorEntry ($editor);
	if ($entry == -1) {
		return ("animationList");
	}
	return ($gDefaultConnection[$entry]);
}

global proc
registerEditor (string $editor, string $defaultConnection)
//
//	Procedure Name:
//		registerEditor
//
//	Description:
//		Helper method to register the name of the default selection connection
//	for this editor
//
//  Input Arguments:
//		string $editor			The name of the editor that is being registered
//		string $defaultConnection	The name of the default selection connection
//
//  Return Value:
//      None.
//
{
	global string $gEditorList[];
	global string $gDefaultConnection[];

	int $entry = findEditorEntry ($editor);
	if ($entry == -1) {
		int $length = size ($gEditorList);
		$gEditorList[$length] = $editor;
		$gDefaultConnection[$length] = $defaultConnection;
	}
}

global proc string[] findActiveAnimCurves (string $editor)
//
//	Procedure Name:
//		findActiveAnimCurves 
//
//	Description:
//		This returns the list of highlighted anim curves 
//
//  Input Arguments:
//		string $editor			The name of the editor that is being checked
//								for highlighted curves
//
//  Return Value:
//      string[] $curves: 		String array of highlighted curves 
//
{
	string $activeConnectionList = `editor -query -highlightConnection $editor`;
	string $curves[] = `findAnimCurves $activeConnectionList`;
	return $curves;
}

global proc
buildAnimEditMenu (string $editor, string $animEditor, string $parentMenu, string $options, string $buildMenuCommand)
//
//	Procedure Name:
//		buildAnimEditMenu
//
//	Description:
//		This actually builds the edit subMenu if necessary
//
//  Input Arguments:
//		string $editor			The name of the editor that this submenu
//								is being attached to
//		string $animEditor		The name of the animation editor that this submenu
//								is being attached to
//		string $parentMenu		The name of the parent menu that this
//								submenu is being attached to
//		string $options			Options for this proc
//								Option words are specified within the
//								the string, with each option seperated
//								by a space (e.g. "bufferCurve otherOption")
//			Current options:
//				noOptions		A nice "do nothing" string to pass
//				bufferCurve		Issue commands to (possibly) create buffer curves
//		string $buildMenuCommand
//								An optional command to be called when
//								this menu is built.  The command will
//								be called with $editor $parentMenu
//
//  Return Value:
//      None.
//
{
	setParent -menu $parentMenu;
	if (`menu -query -numberOfItems $parentMenu` != 0) {
		return;
	}

	// Check for the bufferCurve option
	//
	int $performBase = 0;
	if (match ("bufferCurve", $options) == "bufferCurve") {
		$performBase = 3;
	}

	int $enableRegionTool = 0;
	if (match ("regionTool", $options) != "") {
		$enableRegionTool = 1;
	}

	int $enableRetimeTool = 0;
	if (match ("retimeTool", $options) != "") {
		$enableRetimeTool = 1;
	}

	menuItem -label (uiRes("m_loadAnimMenuLibrary.kUndo")) 
		-annotation (uiRes("m_loadAnimMenuLibrary.kUndoAnnot")) 
		-command "Undo"
		animUndoItem;
	dimWhen -false "UndoAvailable" animUndoItem;
	menuItem -label (uiRes("m_loadAnimMenuLibrary.kRedo")) 
		-annotation (uiRes("m_loadAnimMenuLibrary.kRedoAnnot"))
		-command "Redo"
		animRedoItem;
	dimWhen -false "RedoAvailable" animRedoItem;

	menuItem -divider true;

	string $selectionConnection = `editor -query -selectionConnection $editor`;
	if (match ("bufferCurve", $options) == "bufferCurve") {
		$selectionConnection = $animEditor;
	}

	menuItem -label (uiRes("m_loadAnimMenuLibrary.kCut")) 
		-annotation (uiRes("m_loadAnimMenuLibrary.kCutAnnot")) 
		-command ("performCutKeyArgList 1 {\"" + $performBase + "\", \"" + $selectionConnection + "\", \"1\"}") 
		-dragMenuCommand( "performCutKeyArgList 1 {\"" + ($performBase + 2) + "\", \"" + $selectionConnection + "\", \"1\"}")
		cutItem;
	menuItem -optionBox true 
		-annotation (uiRes("m_loadAnimMenuLibrary.kCutOptionsAnnot")) 
		-command ("performCutKeyArgList 1 {\"" + ($performBase + 1) + "\", \"" + $selectionConnection + "\", \"1\"}" ) 
		cutKeyDialogItem;
	menuItem -label (uiRes("m_loadAnimMenuLibrary.kCopy")) 
		-annotation (uiRes("m_loadAnimMenuLibrary.kCopyAnnot"))
		-command ("performCopyKeyArgList 1 {\"" + $performBase + "\", \"" + $selectionConnection + "\", \"1\"}") 
		-dragMenuCommand( "performCopyKeyArgList 1 {\"" + ($performBase + 2) + "\", \"" + $selectionConnection + "\", \"1\"}")
		copyItem;
	menuItem -optionBox true 
		-annotation (uiRes("m_loadAnimMenuLibrary.kCopyOptions")) 
		-command ("performCopyKeyArgList 1 {\"" + ($performBase + 1) + "\", \"" + $selectionConnection + "\", \"1\"}" )
		copyKeyDialogItem;
	menuItem -label (uiRes("m_loadAnimMenuLibrary.kPaste")) 
		-annotation (uiRes("m_loadAnimMenuLibrary.kPasteAnnot")) 
		-command ("performPasteKeyArgList 1 {\"" + $performBase + "\", \"" + $selectionConnection + "\", \"1\"}")
		-dragMenuCommand( "performPasteKeyArgList 1 {\"" + ($performBase + 2) + "\", \"" + $selectionConnection + "\", \"1\"}")
		pasteItem;
	menuItem -optionBox true 
		-annotation (uiRes("m_loadAnimMenuLibrary.kPasteOptions")) 
		-command ("performPasteKeyArgList 1 {\"" + ($performBase + 1) + "\", \"" + $selectionConnection + "\", \"1\"}")
		pasteKeyDialogItem;
	menuItem -label (uiRes("m_loadAnimMenuLibrary.kDelete")) 
		-annotation (uiRes("m_loadAnimMenuLibrary.kDeleteAnnot")) 
		-command ("performClearKeyArgList 1 {\"" + $performBase + "\", \"" + $selectionConnection + "\", \"0\", \"1\"}")
		-dragMenuCommand( "performClearKeyArgList 1 {\"" + ($performBase + 2) + "\", \"" + $selectionConnection + ", \"0\", \"1\"}")
		clearItem;
	menuItem -optionBox true 
		-annotation (uiRes("m_loadAnimMenuLibrary.kDeleteOptions")) 
		-command ("performClearKeyArgList 1 {\"" + ($performBase + 1) + "\", \"" + $selectionConnection + "\", \"0\", \"1\"}")
		clearKeyDialogItem;
	menuItem -label (uiRes("m_loadAnimMenuLibrary.kScale")) 
		-annotation (uiRes("m_loadAnimMenuLibrary.kScaleAnnot"))
		-command ("performScaleKeyArgList 1 {\"" + $performBase + "\", \"" + $selectionConnection + "\", \"1\"}" )
		-dragMenuCommand( "performScaleKeyArgList 1 {\"" + ($performBase + 2) + "\", \"" + $selectionConnection + "\", \"1\"}")
		scaleItem;
	menuItem -optionBox true 
		-annotation (uiRes("m_loadAnimMenuLibrary.kScaleOptions")) 
		-command ("performScaleKeyArgList 1 {\"" + ($performBase + 1) + "\", \"" + $selectionConnection + "\", \"1\"}")
		scaleKeyDialogItem;

	menuItem -label (uiRes("m_loadAnimMenuLibrary.kTransformTools"))
		-subMenu true -tearOff true
		-allowOptionBoxes true transAnimItem;
	menuItem -label (uiRes("m_loadAnimMenuLibrary.kMoveKeysTool")) 
		-annotation (getRunTimeCommandAnnotation("MoveTool"))
		-image "move_M.png"
		-command "MoveTool"
		-dragDoubleClickCommand "MoveToolOptions";

	menuItem -optionBox true
		-annotation (getRunTimeCommandAnnotation("MoveToolOptions"))
		-image "move_M.png" 
		-command "MoveToolOptions"
			;

	menuItem 
		-label (uiRes("m_loadAnimMenuLibrary.kScaleKeysTool"))  
		-annotation (getRunTimeCommandAnnotation("ScaleTool"))
		-image "scale_M.png"
		-command "ScaleTool"
		-dragDoubleClickCommand "ScaleToolOptions"
		;
	menuItem -optionBox true
		-annotation (getRunTimeCommandAnnotation("ScaleToolOptions"))
		-image "scale_M.png" 
		-command "ScaleToolOptions"
			;
	int $enableLattice = ($options != "noOptions");
	menuItem -label (uiRes("m_loadAnimMenuLibrary.kLatticeDeform")) 
		-annotation (getRunTimeCommandAnnotation("LatticeDeformKeysTool"))
		-enable $enableLattice
		-image "latticeDeformKeySmall.png"
		-command "LatticeDeformKeysTool";

	menuItem -optionBox true
		-enable $enableLattice
		-annotation (getRunTimeCommandAnnotation("LatticeDeformKeysToolOptions"))
		-image "latticeDeformKeySmall.png"
		-command "LatticeDeformKeysToolOptions";

	menuItem -label (uiRes("m_loadAnimMenuLibrary.kRegionKeysTool"))
		-enable $enableRegionTool
		-annotation (getRunTimeCommandAnnotation("RegionKeysTool"))
		-image "regionSelectKeySmall.png"
		-command "RegionKeysTool";

	menuItem -label (uiRes("m_loadAnimMenuLibrary.kRetimeKeysTool"))
		-enable $enableRetimeTool
		-annotation (getRunTimeCommandAnnotation("RetimeKeysTool"))
		-image "retimeKeySmall.png"
		-command "RetimeKeysTool";

	menuItem -optionBox true
		-enable $enableRetimeTool
		-annotation (getRunTimeCommandAnnotation("RetimeKeysToolOptions"))
		-image "retimeKeySmall.png"
		-command "RetimeKeysToolOptions";

	setParent -m ..;

	menuItem -divider true;

	menuItem -label (uiRes("m_loadAnimMenuLibrary.kSnap")) 
		-annotation (uiRes("m_loadAnimMenuLibrary.kSnapAnnot"))
		-command ("performSnapKeyArgList 1 { \"" + $performBase + "\", \"" + $selectionConnection + "\", \"1\" }" )
		-dragMenuCommand( "performSnapKeyArgList 1 { \"" + ($performBase + 2) + "\", \"" + $selectionConnection + "\", \"1\" }" )
		snapItem;
	menuItem -optionBox true 
		-annotation (uiRes("m_loadAnimMenuLibrary.kSnapOptions")) 
		-command ("performSnapKeyArgList 1 { \"" + ($performBase + 1) + "\", \"" + $selectionConnection + "\", \"1\" }")
		snapKeyDialogItem;

	menuItem -label (uiRes("m_loadAnimMenuLibrary.kSelectUnsnapped")) 
		-annotation (uiRes("m_loadAnimMenuLibrary.kSelectUnsnappedAnnot")) 
		-command ("performSnapKeyArgList 1 { \"6\", \"" + $selectionConnection + "\", \"1\" } " )
		-dragMenuCommand( "performSnapKeyArgList 1 { \"7\", \"" + $selectionConnection + "\", \"1\" } " )
		selectUnsnappedItem;
		
	menuItem -divider true;
	
	menuItem -label (uiRes("m_loadAnimMenuLibrary.kSelectCurveNodes")) 
		-annotation (uiRes("m_loadAnimMenuLibrary.kSelectCurveNodesAnnot")) 
		-command ( "string $curves[] = `findActiveAnimCurves " + $editor + "`;select -replace $curves;" )
		selectCurveNodesItem;
		
	menuItem -label (uiRes("m_loadAnimMenuLibrary.kChangeCurveColor")) 
		-annotation (uiRes("m_loadAnimMenuLibrary.kChangeCurveColorAnnot")) 
		-command ( "performChangeAnimCurveColor 0 " + $editor )
		changeCurveColorItem;
	menuItem -optionBox true 
		-annotation (uiRes("m_loadAnimMenuLibrary.kChangeCurveColorOptionsAnnot")) 
		-command ( "performChangeAnimCurveColor 1 " + $editor )
		changeCurveColorOptionsItem;
		
	menuItem -label (uiRes("m_loadAnimMenuLibrary.kRemoveCurveColor")) 
		-annotation (uiRes("m_loadAnimMenuLibrary.kRemoveCurveColorAnnot")) 
		-command ( "string $curves[] = `findActiveAnimCurves " + $editor + "`;for ($curve in $curves){setAttr ($curve + \".useCurveColor\") 0;}" )
		removeCurveColorItem;
	
	menuItem -label (uiRes("m_loadAnimMenuLibrary.kSetCurveColors")) 
		-annotation (uiRes("m_loadAnimMenuLibrary.kSetCurveColorsAnnot")) 
		-command ( "showCurveColorWindow " + $editor )
		setCurveColorsItem;

	menuItem -divider true;
		
	string $timeWarpSubMenu =
	`menuItem -subMenu true -label (uiRes("m_loadAnimMenuLibrary.kTimeWarp"))  
		-tearOff true
		-allowOptionBoxes true
		timeWarpSubMenu`;

		// 	Add Time Warp
		//
		menuItem -label (uiRes("m_loadAnimMenuLibrary.kAddTimeWarp"))  -command "AddTimeWarp" 
			-annotation (uiRes("m_loadAnimMenuLibrary.kAddTimeWarpAnnot")) 
			addTimeWarpItem;

		// 	Select Time Warp
		//
		menuItem -label (uiRes("m_loadAnimMenuLibrary.kSelectTimeWarp"))  -command "SelectTimeWarp" 
			-annotation (uiRes("m_loadAnimMenuLibrary.kSelectTimeWarpAnnot")) 
			selectTimeWarpItem;

		// 	Delete Time Warp
		//
		menuItem -label (uiRes("m_loadAnimMenuLibrary.kDeleteTimeWarp"))  -command "DeleteTimeWarp" 
			-annotation (uiRes("m_loadAnimMenuLibrary.kDeleteTimeWarpAnnot")) 
			deleteTimeWarpItem;

		// 	Enable Time Warp
		//
		string $enableTimeWarpItem = 
		`menuItem -label (uiRes("m_loadAnimMenuLibrary.kEnableTimeWarp"))
			-annotation (uiRes("m_loadAnimMenuLibrary.kEnableTimeWarpAnnot")) 
			-cb 1
			-command "setAttr time1.enableTimewarp (!`getAttr time1.enableTimewarp`); currentTime `currentTime -q`;"
			enableTimeWarpItem`;

		setParent -m ..;

	menuItem -e
		-pmc ( "menuItem -e -cb `getAttr time1.enableTimewarp` " + $enableTimeWarpItem )
		$timeWarpSubMenu;

	if ($buildMenuCommand != "") {
		eval (($buildMenuCommand + " " + $animEditor + " " + $parentMenu));
	}
}

global proc
defineEditMenu (string $editor, string $animEditor, string $parentMenu, string $options, string $buildMenuCommand)
//
//	Procedure Name:
//		defineEditMenu
//
//	Description:
//		This creates the submenu for edit functionality
//
//	Example:
//		Create a menu that this submenu is to be attached to
//	(make sure that the menu is defined to allow option boxes)
//
//		menuItem -label _L10N( kEdit, "Edit" ) 
//			-allowOptionBoxes true
//			-subMenu true
//			editHierItem;
//			defineEditMenu $editor "editHierItem" "optionalBuildMenuCommand"; 
//		setParent -menu ..;
//
//  Input Arguments:
//		string $editor			The name of the editor that this submenu
//								is being attached to
//		string $parentMenu		The name of the parent menu that this
//								submenu is being attached to
//		string $options			Options for this proc
//								Option words are specified within the
//								the string, with each option seperated
//								by a space (e.g. "bufferCurve otherOption")
//			Current options:
//				noOptions		A nice "do nothing" string to pass
//				bufferCurve		Issue commands to (possibly) create buffer curves
//		string $buildMenuCommand
//								An optional command to be called when
//								this menu is built.  The command will
//								be called with $editor $parentMenu
//
//  Return Value:
//      None.
//
{
	setParent -menu $parentMenu;

	menu -edit
		-postMenuCommand ("buildAnimEditMenu " + $editor + " " + $animEditor + " " + $parentMenu + "\"" + $options + "\"" + " " + "\"" + $buildMenuCommand + "\"")
		$parentMenu;

	// This section will allow the undo item to display what is going to
	// be undone.  This is the fix for bug 55712.  However the main undo
	// menu items no longer show this, so this block is commented out for
	// now
	//
//mm	menu -edit
//mm		-postMenuCommand ("handleEditMenuCmd " + $parentMenu)
//mm		$parentMenu;

}

global proc
handleEditMenuCmd (string $parentMenu)
//
//  Procedure Name:
//      handleEditMenuCmd
//
//  Description:
//		This proc is a -postMenuCommand callback which sets the state of
//	menu items in the Edit menu.
//
//  Input Arguments:
//      None.
//
//  Return Value:
//      None.
//
{
	string $undoName;
	string $buffer[];
	string $menuItemRes;
	
	setParent -menu $parentMenu;

	$undoName = `undoInfo -query -undoName`;
	tokenize ($undoName, $buffer);
	$menuItemRes = `uiRes("m_loadAnimMenuLibrary.kUndo")`;
	$undoName = ($menuItemRes + " " + $buffer[0]);
	menuItem -edit -label $undoName animUndoItem;

	$undoName = `undoInfo -query -redoName`;
	tokenize ($undoName, $buffer);
	$menuItemRes = `uiRes("m_loadAnimMenuLibrary.kRedo")`;
	$undoName = ($menuItemRes + " " + $buffer[0]);
	menuItem -edit -label $undoName animRedoItem;
}

global proc int
isAutoLoad (string $editor)
{
	// First, find out what is connected to this editor
	//
	string $mainListConnection = `editor -query -mainListConnection $editor`;

	// If it is NOT the active list, then check it off
	//
	string $defaultConnection = getDefaultConnection ($editor);
	if(( $mainListConnection != "activeList" ) 
	&& ( $mainListConnection != $defaultConnection )) 
	{
		return (0);
	}
	else if (`selectionConnection -query -lock $mainListConnection`) {
		return (0);
	}
	return (1);
}

global proc
toggleAutoLoad (string $editor, int $toggle)
//
//  Procedure Name:
//      toggleAutoLoad
//
//  Description:
//		This proc is a helper to toggle the auto load state
//		of the outliner.
//
//  Input Arguments:
//      None.
//
//  Return Value:
//      None.
//
{
	// First, find out what is connected to this editor
	//
	string $mainListConnection = `editor -query -mainListConnection $editor`;
	// If it is NOT the active list, then force it to use the active list
	//
	string $defaultConnection = getDefaultConnection ($editor);
	if (($mainListConnection != "activeList") && ($mainListConnection != $defaultConnection)) {
		editor -edit -unlockMainConnection $editor;
		editor -edit -mainListConnection $defaultConnection $editor;
	}
	else if ($toggle) {
		editor -edit -unlockMainConnection $editor;
	}
	else {
		editor -edit -lockMainConnection $editor;
	}

	// The best way to resolve the button name is to pass in the full
	// path to the button, however toggleAutoLoad is called from several
	// places (including some c++ code) and this makes it difficult.
	// So instead we will use a carefully constructed name for the
	// button
	//
	if (`iconTextCheckBox -exists ($editor + "loadToggleButton")`) {
		iconTextCheckBox -edit
			-value `isAutoLoad $editor`
			($editor + "loadToggleButton");
	}

	if (`iconTextButton -exists ($editor + "reloadButton")`) {
		iconTextButton -edit
			-enable (!`isAutoLoad $editor`)
			($editor + "reloadButton");
	}
}

global proc
doReload (string $editor)
//
//  Procedure Name:
//      doReload
//
//  Description:
//		This proc is a helper to have the outliner do a reload.
//
//  Input Arguments:
//      None.
//
//  Return Value:
//      None.
//
{
	// First, find out what is connected to this editor
	//
	string $mainListConnection = `editor -query -mainListConnection $editor`;
	// If it is NOT the active list, then force it to use the active list
	//
	string $defaultConnection = getDefaultConnection ($editor);
	if (($mainListConnection != "activeList") && ($mainListConnection != $defaultConnection)) {
//		editor -edit -unlockMainConnection $editor;
//		editor -edit -mainListConnection $defaultConnection $editor;
//		editor -edit -lockMainConnection $editor;
		editor -edit -forceMainConnection $defaultConnection $editor;
	}
	// Otherwise switch the lock on the list off and on
	//
	else if (`selectionConnection -query -lock $mainListConnection`) {
//		editor -edit -unlockMainConnection $editor;
//		editor -edit -mainListConnection $defaultConnection $editor;
//		editor -edit -lockMainConnection $editor;
		editor -edit -forceMainConnection $defaultConnection $editor;
	}
}

global proc
handleListMenuCmd (string $options, string $editor, string $animEditor, string $parentMenu, string $buildMenuCommand)
//
//  Procedure Name:
//      handleListMenuCmd
//
//  Description:
//		This proc is a -postMenuCommand callback which sets the state of
//	menu items in the List menu.
//
//  Input Arguments:
//		string $options			Options for this menu
//								Option words are specified within the
//								the string, with each option seperated
//								by a space (e.g. "noScroll otherOption")
//
//			Current options:
//				noOptions		A nice "do nothing" string to pass
//				useHier			Add a "Hierarchy Below" entry
//				useCharacters	Add support for characters
//				useSUC			Add a "Show upstream curves" entry
//
//  Return Value:
//      None.
//
{
	// Set the proper check state of the AutoLoad menu
	//
	setParent -menu $parentMenu;

	string $objects = (uiRes("m_loadAnimMenuLibrary.kObjects"));
	string $bookmarkType = "bookmarkAnimCurves";
	string $toggleLoadCmd = ("toggleAutoLoad " + $editor + " #1");
	int $autoLoad = 1;
	string $editorName = (uiRes("m_loadAnimMenuLibrary.kGraphEditor"));
	if (match ("useCharacters", $options) == "useCharacters") {
		$objects = (uiRes("m_loadAnimMenuLibrary.kCharacters"));
		$bookmarkType = "bookmarkClips";
		$toggleLoadCmd += ("; optionVar -intValue traxAutoLoadSel #1");
		$editorName = (uiRes("m_loadAnimMenuLibrary.kTraxEditor"));
		if (`optionVar -exists traxAutoLoadSel`) {
			$autoLoad = `optionVar -q traxAutoLoadSel`;
		}
	}

	if (`menu -query -numberOfItems $parentMenu` == 0) {
		if (match ("useHier", $options) == "useHier") {
			menuItem -label (uiRes("m_loadAnimMenuLibrary.kHierarchyBelow")) 
				-annotation (uiRes("m_loadAnimMenuLibrary.kHierarchyBelowAnnot"))
				-checkBox false
				-command ("setHierarchyBelow #1 " + $animEditor)
				hierItem;
		}
		string $autoLoadFormat = (uiRes("m_loadAnimMenuLibrary.kAutoLoad"));
		string $autoLoadAnnotFormat = (uiRes("m_loadAnimMenuLibrary.kAutoLoadAnnot"));
		string $autoLoadLabel = `format -stringArg $objects $autoLoadFormat`;
		string $autoLoadAnnot = `format -stringArg $editorName $autoLoadAnnotFormat`;

		menuItem -label $autoLoadLabel
			-checkBox $autoLoad
			-annotation $autoLoadAnnot
			-command $toggleLoadCmd
			autoLoadItem;

		string $loadSelFormat = (uiRes("m_loadAnimMenuLibrary.kLoadSel"));
		string $loadSelAnnotFormat = (uiRes("m_loadAnimMenuLibrary.kLoadSelAnnot"));
		string $loadSel = `format -stringArg $objects $loadSelFormat`;
		string $loadSelAnnot = `format -stringArg $editorName $loadSelAnnotFormat`;
		menuItem -label $loadSel
			-annotation $loadSelAnnot
			-command ("doReload " + $editor)
			reloadItem;

		string $addSelFormat = (uiRes("m_loadAnimMenuLibrary.kAddSel"));
		string $addSelAnnotFormat = (uiRes("m_loadAnimMenuLibrary.kAddSelAnnot"));
		string $addSel = `format -stringArg $objects $addSelFormat`;
		string $addSelAnnot = `format -stringArg $editorName $addSelAnnotFormat`;
		menuItem -label $addSel
			-annotation $addSelAnnot
			-command ("addSelectedToEditorWithOptions \"" + $options + "\" " + $editor)
			addToListItem;

		string $menuItem = `menuItem -label (uiRes("m_loadAnimMenuLibrary.kBookmarks")) 
			-subMenu true -allowOptionBoxes true
			bookMarkHierItem`;

		menuItem -edit
			-postMenuCommand ("buildBookmarkMenu -type " + $bookmarkType + " -editor " + $editor + " " + $menuItem)
			$menuItem;

		string $bookmarkFormat = (uiRes("m_loadAnimMenuLibrary.kBookmarkCurrent"));
		string $bookmark = `format -stringArg $objects $bookmarkFormat`;
			menuItem 
				-label $bookmark
				-annotation (uiRes("m_loadAnimMenuLibrary.kBookmarkAnnot")) 
				-command ("createBookmark " + $editor + " " + $bookmarkType + " false") 
				bookAnimMarkObjectsItem;
				menuItem -optionBox true
					-annotation (uiRes("m_loadAnimMenuLibrary.kBookmarkOptions")) 
					-command ("createBookmark " + $editor + " " + $bookmarkType + " true")
					bookAnimMarkObjectsDialog;
					
			//these menu items are not applicable to trax (clipEditor)	
			if (!`gmatch $editor "*clip*"`){
			menuItem 
				-label (uiRes("m_loadAnimMenuLibrary.kBookmarkCurves")) 
				-annotation (uiRes("m_loadAnimMenuLibrary.kBookmarkCurvesAnnot")) 
				-command ("string $objects[] = `ls -sl`;" + "string $curves[] = `findActiveAnimCurves " + $editor + "`;select -replace $curves;createBookmark " + $editor + " " + $bookmarkType + " false; select -replace $objects;") 
				bookAnimMarkCurvesItem;
				menuItem -optionBox true
					-annotation (uiRes("m_loadAnimMenuLibrary.kBookmarkCurvesOptions")) 
					-command ("string $objects[] = `ls -sl`;" + "string $curves[] = `findActiveAnimCurves " + $editor + "`;select -replace $curves;createBookmark " + $editor + " " + $bookmarkType + " true; select -replace $objects;")
					bookAnimMarkCurvesDialog;
				}

			menuItem 
				-label (uiRes("m_loadAnimMenuLibrary.kRemoveBookmarks")) 
				-annotation (uiRes("m_loadAnimMenuLibrary.kRemoveBookmarksAnnot")) 
				-command ("removeBookmark {} " + $bookmarkType) 
				removeAllBookmarksItem;
			setParent -menu ..;

		if (match ("useSUC", $options) == "useSUC") {
			menuItem -divider true;

			menuItem -label (uiRes("m_loadAnimMenuLibrary.kShowUpstreamCurves")) 
				-checkBox true
				-annotation (uiRes("m_loadAnimMenuLibrary.kShowUpstreamCurvesAnnot"))
				-command (
					"outlinerEditor -e -suc #1 " + $editor + ";" +
					"animCurveEditor -e -suc #1 " + $animEditor + ";" +
					"optionVar -intValue graphEditorShowUpstreamCurves #1;"
				)
				showUpstreamCurvesItem;
		}

		if ($buildMenuCommand != "") {
			eval (($buildMenuCommand + " " + $editor + " " + $animEditor + " " + $parentMenu));
		}
	}

	if (match ("useHier", $options) == "useHier") {
		menuItem -edit
			-checkBox `dopeSheetEditor -query -hierarchyBelow $animEditor`
			hierItem;
	}

	if (match ("useSUC", $options) == "useSUC") {
		menuItem -edit
			-checkBox `outlinerEditor -q -suc $editor`
			showUpstreamCurvesItem;
	}

	// First, find out what is connected to this editor
	//
	string $mainListConnection = `editor -query -mainListConnection $editor`;
	if ($mainListConnection == "") {
		if (`modelEditor -exists $editor`) {
			$mainListConnection = "activeList";
		}
	}

	// If it is NOT the active list, then check it off
	//
	string $defaultConnection = getDefaultConnection ($editor);
	if(( $mainListConnection != "activeList") 
    && ( $mainListConnection != $defaultConnection )) 
	{
		menuItem -edit -checkBox off autoLoadItem;
		menuItem -edit -enable true reloadItem;
		menuItem -edit -enable true addToListItem;
	}
	else if (`selectionConnection -query -lock $mainListConnection`) {
		menuItem -edit -checkBox off autoLoadItem;
		menuItem -edit -enable true reloadItem;
		menuItem -edit -enable true addToListItem;
	}
	else {
		menuItem -edit -checkBox on autoLoadItem;
		menuItem -edit -enable false reloadItem;
		menuItem -edit -enable false addToListItem;
	}
}

global proc
defineListMenu (string $options, string $editor, string $animEditor,
				string $parentMenu, string $buildMenuCommand)
//
//	Procedure Name:
//		defineListMenu
//
//	Description:
//		This creates the submenu for list functionality
//
//	Example:
//		Create a menu that this submenu is to be attached to
//	(make sure that the menu is defined to allow option boxes)
//
//		menuItem -label _L10N( kList, "List" ) 
//			-allowOptionBoxes true
//			-subMenu true
//			optionsHierItem;
//			defineListMenu $editor $animEditor "optionsHierItem"; 
//			{further menu items could be defined here}
//		setParent -m ..;
//
//  Input Arguments:
//		string $editor			The name of the editor that this submenu
//								is being attached to
//		string $parentMenu		The name of the parent menu that this
//								submenu is being attached to
//		string $options			Options for this menu
//								Option words are specified within the
//								the string, with each option seperated
//								by a space (e.g. "noScroll otherOption")
//
//			Current options:
//				noOptions		A nice "do nothing" string to pass
//				useHier			Add a "Hierarchy Below" entry
//				useCharacters	Add support for characters
//				useSUC			Add a "Show upstream curves" entry
//
//  Return Value:
//      None.
//
{
	setParent -menu $parentMenu;
	menu -edit
		-postMenuCommand ("handleListMenuCmd " + $options + " " + $editor + " " + $animEditor + " " + $parentMenu + "\"" + $buildMenuCommand + "\"")
		$parentMenu;
}

global proc
doKeyTangent (string $commandOptions, string $selectionConnection, string $options)
//
//  Procedure Name:
//      doKeyTangent
//
//  Description:
//		This is a helper proc which will issue the proper form of the
//		keyTangent command, depending upon whether or not keys are active.
//
//  Input Arguments:
//		string $commandOptions			Options to be passed to the keyTangent
//										command
//		string $selectionConnection		The name of the selection connection
//										that contains potential objects to
//										perform the keyTangent command upon
//		string $options					Options for this proc
//										Option words are specified within the
//										the string, with each option seperated
//										by a space (e.g. "bufferCurve otherOption")
//			Current options:
//				noOptions				A nice "do nothing" string to pass
//				bufferCurve				Issue commands to (possibly) create buffer curves
//
//  Return Value:
//      None.
//
{
	// Build up the command string
	//
	string $command = ("keyTangent " + $commandOptions);

	string $realConnection = $selectionConnection;

	// Check for the bufferCurve option
	//
	if (match ("bufferCurve", $options) == "bufferCurve") {
		$realConnection = `editor -query -mainListConnection $selectionConnection`;
		// Check to see if we need to create buffer curves
		//
		if (`animCurveEditor -query -showBufferCurves $selectionConnection` == "on") {
			$command = "bufferCurve -animation \"keys\" -overwrite false; " + $command;
		}
	}

	// Check to see if any keys are selected
	//
	int $keys = 0;
	if (!`isTrue SomethingSelected`
	||	catch ($keys = `keyframe -animation keys -query -keyframeCount`)) {
		$keys = 0;
	}
	if ($keys == 0) {
		// No keys, so use the selection connection
		//
		$command = ($command + " -animation objects " + $realConnection);
	}
	// Now issue the command
	//
	catch( evalEcho ($command) );
	
	// Update tangent iconTextCheckBoxes
	doUpdateTangentFeedback( );
}

global proc
doKeyEdit (string $commandOptions, string $selectionConnection, string $options)
//
//  Procedure Name:
//      doKeyEdit
//
//  Description:
//		This is a helper proc which will issue the proper form of the
//		keyframe command, depending upon whether or not keys are active.
//
//  Input Arguments:
//		string $commandOptions			Options to be passed to the keyTangent
//										command
//		string $selectionConnection		The name of the selection connection
//										that contains potential objects to
//										perform the keyTangent command upon
//		string $options				Options for this proc
//										Option words are specified within the
//										the string, with each option seperated
//										by a space (e.g. "bufferCurve otherOption")
//			Current options:
//				noOptions				A nice "do nothing" string to pass
//				bufferCurve				Issue commands to (possibly) create buffer curves
//				addInbetween			Create options to add an inbetween at the current time
//				removeInbetween			Create options to remove an inbetween at the current time
//
//  Return Value:
//      None.
//
{
	// Build up the command string
	//
	string $command = ("keyframe " + $commandOptions);

	int $checkKeys = true;
	// Check for the inbetweens
	//
	if (match ("addInbetween", $options) == "addInbetween") {
		$command = $command + " -time \"" + `currentTime -query` + ":\" " +
			"-relative -timeChange 1 -option over";
		$checkKeys = false;
	}
	else if (match ("removeInbetween", $options) == "removeInbetween") {
		$command = $command + " -time \"" + `currentTime -query` + ":\" " +
			"-relative -timeChange -1 -option over";
		$checkKeys = false;
	}

	string $realConnection = $selectionConnection;

	// Check for the bufferCurve option
	//
	if (match ("bufferCurve", $options) == "bufferCurve") {
		$realConnection = `editor -query -mainListConnection $selectionConnection`;
		// Check to see if we need to create buffer curves
		//
		if (`animCurveEditor -query -showBufferCurves $selectionConnection` == "on") {
			$command = "bufferCurve -animation \"keys\" -overwrite false; " + $command;
		}
	}

	// Check to see if any keys are selected
	//
	int $keys = 0;
	if ($checkKeys && (!`isTrue SomethingSelected`
	||	catch ($keys = `keyframe -animation keys -query -keyframeCount`))) {
		$keys = 0;
	}
	if ($keys == 0) {
		// No keys, so use the selection connection
		//
		$command = ($command + " -animation objects " + $realConnection);
	}
	// Now issue the command
	//
	evalEcho ($command);
}


global proc
int looksLikeAttr(string $nodeAttr)
//
//  Procedure Name:
//      looksLikeAttr
//
//  Description:
//      A convenience method to test if nodeAttr represents an attribute
//  written in the node.Attr format.
{
	int $result = 0;
	string $tokens[];
	tokenize($nodeAttr,".",$tokens);
	if(size($tokens) > 1) 
	{
		$result = 1;
	}
	return $result;
}


global proc string getAnimAttr(string $selectedItem)
//
//  Procedure Name:
//      getAnimAttr
//
//  Description:
//		This is a helper proc to get proper attribute from animCurve node
//
{
	if(looksLikeAttr($selectedItem))
		return $selectedItem;

	string $attr = $selectedItem;
	string $connectedNodes[] = `listConnections -source false $selectedItem`;

	if (size($connectedNodes) > 0) {
		string $objectType = `objectType $connectedNodes[0]`;
		string $characterNode;
		string $sattr;

		switch ($objectType){

			// Simple Anim
			case "transform":
				$connectedNodes = `listConnections -source false -plugs true $selectedItem`;
				$attr = $connectedNodes[0];
				break;

				// Simple and Muted
			case "mute":
				string $connectedNodes2[] = `listConnections -source false -type transform -plugs true $connectedNodes[0]`;
				if (size($connectedNodes2) > 0) 
				{
					$attr = $connectedNodes2[0];
				}
				else
				{
					$connectedNodes2 = `listConnections -source false -type animBlendNodeBase -plugs true $connectedNodes[0]`;
					$attr = $connectedNodes2[0];
				}
				break;

				// The attribute belongs to a character
			case "character":
				$characterNode = $connectedNodes[0];
				$connectedNodes = `listConnections -source false -plugs true $selectedItem`;
				int $mindex = `character -q -memberIndex $connectedNodes[0]`;
				$sattr = $characterNode + ".dnSetMembers[" + $mindex + "]";
				$connectedNodes = `listConnections -destination false -plugs true $sattr`;
				$attr = $connectedNodes[0];
				break;

				// The attribute belongs to a character and instanced to a clip
			case "clipLibrary":
				// Get character node
				$connectedNodes = `listConnections -destination false -type character $connectedNodes[0]`;
				$characterNode =  $connectedNodes[0];

				// Get character member index
				$connectedNodes = `listConnections -source false -plugs true $selectedItem`;
				string $strs[];
				tokenize($connectedNodes[0], ".", $strs);
				int $ssize = size($strs[2]);
				// clipEval index
				string $cindex = substring($strs[2], 10, $ssize-1);
				$sattr = $characterNode + ".dnSetMembers[" + $cindex + "]";

				$connectedNodes = `listConnections -destination false -plugs true $sattr`;
				$attr = $connectedNodes[0];
				break;
			default:
				$connectedNodes = `listConnections -source false -plugs true $selectedItem`;
				$attr = $connectedNodes[0];
		}
	}

	return $attr;
}

global proc
int isChannelFromClip(string $channel)
{
	int $result = 0;
	string $buffer[];
	tokenize($channel,".",$buffer);
	if (nodeType($buffer[0]) == "clipLibrary") {
		$result = 1;
	}
	return $result;
}


global proc
doTemplateChannel(string $selectionConnection, int $newState)
{
	string $command;
	int $result = 0;    

	string $membersArray[] = `keyframe -query -sl -name`;

	if (size($membersArray) == 0)
	{
		string $selConn[] = expandSelectionConnectionAsArray($selectionConnection);
		for ($sel in $selConn) {
			string $isPC[] = `ls -type animCurve $sel`;
			if (size($isPC)) {
				$membersArray[size($membersArray)] = $sel;
			} else {
				string $pc[] = `listConnections -type animCurve $sel`;
				if (size($pc) == 1) {
					$membersArray[size($membersArray)] = $pc[0];
				}
			}
		}
	}

	for ($m in $membersArray) {
		setAttr -l $newState ($m+".ktv");
	}

	if (size($membersArray) == 0)
	{
		error( (uiRes("m_loadAnimMenuLibrary.kNoChannelsSelected")));
	}
}

global proc
doPinChannel( string $editor, string $selectionConnection, int $newState )
{
	string $selConn[] = expandSelectionConnectionAsArray( $selectionConnection );
	if ( size( $selConn ) == 0 )
	{
		error( (uiRes("m_loadAnimMenuLibrary.kPinNoChannelsSelected")) );
	}
	else
	{
		if ( $newState )
		{
			// pin
			for ( $sel in $selConn )
			{
				outlinerEditor -e -pin $sel $editor;
			}
		}
		else
		{
			// unpin
			for ( $sel in $selConn )
			{
				outlinerEditor -e -unp $sel $editor;
			}
		}
	}
}

global proc
doMuteChannel (string $selectionConnection, string $flag)
//
//  Procedure Name:
//     doMuteChannel 
//
//  Description:
//		This is a helper proc which will issue the proper form of the
//		mute command, depending upon whether or not channels are selected

{
	string $command;
	int $result = 0;    

	string $membersArray[] = `keyframe -query -sl -name`;

	if (size($membersArray) == 0)
	{
		$membersArray = expandSelectionConnectionAsArray($selectionConnection);
	}

	if ($flag == "-true") {
		for ($m in $membersArray)
		{	
			// don't mute mute
			if (match("mute", $m) == ""){

				$mm = getAnimAttr($m);
				string $muted[] = `mute  $mm`;
				for ($mute in $muted) {
					//if we get a mute channel set the first and last keys to be on
					$result = 1;
					// set the begin and end keys.
					int   $lastkey = `keyframe -q -kc $m` - 1;
					if ($lastkey >= 0) {
						float $start[] = `keyframe -index 0 -q -tc $m`;
						float $end[] = `keyframe -index $lastkey -q -tc $m`;
						$command = "cutKey -index \"0:" + $lastkey + "\" "+ $muted[0];
						eval($command);
						float $playstart = `playbackOptions -q -min`;
						float $playend   = `playbackOptions -q -max`;
						
						setKeyframe -time  $playstart -value 1 $mute ;
						setKeyframe -time  $playend -value 1 $mute ;
					}
				}

			}
		}
	}
	else 
	{

		for ($m in $membersArray)
		{

			if (match("mute", $m) == ""){
				//get the mute channel
				string $chan = getAnimAttr($m);
				string $chans[] = `listConnections -type mute $chan`;

				for ($c in $chans) {
					if ($c != "")
					{
						// get the keys of the mute channel
						int $keys = `keyframe -q -kc $chan`;
						if ($keys >= 0) {
							//remove all the keys
							$command = "cutKey -index \"0:" + $keys + "\" "+ $c;
							eval($command);
							
							$m = getAnimAttr($m);
							mute -disable $m;
							$result = 1;
						}
					}
				}
			}
		}
	}   

	if ($result == 0)
	{
		string $errMsg;
		if ($flag == "-true") {
			$errMsg = (uiRes("m_loadAnimMenuLibrary.kNoChannelToMute"));
		}
		else {
			$errMsg = (uiRes("m_loadAnimMenuLibrary.kNoChannelToUnmute"));
		}
		error($errMsg);
	}
}

global proc
doMuteRegion(string $channel, string $flag, float $start, float $end)
//
//  Procedure Name:
//     doMuteRegion
//
//  Description:
//		This is a helper proc which will issue the proper form of the
//		mute command, depending upon which keys are selected

{

	int $value;
	int $result = 0;

	if ($flag == "-true") 
		$value = 1;
	else
		$value = 0;

	string $chan = getAnimAttr($channel);
	if ($chan == "") {
		$chan = $channel;
	}
	

	// skip mute channels. Don't want to mute mute channels
	if (match("mute", $chan) == "")
	{
		// create a mute channel or get it if it exits.
		string $muted[] = `mute $chan`;    

		for ($mute in $muted) {
			//test to see if this mute channel has keys

			float $mkeys[] = `keyframe -q -tc $mute`;

			float $endvalue[] = `keyframe -absolute -time ($end -1) -q -eval ($mute + ".mute")`;

			// We don't have any values keyed yet
			if (size($mkeys)!= 0) {
				string $range = "\"" + $start + ":" + $end + "\"";
				string $cmd = ("cutKey -time "+ $range +" -option keys " + $mute + ".mute");
				eval($cmd);
			}

			int $inverse = (1 - $value );
			float $playstart = `playbackOptions -q -min`;
			float $playend   = `playbackOptions -q -max`;

			int  $nbkeys = `keyframe -q -kc ($mute + ".mute")`;
			if ($nbkeys == 0) {
				// set the begin and end keys.
				setKeyframe -time $playstart -value 0 $mute;
				setKeyframe -time $playend -value 0 $mute;
			}

			// Move just abit along the curve (in case there is a key right on the
			// spot and get the reading
			float $keyvalue[] = `keyframe -absolute -time ($start +.001) -q -eval ($mute + ".mute")`;

			// Since the number is float it could be edited away from
			// 0 and 1 value.  Let it round to the neareast value.  This
			// matches up with stipple drawing in the graph editor and 
			// other places.
			if ($endvalue[0] > 0.5){
				$endvalue[0] = 1.0; 
			}
			else {
				$endvalue[0] = 0.0;
			}
			if ($keyvalue[0] > 0.5){
				$keyvalue[0] = 1.0; 
			}
			else {
				$keyvalue[0] = 0.0;
			}

			// Check if we need to add a new starting key.
			if ($keyvalue[0] != $value) {
				setKeyframe -time $start -value $value $mute;
				if ($endvalue[0] != $value) {
					// We want to mute the selected ticks but not the
					// effect the key at the end value. So move it back almost
					// a full key. This is currently composented for in the 
					// drawing routine.
					setKeyframe -time $end -value $inverse $mute;
				}
			}
			// Check if we need to an ending key
			else if ($keyvalue[0] != $endvalue[0] ) {
				setKeyframe -time $end -value $inverse $mute;
			}

		}
	}
}

global proc
doMuteKey (string $flag)
//
//  Procedure Name:
//      doMuteKey
//
//  Description:
//		This is a helper proc which will issue the proper form of the
//		mute command, depending upon which keys are selected

{
    string $curves[] = `keyframe -query -sl -name`;
    string $c;
    int $value;
    int $result = 0;
    
    if ($flag == "-true") 
        $value = 1;
    else
        $value = 0;
    
    for( $c in $curves ) {
        // skip mute channels. Don't want to mute mute channels
        if (match("mute", $c) == ""){
            
			string $chan = getAnimAttr($c);
            // create a mute channel or get it if it exits.
            string $muted[] = `mute $chan`;    
            
            //test to see if this mute channel has keys
            float $mkeys[] = `keyframe -q -tc $muted[0]`;
            int   $lastkey = `keyframe -q -kc $c` - 1;
            
            if (size($mkeys) == 0)
            {
                int $inverse = (1 - $value );
                
                // set the begin and end keys.             
                float $start[] = `keyframe -index 0 -q -tc $c`;
                float $end[] = `keyframe -index $lastkey -q -tc $c`;
                setKeyframe -time $start[0] -value 0 $muted[0] ;
                setKeyframe -time $end[0] -value 0 $muted[0] ;                        
            }
            
            // get the time of the keys
            int $keys[] = `keyframe -sl -q -iv $c`;
            int $index, $i;
			$lastkey = `keyframe -q -kc $c`;
            for ($i = 0; $i < size($keys); ++$i ){
                // set the key and mark it dirty to get let the 
                // graph editor pick up it.
				$index = $keys[$i];
				float $t[] = `keyframe -index $index -q $c`;
                setKeyframe -time ($t[0] - 0.0001) -value $value $muted[0] ;
				$result = 1; 
				
				// if the next is not selected 
				if ($value == 1)
				{
					if ( ($i < (size($keys) - 1) && $keys[$i + 1] != ($index + 1) )
						|| ( $i == (size($keys) - 1) &&  $index != $lastkey) ) 
					{
						float $tt[] = `keyframe -index ($index + 1) -q $c`;
						// test to see if the key is already off.
						float $va[] = `keyframe -time $tt[0] -q -eval $muted[0]`;
						if ($va[0] > 0.0)
							setKeyframe -time $tt[0] -value 0 $muted[0] ;
					}	
				}
			}
        }
    }
    
    if ($result == 0)
    {
    	string $errMsg;
    	if (size($curves) == 0) {
			$errMsg = (uiRes("m_loadAnimMenuLibrary.kNoObjectToMute"));
    	}
    	else {
			$errMsg = (uiRes("m_loadAnimMenuLibrary.kNoObjectToUnmute"));
    	}
		error($errMsg);    
    }
}




global proc
doSetInfinity (string $commandOptions, string $selectionConnection, string $options)
//
//  Procedure Name:
//      doSetInfinity
//
//  Description:
//		This is a helper proc which will issue the proper form of the
//		setInfinity command, depending upon whether or not keys are active.
//
//  Input Arguments:
//		string $commandOptions			Options to be passed to the setInfinity
//										command
//		string $selectionConnection		The name of the selection connection
//										that contains potential objects to
//										perform the setInfinity command upon
//		string $options					Options for this proc
//										Option words are specified within the
//										the string, with each option seperated
//										by a space (e.g. "bufferCurve otherOption")
//			Current options:
//				noOptions				A nice "do nothing" string to pass
//				bufferCurve				Issue commands to (possibly) create buffer curves
//
//  Return Value:
//      None.
//
{
	// Build up the command string
	//
	string $command = ("setInfinity " + $commandOptions);

	string $realConnection = $selectionConnection;

	// Check for the bufferCurve option
	//
	if (match ("bufferCurve", $options) == "bufferCurve") {
		$realConnection = `editor -query -mainListConnection $selectionConnection`;
		// Check to see if we need to create buffer curves
		//
		if (`animCurveEditor -query -showBufferCurves $selectionConnection` == "on") {
			$command = "bufferCurve -animation \"keys\" -overwrite false; " + $command;
		}
	}

	// Check to see if any keys are selected
	//
	int $keys = 0;
	if (!`isTrue SomethingSelected`
	||	catch ($keys = `keyframe -animation keys -query -keyframeCount`)) {
		$keys = 0;
	}
	if ($keys == 0) {
		// No keys, so use the selection connection
		//
		$command = ($command + " " + $realConnection);
	}
	// Now issue the command
	//
	evalEcho ($command);
}

global proc
buildInOutTangentsMenu(string $selectionConnection,string $options)
{
	global string $gTangentInPluginItemList[];
	string $plugins[] = `keyTangent -q -ptt`;
	string $plugin;
	string $pluginBtn;

	menuItem -label (uiRes("m_loadAnimMenuLibrary.kInTangent"))  -subMenu true -to true inTanHierItem;
		menuItem -label `uiRes( "m_loadAnimMenuLibrary.kAuto" )`
			-annotation `uiRes( "m_loadAnimMenuLibrary.kAutoAnnot" )`
			-command ("doKeyTangent \"-e -itt auto\" " + $selectionConnection + " " + "\"" + $options + "\"");
		menuItem -label `uiRes( "m_loadAnimMenuLibrary.kSpline" )`
			-annotation  `uiRes( "m_loadAnimMenuLibrary.kSplineAnnot" )`
			-command ("doKeyTangent \"-e -itt spline\" " + $selectionConnection + " " + "\"" + $options + "\"");
		menuItem -label `uiRes( "m_loadAnimMenuLibrary.kLinear" )`
			-annotation `uiRes( "m_loadAnimMenuLibrary.kLinearAnnot" )`
			-command ("doKeyTangent \"-e -itt linear\" " + $selectionConnection + " " + "\"" + $options + "\"");
		menuItem -label `uiRes( "m_loadAnimMenuLibrary.kClamped" )`
			-annotation `uiRes( "m_loadAnimMenuLibrary.kClampedAnnot" )`
			-command ("doKeyTangent \"-e -itt clamped\" " + $selectionConnection + " " + "\"" + $options + "\"");
		menuItem -label `uiRes( "m_loadAnimMenuLibrary.kFlat" )`
			-annotation  `uiRes( "m_loadAnimMenuLibrary.kFlatAnnot" )`
			-command ("doKeyTangent \"-e -itt flat\" " + $selectionConnection + " " + "\"" + $options + "\"");
		menuItem -label `uiRes( "m_loadAnimMenuLibrary.kFixed" )`
			-annotation `uiRes( "m_loadAnimMenuLibrary.kFixedAnnot" )`
			-command ("doKeyTangent \"-e -itt fixed\" " + $selectionConnection + " " + "\"" + $options + "\"");
		menuItem -label `uiRes( "m_loadAnimMenuLibrary.kPlateau" )`
			-annotation `uiRes( "m_loadAnimMenuLibrary.kPlateauAnnot" )`
			-command ("doKeyTangent \"-e -itt plateau\" " + $selectionConnection + " " + "\"" + $options + "\"");

		// Add menu items for the tangent plugins.
		for ($plugin in $plugins)
		{
			$pluginBtn = `menuItem -label $plugin
				-annotation (uiRes("m_loadAnimMenuLibrary.kPluginAnnot2")) 
				-command ("doKeyTangent \"-e -itt " + $plugin + "\" " + $selectionConnection + " " + "\"" + $options + "\"")`;
			$gTangentInPluginItemList[size($gTangentInPluginItemList)] = $pluginBtn;	
		}
			
	setParent -m ..;

	menuItem -label (uiRes("m_loadAnimMenuLibrary.kChangeMe"))  -subMenu true -to true outTanHierItem;
		menuItem -label `uiRes( "m_loadAnimMenuLibrary.kAuto" )`
			-annotation `uiRes( "m_loadAnimMenuLibrary.kAutoAnnot" )`
			-command ("doKeyTangent \"-e -ott Auto\" " + $selectionConnection + " " + "\"" + $options + "\"");
		menuItem -label `uiRes( "m_loadAnimMenuLibrary.kSpline" )`
			-annotation  `uiRes( "m_loadAnimMenuLibrary.kSplineAnnot" )`
			-command ("doKeyTangent \"-e -ott spline\" " + $selectionConnection + " " + "\"" + $options + "\"");
		menuItem -label `uiRes( "m_loadAnimMenuLibrary.kLinear" )`
			-annotation `uiRes( "m_loadAnimMenuLibrary.kLinearAnnot" )`
			-command ("doKeyTangent \"-e -ott linear\" " + $selectionConnection + " " + "\"" + $options + "\"");
		menuItem -label `uiRes( "m_loadAnimMenuLibrary.kClamped" )`
			-annotation `uiRes( "m_loadAnimMenuLibrary.kClampedAnnot" )`
			-command ("doKeyTangent \"-e -ott clamped\" " + $selectionConnection + " " + "\"" + $options + "\"");
		menuItem -label `uiRes( "m_loadAnimMenuLibrary.kFlat" )`
			-annotation  `uiRes( "m_loadAnimMenuLibrary.kFlatAnnot" )`
			-command ("doKeyTangent \"-e -ott flat\" " + $selectionConnection + " " + "\"" + $options + "\"");
		menuItem -label `uiRes( "m_loadAnimMenuLibrary.kFixed" )`
			-annotation `uiRes( "m_loadAnimMenuLibrary.kFixedAnnot" )`
			-command ("doKeyTangent \"-e -ott fixed\" " + $selectionConnection + " " + "\"" + $options + "\"");
		menuItem -label `uiRes( "m_loadAnimMenuLibrary.kPlateau" )`
			-annotation `uiRes( "m_loadAnimMenuLibrary.kPlateauAnnot" )`
			-command ("doKeyTangent \"-e -ott plateau\" " + $selectionConnection + " " + "\"" + $options + "\"");

		// Add menu items for the tangent plugins.
		for ($plugin in $plugins)
		{
			$pluginBtn = `menuItem -label $plugin
				-annotation (uiRes("m_loadAnimMenuLibrary.kPluginAnnot3")) 
				-command ("doKeyTangent \"-e -itt " + $plugin + "\" " + $selectionConnection + " " + "\"" + $options + "\"")`;
			$gTangentInPluginItemList[size($gTangentInPluginItemList)] = $pluginBtn;	
		}

	setParent -m ..;
	
	menuItem -divider true;	
}

global proc
buildTangentsMenu (string $editor, string $animEditor, string $parentMenu, string $options, string $buildMenuCommand) 
//
//  Procedure Name:
//      buildGraphEdTangentsMenu
//
//  Description:
//		Creates the menu entries that control
//		tangent settings in the graph editor.
//
//  Input Arguments:
//		string $options			Options for this proc
//								Option words are specified within the
//								the string, with each option seperated
//								by a space (e.g. "bufferCurve otherOption")
//			Current options:
//				noOptions		A nice "do nothing" string to pass
//				bufferCurve		Issue commands to (possibly) create buffer curves
//				noBreakUnify	Do not show the break and unify tangent menus
//
//  Return Value:
//      None.
//
{
	global string $gTangentParentEditor;
	global string $gTangentAnimEditor;
	global string $gTangentParentMenu;
	global string $gTangentInParentMenu;
	global string $gTangentOutParentMenu;
	global string $gTangentMenuOptions;
	global string $gTangentPluginItemList[];
	global string $gTangentInPluginItemList[];
	global string $gTangentOutPluginItemList[];
	$gTangentParentEditor = $editor;
	$gTangentAnimEditor = $animEditor;
	$gTangentParentMenu = $parentMenu;
	$gTangentMenuOptions = $options;

	setParent -menu $parentMenu;
	if (`menu -query -numberOfItems $parentMenu` != 0) {
		return;
	}

	string $selectionConnection = `editor -query -selectionConnection $editor`;

	// Check for the bufferCurve option
	//
	if (match ("bufferCurve", $options) == "bufferCurve") {
		$selectionConnection = $animEditor;
	}

	string $plugins[] = `keyTangent -q -ptt`;

	menuItem -label (uiRes("m_loadAnimMenuLibrary.kAuto")) 
		-annotation (uiRes("m_loadAnimMenuLibrary.kAutoAnnot"))
		-command ("doKeyTangent \"-e -itt auto -ott auto\" " + $selectionConnection + " " + "\"" + $options + "\"");
	menuItem -label (uiRes("m_loadAnimMenuLibrary.kSpline")) 
		-annotation (uiRes("m_loadAnimMenuLibrary.kSplineAnnot")) 
		-command ("doKeyTangent \"-e -itt spline -ott spline\" " + $selectionConnection + " " + "\"" + $options + "\"");
	menuItem -label (uiRes("m_loadAnimMenuLibrary.kLinear")) 
		-annotation (uiRes("m_loadAnimMenuLibrary.kLinearAnnot"))
		-command ("doKeyTangent \"-e -itt linear -ott linear\" " + $selectionConnection + " " + "\"" + $options + "\"");
	menuItem -label (uiRes("m_loadAnimMenuLibrary.kClamped")) 
		-annotation (uiRes("m_loadAnimMenuLibrary.kClampedAnnot"))
		-command ("doKeyTangent \"-e -itt clamped -ott clamped\" " + $selectionConnection + " " + "\"" + $options + "\"");
	menuItem -label (uiRes("m_loadAnimMenuLibrary.kStepped")) 
		-annotation (uiRes("m_loadAnimMenuLibrary.kSteppedAnnot"))
		-command ("doKeyTangent \"-e -ott step\" " + $selectionConnection + " " + "\"" + $options + "\"");
	menuItem -label (uiRes("m_loadAnimMenuLibrary.kSteppedNext")) 
		-annotation (uiRes("m_loadAnimMenuLibrary.kSteppedNextAnnot"))
		-command ("doKeyTangent \"-e -ott stepnext\" " + $selectionConnection + " " + "\"" + $options + "\"");
	menuItem -label (uiRes("m_loadAnimMenuLibrary.kFlat")) 
		-annotation (uiRes("m_loadAnimMenuLibrary.kFlatAnnot"))
		-command ("doKeyTangent \"-e -itt flat -ott flat\" " + $selectionConnection + " " + "\"" + $options + "\"");
	menuItem -label (uiRes("m_loadAnimMenuLibrary.kFixed")) 
		-annotation (uiRes("m_loadAnimMenuLibrary.kFixedAnnot"))
		-command ("doKeyTangent \"-e -itt fixed -ott fixed\" " + $selectionConnection + " " + "\"" + $options + "\"");
	menuItem -label (uiRes("m_loadAnimMenuLibrary.kPlateau")) 
		-annotation (uiRes("m_loadAnimMenuLibrary.kPlateauAnnot"))
		-command ("doKeyTangent \"-e -itt plateau -ott plateau\" " + $selectionConnection + " " + "\"" + $options + "\"");

	// Add buttons for the tangent plugins.
	string $plugin;
	string $pluginBtn;
	for ($plugin in $plugins)
	{
		$pluginBtn = `menuItem -label $plugin
			-annotation (uiRes("m_loadAnimMenuLibrary.kPluginAnnot1")) 
			-command ("doKeyTangent \"-e -itt " + $plugin + " -ott " + $plugin + "\" " + $selectionConnection + " " + "\"" + $options + "\"")`;
		$gTangentPluginItemList[size($gTangentPluginItemList)] = $pluginBtn;	
	}

	menuItem -divider true;

	buildInOutTangentsMenu($selectionConnection,$options);

	// Check for the "noBreakUnify" option
	//
	if (match ("noBreakUnify", $options) != "noBreakUnify") {
		menuItem -label (uiRes("m_loadAnimMenuLibrary.kBreakTangents")) 
			-annotation (uiRes("m_loadAnimMenuLibrary.kBreakTangentsAnnot")) 
			-command ("doKeyTangent \"-lock off\" " + $selectionConnection + " noOptions")
			breakTanItem;
		menuItem -label (uiRes("m_loadAnimMenuLibrary.kUnifyTangents")) 
			-annotation (uiRes("m_loadAnimMenuLibrary.kUnifyTangentsAnnot")) 
			-command ("doKeyTangent \"-lock on\" " + $selectionConnection + " noOptions")
			unifyTanItem;
		menuItem -divider true;
	}

	menuItem -label (uiRes("m_loadAnimMenuLibrary.kLockTangentWeight")) 
		-annotation (uiRes("m_loadAnimMenuLibrary.kLockTangentWeightAnnot")) 
		-command ("doKeyTangent \"-weightLock on\" " + $selectionConnection + " noOptions")
		tanWeightLockItem;
	menuItem -label (uiRes("m_loadAnimMenuLibrary.kFreeTangentWeight")) 
		-annotation (uiRes("m_loadAnimMenuLibrary.kFreeTangentWeightAnnot")) 
		-command ("doKeyTangent \"-weightLock off\" " + $selectionConnection + " noOptions")
		tanWeightFreeItem;

	if ($buildMenuCommand != "") {
		eval (($buildMenuCommand + " " + $editor + " " + $animEditor + " " + $parentMenu));
	}
}

global proc
defineTangentsMenu (string $editor, string $animEditor, string $parentMenu, string $options, string $buildMenuCommand)
//
//	Procedure Name:
//		defineTangentsMenu
//
//	Description:
//		This creates the submenu for tangent setting functionality
//
//	Example:
//		Create a menu that this submenu is to be attached to
//
//		menuItem -label _L10N( kTangents, "Tangents" ) 
//			-allowOptionBoxes false
//			-subMenu true
//			tangentsHierItem;
//			defineTangentsMenu $editor $animEditor "tangentsHierItem"; 
//			{further menu items could be defined here}
//		setParent -m ..;
//
//  Input Arguments:
//		string $editor			The name of the editor that this submenu
//								is being attached to
//		string $parentMenu		The name of the parent menu that this
//								submenu is being attached to
//		string $options			Options for this proc
//								Option words are specified within the
//								the string, with each option seperated
//								by a space (e.g. "bufferCurve otherOption")
//			Current options:
//				noOptions		A nice "do nothing" string to pass
//				bufferCurve		Issue commands to (possibly) create buffer curves
//				noBreakUnify	Do not show the break and unify tangent menus
//
//  Return Value:
//      None.
//
{

	setParent -menu $parentMenu;
	menu -edit
		-postMenuCommand ("buildTangentsMenu " + $editor + " " + $animEditor + " " + $parentMenu + "\"" + $options + "\"" + " " + "\"" + $buildMenuCommand + "\"")
		$parentMenu;

}

global proc
updateTangentsMenu (string $plugin, int $isAdded) 
//
//  Procedure Name:
//      updateTangentsMenu
//
//  Description:
//		Updates the tangents menu in response to tangent plugins being added or removed.
//
//  Input Arguments:
//		string $plugin			The name of the tangent plugin being added or removed.
//		int	   $isAdded			Set to true if the plugin has been added.
//
//  Return Value:
//      None.
//
{
	global string $gTangentParentEditor;
	global string $gTangentAnimEditor;
	global string $gTangentParentMenu;
	global string $gTangentInParentMenu;
	global string $gTangentOutParentMenu;
	global string $gTangentMenuOptions;
	global string $gTangentPluginItemList[];
	global string $gTangentInPluginItemList[];
	global string $gTangentOutPluginItemList[];

	// If the editor has not been built yet, do nothing.
	if ($gTangentParentEditor == "")
		return;

	string $selConnection = `editor -query -selectionConnection $gTangentParentEditor`;
	// Check for the bufferCurve option
	//
	if (match ("bufferCurve", $gTangentMenuOptions) == "bufferCurve") {
		$selConnection = $gTangentAnimEditor;
	}

	// Update each tangent menu.
	setParent -menu $gTangentParentMenu;
	doUpdateTangentsMenu($plugin, $isAdded, $gTangentPluginItemList, $selConnection);
	setParent -menu $gTangentInParentMenu;
	doUpdateTangentsMenu($plugin, $isAdded, $gTangentInPluginItemList, $selConnection);
	setParent -menu $gTangentOutParentMenu;
	doUpdateTangentsMenu($plugin, $isAdded, $gTangentOutPluginItemList, $selConnection);
}

proc
doUpdateTangentsMenu (string $plugin, int $isAdded, string $itemList[],
					  string $selConnection) 
//
//  Procedure Name:
//      doUpdateTangentsMenu
//
//  Description:
//		Do the work of updating the given tangent menu.
//
//  Input Arguments:
//		string $plugin			The name of the tangent plugin being added or removed.
//		int	   $isAdded			Set to true if the plugin has been added.
//		string $itemList[]		The tangent menu to update.
//		string $selConnection	The selection connection to use when creating new items.
//
//  Return Value:
//      None.
//
{
	global string $gTangentMenuOptions;

	// Look for the plugin in the tangents menu.  If found, enable/disable it.
	// If not found, add it.
	string $item;
	for ($item in $itemList)
	{
		string $pluginLabel = `menuItem -q -label $item`;
		if ($pluginLabel == $plugin)
		{
			menuItem -e -enable $isAdded;
			return;
		}
	}

	// Add a new menu item if necessary.
	if ($isAdded == true)
	{
		string $pluginItem = `menuItem -label $plugin
			-annotation (uiRes("m_loadAnimMenuLibrary.kPluginAnnot4")) 
			-command ("doKeyTangent \"-e -itt " + $plugin + " -ott " + $plugin + "\" " + $selConnection + " " + "\"" + $gTangentMenuOptions + "\"")`;
		$itemList[size($itemList)] = $pluginItem;	
		setParent -m ..;
	}
}

global proc
buildCurvesMenu (string $editor, string $animEditor, string $parentMenu, string $options, string $buildMenuCommand) 
//
//  Procedure Name:
//      buildCurvesMenu
//
//  Description:
//		Creates the menu entries that control
//		curve editing within an animation editor.
//
//  Input Arguments:
//		string $options			Options for this proc
//								Option words are specified within the
//								the string, with each option seperated
//								by a space (e.g. "bufferCurve otherOption")
//			Current options:
//				noOptions		A nice "do nothing" string to pass
//				bufferCurve		Issue commands to (possibly) create buffer curves
//				useSmoothness	Add a "Curve Smoothness" entry
//				usePin			Add "Pin channels" and "Unpin channels" entries
//
//  Return Value:
//      None.
//
{
	setParent -menu $parentMenu;
	if (`menu -query -numberOfItems $parentMenu` != 0) {
		// Update radio button checks for curve smoothness
		//
		if (match ("useSmoothness", $options) == "useSmoothness") {
			string $curveSmoothness = `animCurveEditor -query -smoothness $animEditor`;
			menuItem -edit
				-radioButton ($curveSmoothness == "coarse")
				coarseCurveItem;
			menuItem -edit
				-radioButton ($curveSmoothness == "rough")
				roughCurveItem;
			menuItem -edit
				-radioButton ($curveSmoothness == "medium")
				mediumCurveItem;
			menuItem -edit
				-radioButton ($curveSmoothness == "fine")
				fineCurveItem;
		}

		global string $gUnisolatedCurves[];
		menuItem -edit -cb (size($gUnisolatedCurves) > 0) isolateCurveItem;
		
		return;
	}

	string $selectionConnection = `editor -query -selectionConnection $editor`;
	string $realSelectionConnection = $selectionConnection;

	// Check for the bufferCurve option
	//
	int $performBase = 0;
	if (match ("bufferCurve", $options) == "bufferCurve") {
		$selectionConnection = $animEditor;
		$performBase = 3;
	}

	menuItem -label (uiRes("m_loadAnimMenuLibrary.kPreInfinity"))  -subMenu true -to true preInfinityHierItem;
		menuItem -label (uiRes("m_loadAnimMenuLibrary.kCycle")) 
			-annotation (uiRes("m_loadAnimMenuLibrary.kCycleBeforeAnnot")) 
			-command ("doSetInfinity \"-pri cycle\" " + $selectionConnection + " " + "\"" + $options + "\"");
		menuItem -label (uiRes("m_loadAnimMenuLibrary.kCycleOffset")) 
			-annotation (uiRes("m_loadAnimMenuLibrary.kCycleOffsetBeforeAnnot")) 
			-command ("doSetInfinity \"-pri cycleRelative\" " + $selectionConnection + " " + "\"" + $options + "\"");
		menuItem -label (uiRes("m_loadAnimMenuLibrary.kOscillate")) 
			-annotation (uiRes("m_loadAnimMenuLibrary.kOscillateBeforeAnnot")) 
			-command ("doSetInfinity \"-pri oscillate\" " + $selectionConnection + " " + "\"" + $options + "\"");
		menuItem -label (uiRes("m_loadAnimMenuLibrary.kMakeLinear")) 
			-annotation (uiRes("m_loadAnimMenuLibrary.kMakeLinearBeforeAnnot")) 
			-command ("doSetInfinity \"-pri linear\" " + $selectionConnection + " " + "\"" + $options + "\"");
		menuItem -label (uiRes("m_loadAnimMenuLibrary.kConstant")) 
			-annotation (uiRes("m_loadAnimMenuLibrary.kConstantBeforeAnnot"))
			-command ("doSetInfinity \"-pri constant\" " + $selectionConnection + " " + "\"" + $options + "\"");
	setParent -m ..; 

	menuItem -label (uiRes("m_loadAnimMenuLibrary.kPostInfinity"))  -subMenu true -to true postInfinityHierItem;
		menuItem -label `uiRes( "m_loadAnimMenuLibrary.kCycle" )`
			-annotation (uiRes("m_loadAnimMenuLibrary.kCycleAfterAnnot")) 
			-command ("doSetInfinity \"-poi cycle\" " + $selectionConnection + " " + "\"" + $options + "\"");
		menuItem -label `uiRes( "m_loadAnimMenuLibrary.kCycleOffset" )`
			-annotation (uiRes("m_loadAnimMenuLibrary.kCycleOffsetAfterAnnot")) 
			-command ("doSetInfinity \"-poi cycleRelative\" " + $selectionConnection + " " + "\"" + $options + "\"");
		menuItem -label `uiRes( "m_loadAnimMenuLibrary.kOscillate" )`
			-annotation (uiRes("m_loadAnimMenuLibrary.kOscillateAfterAnnot")) 
			-command ("doSetInfinity \"-poi oscillate\" " + $selectionConnection + " " + "\"" + $options + "\"");
		menuItem -label `uiRes( "m_loadAnimMenuLibrary.kLinear" )`
			-annotation (uiRes("m_loadAnimMenuLibrary.kLinearAfterAnnot"))
			-command ("doSetInfinity \"-poi linear\" " + $selectionConnection + " " + "\"" + $options + "\"");
		menuItem -label `uiRes( "m_loadAnimMenuLibrary.kConstant" )`
			-annotation (uiRes("m_loadAnimMenuLibrary.kConstantAfterAnnot"))
			-command ("doSetInfinity \"-poi constant\" " + $selectionConnection + " " + "\"" + $options + "\"");
	setParent -m ..; 

	menuItem -divider true;

	menuItem -label (uiRes("m_loadAnimMenuLibrary.kIsolateCurve"))
		-cb false
		-annotation (uiRes("m_loadAnimMenuLibrary.kIsolateCurveAnnot"))
		-command ("isolateAnimCurve #1 "+$realSelectionConnection+" "+$animEditor)
		isolateCurveItem;

	if (match ("useSmoothness", $options) == "useSmoothness") {
		menuItem -label (uiRes("m_loadAnimMenuLibrary.kCurveSmoothness"))  -subMenu true -tearOff true curveSmoothHierItem;
			//	Create a collection to keep the rb's in proper
			//	sync (IE: only one on at any one time. )
			//
			radioMenuItemCollection;
			menuItem -label (uiRes("m_loadAnimMenuLibrary.kCoarse")) 
				-radioButton true
				-annotation (uiRes("m_loadAnimMenuLibrary.kCoarseAnnot")) 
				-command ("animCurveEditor -edit -smoothness coarse " + $animEditor) coarseCurveItem;
			menuItem -label (uiRes("m_loadAnimMenuLibrary.kRough")) 
				-radioButton false
				-annotation (uiRes("m_loadAnimMenuLibrary.kRoughAnnot")) 
				-command ("animCurveEditor -edit -smoothness rough " + $animEditor) roughCurveItem;
			menuItem -label (uiRes("m_loadAnimMenuLibrary.kMedium")) 
				-radioButton false
				-annotation (uiRes("m_loadAnimMenuLibrary.kMediumAnnot")) 
				-command ("animCurveEditor -edit -smoothness medium " + $animEditor) mediumCurveItem;
			menuItem -label (uiRes("m_loadAnimMenuLibrary.kFine")) 
				-radioButton false
				-annotation (uiRes("m_loadAnimMenuLibrary.kFineAnnot")) 
				-command ("animCurveEditor -edit -smoothness fine " + $animEditor) fineCurveItem;
		setParent -m ..;
	}

	menuItem -label (uiRes("m_loadAnimMenuLibrary.kBakeChannel")) 
		-annotation (uiRes("m_loadAnimMenuLibrary.kBakeChannelAnnot")) 
		-c ("performBakeResults " + $performBase + " " + $selectionConnection) 
		-dragMenuCommand( "performBakeResults " + ($performBase + 2) + " \"" + 
						  $selectionConnection + "\"")
		bakeResultsItem;
		menuItem -optionBox true 
		-annotation (uiRes("m_loadAnimMenuLibrary.kBakeChannelOptions")) 
		-c ("performBakeResults " + ($performBase + 1) + " " + $selectionConnection) bakeResultsOptionsItem;

	menuItem -label (uiRes("m_loadAnimMenuLibrary.kMuteChannel")) 
		-annotation (uiRes("m_loadAnimMenuLibrary.kMuteChannelAnnot")) 
        -command ("doMuteChannel "+ $realSelectionConnection + " -true")
		muteChannelItem;
	menuItem -label (uiRes("m_loadAnimMenuLibrary.kUnmuteChannel")) 
		-annotation (uiRes("m_loadAnimMenuLibrary.kUnmuteChannelAnnot")) 
        -command ("doMuteChannel "+ $realSelectionConnection + " -false")
        unmuteChannelItem;
        
	menuItem -label (uiRes("m_loadAnimMenuLibrary.kTemplateChannel")) 
		-annotation (uiRes("m_loadAnimMenuLibrary.kTemplateChannelAnnot")) 
        -command ("doTemplateChannel "+ $realSelectionConnection + " 1")
		templateChannelItem;
	menuItem -label (uiRes("m_loadAnimMenuLibrary.kUntemplateChannel")) 
		-annotation (uiRes("m_loadAnimMenuLibrary.kUntemplateChannelAnnot")) 
        -command ("doTemplateChannel "+ $realSelectionConnection + " 0")
        untemplateChannelItem;

	if (match ("usePin", $options) == "usePin") {
		menuItem -label (uiRes("m_loadAnimMenuLibrary.kPinChannel")) 
			-annotation (uiRes("m_loadAnimMenuLibrary.kPinChannelAnnot")) 
	        -command ("doPinChannel " + $editor + " " + $realSelectionConnection + " 1")
			pinChannelItem;
		menuItem -label (uiRes("m_loadAnimMenuLibrary.kUnpinChannel")) 
			-annotation (uiRes("m_loadAnimMenuLibrary.kUnpinChannelAnnot")) 
	        -command ("doPinChannel " + $editor + " " + $realSelectionConnection + " 0")
	        unpinChannelItem;
	}

	menuItem -divider true;

	menuItem -label (uiRes("m_loadAnimMenuLibrary.kChangeRotInterp"))  -subMenu true -tearOff true rotationInterpolationHierItem;
		//
		//	These are not radio buttons because we cannot show the type
		//	of the current selection: there could be many curves currently
		//	selected.
		//
		menuItem -label (uiRes("m_loadAnimMenuLibrary.kIndEuler")) 
			-annotation (uiRes("m_loadAnimMenuLibrary.kIndEulerAnnot")) 
				-c ("performRotationInterpolation none " + $realSelectionConnection);
		menuItem -label (uiRes("m_loadAnimMenuLibrary.kSyncEuler")) 
			-annotation (uiRes("m_loadAnimMenuLibrary.kSyncEulerAnnot")) 
				-c ("performRotationInterpolation euler " + $realSelectionConnection);		
		menuItem -label (uiRes("m_loadAnimMenuLibrary.kSyncQuatSlerp")) 
			-annotation (uiRes("m_loadAnimMenuLibrary.kSyncQuatSlerpAnnot")) 
				-c ("performRotationInterpolation quaternionSlerp " + $realSelectionConnection);
	    menuItem -label (uiRes("m_loadAnimMenuLibrary.kSyncQuatSquad")) 
			-annotation (uiRes("m_loadAnimMenuLibrary.kSyncQuatSquadAnnot")) 
				-c ("performRotationInterpolation quaternionSquad " + $realSelectionConnection);
        menuItem -label (uiRes("m_loadAnimMenuLibrary.kSyncQuat")) 
			-annotation (uiRes("m_loadAnimMenuLibrary.kSyncQuatAnnot")) 
				-c ("performRotationInterpolation quaternion " + $realSelectionConnection);				
	setParent -m ..;
	
	menuItem -label (uiRes("m_loadAnimMenuLibrary.kSimplifyCurve")) 
		-annotation (uiRes("m_loadAnimMenuLibrary.kSimplifyCurveAnnot")) 
		-c ("performSimplify " + $performBase + " " + $selectionConnection) 
		-dragMenuCommand( "performSimplify " + ($performBase + 2) + " \"" + 
						  $selectionConnection + "\"")
		simplifyItem;
	menuItem -optionBox true 
		-annotation (uiRes("m_loadAnimMenuLibrary.kSimplifyCurveOptions")) 
		-c ("performSimplify " + ($performBase + 1) + " " + $selectionConnection) 
		simplifyOptionsItem;

	menuItem -label (uiRes("m_loadAnimMenuLibrary.kEulerFilter")) 
		-annotation (uiRes("m_loadAnimMenuLibrary.kEulerFilterAnnot"))
		-c ("performEulerFilter " + $realSelectionConnection)
		eulerFilterItem;

	menuItem -label (uiRes("m_loadAnimMenuLibrary.kResampleCurve")) 
		-annotation (uiRes("m_loadAnimMenuLibrary.kResampleCurveAnnot"))	
		-c ("performResample " + $performBase + " " + $selectionConnection)
		-dragMenuCommand( "performResample " + ($performBase + 2) + " \"" +
						   $selectionConnection + "\"")
		resampleItem;
	menuItem -optionBox true
		-annotation (uiRes("m_loadAnimMenuLibrary.kResampleCurveOptions")) 
		-c ("performResample " + ($performBase + 1) + " " + $selectionConnection)
		resampleOptionsItem;

	menuItem -label (uiRes("m_loadAnimMenuLibrary.kSpreadsheet")) 
		-annotation (uiRes("m_loadAnimMenuLibrary.kSpreadsheetAnnot")) 
		-command ("OpenAnimSpreadsheet " + $realSelectionConnection)
		spreadSheetItem;

	// Check for the bufferCurve option
	//
	if (match ("bufferCurve", $options) == "bufferCurve") {
		menuItem -label (uiRes("m_loadAnimMenuLibrary.kBufferCurve")) -subMenu true bufferCurveMenuItem;
			//	Create a collection to keep the rb's in proper
			//	sync (IE: only one on at any one time. )
			//
			menuItem -label (uiRes("m_loadAnimMenuLibrary.kBufferCurveSnapshot")) 
				-annotation (uiRes("m_loadAnimMenuLibrary.kBufferCurveSnapshotAnnot")) 
				-command "bufferCurve -animation \"keys\" -overwrite true"
				bufferSnapItem;
			menuItem -label (uiRes("m_loadAnimMenuLibrary.kBufferCurveReference")) 
				-annotation (uiRes("m_loadAnimMenuLibrary.kBufferCurveReferenceAnnot")) 
				-command "bufferCurve -animation \"keys\" -overwrite true -useReferencedCurve"
				bufferReferenceItem;
			setParent -m ..;
		menuItem -label (uiRes("m_loadAnimMenuLibrary.kSwapBufferCurve")) 
			-annotation (uiRes("m_loadAnimMenuLibrary.kSwapBufferCurveAnnot"))
			-command "bufferCurve -animation \"keys\" -swap"
			bufferSwapItem;
	}

	menuItem -divider true;

	menuItem -label (uiRes("m_loadAnimMenuLibrary.kNonWeightTangents")) 
		-annotation (uiRes("m_loadAnimMenuLibrary.kNonWeightTangentsAnnot")) 
		-command ("doKeyTangent \"-edit -weightedTangents false\" " + $selectionConnection + " " + "\"" + $options + "\"");
	menuItem -label (uiRes("m_loadAnimMenuLibrary.kWeightTangents")) 
		-annotation (uiRes("m_loadAnimMenuLibrary.kWeightTangentsAnnot"))
		-command ("doKeyTangent \"-edit -weightedTangents true\" " + $selectionConnection + " " + "\"" + $options + "\"");

	if ($buildMenuCommand != "") {
		eval (($buildMenuCommand + " " + $editor + " " + $animEditor + " " + $parentMenu));
	}
}

global proc
defineCurvesMenu (string $editor, string $animEditor, string $parentMenu, string $options, string $buildMenuCommand)
//
//	Procedure Name:
//		defineCurvesMenu
//
//	Description:
//		This creates the submenu for curve editing functionality
//
//	Example:
//		Create a menu that this submenu is to be attached to
//
//		menuItem -label _L10N( kCurves, "Curves" ) 
//			-allowOptionBoxes false
//			-subMenu true
//			curvesHierItem;
//			defineCurvesMenu $editor $animEditor "curvesHierItem"; 
//			{further menu items could be defined here}
//		setParent -m ..;
//
//  Input Arguments:
//		string $editor			The name of the editor that this submenu
//								is being attached to
//		string $parentMenu		The name of the parent menu that this
//								submenu is being attached to
//		string $options			Options for this proc
//								Option words are specified within the
//								the string, with each option seperated
//								by a space (e.g. "bufferCurve otherOption")
//			Current options:
//				noOptions		A nice "do nothing" string to pass
//				bufferCurve		Issue commands to (possibly) create buffer curves
//
//  Return Value:
//      None.
//
{
	setParent -menu $parentMenu;
	menu -edit
		-postMenuCommand ("buildCurvesMenu " + $editor + " " + $animEditor + " " + $parentMenu + "\"" + $options + "\"" + " " + "\"" + $buildMenuCommand + "\"")
		$parentMenu;
}


global proc
OpenAnimSpreadsheet (string $selectionConnection)
//
//	Procedure Name:
//		OpenAnimSpreadsheet
//
//	Description:
//		This is a helper proc to open the attribute editor for
//		a selected curve (or the first curve if more than one
//		is selected)
//
//  Input Arguments:
//      None.
//
//  Return Value:
//      None.
//
{
	string $animCurves[];

	if (`isTrue SomethingSelected` != 0) {
		catch ($animCurves = `keyframe -an keys -query -name`);
	}
	if (size ($animCurves) == 0) {
		$animCurves = `findAnimCurves $selectionConnection`;
	}

	if (size ($animCurves) > 0) {
		showEditor $animCurves[0];
	}
	else {
		warning (uiRes("m_loadAnimMenuLibrary.kNoKeysSelected"));
	}
}

proc 
string findCommonSelectedKeyTangentInfo( string $queryOpt )
//
//	Procedure Name:
//		findCommonSelectedKeyTangentInfo
//
//	Description:
//		This is a helper procedure to find common tangent 
//      information given a selected keyset.
//
//  Input Arguments:
//      string $queryOpt A queryable flag
//
//  Return Value:
//      string The common tangent information for a selected keyset.
//      If no keys are selected or no common information is found
//      the string return is "-1"
//
{
	// If there are any key frames selected
	//
	if( size( `keyframe -q -sl` ) )
	{
		// Query selected key tangent specified information
		//
		string $info[];
		
		if( $queryOpt == "-itt" || $queryOpt == "-inTangentType" ||
		    $queryOpt == "-ott" || $queryOpt == "-outTangentType" )
		{
			$info = `keyTangent -q $queryOpt`;
		}
		else if( $queryOpt == "-l"  || $queryOpt == "-lock"       ||
				 $queryOpt == "-wl" || $queryOpt == "-weightLock" ||
				 $queryOpt == "-wt" || $queryOpt == "-weightedTangents" )
		{
			int $intInfo[] = `keyTangent -q $queryOpt`;
			
			// FIXME : Is there a better way to do this sort of cast ?
			//
			int $i;
			for( $i = 0; $i < size( $intInfo ); ++$i )
				$info[ $i ] = $intInfo[ $i ];
		}
		else
		{
			float $floatInfo[] = `keyTangent -q $queryOpt`;
			
			// FIXME : Is there a better way to do this sort of cast ?
			//
			int $i;
			for( $i = 0; $i < size( $floatInfo ); ++$i )
				$info[ $i ] = $floatInfo[ $i ];
		}
		
		int $i;
		string $common = $info[ 0 ];
		for( $i = 1; $i < size( $info ); ++$i )
		{
			if( $common != $info[ $i ] )
				return "-1";
		}
		
		return $common;
	}
	
	return "-1";
} 

global proc
doUpdateTangentFeedback( )
//
//  Procedure Name:
//      updateTangentFeedback
//
//  Description:
//      This procedure updates the key tangent iconTextCheckBoxes based on
//      the current keyset selection.  It is called on a paramCurveChanged message
//      found in TgraphEditor class.
//
//  Input Arguments:
//      None
//
//  Return Value:
//      None
//
{
	global string $gGraphEditorTanButtonNames[];
	string $name;

	// Check existence
	//
	for( $name in $gGraphEditorTanButtonNames )
		if( !`iconTextCheckBox -ex $name` )
			return;

	// Reset tangent types
	//
	for( $name in $gGraphEditorTanButtonNames )
		iconTextCheckBox -e -v false $name;

	// Toggle correct in-out tangent types
	//
	string $types[] = { "-itt", "-ott" };
	for ($t in $types)
	{
		string $tmp0 = findCommonSelectedKeyTangentInfo($t);
		if ($tmp0 == "-1" || $tmp0 == "fixed" )
			continue;

		if ( `iconTextCheckBox -q -ex ($tmp0 + "TanButton" )` )
			catchQuiet(`format -s $tmp0 "iconTextCheckBox -e -v true ^sTanButton"`);
	}

	// Toggle correct tangent lock state
	//
	$tmp0 = findCommonSelectedKeyTangentInfo( "-l" );
	if( $tmp0 != "-1" )
	{
		int $i = ( $tmp0 == "0" ) ? 7 : 8;
		iconTextCheckBox -e -v true $gGraphEditorTanButtonNames[ $i ];
	}

	// Toggle correct tangent weight lock state
	//
	$tmp0 = findCommonSelectedKeyTangentInfo( "-wl" );
	if( $tmp0 != "-1" )
	{
		int $i = ( $tmp0 == "0" ) ? 9 : 10;
		iconTextCheckBox -e -v true $gGraphEditorTanButtonNames[ $i ];
	}
}

global
proc loadAnimMenuLibrary ()
{
}
