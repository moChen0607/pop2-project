// Copyright (C) 1997-2014 Autodesk, Inc., and/or its licensors.
// All rights reserved.
//
// The coded instructions, statements, computer programs, and/or related
// material (collectively the "Data") in these files contain unpublished
// information proprietary to Autodesk, Inc. ("Autodesk") and/or its licensors,
// which is protected by U.S. and Canadian federal copyright law and by
// international treaties.
//
// The Data is provided for use exclusively by You. You have the right to use,
// modify, and incorporate this Data into other products for purposes authorized 
// by the Autodesk software license agreement, without fee.
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND. AUTODESK
// DOES NOT MAKE AND HEREBY DISCLAIMS ANY EXPRESS OR IMPLIED WARRANTIES
// INCLUDING, BUT NOT LIMITED TO, THE WARRANTIES OF NON-INFRINGEMENT,
// MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE, OR ARISING FROM A COURSE 
// OF DEALING, USAGE, OR TRADE PRACTICE. IN NO EVENT WILL AUTODESK AND/OR ITS
// LICENSORS BE LIABLE FOR ANY LOST REVENUES, DATA, OR PROFITS, OR SPECIAL,
// DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES, EVEN IF AUTODESK AND/OR ITS
// LICENSORS HAS BEEN ADVISED OF THE POSSIBILITY OR PROBABILITY OF SUCH DAMAGES.

	//
//
//  Creation Date:  Oct, 2000
//
//	Procedure Name:
//		cacheClipData
//
//	Description:
//		Callback used before removing attributes from a character
//      to cache clip data for the attributes. The 
//		clip data is isolated separate from the character in a
//		clipLibrary from which it can be copied and pasted
//		onto a new character using copyCachedClipDataCallback.
//
//	Input Arguments:
//	$character :  	name of the original character
//  $attrs : 		attributes to be cached
//
//	Return Value:
//		Library file and clip names for the cached clips
//
global proc string[]
cacheClipDataForCharacter(string $character, string $attrs[])
{
	// Isolate any clips for channels that we want to copy to the other
	// new subcharacter
	//
	string $isolateResult[];
	if (size($attrs) > 0) {
		string $sch = `character -q -sc $character`;
		if (size($sch) > 0) {
			string $schedClips[] = `clipSchedule -q -n $sch`;
			if (size($schedClips) > 0) {
				string $isolateCmd = "clip -ignoreSubcharacters -isolate";
				for ($sc in $schedClips) {
					$isolateCmd += (" -name "+$sc);
				}
				for ($aic in $attrs) {
					$isolateCmd += (" -uc "+$aic);
				}
				$isolateCmd += (" "+$character);
				$isolateResult = eval($isolateCmd);
			}
		}
	}
	return $isolateResult;
}

global proc string[]
cacheClipData(string $character, string $attrs[])
{
	string $result[];
	
	// If the character isn't specified, find out if the attributes are in
    // a character
	//
	if ("" == $character) {
		int $ii, $jj;
		int $atCount = size($attrs);
		string $myAttrs[];
		string $myChars[];
		for ($ii = 0; $ii < $atCount; $ii++) {
			string $mem[] = `listConnections -d 1 -s 0 -type character $attrs[$ii]`;
			if (size($mem)) {
				$myAttrs[$ii] = $attrs[$ii];
				$myChars[$ii] = $mem[0];
			} else {
				$myAttrs[$ii] = "";
				$myChars[$ii] = "";				
			}
		}
		for ($ii = 0; $ii < $atCount; $ii++) {
			string $attrsToAdd[];
			if ($myAttrs[$ii] == "") continue;

			$attrsToAdd[0] = $myAttrs[$ii];
			string $currChar = $myChars[$ii];
			for ($jj = 0; $jj < $atCount; $jj++) {
				if ($myChars[$jj] == $currChar) {
					$attrsToAdd[size($attrsToAdd)] = $myAttrs[$jj];
					$myAttrs[$jj] = "";
					$myChars[$jj] = "";
				}
			}
			string $currR;
			string $currResult[];
			$currResult = cacheClipDataForCharacter($currChar,$attrsToAdd);
			for ($currR in $currResult) {
				$result[size($result)] = $currR;
			}
			clear($attrsToAdd);
		}
	} else {
		$result = cacheClipDataForCharacter($character,$attrs);
	}
	return $result;
}
