// Copyright (C) 1997-2014 Autodesk, Inc., and/or its licensors.
// All rights reserved.
//
// The coded instructions, statements, computer programs, and/or related
// material (collectively the "Data") in these files contain unpublished
// information proprietary to Autodesk, Inc. ("Autodesk") and/or its licensors,
// which is protected by U.S. and Canadian federal copyright law and by
// international treaties.
//
// The Data is provided for use exclusively by You. You have the right to use,
// modify, and incorporate this Data into other products for purposes authorized 
// by the Autodesk software license agreement, without fee.
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND. AUTODESK
// DOES NOT MAKE AND HEREBY DISCLAIMS ANY EXPRESS OR IMPLIED WARRANTIES
// INCLUDING, BUT NOT LIMITED TO, THE WARRANTIES OF NON-INFRINGEMENT,
// MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE, OR ARISING FROM A COURSE 
// OF DEALING, USAGE, OR TRADE PRACTICE. IN NO EVENT WILL AUTODESK AND/OR ITS
// LICENSORS BE LIABLE FOR ANY LOST REVENUES, DATA, OR PROFITS, OR SPECIAL,
// DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES, EVEN IF AUTODESK AND/OR ITS
// LICENSORS HAS BEEN ADVISED OF THE POSSIBILITY OR PROBABILITY OF SUCH DAMAGES.

//
//
//
//
//
//
//  Creation Date:  Nov. 96
//
//
// Description:
//	This script creates a window that can be used to
//	set the locked status of attributes on active objects.
//
//  Input Arguments:
//      None.
//
//  Return Value:
//      None.
//
//

global proc PSupdateLockingUI ( string $parent, string $selectedItem )
//
// Setup the two lists of attributes - those that
// are locked, and those that aren't, so the user
// can flip them from one side to the other.
//
{
	setParent $parent;

	int $LOCKED_List_Limit, $NONLOCKED_List_Limit;
	string $LOCKED_List[], $NONLOCKED_List[];

	$LOCKED_List = `listAttr  -m -l -s -v -r -w -c $selectedItem`;
	$NONLOCKED_List = `listAttr -m -u -s -v -r -w -c $selectedItem`;
	$LOCKED_List_Limit = size( $LOCKED_List );
	$NONLOCKED_List_Limit = size( $NONLOCKED_List );

	if( !`exists lockingKeyableWnd_uiNames` ) {
		source lockingKeyableWnd;
	}

	// The $LOCKED_List and $NONLOCKED_List are lists of
	// long names.  Now that we support Channel Names in
	// "long", "short", or "nice" mode, we might need to
	// convert the displayed attributes from long names to
	// whatever our current display mode is.  We therefore
	// fill in the ${LOCKED,NONLOCKED}_UI_List
	// arrays based on the display mode.
	//
	$LOCKED_List = sort($LOCKED_List);
	$LOCKED_UI_List = lockingKeyableWnd_uiNames( $LOCKED_List, $selectedItem );
	$NONLOCKED_List = sort($NONLOCKED_List);
	$NONLOCKED_UI_List = lockingKeyableWnd_uiNames( $NONLOCKED_List, $selectedItem );

	// Since listAttr is going to return the full attribute names
	// we need, strip off any component parts of $selectedItem
	// by tokenizing based on the "." character.
	//
	string $node, $buffer[];
	tokenize( $selectedItem, ".", $buffer );
	if( size( $buffer ) > 0 ) {
		$node = $buffer[0];
	} else {
		$node = $selectedItem;
	}

	// First clear, then refill the locked and non-locked scroll lists
	// Each pane in the tabLayout has two scroll lists to manage: the 
	// first (ex: LOCKED_List) contains the attr name as determined by
	// the current display mode (optionVar "CCchannelNames"), and the 
	// second (ex: LOCKED_LONG_List) contains the long name of what's
	// being displayed, to guarantee that we can issue the appropriate
	// MEL command to change the state on the attr.
	//
	textScrollList -e -m 0 LOCKED_List;
	textScrollList -e -m 0 LOCKED_LONG_List;
	textScrollList -e -m 0 NONLOCKED_LONG_List;

	textScrollList -e -ra LOCKED_List;
	textScrollList -e -ra LOCKED_LONG_List;
	textScrollList -e -ra NONLOCKED_List;
	textScrollList -e -ra NONLOCKED_LONG_List;

	int $i;
	for ( $i=0; $i < $LOCKED_List_Limit; $i++ )
	{
		textScrollList -e -a $LOCKED_UI_List[$i] LOCKED_List;
		textScrollList -e -a $LOCKED_List[$i] LOCKED_LONG_List;
	}

	for ( $i=0; $i < $NONLOCKED_List_Limit; $i++ )
	{
		int $isLocking;
		string  $attrName = ( $node + "." + $NONLOCKED_List[$i] );

		if( !catch( $isLocking = `getAttr -l $attrName` )
		&&( $isLocking == 0 ) )
		{					
			textScrollList -e -a $NONLOCKED_UI_List[$i] NONLOCKED_List;
			textScrollList -e -a $NONLOCKED_List[$i] NONLOCKED_LONG_List;
		}
	}

	textScrollList -e -m 1 LOCKED_List;
	textScrollList -e -m 1 NONLOCKED_List;

	// Hook up the buttons to the right object
	//
	button -e 
		-c ( "PS_unlockAttributes " + $parent + " " + $selectedItem )
		NONLOCKED_Button;
	button -e
		-c ( "PS_lockAttributes " + $parent + " " + $selectedItem )
		LOCKED_Button;

	// Dim the lock and unlock buttons.  They will be undimmed when
	// the user clicks on either list
	//
	disable LOCKED_Button;
	disable NONLOCKED_Button;
}

global proc PS_lockAttributes ( string $parent, string $selectedItem )
//
// Move items selected in the non-locked list
// to the locked list...
//
{
	setParent $parent;

	string $selectedAttrs[];
	int $selectedAttrsSize;
	int $selectedIndices[];

	$selectedIndices = `textScrollList -q -sii NONLOCKED_List`;
	$selectedAttrsSize = size( $selectedIndices );
	string $longNames[] = `textScrollList -q -ai NONLOCKED_LONG_List`;
	
	// Subtract one since the indices were filled up from 1-based
	// textScrollList -q -sii but array $longNames requires 0-based
	// access...
	//
	for( $index in $selectedIndices ) {
		$selectedAttrs[size($selectedAttrs)] = $longNames[$index-1];
	}

	// Since listAttr is going to return the full attribute names
	// we need, strip off any component parts of $selectedItem
	// by tokenizing based on the "." character.
	//
	string $node, $buffer[];
	tokenize( $selectedItem, ".", $buffer );
	if( size( $buffer ) > 0 ) {
		$node = $buffer[0];
	} else {
		$node = $selectedItem;
	}

	// see if the ALL option is engaged
	//
	int $changeAll = `checkBox -q -v CC_LOCKALL_Box`;

	if ( $changeAll ){
		// get the node type of the current node
		//
		string $baseType = `nodeType $selectedItem`;

		// get a list of all selected nodes
		//
		string $allNodes[] = `selectedNodes`;

		// for each node that matches type, set the locked state
		// of each attribute in the non-locked list
		//
		int $limit = `size($allNodes)`;
		string $thisNode;
		int $index;
		for ( $index=0; $index<$limit; $index++ ){
			$thisNode = $allNodes[$index];
			if ( `nodeType $thisNode` == $baseType ){
				int $i;
				for ( $i=0; $i<$selectedAttrsSize; $i++ ){
					setAttr -l on ( $thisNode + "." + $selectedAttrs[$i] );
				}
			}
		}
	} else {  // only change the selected node

		int $i;
		for( $i=0; $i < $selectedAttrsSize; $i++ )
		{
			setAttr -l on ( $node + "." + $selectedAttrs[$i] );
		}
	}

	// Update the window
	//
	PSupdateLockingUI $parent $selectedItem;
}


global proc PS_unlockAttributes ( string $parent, string $selectedItem )
//
// Move items selected in the locked list
// to the non-locked list...
//
{
	setParent $parent;
	
	string $selectedAttrs[];
	int $selectedAttrsSize;
	int $selectedIndices[];

	$selectedIndices = `textScrollList -q -sii LOCKED_List`;
	$selectedAttrsSize = size( $selectedIndices );
	string $longNames[] = `textScrollList -q -ai LOCKED_LONG_List`;

	// Subtract one since the indices were filled up from 1-based
	// textScrollList -q -sii but array $longNames requires 0-based
	// access...
	//
	for( $index in $selectedIndices ) {
		$selectedAttrs[size($selectedAttrs)] = $longNames[$index-1];
	}

	// Since listAttr is going to return the full attribute names
	// we need, strip off any component parts of $selectedItem
	// by tokenizing based on the "." character.
	//
	string $node, $buffer[];
	tokenize( $selectedItem, ".", $buffer );
	if( size( $buffer ) > 0 ) {
		$node = $buffer[0];
	} else {
		$node = $selectedItem;
	}

	// see if the ALL option is engaged
	//
	int $changeAll = `checkBox -q -v CC_LOCKALL_Box`;

	if ( $changeAll ){
		// get the node type of the current node
		//
		string $baseType = `nodeType $selectedItem`;

		// get a list of all selected nodes
		//
		string $allNodes[] = `selectedNodes`;

		// for each node that matches type, set the locked state
		// of each attribute in the non-locked list
		//
		int $limit = `size($allNodes)`;
		string $thisNode;
		int $index;
		for ( $index=0; $index<$limit; $index++ ){
			$thisNode = $allNodes[$index];
			if ( `nodeType $thisNode` == $baseType ){
				int $i;
				for ( $i=0; $i<$selectedAttrsSize; $i++ ){
					string $pAttr[] = `attributeQuery -lp -n $thisNode $selectedAttrs[$i]`;
					if (size($pAttr) > 0) {
						int $pLock;
						$pLock = `getAttr -l ( $thisNode + "." + $pAttr[0] )`;
						if ($pLock == 1) {
							// If the parent is locked.
							//		Unlock the parent and 
							//		Lock the rest of the children
							//
							setAttr  -l off ( $thisNode + "." + $pAttr[0] );
							string $cAttr[] = `attributeQuery -lc -n $thisNode $pAttr[0]`;
							int $cCount = size($cAttr);
							for ( $c=0; $c<$cCount; $c++ ){
								setAttr -l 1 ( $thisNode + "." + $cAttr[$c] );
							}
						}
					}
					setAttr -l off ( $thisNode + "." + $selectedAttrs[$i] );
				}
			}
		}
	} else {  // only change the selected node
		int $i;
		for( $i=0; $i < $selectedAttrsSize; $i++ )
		{
			string $pAttr[] = `attributeQuery -lp -n $node $selectedAttrs[$i]`;
			if (size($pAttr) > 0) {
				int $pLock;
				$pLock = `getAttr -l ( $node + "." + $pAttr[0] )`;
				if ($pLock == 1) {
					// If the parent is locked.
					//		Unlock the parent and 
					//		Lock the rest of the children
					//
					setAttr  -l off ( $node + "." + $pAttr[0] );
					string $cAttr[] = `attributeQuery -lc -n $node $pAttr[0]`;
					int $cCount = size($cAttr);
					for ( $c=0; $c<$cCount; $c++ ){
						setAttr -l 1 ( $node + "." + $cAttr[$c] );
					}
				}
			}
			setAttr -l off ( $node + "." + $selectedAttrs[$i] );	
		}
	}

	// Update the window
	//
	PSupdateLockingUI $parent $selectedItem;
}


global proc PScreateLockingUI( string $parent, string $node )
//
// Sets up a UI that shows all the DAG and
// Shape nodes in the system, so that the 
// user can set the locked attributes for
// them.
//
{
	setParent $parent;

	string $myContainer = `formLayout containerForm`;

	text -label (uiRes("m_PScreateLockingUI.kLocked")) LOCKED_Text;

	// Label the non-locked area
	//
	text -label (uiRes("m_PScreateLockingUI.kNonLocked")) NONLOCKED_Text;

	// Create the Move to non-locked button
	//
	string $nkButton = `button -label (uiRes("m_PScreateLockingUI.kMoveRight"))
		-c ( "PS_unlockAttributes " + $parent + " " + $node )
		-h 26
		NONLOCKED_Button`;

	// Create the Move to locked button
	//
	string $kButton = `button -label (uiRes("m_PScreateLockingUI.kMoveLeft"))
		-c ( "PS_lockAttributes " + $parent + " " + $node )
		-h 26
		LOCKED_Button`;

	// Create the cancel/close button
	//
	button -label (uiRes("m_PScreateLockingUI.kClose")) -h 26 -c "deleteUI LockingKeyable" CLOSE_Button;

	// Create the ALL checkbox
	//
	if ( !`optionVar -exists CClockAllSame` ){
		optionVar -intValue CClockAllSame 1;
	}
	checkBox
		-label (uiRes("m_PScreateLockingUI.kChangeAllObjects"))
		-v `optionVar -q CClockAllSame`
		-cc "optionVar -intValue CClockAllSame #1"
		CC_LOCKALL_Box;

	// Create the locked scroll list
	//
	textScrollList
		-ams 1
		-h 150
		-sc ("disable LOCKED_Button; disable -v false " + $nkButton + ";textScrollList -e -da NONLOCKED_List" )
		LOCKED_List;

	// Create the non-locked scroll list
	//
	textScrollList
		-ams 1
		-h 150
		-sc ("disable NONLOCKED_Button; disable -v false " + $kButton + ";textScrollList -e -da LOCKED_List" )
		NONLOCKED_List;

	// When we're displaying Nice attr names, we can't just 
	// query the textScrollList for its selected entries to
	// get an attr's long name to execute its state-changing
	// MEL command.  So, no matter what we're actually displaying,
	// these two {LOCKED,NONLOCKED}_LONG_List 
	// textScrollLists hold on to the long names required for 
	// the MEL commands.  They're always kept in sync whenever
	// their corresponding display-name textScrollLists are 
	// modified, and it was easier implementing things this way
	// than passing a bunch of arrays around and modifying proc
	// signatures and such.  These widgets are never made visible
	// and really are for convenience only.
	//
	textScrollList
		-ams 1
		-visible 0
		LOCKED_LONG_List;
	textScrollList
		-ams 1
		-visible 0
		NONLOCKED_LONG_List;

	separator -hr true LOCKED_Sep;

	// Edit the form attachments
	//

	formLayout -edit
		-af LOCKED_Text top 10 
		-af LOCKED_Text left 10
		-ap LOCKED_Text right 10 50
		-an LOCKED_Text bottom

		-af NONLOCKED_Text top 10
		-ap NONLOCKED_Text left 10 50
		-af NONLOCKED_Text right 10 
		-an NONLOCKED_Text bottom

		-af LOCKED_List top 30
		-af LOCKED_List left 10
		-ap LOCKED_List right 0 50
		-ac LOCKED_List bottom 10 LOCKED_Sep

		-af NONLOCKED_List top 30
		-ap NONLOCKED_List left 0 50
		-af NONLOCKED_List right 10
		-ac NONLOCKED_List bottom 10 LOCKED_Sep

		-an LOCKED_Sep top
		-af LOCKED_Sep left 0
		-af LOCKED_Sep right 0
		-af LOCKED_Sep bottom 60

		-an CC_LOCKALL_Box top
		-af CC_LOCKALL_Box left 15
		-af CC_LOCKALL_Box bottom 35
		-an CC_LOCKALL_Box right

		-an CLOSE_Button top
		-ap CLOSE_Button right 2 66
		-ap CLOSE_Button left 2 33
		-af CLOSE_Button bottom 5

		-an NONLOCKED_Button top
		-ap NONLOCKED_Button right 2 33
		-af NONLOCKED_Button left 5
		-af NONLOCKED_Button bottom 5

		-an LOCKED_Button top
		-ap LOCKED_Button left 2 66
		-af LOCKED_Button right 5
		-af LOCKED_Button bottom 5

		$myContainer;


	// Fill the scroll lists
	// with the selected object's attributes
	//

	PSupdateLockingUI $parent $node;
	showWindow;
}
