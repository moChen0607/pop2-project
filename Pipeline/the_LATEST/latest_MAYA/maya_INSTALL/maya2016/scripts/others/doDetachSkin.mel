// Copyright (C) 1997-2014 Autodesk, Inc., and/or its licensors.
// All rights reserved.
//
// The coded instructions, statements, computer programs, and/or related
// material (collectively the "Data") in these files contain unpublished
// information proprietary to Autodesk, Inc. ("Autodesk") and/or its licensors,
// which is protected by U.S. and Canadian federal copyright law and by
// international treaties.
//
// The Data is provided for use exclusively by You. You have the right to use,
// modify, and incorporate this Data into other products for purposes authorized 
// by the Autodesk software license agreement, without fee.
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND. AUTODESK
// DOES NOT MAKE AND HEREBY DISCLAIMS ANY EXPRESS OR IMPLIED WARRANTIES
// INCLUDING, BUT NOT LIMITED TO, THE WARRANTIES OF NON-INFRINGEMENT,
// MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE, OR ARISING FROM A COURSE 
// OF DEALING, USAGE, OR TRADE PRACTICE. IN NO EVENT WILL AUTODESK AND/OR ITS
// LICENSORS BE LIABLE FOR ANY LOST REVENUES, DATA, OR PROFITS, OR SPECIAL,
// DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES, EVEN IF AUTODESK AND/OR ITS
// LICENSORS HAS BEEN ADVISED OF THE POSSIBILITY OR PROBABILITY OF SUCH DAMAGES.

//
//
//  Creation Date:  Sept, 1998
//
//  Description:
//      This script performs a detachSkin operation
//
//

proc int checkReference(string $node)
// 
// Checks if the deformer node is from a reference
// Returns true if it isn't
//
{
	string $ref[] = `ls -ro $node`;

	if (size($ref) == 0)
		return true;
	else
	{
		error( (uiRes("m_doDetachSkin.kCantUnbind")));
		return false;
	}
}


global proc int doDetachSkin( string $version, string $args[] )
{
	string $bindSkinCmd = "bindSkin ";
	string $skinClusterCmd = "mSkinCluster \"-e ";
	
	int $historyMethod = $args[0];
	int $colorJoints = $args[1];
	$historyMethod -= 1;

	if ($colorJoints) {
		$bindSkinCmd += "-colorJoints ";
	}
	
	if (2 == $historyMethod) { // bake results
		$bindSkinCmd += " -ul; delete -ch";
		$skinClusterCmd = "bindSkin -ul; delete -ch";
	}
	else {
		if ($historyMethod) { // keep history
			$bindSkinCmd += "-ubk";
			$skinClusterCmd += " -ubk\"";
		} else { // remove history
			$bindSkinCmd += "-ub";
			$skinClusterCmd += " -ub\"";
		}
	}

	string $sArr[] = `ls -sl`;

	int $count = 0;
	for ($ii = 0; $ii < size($sArr); $ii++)
	{
		// Find all the DAG leaved under the selected transforms
		//
		string $allShapes[] = `ls -lf -dag $sArr[$ii]`;
		string $shape;
		for($shape in $allShapes)
		{
			// Check if the object still exists
			//
			string $exists[] = `ls $shape`;
			if (size($exists) == 0)
				continue;

			// Ignore intermediate objects
			//
			int $io = `getAttr ($shape+".io")`;
			if ($io == 1)
				continue;

			string $hist[] = `listHistory $shape`;
			for ($jj = 0; $jj < size($hist); $jj++)
			{
				string $node = $hist[$jj];

				string $nt = nodeType($node);
				if ($nt == "jointCluster")
				{
					if (checkReference($node))
					{
						string $cmd = $bindSkinCmd + " " + $shape;
						waitCursor -state on;
						eval($cmd);
						waitCursor -state off;
						$count++;
					}
					break;
				}
				else if ($nt == "skinCluster")
				{
					if (checkReference($node))
					{
						string $influences[] = `listConnections -s 1 ( $node + ".influenceColor" )`;

						select -r $shape;
						waitCursor -state on;
						eval($skinClusterCmd);

						if ($colorJoints)
							for ($inf in $influences)
								colorizeSkeleton($inf, false);

						waitCursor -state off;
						$count++;
					}
					break;
				}
			}
		}
	}
	for ($ii = 0; $ii < size($sArr); $ii++) {
		select -add $sArr[$ii];
	}
	if (0 == $count) {
		error( (uiRes("m_doDetachSkin.kMustSelectSkin")));
	}
	return 1;
}
