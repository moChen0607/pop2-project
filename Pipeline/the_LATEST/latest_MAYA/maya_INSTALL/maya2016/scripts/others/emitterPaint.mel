// Copyright (C) 1997-2014 Autodesk, Inc., and/or its licensors.
// All rights reserved.
//
// The coded instructions, statements, computer programs, and/or related
// material (collectively the "Data") in these files contain unpublished
// information proprietary to Autodesk, Inc. ("Autodesk") and/or its licensors,
// which is protected by U.S. and Canadian federal copyright law and by
// international treaties.
//
// The Data is provided for use exclusively by You. You have the right to use,
// modify, and incorporate this Data into other products for purposes authorized 
// by the Autodesk software license agreement, without fee.
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND. AUTODESK
// DOES NOT MAKE AND HEREBY DISCLAIMS ANY EXPRESS OR IMPLIED WARRANTIES
// INCLUDING, BUT NOT LIMITED TO, THE WARRANTIES OF NON-INFRINGEMENT,
// MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE, OR ARISING FROM A COURSE 
// OF DEALING, USAGE, OR TRADE PRACTICE. IN NO EVENT WILL AUTODESK AND/OR ITS
// LICENSORS BE LIABLE FOR ANY LOST REVENUES, DATA, OR PROFITS, OR SPECIAL,
// DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES, EVEN IF AUTODESK AND/OR ITS
// LICENSORS HAS BEEN ADVISED OF THE POSSIBILITY OR PROBABILITY OF SUCH DAMAGES.

//
//
//
//
//
//
//
//  Creation Date:  Mar 1997
//
//  Description:
//     This is an example script for the Maya Artisan Script
//     Paint tool. It will paint particle emitters onto a
//     NURBS surface as well as painting various parameters of
//     any painted particle emitters.
//
// Usage:
// 1) Place this script into your scripts directory (usually the
//    maya/scripts directory in your home directory
// 2) Select the Script Paint Tool (Modify->Script Paint Tool)
//    and bring up the Tool Settings window
// 3) Go to the Setup tab and enter "emitterPaint" into the
//    "Tool Setup Cmd" field and hit enter
// 4) Paint Emitters
//
// Tips:
// Once you have the Emitter Paint Tool setup you may want to drag
// it from the minibar to the shelf so that it is always accessible
//

// These are global variables used to keep track of multiple
// surfaces and various names associated with each surface
//
global string $emitterNamePrefix[];
global string $emitterParentName[];
global string $emitterParticles[];
global string $emitterGroupName[];
global int $emitterSrfType[];			// 0 - NURBS surface, 1 - mesh surface, 2 - subd surface
global int $emitterPaintFreeSlot = 0;
global int $emitterPaintSlots = 0;

// These are global variables used to control what will happen
// during painting. These globals are modified using a separate
// UI window created when this tool becomes active.
//
global int $gridSizeU = 25;
global int $gridSizeV = 25;
global string $modifyAttr = ".rate";
global string $modifyAttrCheck = "";
global string $modifyAttrType = "";

// what mode are we in:
// 1 - create emitters
// 2 - remove emitters
// 3 - modify emitter attributes
// 4 - modify particles attributes
// 5 - change particle render type
//
global int $emitterOp = 1;

global int $jitterGrid = 1;
global int $ditherGrid = 1;
global int $createType = 2;
global float $createRate = 25;
global float $createSpeed = 1;
global float $createSpread = 0.1;
global float $createMinDist = 0;
global float $createMaxDist = 0;
global int $particleShapePerEmitter = 1;

// stuff related to render type
//
global string $renderTypeNames[] = {
	"Multi-Point", "Multi-Streak", "Numeric", "Points", "Spheres", "Sprites", "Streak", "Blobby (s/w)"
};
global int $curRenderType = 3;

global proc changeCurRenderType(
	string $type
)
{
	global string $renderTypeNames[];
	global int $curRenderType;

	int $rt;
	int $nrt = size( $renderTypeNames );

	for ( $rt = 0; $rt < $nrt; ++$rt ) {
		if ( $renderTypeNames[$rt] == $type ) {
			$curRenderType = $rt;
			break;
		}
	}
}

// This is an internal procedure which changes which attribute
// on existing emitters/particles is to be painted.
// 
proc updateModifyAttr(
	string $attr,
	string $attrCheck,
	string $attrType,
	float $offset,
	float $mult,
	string $context
)
{
	global string $modifyAttr;
	global string $modifyAttrCheck;
	global string $modifyAttrType;

	$modifyAttr = $attr;
	$modifyAttrCheck = $attrCheck;
	$modifyAttrType = $attrType;
	
	//userPaintCtx -e -offset $offset -mult $mult $context;
	
	float $minValue = `artUserPaintCtx -q -minvalue $context` ;
	float $maxValue = `artUserPaintCtx -q -maxvalue $context` ;
	float $value = `artUserPaintCtx -q -value  $context` ;
	
	$minValue += $offset ;
	$maxValue += $offset ;
	$value += $offset ;
	
	$minValue = $minValue * $mult ;
	$maxValue = $maxValue * $mult ;
	$value = $value * $mult ;
	
	artUserPaintCtx -e -minvalue $minValue -maxvalue $maxValue -value $value $context;
}

// emitter attribute info
//
global string $emitterAttrName[] = {
	"Rate", "Spread", "Speed", "Min Dist", "Max Dist"
};
global string $emitterAttr[] = {
	".rate", ".spr", ".spd", ".min", ".max"
};
global float $emitterAttrOffset[] = {
	0.0, 0.0, 0.0, 0.0, 0.0
};
global float $emitterAttrMult[] = {
	10.0, 1.0, 5.0, 10.0, 10.0
};
global int $curEmitterAttr = 0;

global proc updateEmitterAttr(
	string $name,
	string $context
)
{
	global string $emitterAttrName[];
	global int $curEmitterAttr;
	global int $emitterOp;

	int $opt;
	int $numOpt = size( $emitterAttrName );

	for ( $opt = 0; $opt < $numOpt; ++$opt ) {
		if ( $emitterAttrName[$opt] == $name ) {
			$curEmitterAttr = $opt;
			if ( $emitterOp == 3 ) {
				// if we are modifying attributes, update some globals
				//
				global string $emitterAttr[];
				global float $emitterAttrOffset[];
				global float $emitterAttrMult[];
	
				updateModifyAttr( 
					$emitterAttr[$curEmitterAttr],
					"", "",
					$emitterAttrOffset[$curEmitterAttr],
					$emitterAttrMult[$curEmitterAttr],
					$context
				);
			}
			break;
		}
	}
}

// particle attribute info
//
global string $particleAttrName[] = {
	"Lifespan", "Opacity", "Point Size", "Line Width",
	"Tail Fade", "Tail Size", "Radius", "Multi Count",
	"Multi Radius"
};
global string $particleAttr[] = {
	".lifespan", ".opacity", ".pointSize", ".lineWidth",
	".tailFade", ".tailSize", ".radius", ".multiCount",
	".multiRadius"
};
global string $particleAttrCheck[] = {
	"lifespan", "opacity", "pointSize", "lineWidth",
	"tailFade", "tailSize", "radius", "multiCount",
	"multiRadius"
};
global string $particleAttrType[] = {
	"double", "double", "long", "long",
	"float", "float", "float", "long",
	"float"
};
global float $particleAttrOffset[] = {
	0.0, 0.0, 1.0, 1.0,
	0.0, 0.0, 0.0, 1.0,
	0.0
};
global float $particleAttrMult[] = {
	5.0, 1.0, 20.0, 20.0,
	1.0, 30.0, 5.0, 30.0,
	5.0
};
global int $curParticleAttr = 0;

global proc updateParticleAttr(
	string $name,
	string $context
)
{
	global string $particleAttrName[];
	global int $curParticleAttr;
	global int $emitterOp;

	int $opt;
	int $numOpt = size( $particleAttrName );

	for ( $opt = 0; $opt < $numOpt; ++$opt ) {
		if ( $particleAttrName[$opt] == $name ) {
			$curParticleAttr = $opt;
			if ( $emitterOp == 4 ) {
				// if we are modifying attributes, update some globals
				//
				global string $particleAttr[];
				global string $particleAttrCheck[];
				global string $particleAttrType[];
				global float $particleAttrOffset[];
				global float $particleAttrMult[];
	
				updateModifyAttr( 
					$particleAttr[$curParticleAttr],
					$particleAttrCheck[$curParticleAttr],
					$particleAttrType[$curParticleAttr],
					$particleAttrOffset[$curParticleAttr],
					$particleAttrMult[$curParticleAttr],
					$context
				);
			}
			break;
		}
	}
}

// This is an internal procedure which adjusts the "Set Value Cmd"
// and "Get Value Cmd", based on the current operation
// 
global proc changeEmitterOp( int $op, string $context )
{
	global int $emitterOp;

	string $getval;
	string $setval;

	$emitterOp = $op;
	if ( $emitterOp == 1 ) {
		$getval = "";
		$setval = "createEmitter";
	} else if ( $emitterOp == 2 ) {
		$getval = "";
		$setval = "deleteEmitter";
	} else if ( $emitterOp == 3 ) {
		$getval = "getEmitterAttr";
		$setval = "setEmitterAttr";
	} else if ( $emitterOp == 4 ) {
		$getval = "getParticlesAttr";
		$setval = "setParticlesAttr";
	} else if ( $emitterOp == 5 ) {
		$getval = "";
		$setval = "changeParticleRenderType";
	}
	artUserPaintCtx -e
//		-svc $setval -gvc $getval -offset 0 -mult 1
		-svc $setval -gvc $getval -minvalue 0 -maxvalue 1
		$context;

	if ( $emitterOp == 3 ) {
		global string $emitterAttrName[];
		global int $curEmitterAttr;

		updateEmitterAttr( $emitterAttrName[$curEmitterAttr], $context );
	} else if ( $emitterOp == 4 ) {
		global string $particleAttrName[];
		global int $curParticleAttr;

		updateParticleAttr( $particleAttrName[$curParticleAttr], $context );
	}
}

// This procedure creates the dialog box used to control various
// parameters that control what happens when painting.
// NOTE: This is in no way meant to be an example of good UI
// design!
//
proc emitterPaintUI( string $context ) 
{
	global int $gridSizeU;
	global int $gridSizeV;
	global int $emitterOp;
	global int $jitterGrid;
	global int $ditherGrid;
	global string $modifyAttr;
	global int $createType;
	global float $createRate;
	global float $createSpeed;
	global float $createSpread;
	global float $createMinDist;
	global float $createMaxDist;
	global int $particleShapePerEmitter;
	global string $renderTypeNames[];
	global int $curRenderType;
	global string $emitterAttrName[];
	global int $curEmitterAttr;
	global string $particleAttrName[];
	global int $curParticleAttr;

	int $opt, $numOpt;

	if ( `window -ex emitterPaintWindow` )
	{
		showWindow emitterPaintWindow ;
		return ;
	}
	
	string	$winName=`window emitterPaintWindow`;
	setUITemplate -pushTemplate DefaultTemplate;
	columnLayout -adj false -cal left
		column;

		intSliderGrp -field true -l (uiRes("m_emitterPaint.kEmitterPaintUGridSize")) -min 2 -max 100
					 -v $gridSizeU
					 -cc "$gridSizeU = #1"
					 uGrid; 
		intSliderGrp -field true -l (uiRes("m_emitterPaint.kEmitterPaintVGridSize")) -min 2 -max 100
					 -v $gridSizeV
					 -cc "$gridSizeV = #1"
					 vGrid;
		checkBoxGrp -ncb 2 -l (uiRes("m_emitterPaint.kEmitterPaintGridOptions"))
					-l1 (uiRes("m_emitterPaint.kEmitterPaintJitter"))
					-v1 $jitterGrid
					-cc1 "$jitterGrid = #1"
					-l2 (uiRes("m_emitterPaint.kEmitterPaintDither"))
					-v2 $ditherGrid
					-cc2 "$ditherGrid = #1"
					options;

		radioButtonGrp -l (uiRes("m_emitterPaint.kEmitterPaintOperation"))
			-nrb 2
			-l1 (uiRes("m_emitterPaint.kEmitterPaintCreate"))
			-on1 ("changeEmitterOp 1 " + $context)
			-l2 (uiRes("m_emitterPaint.kEmitterPaintRemove"))
			-on2 ("changeEmitterOp 2 " + $context)
			operation0;
		radioButtonGrp -l "" -nrb 1
			-scl operation0
			-l1 (uiRes("m_emitterPaint.kEmitterPaintModify"))
			-on1 ("changeEmitterOp 3 " + $context)
			operation1;

		optionMenuGrp -l (uiRes("m_emitterPaint.kEmitterPaintAttribute"))
			-cc ("updateEmitterAttr \"#1\" " + $context)
			emitterAttrMenu;
		$numOpt = size( $emitterAttrName );
		for ( $opt = 0; $opt < $numOpt; ++$opt ) {
			menuItem -label $emitterAttrName[$opt];
		}
		optionMenuGrp -e -sl ($curEmitterAttr + 1) emitterAttrMenu;

		radioButtonGrp -l "" -nrb 1
			-scl operation0
			-l1 (uiRes("m_emitterPaint.kEmitterPaintModify"))
			-on1 ("changeEmitterOp 4 " + $context)
			operation2;

		optionMenuGrp -l (uiRes("m_emitterPaint.kEmitterPaintParticleAttribute"))
			-cc ("updateParticleAttr \"#1\" " + $context)
			particleAttrMenu;
		$numOpt = size( $particleAttrName );
		for ( $opt = 0; $opt < $numOpt; ++$opt ) {
			menuItem -label $particleAttrName[$opt];
		}
		optionMenuGrp -e -sl ($curParticleAttr + 1) particleAttrMenu;

		radioButtonGrp -l "" -nrb 1
			-scl operation0
			-l1 (uiRes("m_emitterPaint.kEmitterPaintModify"))
			-on1 ("changeEmitterOp 5 " + $context)
			operation3;

		optionMenuGrp -l (uiRes("m_emitterPaint.kEmitterPaintRenderType"))
			-cc "changeCurRenderType \"#1\""
			renderTypeMenu;
		$numOpt = size( $renderTypeNames );
		for ( $opt = 0; $opt < $numOpt; ++$opt ) {
			menuItem -label $renderTypeNames[$opt];
		}
		optionMenuGrp -e -sl ($curRenderType + 1) renderTypeMenu;

		if ( $emitterOp < 3 ) {
			radioButtonGrp -e -sl $emitterOp operation0;
		} else if ( $emitterOp == 3 ) {
			radioButtonGrp -e -sl 1 operation1;
		} else if ( $emitterOp == 4 ) {
			radioButtonGrp -e -sl 1 operation2;
		} else if ( $emitterOp == 5 ) {
			radioButtonGrp -e -sl 1 operation3;
		}			

		frameLayout -l (uiRes("m_emitterPaint.kEmitterPaintCreationOptions"))
			 -collapse false
			 -collapsable false;
		columnLayout;
		radioButtonGrp -l (uiRes("m_emitterPaint.kEmitterPaintType")) -nrb 2
			-l1 (uiRes("m_emitterPaint.kEmitterPaintOmniDirectional"))
			-on1 "$createType = 1"
			-l2 (uiRes("m_emitterPaint.kEmitterPaintDirectional"))
			-on2 "$createType = 2"
			-sl $createType
			createType;
		floatSliderGrp -field true -l (uiRes("m_emitterPaint.kEmitterPaintRate")) -min 1 -max 100
			-v $createRate
			-cc "$createRate = #1"
			createRate;
		floatSliderGrp -field true -l (uiRes("m_emitterPaint.kEmitterPaintSpeed")) -min 0 -max 10
			-v $createSpeed
			-cc "$createSpeed = #1"
			createSpeed;
		floatSliderGrp -field true -l (uiRes("m_emitterPaint.kEmitterPaintSpread")) -min 0 -max 1
			-v $createSpread
			-cc "$createSpread = #1"
			createSpread;
		floatSliderGrp -field true -l  (uiRes("m_emitterPaint.kEmitterPaintMinDist")) -min 0 -max 10
			-v $createMinDist
			-cc "$createMinDist = #1"
			createMinDist;
		floatSliderGrp -field true -l  (uiRes("m_emitterPaint.kEmitterPaintSpreadMaxDist")) -min 0 -max 10
			-v $createMaxDist
			-cc "$createMaxDist = #1"
			createMaxDist;
		checkBoxGrp -ncb 1 -l  (uiRes("m_emitterPaint.kEmitterPaintParticles"))
					-l1  (uiRes("m_emitterPaint.kEmitterPaintPerEmitter"))
					-v1 $particleShapePerEmitter
					-cc1 "$particleShapePerEmitter = #1"
					createOptions;
		setParent ..;
		setParent ..;

		setParent ..;
	setUITemplate -popTemplate;
	showWindow $winName;
}

// This procedure should be set as the "Tool Setup Cmd" in the 
// Setup tab of the Maya Artisan Script Paint tool's tool settings
// window. The tool context is supplied as an argument.
//
global proc emitterPaint( string $context )
{
	global int $emitterOp;

	// initialize all the other commands in this scriptable 
	// paint tool context.
	// 
	artUserPaintCtx -e
		-ic "initEmitterPaint"
		-fc "finishEmitterPaint"
		-tcc "cleanupEmitterPaint"
		-gsc ""
		-cc ""
		-gac ""
		$context;
		
	// create the dialog box to control various parameters
	//
	emitterPaintUI( $context );

	// this will setup the "Set Value Cmd" and "Get Value Cmd"
	// commands depending on what the current operation is
	//
	changeEmitterOp( $emitterOp, $context );

	// We force the tool to use texture paint
	// mode (as opposed to projection paint mode)
	//
	//artUserPaintCtx -e -painttype "forceTexture" $context;
}

// This is the "Tool Cleanup Cmd". It is called when the tool is
// exited. In this case, the special dialog window that was created
// is deleted
//
global proc cleanupEmitterPaint( string $context )
{
	deleteUI emitterPaintWindow;
}

// This is the "Initialize Cmd". This procedure is called once
// for every selected surface when an intial click is received
// on any surface. The argument is the name of the surface. This
// procedure returns a string which indicates to the scriptable
// tool how to behave for the duration of the stroke. 
//
global proc string initEmitterPaint( string $name )
{
	global string $emitterNamePrefix[];
	global string $emitterParentName[];
	global string $emitterParticles[];
	global string $emitterGroupName[];
	global int $emitterSrfType[];			// 0 - NURBS surface, 1 - mesh surface, 2 - subd surface
	global int $emitterPaintFreeSlot;
	global int $emitterPaintSlots;
	global int $gridSizeU;
	global int $gridSizeV;
	global int $jitterGrid;
	global int $ditherGrid;
	global int $emitterOp;
	global int $particleShapePerEmitter;

	int $slot;

	// find a free slot for this surface in the global arrays
	//
	for ( $slot = $emitterPaintFreeSlot; $slot < $emitterPaintSlots; $slot++ ) {
		if ( $emitterNamePrefix[$slot] == "" ) {
			break;
		}
	}  

	if ( $slot == $emitterPaintSlots ) {
		$emitterPaintSlots++;
		$emitterPaintFreeSlot = $emitterPaintSlots;
	}

	if ( `nodeType $name` == "nurbsSurface" ) {
		$emitterSrfType[$slot] = 0;
	} else if ( `nodeType $name` == "mesh" ) {
		$emitterSrfType[$slot] = 1;
	} else if ( `nodeType $name` == "subdiv" ) {
		$emitterSrfType[$slot] = 2;
	} else {
		$emitterSrfType[$slot] = -1;
	}

	if ( $emitterSrfType[$slot] >= 0 ) {
		// save the name of the parent of this shape as well
		// as a prefix to use when creating the spheres
		//
		string $parent[] = `listRelatives -p $name`;
		$emitterParentName[$slot] = $parent[0];
		$emitterNamePrefix[$slot] = $parent[0] + "Emitter";

		// create particle shape that will hold emitted particles
		// if necessary 
		//
		$emitterParticles[$slot] = $parent[0] + "EParticles";
		if ( ! $particleShapePerEmitter && ! `objExists $emitterParticles[$slot]` ) {
			particle -n $emitterParticles[$slot];
		}

		$emitterGroupName[$slot] = $parent[0] + "EmitterGrp";

		if (  ! `objExists $emitterGroupName[$slot]` ) {
			// Make a group for the painted emitters. Place it at the
			// same level as the surface
			//
			string $parentParent[] = `listRelatives -p $emitterParentName[$slot]`;

			if ( size($parentParent) > 0 ) {
				group -em -p $parentParent[0] -n $emitterGroupName[$slot];
			} else {
				group -em -w -n $emitterGroupName[$slot];
			}

			// Connect this new transform to the surface's transform
			//
			string $from = $emitterParentName[$slot];
			string $to = $emitterGroupName[$slot];
			string $attr[] = { "t", "r", "ro", "s", "sh",
							   "rp", "rpt", "sp", "spt" };

			for ( $a = 0; $a < size($attr); $a++ ) {
				connectAttr ($from + "." + $attr[$a]) ($to + "." + $attr[$a]);
			}
		}
	}

	string $options;

	// build up the string that will be passed back to the
	// scriptable paint tool
	//
	if ( $emitterOp == 3 || $emitterOp == 4 ) {
		// attribute painting
		//
		$options = ( "-id " + $slot
				   + " -grid " + $gridSizeU + " " + $gridSizeV );
	} else {
		// creation/deletion/change render type
		//
		string $dither;

		if ( $ditherGrid ) {
			$dither = "true";
		} else {
			$dither = "false";
		}

		if ( $emitterOp == 1 ) {
			// creation of emitters
			//
			string $jitter;

			if ( $jitterGrid ) {
				$jitter = "true";
			} else {
				$jitter = "false";
			}

			$options = ( "-id " + $slot
					   + " -grid " + $gridSizeU + " " + $gridSizeV
					   + " -uv surface"
					   + " -position local -normal local"
					   + " -jitter " + $jitter
					   + " -dither " + $dither );
		} else {
			// deletion of emitters/change render type
			//
			$options = ( "-id " + $slot
					   + " -grid " + $gridSizeU + " " + $gridSizeV
					   + " -jitter false"
					   + " -dither " + $dither );
		}
	}
	return $options;
}

// This is the "Finalize Cmd". This procedure is called at the
// end of the stroke. It is passed the surface ID, that was
// generated by the "Initialize Cmd".
//
global proc finishEmitterPaint( int $slot )
{
	global string $emitterNamePrefix[];
	global int $emitterPaintFreeSlot;

	// clear out the slot that was used for this surface
	//
	$emitterNamePrefix[$slot] = "";
	if ( $slot < $emitterPaintFreeSlot ) {
		$emitterPaintFreeSlot = $slot;
	}
}

// This is the "Set Value Cmd" when the operation is creating
// emitters. A surface ID, a grid index on the surface and the
// value associated with that grid index is passed. In addition
// this procedure is also passed the (u,v) surface parameter
// position for this grid point (this was specified in the
// initEmitterPaint procedure)
//
global proc createEmitter(
	int $slot,
	int $index,
	float $val,
	float $u,
	float $v,
	float $x,
	float $y,
	float $z,
	float $nx,
	float $ny,
	float $nz
)
{
	global string $emitterNamePrefix[];
	global string $emitterParentName[];
	global string $emitterParticles[];
	global string $emitterGroupName[];
	global int $emitterSrfType[];			// 0 - NURBS surface, 1 - mesh surface, 2 - subd surface
	global int $createType;
	global float $createRate;
	global float $createSpeed;
	global float $createSpread;
	global float $createMinDist;
	global float $createMaxDist;
	global int $particleShapePerEmitter;

	if ( $emitterNamePrefix[$slot] != "" && $val > 0 ) {
		// generate the emitter name
		//
		string $objname = $emitterNamePrefix[$slot] + $index;

		if ( !`objExists $objname` ) {
			// if the emitter doesn't exist, one will be created
			//
			string $type;

			if ( $createType == 1 ) {
				$type = "omni";
			} else {
				$type = "dir";
			}

			string $parent = $emitterParentName[$slot];

			// create the emitter, reparent it to the surface's
			// parent and make a dynamics connecttion to the
			// particle shape
			//
			emitter -type $type -pos 0 0 0
					-rate $createRate -spread $createSpread
					-mnd $createMinDist -mxd $createMaxDist
					-speed $createSpeed -name $objname;
			setAttr ($objname + ".dx") 0;
			setAttr ($objname + ".dy") 0;
			setAttr ($objname + ".dz") 1;
			parent -r $objname $emitterGroupName[$slot];

			string $particles;
		
			if ( $particleShapePerEmitter ) {
				$particles = $emitterParticles[$slot] + $index;
				particle -n $particles;
			} else {
				$particles = $emitterParticles[$slot];
			}
			connectDynamic -em $objname $particles;

			if ( $emitterSrfType[$slot] == 0 ) {	// NURBS surface
				// create point on surface node which will be used to
				// attach the emitter to the surface so that the emitter
				// will move with the surface
				// - also connect the normal of the surface so that the
				//   emitter always points along the normal
				//
				string $srfpoint = ($objname + "Loc");
				createNode "pointOnSurfaceInfo" -n $srfpoint;
				setAttr ($srfpoint + ".u") $u;
				setAttr ($srfpoint + ".v") $v;
				connectAttr ($parent + ".local") ($srfpoint + ".is");
				connectAttr ($srfpoint + ".position") ($objname + ".translate");
				connectAttr ($srfpoint + ".nx") ($objname + ".directionX");
				connectAttr ($srfpoint + ".ny") ($objname + ".directionY");
				connectAttr ($srfpoint + ".nz") ($objname + ".directionZ");
			} else if ( $emitterSrfType[$slot] == 1 || $emitterSrfType[$slot] == 2) {		// mesh or subdiv surface
				setAttr ($objname + ".translateX") $x;
				setAttr ($objname + ".translateY") $y;
				setAttr ($objname + ".translateZ") $z;
				setAttr ($objname + ".directionX") $nx;
				setAttr ($objname + ".directionY") $ny;
				setAttr ($objname + ".directionZ") $nz;
			}
		}
	}
}

// This is the "Set Value Cmd" when the operation is deleting
// emitters. A surface ID, a grid index on the surface and the
// value associated with that grid index is passed.
//
global proc deleteEmitter(
	int $slot,
	int $index,
	float $val
)
{
	global string $emitterNamePrefix[];
	global string $emitterParticles[];
	global string $emitterGroupName[];

	if ( $emitterNamePrefix[$slot] != "" && $val > 0 ) {
		string $objname = $emitterNamePrefix[$slot] + $index;
		if ( `objExists $objname` ) {
			delete $objname;
		}
		string $particles = $emitterParticles[$slot] + $index;
		if ( `objExists $particles` ) {
			delete $particles;
		}
		string $srfpoint = ($objname + "Loc");
		if ( `objExists $srfpoint` ) {
			delete $srfpoint;
		}

		// if there is a group and it's empty delete it
		//
		if ( `objExists $emitterGroupName[$slot]` ) {
			string $children[] = `listRelatives -c $emitterGroupName[$slot]`;

			if ( size($children) == 0 ) {
				delete $emitterGroupName[$slot];
			}
		}
	}
}

// This is the "Set Value Cmd" when the operation is changing
// particle render type. A surface ID, a grid index on the
// surface and the value associated with that grid index is
// passed.
//
global proc changeParticleRenderType(
	int $slot,
	int $index,
	float $val
)
{
	global string $emitterNamePrefix[];
	global string $emitterParticles[];
	global int $curRenderType;

	if ( $emitterNamePrefix[$slot] != "" && $val > 0 ) {
		string $particles = $emitterParticles[$slot] + $index;
		if ( `objExists $particles` ) {
			setAttr ($particles + ".particleRenderType") $curRenderType;
		}
	}
}

proc setObjectAttr(
	string $object,
	float $val
)
{
	global string $modifyAttr;
	global string $modifyAttrCheck;
	global string $modifyAttrType;

	if ( `objExists $object` ) {
		// if the object exists, check if the attribute
		// needs to be checked for existence
		//
		if ( $modifyAttrCheck != "" ) {
			string $shapes[] = `ls -dag -shapes $object`;
			if ( ! `attributeQuery -n $shapes[0] -ex $modifyAttrCheck` ) {
				addAttr -ln $modifyAttrCheck -at $modifyAttrType $shapes[0];
			}
		}
		setAttr ($object + $modifyAttr) $val;
	}
}

proc float getObjectAttr(
	string $object
)
{
	global string $modifyAttr;
	global string $modifyAttrCheck;

	if ( `objExists $object` ) {
		// if the object exists, check if the attribute
		// needs to be checked for existence
		//
		if ( $modifyAttrCheck != "" ) {
			string $shapes[] = `ls -dag -shapes $object`;
			if ( ! `attributeQuery -n $shapes[0] -ex $modifyAttrCheck` ) {
				return 0.0;
			}
		}
		return (float) `getAttr ($object + $modifyAttr)`;
	} else {
		return 0.0;
	}
}

// This is the "Set Value Cmd" when the operation is setting
// an emitter's attribute. A surface ID, a grid index on the
// surface and the value associated with that grid index is
// passed.
//
global proc setEmitterAttr(
	int $slot,
	int $index,
	float $val
)
{
	global string $emitterNamePrefix[];

	if ( $emitterNamePrefix[$slot] != "" ) {
		// generate the name of the emitter
		//
		string $objname = $emitterNamePrefix[$slot] + $index;
		setObjectAttr( $objname, $val );
	}
}

// This is the "Get Value Cmd" when the operation is setting
// an emitter's attribute. A surface ID, a grid index on the
// surface is passed.
//
global proc float getEmitterAttr(
	int $slot,
	int $index
)
{
	global string $emitterNamePrefix[];

	if ( $emitterNamePrefix[$slot] != "" ) {
		// generate the name of the emitter
		//
		string $objname = $emitterNamePrefix[$slot] + $index;
		return getObjectAttr( $objname );
	} else {
		return 0.0;
	}
}

// This is the "Set Value Cmd" when the operation is setting
// a particle shape's attribute. A surface ID, a grid index
// on the surface and the value associated with that grid
// index is passed.
//
global proc setParticlesAttr(
	int $slot,
	int $index,
	float $val
)
{
	global string $emitterNamePrefix[];
	global string $emitterParticles[];

	if ( $emitterNamePrefix[$slot] != "" ) {
		// generate the name of the particle shape
		//
		string $objname = $emitterParticles[$slot] + $index;
		setObjectAttr( $objname, $val );
	}
}

// This is the "Get Value Cmd" when the operation is setting
// an emitter's attribute. A surface ID, a grid index on the
// surface is passed.
//
global proc float getParticlesAttr(
	int $slot,
	int $index
)
{
	global string $emitterNamePrefix[];
	global string $emitterParticles[];

	if ( $emitterNamePrefix[$slot] != "" ) {
		// generate the name of the emitter
		//
		string $objname = $emitterParticles[$slot] + $index;
		return getObjectAttr( $objname );
	} else {
		return 0.0;
	}
}
