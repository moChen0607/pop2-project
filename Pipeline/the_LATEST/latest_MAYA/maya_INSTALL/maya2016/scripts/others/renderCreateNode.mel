// Copyright (C) 1997-2014 Autodesk, Inc., and/or its licensors.
// All rights reserved.
//
// The coded instructions, statements, computer programs, and/or related
// material (collectively the "Data") in these files contain unpublished
// information proprietary to Autodesk, Inc. ("Autodesk") and/or its licensors,
// which is protected by U.S. and Canadian federal copyright law and by
// international treaties.
//
// The Data is provided for use exclusively by You. You have the right to use,
// modify, and incorporate this Data into other products for purposes authorized 
// by the Autodesk software license agreement, without fee.
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND. AUTODESK
// DOES NOT MAKE AND HEREBY DISCLAIMS ANY EXPRESS OR IMPLIED WARRANTIES
// INCLUDING, BUT NOT LIMITED TO, THE WARRANTIES OF NON-INFRINGEMENT,
// MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE, OR ARISING FROM A COURSE 
// OF DEALING, USAGE, OR TRADE PRACTICE. IN NO EVENT WILL AUTODESK AND/OR ITS
// LICENSORS BE LIABLE FOR ANY LOST REVENUES, DATA, OR PROFITS, OR SPECIAL,
// DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES, EVEN IF AUTODESK AND/OR ITS
// LICENSORS HAS BEEN ADVISED OF THE POSSIBILITY OR PROBABILITY OF SUCH DAMAGES.

//
//  Procedure Name:
//      createRenderNode
//
//  Description:
//		Procedure to popup the render creation window.
//
//  Input Arguments:
//		A flag specifying which types of render nodes to create.
//		Currently "-all", "-allWithTexturesUp", "-allWithShadersUp", 
//		"-allWithLightsUp", "-textures", "-shadersSG", "-shaders", 
//		"-lights", "-utilities" are supported.
//
//      The command to run after the a node has been created. The name
//      of the created node will substituted "%node" in the command
//      string. If an empty string is passed for the command nothing
//      will be done. Currently the command is only attached to the
//      buttons in the texture tab.
//
//		If a command is specified the createRenderNode window will be
//		closed.
//
//  Return Value:
//      None.
//
//////////////////////////////////////////////////////////////////////
//
//  Procedure Name:
//      createRenderNodeCB
//
//  Description:
//		Procedure to create the node classified as specifed by the inputs
//
//  Input Arguments:
//		$as - 
//		A flag specifying which how to classify the node created.
//		Choices:
//			-as2DTexture : 2d textures
//			-as3DTexture : 3d textures
//			-asEnvTexture : Environment textures
//			-asShader : as a shader
//			-asLight : as a light
//			-asUtility : as a rendering utility node
//
//      $flag - 
//			A secondary flag used to make decisions in combination with $as.
//			Choices:
//				-asNoShadingGroup : for materials; create without a shading group
//				-asDisplacement : for anything; map the created node 
//					to a displacement material.
//				-asUtility : for anything; do whatever the $as flag says,
//					but also classify as a utility
//				-asPostProcess : for any postprocess node
//
//		$type - 
//			The type of node to be created.
//
//		$command - 
//			A command entered by the user when invoking createRenderNode.
//		The command will substitute the string %node with the name of the
//		node it creates.  createRenderWindow will be closed if a command
//		is not the null string ("").
//
//  Return Value:
//      None.
//

//
// Function returns true if the node handles image files as texture.
//
proc int isNodeOfFileType( string $type )
{
	if( $type == "file" || $type == "psdFileTex" )
		return 1 ;

	return 0 ;
}

global proc string renderCreateNode(
	string $as, string $flag, string $type, string $command,
	int $projection, int $stencil, int $placement, int $shadingGroup,
	int $createAndDrop, string $editor)
{
	string $node;
	string $cmd;
	string $temp;
	string $image;
	if( $type == "fluidTexture3D" ){
		$placement = false;
	}
	
	if ($as == "-asTexture") {

		$cmd = "shadingNode -asTexture "+$type;
		$node = `evalEcho $cmd`;
	}
	else if ($as == "-as2DTexture") {

    	    // ADSK_CLR_MGT_BEGIN
	    string $isColorManagedOption;

	    if ( isNodeOfFileType($type) )
 	    {
	        $isColorManagedOption = "-isColorManaged ";
	    }
   	    // ADSK_CLR_MGT_END

	    if ($projection) {
			$cmd = "shadingNode -asTexture projection";
            $node = `evalEcho $cmd`;

			$cmd = "shadingNode -asTexture " + $isColorManagedOption + $type;
			$image = `evalEcho $cmd`;

			$cmd = "shadingNode -asUtility place3dTexture";
            string $place3d = `evalEcho $cmd`;

			$cmd = ("connectAttr "+$place3d+".wim[0] "+$node+".pm");
			evalEcho $cmd;
			
			$cmd = ("connectAttr "+$image+".outColor "+$node+".image");
			evalEcho $cmd;

			if ($placement) {
				$cmd = "shadingNode -asUtility place2dTexture";
				string $place2d = `evalEcho $cmd`;

				// Correct #repeats for certain 2d textures
				if ($type == "checker" || $type == "bulge" || 
					$type == "cloth" || $type == "grid") {
					setAttr ($place2d + ".repeatU") 4;
					setAttr ($place2d + ".repeatV") 4;
				} else if ( isNodeOfFileType( $type) ) {
					fileTexturePlacementConnect $image $place2d;
                } 
				$cmd = ("connectAttr "+$place2d+".outUV "+$image+".uv");
				evalEcho $cmd;
				$cmd = ("connectAttr "+$place2d+".outUvFilterSize "+$image+".uvFilterSize");
				evalEcho $cmd;
			}
		}
		else if ($stencil) {
			$cmd = "shadingNode -asUtility stencil";
            $node = `evalEcho $cmd`;

			$cmd = "shadingNode -asTexture " + $isColorManagedOption + $type;
			$image = `evalEcho $cmd`;
			
			$cmd = ("connectAttr "+$image+".outColor "+$node+".image");
			evalEcho $cmd;

			if ($placement) {
				$cmd = "shadingNode -asUtility place2dTexture";
				string $place2d = `evalEcho $cmd`;

				$cmd = "shadingNode -asUtility place2dTexture";
				string $placeStencil = `evalEcho $cmd`;
				
                // Correct #repeats for certain 2d textures
                if ($type == "checker" || $type == "bulge" || 
                    $type == "cloth" || $type == "grid") {
                    setAttr ($place2d + ".repeatU") 4;
                    setAttr ($place2d + ".repeatV") 4;        
				} 
				else if ( isNodeOfFileType( $type) ) {
					// special connections for file texture
					fileTexturePlacementConnect $image $place2d;
                }
				// connect texture placement
				$cmd = ("connectAttr "+$place2d+".outUV "+$image+".uv");
				evalEcho $cmd;
				$cmd = ("connectAttr "+$place2d+".outUvFilterSize "+$image+".uvFilterSize");
				evalEcho $cmd;
				$cmd = ("connectAttr "+$placeStencil+".outUV "+$node+".uv");
				evalEcho $cmd;
				$cmd = ("connectAttr "+$placeStencil+".outUvFilterSize "+$node+".uvFilterSize");
				evalEcho $cmd;
				// redefine UV space for input texture
				$cmd = ("connectAttr "+$placeStencil+".outUV "+$place2d+".uv");
				evalEcho $cmd;
				$cmd = ("connectAttr "+$placeStencil+".outUvFilterSize "+$place2d+".uvFilterSize");
				evalEcho $cmd;
			}
		}
		else {
			$cmd = ("shadingNode -asTexture " + $isColorManagedOption + $type);

			$node = `evalEcho $cmd`;
			$image = $node;

			if ($placement) {
				$cmd = "shadingNode -asUtility place2dTexture";
				string $place2d = `evalEcho $cmd`;
				
                // Correct #repeats for certain 2d textures
                if ($type == "checker" || $type == "bulge" || 
                    $type == "cloth" || $type == "grid") {
                    setAttr ($place2d + ".repeatU") 4;
                    setAttr ($place2d + ".repeatV") 4;        
				} else if ( isNodeOfFileType( $type) ) {
					fileTexturePlacementConnect $node $place2d;
                } 
				$cmd = ("connectAttr "+$place2d+".outUV "+$node+".uv");
				evalEcho $cmd;
				$cmd = ("connectAttr "+$place2d+".outUvFilterSize "+$node+".uvFilterSize");
				evalEcho $cmd;
			}
		}
	}
	else if ($as == "-as3DTexture") {
		// Warning messsage that a projection node will not be created. 
		if ($projection)
            warning (uiRes("m_renderCreateNode.kProjectionNotCreatedS"));

		$cmd = "shadingNode -asTexture "+$type;
		$node = `evalEcho $cmd`;
		$image = $node;

		if ($placement) {
			$cmd = "shadingNode -asUtility place3dTexture";
			string $place3d = `evalEcho $cmd`;

			$cmd = ("connectAttr "+$place3d+".wim[0] "+$node+".pm");
			evalEcho $cmd;
		}
	}
	else if ($as == "-asEnvTexture") {
        // Warning messsage that a projection node will not be created.
        if ($projection)
            warning (uiRes("m_renderCreateNode.kProjectionNotCreatedE"));

		$cmd = "shadingNode -asTexture "+$type;
		$node = `evalEcho $cmd`;
		$image = $node;

		if ($placement) {
			$cmd = "shadingNode -asUtility place3dTexture";
            string $place3d = `evalEcho $cmd`;

            // Connect the placement matrix
            $cmd = ("connectAttr "+$place3d+".wim[0] "+$node+".pm");
            evalEcho $cmd;

		}
	}
	else if ($as == "-asShader" && $shadingGroup &&
			 $flag != "-asNoShadingGroup") {
		$cmd = ("shadingNode " + $as + " " + $type);
		$node =  `evalEcho $cmd`;
		$image = $node;

		$cmd = "sets -renderable true -noSurfaceShader true -empty -name "+$node+"SG";
		string $group = `evalEcho $cmd`;

		if ($type == "dx11Shader" && `optionVar -exists "dx11ShaderDefaultEffect"`)
		{
			string $defaultShader = `optionVar -q "dx11ShaderDefaultEffect"`;
			string $cmd = ("setAttr -type \"string\" " + $node + ".shader \"" + $defaultShader + "\"");
			evalEcho $cmd;
		}

		if ($type == "ShaderfxShader" || $type == "StingrayPBS")
		{
			string $cmd = ( "shaderfx -sfxnode \"" + $node + "\" -initShaderAttributes" );
			evalEcho $cmd;
		}

		if ($type == "displacementShader")
		{
			string $cmd = ("connectAttr -f " + $node + ".displacement " + $group + "." + $flag);
			evalEcho $cmd;
		}
		else
		{
			string $cmd = ("connectAttr -f " + $node + ".outColor " + $group + "." + $flag);
			evalEcho $cmd;
			if( $type == "oceanShader" && $flag == "surfaceShader" ){
				// additionally hook up to displacement
				string $cmd = ("connectAttr -f " + $node + ".displacement " + $group + ".displacementShader");
				evalEcho $cmd;
				$cmd = ("connectAttr -f time1.outTime " + $node + ".time");
				evalEcho $cmd;
			}
		}
	}
	else if ($as == "-asLight") 
	{
		$cmd = ("shadingNode " + $as + " " + $type);
		string $parent = `evalEcho $cmd`;
		// Most lights are DAG objects, and the shape is the
		// children. Plug-in lights may be regular node, and in this
		// case they have no children.
		string $children[] = `listRelatives -children $parent`;
		if (size($children)>0)	{ $node = $children[0]; }
		else					{ $node = $parent; }
		$image = $node;
	} 
	else if( $type == "renderLayer" ){
        $cmd = "createRenderLayer -empty";
        $node =  `evalEcho $cmd`;
        $image = $node;
   	}
   	else {
		$cmd = ("shadingNode " + $as + " " + $type);
		$node =  `evalEcho $cmd`;
		$image = $node;
	}

    if ($flag == "-asDisplacement") {
        $cmd = "shadingNode -asShader displacementShader";
        string $disp = `evalEcho $cmd`;

        $cmd = ("connectAttr " + $node+".outAlpha " + $disp+".displacement");
        evalEcho $cmd;

        // now, reassign $node to be the displacement node
        $node=$disp;
    }
	if( ($type == "fluidTexture3D" || $type == "fluidTexture2D" || $type == "fluidShape" ) && size($image) > 0){
	
        $cmd = ("connectAttr time1.outTime " + $image+".currentTime");
        evalEcho $cmd;
	}
	
	if ($type == "renderPass")
	{
	    getRenderPassPresets(); // make sure $gRenderPassPresetPath is initialized
	    global string $gRenderPassPresetPath[];
	    string $path = "";
	    // We initialize with the beauty pass preset.
	    for ($curPath in $gRenderPassPresetPath)
	    {
	        if( size( match( "beauty.mel", $curPath ) ) )
	        {
	            $path = $curPath;
	        }
	    }
	    
        if(`filetest -e $path`){
			$cmd = "applyAttrPreset \"" + $node + "\" \"" + $path + "\" 1"; 
			evalEcho($cmd);
        }
        else{
            string $warn = (uiRes("m_renderCreateNode.kNoBeautyPreset"));
            warning($warn);
        }
        
        // Attach it to the current render layer
        string $currentLayer = `editRenderLayerGlobals -q -currentRenderLayer`;
        evalEcho("connectAttr -nextAvailable " + $currentLayer + ".renderPass " + $node + ".owner");
    }

    select $node;

	if ($command != "") {
		string $cmd = substitute("%node", $command, $node);
		$cmd = substitute("%type", $cmd, ("\"" + $type + "\""));
		evalEcho $cmd;
	}

	if($createAndDrop != 0) {
		hyperShade -rcd $node $editor;
	}

	return $node;
}
