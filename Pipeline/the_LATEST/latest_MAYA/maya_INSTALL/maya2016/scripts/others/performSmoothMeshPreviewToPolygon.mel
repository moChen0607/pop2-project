// Copyright (C) 1997-2014 Autodesk, Inc., and/or its licensors.
// All rights reserved.
//
// The coded instructions, statements, computer programs, and/or related
// material (collectively the "Data") in these files contain unpublished
// information proprietary to Autodesk, Inc. ("Autodesk") and/or its licensors,
// which is protected by U.S. and Canadian federal copyright law and by
// international treaties.
//
// The Data is provided for use exclusively by You. You have the right to use,
// modify, and incorporate this Data into other products for purposes authorized 
// by the Autodesk software license agreement, without fee.
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND. AUTODESK
// DOES NOT MAKE AND HEREBY DISCLAIMS ANY EXPRESS OR IMPLIED WARRANTIES
// INCLUDING, BUT NOT LIMITED TO, THE WARRANTIES OF NON-INFRINGEMENT,
// MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE, OR ARISING FROM A COURSE 
// OF DEALING, USAGE, OR TRADE PRACTICE. IN NO EVENT WILL AUTODESK AND/OR ITS
// LICENSORS BE LIABLE FOR ANY LOST REVENUES, DATA, OR PROFITS, OR SPECIAL,
// DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES, EVEN IF AUTODESK AND/OR ITS
// LICENSORS HAS BEEN ADVISED OF THE POSSIBILITY OR PROBABILITY OF SUCH DAMAGES.

//
// Description:
// Takes all poly objects selected that are in smooth mesh preview mode and performs a poly
// smooth on them so that the smoothed object matches the smooth preview.
//
global proc performSmoothMeshPreviewToPolygon()
{
	string $polyObjects[] = `filterExpand -expand true -fullPath true -selectionMask 12`;
	if (0 != `size $polyObjects`)
	{
		int $convertedAtLeastOne = false;

		for ($poly in $polyObjects)
		{
			int $displayStyle = `getAttr ($poly + ".displaySmoothMesh")`;
			if (0 == $displayStyle)
				continue;

			int $smoothLevel = `getAttr ($poly + ".smoothLevel")`;
			float $continuity = `getAttr ($poly + ".continuity")`;
			int $smoothUVs = `getAttr ($poly + ".smoothUVs")`;
			int $keepBorder = `getAttr ($poly + ".keepBorder")`;
			int $keepHardEdge = `getAttr ($poly + ".keepHardEdge")`;
			int $keepMapBorders = `getAttr ($poly + ".keepMapBorders")`;
			int $constructionHistory = `constructionHistory -q -tgl`;
			int $boundaryRule = `getAttr ($poly + ".boundaryRule")`; 
			int $subdivisionType = `getAttr ($poly + ".smoothDrawType")`; 
			
			setAttr ($poly + ".displaySmoothMesh") 0;
			setAttr ($poly + ".smoothLevel") 2;

			polySmooth  -method 0 
						-sdt $subdivisionType
						-bnr $boundaryRule 
						-dv $smoothLevel 
						-c $continuity 
						-kb $keepBorder 
						-khe $keepHardEdge 
						-kmb $keepMapBorders
						-suv $smoothUVs
						-ch $constructionHistory
						$poly;

			$convertedAtLeastOne = true;
		}

		if (!$convertedAtLeastOne)
		{
			string $warn = (uiRes("m_performSmoothMeshPreviewToPolygon.kNoConversionsMade"));
			warning($warn);
		}
	}
	else
	{
		string $warn = (uiRes("m_performSmoothMeshPreviewToPolygon.kNoSelectedPolys"));
		warning($warn);
	}
}
