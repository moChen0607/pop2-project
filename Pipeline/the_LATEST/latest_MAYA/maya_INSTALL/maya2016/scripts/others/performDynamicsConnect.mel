// Copyright (C) 1997-2014 Autodesk, Inc., and/or its licensors.
// All rights reserved.
//
// The coded instructions, statements, computer programs, and/or related
// material (collectively the "Data") in these files contain unpublished
// information proprietary to Autodesk, Inc. ("Autodesk") and/or its licensors,
// which is protected by U.S. and Canadian federal copyright law and by
// international treaties.
//
// The Data is provided for use exclusively by You. You have the right to use,
// modify, and incorporate this Data into other products for purposes authorized 
// by the Autodesk software license agreement, without fee.
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND. AUTODESK
// DOES NOT MAKE AND HEREBY DISCLAIMS ANY EXPRESS OR IMPLIED WARRANTIES
// INCLUDING, BUT NOT LIMITED TO, THE WARRANTIES OF NON-INFRINGEMENT,
// MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE, OR ARISING FROM A COURSE 
// OF DEALING, USAGE, OR TRADE PRACTICE. IN NO EVENT WILL AUTODESK AND/OR ITS
// LICENSORS BE LIABLE FOR ANY LOST REVENUES, DATA, OR PROFITS, OR SPECIAL,
// DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES, EVEN IF AUTODESK AND/OR ITS
// LICENSORS HAS BEEN ADVISED OF THE POSSIBILITY OR PROBABILITY OF SUCH DAMAGES.

//
//
//  Creation Date:  April, 1997
//
//  Description:
//      This script contains code to connect fields/emitters/
//		collisions to objects.
//		performDynamicsConnect is called when a user selects
//      a Connect menu item.
//
//  Input Arguments to performDynamics():
//		int $whichConnection -- 1 = field; 2 = emitter; 3 = collision
//
//  Return Value:
//      None.
//
//
//  ========== performDynamicsConnect ==========
//
//  SYNOPSIS
//		Issue the appropriate connectDynamic command.
//
global proc performDynamicsConnect( int $whichConnection)
{
	string $selected[] = `ls -sl`;
	string $cmd;
	int $i;
	string $cmdStart = "connectDynamic";
	int $len = size($selected);
	int $numConnections =  $len - 1;

	if ($numConnections < 1)
	{
		string $theMsg;
		string $theType;
		switch ($whichConnection) 
		{
			case 1: {
				$theType = (uiRes("m_performDynamicsConnect.kField"));
				break;
			}
			case 2: {
				$theType = (uiRes("m_performDynamicsConnect.kEmitter"));
				break;
			}
			case 3: {
				$theType = (uiRes("m_performDynamicsConnect.kCollision"));
				break;
			}
		}

		if ($numConnections  == -1)
		{
			$theMsg = (uiRes("m_performDynamicsConnect.kNothingSelected"));
		}
		else if ($numConnections == 0)
		{
			$theMsg = (uiRes("m_performDynamicsConnect.kOnlyOneObjectSelected"));
		}

		string $warnFormat = (uiRes("m_performDynamicsConnect.kSelectFirstObjects"));
		string $warnSelect = `format -stringArg $theType $warnFormat`;
		string $warnMsg = ($theMsg + "  " + $warnSelect);
		warning($warnMsg);
		return;
	}

	// Create the command args for the selected command, and
	// issue the command.
	//
	switch ($whichConnection) 
	{
    	case 1: {
			string $field, $objects;
			string $fields[] = `ls -sl -typ field`;
			int $numFields = size($fields);
			if($numFields > 0) {
				for ($i = 0; $i < $len; $i++) {
					string $isField[] = `ls -type field $selected[$i]`;
					if (0 == size($isField)) {
						$objects += (" " + $selected[$i]);
					}
				}
				for ($field in $fields) {
					$cmd += ($cmdStart + " -f " + $field + $objects +"; ");
					$cmd += "; ";
				}
			} else {
				// if there's no dull normal fields selected...
				// see if there's any fluids - and use them as fields instead
				string $fluids[];
				int $numFluids = 0;
				for ($i = 0; $i < $len; $i++) {
					string $fluidName = getFluidShape($selected[$i]);
					if (0 == size($fluidName)) {
						$objects += (" " + $selected[$i]);
					} else {
						$fluids[$numFluids++]  = $fluidName;
					}
				}
				for ($fluid in $fluids) {
					$cmd += ($cmdStart + " -f " + $fluid + $objects +"; ");
					$cmd += "; ";
				}

			}
			break;
		}			
		case 2:

			$cmd = $cmdStart + " -em " + $selected[$numConnections];
			break;

		case 3:
			// Collision.  Must check whether last two
			// objects in selection list are the two parts of a
			// soft body.  If so, use the geometry's name (which
			// will be second to last in list).  The particle shape
			// will be last.  
			//
			string $softQuery = "soft -q " + $selected[$len-1] + 
								" " + $selected[$len-2];
			int $leadIsSoft = eval( $softQuery );
			if ($leadIsSoft)
			{
				$numConnections = $numConnections - 1;
			}
			$cmd = $cmdStart + " -c " + $selected[$numConnections];
			break;
	}

	if ($whichConnection != 1) {
		for ($i = 0; $i < $numConnections; $i++) 
		{
			$cmd = $cmd + " " + $selected[$i];
		}
	}
	evalEcho ($cmd);
}

