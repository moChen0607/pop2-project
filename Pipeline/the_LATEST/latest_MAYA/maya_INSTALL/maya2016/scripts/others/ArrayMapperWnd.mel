// Copyright (C) 1997-2014 Autodesk, Inc., and/or its licensors.
// All rights reserved.
//
// The coded instructions, statements, computer programs, and/or related
// material (collectively the "Data") in these files contain unpublished
// information proprietary to Autodesk, Inc. ("Autodesk") and/or its licensors,
// which is protected by U.S. and Canadian federal copyright law and by
// international treaties.
//
// The Data is provided for use exclusively by You. You have the right to use,
// modify, and incorporate this Data into other products for purposes authorized 
// by the Autodesk software license agreement, without fee.
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND. AUTODESK
// DOES NOT MAKE AND HEREBY DISCLAIMS ANY EXPRESS OR IMPLIED WARRANTIES
// INCLUDING, BUT NOT LIMITED TO, THE WARRANTIES OF NON-INFRINGEMENT,
// MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE, OR ARISING FROM A COURSE 
// OF DEALING, USAGE, OR TRADE PRACTICE. IN NO EVENT WILL AUTODESK AND/OR ITS
// LICENSORS BE LIABLE FOR ANY LOST REVENUES, DATA, OR PROFITS, OR SPECIAL,
// DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES, EVEN IF AUTODESK AND/OR ITS
// LICENSORS HAS BEEN ADVISED OF THE POSSIBILITY OR PROBABILITY OF SUCH DAMAGES.

//
//
//  Creation Date:	July 1, 1997
//
//  Description:
//		Helper dialog to launch the arrayMapper command.
//
//	Contents:
//		makeMonochromRampAMW	Make monochromatic ramp.
//		okayAMW()				Callback for the OK button.
//		makeAttrName()			Create a new attribute name.
//		replaceBtns()			Rebuild the buttons in the menu.
//		makeAryAttrList()		Get all array attributes from shape.
//		create()				Build the dialog.
//		register()				Register the callbacks.
// 		ArrayMapperWnd()		Main entry point. Launch dialog.


global string	$gArrayMapperObject = "";
global string	$gArrayMapperAttr = "";
global string   $attrLongNameList[];
global string   $attrNiceNameList[];

//  ========== niceNameToLongName ===========
//
// Description:
//      Given a nice name, it will try to return
//      its corresponding long name.
//

proc string niceNameToLongName( string $niceName )
{
    global string   $attrLongNameList[];
    global string   $attrNiceNameList[];
    int $length = `size($attrNiceNameList)`;
    for($i = 0; $i < $length; $i++)
    {
        if ($niceName == $attrNiceNameList[$i])
        {
            return $attrLongNameList[$i] ;
        }
    }
    return $niceName ;
}

//  ========== storeAttrName ===========
//
// Description:
//      Stores attribute's long name and nice name
//      for later query.
//

proc storeAttrName( string $longName, string $niceName )
{
    global string   $attrLongNameList[];
    global string   $attrNiceNameList[];
    int $length = `size($attrLongNameList)` ;
    for($i = 0; $i < $length; $i++)
    {
        if ( $attrLongNameList[$i] == $longName )
        {
            $attrNiceNameList[$i] = $niceName ;
            return ;
        }
    }
    $attrLongNameList[$length] = $longName ;
    $attrNiceNameList[$length] = $niceName ;
}

//  ========== getAttrNiceName ===========
//
// Description:
//      Return the nice name of node's attribute.
//
proc string getAttrNiceName(string $node, string $longName)
{
    return `attributeName -nice ($node + "." + $longName)`;

}


//  ========== makeMonochromRampAMW ==========
//
//  Description:
//		Make the ramp monochromatic if it is connected
//		to a doubleArray attribute (vs vectorArray).
//

global proc  makeMonochromRampAMW( string $node, string $attr )
{

	// Check if the attribute is of type doubleArray.
	//
	string	$dblAttrAry[] = `particle -q -ppd $node`;
	int		$dblAttrCnt = size( $dblAttrAry );
	int		$isDoubleArray = 0;

	for ($i = 0; $i < $dblAttrCnt; $i++)
	{
		if ($attr == $dblAttrAry[$i])
		{
			$isDoubleArray = 1;
			break;
		}
	}


	// If attribute is double array, then make the
	// ramp monochromatic.
	//
	if ($isDoubleArray)
	{
		// Need to find the ramp node.
		//
		string	$cnctAry[];
		string	$arrayMapperNode;
		string	$rampNode;

		$cnctAry = `listConnections -s true -d false ($node+"."+$attr)`;
		$arrayMapperNode = $cnctAry[0];
		$cnctAry = `listConnections -s true -d false ($arrayMapperNode+".computeNode")`;
		$rampNode = $cnctAry[0];


		// Set the ramp colors and positions to a monochromatic ramp.
		//
		setAttr ($rampNode+".colorEntryList[0].color") -type double3 1 1 1 ;
		setAttr ($rampNode+".colorEntryList[1].color") -type double3 0.5 0.5 0.5 ;
		setAttr ($rampNode+".colorEntryList[2].color") -type double3 0 0 0 ;
		setAttr ($rampNode+".colorEntryList[1].position") 0.5;
		setAttr ($rampNode+".colorEntryList[2].position") 1.0;
	}


}  // makeMonochromRampAMW //



//  ========== okayAMW ==========
//
//  Description:
//		Callback for the OK button. This builds the actual
//		arrayMapper command string, and executes it.
//

global proc  okayAMW( string $win, string $rowLyt )
{
	setParent $win;

	// Start building the command string.
	//
	global string	$gArrayMapperObject;
	global string	$gArrayMapperAttr;
	string			$cmd, $inU, $inV;

	$cmd = "arrayMapper -target "+$gArrayMapperObject+" -destAttr "+$gArrayMapperAttr;


	// Determine inputU flag.
	//
	int		$uIndex = `optionMenu -q -select uSourceOM`;

	switch ($uIndex)
	{
		case 1 :
			// do nothing
			break;

		case 2 :
			$cmd += " -inputU ageNormalized";
			break;

		default:
            string $menuItemLabel = `optionMenu -q -value uSourceOM` ;
			$cmd += " -inputU " + niceNameToLongName($menuItemLabel) ;
			break;
	}


	// Determine inputV flag.
	//
	int		$vIndex = `optionMenu -q -select vSourceOM`;

	switch ($vIndex)
	{
		case 1 :
			// do nothing
			break;

		case 2 :
			$cmd += " -inputV ageNormalized";
			break;

		default:
            string $menuItemLabel = `optionMenu -q -value vSourceOM` ;
			$cmd += " -inputV " + niceNameToLongName($menuItemLabel) ;
			break;
	}


	// Determine -type flag.
	//
	int		$computeNode = `optionMenu -q -select mapOM`;

	switch ($computeNode)
	{
		case 1 :
			// do nothing
			break;

		case 2 :
			$cmd += " -type ramp";
			break;

		default :
			// Any button after the first two, contains the name of
			// a ramp node to use.
			//
			string	$nodeName = `optionMenu -q -v mapOM`;
			$cmd += " -mapTo "+$nodeName;
			break;
	}


	// Execute the arrayMapper command.
	//
	evalEcho( $cmd );
	window -e -vis 0 $win;


	// Special case for monochromatic rmap. If the destination
	// attribute is a doubleArray, then fix the ramp to be
	// monochormatic.
	//
	if ($computeNode == 2)
	{
		makeMonochromRampAMW( $gArrayMapperObject, $gArrayMapperAttr );
	}


	// If the row layout was specifed, then update it.
	//
	if (size( $rowLyt ))
	{
		AEgenericUpdateOneTextfield( $gArrayMapperObject, $gArrayMapperAttr, $rowLyt );
	}


}  // okayAMW //



//  ========== makeAttrName ==========
//
//  Description:
//		Given an attribute name, insert the given character
//		before the 'PP' characters if they are present.
//

proc string  makeAttrName( string $char, string $node, string $name )
{
	string  $s1 = $char+"PP";
	string	$s2 = substitute( "PP", $name, $s1 );

	if ($s2 == $name)
	{
		$s2 = $name+$char;
	}

    // TODO:
    // Logged as bug 331611
    // Here we require to access to a dynamic attribute nice name
    // before it was actually added to the node.
    // We are planning to add a flag to "attributeName", so that
    // this command can handle this logic.
    // When it is done, we should repalce the following codes with
    // "attributeName"
    string $niceName = "";
    // If this dynamic attribute is already added
    // We query its nice name via "attributeName -nice"
    if (`attributeQuery -exists -n $node $s2`)
    {
        $niceName = getAttrNiceName($node, $s2);
    }
    // If not, we try to query its localized string
    // using "displayString" directory.
    else
    {
        string $res_key = "n_nParticle.a_" + $s2 + "_niceName" ;
        if (`displayString -exists $res_key`)
        {
            $niceName = `displayString -q -v $res_key`;
        }
        else
        {
            $niceName = $s2 ;
        }
    }

    storeAttrName( $s2, $niceName) ;
    return $niceName;

}  // makeAttrName //



//  ========== replaceBtns ==========
//
//  Description:
//		Replace the buttons in the menu with 
//		the new buttons.
//

proc  replaceBtns( string $win, string $menu, string $newBtnAry[] )
{

	setParent $win;


	// Delete the old buttons.
	//
	string	$oldBtnAry[] = `optionMenu -q -ils $menu`;
	int		$oldBtnCnt = size( $oldBtnAry );

	for ($i = 0; $i < $oldBtnCnt; $i++)
	{
		deleteUI $oldBtnAry[$i];
	}


	// Add the new buttons.
	//
	int		$newBtnCnt = size( $newBtnAry );

	for ($i = 0; $i < $newBtnCnt; $i++)
	{
		menuItem -p $menu -l $newBtnAry[$i];
	}


}  // replaceBtns //



//  ========== makeAryAttrList ==========
//
//  Description:
//		Make a list of all array attributes available
//		in the particle shape which are suitable for
//		using as input attributes to the mapper node.
//		Make sure to remove the given attribute because
//		it is already being used as the output node.
//		Also, remove the ageNormalized attribute because
//		it is redundant with the "Particle's Age" item.
//

proc string[]  makeAryAttrList( string $win, string $node, string $outAttr )
{
	string	$attrList[] = `particle -q -ppd $node`;
	int		$attrCnt = size( $attrList );
	string	$aryList[];
	int		$len;
	int		$outCnt = 0;


	for ($i = 0; $i < $attrCnt; $i++)
	{
		if (($attrList[$i] != $outAttr) && ($attrList[$i] != "ageNormalized"))
		{
            string $longName = $attrList[$i] ;
            string $niceName = getAttrNiceName( $node, $longName ) ;
            storeAttrName( $longName, $niceName) ;
			$aryList[$outCnt++] = $niceName ;
		}
	}


	return( $aryList );


}  // makeAryAttrList //



//  ========== create ==========
//
//  SYNOPSIS
//		Create the window and all the controls.
//

proc  create( string $win )
{

	// Create window and base container widgets.
	//
	window 
		-title (uiRes("m_ArrayMapperWnd.kCreateRampOptions"))
		-widthHeight 400 400
		-minimizeButton false 
		-maximizeButton false
		-retain 
		-sizeable true
		-resizeToFitChildren false
		$win;

	formLayout -nd 100 workLyt;

	// This doesn't appear to be displayed
	//
	text -l "none" headerTxt;
		formLayout -e
			-af headerTxt left 4
			-af headerTxt top 4
			workLyt;

	string $none = (uiRes("m_ArrayMapperWnd.kNone"));
	optionMenu -l (uiRes("m_ArrayMapperWnd.kInputU")) uSourceOM;
		menuItem -l $none;
		formLayout -e 
			-af uSourceOM left 12 
			-ac uSourceOM top 4 headerTxt
			workLyt;

	optionMenu -l (uiRes("m_ArrayMapperWnd.kInputV")) vSourceOM;
		menuItem -l $none;
		formLayout -e 
			-af vSourceOM left 12 
			-ac vSourceOM top 4 uSourceOM
			workLyt;

	optionMenu -l (uiRes("m_ArrayMapperWnd.kMapTo")) mapOM;
		menuItem -l $none;
		formLayout -e 
			-af mapOM left 10
			-ac mapOM top 4 vSourceOM
			workLyt;

	button -l (uiRes("m_ArrayMapperWnd.kOk")) -w 100 -h 26 okBtn;
		formLayout -e 
			-ap okBtn left -50 25 
			-af okBtn bottom 4 
			workLyt;

	button -l (uiRes("m_ArrayMapperWnd.kCancel")) -w 100 -h 26 cancelBtn;
		formLayout -e 
			-ap cancelBtn left -50 75 
			-af cancelBtn bottom 4 
			workLyt;

	separator -horizontal true sep1;
		formLayout -e
			-af sep1 left 0
			-af sep1 right 0
			-ac sep1 bottom 4 okBtn
			workLyt;


}  // create //



//  ========== register ==========
//
//  Description:
//		Register the callbacks on the widgets.
//

proc  register( string $win )
{

	setParent $win;

	button -e -c ("window -e -vis 0 "+$win) cancelBtn;


}  // register //



//  ========== update ==========
//
//  Description:
//		Build the option menus to reflect the current
//		state of the scene.
//

proc  update( string $win, string $node, string $dstAttr, string $rowLyt )
{

	setParent $win;


	// Put the attribute name in the header text.
	//
	string $label = (uiRes("m_ArrayMapperWnd.kDestination"));
	text -e -l `format -s $dstAttr $label` headerTxt;

	// Get the available list of array attributes.
	//
	string	$attrAry[] = makeAryAttrList( $win, $node, $dstAttr );
	int		$attrCnt = size( $attrAry );

	// Set the first two buttons for the input option menus.
	//
	string  $none = (uiRes("m_ArrayMapperWnd.kNone2"));
	string	$btnAry[];
	$btnAry[0] = $none;
	$btnAry[1] = (uiRes("m_ArrayMapperWnd.kParticlesAge"));

	// Source U menu.
	//
	$btnAry[2] = makeAttrName( "U", $node, $dstAttr );

	for ($i = 0; $i < $attrCnt; $i++)
	{
		$btnAry[$i+3] = $attrAry[$i];
	}

	replaceBtns( $win, "uSourceOM", $btnAry );

	// Source V menu.
	//
	$btnAry[2] = makeAttrName( "V", $node, $dstAttr );
	replaceBtns( $win, "vSourceOM", $btnAry );
	optionMenu -e -sl 2 vSourceOM;

	// Map menu.
	//
	string	$mapBtns[];
	string	$rampAry[] = `ls -type ramp`;
	int		$rampCnt = size( $rampAry );

	$mapBtns[0] = $none;
	$mapBtns[1] = (uiRes("m_ArrayMapperWnd.kNewRamp"));

	for ($i = 0; $i < $rampCnt; $i++)
	{
		$mapBtns[$i+2] = $rampAry[$i];
	}

	replaceBtns( $win, "mapOM", $mapBtns );
	optionMenu -e -sl 2 mapOM;


	// Need to register a new callback each time because
	// the row layout changes. It gets passed in by
	// the textfield popup menu.
	//
	button -e -c ("okayAMW "+$win+" "+$rowLyt) okBtn;


}  // update //



//  ========== ArrayMapperWnd ==========
//
//  Description:
//		Main entry point. Must be last procedure in file.
//

global proc  ArrayMapperWnd( string $node, string $attr, string $rowLyt )
{
	string	$win = "ArrayMapperWnd";

	if (! `window -exists $win`)
	{
		create( $win );
		register( $win );
	}

	update( $win, $node, $attr, $rowLyt );


	// Save the node name and attribute in a global
	// variable, so the callback can get access to it.
	//
	global string	$gArrayMapperObject;
	global string	$gArrayMapperAttr;

	$gArrayMapperObject = $node;
	$gArrayMapperAttr = $attr;

	showWindow( $win );


}  // ArrayMapperWnd //
