// Copyright (C) 1997-2014 Autodesk, Inc., and/or its licensors.
// All rights reserved.
//
// The coded instructions, statements, computer programs, and/or related
// material (collectively the "Data") in these files contain unpublished
// information proprietary to Autodesk, Inc. ("Autodesk") and/or its licensors,
// which is protected by U.S. and Canadian federal copyright law and by
// international treaties.
//
// The Data is provided for use exclusively by You. You have the right to use,
// modify, and incorporate this Data into other products for purposes authorized 
// by the Autodesk software license agreement, without fee.
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND. AUTODESK
// DOES NOT MAKE AND HEREBY DISCLAIMS ANY EXPRESS OR IMPLIED WARRANTIES
// INCLUDING, BUT NOT LIMITED TO, THE WARRANTIES OF NON-INFRINGEMENT,
// MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE, OR ARISING FROM A COURSE 
// OF DEALING, USAGE, OR TRADE PRACTICE. IN NO EVENT WILL AUTODESK AND/OR ITS
// LICENSORS BE LIABLE FOR ANY LOST REVENUES, DATA, OR PROFITS, OR SPECIAL,
// DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES, EVEN IF AUTODESK AND/OR ITS
// LICENSORS HAS BEEN ADVISED OF THE POSSIBILITY OR PROBABILITY OF SUCH DAMAGES.

//
//
//  Creation Date:  22 April 1998
//
//  Description:
//		Initialize the option values for "cut curve at intersection"  menu item.
//
//  Input Arguments:
//      int action
//		  0 - just execute the "cut curve" operation
//        1 - show the option box dialog
//		  2 - drag to shelf
//
//  Return Value:
//      None.
//

proc setOptionVars(int $forceFactorySettings)
{
	// 	Use Global vs. Local tolerance (1 - use global, 2 - use local)
	//
	if ($forceFactorySettings || !`optionVar -exists cutCurveUseTol`) {
		optionVar -intValue cutCurveUseTol 1;
	}

	// "-rpo/-replaceOriginal" flag for detach commands.
	if ($forceFactorySettings || !`optionVar -exists cutCurveKeepOriginal`) {
		optionVar -intValue cutCurveKeepOriginal 0;
	}

	//	Tolerance
	//
	if ($forceFactorySettings || !`optionVar -exists cutCurveTol`) {
		optionVar -floatValue cutCurveTol 0.0001;
	}

	//  Direction Type (0 - don't use direction, 1 - use direction from
	//  option vars, 2 - use active view, 3 - use X axis, 4 - use Y axis, 5 - use Z,
	//	6 - use smart mode: use view vectors in ortho views but don't use direction
	//	in persp view. )
	//	Default value is to use smart mode.
	//
	if ($forceFactorySettings || !`optionVar -exists cutCurveUseDirection`) {
		optionVar -intValue cutCurveUseDirection 6;
	}

	//	Direction in x, y, z
	//
	if ($forceFactorySettings || !`optionVar -exists cutCurveDirX`) {
		optionVar -floatValue cutCurveDirX 0.0;
	}
	if ($forceFactorySettings || !`optionVar -exists cutCurveDirY`) {
		optionVar -floatValue cutCurveDirY 1.0;
	}
	if ($forceFactorySettings || !`optionVar -exists cutCurveDirZ`) {
		optionVar -floatValue cutCurveDirZ 0.0;
	}

	// Option to cut all curves with each other OR
	// cut all curves with last curve only
	//	1 - cut all curves with each other
	//	2 - cut all curves with last curve
	//
	if ($forceFactorySettings || 
		!`optionVar -exists cutCurveWithAllCurvesOrLastCurve`) {
		optionVar -intValue cutCurveWithAllCurvesOrLastCurve 1;
	}

	// Option to segment (cut the curve into pieces and keep all pieces) OR
	// to cut and keep the longest piece.
	// 1 - keep longest piece, 2 - keep all curve pieces
	// 3 - keep curve segments with curve points selected on them
	//
	if ($forceFactorySettings ||
		!`optionVar -exists cutCurveSegmentOrKeepLongest`) {
		optionVar -intValue cutCurveSegmentOrKeepLongest 2;
	}
}

//
//  Procedure Name:
//      cutCurveSetup
//
//  Description:
//		Update the state of the option box UI to reflect the cutCurve
//		option values.
//
//  Input Arguments:
//      parent               - Top level parent layout of the option box UI.
//                             Required so that UI object names can be 
//                             successfully resolved.
//
//		forceFactorySettings - Whether the option values should be set to
//                             default values.
//
//  Return Value:
//      None.
//
global proc cutCurveSetup(string $parent,
						  int $forceFactorySettings,
						  string $goToTool)
{
	//	Retrieve the option settings
	//
	setOptionVars($forceFactorySettings);
	cutCurveToolSetup( $forceFactorySettings, $goToTool );

	setParent $parent;

	//	Query the optionVar's and set the values into the controls.

	//	Set use direction or not:
	//  Direction Type (0 - don't use direction, 1 - use direction from
	//  option vars, 2 - use active view, 3 - use X axis, 4 - use Y axis, 5 - use Z)
	//	(6 - use smart mode: use view vectors in ortho views but don't use direction
	//	in persp view. )
	//
	int $useDir = `optionVar -query cutCurveUseDirection`;
	if( $useDir == 0 ) {
		radioButtonGrp -edit -select 2 cutCurveUseDirRadioGrp;
		radioButtonGrp -e -en 0 cutCurveDirectionGrp;
		radioButtonGrp -e -en 0 cutCurveDirectionGrp2;
		floatFieldGrp -edit -en 0 cutCurveDirectionField;
	} else if( $useDir == 6 ) {
		radioButtonGrp -edit -select 1 cutCurveUseDirRadioGrp;
		radioButtonGrp -e -en 0 cutCurveDirectionGrp;
		radioButtonGrp -e -en 0 cutCurveDirectionGrp2;
		floatFieldGrp -edit -en 0 cutCurveDirectionField;
	} else {
		radioButtonGrp -edit -select 1 cutCurveUseDirRadioGrp2;
		radioButtonGrp -e -en 1 cutCurveDirectionGrp;
		radioButtonGrp -e -en 1 cutCurveDirectionGrp2;
	}

	//	Set the direction radio button and the direction vector values.
	//
	switch( $useDir ) {
		case 1: 							// use direction from option vars
			floatFieldGrp -edit -en 1 cutCurveDirectionField;
		case 0:
		case 6:
			radioButtonGrp -e -select 2 cutCurveDirectionGrp2;
			float $dirX = `optionVar -query cutCurveDirX`;
			float $dirY = `optionVar -query cutCurveDirY`;
			float $dirZ = `optionVar -query cutCurveDirZ`;
			floatFieldGrp -edit -v $dirX $dirY $dirZ 0.0 cutCurveDirectionField;
			break;	
		case 2: 							// use active view
			radioButtonGrp -e -select 1 cutCurveDirectionGrp2;
			float $viewVector[] = nurbsViewDirectionVector(0);
			floatFieldGrp -e -v1 $viewVector[0] -v2 $viewVector[1]
				-v3 $viewVector[2] cutCurveDirectionField;
			floatFieldGrp -edit -en 0 cutCurveDirectionField;
			break;
		case 3: 							// use X axis
			radioButtonGrp -e -select 1 cutCurveDirectionGrp;
			floatFieldGrp -e -v1 1.0 -v2 0.0 -v3 0.0 cutCurveDirectionField;
			floatFieldGrp -edit -en 0 cutCurveDirectionField;
			break;	
		case 4: 							// use Y axis
			radioButtonGrp -e -select 2 cutCurveDirectionGrp;
			floatFieldGrp -e -v1 0.0 -v2 1.0 -v3 0.0 cutCurveDirectionField;
			floatFieldGrp -edit -en 0 cutCurveDirectionField;
			break;	
		case 5:								// use Z axis
			radioButtonGrp -e -select 3 cutCurveDirectionGrp;
			floatFieldGrp -e -v1 0.0 -v2 0.0 -v3 1.0 cutCurveDirectionField;
			floatFieldGrp -edit -en 0 cutCurveDirectionField;
			break;	
	}

	// Option to cut curve with all other curves or with last curve only
	//
	int $cutAllOrLastCurve = 
		`optionVar -query cutCurveWithAllCurvesOrLastCurve`;
	radioButtonGrp -edit -select $cutAllOrLastCurve
		cutCurveAllOrWithLastCurveGrp;

	// 	Segment (and keep all pieces) or cut (and keep the longest piece only)
	//
	int $segmentOrKeepLongest = `optionVar -query cutCurveSegmentOrKeepLongest`;
	if( $segmentOrKeepLongest == 1 || $segmentOrKeepLongest == 2 ) {
		radioButtonGrp -edit
			-select $segmentOrKeepLongest
			cutCurveSegmentOrKeepLongestGrp;
	} 
	else if( $segmentOrKeepLongest == 3 ) {
		radioButtonGrp -edit -select 1
			cutCurveSegmentOrKeepLongestGrp2;
	}

	//	Use global vs. local tolerance
	//
	int $globalOrLocal = `optionVar -query cutCurveUseTol`;
	radioButtonGrp -edit -select $globalOrLocal cutCurveTolBtnGrp;
	if( $globalOrLocal == 1 ) {
		floatSliderGrp -edit -en 0 cutCurveTolSlider;
	} else {
		floatSliderGrp -edit -en 1 cutCurveTolSlider;
	}

	// 	Tolerance.
	float $tol = `optionVar -query cutCurveTol`;
	floatSliderGrp -edit -value $tol cutCurveTolSlider;

	//	Keep Original
	int $keepOriginal = `optionVar -query cutCurveKeepOriginal`;
	checkBoxGrp -edit -value1 $keepOriginal cutCurveKeepOriginalCheckBox;

	if( "" != $goToTool ) { 
		checkBoxGrp -e -v1 `scriptCtx -q -euc $goToTool`
		  scriptToolExtraWidget;
		checkBoxGrp -e -v2 `scriptCtx -q -lac $goToTool`
		  scriptToolExtraWidget;
	}
}

//
//  Procedure Name:
//      cutCurveCallback
//
//  Description:
//		Update the option values with the current state of the option box UI.
//
//  Input Arguments:
//      parent - Top level parent layout of the option box UI.  Required so
//               that UI object names can be successfully resolved.
//
//		doIt   - Whether the command should execute.
//
//  Return Value:
//      None.
//
global proc cutCurveCallback(string $parent, int $doIt, string $goToTool)
{
	if( "" != $goToTool ) {
		optionVar -iv cutCurveEuc `scriptCtx -q -euc $goToTool`;
		optionVar -iv cutCurveLac `scriptCtx -q -lac $goToTool`;
	}
    setParent $parent;

	//	Set the optionVar's from the control values, and then
	//	perform the command.
	//

	// Get the value from the cutCurveUseDirRadioGrp.
	// Set the option value.
	//
	int $intersectionType = `radioButtonGrp -q -select cutCurveUseDirRadioGrp`;
	if( $intersectionType == 1 ) {
		// Use smart mode
		optionVar -intValue cutCurveUseDirection 6;
	} else if( $intersectionType == 2 ) {
		// don't use direction, always find 3d intersections
		optionVar -intValue cutCurveUseDirection 0;
	} else if( `radioButtonGrp -q -select cutCurveUseDirRadioGrp` == 1 ) {
		// Use direction
		optionVar -intValue cutCurveUseDirection 1;
	}

	//  Use Direction option var, cutCurveUseDirection
	//  Direction Type (0 - don't use direction, 1 - use direction from
	//  option vars, 2 - use active view, 3 - use X axis, 4 - use Y axis, 5 - use Z)
	//	6 - use smart mode: use view vectors in ortho views but don't use direction
	//	in persp view. )
	if( $intersectionType != 1 && $intersectionType != 2 ) {
		int $dirType = `radioButtonGrp -q -select cutCurveDirectionGrp`;
		switch( $dirType ) {
			case 1:
				optionVar -intValue cutCurveUseDirection 3;
				break;
			case 2:
				optionVar -intValue cutCurveUseDirection 4;
				break;
			case 3:
				optionVar -intValue cutCurveUseDirection 5;
				break;
		}
		int $dirType = `radioButtonGrp -q -select cutCurveDirectionGrp2`;
		switch( $dirType ) {
			case 1:
				optionVar -intValue cutCurveUseDirection 2;
				break;
			case 2:
				optionVar -intValue cutCurveUseDirection 1;
				break;
		}
	}

	// Direction
	//
	float $dirX = `floatFieldGrp -q -v1 cutCurveDirectionField`;
	float $dirY = `floatFieldGrp -q -v2 cutCurveDirectionField`;
	float $dirZ = `floatFieldGrp -q -v3 cutCurveDirectionField`;
	optionVar -floatValue cutCurveDirX $dirX;
	optionVar -floatValue cutCurveDirY $dirY;
	optionVar -floatValue cutCurveDirZ $dirZ;

	// Option to cut curve with all other curves or with last curve only
	//
	int $cutWithAllOrWithLastCurve = 
		`radioButtonGrp -q -select cutCurveAllOrWithLastCurveGrp`;
	optionVar -intValue cutCurveWithAllCurvesOrLastCurve 
		$cutWithAllOrWithLastCurve;

	// Segment (keep all pieces) vs. cut (keep longest piece)
	//
	int $segmentOrKeepLongest = 
		`radioButtonGrp -q -select cutCurveSegmentOrKeepLongestGrp`;
	if( $segmentOrKeepLongest == 0 ) {
		$segmentOrKeepLongest = 
			`radioButtonGrp -q -select cutCurveSegmentOrKeepLongestGrp2` + 2;
	}
	optionVar -intValue cutCurveSegmentOrKeepLongest $segmentOrKeepLongest;

	// Use Global vs. Local tolerance
	//
	int $globalOrLocalTol = `radioButtonGrp -q -select cutCurveTolBtnGrp`;
	if( $globalOrLocalTol == 1 ) {
		// Use global.  Update the "curve tolerance" and 
		// "use global tolerance" optionvar
		//
		float $tol = `tolerance -q -linear`;
		optionVar -floatValue cutCurveTol $tol;
		optionVar -intValue cutCurveUseTol $globalOrLocalTol;
	} else {
		// Use local.  Update the "curve tolerance" and 
		// "use local tolerance" optionvar
		//
		float $tol = `floatSliderGrp -q -value cutCurveTolSlider`;
		optionVar -floatValue cutCurveTol $tol;
		optionVar -intValue cutCurveUseTol $globalOrLocalTol;
	}

	// Keep Original Check box
	int $keep = `checkBoxGrp -query -value1 cutCurveKeepOriginalCheckBox`;
	optionVar -intValue cutCurveKeepOriginal $keep;

	if (1 == $doIt) {
		performCutCurve( 0, $goToTool ); 
		string $tmpCmd = "performCutCurve( 0, \"" + $goToTool + "\")";
		addToRecentCommandQueue $tmpCmd "Cut Curve";
	}
	else if( $doIt ) {
		setToolTo $goToTool;
	}
}

//
//  Procedure Name:
//      createCutCurveUI
//
//  Description:
//		Fill the contents of the option box for this operation.
//
//  Input Arguments:
//      The name of the parent layout.
//
//  Return Value:
//      None.
//
global proc createCutCurveUI(string $parent, int $inTheTool, string $goToTool)
{
	setParent $parent;

	// radio button group for using direction or not.
	radioButtonGrp -label (uiRes("m_performCutCurve.kFindIntersections"))   -nrb 2
		-label1 (uiRes("m_performCutCurve.kIn2DAnd3D")) 
		-label2 (uiRes("m_performCutCurve.kIn3DOnly")) 
		cutCurveUseDirRadioGrp;
	radioButtonGrp  -nrb 1 -shareCollection cutCurveUseDirRadioGrp
		-label1 (uiRes("m_performCutCurve.kUseDirection")) 
		cutCurveUseDirRadioGrp2;

	// Two sets of radio buttons - for projecting the curves before
	// intersecting.
	radioButtonGrp -label (uiRes("m_performCutCurve.kDirection"))  -numberOfRadioButtons 3
		-label1 (uiRes("m_performCutCurve.kX")) 
		-label2 (uiRes("m_performCutCurve.kY")) 
		-label3 (uiRes("m_performCutCurve.kZ")) 
		-select 1
		cutCurveDirectionGrp;

	radioButtonGrp -shareCollection cutCurveDirectionGrp
		-numberOfRadioButtons 2
		-label1 (uiRes("m_performCutCurve.kActiveView")) 
		-label2 (uiRes("m_performCutCurve.kFree")) 
		cutCurveDirectionGrp2;

	floatFieldGrp -label (uiRes("m_performCutCurve.kDirectionValues"))  
		-numberOfFields 3 cutCurveDirectionField;

	// Option whether or not to cut all curves with each other
	// or cut all curves with the last curve.
	radioButtonGrp -label (uiRes("m_performCutCurve.kCut")) 
		-numberOfRadioButtons 2 
		-label1 (uiRes("m_performCutCurve.kAtAllIntersections")) 
		-label2 (uiRes("m_performCutCurve.kUsingLastCurve")) 
		cutCurveAllOrWithLastCurveGrp;

	// Radio button for option to "Segment" (cut all curves and keep all pieces)
	// or "Cut" (and keep the longest piece).
	radioButtonGrp 
		-numberOfRadioButtons 2 
		-label (uiRes("m_performCutCurve.kKeep")) 
		-label1 (uiRes("m_performCutCurve.kLongestSegments")) 
		-label2 (uiRes("m_performCutCurve.kAllCurveSegments")) 
		cutCurveSegmentOrKeepLongestGrp;
	radioButtonGrp -shareCollection cutCurveSegmentOrKeepLongestGrp
		-numberOfRadioButtons 1
		-label1 (uiRes("m_performCutCurve.kSegmentsWithCurvePoints")) 
		cutCurveSegmentOrKeepLongestGrp2;

	separator;

	// Tolerance radio button - user can chose either "Global" or "Local"
	radioButtonGrp -label (uiRes("m_performCutCurve.kUseTolerance"))  
		-numberOfRadioButtons 2 
		-label1 (uiRes("m_performCutCurve.kGlobal")) 
		-label2 (uiRes("m_performCutCurve.kLocal")) 
		-onCommand1 ("floatSliderGrp -e -enable 0 cutCurveTolSlider;")
		-onCommand2 ("floatSliderGrp -e -enable 1 cutCurveTolSlider;")
		cutCurveTolBtnGrp;

	// Slider for specifying local tolerance
	floatSliderGrp -label (uiRes("m_performCutCurve.kTolerance"))  
		-min 0.001 -max 1.0 -fmn 0.00001 -fmx 10.0
		cutCurveTolSlider;

	// Check box for Keep Original
	checkBoxGrp -ncb 1 -label1 (uiRes("m_performCutCurve.kKeepOriginal"))  cutCurveKeepOriginalCheckBox;

	if( $inTheTool ) {
		separator;
		checkBoxGrp -ncb 2 -label (uiRes("m_performCutCurve.kToolBehavior")) 
		  -label1 (uiRes("m_performCutCurve.kExitOnCompletion")) 
		  -v1 off
		  -on1 ("scriptCtx -e -euc true " + $goToTool)
		  -of1 ("scriptCtx -e -euc false " + $goToTool)

		  -label2 (uiRes("m_performCutCurve.kAutoCompletion")) 
		  -v2 on
		  -on2 ("scriptCtx -e -lac true -ssc 2 " + $goToTool)
		  -of2 ("scriptCtx -e -lac false -ssc 0 " + $goToTool)
		  scriptToolExtraWidget;
	}

	//--------------------------------------------
	// Now link some of the controls together....
	//--------------------------------------------

	// Edit the "Find Intersections" radio button grp so that it enables/disables
	// the other direction vector controls.
	string $onCmd = "radioButtonGrp -e -en 1 cutCurveDirectionGrp;" +
		"radioButtonGrp -e -en 1 cutCurveDirectionGrp2;" +
		"if( `radioButtonGrp -q -select cutCurveDirectionGrp2` == 2) " +
		"floatFieldGrp -e -en 1 cutCurveDirectionField;";
	string $offCmd = "radioButtonGrp -e -en 0 cutCurveDirectionGrp;" +
		"radioButtonGrp -e -en 0 cutCurveDirectionGrp2;" +
		"if( `radioButtonGrp -q -select cutCurveDirectionGrp2` == 2) " +
		"floatFieldGrp -e -en 0 cutCurveDirectionField;";
	radioButtonGrp  -e
		-onCommand1 $offCmd
		-onCommand2 $offCmd
		cutCurveUseDirRadioGrp;
	radioButtonGrp -e
		-onCommand1 $onCmd			// use direction button
		cutCurveUseDirRadioGrp2;

	// Edit the tolerance radio button so it enables/disables
	// the tolerance slider.
	radioButtonGrp -e
		-onCommand1 ("floatSliderGrp -e -enable 0 cutCurveTolSlider;")
		-onCommand2 ("floatSliderGrp -e -enable 1 cutCurveTolSlider;")
		cutCurveTolBtnGrp;

	// Edit the "X" direction button so when it's selected, then 
	// the direction field will be (1, 0, 0)
	$onCmd = "floatFieldGrp -e -en 0 cutCurveDirectionField;" +
			"floatFieldGrp -e -v 1.0 0.0 0.0 0.0 cutCurveDirectionField;";
	radioButtonGrp -e -onCommand1 $onCmd cutCurveDirectionGrp;

	// Edit the "Y" direction button so when it's selected, then 
	// the direction field will be (0, 1, 0)
	$onCmd = "floatFieldGrp -e -en 0 cutCurveDirectionField;" +
			"floatFieldGrp -e -v 0.0 1.0 0.0 0.0 cutCurveDirectionField;";
	radioButtonGrp -e -onCommand2 $onCmd cutCurveDirectionGrp;

	// Edit the "Z" direction button so when it's selected, then 
	// the direction field will be (0, 0, 1)
	$onCmd = "floatFieldGrp -e -en 0 cutCurveDirectionField;" +
			"floatFieldGrp -e -v 0.0 0.0 1.0 0.0 cutCurveDirectionField;";
	radioButtonGrp -e -onCommand3 $onCmd cutCurveDirectionGrp;

	// Edit the "Active View" direction button so when it's selected, then 
	// the float field group is disabled.
	$onCmd = "floatFieldGrp -e -en 0 cutCurveDirectionField;" +
		"float $v[] = nurbsViewDirectionVector(0);" +
		"floatFieldGrp -e -v1 $v[0] -v2 $v[1] -v3 $v[2] cutCurveDirectionField;"
	;
	radioButtonGrp -e -onCommand1 $onCmd cutCurveDirectionGrp2;

	// Edit the "Free" direction button so when it's selected, then
	// the float field group is enabled.
	$onCmd = "floatFieldGrp -e -en 1 cutCurveDirectionField;";
	radioButtonGrp -e -onCommand2 $onCmd cutCurveDirectionGrp2;
}

//
//  Procedure Name:
//      cutCurveOptions
//
//  Description:
//		Construct the option box UI.  Involves accessing the standard option
//		box and customizing the UI accordingly.
//
//  Input Arguments:
//      None.
//
//  Return Value:
//      None.
//
proc cutCurveOptions( int $inTheTool, string $goToTool )
{
	//	Name of the command for this option box.
	//
	string $commandName = "cutCurve";

	//	Build the option box actions.
	//
	string $callback = ($commandName + "Callback");
	string $setup = ($commandName + "Setup");

	global string $gOptionBoxActionToolItem;
	$gOptionBoxActionToolItem = "modelWithToolCutCurve";
	global string $gOptionBoxActionToolItemCB;
	$gOptionBoxActionToolItemCB = "cutCurveToolScript 3";

	//  The value returned is the name of the layout to be used as
	//	the parent for the option box UI.
	//
	string $layout = getOptionBox();
	setParent $layout;
	
	//	Pass the command name to the option box.
	//
	//	Any default option box behavior based on the command name is set 
	//	up with this call.
	//
	setOptionBoxCommandName($commandName);
	
	//	Activate the default UI template so that the layout of this 
	//	option box is consistent with the layout of the rest of the 
	//	application.
	//
	setUITemplate -pushTemplate DefaultTemplate;

	//	Turn on the wait cursor.
	//
	waitCursor -state 1;

	//	RECOMMENDATION:  Place the UI in a scroll layout.  If the 
	//	option box window is ever resized such that it's entire 
	//	contents is not visible then the scroll bars provided by the
	//	scroll layout will allow the user to access the hidden UI.
	//
	tabLayout -scr true -tv false;
	
	string $parent = `columnLayout -adjustableColumn 1`;

	//	Create the UI for the tab that is initially visible.
	//
	createCutCurveUI($parent, $inTheTool, $goToTool);

	// Set the command name again here.  The only reason to do this is so that
	// the "Help" menu item refers to a useful MEL command, "curveIntersect".
	// Otherwise, the Help menu item defaults to "Help with cutCurve",
	// but no "cutCurve" command exists.
	//
	setOptionBoxCommandName( "curveIntersect");

	//	Turn off the wait cursor.
	//
	waitCursor -state 0;

	//	Deactivate the default UI template.
	//
	setUITemplate -popTemplate;

	//	Attach actions to those buttons that are applicable to the option
	//	box.  Note that the 'Close' button has a default action attached 
	//	to it that will hide the window.  If a a custom action is
	//	attached to the 'Close' button then be sure to call the 'hide the
	//	option box' procedure within the custom action so that the option
	//	box is hidden properly.

	//	'Cut' button.
	//
	string $applyBtn = getOptionBoxApplyBtn();
	if( $inTheTool ) {
		button -edit -label (uiRes("m_performCutCurve.kCutTool")) 
			-command ($callback + " " + $parent + " 3 \"" + $goToTool + "\"")
			$applyBtn;
	}
	else {
		button -edit -label (uiRes("m_performCutCurve.kCutButton")) 
			-command ($callback + " " + $parent + " 1 \"" + $goToTool + "\"")
			$applyBtn;
	}

	//	'Save' button.
	//
	string $saveBtn = getOptionBoxSaveBtn();
	button -edit 
		-command ($callback + " " + $parent + " 0 \"" +
				  $goToTool + "\"; hideOptionBox")
		$saveBtn;

	//	'Reset' button.
	//
	string $resetBtn = getOptionBoxResetBtn();
	button -edit 
		-command ($setup + " " + $parent + " 1 \"" + $goToTool + "\"")
		$resetBtn;

	//	Set the option box title.
	//
	if( $inTheTool ) {
		setOptionBoxTitle (uiRes("m_performCutCurve.kCutCurveToolOptions"));
	}
	else {
		setOptionBoxTitle (uiRes("m_performCutCurve.kCutCurveOptions"));
	}

	//	Customize the 'Help' menu item text.
	//
	setOptionBoxHelpTag( "CutCurve" );

	//	Set the current values of the option box.
	//
	eval ($setup + " " + $parent + " 0 \"" + $goToTool + "\"");	
	
	//	Show the option box.
	//
	showOptionBox();
}

//
//  Procedure Name:
//      cutCurveHelp
//
//  Description:
//		Returns a short description about how to use this command.
//
//  Input Arguments:
//      None.
//
//  Return Value:
//      string.
//
proc string cutCurveHelp()
{
	return 
	"  Command: Cuts two curves. \n" +
	"Selection: Two curves that intersect.";	
}

//
//  Procedure Name:
//      assembleCmd
//
//  Description:
//		Construct the preset command that will apply the option box 
//		values.
//
//  Input Arguments:
//      None.
//
//  Return Value:
//      The preset command string.
//
proc string assembleCmd()
{
	setOptionVars(false);

	// get the global history flag value
	int $doHistory = `constructionHistory -q -tgl`;

	// get the replace original value
	int $replaceOriginal = !`optionVar -query cutCurveKeepOriginal`;
	
	// tolerance
	float $tolerance = `optionVar -query cutCurveTol`;

	// query direction type and direction vector
	int $useDirection = `optionVar -query cutCurveUseDirection`;
	float $dirX = `optionVar -query cutCurveDirX`;
	float $dirY = `optionVar -query cutCurveDirY`;
	float $dirZ = `optionVar -query cutCurveDirZ`;

	// Query whether or not to segment or keep longest curve piece
	// 1 - keep longest piece, 2 - keep all curve pieces
	// 3 - keep curve segments with curve points selected on them
	//
	int $segment = `optionVar -query cutCurveSegmentOrKeepLongest`;

	int $cutWithAllOrLast = `optionVar -query cutCurveWithAllCurvesOrLastCurve`;

	// set up string for preset function call
	string $cmd = "cutCurvePreset";
	$cmd = $cmd + "(" + $doHistory + "," + $replaceOriginal + ","
			+ $tolerance + ","
			+ $useDirection + "," + $dirX + "," + $dirY + "," + $dirZ
			+ "," + $segment  + "," + $cutWithAllOrLast + ")";
	return $cmd;
}

//
//  Procedure Name:
//      performCutCurve
//
//  Description:
//		Perform the "cut curve at intersection" operation using the 
//		corresponding option values.  This procedure will also show 
//		the option box window if necessary as well as construct the 
//		command string that will invoke the correct command with the current
//		option box values.
//
//  Input Arguments:
//      0 - Execute the command.
//      1 - Show the option box dialog.
//      2 - Return the command to drag to shelf.
//
//  Return Value:
//      The "Cut Curve at intersection" command string.
//
global proc string performCutCurve(int $action, string $goToTool)
{
	int $inTheTool = false;
	if( 3 == $action ) {
		$action = 1;
		$inTheTool = true;
	}

	string $cmd = "";
	switch ($action) {

	  case 0:
		setOptionVars(false);
		$cmd = `assembleCmd`;
		eval($cmd);
		break;

	  case 1:
		cutCurveOptions( $inTheTool, $goToTool );
		break;

	  case 2:
	  default:
		setOptionVars(false);
		$cmd = `assembleCmd`;
		break;
	}
	return $cmd;
}
