// Copyright (C) 1997-2014 Autodesk, Inc., and/or its licensors.
// All rights reserved.
//
// The coded instructions, statements, computer programs, and/or related
// material (collectively the "Data") in these files contain unpublished
// information proprietary to Autodesk, Inc. ("Autodesk") and/or its licensors,
// which is protected by U.S. and Canadian federal copyright law and by
// international treaties.
//
// The Data is provided for use exclusively by You. You have the right to use,
// modify, and incorporate this Data into other products for purposes authorized 
// by the Autodesk software license agreement, without fee.
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND. AUTODESK
// DOES NOT MAKE AND HEREBY DISCLAIMS ANY EXPRESS OR IMPLIED WARRANTIES
// INCLUDING, BUT NOT LIMITED TO, THE WARRANTIES OF NON-INFRINGEMENT,
// MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE, OR ARISING FROM A COURSE 
// OF DEALING, USAGE, OR TRADE PRACTICE. IN NO EVENT WILL AUTODESK AND/OR ITS
// LICENSORS BE LIABLE FOR ANY LOST REVENUES, DATA, OR PROFITS, OR SPECIAL,
// DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES, EVEN IF AUTODESK AND/OR ITS
// LICENSORS HAS BEEN ADVISED OF THE POSSIBILITY OR PROBABILITY OF SUCH DAMAGES.

//
// Description:
//
//	Tools for defining the various types of HyperShade tabs that can be
//	created, and for controlling the available filtering options for
//	those tabs.
//
//	In order to add new types of tabs, just add a row to the 
//	$gHyperShadeTabTypes table, and add a new else clause to
//	the filteredCollection_RelatedFilters() procedure.
//
//-----------------------------------------------------------------------------

//
//	This table determines the types of HyperShade tabs that can
//	be created from the HyperShade "Create New Tab" dialog.  The
//	"UI Name" determines the name that will be displayed in the
//	dialog dropdown.  The "Internal Name" is just a name used to
//	identify the tab type internally.  The "Filter Name" is the name
//	of a filter node that will be used as the default filter for the
//	view.  These filter nodes are defined in initDefaultFilters.mel.
//	The special filter name "0" means "all nodes".
//

global proc initializeHyperShadeTabFilterTypes()
{
    global string $gHyperShadeTabTypes[];
	
	// Each block contains:
	//	the UI Name of the filter
	//	the Internal Name of the filter and
	//	the Filter Name

	if( size( $gHyperShadeTabTypes ) == 0 ) 
	{
	    int $index = 0 ; 
	    $gHyperShadeTabTypes[$index++] = (uiRes("m_filteredCollection.kMaterials"));
	    $gHyperShadeTabTypes[$index++] = "Materials";
	    $gHyperShadeTabTypes[$index++] = "DefaultMaterialsFilter";
		
	    $gHyperShadeTabTypes[$index++] = (uiRes("m_filteredCollection.kMaterialsAndShaderGlow"));
	    $gHyperShadeTabTypes[$index++] = "MaterialsAndShaderGlow";
	    $gHyperShadeTabTypes[$index++] = "DefaultMaterialsAndShaderGlowFilter";
			
	    $gHyperShadeTabTypes[$index++] = (uiRes("m_filteredCollection.kTextures"));
	    $gHyperShadeTabTypes[$index++] = "Textures";
	    $gHyperShadeTabTypes[$index++] = "DefaultTexturesFilter";
		
	    $gHyperShadeTabTypes[$index++] = (uiRes("m_filteredCollection.kCameras"));
	    $gHyperShadeTabTypes[$index++] = "Cameras";
	    $gHyperShadeTabTypes[$index++] = "DefaultCameraShapesImagePlanesFilter";
	
	    $gHyperShadeTabTypes[$index++] = (uiRes("m_filteredCollection.kUtilities"));
	    $gHyperShadeTabTypes[$index++] = "Utilities";
	    $gHyperShadeTabTypes[$index++] = "DefaultRenderUtilitiesFilter";
	
	    $gHyperShadeTabTypes[$index++] = (uiRes("m_filteredCollection.kRendering"));
	    $gHyperShadeTabTypes[$index++] = "Rendering";
	    $gHyperShadeTabTypes[$index++] = "DefaultRenderingFilter";
	    
	    $gHyperShadeTabTypes[$index++] = (uiRes("m_filteredCollection.kLights"));
	    $gHyperShadeTabTypes[$index++] = "Lights";
	    $gHyperShadeTabTypes[$index++] = "DefaultAllLightsFilter";
	    $gHyperShadeTabTypes[$index++] = (uiRes("m_filteredCollection.kLightsAndOpticalFX"));
	    $gHyperShadeTabTypes[$index++] = "LightsAndOpticalFX";
	    $gHyperShadeTabTypes[$index++] = "DefaultLightsAndOpticalFXFilter";
	    $gHyperShadeTabTypes[$index++] = (uiRes("m_filteredCollection.kShadingGroups"));
	    $gHyperShadeTabTypes[$index++] = "ShadingGroups";
	    $gHyperShadeTabTypes[$index++] = "DefaultShadingGroupsFilter";
	
	    $gHyperShadeTabTypes[$index++] = (uiRes("m_filteredCollection.kPostProcess"));
	    $gHyperShadeTabTypes[$index++] = "PostProcess";
	    $gHyperShadeTabTypes[$index++] = "DefaultPostProcFilter";
	
	    $gHyperShadeTabTypes[$index++] = (uiRes("m_filteredCollection.kBakeSets"));
	    $gHyperShadeTabTypes[$index++] = "BakeSets";
	    $gHyperShadeTabTypes[$index++] = "DefaultBakeSetsFilter";

	    $gHyperShadeTabTypes[$index++] = (uiRes("m_filteredCollection.kAssetNodes"));
	    $gHyperShadeTabTypes[$index++] = "ContainerNodes";
	    $gHyperShadeTabTypes[$index++] = "DefaultContainerNodeFilter";
	    
	    $gHyperShadeTabTypes[$index++] = (uiRes("m_filteredCollection.kAllNodes"));
	    $gHyperShadeTabTypes[$index++] = "AllNodes";
	    $gHyperShadeTabTypes[$index++] = "0";
	
	    $gHyperShadeTabTypes[$index++] = (uiRes("m_filteredCollection.kAllShadingNodes"));
	    $gHyperShadeTabTypes[$index++] = "AllShadingNodes";
	    $gHyperShadeTabTypes[$index++] = "DefaultAllShadingNodesFilter";

	    $gHyperShadeTabTypes[$index++] = (uiRes("m_filteredCollection.kAllMentalRayNodes"));
	    $gHyperShadeTabTypes[$index++] = "AllMentalRay";
	    $gHyperShadeTabTypes[$index++] = "DefaultMrNodesFilter";
	
	    $gHyperShadeTabTypes[$index++] = (uiRes("m_filteredCollection.kMentalRayMaterials"));
	    $gHyperShadeTabTypes[$index++] = "mrMaterials";
	    $gHyperShadeTabTypes[$index++] = "DefaultMrMaterialFilter";
	
	    $gHyperShadeTabTypes[$index++] = (uiRes("m_filteredCollection.kMentalRayShadowShaders"));
	    $gHyperShadeTabTypes[$index++] = "mrShadow";
	    $gHyperShadeTabTypes[$index++] = "DefaultMrShadowFilter";
	
	    $gHyperShadeTabTypes[$index++] = (uiRes("m_filteredCollection.kMentalRayVolumeShaders"));
	    $gHyperShadeTabTypes[$index++] = "mrVolume";
	    $gHyperShadeTabTypes[$index++] = "DefaultMrVolumeFilter";
	
	    $gHyperShadeTabTypes[$index++] = (uiRes("m_filteredCollection.kMentalRayDisplacementShaders"));
	    $gHyperShadeTabTypes[$index++] = "mrDisplacement";
	    $gHyperShadeTabTypes[$index++] = "DefaultMrDisplacementFilter";
	
	    $gHyperShadeTabTypes[$index++] = (uiRes("m_filteredCollection.kMentalRayPhotonShaders"));
	    $gHyperShadeTabTypes[$index++] = "mrPhoton";
	    $gHyperShadeTabTypes[$index++] = "DefaultMrPhotonFilter";
	
	    $gHyperShadeTabTypes[$index++] = (uiRes("m_filteredCollection.kMentalRayPhotonVolumeShaders"));
	    $gHyperShadeTabTypes[$index++] = "mrPhotonVolume";
	    $gHyperShadeTabTypes[$index++] = "DefaultMrPhotonVolumeFilter";
	
	    $gHyperShadeTabTypes[$index++] = (uiRes("m_filteredCollection.kMentalRayTextureShaders"));
	    $gHyperShadeTabTypes[$index++] = "mrTexture";
	    $gHyperShadeTabTypes[$index++] = "DefaultMrTextureFilter";
	
	    $gHyperShadeTabTypes[$index++] = (uiRes("m_filteredCollection.kMentalRayEnvironmentShaders"));
	    $gHyperShadeTabTypes[$index++] = "mrEnvironment";
	    $gHyperShadeTabTypes[$index++] = "DefaultMrEnvironmentFilter";
	
	    $gHyperShadeTabTypes[$index++] = (uiRes("m_filteredCollection.kMentalRayLightShaders"));
	    $gHyperShadeTabTypes[$index++] = "mrLight";
	    $gHyperShadeTabTypes[$index++] = "DefaultMrLightFilter";
	
	    $gHyperShadeTabTypes[$index++] = (uiRes("m_filteredCollection.kMentalRayPhotonEmitterShaders"));
	    $gHyperShadeTabTypes[$index++] = "mrEmitter";
	    $gHyperShadeTabTypes[$index++] = "DefaultMrEmitterFilter";
	
	    $gHyperShadeTabTypes[$index++] = (uiRes("m_filteredCollection.kMentalRayLightmapShaders"));
	    $gHyperShadeTabTypes[$index++] = "mrLightmap";
	    $gHyperShadeTabTypes[$index++] = "DefaultMrLightmapFilter";
	
	    $gHyperShadeTabTypes[$index++] = (uiRes("m_filteredCollection.kMentalRayLensShaders"));
	    $gHyperShadeTabTypes[$index++] = "mrLens";
	    $gHyperShadeTabTypes[$index++] = "DefaultMrLensFilter";
	
	    $gHyperShadeTabTypes[$index++] = (uiRes("m_filteredCollection.kMentalRayOutputShaders"));
	    $gHyperShadeTabTypes[$index++] = "mrOutput";
	    $gHyperShadeTabTypes[$index++] = "DefaultMrOutputFilter";

	    $gHyperShadeTabTypes[$index++] = (uiRes("m_filteredCollection.kMentalRayGeometryShaders"));
	    $gHyperShadeTabTypes[$index++] = "mrGeometry";
	    $gHyperShadeTabTypes[$index++] = "DefaultMrGeometryFilter";
	
	    $gHyperShadeTabTypes[$index++] = (uiRes("m_filteredCollection.kMentalRayContourStoreShaders"));
	    $gHyperShadeTabTypes[$index++] = "mrContourStore";
	    $gHyperShadeTabTypes[$index++] = "DefaultMrContourStoreFilter";
	
	    $gHyperShadeTabTypes[$index++] = (uiRes("m_filteredCollection.kMentalRayContourContrastShaders"));
	    $gHyperShadeTabTypes[$index++] = "mrContourContrast";
	    $gHyperShadeTabTypes[$index++] = "DefaultMrContourContrastFilter";
	
	    $gHyperShadeTabTypes[$index++] = (uiRes("m_filteredCollection.kMentalRayContourShaders"));
	    $gHyperShadeTabTypes[$index++] = "mrContourShader";
	    $gHyperShadeTabTypes[$index++] = "DefaultMrContourShaderFilter";
	
	    $gHyperShadeTabTypes[$index++] = (uiRes("m_filteredCollection.kMentalRayContourOutputShaders"));
	    $gHyperShadeTabTypes[$index++] = "mrContourOutput";
	    $gHyperShadeTabTypes[$index++] = "DefaultMrContourOutputFilter";
	
	    $gHyperShadeTabTypes[$index++] = (uiRes("m_filteredCollection.kMentalRaySampleCompositingShaders"));
	    $gHyperShadeTabTypes[$index++] = "mrCompositing";
	    $gHyperShadeTabTypes[$index++] = "DefaultMrSampleCompositingFilter";
	
	    $gHyperShadeTabTypes[$index++] = (uiRes("m_filteredCollection.kMentalRayDataConversionShaders"));
	    $gHyperShadeTabTypes[$index++] = "mrConversion";
	    $gHyperShadeTabTypes[$index++] = "DefaultMrDataConversionFilter";

	    $gHyperShadeTabTypes[$index++] = (uiRes("m_filteredCollection.kMentalRayStateShaders"));
	    $gHyperShadeTabTypes[$index++] = "mrState";
	    $gHyperShadeTabTypes[$index++] = "DefaultMrStateFilter";

	    $gHyperShadeTabTypes[$index++] = (uiRes("m_filteredCollection.kMentalRayMiscShaders"));
	    $gHyperShadeTabTypes[$index++] = "mrMisc";
	    $gHyperShadeTabTypes[$index++] = "DefaultMrMiscFilter";

	    $gHyperShadeTabTypes[$index++] = (uiRes("m_filteredCollection.kMentalRayLegacyShaders"));
	    $gHyperShadeTabTypes[$index++] = "mrLegacy";
	    $gHyperShadeTabTypes[$index++] = "DefaultMrLegacyFilter";
		
	}   
}

global proc string[] filteredCollection_RelatedFilters( 
	string $internalFilterName)
{
	//
	// Description:
	//	This procedure specifies the filter categories that are related
	//	to a particular filter.  These filter categories will be used
	//	to populate the "Objects->" submenu of the "Show" popup menu
	//	of a filtered collection.
	//
	//	These collection filter categories also determine the categories
	//	that will be assigned to user-defined type filters (created
	//	when a user does a "Show Selected Types", then a "Create Entry"
	//	operation).  The categories for the current collection will
	//	be assigned to the new type filter.
	//
	//	Filter categories are defined in initDefaultFilters.mel
	//	when the filters are created.  Returning a list whose
	//	only element is the entry "ALL" means that all filter
	//	categories apply to this collection.  The special
	//	filter "" means that this collection is related to filters
	//	that were created with no category (such as those created
	//	in an AllNodes collection).
	//
	string $res[];

	if( $internalFilterName == "AllNodes" )
	{
		//	for the AllNodes tab, specify that all filters 
		//	are related, since any node type can appear in this
		//	tab.  This means that any user-defined type filters
		//	built from this tab will have no categorization.
		//
		$res = { "ALL" };
	}
	else if( 
			($internalFilterName == "AllMentalRay")		||
			($internalFilterName == "mrMaterials")		||
			($internalFilterName == "mrShadow")			||
			($internalFilterName == "mrVolume")			||
			($internalFilterName == "mrDisplacement")	||
			($internalFilterName == "mrPhoton")			||
			($internalFilterName == "mrPhotonVolume")	||
			($internalFilterName == "mrTexture")		||
			($internalFilterName == "mrEnvironment")	||
			($internalFilterName == "mrLight")			||
			($internalFilterName == "mrEmitter")		||
			($internalFilterName == "mrLightmap")		||
			($internalFilterName == "mrLens")			||
			($internalFilterName == "mrOutput")			||
			($internalFilterName == "mrGeometry")		||
			($internalFilterName == "mrContourStore")	||
			($internalFilterName == "mrContourContrast")||
			($internalFilterName == "mrContourShader")	||
			($internalFilterName == "mrContourOutput")	||
			($internalFilterName == "mrCompositing")	||
			($internalFilterName == "mrConversion")		||
			($internalFilterName == "mrState")			||
			($internalFilterName == "mrMisc") 
	)
	{
		//	For the mental ray tabs, specify that all mentalray-related
		//	filters are applicable.  Also, we specify that filters 
		//	with no categorization (such as those created in an AllNodes
		//	tab) apply to this one as well.
		//
		$res = { "mentalray", "" };
	}
	else if( ($internalFilterName == "Lights") 
			|| ($internalFilterName == "LightsAndOpticalFX")
			)
    {
		$res = { "Lighting", "" };
    } 
    else if ( ($internalFilterName == "Textures") )
    {
		$res = { "Texture", "" };
    }
    else if ( ($internalFilterName == "Cameras") )
    {
		$res = { "Camera", "" };
    }
    else if ( ($internalFilterName == "Materials")
			 || ($internalFilterName == "MaterialsAndShaderGlow")
																	)
    {
		$res = { "Material", "" };
    }
    else if ( ($internalFilterName == "Utilities") )
    {
		$res = { "Utility", "" };
    }
    else if ( ($internalFilterName == "ShadingGroups") )
    {
		$res = { "ShadingGroup", "" };
    }
	else if( ($internalFilterName == "PostProcess") )
    {
		$res = { "PostProcess", "" };
    }
	else if( ($internalFilterName == "BakeSets") )
	{
		$res = { "BakeSets", "" };
	}
	else
	{
		//	Unknown tab type, let's say that only uncategorized filters 
		//	are related.
		//
		$res = { "" };
	}

	return $res;
}

//	lookup tables for filtered collections
//
global string $gFilteredCollectionLookupTable[];
global int $gFilteredCollectionLookupTableInit = 0;

proc filteredCollection_CreateLookupTable()
{
	// Description:	
	//	Initializes the lookup table for the various types of filtered
	//	collections, based on the contents of the $gHyperShadeTabTypes
	//	table.
	//
	// Make sure all the different types of HyperShade tab filters are filled in before we use them.
	//
	initializeHyperShadeTabFilterTypes();
	
	global string $gFilteredCollectionLookupTable[];
	global int $gFilteredCollectionLookupTableInit;
	global string $gHyperShadeTabTypes[];

	if( $gFilteredCollectionLookupTableInit )
	{
		return;
	}

	string $cols[] = {
		"uiName",
		"internalName",
		"implicitFilterName"
	};

	//	init the lookup table
	//
	lookupTable( $gFilteredCollectionLookupTable, $cols );

	//	fill in the table
	//
	int $i;
	for( $i = 0; $i < size($gHyperShadeTabTypes)/3; $i++ )
	{
		string $uiName = $gHyperShadeTabTypes[3*$i];
		string $internalName = $gHyperShadeTabTypes[3*$i+1];
		string $filterName = $gHyperShadeTabTypes[3*$i+2];

		lookupTableAddRow( $gFilteredCollectionLookupTable,
						   { $uiName, $internalName, $filterName } );
	}

	$gFilteredCollectionLookupTableInit = 1;
}

global proc string[] filteredCollection_ListTypes()
{
	// Description:
	//	Lists all the various types of filtered collections 
	//	that can be created.  Returns the "UI-friendly" names
	//	for the types, suitable for creating a menu of choices.
	//
	filteredCollection_CreateLookupTable();
	global string $gFilteredCollectionLookupTable[];
	return lookupTableGetColumn( $gFilteredCollectionLookupTable, "uiName" );
}

global proc string filteredCollection_InternalName( 
	string $uiName)
{
	// Description:
	//	Converts a UI-friendly filtered collection type name to an
	//	internal name that can be passed to the functions in 
	//	collectionUI.mel.
	//
	filteredCollection_CreateLookupTable();
	global string $gFilteredCollectionLookupTable[];
	return lookupTableLookup( 
				$gFilteredCollectionLookupTable, 
				"uiName",
				$uiName,
				"internalName" );
}

global proc string filteredCollection_RealFilterName( 
	string $internalName)
{
	// Description:
	//	Given the internal name of a filtered collection
	//	type, finds the objectFilter node that will perform
	//	the required filtering.  This filter is suitable to
	//	be passed to filterUISetImplicitFilter() in filterUI.mel,
	//	which specifies a base filter to be used for the collection.
	//
	filteredCollection_CreateLookupTable();
	global string $gFilteredCollectionLookupTable[];
	return lookupTableLookup( 
				$gFilteredCollectionLookupTable, 
				"internalName",
				$internalName,
				"implicitFilterName" );
}

global proc string filteredCollection_InternalFromFilter( 
	string $filter )
{
	// Description:
	//	Finds the internal name of a filtered collection
	//	type from the name of its corresponding objectFilter
	//	node.
	//
	filteredCollection_CreateLookupTable();
	global string $gFilteredCollectionLookupTable[];
	return lookupTableLookup( 
				$gFilteredCollectionLookupTable, 
				"implicitFilterName",
				$filter,
				"internalName" );
}

global proc filteredCollection()
{
	// Description:
	//	Called just to get the global functions in 
	//	this file to be declared.
	//

	filteredCollection_CreateLookupTable();
}









