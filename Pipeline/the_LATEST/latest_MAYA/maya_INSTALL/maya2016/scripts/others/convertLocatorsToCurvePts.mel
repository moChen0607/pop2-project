// Copyright (C) 1997-2014 Autodesk, Inc., and/or its licensors.
// All rights reserved.
//
// The coded instructions, statements, computer programs, and/or related
// material (collectively the "Data") in these files contain unpublished
// information proprietary to Autodesk, Inc. ("Autodesk") and/or its licensors,
// which is protected by U.S. and Canadian federal copyright law and by
// international treaties.
//
// The Data is provided for use exclusively by You. You have the right to use,
// modify, and incorporate this Data into other products for purposes authorized 
// by the Autodesk software license agreement, without fee.
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND. AUTODESK
// DOES NOT MAKE AND HEREBY DISCLAIMS ANY EXPRESS OR IMPLIED WARRANTIES
// INCLUDING, BUT NOT LIMITED TO, THE WARRANTIES OF NON-INFRINGEMENT,
// MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE, OR ARISING FROM A COURSE 
// OF DEALING, USAGE, OR TRADE PRACTICE. IN NO EVENT WILL AUTODESK AND/OR ITS
// LICENSORS BE LIABLE FOR ANY LOST REVENUES, DATA, OR PROFITS, OR SPECIAL,
// DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES, EVEN IF AUTODESK AND/OR ITS
// LICENSORS HAS BEEN ADVISED OF THE POSSIBILITY OR PROBABILITY OF SUCH DAMAGES.

//
//	Description:
//		Given a list of names of locator shapes, this proc returns a list
//		of "curve point" selection items.  The number of resulting strings
//		is equal to the number of locator shape names passed in.
//
//		eg. if a parameter locator on a curve is passed in as:
//			curveShape1->locatorShape1
//		Then this proc will return a curve point selection item depending
//		on where along the curve the locator is, eg:
//			curveShape1.u[0.55];
//
global proc string[] convertLocatorsToCurvePts( string $locatorShapes[] )
{
	// For each locator
	//    - get the name of it's parent curve
	//	  - figure out the parameter value of the locator
	// 	  - put together the string for the selection item.
	//
	string $selectionList[];
	string $curveName;
	float $parm;
	int $i;
	int $numLocators = size($locatorShapes);

	for( $i = 0; $i < $numLocators; $i ++ ) {

		// Get the parent transform above the locator shape
		//
		string $parent1[] = `listRelatives -p $locatorShapes[$i]`;
			
		// Get the shape above the transform.  If it's not a nurbs curve,
		// then reject it.
		//
		string $parent2[] = `listRelatives -p $parent1[0]`;
		$curveName = $parent2[0];
		if( `nodeType $curveName` != "nurbsCurve" ) continue;

		// Figure out the parameter value in "underworld" space by multiplying
		// the locator shape's local position with the locator's transform 
		// matrix.  The X value of the resulting point is the parameter value.
		//
		string $pmm;
		if( !catch($pmm = `createNode pointMatrixMult`) ) {

			// Get the local position of the locator shape
			//
			float $pos[] = `getAttr ($locatorShapes[$i] + ".localPosition")`;
			$parm = `getAttr ($parent1[0] + ".translateX")`;

			// Get the transformation matrix of the transform above the
			// locator shape.  Multiply the point and the matrix using
			// the pointMatrixMult node to get the resulting parameter value.
			//
			setAttr ($pmm +".inPoint") -type double3  $pos[0] $pos[1] $pos[2];
			setAttr ($pmm +".vectorMultiply") true ;
			connectAttr ($parent1[0]+".worldMatrix[0]") ($pmm+".inMatrix") ;
			float $result[] = `getAttr ($pmm+".output")` ;
			$parm = $result[0];		// Use the resulting points "X" value.

			// Put together the curve parameter point as a selection item
			// of the form:  "<curvename>.u[<parameter>]" and add it to
			// the selection list.
			//
			string $selectionItem = $curveName + ".u[" + $parm + "]";
			$selectionList[ size($selectionList) ] = $selectionItem;

			delete $pmm;
		}
	}
	return $selectionList;
}
