// Copyright (C) 1997-2014 Autodesk, Inc., and/or its licensors.
// All rights reserved.
//
// The coded instructions, statements, computer programs, and/or related
// material (collectively the "Data") in these files contain unpublished
// information proprietary to Autodesk, Inc. ("Autodesk") and/or its licensors,
// which is protected by U.S. and Canadian federal copyright law and by
// international treaties.
//
// The Data is provided for use exclusively by You. You have the right to use,
// modify, and incorporate this Data into other products for purposes authorized 
// by the Autodesk software license agreement, without fee.
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND. AUTODESK
// DOES NOT MAKE AND HEREBY DISCLAIMS ANY EXPRESS OR IMPLIED WARRANTIES
// INCLUDING, BUT NOT LIMITED TO, THE WARRANTIES OF NON-INFRINGEMENT,
// MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE, OR ARISING FROM A COURSE 
// OF DEALING, USAGE, OR TRADE PRACTICE. IN NO EVENT WILL AUTODESK AND/OR ITS
// LICENSORS BE LIABLE FOR ANY LOST REVENUES, DATA, OR PROFITS, OR SPECIAL,
// DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES, EVEN IF AUTODESK AND/OR ITS
// LICENSORS HAS BEEN ADVISED OF THE POSSIBILITY OR PROBABILITY OF SUCH DAMAGES.


global proc txtWndUpdateEditor(string $editor, string $editorCmd, string $updatFunc, int $reason)
//
// Description:
//		Update menu items based on current state of texture window
//		options. 
//
//		This proc should also be registered as the textureWindow's change
//		command (by calling: "textureWindow -e -cc " with the appropriate
//		parms). It is for this reason that an updateFunc and reason param
//		are included.
//
// 		This proc is explicitly called from all menuItems and
//		buttons that modify the state of another menuItem or button
//		(e.g. the toggleGridButton modifies the state of the Grid menuItem)
//		The default reason 101 is given so as not to conflict with any
//		textureWindow specific reasons (see docs for a brief explanation).
//
// Arguments:
//
// Returns:
//
// Notes:
//		hmmm $updateFunc is never used ?
//
{
	global string $gTextureEditorMenubarPrefix;

	string $popupPrefix = $editor;
	string $menubarPrefix = ($gTextureEditorMenubarPrefix + $editor);

	// update texture items
	//
	if ( $reason == 101 ) {
		// update unfold tool button
		int $u3DLoaded = `pluginInfo -q -loaded Unfold3D`;
		if ( $u3DLoaded && `currentCtx` == "texUnfoldUVContext" )
		{
			int $unfoldMode = eval("Unfold3DContext -q -u texUnfoldUVContext");
			if ( $unfoldMode )
				toolButton -e -select texUnfoldUVBrushButton;
			else
				toolButton -e -select texOptimizeUVBrushButton;
		}
		if ( `currentCtx` == "texCutUVContext" )
		{
			string $mode = `texCutContext -q -mode texCutUVContext`;
			if ( $mode == "Cut" )
				toolButton -e -select texCutUVButton;
			else
				toolButton -e -select texSewUVButton;
		}
		else if ( `currentCtx` == "texSculptCacheContextObj" )
		{
			string $mode = `texSculptCacheContext -q -mode texSculptCacheContextObj`;
			if ( $mode == "Grab" )
				toolButton -e -select texGrabUVButton;
			else if ( $mode == "Freeze" )
				toolButton -e -select texPinUVButton;
			else if ( $mode == "Pinch" )
				toolButton -e -select texPinchUVButton;
			else if ( $mode == "Smear" )
				toolButton -e -select texSmearUVButton;
		}
		
		// update image display menu item
		//
		int $drawImage = eval ($editorCmd +" -q -imageDisplay "+ $editor) ;
		menuItem -e -cb  $drawImage ($popupPrefix+"ImageDisplay") ;
		menuItem -e -cb  $drawImage ($menubarPrefix+"ImageDisplay") ;
		iconTextCheckBox -e -value $drawImage imageDisplayButton;

		// update image dimming menu item
		//
		float $color[] = eval ($editorCmd +" -q -imageBaseColor "+ $editor) ;
		int $dimmed = ($color[0] < 0.99);
		menuItem -e -cb  $dimmed ($popupPrefix+"DimImage") ;
		menuItem -e -cb  $dimmed ($menubarPrefix+"DimImage") ;
		iconTextCheckBox -e -value $dimmed dimmerButton;

		// update editor image display menu items and icone
		//
		int $drawEditorImage = `optionVar -q displayEditorImage`;
		menuItem -e -cb  $drawEditorImage ($popupPrefix+"DisplayEditorImage") ;
		menuItem -e -cb  $drawEditorImage ($menubarPrefix+"DisplayEditorImage") ;
		iconTextCheckBox -e -value $drawEditorImage editorImageDisplayButton;

		// update editor image display menu items and icone
		//
		int $drawMapOverlay = eval ($editorCmd +" -q -displaySolidMap "+ $editor) ;
		menuItem -e -cb $drawMapOverlay ($menubarPrefix+"MapOverlay") ;

		//showUVImageButton -e -value 0; // update toolbar

		int $flag = eval ($editorCmd +" -q -iuf "+ $editor) ;
		menuItem -e -cb  $flag ($popupPrefix+"ImageUnfiltered") ;
		menuItem -e -cb  $flag ($menubarPrefix+"ImageUnfiltered") ;
		iconTextCheckBox -e -value $flag filteredButton;

		$flag = eval ($editorCmd +" -q -imr "+ $editor) ;
		menuItem -e -cb  $flag ($popupPrefix+"ImageRatio") ;
		menuItem -e -cb  $flag ($menubarPrefix+"ImageRatio") ;
		iconTextCheckBox -e -value $flag ratioButton;

		$flag = `snapMode -q -pixelSnap`;
		menuItem -e -cb  $flag ($popupPrefix+"ImageSnap") ;
		menuItem -e -cb  $flag ($menubarPrefix+"ImageSnap") ;
		iconTextCheckBox -e -value $flag pixelSnapButton;

		// update grid settings menu item
		//
		int $drawGrid = eval ($editorCmd +" -q -tgl "+ $editor) ;
		menuItem -e -cb  $drawGrid ($popupPrefix+"toggleGrid") ;
		menuItem -e -cb  $drawGrid ($menubarPrefix+"toggleGrid") ;
		iconTextCheckBox -e -value $drawGrid gridDisplayButton;
		
		// update uv tiles menu item
		//
		int $drawTL = eval ($editorCmd +" -q -tlb "+ $editor) ;
		menuItem -e -cb  $drawTL ($popupPrefix+"toggleTileLabels") ;
		menuItem -e -cb  $drawTL ($menubarPrefix+"toggleTileLabels") ;

		// update shade uv
		//
		int $shadeUV = eval ($editorCmd +" -q -displaySolidMap "+ $editor) ;
		menuItem -e -cb  $shadeUV ($popupPrefix+"MapOverlay") ;
		menuItem -e -cb  $shadeUV ($menubarPrefix+"MapOverlay") ;
		iconTextCheckBox -e -value $shadeUV overlapButton;

		// showUVGridButton -e -value 0; // update toolbar
		
		// update Toolbar menuItem
		//
		int $showToolbar = (!`optionVar -q textureEditorToolbarState`);
		menuItem -e -cb $showToolbar ($popupPrefix+"toggleToolbar");
		menuItem -e -cb $showToolbar ($menubarPrefix+"toggleToolbar");

		// update "contained faces" menu item
		//
		int $selectContained = eval($editorCmd + " -q -internalFaces " + $editor);
		menuItem -e -cb $selectContained ($popupPrefix+"containedFacesItem");
		menuItem -e -cb $selectContained ($menubarPrefix+"containedFacesItem");
		if ( $selectContained ) {
			optionVar -iv textureWindowShaderFacesMode 0;
		}			

		// update "connected faces" menu item
		//
		int $selectConnected = eval($editorCmd + " -q -relatedFaces " + $editor);
		menuItem -e -cb $selectConnected ($popupPrefix+"connectedFacesItem");
		menuItem -e -cb $selectConnected ($menubarPrefix+"connectedFacesItem");
		if ($selectConnected) {
			optionVar -iv textureWindowShaderFacesMode 0;
		}			

		// update "shader faces" menu item
		//
		int $useFaceGroup = eval($editorCmd + " -q -useFaceGroup " + $editor);
		int $selectShader = `optionVar -q textureWindowShaderFacesMode`;
		int $shaderFacesVal = 0;
		int $isolateViewVal = 0;

		if (0 == $useFaceGroup && 0 == $selectShader)
		{
			$shaderFacesVal = 0;
			$isolateViewVal = 0;
		}
		else
		{
			if (1 == $useFaceGroup && 0 == $selectShader)
			{
				$shaderFacesVal = 0;
				$isolateViewVal = 0;
			}
			if ( 1 == $useFaceGroup && 1 == $selectShader)
			{
				$shaderFacesVal = 1;
				$isolateViewVal = 0;
				int $shaderIndex = textureWindowFindActiveShader($editor);
				if (0 != $shaderIndex) 
					textureWindowSelectImage($shaderIndex-1, $editor);
			}
			if ( 1 == $useFaceGroup && 2 == $selectShader)
			{
				$shaderFacesVal = 0;
				$isolateViewVal = 1;
			}
		}
		menuItem -edit -checkBox $shaderFacesVal 
			($popupPrefix+"shaderFacesItem");
		menuItem -edit -checkBox $shaderFacesVal 
			($menubarPrefix+"shaderFacesItem");
		menuItem -edit -checkBox $isolateViewVal 
			($popupPrefix+"isolateViewItem");
		menuItem -edit -checkBox $isolateViewVal 
			($menubarPrefix+"isolateViewItem");
		iconTextCheckBox -edit -value $isolateViewVal isolateSelectButton;
	}
}

global proc txtWndShapesFromSelList(string $shapes[])
{
	// Counter to maintain current insertion point for new shapes
	//
	int $shapeCount = 0;
	
	// Loop through selection list *and* hilite list for shapes.
	//
	string $selList[] = `ls -l -sl`;
	string $hiliteList[] = `ls -l -hl`;
	$selList = stringArrayCatenate( $selList, $hiliteList );
	$selList = stringArrayRemoveDuplicates( $selList );

	int $i;
	for( $i = 0; $i < size($selList); $i++ )
	{
		// Determine object type
		//
		string $object = $selList[$i];
		string $type = `objectType $object`;

		string $tmpShapes[];
		int $nShapes = 0;
		if( $type == "transform" )
		{
			// Get all children that are shapes of the transform
			//
			$tmpShapes = `listRelatives -f -ad -typ "shape" $object`;
			$nShapes = size($tmpShapes);
		}
		else
		{
			// If it is not a transform, we assume it to be a shape.
			//
			$tmpShapes[0] = $object;
			$nShapes = 1;
		}

		// Append the list of shapes obtained from this object to our return
		// value
		//
		int $j;
		for( $j = 0; $j < $nShapes; $j++ )
		{
			$shapes[$shapeCount] = $tmpShapes[$j];
			$shapeCount++;
		}
	}
}

global proc txtWndSelectedTypes( int $selectedTypes[] )
//
//	Description:
//		Returns (3) booleans of what types have been selected. The integer array
//	parameter serves as the output array of booleans. The meaning of each element
//	is as follows:
//
//	$selectedType[0] == "A Poly is selected"
//	$selectedType[1] == "A NURBS is selected"
//	$selectedType[2] == "A Subdiv is selected"
//
{
	string $shapes[];
	txtWndShapesFromSelList( $shapes );

	int $polySelected = 0;
	int $nurbsSelected = 0;
	int $subdivSelected = 0;
	int $i = 0;
	int $nShapes = size($shapes);
	for( $i = 0; $i < $nShapes; $i++ )
	{
		string $type = `objectType $shapes[$i]`;
		if( $type == "mesh" )
		{
			$polySelected = 1;
		}
		else if( $type == "nurbsSurface" )
		{
			$nurbsSelected = 1;
		}
		else if( $type == "subdiv" )
		{
			$subdivSelected = 1;
		}
	}

	$selectedTypes[0] = $polySelected;
	$selectedTypes[1] = $nurbsSelected;
	$selectedTypes[2] = $subdivSelected;
}

global proc int queryNurbsEditUVMode()
{
	int $value = 0;

	string $shapes[];
	txtWndShapesFromSelList( $shapes );
	
	// Go through all shapes. If any one has EditUV mode enabled,
	// return true.
	//
	int $i;
	for( $i = 0; $i < size($shapes); $i++ )
	{
		// Only grab first selected object to reflect state
		//
		string $shape = $shapes[$i];

		if( `objectType $shape` == "nurbsSurface" )
		{
			int $values[] = `nurbsUVSet -q -ue $shape`;
			$value = $values[0];

			if( $value )
			{
				break;
			}
		}
	}
	return $value;
}

proc int isMesh(string $thisObject) {
	if ("" == $thisObject) return 0;
	return size(`polyListComponentConversion -tf $thisObject`);
}

global proc int textureWindowFindActiveShader(string $whichPanel)
{
	string $menuNames[] = `textureWindow -q -imageNames $whichPanel`;
	int $i = 0;	
	for ($menuName in $menuNames) {
		$i++;
		string $buffer[];
		tokenize $menuName " " $buffer;
		string $thisObject = $buffer[0];
		string $thisShader = $buffer[2];

		if (!isMesh($thisObject)) {
			continue;
		}
		
		int $activeGid = getAttr ($thisObject+".dfgi");
		string $objGroups[] = `listConnections -p on ($thisShader+".dsm")`; 
		string $shapes[] = `listConnections -sh on ($thisShader+".dsm")`;
		for ($objGroup in $objGroups) {
			int $gid = -99;
			if (`objExists ($objGroup+".gid")`) {
				if( catchQuiet( $gid = `getAttr ($objGroup+".gid")` ) ) {
					int $gids[] = `getAttr ($objGroup+".gid")`;
					if( size($gids) > 0 )
						$gid = $gids[0];
				}
			} else {
				continue;
			}
			if ($gid == $activeGid) {
				return $i;
			}
		}
	}
	return $i;
}

