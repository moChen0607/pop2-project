// Copyright (C) 1997-2014 Autodesk, Inc., and/or its licensors.
// All rights reserved.
//
// The coded instructions, statements, computer programs, and/or related
// material (collectively the "Data") in these files contain unpublished
// information proprietary to Autodesk, Inc. ("Autodesk") and/or its licensors,
// which is protected by U.S. and Canadian federal copyright law and by
// international treaties.
//
// The Data is provided for use exclusively by You. You have the right to use,
// modify, and incorporate this Data into other products for purposes authorized 
// by the Autodesk software license agreement, without fee.
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND. AUTODESK
// DOES NOT MAKE AND HEREBY DISCLAIMS ANY EXPRESS OR IMPLIED WARRANTIES
// INCLUDING, BUT NOT LIMITED TO, THE WARRANTIES OF NON-INFRINGEMENT,
// MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE, OR ARISING FROM A COURSE 
// OF DEALING, USAGE, OR TRADE PRACTICE. IN NO EVENT WILL AUTODESK AND/OR ITS
// LICENSORS BE LIABLE FOR ANY LOST REVENUES, DATA, OR PROFITS, OR SPECIAL,
// DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES, EVEN IF AUTODESK AND/OR ITS
// LICENSORS HAS BEEN ADVISED OF THE POSSIBILITY OR PROBABILITY OF SUCH DAMAGES.

//
//
//  Creation Date:  Jun 20, 1997
//<doc>
//<name groupObjectsByName>
//
//<synopsis>
//		string[] groupObjectsByName( string $objectList[], string $token )
//
//<description>
//		Given a list of strings, this procedure groups the strings into
//		lists with the same object.
//
//<flags>
//		string[]	$objectList List of objects to be grouped
//		string		$token	Separator at which the object grouping is defined
//
//<returns>
//		string[] : $objectList, grouped by types separated by $token
//
//<examples>
//  string $objectList[] = { "curve1.cv[1]",
//                           "curve1.u[0.3]",
//                           "curve3.cv[2]",
//                           "curve4.cv[0]",
//                           "curve1.cv[0]" };
//  groupObjectsByName($objectList, ".");
//  // Result : { "curve1.cv[1] curve1.u[0.3] curve1.cv[0]",
//  //            "curve3.cv[2]", "curve4.cv[0]" } //
//
//  // The token is the string that limits the object name.  Changing
//  // the token gives different results.
//  //
//  groupObjectsByName($objectList, "[");
//  // Result : { "curve1.cv[1] curve1.cv[0]", "curve1.u[0.3]",
//  //            "curve3.cv[2]", "curve4.cv[0]" } //
//
//</doc>
//

proc int foundObjectInList( string $name, string $listOfNames[] )
//
//	Description:
//		This procedure returns true if the given name was found in the
//		list of names.  WARNING: this is a slow algorithm and is not
//		efficient when dealing with a long list of names.
//
{
	int $index = -1;
	int $foundName = false;
	int $numNames = size( $listOfNames );
	for( $i = 0; $i < $numNames; $i ++ )
	{
		if( $name == $listOfNames[$i] )
		{
			$foundName = true;
			$index = $i;
			return $index;
		}
	}

	return $index;	
}

global proc string[] groupObjectsByName( string $objectList[], string $token )
{
	string $processedNames[];
	string $argList[];
	int $i;

	// for each object in objectList, try to group it with previous objects
	//
	int $numObjects = size($objectList);

	for( $i = 0; $i < $numObjects; $i ++ )
	{
		string $objectName[];
		$numTokens = `tokenize $objectList[$i] $token $objectName`;

		if( $numTokens > 0 )
		{
			int $index = foundObjectInList( $objectName[0], $processedNames );
			if( $index >= 0 )
			{
				// Concatenate the string
				//
				$argList[$index] = $argList[$index] + " ";
				$argList[$index] = $argList[$index] + $objectList[$i];
			}
			else
			{
				// Add this name to the $processedNames
				//
				int $processedNamesSize = size( $processedNames );
				$processedNames[$processedNamesSize] = $objectName[0];

				// start a new arg string
				//
				int $argSize = size( $argList );
				$argList[$argSize] = $objectList[$i];
			}
		}
	}
	return $argList;
}
