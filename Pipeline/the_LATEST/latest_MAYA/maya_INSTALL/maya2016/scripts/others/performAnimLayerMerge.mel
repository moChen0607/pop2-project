// Copyright (C) 1997-2014 Autodesk, Inc., and/or its licensors.
// All rights reserved.
//
// The coded instructions, statements, computer programs, and/or related
// material (collectively the "Data") in these files contain unpublished
// information proprietary to Autodesk, Inc. ("Autodesk") and/or its licensors,
// which is protected by U.S. and Canadian federal copyright law and by
// international treaties.
//
// The Data is provided for use exclusively by You. You have the right to use,
// modify, and incorporate this Data into other products for purposes authorized 
// by the Autodesk software license agreement, without fee.
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND. AUTODESK
// DOES NOT MAKE AND HEREBY DISCLAIMS ANY EXPRESS OR IMPLIED WARRANTIES
// INCLUDING, BUT NOT LIMITED TO, THE WARRANTIES OF NON-INFRINGEMENT,
// MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE, OR ARISING FROM A COURSE 
// OF DEALING, USAGE, OR TRADE PRACTICE. IN NO EVENT WILL AUTODESK AND/OR ITS
// LICENSORS BE LIABLE FOR ANY LOST REVENUES, DATA, OR PROFITS, OR SPECIAL,
// DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES, EVEN IF AUTODESK AND/OR ITS
// LICENSORS HAS BEEN ADVISED OF THE POSSIBILITY OR PROBABILITY OF SUCH DAMAGES.


//
//  Description:
//      This is a helper script to setup the UI option box for merging 
//  animation layers
//
//  Input Arguments:
//		int action			0 - just execute the command
//						1 - show the option box dialog
//						2 - return the command
//
//  Return Value:
//      None.
//

proc setOptionVars(int $forceFactorySettings)
{

	// Merges to a in the first or in the last layer
	if ($forceFactorySettings || !`optionVar -exists animLayerMergeUp`) {
		optionVar -intValue animLayerMergeUp 1;
	}

	// Bake selected layers or selected and their childs
	if ($forceFactorySettings || !`optionVar -exists animLayerMergeChilds`) {
		optionVar -intValue animLayerMergeChilds 0;
	}

	if ($forceFactorySettings || !`optionVar -exists animLayerMergeResultType`) {
		optionVar -intValue animLayerMergeResultType 0;
	}

	if ($forceFactorySettings || !`optionVar -exists animLayerMergeDeleteLayers`) {
		optionVar -intValue animLayerMergeDeleteLayers 1;
	}

	if ($forceFactorySettings || !`optionVar -exists animLayerMergeBakeAll`) {
		optionVar -intValue animLayerMergeBakeAll 1;
	}
	
	//	By Time
	//
	if ($forceFactorySettings || !`optionVar -exists animLayerMergeByTime`) {
		optionVar -floatValue animLayerMergeByTime 1.0;
	}

	//	Smart Bake
	//
	if ($forceFactorySettings || !`optionVar -exists animLayerMergeSmartBake`) {
		optionVar -intValue animLayerMergeSmartBake 0;
	}

	//
	if ($forceFactorySettings || !`optionVar -exists animLayerMergeSmartFidelity`) {
		optionVar -intValue animLayerMergeSmartFidelity 0.0;
	}

	if ($forceFactorySettings || !`optionVar -exists animLayerMergeSmartFidelityDelta`) {
		optionVar -floatValue animLayerMergeSmartFidelityDelta 5;
	}
}


//
//  Procedure Name:
//      animLayerMergeSetup
//
//  Description:
//		Update the state of the option box UI to reflect the option values.
//
//  Input Arguments:
//      parent               - Top level parent layout of the option box UI.
//                             Required so that UI object names can be 
//                             successfully resolved.
//
//		forceFactorySettings - Whether the option values should be set to
//                             default values.
//
//  Return Value:
//      None.
//
global proc animLayerMergeSetup(string $parent, int $forceFactorySettings)
{
	//	Retrieve the option settings
	//

	setOptionVars($forceFactorySettings);
	setParent $parent;


	radioButtonGrp -edit -select ((`optionVar -query animLayerMergeUp`)!=0?2:1) animLayerMergeToRB;

	radioButtonGrp -edit -select ((`optionVar -query animLayerMergeChilds`)!=0?2:1) animLayerMergeChildsRB;

	radioButtonGrp -edit -select (`optionVar -query animLayerMergeResultType`+1) animLayerMergeResultRB;

	checkBoxGrp -edit -value1 ((`optionVar -query animLayerMergeDeleteLayers`)?1:0) animLayerMergeDeleteLayersCB;
	
	checkBoxGrp -edit -value1 ((`optionVar -query animLayerMergeBakeAll`)?0:1) animLayerMergeBakeNotAllCB;

	floatFieldGrp -edit -value1 `optionVar -query animLayerMergeByTime` animLayerMergeSampleByValueF;

	checkBoxGrp -edit -value1 ((`optionVar -query animLayerMergeSmartBake`)?1:0) animLayerMergeSmartBakeCB;


	checkBoxGrp -edit -value1 ((`optionVar -query animLayerMergeSmartFidelity`)?1:0) animLayerMergeIncreaseFedelityCB;

	floatFieldGrp -edit -value1 `optionVar -query animLayerMergeSmartFidelityDelta` animLayerMergeFidelityDeltaF;
}

proc updateMergeOptionVarsFromUI()
{
	optionVar -intValue animLayerMergeUp ((`radioButtonGrp -q -select animLayerMergeToRB`)==2?1:0);

	optionVar -intValue animLayerMergeChilds ((`radioButtonGrp -q -select animLayerMergeChildsRB`)==2?1:0);

	optionVar -intValue animLayerMergeResultType ((`radioButtonGrp -q -select animLayerMergeResultRB`)-1);

	optionVar -intValue animLayerMergeDeleteLayers `checkBoxGrp -q -value1 animLayerMergeDeleteLayersCB`;

	optionVar -intValue animLayerMergeBakeAll (!(`checkBoxGrp -q -value1 animLayerMergeBakeNotAllCB`));
	
	optionVar -floatValue animLayerMergeByTime `floatFieldGrp -q -value1 animLayerMergeSampleByValueF`;

	optionVar -intValue animLayerMergeSmartBake `checkBoxGrp -q -value1 animLayerMergeSmartBakeCB`;

	optionVar -intValue animLayerMergeSmartFidelity `checkBoxGrp -q -value1 animLayerMergeIncreaseFedelityCB`;

	optionVar -floatValue animLayerMergeSmartFidelityDelta `floatFieldGrp -q -value1 animLayerMergeFidelityDeltaF`;
}

//
//  Procedure Name:
//      animLayerMergeCallback
//
//  Description:
//		Update the option values with the current state of the option box UI.
//
//  Input Arguments:
//      parent - Top level parent layout of the option box UI.  Required so
//               that UI object names can be successfully resolved.
//
//	doIt       - Whether the command should execute.
//
//  Return Value:
//      None.
//
global proc animLayerMergeCallback (string $parent, int $doIt)
{
    setParent $parent;	

	updateMergeOptionVarsFromUI();
	

	if ($doIt)
	{	
		performAnimLayerMerge 0;
	}
}

global proc animLayerMergeRefreshStates()
{
	int $lSmart = `checkBoxGrp -q -value1 animLayerMergeSmartBakeCB`;
	int $lAddKeys = `checkBoxGrp -q -value1 animLayerMergeIncreaseFedelityCB`;


	floatFieldGrp -e -enable (!$lSmart) animLayerMergeSampleByValueF;

	checkBoxGrp -e -enable $lSmart animLayerMergeIncreaseFedelityCB;

	floatFieldGrp -e -enable ($lSmart&&$lAddKeys) animLayerMergeFidelityDeltaF;
}

proc string createAnimLayerMergeWidgets( string $parent )
{
	setParent $parent;
	
	string $tabForm = `columnLayout -adjustableColumn true`;	



	// frameLayout -bv no -lv no -collapsable no;

	radioButtonGrp -numberOfRadioButtons 2
		-label (uiRes("m_performAnimLayerMerge.kAnimLayerMergeTo")) 
		-label1 (uiRes("m_performAnimLayerMerge.kAnimLayerMergeToUp")) 
		-label2 (uiRes("m_performAnimLayerMerge.kAnimLayerMergeToDown")) 
		animLayerMergeToRB;

	radioButtonGrp -numberOfRadioButtons 2
		-label (uiRes("m_performAnimLayerMerge.kAnimLayerMergeChilds")) 
		-label1 (uiRes("m_performAnimLayerMerge.kAnimLayerMergeChildsNo")) 
		-label2 (uiRes("m_performAnimLayerMerge.kAnimLayerMergeChildsYes")) 
		animLayerMergeChildsRB;

	separator;

	radioButtonGrp -numberOfRadioButtons 3
		-label (uiRes("m_performAnimLayerMerge.kAnimLayerMergeResult")) 
		-label1 (uiRes("m_performAnimLayerMerge.kAnimLayerMergeResult1")) 
		-label2 (uiRes("m_performAnimLayerMerge.kAnimLayerMergeResult2")) 
		-label3 (uiRes("m_performAnimLayerMerge.kAnimLayerMergeResult3")) 
		animLayerMergeResultRB;

	checkBoxGrp 
		-label (uiRes("m_performAnimLayerMerge.kAnimLayerMergeDeleteLayers")) 
		animLayerMergeDeleteLayersCB;

	checkBoxGrp 
		-label (uiRes("m_performAnimLayerMerge.kAnimLayerMergeBakeOnlyNeeded")) 
		-visible false
		animLayerMergeBakeNotAllCB;

	separator;

	floatFieldGrp -label (uiRes("m_performAnimLayerMerge.kAnimLayerMergeSampleBy"))  -value1 1.0 animLayerMergeSampleByValueF;

	checkBoxGrp 
		-label (uiRes("m_performAnimLayerMerge.kAnimLayerMergeSmartBake")) 
		-enable true
		-onCommand "animLayerMergeRefreshStates"
		-offCommand "animLayerMergeRefreshStates"
		animLayerMergeSmartBakeCB;

	checkBoxGrp 
		-label (uiRes("m_performAnimLayerMerge.kAnimLayerMergeIncreaseFidelity")) 
		-visible true
		-onCommand "animLayerMergeRefreshStates"
		-offCommand "animLayerMergeRefreshStates"
		animLayerMergeIncreaseFedelityCB;

	floatFieldGrp -label (uiRes("m_performAnimLayerMerge.kAnimLayerFidelityDelta"))  
				  -extraLabel (uiRes("m_performAnimLayerMerge.kAnimLayerFidelityUnits"))
				  -value1 0.250 
		  		  -visible true
				  animLayerMergeFidelityDeltaF;

	setParent ..;


	return $tabForm;
}

global proc animLayerMergeOptions ()
{

	string $commandName = "animLayerMerge";


	string $callback = ($commandName + "Callback");
	string $setup = ($commandName + "Setup");


	string $layout = getOptionBox();
	setParent $layout;

	setOptionBoxCommandName("animLayer");

	setUITemplate -pushTemplate DefaultTemplate;
	waitCursor -state 1;
	tabLayout -scr true -tv false;	// To get the scroll bars

	string $parent = `columnLayout -adjustableColumn 1`;

	createAnimLayerMergeWidgets $parent;

	waitCursor -state 0;
	setUITemplate -popTemplate;

	//	'Apply' button.
	//
	string $applyBtn = getOptionBoxApplyBtn();
	button -edit		
		-command ($callback + " " + $parent + " " + 1)
		-label (uiRes("m_performAnimLayerMerge.kAnimLayerMergeApply"))
		$applyBtn;

	//	'Save' button.
	//
	string $saveBtn = getOptionBoxSaveBtn();
	button -edit 
		-command ($callback + " " + $parent + " " + 0 + "; hideOptionBox")
		$saveBtn;

	//	'Reset' button.
	//
	string $resetBtn = getOptionBoxResetBtn();
	button -edit 
		-command ($setup + " " + $parent + " " + 1)
		$resetBtn;

	//	Set the option box title.
	//
	setOptionBoxTitle (uiRes("m_performAnimLayerMerge.kAnimLayerMergeOptions"));
	
	setOptionBoxHelpTag("AnimLayerMerge");

	//	Set the current values of the option box.
	//
	eval (($setup + " " + $parent + " " + 0));	
	animLayerMergeRefreshStates;
	
	//	Show the option box.
	//
	showOptionBox();
}

proc string[] appendArray(string $a[], string $b[]) 
//
//	Description:
//		Appends the contents of $b onto $a
//
{
	string $combined[] = $a;
	int $nA = size($combined);

	int $nB = size($b);

	for ($ii = 0; $ii < $nB; $ii++) {
		$combined[$nA++] = $b[$ii];
	}

	return $combined;
}

proc string[] makeUnique(string $a[]) 
//
//	Description:
//		Returns a unique string array in alphabetcial order.
//
{
	string $sorted[] = sort($a);

	int $index = 0;
	string $newArray[];

	int $nItems = size($sorted);
	if ($nItems > 0) {
		$newArray[$index++] = $sorted[0];
	}

	for ($ii = 1; $ii < $nItems; $ii++) {
		if ($sorted[$ii] != $sorted[$ii-1]) {
			$newArray[$index++] = $sorted[$ii];
		}
	}

	return $newArray;
}


proc addNodeRecursive( string $layerNode, string $layers[] )
{
	$layers[size($layers)] = $layerNode;

    string $children[] = `animLayer -query -children $layerNode`;

    int $iter = 0;
	for(; $iter < size($children); $iter++)
	{
		addNodeRecursive( $children[$iter], $layers );
	}
}

proc getAllLayersOrdered( string $layers[] )
{
	// 
	string $rootLayer = `animLayer -q -root`;

	if( $rootLayer != "" )
	{
		addNodeRecursive( $rootLayer, $layers );
	}
}

proc orderLayers( string $layers[] )
{

	string $lNewList[];
	string $lAllLayers[];

	getAllLayersOrdered($lAllLayers);

	// Follow layer hierarchy and if you find 
	for($layer1 in $lAllLayers )
	{
		for($layer2 in $layers )
		{
			if( $layer2 == $layer1  )
			{
				$lNewList[size($lNewList)] = $layer1;
			}
		}
	}
	$layers = $lNewList;
}

proc addChildLayers( string $layers[] )
{
	string $lNewList[];
	string $lAllLayers[];

	getAllLayersOrdered($lAllLayers);

	// Follow layer hierarchy and if you find 
	for($layer1 in $lAllLayers )
	{
		int $lAlreadyAdded = false;

		for($layer2 in $lNewList )
		{
			if( $layer2 == $layer1  )
			{
				$lAlreadyAdded = true;
			}
		}

		if( !$lAlreadyAdded )
		{
			for($layer2 in $layers )
			{
				if( $layer2 == $layer1  )
				{
					addNodeRecursive( $layer1, $lNewList );
				}
			}
		}
	}
	$layers = $lNewList;
}

proc tryMovingCurves( string $layers[], string $attributes[], string $destLayer )
{
	string $layerAttributes[];

	// Find the list of layers compatible with destLayer
	// Assuming $destLayer is not animated
	string $compatibleLayers[];

	int $destOverride    = `animLayer -query -override $destLayer`;
	int $destRotMode     = `getAttr( $destLayer+".rotationAccumulationMode")`;
	int $destScalingMode	= `getAttr( $destLayer+".scaleA-ccumulationMode")`;

	for( $layer in $layers )
	{
		// check that the weight is 1 and not animated (lots of conditions to check)
		// We just check for one since animation is not easy, the user just have to disable the option if not happy

		// Check other attributes

		int $lOverride    = `animLayer -query -override $layer`;
		int $lRotMode     = `getAttr( $layer+".rotationAccumulationMode")`;
		int $lScalingMode = `getAttr( $layer+".scaleAccumulationMode")`;
		float $lWeight	  = `getAttr( $layer+".foregroundWeight")`;

		if( $lWeight >= 1.0  // No check for epsilon here because we want to skip animated stuff
			&& $lOverride == $destOverride
			&& $lRotMode  == $destRotMode
			&& $lScalingMode  == $destScalingMode )
		{
			// Got One
			$compatibleLayers[size($compatibleLayers)] = $layer;
		}
	}


	// Find attributes that are specific to the $compatibleLayers
	// this could be optimised if needed
	string $movableAttributes[];
	string $nonMovableAttributes[];

	for($layer in $compatibleLayers)
	{
		$layerAttributes = `animLayer -query -attribute $layer`;

		for( $attribute in $layerAttributes )
		{
			int $lUnique = true;

			for($layer2 in $layers)
			{
				if( $layer2 != $layer )
				{
					string $layerAttributes2[] = `animLayer -query -attribute $layer2`;

					for( $attribute2 in $layerAttributes2 )
					{
						if( $attribute2 == $attribute )
						{
							$lUnique = false;
							break;
						}
					}
				}

				if( !$lUnique )
				{
					break;
				}
			}

			if( $lUnique )
			{
				$movableAttributes[ size($movableAttributes) ] = $attribute;
			}
		}
	}


	
	// Move the attributes that can be moved
	// Add the attributes that can be modes to the destination layer and then do an extract animation

	for( $attribute in $movableAttributes )
	{
		animLayer -edit -attribute $attribute $destLayer;
	}

	for( $layer in $compatibleLayers )
	{
		animLayer -edit -extractAnimation $layer $destLayer; // Sould copy only if not deleting baked layers
	}

	// Update the attribute list to bake
	for( $attribute in $attributes )
	{
		int $lFound = false;

		for( $attribute2 in $movableAttributes )
		{
			if( $attribute == $attribute2 )
			{
				$lFound = true;
				break;
			}
		}

		if( !$lFound )
		{
			$nonMovableAttributes[ size($nonMovableAttributes) ] = $attribute;
		}
	}
	$attributes = $nonMovableAttributes;

}

proc deleteEmptyLayers( string $layers[] )
{
	// Delete empty layers, should be move to the bakeResult command and expanded to work on bake
	orderLayers($layers);

    int $iter = size($layers)-1;

	for(; $iter >=0; $iter--)
    {
	    string $children[] = `animLayer -query -children $layers[$iter]`;
	    string $attr[] = `animLayer -query -attribute $layers[$iter]`;

		if( size( $children )== 0 && size( $attr )== 0 )
		{
			delete $layers[$iter];			
		}
	}
}

global proc animLayerMerge( string $layers[] )
{
	int $lMergingBase = false;

	orderLayers($layers);

	// Remove Base Layer if it is part of the list because it does not work for now

	if( size( $layers ) > 0 )
	{
		if( `animLayer -q -parent $layers[0]` == "" )
		{
			// warning( _L10N( kAnimLayerMergeNoBaseSupportWrn," animLayerMerge does not support BaseAnimation\n"));

			$lMergingBase = true;

			// Replace first layer with a new real layer on which we will extract the content of the base
			string $lNewBase = `animLayer -override 1 "BaseCopy"`;

			string $children[] = `animLayer -query -children $layers[0]`;

			if( size( $children ) )
			{
				animLayer -edit -moveLayerBefore $children[0] $lNewBase;
			}

			$layers[0] = $lNewBase;
		}
	}


	string $lSelectedLayers[] = $layers;

	if( `optionVar -query animLayerMergeChilds` )
	{
		addChildLayers($layers);
	}


	// Identify the attributes to bake
	string $attributes[];

	for($layer in $layers)
	{
		string $attrs[] = `animLayer -query -attribute $layer`;

		$attributes = appendArray( $attributes, $attrs );
	}
	
	$attributes = makeUnique( $attributes );

	// Only continue if they are attributes to merge otherwise the bakeResult command will bake the selection
	if( size($attributes) > 0 )
	{

		// Create the destination layer
		int $override = 0;
		int $rotationMode = 0;
		int $scalingMode = 0;
		string $destLayer = "Merged_Layer";

		$destLayer = `animLayer $destLayer`;

		// Determine the type and cumulation mode of the new layer
		int $lOverrideCount = 0;
		int $lRotationTotal = 0;
		int $lScalingTotal = 0;


		int $lResultType = (`optionVar -query animLayerMergeResultType`)+1;

		for($layer in $layers)
		{
			if( `animLayer -query -override $layer` ) $lOverrideCount++;
			if( `getAttr($layer+".rotationAccumulationMode")` ) $lRotationTotal++;
			if( `getAttr($layer+".scaleAccumulationMode")` ) $lScalingTotal++;
		}


		if( ($lResultType<2 && $lOverrideCount > 0)||($lResultType==3) )
		{
			animLayer -edit -override 1 $destLayer;
		}

		setAttr( $destLayer+".scaleAccumulationMode", ($lScalingTotal*2>= size($layers))?1:0 );
		setAttr( $destLayer+".rotationAccumulationMode",  ($lRotationTotal*2>= size($layers))?1:0 );


		// Determine its position
		// Just crate a brother fot the first layer of the list for now

		string $lTargetLayer = $lSelectedLayers[0];

		if( !(`optionVar -query animLayerMergeUp`) )
		{
			$lTargetLayer = $lSelectedLayers[size($lSelectedLayers)-1];
		}


        string $lParent = `animLayer -q -parent $lTargetLayer`;            

		animLayer -edit -parent $lParent $destLayer;

		if( (`optionVar -query animLayerMergeUp`) )
		{
			animLayer -edit -moveLayerBefore $lTargetLayer $destLayer;
		}
		else
		{
			animLayer -edit -moveLayerAfter $lTargetLayer $destLayer;
		}

		// Extract the animation from the base to the temp base if needed
		if( $lMergingBase )
		{
			for($attr in $attributes)
			{
				animLayer -edit -attribute $attr $lSelectedLayers[0];
			}

			
			if( (`optionVar -query animLayerMergeUp`) || !(`optionVar -query animLayerMergeDeleteLayers`) )
			{
				// Case where the existing base animation is expected to remain or being replaced but not cleared
				// For this case, the original base layer curves must remain in place during the merge operaton 
				// in order to preserve any important connection these curve nodes had with the rest of the scene
				// Trax owned curves have their ".apply" plug connected and we want to preserve that connection by making a copy
 				// intead of a extract/move operation, bug 322484
				animLayer -edit -copyAnimation (`animLayer -q -parent $lSelectedLayers[0]`) $lSelectedLayers[0];
			}
			else
			{
				// Case where the Base animation is expected to be cleared after the Merge operation
				animLayer -edit -extractAnimation (`animLayer -q -parent $lSelectedLayers[0]`) $lSelectedLayers[0];			
			}
		}

		// Try moving curves that can be moved
		if( !(`optionVar -query animLayerMergeBakeAll`) )
		{

			/* Option currently not exposed in the UI
			tryMovingCurves( $layers, $attributes, $destLayer );
			*/
		}

		if( size( $attributes ) )
		{

			// Add the baked attributes to the resulting layer
			// Add attributes to it
			for($attr in $attributes)
			{
				animLayer -edit -attribute $attr $destLayer;
			}


			// Mute the result layer before baking
			animLayer -edit -mute 1 $destLayer;
			dgdirty -allPlugs;

			// If there is an override layer overriding what we are trying to merge we should also mute all these 
			// Workarround, manually mute overriding layers


			// Build the command and Call the bake function
			string $lCommand = "bakeResults -simulation false -dic false -removeBakedAttributeFromLayer "+ `optionVar -query animLayerMergeDeleteLayers` +" -destinationLayer " +$destLayer;
			
			if( `optionVar -query animLayerMergeSmartBake` )
			{
				$lCommand = $lCommand + " -smart 1";

				if( `optionVar -query animLayerMergeSmartFidelity` )
				{
					$lCommand = $lCommand +" "+ `optionVar -query animLayerMergeSmartFidelityDelta`;
				}

			}

			// Adjust the pitch
			$lCommand = $lCommand + " -sampleBy " + `optionVar -query animLayerMergeByTime`;

			// Adjust time range (default time range is provided but can be expanded the bake command if it find that they are keys outside of the specified range)
			$lCommand= ($lCommand+ " -time \"" + `playbackOptions -query -minTime` + ":" +`playbackOptions -query -maxTime` + "\"");

			for($layer in $layers)
			{
				$lCommand  = $lCommand + " -resolveWithoutLayer "+$layer;
			}

			for($attr in $attributes)
			{
				$lCommand  = $lCommand +" "+$attr;
			}

			evalEcho($lCommand);

			// Un-Mute the result layer before baking
			animLayer -edit -mute 0 $destLayer;
		}

		// Delete the souce layers
		if( `optionVar -query animLayerMergeDeleteLayers` )
		{
			if( $lMergingBase && (`optionVar -query animLayerMergeUp`) )
			{
				// Move the merged animation to the base
				animLayer -edit -extractAnimation $destLayer (`animLayer -q -parent $lSelectedLayers[0]`);

				// Add the $destKayer to $layers to get it deleted
				$layers[ size($layers) ] = $destLayer;
			}
			
			deleteEmptyLayers( $layers );
		}
		else
		{
			// Just mute the selected layers
			// Result will move if you merged parent layers but not all their childs
			for($layer in $lSelectedLayers)
			{
				animLayer -edit -mute 1 $layer;
			}

			if( $lMergingBase )
			{
				// Still delete the Base extraction that have been done since it is only a temporary layer
				animLayer -edit -extractAnimation $lSelectedLayers[0] (`animLayer -q -parent $lSelectedLayers[0]`) ;
				delete $lSelectedLayers[0];	
			}
		}
		dgdirty -allPlugs;

        select -cl;

	}

}


//
//  Procedure Name:
//      autoAnimLayerMerge
//
//  Description:
//		Automatically merges then removes all animation layers.
//		Does not merge if reference nodes in scene
//
//  Input Arguments:
//      None.
//
//  Return Value:
//      0 scene was not modified
//      1 scene was modified
//
global proc int autoAnimLayerMerge()
{
	string $layerArray[];
	getAllLayersOrdered($layerArray);
	if( size($layerArray) == 0 )
	{
		return 0;
	}
	
	// Cannot merge if any animLayer is a referenced node
	string $layer;
	for($layer in $layerArray)
	{
		if ( `referenceQuery -isNodeReferenced $layer` == 1 )
		{
			// Cannot merge because we have referenced animLayer nodes!
			return 0;
		}
	}

	// Cannot merge if any object is referenced node
	string $refs[] = `file -q -r`;
	if(size($refs) > 0)
	{
		return 0;
	}

	// Merge if more than one layer
	if ( size($layerArray) > 1 )
	{
		// Create optionVars that do not exist
		setOptionVars(0);

		// Backup options
		int $animLayerMergeUpVal = `optionVar -query animLayerMergeUp`;
		int $animLayerMergeChildsVal = `optionVar -query animLayerMergeChilds`;
		int $animLayerMergeResultTypeVal = `optionVar -query animLayerMergeResultType`;
		int $animLayerMergeDeleteLayersVal = `optionVar -query animLayerMergeDeleteLayers`;
		int $animLayerMergeBakeAllVal = `optionVar -query animLayerMergeBakeAll`;
		float $animLayerMergeByTimeVal = `optionVar -query animLayerMergeByTime`;
		int $animLayerMergeSmartBakeVal = `optionVar -query animLayerMergeSmartBake`;
		int $animLayerMergeSmartFidelityVal = `optionVar -query animLayerMergeSmartFidelity`;
		float $animLayerMergeSmartFidelityDeltaVal = `optionVar -query animLayerMergeSmartFidelityDelta`;

		// Set options to factory defaults
		setOptionVars(1);

		// Set option to enable smart bake, we want curves to be editable afterwards
		optionVar -intValue animLayerMergeSmartBake 1;

		// Perform merge
		animLayerMerge($layerArray);

		// Restore options
		optionVar -intValue animLayerMergeUp $animLayerMergeUpVal;
		optionVar -intValue animLayerMergeChilds $animLayerMergeChildsVal;
		optionVar -intValue animLayerMergeResultType $animLayerMergeResultTypeVal;
		optionVar -intValue animLayerMergeDeleteLayers $animLayerMergeDeleteLayersVal;
		optionVar -intValue animLayerMergeBakeAll $animLayerMergeBakeAllVal;
		optionVar -floatValue animLayerMergeByTime $animLayerMergeByTimeVal;
		optionVar -intValue animLayerMergeSmartBake $animLayerMergeSmartBakeVal;
		optionVar -intValue animLayerMergeSmartFidelity $animLayerMergeSmartFidelityVal;
		optionVar -floatValue animLayerMergeSmartFidelityDelta $animLayerMergeSmartFidelityDeltaVal;
	}

	// Delete BaseAnimation layer
	string $lRootLayer = `animLayer -q -root`;
	if( $lRootLayer != "" )
	{
		delete $lRootLayer;
	}

	return 1;
}

//
//  Procedure Name:
//      performAnimLayerMerge
//
//  Description:
//		Creates the UI to merge animation layers.
//
//  Input Arguments:
//      0 - Execute the command.
//      1 - Show the option box dialog.
//      2 - Return the command.
//
//  Return Value:
//      None.
//
global proc string performAnimLayerMerge (int $action)
{
    global string $gSelectedAnimLayers[];

	switch ($action) {

		//	Execute the command.
		//
		case 0:
			//	Retrieve the option settings
			//
			setOptionVars(false);

			//	Execute the command with the option settings.
			//
			animLayerMerge($gSelectedAnimLayers);

			break;

		//	Show the option box.
		//
		case 1:
			animLayerMergeOptions;
			break;
		case 2:
			//	Get the command.
			//
			// Command would be too complex, not implemented
			break;
	}
	return "";
}

