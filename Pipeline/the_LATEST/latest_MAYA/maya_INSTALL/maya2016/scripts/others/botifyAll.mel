// Copyright (C) 1997-2014 Autodesk, Inc., and/or its licensors.
// All rights reserved.
//
// The coded instructions, statements, computer programs, and/or related
// material (collectively the "Data") in these files contain unpublished
// information proprietary to Autodesk, Inc. ("Autodesk") and/or its licensors,
// which is protected by U.S. and Canadian federal copyright law and by
// international treaties.
//
// The Data is provided for use exclusively by You. You have the right to use,
// modify, and incorporate this Data into other products for purposes authorized 
// by the Autodesk software license agreement, without fee.
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND. AUTODESK
// DOES NOT MAKE AND HEREBY DISCLAIMS ANY EXPRESS OR IMPLIED WARRANTIES
// INCLUDING, BUT NOT LIMITED TO, THE WARRANTIES OF NON-INFRINGEMENT,
// MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE, OR ARISING FROM A COURSE 
// OF DEALING, USAGE, OR TRADE PRACTICE. IN NO EVENT WILL AUTODESK AND/OR ITS
// LICENSORS BE LIABLE FOR ANY LOST REVENUES, DATA, OR PROFITS, OR SPECIAL,
// DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES, EVEN IF AUTODESK AND/OR ITS
// LICENSORS HAS BEEN ADVISED OF THE POSSIBILITY OR PROBABILITY OF SUCH DAMAGES.

proc string fileTail ( string $file )
//
// Purpose: returns the tail of a given filename 
//			(for example, the tail of a/b/foo is "foo").
//
{
	int $len = size ( $file );

	if ( $len == 0 ) {
		return "";

	} else {

		// search backwards to find a file separator
		int $i;
		for ( $i = $len ; $i > 0 ; $i-- ) {
			string $sub = `substring $file $i $i`;
			if( ($sub == "/") || ($sub == "\\") ) {
				return `substring $file ($i+1) $len`;
			}
		}

		return $file;
	}
}

global proc botifyAll ( int $verb, int $minRes, string $outputDir, int $force, int $absolute )
//
//	Purpose: Converts file textures in the scene to BOT files, according to various criteria.
//
//	Parameters:
//				verb:	Verbose mode.  Outputs various information about the file textures
//						in the scene, and causes 'makebot' to be invoked in verbose mode.
//
//				minRes:	Minimum resolution for textures to be converted to BOT format.  Since
//						there is a slight performance hit when using small BOT files, this
//						option allows the user to specify that only file textures larger than
//						'minRes' pixels on a side will be converted.
//
//			 outputDir: Directory where the BOT files will be stored.  If this parameter is
//						"", then the BOT files will be stored in the same directories as the
//						original image files.
//
//				 force: By default, the script will only generate BOT files if it needs to - 
//						if the BOT file for a particular file texture already exists and is
//						newer than the original image, then it doesn't need to be regenerated.
//						The 'force' parameter overrides this behaviour, and cause the script
//						to always regenerate the BOT files.
//			
//			  absolute: Determines whether to store the file texture paths as absolute or
//						relative pathnames.
//
{
	// basic command used to convert images to BOT format
	string $makebotCmd = "makebot -checkres " + $minRes;

	// add verbose option to command string
	if( $verb ) {
		$makebotCmd += " -v ";
	}

	// the '-c' option on makebot is used to check dependencies - the BOT file is
	// only generated if it doesn't already exist, or if it exists, but is older than
	// the source image file
	if( ! $force ) {
		$makebotCmd += " -c ";
	}

	// we will loop through all file texture nodes
	string $texNodes[] = `ls -typ file`;

	// output info about script parameters
	if( $verb ) {
		print( (uiRes("m_botifyAll.kExecAll")) );
		print( (uiRes("m_botifyAll.kVerbose")) );
		string $msg = (uiRes("m_botifyAll.kGreaterRes"));
		print(`format -stringArg $minRes $msg`);
		if( $outputDir != "" ) {
			string $msg = (uiRes("m_botifyAll.kOutputDir"));
			print(`format -stringArg $outputDir $msg`);
		} else {
			print( (uiRes("m_botifyAll.kSameDir")) );
		}
		
		if( ! $force ) {
			print( (uiRes("m_botifyAll.kNotForceAll")) );
		} else {
			print( (uiRes("m_botifyAll.kForceAll")) );
		}

		if( $absolute ) {
			print( (uiRes("m_botifyAll.kAbsolute")));
		} else {
			print( (uiRes("m_botifyAll.kRelative")));
		}
	}

	for ( $node in $texNodes ) {

		string $curCmd = $makebotCmd;
		string $f = `getAttr ($node + ".fileTextureName")`;

		if( $verb ) {
			string $msg = (uiRes("m_botifyAll.kProcessing"));
			print (`format -stringArg $node $msg`);
			$msg = (uiRes("m_botifyAll.kFile"));
			print(`format -stringArg $f $msg`);
		}

		// construct the name of the BOT file to be created: use 
		// "outputDir" if specified, or the source image location
		// otherwise.  The filename is just the name of the source
		// image with ".bot" appended.
		string $botName;
		if( $outputDir == "" ) {
			$botName = $f + ".bot";
		} else {
			// reroot the filename into the output directory
			string $fTail = fileTail( $f );
			$botName = $outputDir + "/" + $fTail + ".bot";
		}

		// append the input and output file parameters to the makebot command
		$curCmd += " -i \"" + $f + "\" -o \"" + $botName + "\"";
		
		if( $verb ) {
			string $msg = (uiRes("m_botifyAll.kExecuting"));
			print(`format -stringArg $curCmd $msg`);
			$msg = (uiRes("m_botifyAll.kGeneratingBOT"));
			print(`format -stringArg $f $msg`);
		}

		// evaluate the makebot command.  If the command encounters no errors,
		// and an up-to-date BOT file is created (or already exists), then the
		// command will return the absolute pathname of that file.  Otherwise,
		// it returns the empty string.
		string $resultFile = `eval($curCmd)`;

		if( $verb ) {
			string $msg = (uiRes("m_botifyAll.kResultFile"));
			print (`format -stringArg $resultFile $msg`);
		}

		if( $resultFile != "" ) {
			
			// an up-to-date BOT file now exists, so we must update the file texture
			// node to point to that file

			// choose which path to use (absolute or relative), based on the value of
			// the 'absolute' parameter
			string $newFilename;
			if( $absolute ) {
				$newFilename = $resultFile;
			} else {
				$newFilename = $botName;
			} 

			// set the file node's file texture name attribute
			string $attrCmd = "setAttr -type \"string\" " + $node + ".fileTextureName \"" + $newFilename + "\"";
			if( $verb ) {
				evalEcho $attrCmd;
			} else {
				eval $attrCmd;
			}

			// turn on caching for the file texture (not strictly necessary, but we'll do it anyhow)
			string $cacheCmd = "setAttr " + $node + ".useCache 1";
			if( $verb ) {
				evalEcho $cacheCmd;
			} else {
				eval $cacheCmd;
			}
		}
	}

	// summary for verbose mode
	if( $verb ) {
		print((uiRes("m_botifyAll.kBOTallSumary")) );
		int $sz = size($texNodes);
        string $fmt = (uiRes("m_botifyAll.kNumTexture"));
		print(`format -stringArg $sz $fmt` );
		print((uiRes("m_botifyAll.kBOTallEnd")) );
	}
}

