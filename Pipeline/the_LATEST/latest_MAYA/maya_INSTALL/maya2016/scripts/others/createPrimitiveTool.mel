// Copyright (C) 1997-2014 Autodesk, Inc., and/or its licensors.
// All rights reserved.
//
// The coded instructions, statements, computer programs, and/or related
// material (collectively the "Data") in these files contain unpublished
// information proprietary to Autodesk, Inc. ("Autodesk") and/or its licensors,
// which is protected by U.S. and Canadian federal copyright law and by
// international treaties.
//
// The Data is provided for use exclusively by You. You have the right to use,
// modify, and incorporate this Data into other products for purposes authorized 
// by the Autodesk software license agreement, without fee.
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND. AUTODESK
// DOES NOT MAKE AND HEREBY DISCLAIMS ANY EXPRESS OR IMPLIED WARRANTIES
// INCLUDING, BUT NOT LIMITED TO, THE WARRANTIES OF NON-INFRINGEMENT,
// MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE, OR ARISING FROM A COURSE 
// OF DEALING, USAGE, OR TRADE PRACTICE. IN NO EVENT WILL AUTODESK AND/OR ITS
// LICENSORS BE LIABLE FOR ANY LOST REVENUES, DATA, OR PROFITS, OR SPECIAL,
// DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES, EVEN IF AUTODESK AND/OR ITS
// LICENSORS HAS BEEN ADVISED OF THE POSSIBILITY OR PROBABILITY OF SUCH DAMAGES.

proc vector cameraDirection(string $camera)
{
	vector $v = <<0, 0, -1>>; //Default camera direction
	// Get camera rotation
	float $rot[] = `camera -q -rotation $camera`;
	// Convert to radians if necessary
	string $unit = `currentUnit -query -angle`;
	if($unit == "deg" || $unit == "degree") {
		$rot[0] = `deg_to_rad $rot[0]`;
		$rot[1] = `deg_to_rad $rot[1]`;
		$rot[2] = `deg_to_rad $rot[2]`;
	}
	
	float $delta = 1e-5;
	// Rotate view vector accordingly
	if(abs($rot[0]) > $delta) {
		$v = `rot $v <<1, 0, 0>> $rot[0]`;
	}
	if(abs($rot[1]) > $delta) {
		$v = `rot $v <<0, 1, 0>> $rot[1]`;
	}
	if(abs($rot[2]) > $delta) {
		$v = `rot $v <<0, 0, 1>> $rot[2]`;
	}

	return $v; 
}

global proc vector placeOnGround(vector $position, string $upAxis, float $boundingBox[], int $centerIt)
{
	vector $result = $position;
	
	if(!$centerIt) {
		$result = <<$result.x + ($boundingBox[3] - $boundingBox[0]) / 2,
					$result.y + ($boundingBox[4] - $boundingBox[1]) / 2,
					$result.z + ($boundingBox[5] - $boundingBox[2]) / 2>>;
	} else {
		switch($upAxis) {
			case "x": $result = <<$result.x + ($boundingBox[3] - $boundingBox[0]) / 2, $result.y, $result.z>>; break;
			case "y": $result = <<$result.x, $result.y + ($boundingBox[4] - $boundingBox[1]) / 2, $result.z>>; break;
			case "z": $result = <<$result.x, $result.y, $result.z + ($boundingBox[5] - $boundingBox[2]) / 2>>; break;
		}
	}
	
	return $result;
}

global proc createPrimitiveContextPress()
{
	global float $boundingBox[];
	global int $dragHappened;
	global string $selection[];
	global string $upAxis;
	
	if(`draggerContext -query -currentStep createPrimitiveContext` == 1) {
		int $button = `draggerContext -query -button createPrimitiveContext`;
		if($button == 2) {
			draggerContext -edit -stepsCount 2 createPrimitiveContext;
		} else {
			draggerContext -edit -stepsCount 1 createPrimitiveContext;
		}

		$boundingBox = `exactWorldBoundingBox`;

		$selection = `ls -selection`;
		hide $selection;
		$dragHappened = false;
	}
		
	$upAxis = `upAxis -query -query -axis`; // Default up axis - get it from user setting
	string $panel = `getPanel -underPointer`;
	if(`modelPanel -exists $panel`) {
		string $camera = `modelPanel -query -camera $panel`;
		if(`camera -query -orthographic $camera`) {
			vector $cameraVector = cameraDirection($camera);
			float $delta = 1e-5;
			if(abs($cameraVector.x) > $delta) {
				$upAxis = "x";
			} else if(abs($cameraVector.y) > $delta) {
				$upAxis = "y";
			} else {
				$upAxis = "z";
			}
		}
	}
	
	switch($upAxis) {
		case "x": draggerContext -edit -plane 1 0 0 createPrimitiveContext; break;
		case "y": draggerContext -edit -plane 0 1 0 createPrimitiveContext; break;
		case "z": draggerContext -edit -plane 0 0 1 createPrimitiveContext; break;
	}
}

global proc createPrimitiveContextDrag()
{
	global int $dragHappened;
	global float $boundingBox[];
	global float $sxStage1, $syStage1, $szStage1;
	global string $selection[];
	global string $upAxis;
	global string $heightAxis;

	float  $pressPosition[] = `draggerContext -query -anchorPoint createPrimitiveContext`;
	float  $dragPosition[] = `draggerContext -query -dragPoint createPrimitiveContext`;

	int $mods = `getModifiers`;

	if($dragHappened == false) {
		float $noise = 3.0; // Number of pixels to be considered as noise vs real drag
		string $currentSpace = `draggerContext -query -space createPrimitiveContext`;
		draggerContext -edit -space "screen" createPrimitiveContext;
		float $screenPress[] = `draggerContext -query -anchorPoint createPrimitiveContext`;
		float $screenDrag[] = `draggerContext -query -dragPoint createPrimitiveContext`;
		draggerContext -edit -space $currentSpace createPrimitiveContext;
		if(abs($screenDrag[0] - $screenPress[0]) < $noise 
			&& (abs($screenDrag[1] - $screenPress[1])) < $noise
			&& (abs($screenDrag[2] - $screenPress[2])) < $noise)
		{
			return;
		} else {
			showHidden $selection;
			$dragHappened = true;
			select $selection;
			vector $pos = placeOnGround(<<$pressPosition[0], $pressPosition[1], $pressPosition[2]>>, $upAxis, $boundingBox, ($mods / 4) % 2);
			move ($pos.x) ($pos.y) ($pos.z) $selection;
		}
	} 

	float $sx, $sy, $sz;

	// Shift modifier means equal scale in all directions
	if(($mods / 1) % 2) {
		$sx = $sy = $sz = ( abs($dragPosition[0] - $pressPosition[0]) 
		                  + abs($dragPosition[1] - $pressPosition[1])
						  + abs($dragPosition[2] - $pressPosition[2])) / 3;
		// Take care of sign
		$sx *= sign($dragPosition[0] - $pressPosition[0]);
		$sy *= sign($dragPosition[1] - $pressPosition[1]);
		$sz *= sign($dragPosition[2] - $pressPosition[2]);
	} else {
		// Scale object in ground plane based on drag position, then calculate height as an average of previous two.
		$sx = $dragPosition[0] - $pressPosition[0];
		$sy = $dragPosition[1] - $pressPosition[1];
		$sz = $dragPosition[2] - $pressPosition[2];
	}
	
	if($boundingBox[3] - $boundingBox[0] != 0) {
		$sx /= ($boundingBox[3] - $boundingBox[0]);
	} else {
		$sx = 1;
	}
	if($boundingBox[4] - $boundingBox[1] != 0) {
		$sy /= ($boundingBox[4] - $boundingBox[1]);
	} else {
		$sy = 1;
	}
	if($boundingBox[5] - $boundingBox[2] != 0) {
		$sz /= ($boundingBox[5] - $boundingBox[2]);
	} else {
		$sz = 1;
	}
	
	// If scaling around center - double the scale value
	if(($mods / 4) % 2) {
		$sx *= 2; $sy *= 2; $sz *= 2;
	}
	
	if(`draggerContext -query -stepsCount createPrimitiveContext` == 1) {
		// Calculate height
		switch($upAxis) {
			case "x": $sx = (abs($sy) + abs($sz)) / 2; break;
			case "y": $sy = (abs($sx) + abs($sz)) / 2; break;
			case "z": $sz = (abs($sx) + abs($sy)) / 2; break;
		}
		$heightAxis = $upAxis;
	} else {
			if(`draggerContext -q -currentStep createPrimitiveContext` == 2) {
			switch($heightAxis) {
				case "x":
					if($upAxis == "x") {
						$sx = (abs($dragPosition[1]-$pressPosition[1])+abs($dragPosition[2]-$pressPosition[2])) / 2;
					} else {
						$sx = $dragPosition[0] - $pressPosition[0];
					}
				break;
				case "y":
					if($upAxis == "y") {
						$sy = (abs($dragPosition[0]-$pressPosition[0])+abs($dragPosition[2]-$pressPosition[2])) / 2;
					} else {
						$sy = $dragPosition[1] - $pressPosition[1];
					}
				break;
				case "z":
					if($upAxis == "z") {
						$sz = (abs($dragPosition[0]-$pressPosition[0])+abs($dragPosition[1]-$pressPosition[1])) / 2;
					} else {
						$sy = $dragPosition[2] - $pressPosition[2];
					}
				break;
			}
		} else {
			// First step of two-step context - defining primitive's footprint
			switch($upAxis) {
				case "x": $sx = 0; break;
				case "y": $sy = 0; break;
				case "z": $sz = 0; break;
			}
			$heightAxis = $upAxis;
		}
	}

	float $pivot[] = $pressPosition;
	switch($heightAxis) {
		case "x": $pivot[0] = 0; break;
		case "y": $pivot[1] = 0; break;
		case "z": $pivot[2] = 0; break;
	}

	if((`draggerContext -q -currentStep createPrimitiveContext` == 1)) {
		$sxStage1 = $sx;
		$syStage1 = $sy;
		$szStage1 = $sz;
	} else {
		switch($heightAxis) {
			case "x": $sy = $syStage1; $sz = $szStage1; break;
			case "y": $sx = $sxStage1; $sz = $szStage1; break;
			case "z": $sx = $sxStage1; $sy = $syStage1; break;
		}
	}

	scale -pivot $pivot[0] $pivot[1] $pivot[2] -absolute $sx $sy $sz $selection;
	// Refresh view
	refresh;
}

global proc createPrimitiveContextRelease()
{
	global int $dragHappened;
	global float $boundingBox[];
	global string $selection[];
	global string $upAxis;

	if(`draggerContext -q -currentStep createPrimitiveContext` == 1) {
		if($dragHappened == false) {
			$sxStage1 = $syScale = $szStage1 = 1;
			//Just move created primitive, so it's centered on a click point
			float $pressPosition[] = `draggerContext -query -anchorPoint createPrimitiveContext`;
			vector $pos = placeOnGround(<<$pressPosition[0], $pressPosition[1], $pressPosition[2]>>, $upAxis, $boundingBox, true);
			move ($pos.x) ($pos.y) ($pos.z) $selection;
			showHidden $selection;
			select $selection;
		}
	}

	if((`draggerContext -query -stepsCount createPrimitiveContext` == 1) 
	  || (`draggerContext -q -currentStep createPrimitiveContext` == 2)) {
		xform -preserve on -zeroTransformPivots;
	
		// Exit tool and go into the Select tool	
		global string $gSelect;
		setToolTo $gSelect;
	}
}

global proc createPrimitiveTool(string $op)
{
	// Create context
	if(!`draggerContext -query -exists createPrimitiveContext`) {
		draggerContext createPrimitiveContext;
	}

	// Setup context
	draggerContext -edit
		-prePressCommand	$op
		-pressCommand		"createPrimitiveContextPress"
		-dragCommand		"createPrimitiveContextDrag"
		-releaseCommand		"createPrimitiveContextRelease"
		-space				"world"
		-projection			"plane"
		-undoMode			"sequence"
		-snapping			on
		createPrimitiveContext;

}