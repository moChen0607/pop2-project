// Copyright (C) 1997-2014 Autodesk, Inc., and/or its licensors.
// All rights reserved.
//
// The coded instructions, statements, computer programs, and/or related
// material (collectively the "Data") in these files contain unpublished
// information proprietary to Autodesk, Inc. ("Autodesk") and/or its licensors,
// which is protected by U.S. and Canadian federal copyright law and by
// international treaties.
//
// The Data is provided for use exclusively by You. You have the right to use,
// modify, and incorporate this Data into other products for purposes authorized 
// by the Autodesk software license agreement, without fee.
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND. AUTODESK
// DOES NOT MAKE AND HEREBY DISCLAIMS ANY EXPRESS OR IMPLIED WARRANTIES
// INCLUDING, BUT NOT LIMITED TO, THE WARRANTIES OF NON-INFRINGEMENT,
// MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE, OR ARISING FROM A COURSE 
// OF DEALING, USAGE, OR TRADE PRACTICE. IN NO EVENT WILL AUTODESK AND/OR ITS
// LICENSORS BE LIABLE FOR ANY LOST REVENUES, DATA, OR PROFITS, OR SPECIAL,
// DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES, EVEN IF AUTODESK AND/OR ITS
// LICENSORS HAS BEEN ADVISED OF THE POSSIBILITY OR PROBABILITY OF SUCH DAMAGES.

//
//
//  Creation Date:  November 2000
//
//
//  Procedure Name:
//     	artisanNamedCommandSetup
//
//  Description:
//      Name commands for all artisan/jasper tools.
//
//  Input Arguments:
//
//  Return Value:
//      None.
//


// ========================================================================
// Help procedures and functions.
// ========================================================================

global proc int isSmudgeCtx()
{
	string $tc = currentToolClass();
	return ($tc == "textureSmudgeUV");
}

proc int isDynWireContext()
//
//	Description:
//		Returns true if this is Paint Effects context.
//
{
	string $tc = currentToolClass();
	return ($tc == "paintEffects");
}

proc int isGreasePencilContext()
//
//	Description:
//		Returns true if this is Grease Pencil context.
//
{
	string $tc = currentToolClass();
	return ($tc == "greasePencil");
}

proc int pfxPanelIsActive()
//
//	Description:
//		Determine if the mouse is over the paint effects panel
//		so we can decide which brush resize method to use.
//
{
	string $panelName = `getPanel -wf`;

	// For now we can test the panel name, as we only
	// have one paint effects panel. We could test
	// for a scriptedPanel(below), but if someone develops an
	// artisan scripted panel then this would not be sufficient.
	// string $panelType = `getPanel -to $panelName`;
	// if( $panelType == "scriptedPanel" )

	if( $panelName == "dynPaintScriptedPanel" ){
		return( 1 );
	} else {
		return( 0 );
	}
}

global proc string[] getActiveSoftMod()
//
//	Description:
//		Returns the active softMod(s)
//
{
	string $softMods[];
	string $tc = currentToolClass();
	if( $tc == "softMod" || $tc == "showManip" )
	{
		string $selected[] = `ls -sl`;
		$softMods = `listConnections -s off -d on -type "softMod" $selected`;
	}
	return $softMods;
}

global proc int isArtisanCtx()
//
//	Description:
//		Returns true if this is one of the new artisan tools.
//
{
	// All Artisan tools use the new Artisan architecture.
	// The old architecture has been removed. So, as long as
	// we are not in resize hotkey context (like softmod),
	// or UVsmudge, or paint Effects......
	// any other tool should be a new artisan tool.
	//
	int $notArtisan = (isSmudgeCtx() ||
		 size( getActiveSoftMod()) > 0 ||
		 isDynWireContext() ||
		 pfxPanelIsActive() );

	if ($notArtisan)
		return false;

	string  $currentContext = currentToolClass();
	return startsWith($currentContext, "art");
}

global proc string artisanCommand()
//
//	Description:
//		Returns current artisan conttext command.
//
{
	string	$currentTool = currentToolClass();
	string	$artisanCmd = "";

	if ( $currentTool == "art3dPaint" ) {
		$artisanCmd = "art3dPaintCtx";
	}
	else if ( $currentTool == "artSelect" ) {
		$artisanCmd = "artSelectCtx";
	}
	else if ( $currentTool == "artAttr" ) {
		$artisanCmd = "artAttrCtx";
	}
	else if ( $currentTool == "artClothPaint" ) {
		$artisanCmd = "artAttrCtx";
	}
	else if ( $currentTool == "artClothCollPaint" ) {
 		$artisanCmd = "artAttrCtx";
 	}
	else if ( $currentTool == "artAttrSkin" ) {
		$artisanCmd = "artAttrSkinPaintCtx";
	}
	else if ( $currentTool == "artFluidAttr" ) {
		$artisanCmd = "artFluidAttrCtx";
	}
	else if ( $currentTool == "artAttrColorPerVertex" ) {
		$artisanCmd = "artAttrPaintVertexCtx";
	}
	else if ( $currentTool == "artUserPaint" ) {
		$artisanCmd = "artUserPaintCtx";
	}
 	else if ( $currentTool == "artSetPaint" ) {
 		$artisanCmd = "artSetPaintCtx";
 	}
	else if ( $currentTool == "artPutty" ) {
 		$artisanCmd = "artPuttyCtx";
 	}
	else {
		// All DYNAMICALLY added tools use the artAttrCtx command.
		//
 		$artisanCmd = "artAttrCtx";
	}

	return $artisanCmd;
}

global proc int isArtColorFeedbackCtx()
//
//	Description:
//		Returns true if the current tool is an attibute paint context.
//
{
	string $tc = currentToolClass();
	int	   $isColorFeedback = false;

	if ( ($tc == "artAttr")
			|| ($tc == "artAttrSkin")
			|| ($tc == "artUserPaint")
			|| ($tc == "artAttrBlendShape")
			|| ($tc == "artClothPaint")
			|| ($tc == "artClothCollPaint") ) {
		$isColorFeedback = true;
	} else if ( ($tc == "art3dPaint")
			|| ($tc == "artSelect")
			|| ($tc == "artSetPaint")
			|| ($tc == "artPutty")
			|| ($tc == "artAttrColorPerVertex")
			|| ($tc == "artFluidAttr") 
            ) {
		$isColorFeedback = false;
	} else {
		// Check the colorFeedback flag for DYNAMICALLY added attributes.
		//
        string  $currentContext = `currentCtx`;
		$isColorFeedback = `artAttrCtx -q -colorfeedback $currentContext`;
	}

	return( $isColorFeedback );
}

global proc int isArtColorPerVertexCtx()
//
//	Description:
//		Returns true if the current tool is a color per vertex paint context.
//
{
	string $tc = currentToolClass();
	int $isColorPerVertex = false;

	if( $tc == "artAttrColorPerVertex" )
	{
		$isColorPerVertex = true;
	}
	return $isColorPerVertex;
}

// -------------------------------------------------------
global proc int isArtSkinCtx()
//
//	Description:
//		Returns true if this is the paint skin weights tool
//
{
	string $tc = currentToolClass();
	return ($tc == "artAttrSkin");
}

// -------------------------------------------------------

proc int isAdynPaintPanel()
//
//	Description:
//		Returns true if this is Paint Effects context.
//
{
    string $currentPanel = `getPanel -withFocus`;
    return (`scriptedPanel -ex $currentPanel` &&
    `scriptedPanel -q -type $currentPanel` == "dynPaintScriptedPanelType");
}

global proc int isDynPaint()
{
	return (isDynWireContext() || isAdynPaintPanel());
}

proc dynPaintResize(string $sliderName)
//
//	Description:
//
{
	if (isDynWireContext()) {
		dynWireCtx -e -dbs $sliderName `currentCtx`;
	}
	if (isAdynPaintPanel()) {
		global string $gDynPaintEditorName;
		dynPaintCtx -e -dbs $sliderName `dynPaintEditor -q -drc $gDynPaintEditorName`;
	}
}

global proc artisanToggleInverseReferenceVector(
	 string  $artCmd
)
//
//	Description:
//		Toggle Inverse Reference Vector.
//
{
	if ( isArtisanCtx() ) {
		if ( $artCmd != "" ) {
			string $cmd0 = $artCmd + " -q -invertrefvector `currentCtx`";
			string $cmd1;
			if ( eval($cmd0) ) {
				$cmd1 = $artCmd + " -e -invertrefvector false "  + `currentCtx`;
			} else {
				$cmd1 = $artCmd + " -e -invertrefvector true "  + `currentCtx`;
			}
			eval( $cmd1 );
		}
	}
}

global proc artisanReflectionMenu(
)
//
//	Description:
//		Create the Reflection, Reflection Axis menu for 'u/ hotkey.
//
{
	// Get the proper artisan command for the tool.
	string $artCmd = artisanCommand();

	//Screen Projection
	string $cmd  = $artCmd + " -q -projective `currentCtx`";
	menuItem -label (uiRes("m_artisanNamedCommandSetup.kScreenProjection")) -checkBox `eval($cmd)`
		-command ("artisanToggleScreenProjection ");

	//Reflection
	string $currCtx = `currentCtx`;
	int $toolSupportsReflection = ($currCtx != "artAttrSkinContext");
	$cmd  = $artCmd + " -q -reflection `currentCtx`";
	menuItem -label (uiRes("m_artisanNamedCommandSetup.kReflection")) -checkBox `eval($cmd)`
		-enable $toolSupportsReflection
		-command ("artisanToggleReflection ");

	//Reflection Axis
	menuItem -sm true -en `eval($cmd)`-label (uiRes("m_artisanNamedCommandSetup.kReflectionAxis"));
		radioMenuItemCollection;
		$cmd = ($artCmd + " -q -reflectionaxis `currentCtx`");
		menuItem -label (uiRes("m_artisanNamedCommandSetup.kX"))
				 -radioButton ("x" == `eval $cmd`)
			     -command ($artCmd + " -e -reflectionaxis \"x\" `currentCtx`");
		menuItem -label (uiRes("m_artisanNamedCommandSetup.kY"))
				 -radioButton  ("y" == `eval $cmd`)
			     -command ($artCmd + " -e -reflectionaxis \"y\" `currentCtx`");
		$cmd1 = ($artCmd + " -q -projective " + `currentCtx` );
		menuItem -label (uiRes("m_artisanNamedCommandSetup.kZ"))
				 -enable (!`eval($cmd1)`) -radioButton ("z" == `eval $cmd`)
				 -command ($artCmd + " -e -reflectionaxis \"z\" `currentCtx`");
	setParent -m ..;
}

global	proc artisanToggleReflection(
)
//
// Description:
//	   Toggle Reflection.
//
{
	string $currCtx = `currentCtx`;
	if ($currCtx == "artAttrSkinContext") {
		warning( (uiRes("m_artisanNamedCommandSetup.kReflectionSmoothSkinningWarning")) );
		return;
	}

	// Get the proper artisan command for the tool.
	string	$artCmd	= artisanCommand();

	if (	isArtisanCtx() ) {
		if (	$artCmd	!=	"" ) {
			string	$cmd0 =	$artCmd	+ " -q -reflection	`currentCtx`";
			if (	`eval($cmd0)` ) {
				$cmd1 =	$artCmd	+ " -e -reflection	false "  + `currentCtx`;
				eval( $cmd1 );
			} else	{
				$cmd1 =	$artCmd	+ " -e -reflection	true "	 +	`currentCtx`;
				eval( $cmd1 );
			}

		}
	} else {
		string  $currentContext = `currentCtx`;
		string $ctx =  `contextInfo -c $currentContext`;
		if ($ctx == "manipMove") {
			string	$cmd0 =	"manipMoveContext  -q -reflection Move";
			if (`eval($cmd0)` ) {
				eval("manipMoveContext -e -reflection false Move");
			} else {
				eval("manipMoveContext -e -reflection true Move");
			}
		}
	}
}

global	proc artisanToggleScreenProjection(
)
//
// Description:
//	   Toggle Screen Projection.
//
{
	// Get the proper artisan command for the tool.
	string	$artCmd	= artisanCommand();

	if (	isArtisanCtx() ) {
		if (	$artCmd	!=	"" ) {
			string	$cmd0 =	$artCmd	+ " -q -projective `currentCtx`";
			if (	`eval($cmd0)` ) {
				$cmd1 =	$artCmd	+ " -e -projective	false	"  + `currentCtx`;
				eval( $cmd1 );
			} else	{
				$cmd1 =	$artCmd	+ " -e -projective	true "  + `currentCtx`;
				eval( $cmd1 );
			}

		}
	}
}

global proc artisanInvertReferenceVectorMenu(
	string 	$artCmd
)
//
//	Description:
//		Create the Invert Reference Vector menu for 'u/ hotkey.
//
{
	string $cmd  = $artCmd + " -q -invertrefvector `currentCtx`";
	string $cmd0= $artCmd + " -q -reflection `currentCtx`";
	string $cmd1= $artCmd + " -q -projective `currentCtx`";
	menuItem
		-label (uiRes("m_artisanNamedCommandSetup.kInverseRefVector"))
		-checkBox `eval($cmd)`
		-enable (`eval($cmd0)`&& (!`eval($cmd1)`))
		-command ("artisanToggleInverseReferenceVector " + $artCmd ) artInvertRefVect;
}

proc artisanToolOperationMenu()
//
//	Description:
//		Create a context sensitive popmenu with all paint
//		oparations for all artisan tools.
//
{
	string $tc = currentToolClass();

	// Get the proper artisan command for the tool.
	//string $artCmd = artisanCommand();

	popupMenu -mm 1 -b 1 -p `findPanelPopupParent` artOperationPopupMenu;

	if ( $tc == "art3dPaint"  ) {
		art3dPaintOptionsPopup();
	}
	else if ( $tc == "artSelect" ) {
		artSelectOptionsPopup();
	}
	else if (( $tc == "artAttr" )
	|| 		 ( $tc == "artUserPaint" )
	|| 		 ( $tc == "artFluidAttr" )
	|| 		 ( $tc == "artClothPaint" )
	|| 		 ( $tc == "artClothCollPaint" )
	|| 		 ( $tc == "artAttrSkin" )
	||       ( $tc == "artAttrBlendShape" ))
	{
		artBaseOptionsPopup();
	}
 	else if ( $tc == "artSetPaint" ) {
		artSetPaintOptionsPopup();
 	}
	else if ( $tc == "artPutty" ) {
		artPuttyOptionsPopup();
	}
    else
		return;

	setParent ..;
}

// ========================================================================
// End of help procedures.
// ========================================================================

global proc artActivateScreenSlider(
	string $sliderName
)
//
//	Description:
//		Global procs for activating screen sliders
//		- sets the flag to activate them.
//
{

	// New Artisan Tools.
	if ( isArtisanCtx() ) {
		string $artisanCmd = artisanCommand();
		if( $sliderName == "upper_radius" ) {
			artBaseCtx -e -dragSlider "radius" `currentCtx`;
		} else if( $sliderName == "lower_radius" ) {
			artBaseCtx -e -dragSlider "lowradius" `currentCtx`;
		} else if( $sliderName == "opacity" ) {
			artBaseCtx -e -dragSlider "opacity" `currentCtx`;
		} else if( $sliderName == "value" ) {
			artBaseCtx -e -dragSlider "value" `currentCtx`;
		} else if( $sliderName == "stamp_depth" ) {
			artBaseCtx -e -dragSlider "depth" `currentCtx`;
		} else if( $sliderName == "displacement" ) {
			artBaseCtx -e -dragSlider "displacement" `currentCtx`;
		} else if( $sliderName == "uv_vector" ) {
			artBaseCtx -e -dragSlider "uvvector" `currentCtx`;
		}
	}
	else if ( isGreasePencilContext() )
	{
		if( $sliderName == "upper_radius" )
		{
			// Map B to radius
			artBaseCtx -e -dragSlider "radius" greasePencilContext;
		}
		else if( $sliderName == "displacement" )
		{
			// Map m to opacity rather than value but not for the eraser
			// as this has no effect
			if ( 4 != `greasePencilCtx -query -greasePencilType greasePencilContext` )
			{
				artBaseCtx -e -dragSlider "opacity" greasePencilContext;
			}
		}
	}
	// UV Smudge Tool
	else if ( isSmudgeCtx() ) {
		texSmudgeUVContext -edit -dragSlider "radius" texSmudgeUVCtx;
	}
	// Soft Mod
	else if ( size( getActiveSoftMod() ) > 0 )
	{
		string $ctx = `currentCtx`;
		if( `contextInfo -c $ctx` != "softMod" )
			$ctx = "softModContext";
		softModCtx -e -dragSlider "radius" $ctx;
	}
	// Paint Effects.
	else if ((`isTrue "MayaCreatorExists"`) && isDynPaint())
	{
		if( $sliderName == "displacement" ) {
			dynPaintResize("offset");
		} else if( $sliderName == "lower_radius" ) {
			dynPaintResize("width");
		} else {
			dynPaintResize("size");
		}
	}
	else if ($sliderName == "upper_radius")
	{
		// upper_radius is the "b" key by default.  We only want to use that one
		// for soft select.  The "n" and "m" keys can also come in here so we want
		// to filter those out.
		global string $gSoftSelectOptionsCtx;
		softSelectOptionsCtx -edit -buttonDown $gSoftSelectOptionsCtx;
	}
}

global proc artDeactivateScreenSlider()
//
//	Description:
//		Global procs for deactivating screen sliders - sets the flag to
//		deactivate them.
//
{
	// New Artisan Tools.
	if ( isArtisanCtx() ) {
		artBaseCtx -e -dragSlider "none" `currentCtx`;
	}
	else if ( isGreasePencilContext() )
	{
		artBaseCtx -e -dragSlider "none" greasePencilContext;
	}
	// UV Smudge
	else if ( isSmudgeCtx() ) {
		texSmudgeUVContext -e -dragSlider "none" texSmudgeUVCtx;
	}
	// Soft Mod
	else if ( size( getActiveSoftMod() ) > 0 )
	{
		string $ctx = `currentCtx`;
		if( `contextInfo -c $ctx` != "softMod" )
			$ctx = "softModContext";
		softModCtx -e -dragSlider "none" $ctx;
	}
	// Paint Effects.
    else if (`isTrue "MayaCreatorExists"` && isDynPaint())
	{
		dynPaintResize("none");
	}
	else
	{
		// We filter out the "n" and "m" keys in the activate call
		// but don't here because there isn't a slider name passed
		// in for deactivate.  To soft select context is smart
		// enough to know that it didn't start and edit so we are
		// ok to just call this in case we did.
		global string $gSoftSelectOptionsCtx;
		softSelectOptionsCtx -edit -buttonUp $gSoftSelectOptionsCtx;
	}
}


global proc artPaintOperationMenu()
//
//	Description:
//		Display a popup menu with all artisan paint operations.
//
//	NOTE: This is tool sensitive.
//
{
	artDeletePopMenu();

	// New Artisan Tools.
	if ( isArtisanCtx() ) {
		artisanToolOperationMenu();
	}
}


global proc artDeletePopMenu()
//
//	Description:
//
//
{
	if ( isArtisanCtx() ) {
		if (`popupMenu -exists artOperationPopupMenu`) {
			deleteUI artOperationPopupMenu;
		}

	}
}


global proc artFloodSurfaces()
//
//	Description:
//		Command to flood the surfaces with current values.
//
{
	if ( isArtisanCtx() ) {
		string $artisanCmd = artisanCommand();
		if ( $artisanCmd != "" ) {
			eval( $artisanCmd + " -e -clear `currentCtx`" );
		}
	}
}


global proc artToggleWireframeDisplay()
//
//	Description:
// 		Toggle display of the wireframe - change the value into
//	the opposite one.
//
{
	if ( isArtisanCtx() ) {
		string $artisanCmd = artisanCommand();
		if ( $artisanCmd != "" ) {
			string $cmd0 = $artisanCmd + " -q -showactive `currentCtx`";
			string $cmd1;
			if ( eval($cmd0) ) {
				$cmd1 = $artisanCmd + " -e -showactive false "  + `currentCtx`;
			} else {
				$cmd1 = $artisanCmd + " -e -showactive true "  + `currentCtx`;
			}
			eval( $cmd1 );

			// Update the UI in all artisan tools.
			if ( `checkBoxGrp -exists artShowActiveLinesChkBox`) {
				checkBoxGrp -e -v1 `eval($cmd0)` artShowActiveLinesChkBox;
			}

			// Update the UI in 3d Paint tool.
			if ( `checkBoxGrp -exists art3dShowActiveLinesChkBox`) {
				checkBoxGrp -e -v1 `eval($cmd0)` art3dShowActiveLinesChkBox;
			}
		}
	}
}


global proc artToggleColorFeedback()
//
//	Description:
// 		Toggle the color feedback display - change the value into the opposite.
//
{
	if ( isArtColorFeedbackCtx() ) {
		string $artisanCmd = artisanCommand();
		if ( $artisanCmd != "" ) {
			string  $cmd0 = $artisanCmd + " -q -colorfeedback `currentCtx`";
			string  $cmd1;
			if ( `eval($cmd0)` ) {
				$cmd1 = $artisanCmd + " -e -colorfeedback false " + `currentCtx`;
			} else {
				$cmd1 = $artisanCmd + " -e -colorfeedback true " + `currentCtx`;
			}
			eval($cmd1);

			// Update the UI in artisan tools.
			if ( `checkBoxGrp -exists artColorFeedbackChkBox`) {
				checkBoxGrp -e -v1 `eval($cmd0)` artColorFeedbackChkBox;
			}
		}
	}
}


global proc artToggleMultiColorFeedback()
//
//	Description:
// 		Toggle the color feedback display override - change the value into the opposite.
//      This is so nodes provide their own color feedback, instead of artisan doing it for them.
//      Right now the only thing doing this is paint skin weights.
//
{
	if ( isArtSkinCtx() ) {
		string $artisanCmd = artisanCommand();
		if ( $artisanCmd != "" ) {
			string  $cmd0 = $artisanCmd + " -q -colorfeedbackOverride `currentCtx`";
			string  $cmd1;
			if ( `eval($cmd0)` ) {
				$cmd1 = $artisanCmd + " -e -colorfeedbackOverride false " + `currentCtx`;
			} else {
				$cmd1 = $artisanCmd + " -e -colorfeedbackOverride true " + `currentCtx`;
			}
			eval($cmd1);

			// Update the UI in artisan tools.
			if ( `checkBoxGrp -exists artMultiColorFeedbackChkBox`) {
				checkBoxGrp -e -v1 `eval($cmd0)` artMultiColorFeedbackChkBox;
			}
		}
	}
}


global proc artActivatePickColorMode()
//
//	Description:
//		Activate pick color mode.
//
{
	if ( isArtisanCtx() ) {
		$cmd = artisanCommand() + " -e -pickColor true " + `currentCtx`;
		eval($cmd);
	}
}


global proc artDeactivatePickColorMode()
//
//	Description:
//		Deactivate pick color mode.
//
{
	if ( isArtisanCtx() ) {
		$cmd = artisanCommand() + " -e -pickColor false " + `currentCtx`;
		eval($cmd);
	}
}

// ========================================================================
// MAIN procedure - artisanNamedCommandSetup()
// ========================================================================

global proc artisanNamedCommandSetup( )
{
	assignCommand -e -addDivider "Maya Artisan Tools";

	// Global named commands for Artisan tools.
	nameCommand -annotation (uiRes("m_artisanNamedCommandSetup.kArtisanOpMMPressAnnot"))
		-command ("PaintOperationMarkingMenuPress")
	artisanPaintOperation_Tool;

	nameCommand -annotation (uiRes("m_artisanNamedCommandSetup.kArtisanOpMMReleaseAnnot"))
		-command ("PaintOperationMarkingMenuRelease")
	artisanPaintOperation_Tool_revert;

	nameCommand -annotation (uiRes("m_artisanNamedCommandSetup.kFloodWithCurrentValueAnnot"))
		-command ("FloodSurfaces")
	artisanToggleFlood_press;

	nameCommand -annotation (uiRes("m_artisanNamedCommandSetup.kToggleReflectionAnnot"))
		-command ("ToggleReflection")
	artisanToggleReflection_press;

	nameCommand -annotation (uiRes("m_artisanNamedCommandSetup.kToggleWireframeAnnot"))
		-command ("ToggleWireframeInArtisan")
	artisanToggleWireframe_press;

	nameCommand -annotation (uiRes("m_artisanNamedCommandSetup.kActivatePickColorAnnot"))
		-command ("PickColorActivate")
	artisanPickColorMode_press;

	nameCommand -annotation (uiRes("m_artisanNamedCommandSetup.kDeactivePickColorAnnot"))
		-command ("PickColorDeactivate")
	artisanPickColorMode_release;


	// Global named commands for activating/deactivating screen sliders.
	nameCommand
		-ann (uiRes("m_artisanNamedCommandSetup.kActivateLowerBrushRadiusAnnot"))
		-command ("ModifyLowerRadiusPress")
	artisanModifyLowerRadius_press;

	nameCommand
		-ann (uiRes("m_artisanNamedCommandSetup.kDeactivateLowerBrushRadiusAnnot"))
		-command ("ModifyLowerRadiusRelease")
	artisanModifyLowerRadius_release;

	nameCommand
		-ann (uiRes("m_artisanNamedCommandSetup.kActivateUpperBrushRadiusAnnot"))
		-command ("ModifyUpperRadiusPress")
	artisanModifyUpperRadius_press;

	nameCommand
		-ann (uiRes("m_artisanNamedCommandSetup.kDeactiveUpperBrushRadiusAnnot"))
		-command ("ModifyUpperRadiusRelease")
	artisanModifyUpperRadius_release;

	nameCommand
		-ann (uiRes("m_artisanNamedCommandSetup.kActivateModifyOpacityAnnot"))
		-command ("ModifyOpacityPress")
	artisanModifyOpacity_press;

	nameCommand
		-ann (uiRes("m_artisanNamedCommandSetup.kDeactivateModifyOpacityAnnot"))
		-command ("ModifyOpacityRelease")
	artisanModifyOpacity_release;

	nameCommand
		-ann (uiRes("m_artisanNamedCommandSetup.kActivateModifyValueAnnot"))
		-command ("ModifyPaintValuePress")
	artisanModifyValue_press;

	nameCommand -annotation (uiRes("m_artisanNamedCommandSetup.kDeactivateModifyValueAnnot"))
		-command ("ModifyPaintValueRelease")
	artisanModifyValue_release;

	nameCommand
		-ann (uiRes("m_artisanNamedCommandSetup.kActivateModifyStampDepthAnnot"))
		-command ("ModifyStampDepthPress")
	artisanModifyStampDepth_press;

	nameCommand -annotation (uiRes("m_artisanNamedCommandSetup.kDeactivateModifyStampDepthAnnot"))
		-command ("ModifyStampDepthRelease")
	artisanModifyStampDepth_release;

	nameCommand
		-ann (uiRes("m_artisanNamedCommandSetup.kActivateModifyUVVectorAnnot"))
		-command ("ModifyUVVectorPress")
	artisanModifyUVVector_press;

	nameCommand -annotation (uiRes("m_artisanNamedCommandSetup.kDeactiveModifyUVVectorAnnot"))
		-command ("ModifyUVVectorRelease")
	artisanModifyUVVector_release;


	// Tool specific named commands.
    nameCommand -annotation (uiRes("m_artisanNamedCommandSetup.kToggleColorFeedbackAnnot"))
		-command ("ToggleColorFeedback")
	artisanColorFeedback_press;

	// Skin weight specific commands
	nameCommand -annotation (uiRes("m_artisanNamedCommandSetup.kToogleMultiColorFeedbackAnnot"))
		-command ("ToggleMultiColorFeedback")
	artisanMultiColorFeedback_press;

	nameCommand -annotation (uiRes("m_artisanNamedCommandSetup.kCopySkinWeightsAnnot"))
		-command ("CopyVertexSkinWeights")
	artisanCopyVertexSkinWeights;

	nameCommand -annotation (uiRes("m_artisanNamedCommandSetup.kPasteSkinWeightsAnnot"))
		-command ("PasteVertexSkinWeights")
	artisanPasteVertexSkinWeights;

	nameCommand -annotation (uiRes("m_artisanNamedCommandSetup.kSkinNextPaintModeAnnot"))
		-command ("NextSkinPaintMode")
	artisanNextSkinPaintMode;

	nameCommand -annotation (uiRes("m_artisanNamedCommandSetup.kSkinPrevPaintModeAnnot"))
		-command ("PrevSkinPaintMode")
	artisanPrevSkinPaintMode;

	// PolyBrush named commands
	nameCommand
		-annotation (uiRes("m_artisanNamedCommandSetup.kPolyBrushOpWithMarkingMenuAnnot"))
		-command ("PolyBrushMarkingMenu")
	PolyBrushMarkingMenuNameCommand;

	nameCommand
		-annotation (uiRes("m_artisanNamedCommandSetup.kPolyBrushOpWithMarkingMenuPopDownAnnot"))
		-command ("PolyBrushMarkingMenuPopDown")
	PolyBrushMarkingMenuPopDownNameCommand;

	nameCommand
		-ann (uiRes("m_artisanNamedCommandSetup.kActivateMaxDisplacementAnnot"))
		-command ("ModifyDisplacementPress")
	artisanModifyMaxDisplacement_press;

	nameCommand -annotation (uiRes("m_artisanNamedCommandSetup.kDeactivateMaxDisplacementAnnot"))
		-command ("ModifyDisplacementRelease")
	artisanModifyMaxDisplacement_release;

	// Update Erase Surface
	nameCommand -annotation (uiRes("m_artisanNamedCommandSetup.kUpdateEraseSurfaceAnnot"))
		-command ("UpdateEraseSurface")
		artisanUpdateEraseSurface;

	// Update Reference Surface
	nameCommand -annotation (uiRes("m_artisanNamedCommandSetup.kUpdateReferenceSurfaceAnnot"))
		-command ("UpdateReferenceSurface")
		artisanUpdateReferenceSurface;

	// Toggle Autosmooth
	nameCommand -annotation (uiRes("m_artisanNamedCommandSetup.kToogleAutosmoothAnnot"))
		-command ("ToggleAutoSmooth")
		artisanToggleAutosmooth;

	// Marking Menu for the reference vectors in Sculpt Paint Tool
	nameCommand -annotation (uiRes("m_artisanNamedCommandSetup.kActivateSculptRefVectorMMAnnot"))
		-command ("SculptReferenceVectorMarkingMenuPress")
	sculptReferenceVector_Tool;

	nameCommand -annotation (uiRes("m_artisanNamedCommandSetup.kDeactivateSculptRefVectorMMAnnot"))
		-command ("SculptReferenceVectorMarkingMenuRelease")
	sculptReferenceVector_Tool_revert;

	nameCommand -annotation (uiRes("m_artisanNamedCommandSetup.kActivateScreenSliderAnnot"))
		-command ("ActivateGlobalScreenSlider")
		artisanGlobalScreenSlider_press;

	nameCommand -annotation (uiRes("m_artisanNamedCommandSetup.kDeactivateScreenSliderAnnot"))
		-command ("DeactivateGlobalScreenSlider")
		artisanGlobalScreenSlider_release;

	nameCommand -annotation (uiRes("m_artisanNamedCommandSetup.kActivateScreenSliderMMAnnot"))
		-command ("ActivateGlobalScreenSliderModeMarkingMenu")
		artisanSetGlobalScreenSliderMode_press;

	nameCommand -annotation (uiRes("m_artisanNamedCommandSetup.kDeactivateScreenSliderMMAnnot"))
		-command ("DeactivateGlobalScreenSliderModeMarkingMenu")
		artisanSetGlobalScreenSliderMode_release;
}

global proc deletePopupMenu()
{
	if( `popupMenu -q -exists tempMM` ) {
		deleteUI tempMM;
	}

	if( `popupMenu -q -exists tempMM2` ) {
		deleteUI tempMM2;
	}
}

global proc artPuttyUpdateReferenceSurface( )
{
	string $tc = currentToolClass();
	if ( $tc == "artPutty"  ) {
		string $artCmd = artisanCommand();
		if (	$artCmd	!=	"" ) {
			string $cmd0 =$artCmd + " -e -updaterefsrf `currentCtx`";
			eval( $cmd0 );
		}
	}
}
global proc artPuttyUpdateEraseSurface( )
{
	string $tc = currentToolClass();
	if ( $tc == "artPutty"  ) {
		string $artCmd = artisanCommand();
		if (	$artCmd	!=	"" ) {
			string $cmd0 =$artCmd + " -e -updateerasesrf `currentCtx`";
			eval( $cmd0 );
		}
	}
}

global proc artPuttyToggleAutosmooth()
//
//	Description:
// 		Toggle the Auto Smooth option - change the value into the opposite.
//
{
	string $tc = currentToolClass();
	if ( $tc == "artPutty"  ) {
		string $artisanCmd = artisanCommand();
		if ( $artisanCmd != "" ) {
			string  $cmd0 = $artisanCmd + " -q -autosmooth  `currentCtx`";
			string  $cmd1;
			if ( `eval($cmd0)` ) {
				$cmd1 = $artisanCmd + " -e -autosmooth  false " + `currentCtx`;
			} else {
				$cmd1 = $artisanCmd + " -e -autosmooth  true " + `currentCtx`;
			}
			eval($cmd1);

			// Update the UI in artisan tools.
			if ( `checkBoxGrp -exists autoSmooth`) {
				checkBoxGrp -e -v1 `eval($cmd0)` autoSmooth;
			}
		}
	}
}

global proc artPuttyReferenceVectorMarkingMenu()
//
//	Description:
//		Display a reference vector popup marking menu for Sculpt Paint Tool.
//
{
	if( `popupMenu -q -exists artPuttyReferenceVectorPopupMenu` ) {
		deleteUI artPuttyReferenceVectorPopupMenu;
	}

	if ( isArtisanCtx() ) {
		string $tc = currentToolClass();
		if ( $tc == "artPutty"  ) {
			// Get the proper artisan command for the tool.
			string $artCmd = artisanCommand();
			if ( $artCmd !="" ) {
				popupMenu -mm 1 -b 1 -p `findPanelPopupParent` artPuttyReferenceVectorPopupMenu;
				menuItem -rp "N" -l (uiRes("m_artisanNamedCommandSetup.kNormal"))
					-c ("artPuttyCtx -e -refvector \"normal\" `currentCtx`");
					menuItem -rp "NW" -l (uiRes("m_artisanNamedCommandSetup.kFirstNormal"))
						-c ("artPuttyCtx -e -refvector \"firstnormal\" `currentCtx`");
					menuItem -rp "NE" -l (uiRes("m_artisanNamedCommandSetup.kView"))
						-c ("artPuttyCtx -e -refvector \"view\" `currentCtx`");

					menuItem -rp "W" -l (uiRes("m_artisanNamedCommandSetup.kUDirection"))
						-c ("artPuttyCtx -e -refvector \"uisoparm\" `currentCtx`");
					menuItem -rp "E" -l (uiRes("m_artisanNamedCommandSetup.kVDirection"))
						-c ("artPuttyCtx -e -refvector \"visoparm\" `currentCtx`");

					menuItem -rp "SW" -l (uiRes("m_artisanNamedCommandSetup.kXAxis"))
						-c ("artPuttyCtx -e -refvector \"xaxis\" `currentCtx`");
					menuItem -rp "S" -l (uiRes("m_artisanNamedCommandSetup.kYAxis"))
						-c ("artPuttyCtx -e -refvector \"yaxis\" `currentCtx`");
					menuItem -rp "SE" -l (uiRes("m_artisanNamedCommandSetup.kZAxis"))
						-c ("artPuttyCtx -e -refvector \"zaxis\" `currentCtx`");
				setParent ..;
			}
		}
	}
}

global proc artDeletePuttyReferenceVectorPopMenu()
//
//	Description:
//		Deletes the reference vector marking popmenu
//
{
	if ( isArtisanCtx() ) {
		if (`popupMenu -exists artPuttyReferenceVectorPopupMenu`) {
			deleteUI artPuttyReferenceVectorPopupMenu;
		}
	}
}

global string	$globalScreenSliderMode = "none";

global proc artActivateGlobalScreenSliderModeMarkingMenu()
//
//	Description:
//
{
global string	$globalScreenSliderMode ;

 if( `popupMenu -q -exists artGlobalScreenSliderModePopupMenu` ) {
		deleteUI artGlobalScreenSliderModePopupMenu;
	}

	if ( isArtisanCtx() ) {
		string $tc = currentToolClass();
		// Get the proper artisan command for the tool.
		string $artCmd = artisanCommand();
		if ( $artCmd !="" ) {
			popupMenu -mm 1 -b 1 -p `findPanelPopupParent` artGlobalScreenSliderModePopupMenu;
			menuItem -rp "N" -l (uiRes("m_artisanNamedCommandSetup.kUpperRadius"))
				-c "$globalScreenSliderMode = \"upper_radius\"";
				menuItem -rp "S" -l (uiRes("m_artisanNamedCommandSetup.kLowerRadius"))
					-c "$globalScreenSliderMode = \"lower_radius\"";
				menuItem -rp "W" -l (uiRes("m_artisanNamedCommandSetup.kOpacity"))
				-c "$globalScreenSliderMode = \"opacity\"";
				if ($tc == "artPutty") {
					menuItem -rp "E" -l (uiRes("m_artisanNamedCommandSetup.kDisplacement"))
						-c "$globalScreenSliderMode = \"displacement\"";
				} else {
					menuItem -rp "E" -l (uiRes("m_artisanNamedCommandSetup.kValue"))
						-c "$globalScreenSliderMode = \"value\"";
				}
				menuItem -rp "SW" -l (uiRes("m_artisanNamedCommandSetup.kStampDepth"))
					-c "$globalScreenSliderMode = \"stamp_depth\"";

			setParent ..;
		}
	}
}

global proc artDeactivateGlobalScreenSliderModeMarkingMenu()
//
//	Description:
//
{
	if ( isArtisanCtx() ) {
		if( `popupMenu -q -exists artGlobalScreenSliderModePopupMenu` ) {
				deleteUI artGlobalScreenSliderModePopupMenu;
			}
	}
}

global proc artActivateGlobalScreenSlider()
//
//	Description:
//
//
{
	global string	$globalScreenSliderMode;
	artActivateScreenSlider($globalScreenSliderMode);
}

global proc artDeactivateGlobalScreenSlider()
//
//	Description:
//
{
	artDeactivateScreenSlider() ;
}
