// Copyright (C) 1997-2014 Autodesk, Inc., and/or its licensors.
// All rights reserved.
//
// The coded instructions, statements, computer programs, and/or related
// material (collectively the "Data") in these files contain unpublished
// information proprietary to Autodesk, Inc. ("Autodesk") and/or its licensors,
// which is protected by U.S. and Canadian federal copyright law and by
// international treaties.
//
// The Data is provided for use exclusively by You. You have the right to use,
// modify, and incorporate this Data into other products for purposes authorized 
// by the Autodesk software license agreement, without fee.
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND. AUTODESK
// DOES NOT MAKE AND HEREBY DISCLAIMS ANY EXPRESS OR IMPLIED WARRANTIES
// INCLUDING, BUT NOT LIMITED TO, THE WARRANTIES OF NON-INFRINGEMENT,
// MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE, OR ARISING FROM A COURSE 
// OF DEALING, USAGE, OR TRADE PRACTICE. IN NO EVENT WILL AUTODESK AND/OR ITS
// LICENSORS BE LIABLE FOR ANY LOST REVENUES, DATA, OR PROFITS, OR SPECIAL,
// DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES, EVEN IF AUTODESK AND/OR ITS
// LICENSORS HAS BEEN ADVISED OF THE POSSIBILITY OR PROBABILITY OF SUCH DAMAGES.


//<doc>
//<name containerAutopublishRoot>
//<synopsis>
//		containerAutopublishRoot
//
//<returns>
//		string: name of root if the operation was successful
//
//<description>
//      This script will check if the selected container contains dag
//      nodes that are all within a single dag hierarchy. If it does, then the
//		highest object within that hierarchy will be published as the
//		root transform and parent/child anchor. If the container 
//		has no dag nodes, or consists of multiple hierarchies, this
//		method will do nothing.
//
//<flags>
//		string $objs[], the selection to be considered when choosing a root
//		int $val if 1, publish the translate, rotate and scale for the root
//		int $preview 	if 1, print the name of the node that would be
//						published as root.
//
//<examples>
//	// auto publish the root for container1, and publish its TRS attributes
//	select -r container1;
//	containerAutopublishRoot 1 0;
//
//</doc>
//

global proc string
containerAutopublishRoot(string $objs[], int $val, int $preview)
{
	string $rtn = "";
	if (size($objs) == 0) {
		return $rtn;
	}
	string $container = "";
	if( !$preview ) {
		string $sel[] = `ls -sl`;
		if (size($sel) > 0 && `objectType -isa container $sel[0]`) {
			string $root = "";
			$container = $sel[0];
			$root = `container -q -publishAsRoot $container`; 
			if (size($root) > 0) {
				// The container already has a root. This can happen if you create a container
				// by nesting an object that is published as a root in an existing container.
				//
				container -e -publishAsRoot $root 0 $container;
			}
		} else {
			error((uiRes("m_containerAutopublishRoot.kNoContainerSelected")));
		}
	}
	string $xformsLong[] = `ls -long -type transform $objs`;
	string $xforms[] = `ls -type transform $objs`;	
	int $xformCount = size($xforms);
	if ($xformCount > 0) {

		// Find the transform at the highest level in the dag.
		// It will be our "possible parent". Just knowing it is the highest
		// up doesn't guarantee all the others are below it so we have to
		// check that too.
		//
		int $minDepth = 0;
		int $possibleParent = 0;
		for ($ii = 0; $ii < $xformCount; $ii++) {
			string $buff[];
			tokenize($xformsLong[$ii],"|",$buff);
			int $pathDepth = size($buff);

			if ($ii == 0) {
				$minDepth = $pathDepth;
			} else if ($pathDepth < $minDepth) {
				$possibleParent = $ii;
				$minDepth = $pathDepth;
			}
		}

		// Now validate whether the others all live under the highest one.
		//
		int $commonParent = 1;
		string $children[] = `listRelatives -allDescendents -path $xforms[$possibleParent]`;
		for ($ii = 0; $ii < $xformCount; $ii++) {
			if ($ii != $possibleParent) {
				if (!stringArrayContains($xforms[$ii],$children)) {
					$commonParent = 0;
					break;
				}
			}
		}
		if ($commonParent ) {
			// A common parent was found. Now let's just check to see if its
			// parent is also in the container. This can happen if the user
			// created a container using the "Include Hierarchy Above" option.
			//
			string $root = $xforms[$possibleParent];
			string $parents[] = `listRelatives -parent -path $root`;
			while (size($parents) == 1) {
				string $parentContainer = `container -q -findContainer $parents[0]`;
				if ($parentContainer == $container) {
					$root = $parents[0];
					$parents = `listRelatives -path -parent $root`;
				} else {
					break;
				}
			}
			
			if( $preview ) {
				string $fmt = (uiRes("m_containerAutopublishRoot.kPreviewRoot"));
				print( `format -s $root $fmt` );
			}
			else {
				container -e -publishAsRoot $root 1 $container;
				container -e -publishAsParent $root "rootParentAnchor" $container;
				container -e -publishAsChild $root "rootChildAnchor" $container;
				if ($val) {
					string $tr = ($root+".translate");
					string $rot = ($root+".rotate");
					string $scale = ($root+".scale");
					string $vis = ($root+".visibility");
					container -e -publishAndBind $tr "translate" $container;
					container -e -publishAndBind $rot "rotate" $container;
					container -e -publishAndBind $scale "scale" $container;
					container -e -publishAndBind $vis "visibility" $container;
				}
				$rtn = $root;
			}
		}
		else {
			if( $preview ) {
				print( (uiRes("m_containerAutopublishRoot.kPreviewNoRoot")) );
			}
		}
	}
	return $rtn;
}
