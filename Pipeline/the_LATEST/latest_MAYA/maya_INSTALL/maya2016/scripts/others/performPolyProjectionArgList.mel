// Copyright (C) 1997-2014 Autodesk, Inc., and/or its licensors.
// All rights reserved.
//
// The coded instructions, statements, computer programs, and/or related
// material (collectively the "Data") in these files contain unpublished
// information proprietary to Autodesk, Inc. ("Autodesk") and/or its licensors,
// which is protected by U.S. and Canadian federal copyright law and by
// international treaties.
//
// The Data is provided for use exclusively by You. You have the right to use,
// modify, and incorporate this Data into other products for purposes authorized 
// by the Autodesk software license agreement, without fee.
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND. AUTODESK
// DOES NOT MAKE AND HEREBY DISCLAIMS ANY EXPRESS OR IMPLIED WARRANTIES
// INCLUDING, BUT NOT LIMITED TO, THE WARRANTIES OF NON-INFRINGEMENT,
// MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE, OR ARISING FROM A COURSE 
// OF DEALING, USAGE, OR TRADE PRACTICE. IN NO EVENT WILL AUTODESK AND/OR ITS
// LICENSORS BE LIABLE FOR ANY LOST REVENUES, DATA, OR PROFITS, OR SPECIAL,
// DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES, EVEN IF AUTODESK AND/OR ITS
// LICENSORS HAS BEEN ADVISED OF THE POSSIBILITY OR PROBABILITY OF SUCH DAMAGES.

//
//  Creation Date:  4 April 1997
//
//
//  Description:
//
//
//  Procedure Name:
//      performPolyProjection
//
//  Description:
//        adds a planar, cylindric or spheric projection to the selected polygon facets
//         
//  Input Arguments:
//        $option : Whether to set the options to default values.
//  Return Value:
//        command string iff $option==2
//

proc string argArrayAsString (string $args[])
{
	string $result = "{";
	string $cast = "(string)";
	for ($arg in $args) {
		$result += ($cast + "\"" + $arg + "\"");
		$cast = ", ";
	}
	return ($result + "}");
}

proc setOptionVars (string $primitive, int $forceFactorySettings)
{
     // -psu/-projectionScaleU  -psv/-projectionScaleV 
	float $fval1=180.0;	// [0:360] theta range of spherical coordinate system
	float $fval2=90.0;	// [0:180] phi range of spherical coordinate system
	if ($primitive == "Planar") {
		$fval1=1.0;
		$fval2=1.0;
	} else if ($primitive == "Cylindrical") {
		$fval2=1.0;		// Project using a cylinder of height 1.
	}
	
	if ($forceFactorySettings || !`optionVar -exists ("polyProjectionFitToBoxOrPlane" + $primitive)`) {
		optionVar -intValue ("polyProjectionFitToBoxOrPlane" + $primitive) 2;
	}

	if ($forceFactorySettings || !`optionVar -exists ("polyProjectionMappingDirection" + $primitive)`) {
		optionVar -intValue ("polyProjectionMappingDirection" + $primitive) 1;
	}

	if ($forceFactorySettings || !`optionVar -exists ("polyProjectionInsertionPoint" + $primitive)`) {
		optionVar -intValue ("polyProjectionInsertionPoint" + $primitive) 1;
	}

    if ($primitive == "Planar")
		if ($forceFactorySettings || !`optionVar -exists ("polyProjectionSquareImage" + $primitive)`)
			optionVar -intValue ("polyProjectionSquareImage" + $primitive) 0;

	// -cm/-createMap
	if ($forceFactorySettings || !`optionVar -exists ("polyProjectionCreateMap" + $primitive)`)
		optionVar -intValue ("polyProjectionCreateMap" + $primitive) 0;		

	// -uvs/-uvSetName
	if ($forceFactorySettings || !`optionVar -exists ("polyProjectionUvSetName" + $primitive)`)
		optionVar -stringValue ("polyProjectionUvSetName" + $primitive) "uvSet1";		
	
	if ($forceFactorySettings || !`optionVar -exists ("polyProjectionMethod" + $primitive)`) {
		optionVar -intValue ("polyProjectionMethod" + $primitive) 1;
	}
	if ($forceFactorySettings || !`optionVar -exists ("polyProjectionSmoothness0" + $primitive)`) {
		optionVar -floatValue ("polyProjectionSmoothness0" + $primitive) 0;
	}
	if ($forceFactorySettings || !`optionVar -exists ("polyProjectionSmoothness1" + $primitive)`) {
		optionVar -floatValue ("polyProjectionSmoothness1" + $primitive) 0;
	}
	if ($forceFactorySettings || !`optionVar -exists ("polyProjectionSmoothness2" + $primitive)`) {
		optionVar -floatValue ("polyProjectionSmoothness2" + $primitive) 0;
	}
	if ($forceFactorySettings || !`optionVar -exists ("polyProjectionSmoothness3" + $primitive)`) {
		optionVar -floatValue ("polyProjectionSmoothness3" + $primitive) 0;
	}
	if ($forceFactorySettings || !`optionVar -exists ("polyProjectionOffset0" + $primitive)`) {
		optionVar -floatValue ("polyProjectionOffset0" + $primitive) 0;
	}
	if ($forceFactorySettings || !`optionVar -exists ("polyProjectionOffset1" + $primitive)`) {
		optionVar -floatValue ("polyProjectionOffset1" + $primitive) 0;
	}
	if ($forceFactorySettings || !`optionVar -exists ("polyProjectionOffset2" + $primitive)`) {
		optionVar -floatValue ("polyProjectionOffset2" + $primitive) 0;
	}
	if ($forceFactorySettings || !`optionVar -exists ("polyProjectionOffset3" + $primitive)`) {
		optionVar -floatValue ("polyProjectionOffset3" + $primitive) 0;
	}
	if ($forceFactorySettings || !`optionVar -exists ("polyProjectionUserDefinedCorners" + $primitive)`) {
		optionVar -intValue ("polyProjectionUserDefinedCorners" + $primitive) 0;
	}
}

global proc performPolyProjectionSetup (string $primitive, string $parent, int $forceFactorySettings)
{
	setOptionVars($primitive, $forceFactorySettings);
	setParent $parent;
	float $vals[];
	float $val;

	checkBoxGrp -edit -value1
		`optionVar -q ("polyProjectionInsertionPoint" + $primitive)`
			polyProjectionInsertionPoint;
	
	if ($primitive == "Planar") {
		radioButtonGrp -edit -select
			`optionVar -q ("polyProjectionFitToBoxOrPlane" + $primitive)`
			polyProjectionFitToBoxOrPlane;
	
		radioButtonGrp -edit -select 
			`optionVar -q ("polyProjectionMappingDirection" + $primitive)`
			polyProjectionMappingDirection;
	}
	else if ($primitive == "Contour") {
		radioButtonGrp -edit -select
			`optionVar -q ("polyProjectionMethod" + $primitive)`
			polyProjectionMethod;
		floatFieldGrp -edit -value1 `optionVar -q ("polyProjectionSmoothness0" + $primitive)` polyProjectionSmoothness0;
		floatFieldGrp -edit -value1 `optionVar -q ("polyProjectionSmoothness1" + $primitive)` polyProjectionSmoothness1;
		floatFieldGrp -edit -value1 `optionVar -q ("polyProjectionSmoothness2" + $primitive)` polyProjectionSmoothness2;
		floatFieldGrp -edit -value1 `optionVar -q ("polyProjectionSmoothness3" + $primitive)` polyProjectionSmoothness3;
		floatFieldGrp -edit -value1 `optionVar -q ("polyProjectionOffset0" + $primitive)` polyProjectionOffset0;
		floatFieldGrp -edit -value1 `optionVar -q ("polyProjectionOffset1" + $primitive)` polyProjectionOffset1;
		floatFieldGrp -edit -value1 `optionVar -q ("polyProjectionOffset2" + $primitive)` polyProjectionOffset2;
		floatFieldGrp -edit -value1 `optionVar -q ("polyProjectionOffset3" + $primitive)` polyProjectionOffset3;
	}
	
	if ($primitive == "Planar")
		checkBoxGrp -edit -value1 
			`optionVar -q ("polyProjectionSquareImage" + $primitive)`
				polyProjectionSquareImage;

	if ($primitive == "Contour")
		checkBoxGrp -edit -value1 
			`optionVar -q ("polyProjectionUserDefinedCorners" + $primitive)`
			polyProjectionUserDefinedCorners;

	$val = `optionVar -q ("polyProjectionCreateMap" + $primitive)`;
	checkBoxGrp -edit -value1 $val polyProjectionCreateMap;
	if ($val == 1)
		disable -v false polyProjectionUvSetName;
	else
		disable -v true polyProjectionUvSetName;
	textFieldGrp -edit -tx 
		`optionVar -q ("polyProjectionUvSetName" + $primitive)`		
		polyProjectionUvSetName;
}

global proc performPolyProjectionCallback (string $primitive, string $args[], string $uvSetName, string $parent, int $doIt)
{
	setParent $parent;

	if ($primitive == "Planar") {
		optionVar -intValue ("polyProjectionFitToBoxOrPlane" + $primitive)
			`radioButtonGrp -query -select polyProjectionFitToBoxOrPlane`;

		optionVar -intValue ("polyProjectionMappingDirection" + $primitive)
			`radioButtonGrp -query -select polyProjectionMappingDirection`;
	}
	else if ($primitive == "Contour") {
		optionVar -intValue ("polyProjectionMethod" + $primitive)
			`radioButtonGrp -query -select polyProjectionMethod`;
		optionVar -floatValue ("polyProjectionSmoothness0" + $primitive) `floatFieldGrp -query -value1 polyProjectionSmoothness0`;
		optionVar -floatValue ("polyProjectionSmoothness1" + $primitive) `floatFieldGrp -query -value1 polyProjectionSmoothness1`;
		optionVar -floatValue ("polyProjectionSmoothness2" + $primitive) `floatFieldGrp -query -value1 polyProjectionSmoothness2`;
		optionVar -floatValue ("polyProjectionSmoothness3" + $primitive) `floatFieldGrp -query -value1 polyProjectionSmoothness3`;
		optionVar -floatValue ("polyProjectionOffset0" + $primitive) `floatFieldGrp -query -value1 polyProjectionOffset0`;
		optionVar -floatValue ("polyProjectionOffset1" + $primitive) `floatFieldGrp -query -value1 polyProjectionOffset1`;
		optionVar -floatValue ("polyProjectionOffset2" + $primitive) `floatFieldGrp -query -value1 polyProjectionOffset2`;
		optionVar -floatValue ("polyProjectionOffset3" + $primitive) `floatFieldGrp -query -value1 polyProjectionOffset3`;
	}

	optionVar -intValue ("polyProjectionInsertionPoint" + $primitive)
		`checkBoxGrp -query -value1 polyProjectionInsertionPoint`;

	if ($primitive == "Planar")
		optionVar -intValue ("polyProjectionSquareImage" + $primitive)
			`checkBoxGrp -query -value1 polyProjectionSquareImage`;

	if ($primitive == "Contour")
		optionVar -intValue ("polyProjectionUserDefinedCorners" + $primitive)
			`checkBoxGrp -query -value1 polyProjectionUserDefinedCorners`;

	optionVar -intValue ("polyProjectionCreateMap" + $primitive)
		 `checkBoxGrp -query -value1 polyProjectionCreateMap`;
	optionVar -stringValue ("polyProjectionUvSetName" + $primitive)
		 `textFieldGrp -query -tx polyProjectionUvSetName`;

	if ($doIt) {
		$args[0] = "0";
		performPolyProjectionArgList 1 $args $uvSetName;
		string $tmpCmd = "performPolyProjection \"" + $primitive + "\" 0";
		string $tmpCmdLabel = "PolyProjection";
		if ($primitive == "Planar") $tmpCmdLabel = "PolyPlanarProjection";
		else if ($primitive == "Cylindrical") $tmpCmdLabel = "PolyCylindricalProjection";
		else if ($primitive == "Spherical") $tmpCmdLabel = "PolySphericalProjection";
		else if ($primitive == "Contour") $tmpCmdLabel = "PolyContourProjection";
		addToRecentCommandQueue $tmpCmd $tmpCmdLabel;
	}
}

global proc enableMappingDirection()
{
	disable -v false polyProjectionMappingDirection;
}

global proc enableFitToBoxOrPlane()
{
	disable -v false polyProjectionFitToBoxOrPlane;
}

proc polyProjectionOptions (string $primitive, string $args[], string $uvSetName)
{
	// Global template variables for form spacing
	global int $gOptionBoxTemplateFrameSpacing;
	
	string $layout = getOptionBox();
	setParent $layout;
	setUITemplate -pushTemplate OptionBoxTemplate;
	waitCursor -state 1;
	
	// Form layout
	string $parent;
	if ($primitive == "Planar") {
		$parent =`formLayout polyProjectionOptionsPlanar`;
    } else if ($primitive == "Cylindrical") {
		$parent =`formLayout polyProjectionOptionsCylindrical`;
    } else if ($primitive == "Spherical") {
		$parent =`formLayout polyProjectionOptionsSpherical`;
    } else if ($primitive == "Contour") {
		$parent =`formLayout polyProjectionOptionsContour`;
    }

	string $commandName = "performPolyProjection";
	string $callback = ($commandName + "Callback " + $primitive + " " + argArrayAsString ($args) + " \"" + $uvSetName + "\" " + $parent + " ");
	string $setup = ($commandName + "Setup " + $primitive + " " + $parent + " ");
	
		// Projection manipulator frame
		string $projectManipFrame = 
		`frameLayout -label (uiRes("m_performPolyProjectionArgList.kProjectManipFrame"))`;

			columnLayout;

			if ($primitive == "Planar")
			{
				radioButtonGrp -label (uiRes("m_performPolyProjectionArgList.kFitProjectionTo")) 
							-nrb 2 -label1 (uiRes("m_performPolyProjectionArgList.kFitToBestPlane"))
							-label2 (uiRes("m_performPolyProjectionArgList.kFitToBoundingBox"))
							-on1 ("disable polyProjectionMappingDirection")
							-of1 ("enableMappingDirection") -vr
							polyProjectionFitToBoxOrPlane;

				separator -style "none";

				radioButtonGrp -nrb 4 -label (uiRes("m_performPolyProjectionArgList.kBBoxSide"))
								-label1 (uiRes("m_performPolyProjectionArgList.kXAxis")) 
								-label2 (uiRes("m_performPolyProjectionArgList.kYAxis")) 
								-label3 (uiRes("m_performPolyProjectionArgList.kZAxis")) 
								-label4 (uiRes("m_performPolyProjectionArgList.kCamera")) 
								-vr polyProjectionMappingDirection;
			
				separator -style "none";
			
				checkBoxGrp -label1 (uiRes("m_performPolyProjectionArgList.kKeepImageRatio")) polyProjectionSquareImage;
			}
			else if ($primitive == "Contour")
			{
				radioButtonGrp -label (uiRes("m_performPolyProjectionArgList.kMethod")) 
							-nrb 2
							-label1 (uiRes("m_performPolyProjectionArgList.kWalkContours"))
							-label2 (uiRes("m_performPolyProjectionArgList.kNURBSProjection"))
							-vr polyProjectionMethod;

				separator -style "none";

				floatFieldGrp -label (uiRes("m_performPolyProjectionArgList.kSmoothness0")) polyProjectionSmoothness0;
				floatFieldGrp -label (uiRes("m_performPolyProjectionArgList.kSmoothness1")) polyProjectionSmoothness1;
				floatFieldGrp -label (uiRes("m_performPolyProjectionArgList.kSmoothness2")) polyProjectionSmoothness2;
				floatFieldGrp -label (uiRes("m_performPolyProjectionArgList.kSmoothness3")) polyProjectionSmoothness3;
				floatFieldGrp -label (uiRes("m_performPolyProjectionArgList.kOffset0")) polyProjectionOffset0;
				floatFieldGrp -label (uiRes("m_performPolyProjectionArgList.kOffset1")) polyProjectionOffset1;
				floatFieldGrp -label (uiRes("m_performPolyProjectionArgList.kOffset2")) polyProjectionOffset2;
				floatFieldGrp -label (uiRes("m_performPolyProjectionArgList.kOffset3")) polyProjectionOffset3;

				checkBoxGrp -label1 (uiRes("m_performPolyProjectionArgList.kUserDefinedCorners")) polyProjectionUserDefinedCorners;
			}
			
				checkBoxGrp -label1 (uiRes("m_performPolyProjectionArgList.kInsertBeforeDeformers")) polyProjectionInsertionPoint;

			setParent ..; // columnLayout

		setParent $parent; // frameLayout

		// UV set frame
		string $uvSetFrame = 
		`frameLayout -label (uiRes("m_performPolyProjectionArgList.kUVSetFrame"))`;

			columnLayout;

				checkBoxGrp -label1 (uiRes("m_performPolyProjectionArgList.kCreateNewUVSet"))
					-on1 ("disable -v false polyProjectionUvSetName")
					-of1 ("disable -v true polyProjectionUvSetName")
					polyProjectionCreateMap;
				textFieldGrp -label (uiRes("m_performPolyProjectionArgList.kUVSetName")) polyProjectionUvSetName;

			setParent ..; // columnLayout

		setParent $parent; // frameLayout
		
	setParent ..; // formLayout
	
	// Attach frames to form layout
	formLayout -e
		-af $projectManipFrame "top" $gOptionBoxTemplateFrameSpacing
		-af $projectManipFrame "left" $gOptionBoxTemplateFrameSpacing
		-af $projectManipFrame "right" $gOptionBoxTemplateFrameSpacing
		-an $projectManipFrame "bottom"

		-ac $uvSetFrame "top" $gOptionBoxTemplateFrameSpacing $projectManipFrame
		-af $uvSetFrame "left" $gOptionBoxTemplateFrameSpacing
		-af $uvSetFrame "right" $gOptionBoxTemplateFrameSpacing
		-an $uvSetFrame "bottom" 

	$parent;
	

	waitCursor -state 0;
	setUITemplate -popTemplate;
	   
	string $applyBtn = getOptionBoxApplyBtn();
	button -edit -label (uiRes("m_performPolyProjectionArgList.kProject"))
	       -command ($callback + 1)
		$applyBtn;
	string $saveBtn = getOptionBoxSaveBtn();
	button -edit 
		-command ($callback + 0 + "; hideOptionBox")
		$saveBtn;
	string $resetBtn = getOptionBoxResetBtn();
	button -edit 
		-command ($setup + 1)
		$resetBtn;
			 
	
	if ($primitive == "Planar") {
		setOptionBoxTitle (uiRes("m_performPolyProjectionArgList.kPlanarProjectionOptions"));
		setOptionBoxHelpTag( "PlanarMapping" );
	} else if ($primitive == "Cylindrical") {
		setOptionBoxTitle (uiRes("m_performPolyProjectionArgList.kCylindricalProjectionOptions"));
		setOptionBoxHelpTag( "CylindricalMapping" );
	} else if ($primitive == "Spherical") {
		setOptionBoxTitle (uiRes("m_performPolyProjectionArgList.kSphericalProjectionOptions"));
		setOptionBoxHelpTag( "SphericalMapping" );
	} else if ($primitive == "Contour") {
		setOptionBoxTitle (uiRes("m_performPolyProjectionArgList.kContourProjectionOptions"));
		setOptionBoxHelpTag( "ContourMapping" );
	}

	eval (($setup + 0));
	showOptionBox();
}

proc string setCurrentCmd(string $primitive, int $forceCreate, string $uvSetName)
{
	int $createNewMap =	`optionVar -q ("polyProjectionCreateMap" + $primitive)`;
	string $setCurrent = "";
	if ($createNewMap || $forceCreate)
		$setCurrent = "polyUVSet -luv";
	return $setCurrent;
}

proc string assembleCmd(string $primitive, int $forceCreate, string $uvSetName)
{
	setOptionVars ($primitive, false);

	int $doHistory = `constructionHistory -q -toggle`;

	int $createNewMap =	`optionVar -q ("polyProjectionCreateMap" + $primitive)`;
	string $mapname = `optionVar -q ("polyProjectionUvSetName" + $primitive)`;

	string $cmd;
	if ($primitive == "Contour")
		$cmd=("poly" + $primitive + "Projection" + " -ch " + $doHistory);
	else
		$cmd=("polyProjection -ch " + $doHistory + " -type " + $primitive);
	if (`optionVar -query ("polyProjectionInsertionPoint" + $primitive)`)
		$cmd+=(" -ibd on");
	else $cmd+=(" -ibd off");


	if ($createNewMap || $forceCreate)
	{
		if ($forceCreate) $mapname = $uvSetName;
		if (size($mapname))
		{
			$cmd = $cmd + (" -cm on -uvSetName " + $mapname);
		}
	}

	if ($primitive == "Contour")
	{
		int $method = `optionVar -q ("polyProjectionMethod" + $primitive)`;
		$cmd += " -m " + ( $method - 1 );
		$cmd += " -s0 " + `optionVar -q ("polyProjectionSmoothness0" + $primitive)`;
		$cmd += " -s1 " + `optionVar -q ("polyProjectionSmoothness1" + $primitive)`;
		$cmd += " -s2 " + `optionVar -q ("polyProjectionSmoothness2" + $primitive)`;
		$cmd += " -s3 " + `optionVar -q ("polyProjectionSmoothness3" + $primitive)`;
		$cmd += " -o0 " + `optionVar -q ("polyProjectionOffset0" + $primitive)`;
		$cmd += " -o1 " + `optionVar -q ("polyProjectionOffset1" + $primitive)`;
		$cmd += " -o2 " + `optionVar -q ("polyProjectionOffset2" + $primitive)`;
		$cmd += " -o3 " + `optionVar -q ("polyProjectionOffset3" + $primitive)`;
		$cmd+=(" -udc off");
		return $cmd;
	}

	int $fitToBoundingBox = 0, $fitToBestPlane = 0;

	if ($primitive == "Planar")
	{
		if (`optionVar -query ("polyProjectionSquareImage" + $primitive)`)
			$cmd+=(" -kir ");
	}
	else
	{
		$cmd+=(" -sf on ");
		return $cmd;
	}

	int $result=`optionVar -q ("polyProjectionFitToBoxOrPlane" + $primitive)`;
	if ($result == 1) return ($cmd + " -md b");		//Best Plane
	else if ($result == 2) {			//Bounding Box with direction
		int $mdir = `optionVar -q ("polyProjectionMappingDirection" + $primitive)`;
		switch ($mdir) {
			case 1: return ($cmd + " -md x ");
			case 2: return ($cmd + " -md y ");
			case 3: return ($cmd + " -md z ");
			case 4: return ($cmd + " -md c ");
		}
	}

	return $cmd;	
}

proc string createCurrentShader ()
{
	global string $polyTextureColorShader;
	string $shader;
	string $shaderType="lambert";
	string $textureName="checker";
	if (`optionVar -q polyCreateShaderWithMapping` == 0) 
		return "";
	string $shader=`evalEcho "sets -n texturedFacets -em -r true -nss true"`;
	if ($shader != "") {
		evalEcho ("partition -e -addSet renderPartition " + $shader);
		string $shad[];
		if ($polyTextureColorShader != "")
			$shad=`ls -showType $polyTextureColorShader`;
		if ($polyTextureColorShader == "" || size($shad) == 0) {
			string $texture[]=`ls -showType defaultPolygonTexture`;
			if (size($texture) == 0)
				$texture[0]=`evalEcho ("shadingNode -asTexture " 
						+ $textureName + " -n defaultPolygonTexture")`;			
			$polyTextureColorShader=`evalEcho ("shadingNode -asShader " 
						+ $shaderType + " -n defaultPolygonShader")`;
			evalEcho ("connectAttr " + $texture[0] + ".outColor " 
					+ $polyTextureColorShader + ".color");
			// creating a node selects it: we don't want that...
			select -d $texture[0] $polyTextureColorShader;
		}
		$shad=`ls -showType $polyTextureColorShader`;
		if ($polyTextureColorShader != "" && size($shad) != 0)
			evalEcho ("connectAttr -f " + $polyTextureColorShader + ".outColor " 
								+ $shader + ".surfaceShader");
		else warning (uiRes("m_performPolyProjectionArgList.kDefaultPolygonsShaderWarn"));
	} else warning (uiRes("m_performPolyProjectionArgList.kCreateNewSetWarn"));
	return $shader;
}


proc concatArray(string $res[], string $to_add[])
{
	for($i in $to_add)
		$res[size($res)] = $i;
}

global proc polyContourProjToolStart()
{
	global int $prevTrackSelectionOrder;
	$prevTrackSelectionOrder = `selectPref -q -trackSelectionOrder`;
	selectPref -trackSelectionOrder true;

	global string $polyProjectionTotalSel[];
	$polyProjectionTotalSel = `ls -sl`;
	select -clear;
}

global proc polyContourProjToolFinish()
{
	global int $prevTrackSelectionOrder;
	selectPref -trackSelectionOrder $prevTrackSelectionOrder;

	global string $polyProjectionTotalSel[];
	select -r $polyProjectionTotalSel;
}

// This func gets the char from the string at the specified index
proc string getChar( string $str, int $index )
{
	if ( size( $str ) < $index || 0 >= $index )
		return "";

	string $ret = `substring $str $index $index`;
	return $ret;
}

// This function is used for splitting up a selection string
// which looks like pPlane1.vtx[3]
// Return string is: vtx[3]
proc string getSelectionComp( string $sel )
{	
	string $rest = $sel;
	int $length = size($sel);
	for ($i = 0; $i < $length; $i++)
	{
		if ( getChar( $sel, $i ) == "." )
			$rest = `substring $sel ($i+1) $length`;
	}
	return $rest;
}

global proc polyContourProjSetAttr(string $sel[])
{
	global string $polyProjectionRes[];

	setAttr ($polyProjectionRes[0] + ".userDefinedCorners") true;

	string $cmd = "setAttr " + $polyProjectionRes[0] + ".cornerVertices -type componentList ";
	$cmd += `size($sel)`;
	for($i in $sel)
	{
		$cmd += (" " + getSelectionComp($i));
	}

	evalEcho $cmd;
}

global proc polyContourProjTool()
{
	if (!`contextInfo -exists polyContourProjCtx`)
	{
		scriptCtx
			-title (uiRes("m_performPolyProjectionArgList.kPolyContourProjCtx"))
			-totalSelectionSets 1
			-cumulativeLists false
			-expandSelectionList false
			-exitUponCompletion true
			-fcs "polyContourProjSetAttr $Selection1"
			-toolStart "polyContourProjToolStart"
			-toolFinish "polyContourProjToolFinish"
			-setNoSelectionPrompt (uiRes("m_performPolyProjectionArgList.kSelectContourProjVertices"))
			-setNoSelectionHeadsUp (uiRes("m_performPolyProjectionArgList.kSelectVertices"))
			-setAutoToggleSelection true
			-setAutoComplete false
			-setSelectionCount 0
			-pf false
			-pv true
			-cv true
			-xyz false
			polyContourProjCtx;
	}

	setToolTo polyContourProjCtx;
}

global proc string performPolyProjectionArgList(string $version, string $args[], string $uvSetName)
//
//	Input Arguments:
//	$version: The version of this option box.  Used to know how to 
//	interpret the $args array.
//		"1" : $action, $primitive, $selectCmd
//
//	$args
//	Version 1
//	[0]		$action		0 : Execute the command.
//						1 : Show the option box dialog.
//						2 : Return the command.
//	[1]		$primitive	The type of primitive to create
//	[2]		$selectCmd	The command to issue to determine which objects
//							to affect
//	[3]		$forceCreate	Whether or not to force creation of a new UV set
//
//	$uvSetName: The requested name for a new uv set
//
//  Return Value:
//      The string to execute for this option box.
//
{
	int		$versionNum				= $version;

	int		$action					= $args[0];
	string	$primitive				= $args[1];
	string	$selectCmd				= $args[2];
	int		$forceCreate			= $args[3];

    string $cmd="";
    string $lbl;
    string $sel[], $preFilteredSel[];
    switch ($action) {
    case 0:
		string $objects[] = `eval ($selectCmd)`;
        $sel=`filterExpand -ex false -sm 34 $objects`;
		if (size($sel) > 0) {
			// If selection contains faces, use them
			$preFilteredSel=$sel;
		} else {
			// Try to convert the selection to faces (if the flag is turned on)
			$preFilteredSel=`polyCheckSelection ("poly"+$primitive+"Projection") f 1`;
			string $expSel[];
			$expSel = `filterExpand -ex false -sm 34 `;
			if (size($expSel) <= 0) {
				// If the flag is turned off, suggest to turn it on,
				warning (uiRes("m_performPolyProjectionArgList.kPolyProjectionWarn"));
				return $cmd;
			}
		}

        if (size($preFilteredSel) != 0) {
            setOptionVars($primitive, false);
            int $index=0;
            string $oldnodes[]=`ls -sl -dep`;
            if (size($oldnodes) > 0)
                select -d $oldnodes;

            string $totalSel[];

            // what is selected ?
            concatArray($totalSel, `ls -sl`);

            // Do projections.

			string $cmd=`assembleCmd $primitive $forceCreate $uvSetName`;
			for ($i = 0; $i < size($preFilteredSel); $i++)
				$cmd += (" " + $preFilteredSel[$i]);

            string $res[];
            $res=`evalEcho $cmd`;
            // append $res (nodes) to $totalSel
            concatArray($totalSel, $res);

			// Set current
			string $setCurrent = `setCurrentCmd $primitive $forceCreate $uvSetName`;
			if (size($setCurrent))
			{
				for ($i = 0; $i < size($preFilteredSel); $i++)
					$setCurrent += (" " + $preFilteredSel[$i]);
				evalEcho $setCurrent;
			}

            string $shader=`createCurrentShader`;
            // Update shader's set.
            if( $shader != "") {
                $cmd=("sets -e -fe " + $shader);
				int $i;
                for($i=0; $i < size($preFilteredSel); $i++)
                    $cmd=($cmd + " " + $preFilteredSel[$i]);
                evalEcho $cmd;
            }

            // Set selection
            evalEcho `select -r $totalSel`;

            // clear $sel;
            global string $polyLastTool;
            $polyLastTool="";
            setToolTo ShowManips;

			global string $polyProjectionRes[];
			if ($primitive == "Contour" && `optionVar -q ("polyProjectionUserDefinedCorners" + $primitive)` && size($res) != 0)
			{
				$polyProjectionRes = $res;
				polyContourProjTool();
			}
        } else warning (uiRes("m_performPolyProjectionArgList.kPolyProjectionInvokeWarn")); 
		
        break;

    case 1: polyProjectionOptions $primitive $args $uvSetName; break;
    case 2: $cmd=`assembleCmd $primitive $forceCreate $uvSetName`;	
	  string $setCurrent = `setCurrentCmd $primitive $forceCreate $uvSetName`;
	  $cmd += ("; " + $setCurrent);
	  break;
    default:
        // this is useless: setOptionVars(false);
        $cmd = ("performPolyProjection " + $primitive + " 0");
    }
    return $cmd;
}
