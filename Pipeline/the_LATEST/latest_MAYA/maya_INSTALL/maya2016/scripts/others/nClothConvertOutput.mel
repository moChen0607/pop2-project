// Copyright (C) 1997-2014 Autodesk, Inc., and/or its licensors.
// All rights reserved.
//
// The coded instructions, statements, computer programs, and/or related
// material (collectively the "Data") in these files contain unpublished
// information proprietary to Autodesk, Inc. ("Autodesk") and/or its licensors,
// which is protected by U.S. and Canadian federal copyright law and by
// international treaties.
//
// The Data is provided for use exclusively by You. You have the right to use,
// modify, and incorporate this Data into other products for purposes authorized 
// by the Autodesk software license agreement, without fee.
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND. AUTODESK
// DOES NOT MAKE AND HEREBY DISCLAIMS ANY EXPRESS OR IMPLIED WARRANTIES
// INCLUDING, BUT NOT LIMITED TO, THE WARRANTIES OF NON-INFRINGEMENT,
// MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE, OR ARISING FROM A COURSE 
// OF DEALING, USAGE, OR TRADE PRACTICE. IN NO EVENT WILL AUTODESK AND/OR ITS
// LICENSORS BE LIABLE FOR ANY LOST REVENUES, DATA, OR PROFITS, OR SPECIAL,
// DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES, EVEN IF AUTODESK AND/OR ITS
// LICENSORS HAS BEEN ADVISED OF THE POSSIBILITY OR PROBABILITY OF SUCH DAMAGES.


//<doc>
//<name nClothConvertOutput>
//<owner "Autodesk">
//
//<synopsis>
//		nClothConvertOutput( int $toLocal )
//
//<returns>
//		None.	
//
//<description>
//		Given selected nCloth nodes, convert the output from world space
//	to local space, if $toLocal is true, or vice versa otherwise.
//
//
//<flags>
//	int $toLocal  if true then set the cloth to localSpace otherwise set to worldspace
//
//<examples>
//  nClothConvertOutput false;
//</doc>

global proc nClothConvertOutput( int $toLocal )
{
	// First, find the nCloths directly selected
	//
	string $converted;
	string $pruneTypes[] = { "nucleus", "dynamicConstraint", "nComponent", "nCloth", "nRigid" };
	string $nCloths[] = getSelectedNObjs( "nCloth" );

	int $numCloths = size($nCloths);
	int $index = 0;
	while( $index < $numCloths ){
		string $nCloth = $nCloths[$index];
		$index++;
		if( `getAttr ($nCloth + ".localSpaceOutput")` == $toLocal ){
			// Skip any nCloth already in the right space
			//
			continue;
		}
			

		// Find the output mesh
		//
		int $doFuture = 0;
		string $meshes[];
		string $parents[];
		while( $doFuture <= 1 ){
			string $nodes[] = pruneSearch( $nCloth, $doFuture, $pruneTypes );
			string $allMeshes[] = `ls -type "mesh" $nodes`;
			if( size($allMeshes) > 0 ){
				$meshes[$doFuture] = $allMeshes[0];
				string $allParents[] = `listRelatives -parent $meshes[$doFuture]`;
				if( size($allParents) > 0 ){
					$parents[$doFuture] = $allParents[0];
				}
			}
			$doFuture++;
		}
		if( ($meshes[0] == "") || ($meshes[1] == "") ){
			string $fmt = (uiRes("m_nClothConvertOutput.kMissingMesh"));
			warning(`format -s $nCloth $fmt`);
		} else if( ($parents[0] == "") || ($parents[1] == "") ){
			string $fmt = (uiRes("m_nClothConvertOutput.kMissingParent"));
			warning(`format -s $nCloth $fmt`);
		} else {
			if( $converted == "" ){
				$converted = $nCloth;
			} else {
				$converted = $converted + ", " + $nCloth;
			}
			if( $toLocal ){
				parent -s -r $meshes[1] $parents[0];
				delete $parents[1];
			} else {
				// Create a new parent & copy the old parent's values
				//
				string $worldParent = `createNode "transform" -n "polySurface1"`;
				copyNode $parents[0] $worldParent;
				parent -s -r $meshes[1] $worldParent;
			}
			setAttr ($nCloth + ".localSpaceOutput") $toLocal;
		}
	}
	if( $converted != "" ){
		string $fmt =  (uiRes("m_nClothConvertOutput.kWrongSpaceCache"));
		warning( `format -s $converted $fmt`);
	} else {
		warning( (uiRes("m_nClothConvertOutput.kNothingConverted")) );
	}
}
