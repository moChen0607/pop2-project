// Copyright (C) 1997-2014 Autodesk, Inc., and/or its licensors.
// All rights reserved.
//
// The coded instructions, statements, computer programs, and/or related
// material (collectively the "Data") in these files contain unpublished
// information proprietary to Autodesk, Inc. ("Autodesk") and/or its licensors,
// which is protected by U.S. and Canadian federal copyright law and by
// international treaties.
//
// The Data is provided for use exclusively by You. You have the right to use,
// modify, and incorporate this Data into other products for purposes authorized 
// by the Autodesk software license agreement, without fee.
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND. AUTODESK
// DOES NOT MAKE AND HEREBY DISCLAIMS ANY EXPRESS OR IMPLIED WARRANTIES
// INCLUDING, BUT NOT LIMITED TO, THE WARRANTIES OF NON-INFRINGEMENT,
// MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE, OR ARISING FROM A COURSE 
// OF DEALING, USAGE, OR TRADE PRACTICE. IN NO EVENT WILL AUTODESK AND/OR ITS
// LICENSORS BE LIABLE FOR ANY LOST REVENUES, DATA, OR PROFITS, OR SPECIAL,
// DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES, EVEN IF AUTODESK AND/OR ITS
// LICENSORS HAS BEEN ADVISED OF THE POSSIBILITY OR PROBABILITY OF SUCH DAMAGES.

//
//  Procedure Name:
//      getCameraNode
//
//  Description:
//      Procedure to get the name of a camera node.
//
//  Input Arguments:
//      node - name of node to get
//      camera - camera name to get nodes for
//
//  Return Value:
//      Name of the requested camera node
//

//
//  Procedure Name:
//      getLookAtNode
//
proc string getLookAtNode( string $camera )
{
    string $lookAts[] = `listConnections ($camera+".rotateX")`;

    if (size($lookAts) == 0 || `objectType $lookAts[0]` != "lookAt")
        $lookAts = `listConnections ($camera+".rotateY")`;

    if (size($lookAts) == 0 || `objectType $lookAts[0]` != "lookAt")
        $lookAts = `listConnections ($camera+".rotateZ")`;

    return (size($lookAts) == 0 || `objectType $lookAts[0]` != "lookAt") ?
        "" : $lookAts[0];
}

//
//  Procedure Name:
//      getViewNode
//
proc string getViewNode( string $camera )
{
    string $views[];

    string $lookAt = getLookAtNode( $camera );

    if ($lookAt != "") {
        $views = `listConnections ($lookAt+".target[0].targetTranslateX")`;

        if (size($views) == 0 || `objectType $views[0]` != "transform")
            $views = `listConnections ($lookAt+".target[0].targetTranslateY")`;

        if (size($views) == 0 || `objectType $views[0]` != "transform")
            $views = `listConnections ($lookAt+".target[0].targetTranslateZ")`;
    }

    return (size($views) != 0 && `objectType $views[0]` == "transform") ?
        $views[0] : "";
}

//
//  Procedure Name:
//      getUpNode
//
proc string getUpNode( string $camera )
{
    string $ups[];

    string $lookAt = getLookAtNode( $camera );

    if ($lookAt != "")
        $ups = `listConnections ($lookAt+".worldUpMatrix")`;

    return (size($ups) > 0) ? $ups[0] : "";
}

//
//  Procedure Name:
//      cameraNode
//
global proc string getCameraNode( string $node, string $camera )
{
    string $result = "";
	if (`objectType -isa "camera" $camera`) {
		// In cases where there are more than one shape under a transform and
		// one of them is a camera, it is possible that this method will be
		// called with the actual camera node instead of the transform above
		// it.  Compensate.
		//
		string $parents[] = `listRelatives -parent -path $camera`;
		$camera = $parents[0];
	}

    switch ($node) {
    case "lookAt":
        $result = getLookAtNode( $camera );
        break;

    case "view":
        $result = getViewNode( $camera );
        break;

    case "up":
        $result = getUpNode( $camera );
        break;
    }

    return $result;
}
