// Copyright (C) 1997-2014 Autodesk, Inc., and/or its licensors.
// All rights reserved.
//
// The coded instructions, statements, computer programs, and/or related
// material (collectively the "Data") in these files contain unpublished
// information proprietary to Autodesk, Inc. ("Autodesk") and/or its licensors,
// which is protected by U.S. and Canadian federal copyright law and by
// international treaties.
//
// The Data is provided for use exclusively by You. You have the right to use,
// modify, and incorporate this Data into other products for purposes authorized 
// by the Autodesk software license agreement, without fee.
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND. AUTODESK
// DOES NOT MAKE AND HEREBY DISCLAIMS ANY EXPRESS OR IMPLIED WARRANTIES
// INCLUDING, BUT NOT LIMITED TO, THE WARRANTIES OF NON-INFRINGEMENT,
// MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE, OR ARISING FROM A COURSE 
// OF DEALING, USAGE, OR TRADE PRACTICE. IN NO EVENT WILL AUTODESK AND/OR ITS
// LICENSORS BE LIABLE FOR ANY LOST REVENUES, DATA, OR PROFITS, OR SPECIAL,
// DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES, EVEN IF AUTODESK AND/OR ITS
// LICENSORS HAS BEEN ADVISED OF THE POSSIBILITY OR PROBABILITY OF SUCH DAMAGES.

//
// Flow Along Curves
//
// Date:   November 10, 1998
//
// Description:
//
//    For each selected curve, this clip effect creates an emitted particle
// object that "flows" along the curve.  This is done by creating a
// complicated goal setup.  This also works on curve-on-surface objects
// by creating a world-space curve that follows the curve-on-curve with
// the history.
//

includeEffectsGlobals();

proc string flowAlongCurve( string $setName, string $curveName, int $controlSegmentCount, int $subSegmentCount, int $attachEmitterToCurve, float $emitterRate, float $randomMotionSpeed, float $lifespan, float $goalWeight )
//
// Description:
//
//    This MEL procedure takes a curve in the scene and creates the
// following objects:
//
//    -   Emitter, E
//    -   Particle object, P, being emitted from E
//    -   Goal, G, for P
//    -   A set of locators that drive the "shape" of the goal G
//    -   Two ramps that also control the "shape" of G
//
//    The locators are set up to lie on the curve.  A subset of the
// locators act as "key locations" on the curve for the rest.  The
// remaining locators are linearly interpolated along the curve
// between the "key" locators.  The locators define a goal "path"
// for the particles in P.  They try to move along the path over their
// lifespan.
//
//    At each of the locators, there is also a circle.  The circle is
// "attached" to the curve both in position and in tangent.  These
// circle define a tube around the curve that represents the thickness
// of the goal path.  The particles' goal positions will be somewhere
// within the approximate shape of this tube.
//
{
	//
	// This variable tells the effect whether or not to produce any
	// output to let the user know how/what it is doing.  If it looks
	// like the effect might take more than a minute to execute, then
	// this is turned on so that the user does not think that Maya
	// has hung.
	//
	int $showOutput = 0;
	if( 1 )
	{
		$showOutput = 1;
	}

	//
	// "setArray" is the list of all of the objects or groups created.
	// They will all be grouped together at the end of the procedure.
	//
	string $setArray[];
	clear($setArray);

	//
	// These are arrays to hold the names of the created locators.
	//
	string $controlLocatorArray[];
	clear($controlLocatorArray);
	string $subLocatorArray[];
	clear($subLocatorArray);
	string $paramLocatorArray[];
	clear($paramLocatorArray);

	//
	// These are arrays to hold the names of the created circle.
	//
	string $scalableCircleArray[];
	clear($scalableCircleArray);
	string $controlCircleArray[];
	clear($controlCircleArray);
	string $subCircleArray[];
	clear($subCircleArray);
	string $circleArray[];
	clear($circleArray);

	if( $showOutput )
	{	
		print `format -stringArg $curveName (uiRes("m_flowAlongCurves.kApplyeffect"))` ; 
	}

	//
	// Set the base name for the objects created.  If no name was
	// passed in, then use a default base name.  Create a group
	// for the objects to go into.
	//
	string $setGroupName;
	if( size($setName) == 0 )
		$setGroupName = `group -empty -name ($curveName+"_flowGroup")`;
	else
		$setGroupName = `group -empty -name $setName`;

	string $currentSelectedList[] = `ls -sl`;
	string $setGroupPath = $currentSelectedList[0];
	setAttr -keyable 0 ($setGroupPath+".tx");
	setAttr -keyable 0 ($setGroupPath+".ty");
	setAttr -keyable 0 ($setGroupPath+".tz");
	setAttr -keyable 0 ($setGroupPath+".rx");
	setAttr -keyable 0 ($setGroupPath+".ry");
	setAttr -keyable 0 ($setGroupPath+".rz");
	setAttr -keyable 0 ($setGroupPath+".sx");
	setAttr -keyable 0 ($setGroupPath+".sy");
	setAttr -keyable 0 ($setGroupPath+".sz");
	// setAttr -lock 1 ($setGroupPath+".tx");
	// setAttr -lock 1 ($setGroupPath+".ty");
	// setAttr -lock 1 ($setGroupPath+".tz");
	// setAttr -lock 1 ($setGroupPath+".rx");
	// setAttr -lock 1 ($setGroupPath+".ry");
	// setAttr -lock 1 ($setGroupPath+".rz");
	// setAttr -lock 1 ($setGroupPath+".sx");
	// setAttr -lock 1 ($setGroupPath+".sy");
	// setAttr -lock 1 ($setGroupPath+".sz");

	//
	// Grab the tail of the unique path for this group to
	// use as the base name.
	//
	string $pathNames[];
	tokenize( $setGroupPath, "|", $pathNames );
	$setGroupName = $pathNames[size($pathNames)-1];

	//
	// get some information about the curve for use when setting
	// locator parameters.
	//
	float $curveStart = `getAttr ($curveName+".minValue")`;
	string $curveStartStr = ($curveName+".minValue");
	float $curveEnd = `getAttr ($curveName+".maxValue")`;
	string $curveEndStr = ($curveName+".maxValue");
	float $curveRange = $curveEnd - $curveStart;
	string $curveRangeStr = ("( "+$curveEndStr+" - "+$curveStartStr+" )");

	//
	// Create the particle object
	//
	string $particleName;
	string $particlePath;
	{
		if( $showOutput )
		{
			print (uiRes("m_flowAlongCurves.kCreateParticleObj")) ;
		}

		string $resultArray[] = `particle -name ($setGroupName+"_particle")`;
		$particleName = $resultArray[1];
		$particlePath = ("|"+$resultArray[0]+"|"+$particleName);
		$setArray[size($setArray)] = ("|"+$resultArray[0]);
		addAttr -ln "maxDistance" -dt doubleArray $particlePath;
		addAttr -ln "maxDistance0" -dt doubleArray $particlePath;
		addAttr -ln "curveOffset" -dt vectorArray $particlePath;
		addAttr -ln "curveOffset0" -dt vectorArray $particlePath;
		addAttr -ln "randomPosition" -dt vectorArray $particlePath;
		addAttr -ln "randomPosition0" -dt vectorArray $particlePath;
		addAttr -ln "goalOffset" -dt vectorArray $particlePath;
		addAttr -ln "goalOffset0" -dt vectorArray $particlePath;
		addAttr -ln "goalPP" -dt doubleArray $particlePath;
		addAttr -ln "goalPP0" -dt doubleArray $particlePath;
		addAttr -ln "rampValues" -dt vectorArray $particlePath;
		addAttr -ln "rampValues0" -dt vectorArray $particlePath;
	
		// In previous versions we added lifespan here.
		// Now in 3.0 and later, we set mode to constant.
		//
		setAttr ($particlePath+".lifespanMode") 1;
		setAttr ($particlePath+".lifespan") $lifespan;
	
		addAttr -ln "randomMotionSpeed" -min 0 -dv 0 $particlePath;
		setAttr ($particlePath+".randomMotionSpeed") $randomMotionSpeed;
		setAttr -keyable 1 ($particlePath+".randomMotionSpeed");
	
		string $creationExpr;
		$creationExpr = ($particlePath+".goalPP = 0;\n");
		$creationExpr += ("vector $idVector = "+$particlePath+".id;\n");
		$creationExpr += ("vector $randomPosition = dnoise( $idVector * 10.0 ) * 100.0;\n");
		$creationExpr += ($particlePath+".randomPosition = $randomPosition;\n");
		$creationExpr += ("float $randomMotionSpeed = "+$particlePath+".randomMotionSpeed;\n");
		$creationExpr += ("float $maxDistance = "+$particlePath+".maxDistance;\n");
		$creationExpr += ("vector $curveOffset =\n");
		$creationExpr += ("    dnoise( $randomPosition + ( time * $randomMotionSpeed ) ) *\n    $maxDistance;\n");
		$creationExpr += ("vector $rampValues = "+$particlePath+".rampValues;\n");
		$creationExpr += ($particlePath+".curveOffset =\n    "+$particlePath+".curveOffset;\n");
		$creationExpr += ($particlePath+".goalOffset =\n");
		$creationExpr += ("    $rampValues + $curveOffset;\n");
		dynExpression -c -s $creationExpr $particlePath;
	
		string $runtimeExpr;
		$runtimeExpr = ($particlePath+".goalPP = 1;\n");
		$runtimeExpr += ("vector $randomPosition = "+$particlePath+".randomPosition;\n");
		$runtimeExpr += ("float $randomMotionSpeed = "+$particlePath+".randomMotionSpeed;\n");
		$runtimeExpr += ("float $maxDistance = "+$particlePath+".maxDistance;\n");
		$runtimeExpr += ("vector $curveOffset =\n");
		$runtimeExpr += ("    dnoise( $randomPosition + ( time * $randomMotionSpeed ) ) *\n    $maxDistance;\n");
		$runtimeExpr += ("vector $rampValues = "+$particlePath+".rampValues;\n");
		$runtimeExpr += ($particlePath+".curveOffset =\n    "+$particlePath+".curveOffset;\n");
		$runtimeExpr += ("vector $goalOffset = $rampValues + $curveOffset;\n");
		$runtimeExpr += ($particlePath+".goalOffset =\n");
		$runtimeExpr += ("    $rampValues + $curveOffset;\n");
		dynExpression -r -s $runtimeExpr $particlePath;
	}

	//
	// Create the emitter and connect the particle shape to it.
	//
	string $emitterPath;
	{
		if( $showOutput )
		{
			print ( (uiRes("m_flowAlongCurves.kCreateEmitter")) + "\n");
		}
		string $emitterNameArray[];
		$emitterNameArray = `emitter -pos 0 0 0 -rate $emitterRate -speed 0 -type omni -name ($setGroupName+"_emitter")`;
		string $emitterName = $emitterNameArray[0];
		$emitterPath = ("|"+$emitterName);
		setAttr ($emitterPath+".inheritsTransform") 0;
		connectDynamic -em $emitterPath $particlePath;
		$setArray[size($setArray)] = $emitterPath;
	}

	//
	// Create the array mapper to control the thickness of the
	// goal path.
	//
	string $arrayMapperName;
	string $distanceRampName;
	{
		string $arrayMapperNameArray[] = `arrayMapper -target $particlePath -destAttr maxDistance -inputV ageNormalized -type ramp`;
		$arrayMapperName = $arrayMapperNameArray[0];
		string $rampNameArray[] = `listConnections ($arrayMapperName+".computeNode")`;
		select $rampNameArray[0];
		rename ($setGroupName+"_distance");
		$rampNameArray = `ls -sl`;
		$distanceRampName = $rampNameArray[0];
	}

	//
	// Create the arrayMapper to control to shape of the
	// goal path.
	//
	string $positionRampName;
	{
		$arrayMapperNameArray = `arrayMapper -target $particlePath -destAttr rampValues -inputV ageNormalized -type ramp`;
		$arrayMapperName = $arrayMapperNameArray[0];
		$rampNameArray = `listConnections ($arrayMapperName+".computeNode")`;
		select $rampNameArray[0];
		rename ($setGroupName+"_position");
		$rampNameArray = `ls -sl`;
		$positionRampName = $rampNameArray[0];
	}

	string $goalLocatorPath = "";
	//
	// Create the goal locator and make it a goal of the particle shape
	//
	{
		string $goalLocatorName = ($setGroupName+"_goal");
		createPrimitive nullObject;
		$goalLocatorName = `rename $goalLocatorName`;
		$goalLocatorPath = ("|"+$goalLocatorName);
		setAttr ($goalLocatorPath+".inheritsTransform") 0;
		goal -g $goalLocatorPath -weight $goalWeight $particlePath;
		hide $goalLocatorPath;
	}

	//
	// Add the control attributes to the group
	//
	{
		if( $showOutput )
		{
			print ( (uiRes("m_flowAlongCurves.kAddControl")) + "\n" );
		}

		//
		// "displaySubsegments" turns on the display of the
		// locators controled by the "key" locators.  Turing this
		// on lets you see how compact the locators are along
		// the curve.
		//
		addAttr -ln "displaySubsegments" -at bool $setGroupPath;
		setAttr -keyable 1 ($setGroupPath+".displaySubsegments");
		setAttr ($setGroupPath+".displaySubsegments") 0;
	
		//
		// "editCircles" turns on the display of the
		// circles that define the thickness of the goal path.
		// This must be turned on in order to select the circles
		// for scaling.  While this is turned on, the selection
		// for the "key" locators is disables so that there is
		// not confusion as to which is being editted.
		//
		addAttr -ln "displayAllCircles" -at bool $setGroupPath;
		setAttr -keyable 1 ($setGroupPath+".displayAllCircles");
		setAttr ($setGroupPath+".displayAllCircles") 0;

		//
		// "displayThickness" turns on the display of the tube
		// that defines the thickness of the goal path.
		//
		addAttr -ln "displayThickness" -at bool $setGroupPath;
		setAttr -keyable 1 ($setGroupPath+".displayThickness");
		setAttr ($setGroupPath+".displayThickness") 0;
	
		//
		// The group's "lifespan" attribute is connected to the particle
		// object's "lifespan" attribute.  This is just to make the
		// attribute more accessible to the user by selecting the group.
		//
		addAttr -ln "lifespan" -min 0 $setGroupPath;  // still correct in 3.0 and later
		setAttr -keyable 1 ($setGroupPath+".lifespan");
		setAttr ($setGroupPath+".lifespan") $lifespan;
		connectAttr ($setGroupPath+".lifespan") ($particlePath+".lifespan");
		
		//
		// The group's "goalWeight" attribute is connected to the particle
		// object's "goalWeight[0]" attribute.  This is just to make the
		// attribute more accessible to the user by selecting the group.
		//
		addAttr -ln "goalWeight" -min 0 $setGroupPath;
		setAttr -keyable 1 ($setGroupPath+".goalWeight");
		setAttr ($setGroupPath+".goalWeight") $goalWeight;
		connectAttr ($setGroupPath+".goalWeight") ($particlePath+".goalWeight[0]");
		
		//
		// The group's "randomMotionSpeed" attribute is connected to the particle
		// object's "randomMotionSpeed" attribute.  This is just to make the
		// attribute more accessible to the user by selecting the group.
		//
		addAttr -ln "randomMotionSpeed" $setGroupPath;
		setAttr -keyable 1 ($setGroupPath+".randomMotionSpeed");
		setAttr ($setGroupPath+".randomMotionSpeed") $randomMotionSpeed;
		connectAttr ($setGroupPath+".randomMotionSpeed") ($particlePath+".randomMotionSpeed");
	
		//
		// The group's "emissionRate" attribute is connected to the emitter's
		// "rate" attribute.  This is just to make the attribute more
		// accessible to the user by selecting the group.
		//
		addAttr -ln "emissionRate" $setGroupPath;
		setAttr -keyable 1 ($setGroupPath+".emissionRate");
		setAttr ($setGroupPath+".emissionRate") $emitterRate;
		connectAttr ($setGroupPath+".emissionRate") ($emitterPath+".rate");

		//
		// "curveMin" and "curveMax" just show the values for
		// the curve's minValue and maxValue attributes.  This
		// helps the user place the control locators.  This can
		// not be done automatically after the script has been
		// run, since it would restrict the control that the
		// user has.
		//
		addAttr -ln "curveMin" $setGroupPath;
		setAttr -keyable 1 ($setGroupPath+".curveMin");
		connectAttr $curveStartStr ($setGroupPath+".curveMin");
		setAttr -lock 1 ($setGroupPath+".curveMin");

		addAttr -ln "curveMax" $setGroupPath;
		setAttr -keyable 1 ($setGroupPath+".curveMax");
		connectAttr $curveEndStr ($setGroupPath+".curveMax");
		setAttr -lock 1 ($setGroupPath+".curveMax");
	}

	//
	// The expression to control the parametric spacing of the locators
	// and circles will be stored in "paramExpression".
	//
	string $paramExpression = "";

	//
	// The expression to control the scaling of the circles will be
	// stored in "scaleExpression".
	//
	string $scaleExpression = "";
	
	//
	// Create the locators and circles along the goal path.
	// also set up the expressions needed to interpolate
	// the locators with the "key" locators.
	//
	{
		if( $showOutput )
		{
			print( (uiRes("m_flowAlongCurves.kCreateControlObj")) + "\n" );
		}

		//
		// There has to be at least one control segment and
		// 1 sub-segment.
		//
		$controlSegmentCount = max( $controlSegmentCount, 2 );
		$subSegmentCount = max( $subSegmentCount, 2 );
	
		int $controlLocatorCount = $controlSegmentCount + 1;
		int $totalSubLocatorCount = $controlSegmentCount * $subSegmentCount + 1;

		//
		// For each control segment, we create all of the sub-locators
		// and circles for that segment.
		//
		for( $i = 0; $i < $controlSegmentCount; $i ++ )
		{
			if( $showOutput )
			{
				print( (uiRes("m_flowAlongCurves.kCreateControlSeg")) + $i + "...\n" );
			}

			//
			// This loop creates all of the sub-segment objects as well
			// as the end "key" locators and circles for the segment.
			// If this is the first time through the loop, then we
			// also need to create the first "key" locator and circle
			// on the path.
			//
			if( $i == 0 )
			{
				string $locatorName = ($setGroupName+"_controlLocator_0");

				//
				// Create the first "key" locator.
				// The parametric location of the first "key" locator is
				// the "minValue" attribute value for the curve.
				//
				float $percent = 0.0;
				paramLocator ($curveName+".u["+$curveStart+"]");
				pickWalk -d up;
				$locatorName = `rename $locatorName`;
				$paramLocatorArray[size($paramLocatorArray)] = $locatorName;
				addAttr -ln ("locator_0_pos") -min 0 $setGroupName;
				setAttr -keyable true ($setGroupName+".locator_0_pos");
				connectAttr ($setGroupName+".locator_0_pos") ($locatorName+".localPositionX");
				setAttr ($setGroupName+".locator_0_pos") $curveStart;
	
				//
				// Create the first sub-locator.
				//
				int $subLocatorNumber = 0;
				string $subLocatorName = ($setGroupName+"_locator_0_0");
				createPrimitive nullObject;
				$subLocatorName = `rename $subLocatorName`;
				string $subLocatorPath = ("|"+$subLocatorName);
				scale 2 2 2;
				setAttr ($subLocatorPath+".inheritsTransform") 0;
				$controlLocatorArray[size($controlLocatorArray)] = $subLocatorPath;

				//
				// Attach to path group's selection handle to a point
				// near the first contol locator.
				//
				createPrimitive nullObject;
				rename "SelectionLocal";
				string $sl[] = `ls -sl`;
				string $localSelection = $sl[0];

				parent $localSelection $subLocatorName;
				$sl = `ls -sl`;
				string $localSelection = $sl[0];
				setAttr ($localSelection+".template") 1;
				setAttr ($localSelection+".visibility") 0;
				vector $randPos = sphrand(1);
				setAttr ($localSelection+".translate") -type double3 ($randPos.x) ($randPos.y) ($randPos.z);

				createPrimitive nullObject;
				rename "SelectionLocator";
				$sl = `ls -sl`;
				string $selectionLocator = $sl[0];
				setAttr ($selectionLocator+".template") 1;
				setAttr ($selectionLocator+".visibility") 0;
				setAttr ($selectionLocator+".inheritsTransform") 0;
				$controlLocatorArray[size($controlLocatorArray)] = $selectionLocator;

				select $localSelection $selectionLocator;
				pointConstraint -weight 1;
				setAttr ($setGroupPath+".displayHandle") 1;
				connectAttr ($selectionLocator+".translate") ($setGroupPath+".selectHandle");
				getAttr ($setGroupPath+".selectHandle");
	
				//
				// Create the pointOnCurveInfo node that will drive
				// position od this sub-locator, and connect it's
				// "position" attribute to the sub-locator's "translate"
				// attribute.
				//
				string $subPocName = ($setGroupName+"_POC_0_0");
				$subPocName = `createNode pointOnCurveInfo -name $subPocName`;
				connectAttr ($curveName+".worldSpace[0]") ($subPocName+".inputCurve");
				setAttr ($subPocName+".turnOnPercentage") 0;
				connectAttr ($subPocName+".position") ($subLocatorPath+".translate");

				//
				// If needed, attach the emitter to the first sub-locator's
				// position.
				//
				if( $attachEmitterToCurve == 1 )
				{
					connectAttr ($subLocatorPath+".translate") ($emitterPath+".translate");
				}

				string $cCircleName[] = `circle -c 0 0 0 -nr 0 0 1 -sw 360 -r 1 -d 3 -ut 0 -tol 0.01 -s 6 -ch 1 -name ("control_Circle_0")`;
				select $subLocatorPath $cCircleName[0];
				pointConstraint -weight 1;
				select $curveName $cCircleName[0];
				tangentConstraint -weight 1 -aimVector 0 0 1 -upVector 0 1 0 -worldUpVector 0 1 0;
				setAttr -keyable 0 ($cCircleName[0]+".tx");
				setAttr -keyable 0 ($cCircleName[0]+".ty");
				setAttr -keyable 0 ($cCircleName[0]+".tz");
				setAttr -keyable 0 ($cCircleName[0]+".rx");
				setAttr -keyable 0 ($cCircleName[0]+".ry");
				setAttr -keyable 0 ($cCircleName[0]+".rz");
				setAttr -keyable 0 ($cCircleName[0]+".sy");
				setAttr -keyable 0 ($cCircleName[0]+".sz");
				setAttr -keyable 0 ($cCircleName[0]+".visibility");
				setAttr -lock 1 ($cCircleName[0]+".visibility");
	
				//
				// Create the first circle and "attach" it to the curve
				// with point and tangent constraints.
				//
				string $circleName[] = `circle -c 0 0 0 -nr 0 0 1 -sw 360 -r 1 -d 3 -ut 0 -tol 0.01 -s 6 -ch 1 -name ($setGroupName+"_circle_0_0")`;
				select $subLocatorPath $circleName[0];
				pointConstraint -weight 1;
				select $curveName $circleName[0];
				tangentConstraint -weight 1 -aimVector 0 0 1 -upVector 0 1 0 -worldUpVector 0 1 0;
				$controlCircleArray[size($controlCircleArray)] = $circleName[0];
				$scalableCircleArray[size($scalableCircleArray)] = $cCircleName[0];
				$circleArray[size($circleArray)] = $circleName[0];
		
				float $percent = 0.0;
				//
				// Add the expression lines that keep this sub-locator in the
				// same place as the first "key' locator.
				//
				$paramExpression += ($subPocName+".parameter =\n");
				$paramExpression += ("    "+($locatorName+".localPositionX")+";\n\n");
	
				//
				// Add the expression lines to keep this circle scaled uniformly.
				//
				if( 1 )
				{
					$scaleExpression += ($circleName[0]+".scaleX =\n");
					$scaleExpression += ("    "+$cCircleName[0]+".scaleX;\n\n");
					$scaleExpression += ($cCircleName[0]+".scaleY =\n    "+$cCircleName[0]+".scaleZ =\n    "+$cCircleName[0]+".scaleX;\n");
					$scaleExpression += ($circleName[0]+".scaleY =\n    "+$circleName[0]+".scaleZ =\n    "+$circleName[0]+".scaleX;\n");
				}
				else
				{
					connectAttr ($cCircleName[0]+".scaleX") ($circleName[0]+".scaleX");
					connectAttr ($cCircleName[0]+".scaleX") ($cCircleName[0]+".scaleY");
					connectAttr ($cCircleName[0]+".scaleX") ($cCircleName[0]+".scaleZ");
					connectAttr ($circleName[0]+".scaleX") ($circleName[0]+".scaleY");
					connectAttr ($circleName[0]+".scaleX") ($circleName[0]+".scaleZ");
				}
	
				//
				// Add an entry into the distance ramp for the parametric
				// location of this sub-locator and the scale value of this
				// circle.  This is what defines the thickness of the goal
				// path.
				//
				setAttr ($distanceRampName+".colorEntryList["+$subLocatorNumber+"].position") $percent;
				setAttr -lock 1 ($distanceRampName+".colorEntryList["+$subLocatorNumber+"].position");
				connectAttr ($circleName[0]+".scaleX") ($distanceRampName+".colorEntryList["+$subLocatorNumber+"].colorR");
	
				//
				// Add an entry into the position ramp for the parametric
				// location of this sub-locator and the translate of the
				// sub-locator.  This defines the shape of the goal path.
				//
				setAttr ($positionRampName+".colorEntryList["+$subLocatorNumber+"].position") $percent;
				setAttr -lock 1 ($positionRampName+".colorEntryList["+$subLocatorNumber+"].position");
				connectAttr ($subLocatorPath+".translate") ($positionRampName+".colorEntryList["+$subLocatorNumber+"].color");
			}
	
			int $controlLocatorNumber = $i + 1;
	
			string $locatorName = ($setGroupName+"_controlLocator_"+$controlLocatorNumber);
			string $previousPocName = ($setGroupName+"_controlLocator_"+$i);
			string $PocName = ($setGroupName+"_controlLocator_"+$controlLocatorNumber);
	
			//
			// Create the current "key" locator.
			//
			float $endPercent = (float)$controlLocatorNumber/(float)($controlSegmentCount);
			paramLocator ($curveName+".u["+($curveStart + $endPercent*$curveRange)+"]");
			pickWalk -d up;
			$PocName = `rename $PocName`;
			$paramLocatorArray[size($paramLocatorArray)] = $PocName;
			addAttr -ln ("locator_"+($controlLocatorNumber)+"_pos") -min 0 $setGroupName;
			setAttr -keyable true ($setGroupName+".locator_"+($controlLocatorNumber)+"_pos");
			connectAttr ($setGroupName+".locator_"+($controlLocatorNumber)+"_pos") ($locatorName+".localPositionX");
			setAttr ($setGroupName+".locator_"+($controlLocatorNumber)+"_pos") ($curveStart + $endPercent * $curveRange);
	
			string $startValStr = ($previousPocName+".localPositionX");
			string $endValStr = ($PocName+".localPositionX");
	
			string $cCircleName[] = `circle -c 0 0 0 -nr 0 0 1 -sw 360 -r 1 -d 3 -ut 0 -tol 0.01 -s 6 -ch 1 -name ("control_Circle_"+$controlLocatorNumber)`;
			string $previousCCircleName = ("control_Circle_"+$i);
			string $startScaleStr = ("|"+$previousCCircleName+".scaleX");
			string $endScaleStr = ($cCircleName[0]+".scaleX");

			if( 1 )
			{
				$scaleExpression += ($cCircleName[0]+".scaleY =\n    "+$cCircleName[0]+".scaleZ =\n    "+$cCircleName[0]+".scaleX;\n");
			}
			else
			{
				connectAttr ($cCircleName[0]+".scaleX") ($cCircleName[0]+".scaleY");
				connectAttr ($cCircleName[0]+".scaleX") ($cCircleName[0]+".scaleZ");
			}

			//
			// Create all of the sub-locators between the current and
			// previous "key" locators.  Create all of the circles
			// in between as well
			//
			int $j;
			for( $j = 1; $j <= $subSegmentCount; $j ++ )
			{
				int $subLocatorNumber = ( $i * $subSegmentCount ) + $j;
				string $subLocatorName = ($setGroupName+"_locator_"+$i+"_"+$j);
				createPrimitive nullObject;
				$subLocatorName = `rename $subLocatorName`;
				string $subLocatorPath = ("|"+$subLocatorName);
	
				string $circleName[] = `circle -c 0 0 0 -nr 0 0 1 -sw 360 -r 1 -d 3 -ut 0 -tol 0.01 -s 6 -ch 1 -name ($setGroupName+"_circle_"+$i+"_"+$j)`;
				select $subLocatorPath $circleName[0];
				pointConstraint -weight 1;
				select $curveName $circleName[0];
				tangentConstraint -weight 1 -aimVector 0 0 1 -upVector 0 1 0 -worldUpVector 0 1 0;

				//
				// For each locator, if it is the last locator in this
				// segment, then make it bigger.  These larger ones
				// indicate where the user can select to edit the
				// locations of the "key" locators.  If it is not the
				// last locator, then scale it down a little.
				//
				if( $j == $subSegmentCount )
				{
					select $subLocatorPath $cCircleName[0];
					pointConstraint -weight 1;
					select $curveName $cCircleName[0];
					tangentConstraint -weight 1 -aimVector 0 0 1 -upVector 0 1 0 -worldUpVector 0 1 0;
					setAttr -keyable 0 ($cCircleName[0]+".tx");
					setAttr -keyable 0 ($cCircleName[0]+".ty");
					setAttr -keyable 0 ($cCircleName[0]+".tz");
					setAttr -keyable 0 ($cCircleName[0]+".rx");
					setAttr -keyable 0 ($cCircleName[0]+".ry");
					setAttr -keyable 0 ($cCircleName[0]+".rz");
					setAttr -keyable 0 ($cCircleName[0]+".sy");
					setAttr -keyable 0 ($cCircleName[0]+".sz");
					setAttr -keyable 0 ($cCircleName[0]+".visibility");
					setAttr -lock 1 ($cCircleName[0]+".visibility");

					select $subLocatorPath;
					scale 2 2 2;
					$controlLocatorArray[size($controlLocatorArray)] = $subLocatorPath;
					$controlCircleArray[size($controlCircleArray)] = $circleName[0];
					$scalableCircleArray[size($scalableCircleArray)] = $cCircleName[0];
					$circleArray[size($circleArray)] = $circleName[0];
				}
				else
				{
					select $subLocatorPath;
					scale .5 .5 .5;
					$subLocatorArray[size($subLocatorArray)] = $subLocatorPath;
					$subCircleArray[size($subCircleArray)] = $circleName[0];
					$circleArray[size($circleArray)] = $circleName[0];
				}

				//
				// Create the pointOnCurveInfo node that will use the
				// parametric locations of the "key" locators and set
				// the location of this sub-locator.
				//
				string $subPocName = ($setGroupName+"_controlLocator_"+$i+"_"+$j);
				$subPocName = `createNode pointOnCurveInfo -name $subPocName`;
				connectAttr ($curveName+".worldSpace[0]") ($subPocName+".inputCurve");
				setAttr ($subPocName+".turnOnPercentage") 0;
		
				float $percent = (float)($j)/(float)($subSegmentCount);
	
				$paramExpression += ($subPocName+".parameter =\n");
				$paramExpression += ("    "+$startValStr+" +\n");
				$paramExpression += ("    "+$percent+" * ( "+$endValStr+" -\n");
				$paramExpression += ("      "+$startValStr+" );\n\n");
		
				$scaleExpression += ($circleName[0]+".scaleX =\n");
				$scaleExpression += ("    "+$startScaleStr+" +\n");
				$scaleExpression += ("    "+$percent+" * ( "+$endScaleStr+" -\n");
				$scaleExpression += ("      "+$startScaleStr+" );\n\n");
				if( 1 )
				{
					$scaleExpression += ($circleName[0]+".scaleY =\n    "+$circleName[0]+".scaleZ =\n    "+$circleName[0]+".scaleX;\n");
				}
				else
				{
					connectAttr ($circleName[0]+".scaleX") ($circleName[0]+".scaleY");
					connectAttr ($circleName[0]+".scaleX") ($circleName[0]+".scaleZ");
				}
	
				connectAttr ($subPocName+".position") ($subLocatorPath+".translate");
	
				$percent = (float)$subLocatorNumber/(float)($totalSubLocatorCount - 1);
	
				setAttr ($distanceRampName+".colorEntryList["+$subLocatorNumber+"].position") $percent;
				setAttr -lock 1 ($distanceRampName+".colorEntryList["+$subLocatorNumber+"].position");
				connectAttr ($circleName[0]+".scaleX") ($distanceRampName+".colorEntryList["+$subLocatorNumber+"].colorR");
	
				setAttr ($positionRampName+".colorEntryList["+$subLocatorNumber+"].position") $percent;
				setAttr -lock 1 ($positionRampName+".colorEntryList["+$subLocatorNumber+"].position");
				connectAttr ($subLocatorPath+".translate") ($positionRampName+".colorEntryList["+$subLocatorNumber+"].color");
				setAttr ($subLocatorPath+".inheritsTransform") 0;
			}
		}
	}

	//
	// Execute the expression command for the interpolating and the scaling
	// expressions.
	//
	if( $showOutput )
	{
		print ( (uiRes("m_flowAlongCurves.kCompilingParamExp")) );
	}
	expression -ae 0 -s $paramExpression -name ($setGroupName+"_parameterExpression");
	if( $showOutput )
	{
		print("\n");
	}

	if( $showOutput )
	{
		print ( (uiRes("m_flowAlongCurves.kCompilingScaleExp")) );
	}
	expression -ae 0 -s $scaleExpression -name ($setGroupName+"_scaleExpression");
	if( $showOutput )
	{
		print("\n");
	}


	if( $showOutput )
	{
		print ( (uiRes("m_flowAlongCurves.kCreateGoalVol")) + "\n" );
	}
	//
	// Loft a surface through all of the circles.  This surface represents
	// the thickness of the goal path.
	//
	select $circleArray;
	string $loftName[] = `loft -ch 1 -u 1 -c 0 -ar 1 -d 1 -rn 0 -po 0 -name ($setGroupName+"_distanceShell")`;
	setAttr ($loftName[0]+".template") 1;
	connectAttr ($setGroupPath+".displayThickness") ($loftName[0]+".visibility");

	if( $showOutput )
	{
		print ( (uiRes("m_flowAlongCurves.kGroupAllObj")) + "\n" );
	}
	//
	// Group all of the circles together
	//
	select $scalableCircleArray;
	string $scalableCircleGroupName = `group -name ($setGroupName+"_scalableCircles")`;
	$scalableCircleGroupName = ("|"+$scalableCircleGroupName);
	setAttr -lock 1 ($scalableCircleGroupName+".scale");

	select $controlCircleArray;
	string $controlCircleGroupName = `group -name ($setGroupName+"_controlCircles")`;
	$controlCircleGroupName = ("|"+$controlCircleGroupName);
	setAttr -lock 1 ($controlCircleGroupName+".scale");

	select $subCircleArray;
	string $subCircleGroupName = `group -name ($setGroupName+"_subCircles")`;
	$subCircleGroupName = ("|"+$subCircleGroupName);
	connectAttr ($setGroupPath+".displayAllCircles") ($subCircleGroupName+".visibility");
	setAttr -lock 1 ($subCircleGroupName+".scale");

	select $controlCircleGroupName $subCircleGroupName;
	string $circleGroupName = `group -name ($setGroupName+"_circles")`;
	$circleGroupName = ("|"+$circleGroupName);
	setAttr -lock 1 ($circleGroupName+".scale");
	setAttr ($circleGroupName+".template") 1;

	select $circleGroupName $scalableCircleGroupName;
	string $circlesName = `group -name "Circles"`;
	string $sl[] = `ls -sl`;
	$circlesName = $sl[0];

	//
	// Group all of the locators together
	//
	select $controlLocatorArray;
	string $controlLocatorGroupName = `group -name ($setGroupName+"_controlLocators")`;
	$controlLocatorGroupName = ("|"+$controlLocatorGroupName);

	select $subLocatorArray;
	string $subLocatorGroupName = `group -name ($setGroupName+"_subLocators")`;
	$subLocatorGroupName = ("|"+$subLocatorGroupName);
	connectAttr ($setGroupPath+".displaySubsegments") ($subLocatorGroupName+".visibility");

	select $controlLocatorGroupName $subLocatorGroupName;
	string $locatorGroupName = `group -name ($setGroupName+"_locators")`;
	$locatorGroupName = ("|"+$locatorGroupName);
	setAttr ($locatorGroupName+".template") 1;

	select $locatorGroupName $goalLocatorPath;
	string $locatorsName = `group -name "Locators"`;
	$sl = `ls -sl`;
	$locatorsName = $sl[0];

	select $curveName $loftName[0] $locatorsName $circlesName;
	string $controlObjects = `group -name "ControlObjects"`;
	$sl = `ls -sl`;
	$setArray[size($setArray)] = $sl[0];

	//
	// Parent all of the created objects under the main group.
	//
	select $setArray;
	parent $setArray $setGroupPath;
	select $setGroupPath;
	setAttr ($setGroupPath+".inheritsTransform") 0;

	getAttr ($setGroupPath+".selectHandle");

	if( $showOutput )
	{
		print ( (uiRes("m_flowAlongCurves.kDone")) + "\n" );
		print("//\n");
	}

	//
	// Return the name of the main group created
	//
	string $finalSelectionList[] = `ls -sl`;
	return $finalSelectionList[0];
}

global proc string[] flowAlongCurves( string $setName, int $controlSegmentCount, int $subSegmentCount, int $attachEmitterToCurve, float $emitterRate, float $randomMotionSpeed, float $lifespan, float $goalWeight )    // CAROL 5 4 1 20 .5 5 .5 //
//
// Description:
//
//    This procedure takes the selection list and filters out all of the
// nurbsCurve typed objects.  For each selected curve, it then calls the
// flowAlongCurve() procedure, passing along the other arguments to it.
// If any of the selected curves are curve-on-surfaces, then the
// "duplicateCurve" command is used to create a curve in the world,
// and then the effect is run on the new curve.  Since the original
// curve is still a part of the new curve's history, any changes to
// it will be reflected in the new curve.
//
//    The return value for this procedure is a list of the newly
// created groups that contain the objects used for the effect.
//
{
	//
	// "resultArray" keeps a list of the new groups created.
	// "curveArray" will get filled with all of the currently
	// selected curves.
	//
	string $resultArray[];
	clear($resultArray);
	string $curveArray[];
	clear($curveArray);

	if( `licenseCheck -type complete` == 0 )
	{
		warning((uiRes("m_flowAlongCurves.kNoFlowLicense")));
		return $resultArray;
	}

	$setName = removeAllWhiteSpace( $setName );

	//
	// Save the selection list
	//
	string $currentSelection[] = `ls -sl`;

	//
	// First get the selected curves
	//
	{
		$curveArray = getSelectedList( "allCurves" );
	
		if( size($curveArray) == 0 )
		{
			warning((uiRes("m_flowAlongCurves.kNoCurves")));
			return( $resultArray );
		}
	}

	//
	// For each curve, if it is a curve-on-surface, then
	// use the "duplicateCurve" command to create a curve
	// that is not in the underworld.  Then use this new
	// curve for the effect.  The "duplicateCurve"
	// command puts the original curve in the history
	// for the new curve, so changes to the original will
	// still be reflected i nthe new curve.
	//
	{
		if( size($setName) == 0 )
		{
			$setName = "Flow";
		}

		int $i;
		for( $i = 0; $i < size($curveArray); $i ++ )
		{
			string $newCurve = "";
			if( isObjectInUnderWorld( $curveArray[$i] ) == 1 )
			{
				string $duplicateCurve[] = `duplicateCurve -ch 1 -rn 0 -local 0 -name ($setName+"_FlowCurve") $curveArray[$i]`;
				$newCurve = $duplicateCurve[0];
			}
			else
			{
				string $duplicateCurve = superDuplicateCurve( $curveArray[$i] );
				if( $duplicateCurve == "" )
				{
					continue;
				}
				$newCurve = $duplicateCurve;
			}

			$curveArray[$i] = $newCurve;
			setAttr ($newCurve+".template") 1;
			setAttr ($newCurve+".visibility") 0;
		}
	}

	$controlSegmentCount = max( $controlSegmentCount, 2 );
	$subSegmentCount = max( $subSegmentCount, 2 );

	//
	// For each curve, create the other objects
	//
	{
		int $i;
		for( $i = 0; $i < size($curveArray); $i ++ )
		{
			int $intermediate = isObjectIntermediate( $curveArray[$i] );
			if( $intermediate == 1 )
			{
				string $warnFmt = (uiRes("m_flowAlongCurves.kIntermediate"));
				warning(`format -s $curveArray[$i] $warnFmt`);
				continue;
			}
			string $flowSet = flowAlongCurve( $setName, $curveArray[$i], $controlSegmentCount, $subSegmentCount, $attachEmitterToCurve, $emitterRate, $randomMotionSpeed, $lifespan, $goalWeight );
			$resultArray[size($resultArray)] = $flowSet;
		}
	}

	//
	// Set the selection to be the groups that were created for each curve.
	//
	select $resultArray;

	return( $resultArray );
}


