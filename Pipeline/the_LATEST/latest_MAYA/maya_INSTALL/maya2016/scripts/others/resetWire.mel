// Copyright (C) 1997-2014 Autodesk, Inc., and/or its licensors.
// All rights reserved.
//
// The coded instructions, statements, computer programs, and/or related
// material (collectively the "Data") in these files contain unpublished
// information proprietary to Autodesk, Inc. ("Autodesk") and/or its licensors,
// which is protected by U.S. and Canadian federal copyright law and by
// international treaties.
//
// The Data is provided for use exclusively by You. You have the right to use,
// modify, and incorporate this Data into other products for purposes authorized 
// by the Autodesk software license agreement, without fee.
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND. AUTODESK
// DOES NOT MAKE AND HEREBY DISCLAIMS ANY EXPRESS OR IMPLIED WARRANTIES
// INCLUDING, BUT NOT LIMITED TO, THE WARRANTIES OF NON-INFRINGEMENT,
// MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE, OR ARISING FROM A COURSE 
// OF DEALING, USAGE, OR TRADE PRACTICE. IN NO EVENT WILL AUTODESK AND/OR ITS
// LICENSORS BE LIABLE FOR ANY LOST REVENUES, DATA, OR PROFITS, OR SPECIAL,
// DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES, EVEN IF AUTODESK AND/OR ITS
// LICENSORS HAS BEEN ADVISED OF THE POSSIBILITY OR PROBABILITY OF SUCH DAMAGES.

global proc resetWire()
{
	// There should be two selections: first the wire, 2nd the base wire
	//
	string $sel[] = `ls -sl`;
	if (size($sel)!=2) 
		return;

	// If there is history on the wire, we won't reset it.
	//
	string $hist[] = `listHistory $sel[0]`;
	if (size($hist) > 1) {
		// first check for the case where only an intermediate object
		// is in the history
		//
		if ((size($hist) == 2) &&
			(nodeType($hist[0]) == nodeType($hist[1]))) {
			delete -ch $sel[0];
		} else {
			string $intHist[] = `listHistory -pdo 1 -il 1`;
			string $node;
			print((uiRes("m_resetWire.kNodesInHistory")));
			for ($node in $intHist) {
				string $msg = ("//     "+$node+ "\n" );
				print($msg);
			}
			select -r $sel[0];
			error((uiRes("m_resetWire.kConstructionHistory")));
			return;
		}
	}
	
	int $sp = `getAttr ($sel[1]+ ".spans")`;
	int $deg = `getAttr ($sel[1]+ ".degree")`;
	int $numcv= $sp +$deg;

	float $v[3];

	for ($i=0;$i<$numcv;$i++)
	{
		$v= `xform -q -t ($sel[1]+ ".cv["+$i+"]")`;
		$attr= $sel[0] + ".cp[" + $i + "].";
		$attr2= $attr+"xv";
		setAttr $attr2 $v[0];
		$attr2= $attr+"yv";
		setAttr $attr2 $v[1];
		$attr2= $attr+"zv";
		setAttr $attr2 $v[2];

	}

	//
	// Move the wire to the base wire position.  First parent 
	// the wire under the base transform, then copy the transform attributes
	// and finally put the wire back under its original parent. 
	//
	
	// First check if the two curves have the same parent
	//
	string $par0L[] = `listRelatives -parent $sel[0]`;
	string $par1L[] = `listRelatives -parent $sel[1]`;

	int $sameParent = false;
	if (size($par0L) == 0 && size($par1L) == 0)
		$sameParent = true;
	if (size($par0L) == 1 && size($par1L) == 1 && $par0L[0] == $par1L[0])
		$sameParent = true;

	if (!$sameParent)
	{
		// Reparent wire under the base wire's parent
		//
		if (size($par1L) == 1)
		{
			parent $sel[0] $par1L[0];
		}
		else
		{
			parent -w $sel[0];
		}
	}

	// Copy the transform attributes
	//
	float $t[3] = `getAttr ($sel[1]+".t")`;
	float $r[3] = `getAttr ($sel[1]+".r")`;
	float $s[3] = `getAttr ($sel[1]+".s")`;

	setAttr ($sel[0]+".t") -type "float3" $t[0] $t[1] $t[2];
	setAttr ($sel[0]+".r") -type "float3" $r[0] $r[1] $r[2];
	setAttr ($sel[0]+".s") -type "float3" $s[0] $s[1] $s[2];
	
	if (!$sameParent)
	{
		// Put the wire back under its original parent
		//
		if (size($par0L) == 1)
		{
			parent $sel[0] $par0L[0];
		}
		else
		{
			parent -w $sel[0];
		}
	}
}
