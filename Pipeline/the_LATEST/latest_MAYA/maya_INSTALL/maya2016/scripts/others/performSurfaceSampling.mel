// Copyright (C) 1997-2014 Autodesk, Inc., and/or its licensors.
// All rights reserved.
//
// The coded instructions, statements, computer programs, and/or related
// material (collectively the "Data") in these files contain unpublished
// information proprietary to Autodesk, Inc. ("Autodesk") and/or its licensors,
// which is protected by U.S. and Canadian federal copyright law and by
// international treaties.
//
// The Data is provided for use exclusively by You. You have the right to use,
// modify, and incorporate this Data into other products for purposes authorized 
// by the Autodesk software license agreement, without fee.
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND. AUTODESK
// DOES NOT MAKE AND HEREBY DISCLAIMS ANY EXPRESS OR IMPLIED WARRANTIES
// INCLUDING, BUT NOT LIMITED TO, THE WARRANTIES OF NON-INFRINGEMENT,
// MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE, OR ARISING FROM A COURSE 
// OF DEALING, USAGE, OR TRADE PRACTICE. IN NO EVENT WILL AUTODESK AND/OR ITS
// LICENSORS BE LIABLE FOR ANY LOST REVENUES, DATA, OR PROFITS, OR SPECIAL,
// DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES, EVEN IF AUTODESK AND/OR ITS
// LICENSORS HAS BEEN ADVISED OF THE POSSIBILITY OR PROBABILITY OF SUCH DAMAGES.

//
//  Procedure Name:
//      performSurfaceSampling
//
//  Description:
//	  Dialog and commands to bake a surface information map.
//
//  Input Arguments:
//	  bool    0 - execute a bake 
//              1 - display bake options
//  Return Value:
//      None.
//

global string $surfaceSamplingTargetList[];
global int $surfaceSamplingTargetListSize = 0;
global int $surfaceSamplingTargetNumElements = 1; 
global string $surfaceSamplingSourceList[];
global int $surfaceSamplingSourceListSize = 0;
global int $surfaceSamplingSourceNumElements = 1;
global int $surfaceSamplingNumOutputMaps = 6; 
global float $surfaceSamplingAspectRatio[];
global string $surfaceSamplingDefaultMapName[] = { "sampledNormals", "sampledDisplacement", "sampledDiffuseColor", "sampledColor", "sampledAlpha", "sampledOcculsion", "sampledCustom" };
global string $envelopeAssociationAttribute = "surfaceSamplingEnvelope";
global string $surfaceSamplingMiOptionsNode = "surfaceSamplingMiOptionsNode";
global int $surfaceSamplingMrAcceleration = 0;
global int $surfaceSamplingMrLensBakingItem = 2;

// This next bit can be quite confusing. We reserve the first two entries in the
// output map array to represent the common/shared settings for Maya-based and
// mental Ray-based maps respectively. The first REAL output map sits in slot 2.
// This was done to allow the setup code to just redirect settings that might be
// common to either the map or the common settings using a single variable.
//
global int $surfaceSamplingMayaCommonSettingsIndex = 0;
global int $surfaceSamplingMentalCommonSettingsIndex = 1;
global int $surfaceSamplingFirstOutputMap = 2;
global int $surfaceSamplingOutputArraySize = 2;

global int $surfaceSamplingNormalType = 0;
global int $surfaceSamplingDisplacementType = 1;
global int $surfaceSamplingDiffuseColorType = 2;
global int $surfaceSamplingLitAndShadeColorType = 3;
global int $surfaceSamplingAlphaType = 4;
global int $surfaceSamplingAmbientOcclusionType = 5;
global int $surfaceSamplingCustomType = 6;
global int $surfaceSamplingNumMapTypes = 7;

global string $surfaceSamplingMapTypeNames[];

proc setMapTypeStrings()
{
	global string $surfaceSamplingMapTypeNames[];

	// Build type name strings, cant do this at init time...
	$surfaceSamplingMapTypeNames[0] = (uiRes("m_performSurfaceSampling.kNormalMap")) ;
	$surfaceSamplingMapTypeNames[1] = (uiRes("m_performSurfaceSampling.kDisplacementMap")) ;
	$surfaceSamplingMapTypeNames[2] = (uiRes("m_performSurfaceSampling.kDiffuseColorMap")) ; 
	$surfaceSamplingMapTypeNames[3] = (uiRes("m_performSurfaceSampling.kLitandShadeColorMap")) ;
	$surfaceSamplingMapTypeNames[4] = (uiRes("m_performSurfaceSampling.kAlphaMap")) ;
	$surfaceSamplingMapTypeNames[5] = (uiRes("m_performSurfaceSampling.kAmbientOcclusionMap"));
	$surfaceSamplingMapTypeNames[6] = (uiRes("m_performSurfaceSampling.kCustomMap"));
}

proc deleteMapOptionVars( int $index )
//
// Description: deletes all the option vars for the given map.
//
{
	optionVar -remove ("surfaceSamplingMapWidthOption" + (string)$index);
	optionVar -remove ("surfaceSamplingMapHeightOption" + (string)$index);
	optionVar -remove ("surfaceSamplingLockAspectRatioOption" + (string)$index);
	optionVar -remove ("surfaceSamplingPostBakeOption" + (string)$index);

	optionVar -remove ("surfaceSamplingEnableMapOption" + (string)$index) ; 
	optionVar -remove ("surfaceSamplingMaxValueOption" + (string)$index) ;
	optionVar -remove ("surfaceSamplingMapSpaceOption" + (string)$index) ;
	optionVar -remove ("surfaceSamplingMapMaterialsOption" + (string)$index) ;
	optionVar -remove ("surfaceSamplingIncludeShadowsOption" + (string)$index) ;
	optionVar -remove ("surfaceSamplingFileNameOption" + (string)$index) ;
	optionVar -remove ("surfaceSamplingExtensionOption" + (string)$index);
	optionVar -remove ("surfaceSamplingMentalBitsPerChannel" + (string)$index);
	optionVar -remove ("surfaceSamplingMentalOptimOption" + (string)$index);
	optionVar -remove ("surfaceSamplingUseCommonOutputSettingsField" + (string)$index) ;
	optionVar -remove ("surfaceSamplingType" + (string)$index) ;
	optionVar -remove ("surfaceSamplingCustomShaderName" + (string)$index);
	optionVar -remove ("surfaceSamplingOrthReflectionOption" + (string)$index) ;
	optionVar -remove ("surfaceSamplingCameraName" + (string)$index);
	optionVar -remove ("surfaceSamplingOcclusionFalloff" + (string)$index);
	optionVar -remove ("surfaceSamplingOcclusionRays" + (string)$index);
}


proc surfaceSamplingAdjustSizeSlider(string  $whichSlider, int $makePowerTwoFlag, int $i)
//Discription
//			This adjusts the x resolution and y resolution when the aspect 
//			ratio check box is toggled on
//
{
	global float $surfaceSamplingAspectRatio[];
	
	int $value = `checkBoxGrp -q -v1 ("surfaceSamplingAspectRatioChkBox" + (string)$i)`;
	if ( $value ) {
		if ( $whichSlider == "x" ) {
			int $valX = eval("intSliderGrp -q -value surfaceSamplingWidthField" + (string)$i);
			int $tempVal = $valX/$surfaceSamplingAspectRatio[$i];
			int $newVal = $tempVal;
			if($makePowerTwoFlag){
				$newVal = surfaceSamplingMakePowerOfTwo($tempVal);
			}
			intSliderGrp -e -v $newVal ("surfaceSamplingHeightField" + (string)$i);
		} else {
			int $valY = eval("intSliderGrp -q -value surfaceSamplingHeightField" + (string)$i);
			int $tempVal = $valY*$surfaceSamplingAspectRatio[$i];
			int $newVal = $tempVal;
			if($makePowerTwoFlag){
				$newVal = surfaceSamplingMakePowerOfTwo($tempVal);
			}
			intSliderGrp -e -v $newVal ("surfaceSamplingWidthField" + (string)$i);
		}
	}
}


global proc int surfaceSamplingMakePowerOfTwo(int $sz)
//Discription
//			This adjusts the movment of Size X and Size Y slider to the values of
//			power of 2.
//
{
	int $prevSize = 0, $nextSize = 1;
	while ($nextSize < $sz ){
	   $prevSize = $nextSize;
	   $nextSize = $nextSize * 2;
	}
	
	int $newSize;
	
	if(($sz - $prevSize) < ($nextSize - $sz)){
			$newSize = $prevSize;
	}else{
		$newSize = $nextSize;
	}
	return $newSize;
	
}

global proc surfaceSamplingChangeXResolutionDragCmd(int $sz, int $i)
//Discription
//			This gets exected when the slider is moved with the left
//			mouse button. This is callback command
//

{
	int $newSize = surfaceSamplingMakePowerOfTwo($sz) ;
	intSliderGrp -e -value $newSize ("surfaceSamplingWidthField" + (string)$i) ;
	surfaceSamplingAdjustSizeSlider("x", 1, $i);
}

global proc surfaceSamplingChangeXResolutionChCmd(int $sz, int $i)
//Discription
//			This gets exected when the slider is moved with the left
//			mouse button. This is callback command
//

{
	surfaceSamplingAdjustSizeSlider("x", 0, $i);
}


global proc surfaceSamplingChangeYResolutionDragCmd(int $sz, int $i)
//Discription
//			This gets exected when the slider is moved with the left
//			mouse button. This is callback command
//
{
	int $newSize = surfaceSamplingMakePowerOfTwo($sz);
	intSliderGrp -e -value $newSize ("surfaceSamplingHeightField" + (string)$i);
	surfaceSamplingAdjustSizeSlider("y", 1, $i);
}

global proc surfaceSamplingChangeYResolutionChCmd(int $sz, int $i)
//Discription
//			This gets exected when the slider is moved with the left
//			mouse button. This is callback command
//
{
	surfaceSamplingAdjustSizeSlider("y", 0, $i);
}


global proc surfaceSamplingLockAspectRatioCmd(int $aspect, int $i)
//Discription
//			Calcuates the aspect ratio and maintains
//			it with respect to x and y resolution
//
{
	global string $surfaceSamplingResX, $surfaceSamplingResY;
	global float $surfaceSamplingAspectRatio[];
		
	if($aspect){
		float $sizeX = `intSliderGrp -q -value ("surfaceSamplingWidthField" + (string)$i)`;
		float $sizeY = `intSliderGrp -q -value ("surfaceSamplingHeightField" + (string)$i)`;

		$surfaceSamplingAspectRatio[ $i] = $sizeX / $sizeY;
	}
}


global proc string surfaceSamplingGetCage( int $target, int $createIfMissing)
//
// Description:
//   Tries to find the search depth Envelope for a given surface
//   and optionally creates it if missing
//
{
	global string $envelopeAssociationAttribute;
	global string $surfaceSamplingTargetList[];
	global int $surfaceSamplingTargetNumElements;
	string $path = $surfaceSamplingTargetList[ $target * $surfaceSamplingTargetNumElements];

	// Check this path still exists
	//
	if( size( `ls $path`) == 0) return "";
		
	// See if there's a Envelope attached to this surface
	// already
	//
	string $connections[] = `listConnections -plugs true ($path + ".message")`;
	for( $connection in $connections)
		if( endsWith( $connection, "." + $envelopeAssociationAttribute) )
			return substring( $connection, 1, size( $connection) - size( $envelopeAssociationAttribute) - 1 );

	// If not, and we're not supposed to create one, we're done
	//
	if( $createIfMissing == false )
		return "";
			
	// Create a new Envelope
	//
	string $Envelope = $path + "Envelope";
	string $ls[] = `ls -sl -o`;	
	string $Envelopes[] = `duplicate -name $Envelope $path`;
	string $envelopeShapes[] = `listRelatives -path -shapes $Envelopes[0]`;
	
	// Connect it to the shape so we can identify it as a Envelope
	//
	addAttr -longName $envelopeAssociationAttribute -at message $envelopeShapes[0];
	connectAttr ($path + ".message") ($envelopeShapes[0] + "."  + $envelopeAssociationAttribute);
	
	// Create the Envelope shader if it doesn't exist already
	//
	string $EnvelopeShader = "surfaceSamplingEnvelopeShader";
	string $EnvelopeShadingGroup = $EnvelopeShader + "SG";
	if( size( `ls $EnvelopeShadingGroup` ) == 0 )
	{
		string $shader = `shadingNode -asShader lambert -name $EnvelopeShader`;
		setAttr ($shader + ".color") 1.0 0.5 0.5;
		setAttr ($shader + ".transparency") 0.25 0.25 0.25;
		string $group = `sets -renderable true -noSurfaceShader true -empty -name ($EnvelopeShader + "SG")`;
		connectAttr -f ($shader + ".outColor") ($group + ".surfaceShader");
	}
	
	// Make it single sided
	//
	//setAttr ($Envelopes[0] + ".doubleSided") 0;

	// Throw the Envelope shader on the new Envelope
	//
	sets -e -forceElement $EnvelopeShadingGroup $Envelopes[0];
	
	// Now throw a face extrude on the Envelope 
	//
	float $offset = `floatSliderGrp -q -value ("surfaceSamplingSearchOffsetSlider" + (string)$target)`;	
	$offset *= surfaceSamplingBoundingRadius( $path ) * 0.01;
	string $modifier[] = `polyMoveFacet -ch 1 -localTranslateZ $offset $Envelopes[0]`;
	
	// Make sure our offset is in local space (setting this
	// at create time doesn't always do the trick)
	//
	polyMoveFacet -e -worldSpace off $modifier[0];

	// Parent it under the original transform (so it moves with it)
	//
	string $transform = `firstParentOf $path`;
	$Envelopes = `parent -s $Envelopes[0] $transform`;
	
	select $ls;
	return $Envelopes[0];	
}


proc string surfaceSamplingFindEnvelopeModifier( int $target )
//
// Description:
//   Find the extrude node in the history chain
//   for target $target's search Envelope it it exists
//
{
	// Find the search Envelope if it exists
	//
	string $Envelope = surfaceSamplingGetCage( $target, false );
	if( size( $Envelope ) > 0 )
	{
		// If we created it (and hence, are in any position
		// to modify it), the extrude should be the second 
		// last node in the history (just in front of the
		// original mesh)
		//
		string $history[] = `listHistory( $Envelope )`;
		int $i = size( $history ) - 2;
		if( $i >= 0 && `nodeType $history[ $i ]` == "polyMoveFace" )
			return $history[ $i ];
	}
		
	// No luck
	//
	return "";
}


global proc surfaceSamplingUpdateSearchOffset( int $target )
//
// Description:
//   Update the search depth on the extrude node
//   for $target's search Envelope if it exists
//
{
	string $node = surfaceSamplingFindEnvelopeModifier( $target );
	float $offset = `floatSliderGrp -q -value ("surfaceSamplingSearchOffsetSlider" + (string)$target)`;	

	// Update our option var to make this the most recently 
	// adjusted (and hence, new default) search radius)
	//	
	optionVar -floatValue surfaceSamplingSearchEnvelopeOption $offset;
	
	if( size( $node ) > 0 )
	{
		global string $surfaceSamplingTargetList[];
		global int $surfaceSamplingTargetNumElements;
		string $path = $surfaceSamplingTargetList[ $target * $surfaceSamplingTargetNumElements];
		$offset *= surfaceSamplingBoundingRadius( $path ) * 0.01;
		setAttr ($node + ".localTranslateZ") $offset;
	}
}


global proc float surfaceSamplingBoundingRadius( string $path )
//
// Description:
//   Find the bounding radius for a given target shape
//
{
	float $min[] = `getAttr ($path + ".boundingBoxMin")`;
	float $max[] = `getAttr ($path + ".boundingBoxMax")`;
	float $invtm[] = `getAttr ($path + ".inverseMatrix")`;
	$min = pointMatrixMult( $min, $invtm); 
	$max = pointMatrixMult( $max, $invtm); 
	vector $vec = << $max[0] - $min[0], $max[1] - $min[1], $max[2] - $min[2] >>;
	return mag( $vec ) * 0.5;
}


//
//  Description:
//      gets info about the entry at the given index
//
//  Return Value:
//      the contents of the given field
//
global proc string surfaceSamplingField( int $index, string $field ) 
{
	global string $surfaceSamplingTargetList[];
	global int $surfaceSamplingTargetNumElements;
	global string $surfaceSamplingSourceList[];
	global int $surfaceSamplingSourceNumElements;

	if ( $field == "sourcepath" ) 
		return $surfaceSamplingSourceList[$surfaceSamplingSourceNumElements * $index]; 
	if ( $field == "targetpath" ) 
		return $surfaceSamplingTargetList[$surfaceSamplingTargetNumElements * $index]; 
	return "";
}


global proc surfaceSamplingBuildUVDropdown( string $path, string $menuName)
//
//  Description:
//      Rebuild the list of UV map sets for the geometry at the given index
//
//  Return Value:
//      none
//	
{
	global string $surfaceSamplingTargetList[];
	global int $surfaceSamplingTargetNumElements;
	
	setUITemplate -pushTemplate DefaultTemplate;

	if ( `optionMenu -q -exists $menuName` )
	{
		deleteUI $menuName;
	}
	
	optionMenu
		-enable false
		$menuName;
		
	// Find the shape
	string $shapes[] = { $path};
	int $current = 1;
	if ( `size $shapes` != 0 && `nodeType $shapes[0]` == "mesh" )
	{
		string $uvSets[] = `polyUVSet -q -allUVSets $shapes[0]`;
		string $currentUVSet[] = `polyUVSet -q -currentUVSet $shapes[0]`;

		for ( $i = 0; $i < `size $uvSets`; $i++ )
		{
			menuItem -label $uvSets[$i];
			if ( $uvSets[$i] == $currentUVSet[0] ) $current = $i + 1;
		}
	}

	optionMenu -e
		-enable true
		-select $current
		-width 100
		$menuName;

	setUITemplate -popTemplate;
}


global proc surfaceSamplingRemoveTarget( int $index)
//
//  Description:
//      Remove the target at $index 
//
//  Return Value:
//      none
//	
{
	global string $surfaceSamplingTargetList[];
	global int $surfaceSamplingTargetListSize;
	global int $surfaceSamplingTargetNumElements;

	// Shift everyone down one UI slot
	int $j = $index;
	while( $j + 1 < $surfaceSamplingTargetListSize)
	{
		string $path = $surfaceSamplingTargetList[ ($j + 1) * $surfaceSamplingTargetNumElements];
		$surfaceSamplingTargetList[ $j * $surfaceSamplingTargetNumElements] = $path;
		text -e -w 150 -l $path ("surfaceSamplingTargetNameTxt" + (string)$j);
		$j++;
	}
				
	// Now drop our total by one
	$surfaceSamplingTargetListSize--;
	
	// Delete the last UI
	string $ui = "surfaceSamplingTargetEntryLayout" + (string)$surfaceSamplingTargetListSize;
	if(`control -exists $ui`) {
		// Using evalDeferred here as a workaround for bug MAYA-25469
		// Deleting a popupMenu while the menu is still open will trigger a crash in Qt
		evalDeferred ("deleteUI " + $ui);
	}
}


global proc surfaceSamplingSetEnvelopeFromSelection( int $target)
//
//  Description:
//      Make the selected mesh the cage for target $target 
//
//  Return Value:
//      none
//	
{
	global string $envelopeAssociationAttribute;
	global string $surfaceSamplingTargetList[];
	global int $surfaceSamplingTargetNumElements;
	string $path = $surfaceSamplingTargetList[ $target * $surfaceSamplingTargetNumElements];
	
	// First, validate the selection
	//
	string $selection[] = `ls -sl -o`;
	string $envelopeShapes[] = `listRelatives -shapes $selection`;
	if( size( $envelopeShapes ) != 1 || size( `ls -exactType "mesh" $envelopeShapes[0]` ) != 1 )
	{
		error (uiRes("m_performSurfaceSampling.kErrorSelectonemesh"));
		return;
	}

	// If there's a Envelope attached to this surface
	// already, we need to disconnect it
	//
	string $connections[] = `listConnections -plugs true ($path + ".message")`;
	for( $connection in $connections)
		if( endsWith( $connection, "." + $envelopeAssociationAttribute) )
			disconnectAttr ($path + ".message") $connection;
	
	// Connect the new envelope to the shape so we can identify it as a Envelope
	//
	if( !attributeExists( $envelopeAssociationAttribute, $envelopeShapes[0]) )
		addAttr -longName $envelopeAssociationAttribute -at message $envelopeShapes[0];
	connectAttr ($path + ".message") ($envelopeShapes[0] + "."  + $envelopeAssociationAttribute);

	// Now disable our "delete cages" option to force the user to confirm the
	// delete before removing any geometry they have spent time creating
	//
	checkBoxGrp -e -value1 off surfaceSamplingDeleteCagesField;		
}


proc surfaceSamplingWildcardSourcesOption( int $enable)
{
	global int $surfaceSamplingSourceNumElements;
	
	if( $enable)
	{
		setParent surfaceSamplingSrcSurfaceLayout;
		rowColumnLayout  -cat 1 "left" 10 
									-columnWidth 1 200
									-nc $surfaceSamplingSourceNumElements surfaceSamplingAllSourcesOption;
		text -al "left" -w 150 -fn "obliqueLabelFont" -label (uiRes("m_performSurfaceSampling.kAllOtherSurfaces"));
		setParent ..;
	}
	else
	{
		deleteUI surfaceSamplingAllSourcesOption;
	}
}


global proc surfaceSamplingRemoveSource( int $index)
//
//  Description:
//      Add the surface at $path to the end of our list of sources
//
//  Return Value:
//      none
//	
{
	global string $surfaceSamplingSourceList[];
	global int $surfaceSamplingSourceListSize;
	global int $surfaceSamplingSourceNumElements;

	// Shift everyone down one UI slot
	int $j = $index;
	while( $j + 1 < $surfaceSamplingSourceListSize)
	{
		string $path = $surfaceSamplingSourceList[ ($j + 1) * $surfaceSamplingSourceNumElements];
		$surfaceSamplingSourceList[ $j * $surfaceSamplingSourceNumElements] = $path;
		text -e -al "right" -w 150 -l $path ("surfaceSamplingSourceNameTxt" + (string)$j);
		$j++;
	}
				
	// Now drop our total by one
	$surfaceSamplingSourceListSize--;
				
	// Delete the last UI
	string $ui = "surfaceSamplingSourceEntryLayout" + (string)$surfaceSamplingSourceListSize;
	if(`control -exists $ui`) {
		// Using evalDeferred here as a workaround for bug MAYA-25469
		// Deleting a popupMenu while the menu is still open will trigger a crash in Qt
		evalDeferred ("deleteUI " + $ui);
	}
	
	// If this is the last source, throw up our wildcard option
	if( $surfaceSamplingSourceListSize == 0) 
		surfaceSamplingWildcardSourcesOption( true );
}


global proc surfaceSamplingRemoveTargetByPath( string $path)
//
//  Description:
//      Remove an object from our list of targets by DAG $path
//
//  Return Value:
//      none
//	
{
	global string $surfaceSamplingTargetList[];
	global int $surfaceSamplingTargetListSize;
	global int $surfaceSamplingTargetNumElements;
	
	// If this path has descendents, recursively remove them instead
	//
	string $kids[] = `listRelatives -c -ni -path $path`;
	if( size( $kids ) > 0 )
	{
		for( $kid in $kids )
			surfaceSamplingRemoveTargetByPath( $kid );
	}
	else
	{	
		// Find this bad boy and remove him by index
		//
		int $j = 0;
		while( $j < $surfaceSamplingTargetListSize)
		{
			if( $surfaceSamplingTargetList[ $j * $surfaceSamplingTargetNumElements] == $path)
			{
				surfaceSamplingRemoveTarget( $j);
				break;
			}
			$j++;
		}	
	}
}


global proc surfaceSamplingRemoveSourceByPath( string $path)
//
//  Description:
//      Remove an object from our list of sources by DAG $path
//
//  Return Value:
//      none
//	
{
	global string $surfaceSamplingSourceList[];
	global int $surfaceSamplingSourceListSize;
	global int $surfaceSamplingSourceNumElements;
	
	// If this path has descendents, recursively remove them instead
	//
	string $kids[] = `listRelatives -c -ni -path $path`;
	if( size( $kids ) > 0 )
	{
		for( $kid in $kids )
			surfaceSamplingRemoveSourceByPath( $kid );
	}
	else
	{	
		// Find this bad boy and remove him by index
		//
		int $j = 0;
		while( $j < $surfaceSamplingSourceListSize)
		{
			if( $surfaceSamplingSourceList[ $j * $surfaceSamplingSourceNumElements] == $path)
			{
				surfaceSamplingRemoveSource( $j);
				break;
			}
			$j++;
		}	
	}
}


global proc surfaceSamplingAddTargets( string $path, int $checkForDuplicates)
//
//  Description:
//      Add the surface at $path to the end of our list of destinations
//
//  Return Value:
//      none
//	
{
	global string $surfaceSamplingTargetList[];
	global int $surfaceSamplingTargetNumElements;
	global int $surfaceSamplingTargetListSize;
	global string $envelopeAssociationAttribute;

	// If this path has descendents, add them instead
	// Note that this is deliberately not done recursively in
	// case targets are instanced. Instanced targets do not make
	// sense for this operation - and trying to process them twice
	// makes even less sense
	//
	string $shapes[] = `listRelatives -ad -ni -path -type "mesh" $path`;
	if( size( $shapes ) > 0 )
	{
		for( $kid in $shapes )
			surfaceSamplingAddTargets( $kid, $checkForDuplicates );
		return;
	}

	// If this is an envelope shape, try adding the attached shape instead
	//
	if( attributeExists( $envelopeAssociationAttribute, $path))
	{
		$shapes = `listConnections -sh on ($path + "." + $envelopeAssociationAttribute)`;
		for( $kid in $shapes)
			surfaceSamplingAddTargets( $kid, $checkForDuplicates );
		return;
	}

	// Is this a suitable target?
	//
	if( `nodeType $path` != "mesh" ||
		`getAttr ($path + ".intermediateObject")` != 0 ||
		attributeExists( $envelopeAssociationAttribute, $path))
	{
		return;
	}

	// Optionally check this isn't already in the list 
	//
	if( $checkForDuplicates )
	{
		int $j = 0;
		while( $j < $surfaceSamplingTargetListSize)
		{
			if( $surfaceSamplingTargetList[ $j * $surfaceSamplingTargetNumElements] == $path) return;
			$j++;
		}	
	}

	// Throw this new entry at the end of our list
	//
	int $target = $surfaceSamplingTargetListSize++;

	// Remove this as a source if we have it
	//
	surfaceSamplingRemoveSourceByPath( $path);
	
	// Throw this chap on the end of our list 
	//
	$surfaceSamplingTargetList[ $surfaceSamplingTargetNumElements * $target] = $path;
	
	// Create the row layout
	//
	setParent surfaceSamplingTargetSurfaceLayout;
	
	string $row = `rowColumnLayout  -cat 1 "left" 10 -nc 4
							-columnWidth 1 120 
							-columnWidth 2 120 
							-columnWidth 3 100 
							-columnWidth 4 125 
							("surfaceSamplingTargetEntryLayout" + (string)$target)`;
	
	// Name
	//
	text -align "left" -w 150 -l $path ("surfaceSamplingTargetNameTxt" + (string)$target);
	popupMenu;
	menuItem -label (uiRes("m_performSurfaceSampling.kSelect")) -c ("select `surfaceSamplingField " + $target + " \"targetpath\"`" );
	menuItem -label (uiRes("m_performSurfaceSampling.kRemove")) -c ("surfaceSamplingRemoveTarget " + $target);
	menuItem -label (uiRes("m_performSurfaceSampling.kUseSelectionasEnvelope")) -c ("surfaceSamplingSetEnvelopeFromSelection " + $target);


	// UV sets
	//	
	surfaceSamplingBuildUVDropdown( $surfaceSamplingTargetList[ $target * $surfaceSamplingTargetNumElements], ("surfaceSamplingOutputUVSetMenu" + (string)$target));
		
	if( (`optionVar -q surfaceSamplingTransferSpaceOption` - 1) == 2)
	{
		// UV transfer space
		//	
		surfaceSamplingBuildUVDropdown( $surfaceSamplingTargetList[ $target * $surfaceSamplingTargetNumElements], ("surfaceSamplingTargetUVSpaceMenu" + (string)$target));
	}
	else
	{
		// World/Object space == ray casting
		//
		surfaceSamplingAddTargetRayCastOptions( $target);
	}

	setParent ..;
}



global proc surfaceSamplingAddTargetRayCastOptions( int $target)
//
//  Description:
//      Add the surface at $path to the end of our list of destinations
//
//  Return Value:
//      none
//	
{
	global string $surfaceSamplingTargetList[];
	global int $surfaceSamplingTargetNumElements;
	global int $surfaceSamplingTargetListSize;

	// Display
	//	
	optionMenu -width 80 -cc ("surfaceSamplingSetTargetDisplay( " + $target + " )") ("surfaceSamplingTargetDisplayMenu" + (string)$target);
	{
		menuItem -label (uiRes("m_performSurfaceSampling.kSurface"));
		menuItem -label (uiRes("m_performSurfaceSampling.kEnvelope"));
		menuItem -label (uiRes("m_performSurfaceSampling.kBoth"));
	}
	
	// Search offset. Determine the object's bounding radius to give us a good starting point
	//
	float $offset = `optionVar -q surfaceSamplingSearchEnvelopeOption`;
	
	// If there's an existing Envelope, set the initial value to reflect it's size
	//
	string $modifier = surfaceSamplingFindEnvelopeModifier( $target );
	if( size( $modifier ) > 0 )
	{
		$offset = getAttr ($modifier + ".localTranslateZ");
		string $path = $surfaceSamplingTargetList[ $surfaceSamplingTargetNumElements * $target];
		$offset *= 100.0 / surfaceSamplingBoundingRadius( $path );
	}
	
	floatSliderGrp -min 0.0 -max 100.0 -value $offset
				-width 131
				-cw3 1 50 80 -ct2 "both" "both"
				-columnWidth 1 60
				-columnWidth 2 65
				-field true -fieldMinValue 0.0 -fieldMaxValue 1000.0 
				-dragCommand ("surfaceSamplingUpdateSearchOffset " + (string)$target) 
				-changeCommand ("surfaceSamplingUpdateSearchOffset " + (string)$target) ("surfaceSamplingSearchOffsetSlider" + (string)$target);
}



global proc surfaceSamplingAddSource( string $path, int $checkForDuplicates)
//
//  Description:
//      Add the surface at $path to the end of our list of sources
//
//  Return Value:
//      none
//	
{
	global string $surfaceSamplingSourceList[];
	global int $surfaceSamplingSourceNumElements;
	global int $surfaceSamplingSourceListSize;
	global string $envelopeAssociationAttribute;

	// If this path has descendents, recursively add them instead
	//
	string $kids[] = `listRelatives -c -ni -path $path`;
	if( size( $kids ) > 0 )
	{
		for( $kid in $kids )
			surfaceSamplingAddSource( $kid, $checkForDuplicates );
		return;
	}

	// Is this a suitable target?
	//
	if( `nodeType $path` != "mesh" || 
		`getAttr ($path + ".intermediateObject")` != 0 ||
		attributeExists( $envelopeAssociationAttribute, $path))
	{
		return;
	}

	// An index of -1 indicates we should check the thing isn't 
	// already in our list, and if not, append it at the end
	//
	if( $checkForDuplicates )
	{
		int $j = 0;
		while( $j < $surfaceSamplingSourceListSize)
		{
			if( $surfaceSamplingSourceList[ $j * $surfaceSamplingSourceNumElements] == $path) return;
			$j++;
		}	
	}

	// If this is our first explicit source, remove the * option
	//
	if( $surfaceSamplingSourceListSize == 0) 
		surfaceSamplingWildcardSourcesOption( false );
	

	// Throw this new entry on the end of our list
	//	
	$source = $surfaceSamplingSourceListSize++;

	
	// Remove this as a target if we have it
	//
	surfaceSamplingRemoveTargetByPath( $path);
	
	// Throw this chap on the end of our list 
	//
	$surfaceSamplingSourceList[ $surfaceSamplingSourceNumElements * $source] = $path;
	
	// Create the row layout
	//
	setParent surfaceSamplingSrcSurfaceLayout;
	string $row = `rowColumnLayout  -cat 1 "left" 30 -nc 2 
							-columnWidth 1 200
							-columnWidth 2 120
							("surfaceSamplingSourceEntryLayout" + (string)$source)`;

	// Name
	//
	text -al "left" -w 150 -label $path ("surfaceSamplingSourceNameTxt" + (string)$source);
	popupMenu;
	menuItem -label (uiRes("m_performSurfaceSampling.kSelect1")) -c ("select `surfaceSamplingField " + $source + " \"sourcepath\"`" );
	menuItem -label (uiRes("m_performSurfaceSampling.kRemove1")) -c ("surfaceSamplingRemoveSource " + $source);

	// Setup the UI widget names for this entry
	//	
	if( (`optionVar -q surfaceSamplingTransferSpaceOption` - 1) == 2)
	{
		// UV transfer space
		//	
		surfaceSamplingBuildUVDropdown( $surfaceSamplingSourceList[ $source * $surfaceSamplingSourceNumElements], ("surfaceSamplingSourceUVSpaceMenu" + (string)$source));
	}
	else
	{
	}
	
	setParent ..;

}


global proc surfaceSamplingSetTargetDisplay( int $target )
//
//  Description:
//      
//
//  Return Value:
//      none
//	
{
	global string $surfaceSamplingTargetList[];
	global int $surfaceSamplingTargetNumElements;
	string $path = $surfaceSamplingTargetList[ $target * $surfaceSamplingTargetNumElements];
	
	string $displayOption = `optionMenu -q -v ("surfaceSamplingTargetDisplayMenu" + (string)$target)`;

	// Check this object still exists
	//
	if( size( `ls $path` ) == 0 ) return;
	
	// Set (and possibly create) the Envelope visibility
	//
	if( $displayOption == (uiRes("m_performSurfaceSampling.kSurface")))
	{
		// Hide the Envelope
		//
		string $Envelope = surfaceSamplingGetCage( $target, false );
		if( size( $Envelope ) > 0 )
		{
			string $transform[] = `listRelatives -path -parent $Envelope`;
			hide( $transform[0] );
		}
	}
	else
	{
		// Show (and possibly create) the Envelope
		//
		string $Envelope = surfaceSamplingGetCage( $target, true );
		string $transform[] = `listRelatives -path -parent $Envelope`;
		showHidden( $transform[0] );
	}
	
	// Set the target surface visibility
	//
	if( $displayOption == (uiRes("m_performSurfaceSampling.kEnvelope")))
	{
		// Hide the target surface
		//
		hide( $path );
	}
	else
	{
		// Show the target surface
		//
		showHidden( $path );
	}
	
	
}


proc int ddsIndex()
{
	global string $gSurfaceSamplerMayaFileExtensions[];

	for ( $i = 0; $i < `size $gSurfaceSamplerMayaFileExtensions`; $i++ )
		if ( $gSurfaceSamplerMayaFileExtensions[$i] == "dds" )
			return $i;
	return 0;
}


proc string getDefaultDir()
{
	string $dir = `workspace -q -rootDirectory`;
	if( `filetest -d ($dir + "textures\\")`)
		$dir += "textures\\";
	else if( `filetest -d ($dir + "images\\")`)
		$dir += "images\\";
	return fromNativePath( $dir);
}


proc surfaceSamplingCreateOrResetOptionVars( int $forceFactorySettings )
//
// Description:
//		Make sure all optionVars exist, and optionally force 
//		them to the default settings
//
{
	global int $surfaceSamplingMentalCommonSettingsIndex;
	global int $surfaceSamplingMayaCommonSettingsIndex;

	// On factory reset should delete all output settings variables for maps previously created
	//
	if( $forceFactorySettings )
	{
		int $arraySize = `optionVar -q "surfaceSamplingOutputArraySize"`;
		int $i = 0;
		while( $i < $arraySize )
		{
			deleteMapOptionVars( $i );
			$i++;
		}
	}

	if( $forceFactorySettings || !`optionVar -exists surfaceSamplingSourceList` )
	{
		optionVar -stringValueAppend "surfaceSamplingSourceList" "";
		optionVar -clearArray "surfaceSamplingSourceList";
	}
	if( $forceFactorySettings || !`optionVar -exists surfaceSamplingTargetList` )
	{
		optionVar -stringValueAppend "surfaceSamplingTargetList" "";
		optionVar -clearArray "surfaceSamplingTargetList";
	}

	// The output array size initially is 2, one for the maya common 
	// settings, and one for mental ray common settings
	//
	if( $forceFactorySettings || !`optionVar -exists surfaceSamplingOutputArraySize` )
		optionVar -intValue "surfaceSamplingOutputArraySize" 2;

	// Common-to-both-maya-and-mental-ray common settings
	//
	int $commonIndices[] = { $surfaceSamplingMentalCommonSettingsIndex, $surfaceSamplingMayaCommonSettingsIndex };
	int $i = 0;
	while( $i < `size $commonIndices` )
	{
		if ( $forceFactorySettings || !`optionVar -exists ("surfaceSamplingMapWidthOption" + (string)$commonIndices[$i])` ) 
			optionVar -intValue ("surfaceSamplingMapWidthOption" + (string)$commonIndices[$i]) 256;

		if ( $forceFactorySettings || !`optionVar -exists ("surfaceSamplingMapHeightOption" + (string)$commonIndices[$i])` )
			optionVar -intValue ("surfaceSamplingMapHeightOption" + (string)$commonIndices[$i]) 256;

		if ( $forceFactorySettings || !`optionVar -exists ("surfaceSamplingLockAspectRatioOption" + (string)$commonIndices[$i])` ) 
			optionVar -intValue ("surfaceSamplingLockAspectRatioOption" + (string)$commonIndices[$i]) 1;

		if ( $forceFactorySettings || !`optionVar -exists ("surfaceSamplingPostBakeOption" + (string)$commonIndices[$i])` )
			optionVar -intValue ("surfaceSamplingPostBakeOption" + (string)$commonIndices[$i]) 1;

		$i++;
	}	

	if ( $forceFactorySettings || !`optionVar -exists surfaceSamplingShaderConnectionOption` )
		optionVar -intValue surfaceSamplingShaderConnectionOption 1;

	if ( $forceFactorySettings || !`optionVar -exists surfaceSamplingTransferSpaceOption` )
		optionVar -intValue surfaceSamplingTransferSpaceOption 1;

	if ( $forceFactorySettings || !`optionVar -exists surfaceSamplingSuperSamplingOption` )
		optionVar -intValue surfaceSamplingSuperSamplingOption 2;

	if ( $forceFactorySettings || !`optionVar -exists surfaceSamplingFilterTypeOption` )
		optionVar -intValue surfaceSamplingFilterTypeOption 1;

	if ( $forceFactorySettings || !`optionVar -exists surfaceSamplingFilterSizeOption` )
		optionVar -floatValue surfaceSamplingFilterSizeOption 3.0;

	if ( $forceFactorySettings || !`optionVar -exists surfaceSamplingMaxSearchDistanceOption` )
		optionVar -floatValue surfaceSamplingMaxSearchDistanceOption 0.0;

	if ( $forceFactorySettings || !`optionVar -exists surfaceSamplingFillTextureSeamsOption` )
		optionVar -intValue surfaceSamplingFillTextureSeamsOption 1;

	if ( $forceFactorySettings || !`optionVar -exists surfaceSamplingSearchMethodOption` )
		optionVar -intValue surfaceSamplingSearchMethodOption 1;

	if ( $forceFactorySettings || !`optionVar -exists surfaceSamplingMatchBasedOnOption` )
		optionVar -intValue surfaceSamplingMatchBasedOnOption 1;

	if ( $forceFactorySettings || !`optionVar -exists surfaceSamplingDeleteCagesOption` )
		optionVar -intValue surfaceSamplingDeleteCagesOption 1;
		
	if ( $forceFactorySettings || !`optionVar -exists surfaceSamplingIgnoreMirroredFacesOption` )
		optionVar -intValue surfaceSamplingIgnoreMirroredFacesOption 0;
		
	if ( $forceFactorySettings || !`optionVar -exists surfaceSamplingFlipUOption` )
		optionVar -intValue surfaceSamplingFlipUOption 0;
		
	if ( $forceFactorySettings || !`optionVar -exists surfaceSamplingFlipVOption` )
		optionVar -intValue surfaceSamplingFlipVOption 0;
		
	if ( $forceFactorySettings || !`optionVar -exists surfaceSamplingSearchEnvelopeOption` )
		optionVar -floatValue surfaceSamplingSearchEnvelopeOption 0.0;

	// mental ray bake set options
	//
	if ( $forceFactorySettings || !`optionVar -exists surfaceSamplingMentalNormalDirection` )
		optionVar -intValue surfaceSamplingMentalNormalDirection 2;

	// Orthogonal Reflection was moved out of the common mr settings.  Remove the obsolete optionVar
	//
	if( `optionVar -exists surfaceSamplingMentalOrthogonalReflection` )
		optionVar -remove surfaceSamplingMentalOrthogonalReflection;

	if ( $forceFactorySettings || !`optionVar -exists surfaceSamplingMentalSamples` )
		optionVar -intValue surfaceSamplingMentalSamples 1;

	if ( $forceFactorySettings || !`optionVar -exists surfaceSamplingMentalAlpha` )
		optionVar -intValue surfaceSamplingMentalAlpha 0;

	if ( $forceFactorySettings || !`optionVar -exists surfaceSamplingMentalAlphaMode` )
		optionVar -intValue surfaceSamplingMentalAlphaMode 1;
	
	if ( $forceFactorySettings || !`optionVar -exists surfaceSamplingMentalFinalGatherQuality` )
		optionVar -floatValue surfaceSamplingMentalFinalGatherQuality 1.0;

	if ( $forceFactorySettings || !`optionVar -exists surfaceSamplingMentalFinalGatherReflect` )
		optionVar -floatValue surfaceSamplingMentalFinalGatherReflect 0.0;

	if ( $forceFactorySettings || !`optionVar -exists surfaceSamplingMentalUVRange` )
		optionVar -intValue surfaceSamplingMentalUVRange 1;

	if ( $forceFactorySettings || !`optionVar -exists surfaceSamplingMentalUMin` )
		optionVar -floatValue surfaceSamplingMentalUMin 0.0;

	if ( $forceFactorySettings || !`optionVar -exists surfaceSamplingMentalUMax` )
		optionVar -floatValue surfaceSamplingMentalUMax 0.0;

	if ( $forceFactorySettings || !`optionVar -exists surfaceSamplingMentalVMin` )
		optionVar -floatValue surfaceSamplingMentalVMin 0.0;

	if ( $forceFactorySettings || !`optionVar -exists surfaceSamplingMentalVMax` )
		optionVar -floatValue surfaceSamplingMentalVMax 0.0;

	if ( $forceFactorySettings || !`optionVar -exists surfaceSamplingMentalFillTextureSeams` )
		optionVar -floatValue surfaceSamplingMentalFillTextureSeams 1.0;

	if ( $forceFactorySettings || !`optionVar -exists surfaceSamplingConnectionNode` )
		optionVar -stringValue surfaceSamplingConnectionNode "surfaceSamplingConnectionNode";
		
	if ( $forceFactorySettings || !`optionVar -exists surfaceSamplingMentalTransferSpaceOption` )
		optionVar -intValue surfaceSamplingMentalTransferSpaceOption 1;
}


proc int typeIndexFromString( string $typeName )
{
	global int $surfaceSamplingNumMapTypes;
	global string $surfaceSamplingMapTypeNames[];

	int $i = 0;
	while( $i < $surfaceSamplingNumMapTypes )
	{
		if( $typeName == $surfaceSamplingMapTypeNames[$i] )
			return $i;
		$i++;
	}

	return -1;
}


global proc surfaceSamplingSetOptionVarsFromUI( string $parent)
//
// Description:
//		Set the OptionVars from the UI values.
//
{
    setParent $parent;
    
	// Output Map options
	//
	global int $surfaceSamplingOutputArraySize;
	global int $surfaceSamplingMayaCommonSettingsIndex;
	global int $surfaceSamplingMentalCommonSettingsIndex;
	int $i = 0;

	while( $i < $surfaceSamplingOutputArraySize)
	{
		if( $i > $surfaceSamplingMentalCommonSettingsIndex )
		{
			// our common settings don't have the specialized options 
			//
			int $enabled = `checkBox -q -value ("surfaceSamplingEnableMap" + (string)$i)`;
			optionVar -intValue ("surfaceSamplingEnableMapOption" + (string)$i) $enabled; 

			float $maxValue = `floatFieldGrp -q -value1 ("surfaceSamplingMaxValueField" + (string)$i)`;
			optionVar -floatValue ("surfaceSamplingMaxValueOption" + (string)$i) $maxValue;

			int $mapSpace = `optionMenuGrp -q -select ("surfaceSamplingMapSpaceMenu" + (string)$i)`;
			optionVar -intValue ("surfaceSamplingMapSpaceOption" + (string)$i) $mapSpace;

			int $mapMaterials = `checkBoxGrp -q -value1 ("surfaceSamplingMapMaterialsField" + (string)$i)`;
			optionVar -intValue ("surfaceSamplingMapMaterialsOption" + (string)$i) $mapMaterials;
			
			int $includeShadows = `checkBoxGrp -q -value1 ("surfaceSamplingIncludeShadowsField" + (string)$i)`;
			optionVar -intValue ("surfaceSamplingIncludeShadowsOption" + (string)$i) $includeShadows;
			
			string $name = `textFieldGrp -q -text ("surfaceSamplingFileName" + (string)$i)`;
			optionVar -stringValue ("surfaceSamplingFileNameOption" + (string)$i) $name;

			int $mapExtension = `optionMenuGrp -q -select ("surfaceSamplingFileFormatMenu" + (string)$i)`;
			optionVar -intValue ("surfaceSamplingExtensionOption" + (string)$i) $mapExtension;

			int $bitsPerChannel = `optionMenuGrp -q -select ("surfaceSamplingMentalBitsPerChannel" + (string)$i)`;
			optionVar -intValue ("surfaceSamplingMentalBitsPerChannel" + (string)$i) $bitsPerChannel;
			
			int $optimization = `optionMenuGrp -q -select ("surfaceSamplingMentalOptimField" + (string)$i)`;
			optionVar -intValue ("surfaceSamplingMentalOptimOption" + (string)$i) $optimization;
			
			int $useCommonOutputSettings = `checkBoxGrp -q -value1 ("surfaceSamplingUseCommonOutputSettingsField" + (string)$i)`;
			optionVar -intValue ("surfaceSamplingUseCommonOutputSettingsField" + (string)$i) $useCommonOutputSettings;

			string $typeName = `checkBox -q -label ("surfaceSamplingEnableMap" + (string)$i)`;
			int $typeIndex = `typeIndexFromString( $typeName )`;
			optionVar -intValue ("surfaceSamplingType" + (string)$i) $typeIndex;

			string $customShaderName = `textFieldGrp -q -text ("surfaceSamplingCustomShader" + (string)$i)`;
			optionVar -stringValue ("surfaceSamplingCustomShaderName" + (string)$i) $customShaderName;
	
			int $orthogonalReflection = `checkBoxGrp -q -value1 ("surfaceSamplingOrthReflectionField" + (string)$i)`;
			optionVar -intValue ("surfaceSamplingOrthReflectionOption" + (string)$i) $orthogonalReflection;
			
			string $camName = `optionMenuGrp -q -v ("surfaceSamplingCameraMenu" + (string)$i)`;
			optionVar -stringValue ("surfaceSamplingCameraName" + (string)$i) $camName;

			int $occRays = `intSliderGrp -q -value ("surfaceSamplingOcclusionRays" + (string)$i)`;
			optionVar -intValue ("surfaceSamplingOcclusionRays" + (string)$i) $occRays;

			float $occFalloff = `floatFieldGrp -q -value1 ("surfaceSamplingOcclusionFalloff" + (string)$i)`;
			optionVar -floatValue ("surfaceSamplingOcclusionFalloff" + (string)$i) $occFalloff;
		}

		int $mapWidth = `intSliderGrp -q -value ("surfaceSamplingWidthField" + (string)$i)`;
		optionVar -intValue ("surfaceSamplingMapWidthOption" + (string)$i) $mapWidth;

		int $mapHeight = `intSliderGrp -q -value ("surfaceSamplingHeightField" + (string)$i)`;
		optionVar -intValue ("surfaceSamplingMapHeightOption" + (string)$i) $mapHeight;

		int $lockAspect = `checkBoxGrp -q -value1 ("surfaceSamplingAspectRatioChkBox" + (string)$i)`;
		optionVar -intValue ("surfaceSamplingLockAspectRatioOption" + (string)$i) $lockAspect; 

		$i++;
	}

	// Remember the number of maps we have
	//
	optionVar -intValue "surfaceSamplingOutputArraySize" $surfaceSamplingOutputArraySize;

	// Shader connection options
	int $enableShaderConnection = `checkBoxGrp -q -value1 surfaceSamplingEnableShaderConnection`;
	int $shaderConnection = `radioButtonGrp -q -select surfaceSamplingShaderConnection`;
	optionVar -intValue surfaceSamplingShaderConnectionOption ($shaderConnection * $enableShaderConnection);
	
	// Algorithm Options
	//
	int $transferSpace = `optionMenuGrp -q -select surfaceSamplingTransferSpaceMenu`;
	optionVar -intValue surfaceSamplingTransferSpaceOption $transferSpace;

	int $superSampling = `optionMenuGrp -q -select surfaceSamplingSuperSamplingMenu`;
	optionVar -intValue surfaceSamplingSuperSamplingOption $superSampling;

	int $filterType = `optionMenuGrp -q -select surfaceSamplingFilterTypeMenu`;
	optionVar -intValue surfaceSamplingFilterTypeOption $filterType;

	float $filterSize = `floatSliderGrp -q -value surfaceSamplingFilterSizeField`;
	optionVar -floatValue surfaceSamplingFilterSizeOption $filterSize;

	int $FillTextureSeams = `intFieldGrp -q -value1 surfaceSamplingFillTextureSeamsField`;
	optionVar -intValue surfaceSamplingFillTextureSeamsOption $FillTextureSeams;

	int $searchMethod = `optionMenuGrp -q -select surfaceSamplingSearchMethodMenu`;
	optionVar -intValue surfaceSamplingSearchMethodOption $searchMethod;
	
	int $matchBasedOn = `optionMenuGrp -q -select surfaceSamplingMatchBasedOnMenu`;
	optionVar -intValue surfaceSamplingMatchBasedOnOption $matchBasedOn;	

	float $maxSearchDistance = `floatSliderGrp -q -value surfaceSamplingMaxSearchDistanceField`;
	optionVar -floatValue surfaceSamplingMaxSearchDistanceOption $maxSearchDistance;

	int $deleteCages = `checkBoxGrp -q -value1 surfaceSamplingDeleteCagesField`;
	optionVar -intValue surfaceSamplingDeleteCagesOption $deleteCages;

	int $ignoreMirroredFaces = `checkBoxGrp -q -value1 surfaceSamplingIgnoreMirroredFacesField`;
	optionVar -intValue surfaceSamplingIgnoreMirroredFacesOption $ignoreMirroredFaces;

	int $flipU = `checkBoxGrp -q -value1 surfaceSamplingFlipUField`;
	optionVar -intValue surfaceSamplingFlipUOption $flipU;

	int $flipV = `checkBoxGrp -q -value1 surfaceSamplingFlipVField`;
	optionVar -intValue surfaceSamplingFlipVOption $flipV;

	// mental ray bakeset options
	//
	int $normalDirection = `optionMenuGrp -q -select surfaceSamplingMentalNormalDirectionCtrl`;
	optionVar -intValue surfaceSamplingMentalNormalDirection $normalDirection;

	int $samples = `intSliderGrp -q -value  surfaceSamplingMentalSamplesCtrl`;
	optionVar -intValue surfaceSamplingMentalSamples $samples;

	int $alpha = `checkBoxGrp -q -value1 surfaceSamplingMentalAlphaCtrl`;
	optionVar -intValue surfaceSamplingMentalAlpha $alpha;

	int $alphaMode = `optionMenuGrp -q -select surfaceSamplingMentalAlphaModeCtrl`;
	optionVar -intValue surfaceSamplingMentalAlphaMode $alphaMode;

	float $quality = `floatSliderGrp -q -value surfaceSamplingMentalFinalGatherQualityCtrl`;
	optionVar -floatValue surfaceSamplingMentalFinalGatherQuality $quality;

	float $reflect = `floatSliderGrp -q -value surfaceSamplingMentalFinalGatherReflectCtrl`;
	optionVar -floatValue surfaceSamplingMentalFinalGatherReflect $reflect;

	int $uvRange = `optionMenuGrp -q -select surfaceSamplingMentalUVRangeCtrl`;
	optionVar -intValue surfaceSamplingMentalUVRange $uvRange;

	float $uMin = `floatSliderGrp -q -value surfaceSamplingMentalUMinCtrl`;
	optionVar -floatValue surfaceSamplingMentalUMin $uMin;

	float $uMax = `floatSliderGrp -q -value surfaceSamplingMentalUMaxCtrl`;
	optionVar -floatValue surfaceSamplingMentalUMax $uMax;

	float $vMin = `floatSliderGrp -q -value surfaceSamplingMentalVMinCtrl`;
	optionVar -floatValue surfaceSamplingMentalVMin $vMin;

	float $vMax = `floatSliderGrp -q -value surfaceSamplingMentalVMaxCtrl`;
	optionVar -floatValue surfaceSamplingMentalVMax $vMax;

	float $seams = `floatSliderGrp -q -value surfaceSamplingMentalFillTextureSeamsCtrl`;
	optionVar -floatValue surfaceSamplingMentalFillTextureSeams $seams;

	// mental ray algorithm options
	//
	int $mentalTransferSpace = `optionMenuGrp -q -select surfaceSamplingMentalTransferSpaceCtrl`;
	optionVar -intValue surfaceSamplingMentalTransferSpaceOption $mentalTransferSpace;
}

proc string getSelectedUVSet( string $path, int $target, string $field)
{
	string $uvSet = "";
	string $uvWidget = ($field + (string)$target);
	if( $field != "" && `control -exists $uvWidget` )
	{
		string $uvSets[] = `optionMenu -q -itemListLong $uvWidget`;
		int $item = `optionMenu -q -select $uvWidget`;
		if ( $item <= `size $uvSets` )
			$uvSet = `menuItem -q -label $uvSets[$item - 1]`;
	}
	if( $uvSet == "" && $path != "")
	{
		string $shapes[] = `listRelatives -path -shapes $path`;
		if ( `size $shapes` != 0 && `nodeType $shapes[0]` == "mesh" )
		{
			string $currentUVSet[] = `polyUVSet -q -currentUVSet $shapes[0]`;
			if( size( $currentUVSet) > 0)
				$uvSet = $currentUVSet[0];
		}
	}
	if( $uvSet == "")
	{
		$uvSet = "map1";
	}
	return $uvSet;
}


proc int haveMayaMaps()
//
// Description: return true if any maps are handled by Maya's surfaceSampler cmd
//
{
	global int $surfaceSamplingNormalType;
	global int $surfaceSamplingDisplacementType;
	global int $surfaceSamplingDiffuseColorType;
	global int $surfaceSamplingLitAndShadeColorType;
	global int $surfaceSamplingAlphaType;
	global int $surfaceSamplingFirstOutputMap;

	int $arraySize = `optionVar -q surfaceSamplingOutputArraySize`;
	int $i = $surfaceSamplingFirstOutputMap;
	while( $i < $arraySize )
	{
		int $mapType = `optionVar -q ("surfaceSamplingType" + (string)$i)`;

		if( $mapType == $surfaceSamplingNormalType ||
			$mapType == $surfaceSamplingDisplacementType ||
			$mapType == $surfaceSamplingDiffuseColorType ||
			$mapType == $surfaceSamplingLitAndShadeColorType ||
			$mapType == $surfaceSamplingAlphaType )
		{
			if(`optionVar -q ("surfaceSamplingEnableMapOption" + (string)$i)`)
				return true;
		}
		$i++;
	}
	return false;
}

//
// Identify/find a file extension
//
proc int identifyExtension( string $extension, int $usesMentalRay)
{
	global string $gSurfaceSamplerMayaFileExtensions[];
	global string $gSurfaceSamplerMentalFileExtensions[];
	
	if( $usesMentalRay )
	{
		for ( $i = 1; $i < `size $gSurfaceSamplerMentalFileExtensions`; $i++ )
			if ( $gSurfaceSamplerMentalFileExtensions[$i] == $extension )
				return $i;
	}
	else
	{
		for ( $i = 1; $i < `size $gSurfaceSamplerMayaFileExtensions`; $i++ )
			if ( $gSurfaceSamplerMayaFileExtensions[$i] == $extension )
				return $i;
	}
	return 0;
}


//
// Strip off the file extension if we recognise it
//
proc string stripExtension( string $filename, int $usesMentalRay)
{
	string $buffer[];
	int $nTokens = `tokenize $filename "." $buffer`;
	if ( $nTokens >= 2 )
	{
		if( identifyExtension( $buffer[$nTokens - 1], $usesMentalRay) > 0)
		{
			int $extSize = `size $buffer[$nTokens - 1]`;
			int $nameSize = `size $filename`;
			return `substring $filename 1 ( $nameSize - $extSize - 1 )`;
		}
	}
	return $filename;
}


global proc string surfaceSamplingGenerateCmd()
{
	global string $gSurfaceSamplerMayaFileExtensions[];
	global string $surfaceSamplingTargetList[];
	global int $surfaceSamplingTargetListSize;
	global int $surfaceSamplingTargetNumElements;
	global string $surfaceSamplingSourceList[];
	global int $surfaceSamplingSourceListSize;
	global int $surfaceSamplingSourceNumElements;
	global int $surfaceSamplingNumOutputMaps;
	global int $surfaceSamplingLitAndShadeColorType;
	global int $surfaceSamplingAlphaType;

	if( $surfaceSamplingTargetListSize == 0) 
	{
		error (uiRes("m_performSurfaceSampling.kErrorSetupAtLeastOneTarget"));
		return "";
	}
	
	string $cmd = "surfaceSampler ";
	int $transferSpace = `optionVar -q surfaceSamplingTransferSpaceOption` - 1;

	// Add our target surfaces
	//
	int $target = 0;
	while( $target < $surfaceSamplingTargetListSize)
	{
		string $path = $surfaceSamplingTargetList[ $target * $surfaceSamplingTargetNumElements];
		float $radius = surfaceSamplingBoundingRadius( $path );
		
		$cmd += "-target " + $path + " ";		
		$cmd += "-uvSet " + getSelectedUVSet( $path, $target, "surfaceSamplingOutputUVSetMenu") + " ";	
							
		if( $transferSpace == 2)
		{
			$cmd += "-targetUVSpace " + getSelectedUVSet( $path, $target, "surfaceSamplingTargetUVSpaceMenu") + " ";		
		}
		else
		{
			float $offset = `floatSliderGrp -q -value ("surfaceSamplingSearchOffsetSlider" + (string)$target)`;
			$offset *= $radius * 0.01;
			$cmd += "-searchOffset " + $offset + " ";
			
			float $maxSearchDistance = `optionVar -q surfaceSamplingMaxSearchDistanceOption`;
			$maxSearchDistance *= $radius * 0.01;
			$cmd += "-maxSearchDistance " + $maxSearchDistance + " ";
			
			string $searchCage = surfaceSamplingGetCage( $target, false );
			$cmd += "-searchCage \"" + $searchCage + "\" ";
		}

		$target++;
	}
	
	// Add our source surfaces
	// use any non-target surface as a source
	//
	if( $surfaceSamplingSourceListSize > 0)
	{
		// If the user has selected specific surfaces, use those
		int $source = 0;
		while( $source < $surfaceSamplingSourceListSize)
		{
			string $path = $surfaceSamplingSourceList[ $source * $surfaceSamplingSourceNumElements];
			$cmd += "-source " + $path + " ";
				
			if( $transferSpace == 2)
				$cmd += "-sourceUVSpace " + getSelectedUVSet( $path, $source, "surfaceSamplingSourceUVSpaceMenu") + " ";		
			
			$source++;
		}
	}
	else
	{
		// If the user hasn't select an explicit set of sources, just
		// use every non-target surface in the scene
		//
		string $allShapes[] = `ls -g -v -ni`;
		for( $shape in $allShapes)
		{
			int $isTarget = 0;
			int $target = 0;
			while( $target < $surfaceSamplingTargetListSize)
			{
				if( $shape == $surfaceSamplingTargetList[ $target * $surfaceSamplingTargetNumElements])
				{
					$isTarget = 1;
					break;
				}
				$target++;
			}
			if( $isTarget == 0)
			{
				$cmd += "-source " + $shape + " ";
				if( $transferSpace == 2)
					$cmd += "-sourceUVSpace " + getSelectedUVSet( $shape, 0, "") + " ";		
			}
		}
	}

	// Add our output maps
	//
	global int $surfaceSamplingOutputArraySize;
	global int $surfaceSamplingMayaCommonSettingsIndex;
	global int $surfaceSamplingMentalCommonSettingsIndex;
	global int $surfaceSamplingFirstOutputMap;
	string $mapNames[] = { "normal", "displacement", "diffuseRGB", "litAndShadedRGB", "alpha", "ambient" };
	string $mapSpaces[] = { "object", "tangent" };
	int $i = $surfaceSamplingFirstOutputMap;
	while( $i < $surfaceSamplingOutputArraySize)
	{

		int $mapType = `optionVar -q ("surfaceSamplingType" + (string)$i)`;

		// Only process non-mental ray maps
		//
		if( $mapType <= $surfaceSamplingAlphaType )
		{	
			if( `optionVar -q ("surfaceSamplingEnableMapOption" + (string)$i)`)
			{
				int $commonIndex = $i;

				if( `optionVar -q ("surfaceSamplingUseCommonOutputSettingsField" + (string)$i)` )
				{
					$commonIndex = $surfaceSamplingMayaCommonSettingsIndex;
				}
			
				$cmd += "-mapOutput " + $mapNames[ $mapType ] + " ";
			
				int $mapWidth = `optionVar -q ("surfaceSamplingMapWidthOption" + (string)$commonIndex)`;
				$cmd += "-mapWidth " + $mapWidth + " ";

				int $mapHeight = `optionVar -q ("surfaceSamplingMapHeightOption" + (string)$commonIndex)`;
				$cmd += "-mapHeight " + $mapHeight + " ";

				float $maxValue = `optionVar -q ("surfaceSamplingMaxValueOption" + (string)$i)`;
				$cmd += "-max " + $maxValue + " ";

				int $mapSpace = `optionVar -q ("surfaceSamplingMapSpaceOption" + (string)$i)` - 1;
				$cmd += "-mapSpace " + $mapSpaces[ $mapSpace] + " ";
				
				int $mapMaterials = `optionVar -q ("surfaceSamplingMapMaterialsOption" + (string)$i)`;
				$cmd += "-mapMaterials " + $mapMaterials + " ";
				
				int $includeShadows = `optionVar -q ("surfaceSamplingIncludeShadowsOption" + (string)$i)`;
				$cmd += "-shadows " + $includeShadows + " ";
				
				string $name = stripExtension( `optionVar -q ("surfaceSamplingFileNameOption" + (string)$i)`, 0);
				$cmd += "-filename \"" + $name + "\" ";

				int $mapExtension = `optionVar -q ("surfaceSamplingExtensionOption" + (string)$i)`;
				string $extension = $gSurfaceSamplerMayaFileExtensions[$mapExtension];
				$cmd += "-fileFormat \"" + $extension + "\" ";
				
				// Write the full path back to the environment variable to make sure we always
				// hook the file texture node up to the file that was just written (in case old
				// prefs or UI focus anomolies leave the file name without the correct extension)
				//
				optionVar -stringValue ("surfaceSamplingFileNameOption" + (string)$i) ($name + "." + $extension);
			}		
		}
		$i++;
	}

	// Add our algorithm/quality/rendering options
	//
	if( $transferSpace == 1)
	{
		$cmd += "-ignoreTransforms true ";
	}

	int $superSampling = `optionVar -q surfaceSamplingSuperSamplingOption` - 1;
	$cmd += "-superSampling " + $superSampling + " ";

	int $filterType = `optionVar -q surfaceSamplingFilterTypeOption` - 1;
	$cmd += "-filterType " + $filterType + " ";

	float $filterSize = `optionVar -q surfaceSamplingFilterSizeOption`;
	$cmd += "-filterSize " + $filterSize + " ";

	int $FillTextureSeams = `optionVar -q surfaceSamplingFillTextureSeamsOption`;
	$cmd += "-overscan " + $FillTextureSeams + " ";

	int $searchMethod = `optionVar -q surfaceSamplingSearchMethodOption` - 1;
	$cmd += "-searchMethod " + $searchMethod + " ";

	int $matchBasedOn = `optionVar -q surfaceSamplingMatchBasedOnOption` - 1;
	$cmd += "-useGeometryNormals " + ($matchBasedOn == 0) + " ";

	int $ignoreMirroredFaces = `optionVar -q surfaceSamplingIgnoreMirroredFacesOption`;
	$cmd += "-ignoreMirroredFaces " + $ignoreMirroredFaces + " ";

	int $flipU = `optionVar -q surfaceSamplingFlipUOption`;
	$cmd += "-flipU " + $flipU + " ";

	int $flipV = `optionVar -q surfaceSamplingFlipVOption`;
	$cmd += "-flipV " + $flipV + " ";

	return $cmd;
}


//
// Handle a change in the file extension
//	
global proc surfaceSamplerFileFormatChangeCB( int $index, int $usesMentalRay, int $updateFilename)
{
	global string $gSurfaceSamplerMayaFileExtensions[];
	global string $gSurfaceSamplerMentalFileExtensions[];
	
    // only tif supports 16/32 bits per channel
    //
    if( $usesMentalRay )
    {
		int $selectedIndex = `optionMenuGrp -q -select ("surfaceSamplingFileFormatMenu" + (string)$index)`;
		if( $selectedIndex == 1 )
		{
			optionMenuGrp 
				-edit 
				-enable true 
				("surfaceSamplingMentalBitsPerChannel" + (string)$index) ;
		}
		else
		{
			optionMenuGrp -edit -select 1 ("surfaceSamplingMentalBitsPerChannel" + (string)$index) ;
			optionMenuGrp -edit -enable false ("surfaceSamplingMentalBitsPerChannel" + (string)$index) ;
		}
	}
	
	if( $updateFilename)
	{
		// Update our file name for the new extension
		//
		string $filename = stripExtension( 
							`textFieldGrp -q -text ("surfaceSamplingFileName" + (string)$index)`, 
							$usesMentalRay);
		int $type = `optionMenuGrp -q -select ("surfaceSamplingFileFormatMenu" + (string)$index)`;
		string $extension;
		if( $usesMentalRay)
			$extension = $gSurfaceSamplerMentalFileExtensions[$type];
		else
			$extension = $gSurfaceSamplerMayaFileExtensions[$type];
		textFieldGrp -e
			-text ($filename + "." + $extension)
			("surfaceSamplingFileName" + (string)$index);
	}
}


//
// Process a new file name
//
global proc surfaceSamplerFileNameCB( int $index, int $usesMentalRay, string $filename)
{	
	global string $gSurfaceSamplerMayaFileExtensions[];
	global string $gSurfaceSamplerMentalFileExtensions[];

	// See if this filename has an extension on it we recognise
	//
	int $type = 0;
	string $extension;
	string $buffer[];
	int $nTokens = `tokenize $filename "." $buffer`;
	if ( $nTokens >= 2 )
	{
		$type = identifyExtension( $buffer[$nTokens - 1], $usesMentalRay);
		if( $type > 0)
		{
			int $extSize = `size $buffer[$nTokens - 1]`;
			int $nameSize = `size $filename`;
			$filename = `substring $filename 1 ( $nameSize - $extSize - 1 )`;
			$extension = $buffer[$nTokens - 1];
		}
	}

	if( $type > 0)
	{
		// If we found an extension, update the type dropdown to match it	
		//
		optionMenuGrp -e
			-select $type
			("surfaceSamplingFileFormatMenu" + (string)$index);		
		surfaceSamplerFileFormatChangeCB( $index, $usesMentalRay, 0);
	}
	else
	{
		// If we can't find an extension in the filename, use the current
		// value of the extension dropdown	
		//
		$type = `optionMenuGrp -q -select ("surfaceSamplingFileFormatMenu" + (string)$index)`;
		if( $usesMentalRay)
			$extension = $gSurfaceSamplerMentalFileExtensions[$type];
		else
			$extension = $gSurfaceSamplerMayaFileExtensions[$type];
	}

	textFieldGrp -e
		-text ($filename + "." + $extension)
		("surfaceSamplingFileName" + (string)$index);
}


//
// Process the results of a "Save As" file browser
//
global proc surfaceSamplerFileDialogCB( int $index, int $usesMentalRay, string $filename, string $fileType )
{	
	// Tack on a default extension if the user left the default image type
	// and has not typed in a recogniseable extension
	//
	if ( $fileType == "image" )
	{
		string $buffer[];
		int $nTokens = `tokenize $filename "." $buffer`;
		if ( $nTokens < 2 || identifyExtension( $buffer[$nTokens - 1], $usesMentalRay) <= 0)
			$filename = $filename + "." + "iff";
	}
		
	// Now update the filename and let the filename box callback update itself
	//
	surfaceSamplerFileNameCB( $index, $usesMentalRay, $filename);
}


proc buildCommonOutputSettingsWidgets( int $index, int $allowShaderConnection, int $forMental )
//
// Description: builds the UI widgets for the settings common to all the output map types
// $index - The index number to use when building the widgets
// $allowShaderConnection - True to expose this through the UI
// $forMental - True if its for a mental output map, false for a maya output map. 
//
{
	global float $surfaceSamplingAspectRatio[];

	int $indent = 170;

	intSliderGrp 
		-columnWidth 1 $indent
		-label (uiRes("m_performSurfaceSampling.kMapwidth")) 
		-field true
       	-minValue 16 -maxValue 4096
        -fieldMinValue 16 -fieldMaxValue 4096
        -dragCommand ("surfaceSamplingChangeXResolutionDragCmd #1 " + (string)$index)
		-changeCommand ("surfaceSamplingChangeXResolutionChCmd #1 " + (string)$index)
        -value 256 
        ("surfaceSamplingWidthField" + (string)$index);

	intSliderGrp 
		-columnWidth 1 $indent
		-label (uiRes("m_performSurfaceSampling.kMapheight"))
		-field true
       	-minValue 16 -maxValue 4096
        -fieldMinValue 16 -fieldMaxValue 4096
        -dragCommand ("surfaceSamplingChangeYResolutionDragCmd #1 " + (string)$index)
		-changeCommand ("surfaceSamplingChangeYResolutionChCmd #1 " + (string)$index)
        -value 256 
        ("surfaceSamplingHeightField" + (string)$index);

	checkBoxGrp 
		-numberOfCheckBoxes 1 
		-columnWidth 1 $indent
		-label (uiRes("m_performSurfaceSampling.kKeepAspectRatio"))
		-value1 1
		-cc1 ("surfaceSamplingLockAspectRatioCmd #1 " + (string)$index)
		("surfaceSamplingAspectRatioChkBox" + (string)$index);
		
	$surfaceSamplingAspectRatio[$index] = 1.0;
}


global proc customShaderButtonCB( int $index )
{
	string $shaderName = `textFieldGrp -q -text ("surfaceSamplingCustomShader" + (string)$index)`;
	string $newLabel = (uiRes("m_performSurfaceSampling.kEditCustomShader"));
	if( size($shaderName) == 0 )
	{	
		string $textBoxName = ("surfaceSamplingCustomShader" + (string)$index);
		string $buttonName = ("surfaceSamplingCustomShaderButton" + (string)$index);
		createRenderNode -allWithMentalUp ( "textFieldGrp -e -text %node " + $textBoxName + "; button -e -label \\\"" + $newLabel + "\\\" " + $buttonName ) "";
	}
	else
	{
		button -e -label $newLabel ("surfaceSamplingCustomShaderButton" + (string)$index);
		select -r $shaderName;
	}	
}

global proc customShaderTextboxCB( int $index )
{
	string $text = `textFieldGrp -q -text ("surfaceSamplingCustomShader" + (string)$index)`;
	if( size( $text ) == 0 )
		button -e -label (uiRes("m_performSurfaceSampling.kCreateCustomShader")) ("surfaceSamplingCustomShaderButton" + (string)$index);
	else 
		button -e -label (uiRes("m_performSurfaceSampling.kEditCustomShader")) ("surfaceSamplingCustomShaderButton" + (string)$index);
}

proc buildMapOutputFrame( string $name, int $index, int $hasSpace, int $needsMaxValue, int $needsSurfaceOrMaterial, 
						 int $needsShadows, int $needsOrthogonalReflection, int $allowShaderConnection, int $forMental, int $needsCamera, 
						 int $needsCustomShader, int $needsOcclusionRays, int $needsOcclusionFalloff)
{
	global string $gSurfaceSamplerMayaFileExtensions[];
	global string $gSurfaceSamplerMentalFileExtensions[];
	global float $surfaceSamplingAspectRatio[];
	global string $surfaceSamplingDefaultMapName[];
	global int $surfaceSamplingMrLensBakingItem;

	int $enabled = 1;
	int $indent = 170;

	frameLayout 
		-collapsable false
		-collapse false
		-marginWidth 0
		-marginHeight 6
		-lv false
		("surfaceSamplingOuterMapFrame" + (string)$index);	
	columnLayout ;

	rowLayout -nc 2 -co2 5 0 -cw2 350 93 -ct2 "left" "right";
	
	checkBox
		-label $name
		-value $enabled
		-onCommand  ("frameLayout -e -collapse false surfaceSamplingMapFrame" + (string)$index)
		-offCommand ("frameLayout -e -collapse true  surfaceSamplingMapFrame" + (string)$index)
		("surfaceSamplingEnableMap" + (string)$index);	

	button -label (uiRes("m_performSurfaceSampling.kRemoveMapItem")) -c ("evalDeferred( \"surfaceSamplingDeleteAndShiftMapOptionVars " + (string)$index + "\")");
		
	setParent ..;
		
	frameLayout 
		-collapsable true
		-collapse (1 - $enabled)
		-marginWidth 0
		-marginHeight 6
		-lv false
		-bv false 
		("surfaceSamplingMapFrame" + (string)$index);	

	columnLayout ;

	// File name
	//
	rowLayout
		-numberOfColumns 2
		-columnWidth2 420 60
		("surfaceSamplingRowLayout" + (string)$index);

	string $defaultExtension = "dds";
	if( $forMental)
		$defaultExtension = "tif";
			
	textFieldGrp
		-label $name
		-columnAttach 2 "both" 1
		-columnWidth 1 $indent
		-columnWidth 2 250
		-text ( getDefaultDir() + $surfaceSamplingDefaultMapName[ typeIndexFromString( $name ) ] + "." + $defaultExtension)
		-changeCommand ("surfaceSamplerFileNameCB " + (string)$index + " " + (string)$forMental + " \"#1\"" )
		("surfaceSamplingFileName" + (string)$index);

	string $selectStr = (uiRes("m_performSurfaceSampling.kSelect2"));
	symbolButton
		-command ("fileBrowser( \"surfaceSamplerFileDialogCB " + (string)$index + " " + (string)$forMental + "\", \""+$selectStr+"\", \"image\", 1 )")		
		-image "navButtonBrowse.png"
		("surfaceSamplingBrowseButton" + (string)$index);
	
	setParent ..;
	
	// File format
	//
	optionMenuGrp 
		-label (uiRes("m_performSurfaceSampling.kFileformat")) 
		-columnAlign 1 "right"
		-columnWidth 1 $indent
		("surfaceSamplingFileFormatMenu" + (string)$index);

	if( $forMental )
	{        
		// There are fewer file format options on 
		// the mr bakesets, than the surfaceSampler command
		//
		int $i = 1;
        menuItem -label (uiRes("m_performSurfaceSampling.kTIFF")); 
		$gSurfaceSamplerMentalFileExtensions[$i++] = "tif";
        menuItem -label (uiRes("m_performSurfaceSampling.kIFF")); 
		$gSurfaceSamplerMentalFileExtensions[$i++] = "iff";
        menuItem -label (uiRes("m_performSurfaceSampling.kJPG")); 
		$gSurfaceSamplerMentalFileExtensions[$i++] = "jpg";
        menuItem -label (uiRes("m_performSurfaceSampling.kRGB")); 
		$gSurfaceSamplerMentalFileExtensions[$i++] = "rgb";
        menuItem -label (uiRes("m_performSurfaceSampling.kRLA")); 
		$gSurfaceSamplerMentalFileExtensions[$i++] = "rla";
        menuItem -label (uiRes("m_performSurfaceSampling.kTGA")); 
		$gSurfaceSamplerMentalFileExtensions[$i++] = "tga";
        menuItem -label (uiRes("m_performSurfaceSampling.kBMP")); 
		$gSurfaceSamplerMentalFileExtensions[$i++] = "bmp";
        menuItem -label  (uiRes("m_performSurfaceSampling.kHDR")); 
		$gSurfaceSamplerMentalFileExtensions[$i++] = "hdr";
		
		optionMenuGrp 
			-e 
			-cc ("surfaceSamplerFileFormatChangeCB " + (string)$index + " 1 1")
			("surfaceSamplingFileFormatMenu" + (string)$index);
	}
	else
	{
		int $i = 1;
		menuItem -label (uiRes("m_performSurfaceSampling.kAliasPIX"));
		$gSurfaceSamplerMayaFileExtensions[$i++] = "pix";
		menuItem -label (uiRes("m_buildImageFormatsMenu.kCineon"));
		$gSurfaceSamplerMayaFileExtensions[$i++] = "cin";
		menuItem -label (uiRes("m_buildImageFormatsMenu.kDDS"));
		$gSurfaceSamplerMayaFileExtensions[$i++] = "dds";
		menuItem -label (uiRes("m_buildImageFormatsMenu.kEPS"));
		$gSurfaceSamplerMayaFileExtensions[$i++] = "eps";

		if ( !`about -evalVersion` )
		{
			menuItem -label (uiRes("m_performSurfaceSampling.kEXR"));
			$gSurfaceSamplerMayaFileExtensions[$i++] = "exr";
		}

		menuItem -label (uiRes("m_buildImageFormatsMenu.kGIF"));
		$gSurfaceSamplerMayaFileExtensions[$i++] = "gif";
		menuItem -label (uiRes("m_performSurfaceSampling.kJPEG"));
		$gSurfaceSamplerMayaFileExtensions[$i++] = "jpg";
		menuItem -label (uiRes("m_buildImageFormatsMenu.kMayaIFF"));
		$gSurfaceSamplerMayaFileExtensions[$i++] = "iff";
		menuItem -label (uiRes("m_performSurfaceSampling.kMayaImage"));
		$gSurfaceSamplerMayaFileExtensions[$i++] = "mi";
		menuItem -label (uiRes("m_performSurfaceSampling.kPhotoshop"));
		$gSurfaceSamplerMayaFileExtensions[$i++] = "psd";
		menuItem -label (uiRes("m_buildImageFormatsMenu.kPNG"));
		$gSurfaceSamplerMayaFileExtensions[$i++] = "png";
		menuItem -label (uiRes("m_buildImageFormatsMenu.kQuantel"));
		$gSurfaceSamplerMayaFileExtensions[$i++] = "yuv";
		menuItem -label (uiRes("m_buildImageFormatsMenu.kRLA"));
		$gSurfaceSamplerMayaFileExtensions[$i++] = "rla";
		menuItem -label (uiRes("m_buildImageFormatsMenu.kSGI"));
		$gSurfaceSamplerMayaFileExtensions[$i++] = "sgi";
		menuItem -label (uiRes("m_performSurfaceSampling.kSiliconGraphics"));
		$gSurfaceSamplerMayaFileExtensions[$i++] = "rgb";
		menuItem -label (uiRes("m_buildImageFormatsMenu.kSoftImage"));
		$gSurfaceSamplerMayaFileExtensions[$i++] = "pic";
		menuItem -label (uiRes("m_performSurfaceSampling.kSonyPlaystation"));
		$gSurfaceSamplerMayaFileExtensions[$i++] = "tim";
		menuItem -label (uiRes("m_buildImageFormatsMenu.kTarga"));
		$gSurfaceSamplerMayaFileExtensions[$i++] = "tga";
		menuItem -label (uiRes("m_buildImageFormatsMenu.kTiff"));
		$gSurfaceSamplerMayaFileExtensions[$i++] = "tif";
		menuItem -label (uiRes("m_buildImageFormatsMenu.kWindowsBitmap"));
		$gSurfaceSamplerMayaFileExtensions[$i++] = "bmp";
	
		optionMenuGrp -e
			-select `ddsIndex`
			-cc ("surfaceSamplerFileFormatChangeCB " + (string)$index + " 0 1")
			("surfaceSamplingFileFormatMenu" + (string)$index);
	}

	// For mental we can also specify the number of bits/channel
	//
	optionMenuGrp 
		-label (uiRes("m_performSurfaceSampling.kTextureBitsPerChannel"))
		-columnAlign 1 "right"
		-columnWidth 1 $indent
		-enable ($forMental)
		-visible ($forMental)
		("surfaceSamplingMentalBitsPerChannel" + (string)$index) ;

    menuItem -label (uiRes("m_performSurfaceSampling.kTextureBits8")); 
    menuItem -label (uiRes("m_performSurfaceSampling.kTextureBits16")); 
    menuItem -label (uiRes("m_performSurfaceSampling.kTextureBits32")); 
		

	// For mental we can also choose whether to use light map or lens shader baking
	//
	optionMenuGrp 
		-label (uiRes("m_performSurfaceSampling.kOptimization"))
		-columnAlign 1 "right"
		-columnWidth 1 $indent
		-enable ($forMental)
		-visible ($forMental)
		("surfaceSamplingMentalOptimField" + (string)$index) ;

	// This menu needs to match the values of the optimization optionMenu for baking
    menuItem -label (uiRes("m_performSurfaceSampling.kOptimMultipleObjects")); 
    menuItem -label (uiRes("m_performSurfaceSampling.kOptimSingleObjects")); 
    
    // default to optimize for single object
    optionMenuGrp -edit -select $surfaceSamplingMrLensBakingItem ("surfaceSamplingMentalOptimField" + (string)$index) ;

	// Custom Shader
	//
	rowLayout
		-visible $needsCustomShader
		-numberOfColumns 2
		-columnWidth2 420 60
		("surfaceSamplingCustomShaderRowLayout" + (string)$index);
	
	textFieldGrp
		-label (uiRes("m_performSurfaceSampling.kCustomShaderTextLabel"))
		-visible $needsCustomShader
		-columnWidth 1 $indent
		-columnWidth 2 250				
		-cc ("customShaderTextboxCB " + (string)$index )
		("surfaceSamplingCustomShader" + (string)$index);

	button
		-visible $needsCustomShader
		-command ("customShaderButtonCB " + (string)$index )
		-label (uiRes("m_performSurfaceSampling.kCreateCustomShader"))
		("surfaceSamplingCustomShaderButton" + (string)$index);
	
	setParent ..;

	floatFieldGrp
		-label (uiRes("m_performSurfaceSampling.kMaximumValue"))
		-visible $needsMaxValue
		-columnWidth 1 $indent
		-numberOfFields 1
		-value1 1.0
		-precision 5
		("surfaceSamplingMaxValueField" + (string)$index);

	checkBoxGrp
		-label (uiRes("m_performSurfaceSampling.kIncludeMaterials"))
		-visible $needsSurfaceOrMaterial
		-columnWidth 1 $indent
		-value1 1
		("surfaceSamplingMapMaterialsField" + (string)$index);

	checkBoxGrp
		-label (uiRes("m_performSurfaceSampling.kIncludeShadows"))
		-visible $needsShadows
		-columnWidth 1 $indent
		-value1 1
		("surfaceSamplingIncludeShadowsField" + (string)$index);

	checkBoxGrp
		-label (uiRes("m_performSurfaceSampling.kTextureOrthogonalReflection"))
		-visible $needsOrthogonalReflection
		-columnWidth 1 $indent
		-value1 1
		("surfaceSamplingOrthReflectionField" + (string)$index);

	optionMenuGrp -visible $hasSpace -columnWidth 1 $indent -columnAlign 1 "right" -label (uiRes("m_performSurfaceSampling.kMapSapce")) ("surfaceSamplingMapSpaceMenu" + (string)$index);
	{
		menuItem -label (uiRes("m_performSurfaceSampling.kObjectSpaceinMap")) ("objectSpaceNormalsItem" + (string)$index);
		menuItem -label (uiRes("m_performSurfaceSampling.kTangentSpaceinMap")) ("tangentSpaceNormalsItem" + (string)$index);	
	}

	optionMenuGrp -e -select 2 ("surfaceSamplingMapSpaceMenu" + (string)$index);
		
	intSliderGrp 
		-visible $needsOcclusionRays
		-columnWidth 1 $indent
		-label (uiRes("m_performSurfaceSampling.kOcclusionRays")) 
		-field true
       	-minValue 0 -maxValue 256
		-fieldMinValue 0 -fieldMaxValue 2048
        -value 128
        ("surfaceSamplingOcclusionRays" + (string)$index);

	floatFieldGrp
		-visible $needsOcclusionFalloff
		-label (uiRes("m_performSurfaceSampling.kOcclusionFalloff"))
		-numberOfFields 1
		-value1 0
		-precision 4
		-columnWidth 1 $indent
		("surfaceSamplingOcclusionFalloff" + (string)$index);	

	optionMenuGrp
		-visible $needsCamera
		-columnAlign 1 "right"
		-columnWidth 1 $indent
		-label (uiRes("m_performSurfaceSampling.kCamera"))
		("surfaceSamplingCameraMenu" + (string)$index);
	
	string $cameras[] = `listCameras`;
	string $cam = "";

	for( $cam in $cameras )
		menuItem -label $cam;
	
	// Common settings
	//
	string $commonSettingsLabel = (uiRes("m_performSurfaceSampling.kUseMayaCommonSettings"));

	if( $forMental )
		$commonSettingsLabel = (uiRes("m_performSurfaceSampling.kUseMentalCommonSettings"));

	checkBoxGrp
		-label $commonSettingsLabel
		-value1 1
		-columnWidth 1 $indent
		-onCommand1 (" frameLayout -edit -collapse true " + "surfaceOverrideCommonOutputSettingsFrame" + (string)$index )
		-offCommand1 (" frameLayout -edit -collapse false " + "surfaceOverrideCommonOutputSettingsFrame" + (string)$index )
		("surfaceSamplingUseCommonOutputSettingsField" + (string)$index);

	frameLayout 
		-collapsable true
		-collapse true
		-marginWidth 0
		-marginHeight 6
		-lv false
		-bv false 
		("surfaceOverrideCommonOutputSettingsFrame" + (string)$index);	

	columnLayout;

	rowLayout 
		-numberOfColumns 1
		-columnAlign1  "center" ;

	separator -hr true -h 12;

	setParent ..;

	buildCommonOutputSettingsWidgets( $index, $allowShaderConnection, $forMental ) ;

	setParent ..;
	setParent ..;
	setParent ..;
	setParent ..;
	setParent ..;
	setParent ..;
}


proc buildMapOutputFrameByType( int $type, int $index )
//
// Description: Builds a layout + UI widgets appropriate for the given type.
//
{
	global string $surfaceSamplingMapTypeNames[];
	global int $surfaceSamplingNormalType;
	global int $surfaceSamplingDisplacementType;
	global int $surfaceSamplingDiffuseColorType;
	global int $surfaceSamplingLitAndShadeColorType;
	global int $surfaceSamplingAlphaType;
	global int $surfaceSamplingAmbientOcclusionType;
	global int $surfaceSamplingCustomType;

	int $hasSpace = ( $type == $surfaceSamplingNormalType) ;
	int $needsMaxValue = ( $type == $surfaceSamplingDisplacementType) ;
	int $needsSurfaceOrMaterial = ( $type == $surfaceSamplingNormalType ) ;
	int $needsShadows = ( $type == $surfaceSamplingLitAndShadeColorType || $type == $surfaceSamplingCustomType); 
	int $needsOrthogonalReflection = ( $type == $surfaceSamplingCustomType ); 
	int $forMental = ($type == $surfaceSamplingAmbientOcclusionType || $type == $surfaceSamplingCustomType);
	int $needsCamera = ($type == $surfaceSamplingCustomType);
	int $needsCustomShader = ($type == $surfaceSamplingCustomType);
	int $needsOcclusionRays = ($type == $surfaceSamplingAmbientOcclusionType);
	int $needsOcclusionFalloff = ($type == $surfaceSamplingAmbientOcclusionType);
	int $allowShaderConnection = true;

	buildMapOutputFrame(	$surfaceSamplingMapTypeNames[ $type ], 
							$index,  
							$hasSpace, 
							$needsMaxValue, 
							$needsSurfaceOrMaterial, 
							$needsShadows, 
							$needsOrthogonalReflection,
							$allowShaderConnection,
							$forMental,
							$needsCamera,
							$needsCustomShader,
							$needsOcclusionRays,
							$needsOcclusionFalloff);
}


proc deleteOutputMapWidgets( string $parent )
{
	setParent $parent;
	global int $surfaceSamplingOutputArraySize;
	global int $surfaceSamplingFirstOutputMap;

	// Don't delete the UI for the common widgets
	//
	int $i = $surfaceSamplingFirstOutputMap;

	// Delete each output frame
	while( $i < $surfaceSamplingOutputArraySize )
	{
		deleteUI -layout ("surfaceSamplingOuterMapFrame" + (string)$i);
		$i++;
	}
}


proc int getCameraIndex( string $camName, int $index )
{
	// For cameras, we need to make sure first that the one in the
	// optionvar is still valid.
	string $items[] = `optionMenuGrp -q -itemListLong ("surfaceSamplingCameraMenu" + (string)$index)`;
	int $i = 0;
	for ($i=0 ; $i<size($items) ; $i++)
	{
		string $label = `menuItem -q -label $items[$i]`;
		if ($camName == $label)
			return $i + 1;
	}
	return -1;
}


global proc surfaceSamplingSetUIFromOptionVars( string $parent, int $forceFactorySettings )
//
// Description:
//		Set the UI values to match the current optionVars
//
{
	global int $surfaceSamplingOutputArraySize;
	

	surfaceSamplingCreateOrResetOptionVars ( $forceFactorySettings );

	string $outputsLayout = "surfaceSampingOutputsColumn";
	setParent $outputsLayout ;

	deleteOutputMapWidgets( $outputsLayout );

	// Output Map options
	//
	$surfaceSamplingOutputArraySize = `optionVar -q "surfaceSamplingOutputArraySize"`;

	global int $surfaceSamplingMayaCommonSettingsIndex;
	global int $surfaceSamplingMentalCommonSettingsIndex;
	global int $surfaceSamplingFirstOutputMap;


	// first have to build all of the UI widgets.
	// (common frames are already built)
	//
	int $i = $surfaceSamplingFirstOutputMap;
	while( $i < $surfaceSamplingOutputArraySize)
	{
		int $mapType = `optionVar -q ("surfaceSamplingType" + (string)$i)`;		
		buildMapOutputFrameByType( $mapType, $i );
		$i++;
	}

	$i = 0;

	while( $i < $surfaceSamplingOutputArraySize)
	{
		// $i < $surfaceSamplingFirstOutputMap are "magic" entries for the common settings. 
		// All the other slots represent the maps the user has setup. If we're handling a
		// real map, setup all the map-specific options
		//
		if( $i >= $surfaceSamplingFirstOutputMap )
		{
			// Orthogonal Reflection was moved out of the common settings, so it might not exist in the current form.  Default to true.
			// 
			int $orthogonalReflection = 1;
			if( `optionVar -exists ("surfaceSamplingOrthReflectionOption" + (string)$i)`)
				$orthogonalReflection = `optionVar -q ("surfaceSamplingOrthReflectionOption" + (string)$i)`;
			else
				optionVar -intValue ("surfaceSamplingOrthReflectionOption" + (string)$i) $orthogonalReflection;
				
			// common settings don't have the specialized options 
			//
			checkBox -e -value `optionVar -q ("surfaceSamplingEnableMapOption" + (string)$i)` ("surfaceSamplingEnableMap" + (string)$i);
			frameLayout -e -collapse (`optionVar -q ("surfaceSamplingEnableMapOption" + (string)$i)` == 0) ("surfaceSamplingMapFrame" + (string)$i);
			floatFieldGrp -e -value1 `optionVar -q ("surfaceSamplingMaxValueOption" + (string)$i)` ("surfaceSamplingMaxValueField" + (string)$i);
			optionMenuGrp -e -select `optionVar -q ("surfaceSamplingMapSpaceOption" + (string)$i)` ("surfaceSamplingMapSpaceMenu" + (string)$i);
			checkBoxGrp -e -value1 `optionVar -q ("surfaceSamplingMapMaterialsOption" + (string)$i)` ("surfaceSamplingMapMaterialsField" + (string)$i);
			checkBoxGrp -e -value1 `optionVar -q ("surfaceSamplingIncludeShadowsOption" + (string)$i)` ("surfaceSamplingIncludeShadowsField" + (string)$i);
			checkBoxGrp -e -value1 $orthogonalReflection ("surfaceSamplingOrthReflectionField" + (string)$i);
			textFieldGrp -e -text `optionVar -q ("surfaceSamplingFileNameOption" + (string)$i)` ("surfaceSamplingFileName" + (string)$i);
			int $fileExt = `optionVar -q ("surfaceSamplingExtensionOption" + (string)$i)`;
			optionMenuGrp -e -select $fileExt ("surfaceSamplingFileFormatMenu" + (string)$i);
			optionMenuGrp -e -select `optionVar -q ("surfaceSamplingMentalBitsPerChannel" + (string)$i)` ("surfaceSamplingMentalBitsPerChannel" + (string)$i);
			optionMenuGrp -e -select `optionVar -q ("surfaceSamplingMentalOptimOption" + (string)$i)` ("surfaceSamplingMentalOptimField" + (string)$i);
		
			intSliderGrp -e -value `optionVar -q ("surfaceSamplingOcclusionRays" + (string)$i)` ("surfaceSamplingOcclusionRays" + (string)$i);
			floatFieldGrp -e -value1 `optionVar -q ("surfaceSamplingOcclusionFalloff" + (string)$i)` ("surfaceSamplingOcclusionFalloff" + (string)$i);

			// if the value exists use it, otherwise it should default to 1 not 0.
			int $useCommonSettings = 1 ;

			if( `optionVar -ex ("surfaceSamplingUseCommonOutputSettingsField" + (string)$i)` )
				$useCommonSettings = `optionVar -q ("surfaceSamplingUseCommonOutputSettingsField" + (string)$i)` ;

			checkBoxGrp -e -value1 $useCommonSettings ("surfaceSamplingUseCommonOutputSettingsField" + (string)$i) ;

			// setting the value of the checkbox doesn't trigger the callbacks we have setup on it
			// so manually show/hide the common settings layout.
			frameLayout -e -collapse $useCommonSettings ("surfaceOverrideCommonOutputSettingsFrame" + (string)$i) ;

			string $customShader = `optionVar -q ("surfaceSamplingCustomShaderName" + (string)$i)`;
			string $nodes[] = `ls $customShader`;

			if( size($nodes) > 0 )
			{
				textFieldGrp -e -text `optionVar -q ("surfaceSamplingCustomShaderName" + (string)$i)` ("surfaceSamplingCustomShader" + (string)$i);
				customShaderButtonCB $i;
			}
			else
				textFieldGrp -e -text "" ("surfaceSamplingCustomShader" + (string)$i);

			string $cam = `optionVar -q ("surfaceSamplingCameraName" + (string)$i)`;
			int $camIndex = 1;
			if( size( `ls $cam`) != 0 )
				$camIndex = getCameraIndex( $cam, $i );

			optionMenuGrp -e -select $camIndex ("surfaceSamplingCameraMenu" + (string)$i);
		}

		// Handle the common options
		//
		intSliderGrp -e -value `optionVar -q ("surfaceSamplingMapWidthOption" + (string)$i)` ("surfaceSamplingWidthField" + (string)$i);
		intSliderGrp -e -value `optionVar -q ("surfaceSamplingMapHeightOption" + (string)$i)` ("surfaceSamplingHeightField" + (string)$i);
		checkBoxGrp -e -value1 `optionVar -q ("surfaceSamplingLockAspectRatioOption" + (string)$i)` ("surfaceSamplingAspectRatioChkBox" + (string)$i);

		$i++;
	}

	setParent $parent;

	// Shader connection options
	//
	int $enableShaderConnection = `optionVar -q surfaceSamplingShaderConnectionOption`;
	checkBoxGrp -e -value1 ($enableShaderConnection > 0) surfaceSamplingEnableShaderConnection;
	if( $enableShaderConnection > 0)
		radioButtonGrp -e -enable true -select $enableShaderConnection surfaceSamplingShaderConnection;
	else
		radioButtonGrp -e -enable false surfaceSamplingShaderConnection;
	
	
	// Algorithm options
	//
	optionMenuGrp -e -select `optionVar -q surfaceSamplingTransferSpaceOption` surfaceSamplingTransferSpaceMenu;
	optionMenuGrp -e -select `optionVar -q surfaceSamplingSuperSamplingOption` surfaceSamplingSuperSamplingMenu;
	floatSliderGrp -e -value `optionVar -q surfaceSamplingFilterSizeOption` surfaceSamplingFilterSizeField;
	optionMenuGrp -e -select `optionVar -q surfaceSamplingFilterTypeOption` surfaceSamplingFilterTypeMenu;
	intFieldGrp -e -value1 `optionVar -q surfaceSamplingFillTextureSeamsOption` surfaceSamplingFillTextureSeamsField;
	optionMenuGrp -e -select `optionVar -q surfaceSamplingSearchMethodOption` surfaceSamplingSearchMethodMenu;
	optionMenuGrp -e -select `optionVar -q surfaceSamplingMatchBasedOnOption` surfaceSamplingMatchBasedOnMenu;
	floatSliderGrp -e -value `optionVar -q surfaceSamplingMaxSearchDistanceOption` surfaceSamplingMaxSearchDistanceField;
	checkBoxGrp -e -value1 `optionVar -q surfaceSamplingDeleteCagesOption` surfaceSamplingDeleteCagesField;
	checkBoxGrp -e -value1 `optionVar -q surfaceSamplingIgnoreMirroredFacesOption` surfaceSamplingIgnoreMirroredFacesField;
	checkBoxGrp -e -value1 `optionVar -q surfaceSamplingFlipUOption` surfaceSamplingFlipUField;
	checkBoxGrp -e -value1 `optionVar -q surfaceSamplingFlipVOption` surfaceSamplingFlipVField;

	// mental ray bake set options
	//
	optionMenuGrp -e -select `optionVar -q surfaceSamplingMentalNormalDirection` surfaceSamplingMentalNormalDirectionCtrl;
	intSliderGrp -e -value `optionVar -q surfaceSamplingMentalSamples` surfaceSamplingMentalSamplesCtrl;
	checkBoxGrp -e -value1 `optionVar -q surfaceSamplingMentalAlpha` surfaceSamplingMentalAlphaCtrl;
	optionMenuGrp -e -select `optionVar -q surfaceSamplingMentalAlphaMode` surfaceSamplingMentalAlphaModeCtrl;
	floatSliderGrp -e -value `optionVar -q surfaceSamplingMentalFinalGatherQuality` surfaceSamplingMentalFinalGatherQualityCtrl;
	floatSliderGrp -e -value `optionVar -q surfaceSamplingMentalFinalGatherReflect` surfaceSamplingMentalFinalGatherReflectCtrl;
	optionMenuGrp -e -select `optionVar -q surfaceSamplingMentalUVRange` surfaceSamplingMentalUVRangeCtrl;
	
	// mental ray algorithm options
	//
	optionMenuGrp -e -select `optionVar -q surfaceSamplingMentalTransferSpaceOption` surfaceSamplingMentalTransferSpaceCtrl;

	// manually call the callback on the uvrange
	MentalUVRangeChangeCB( `optionMenuGrp -q -select surfaceSamplingMentalUVRangeCtrl` );

	floatSliderGrp -e -value `optionVar -q surfaceSamplingMentalUMin` surfaceSamplingMentalUMinCtrl;
	floatSliderGrp -e -value `optionVar -q surfaceSamplingMentalUMax` surfaceSamplingMentalUMaxCtrl;
	floatSliderGrp -e -value `optionVar -q surfaceSamplingMentalVMin` surfaceSamplingMentalVMinCtrl;
	floatSliderGrp -e -value `optionVar -q surfaceSamplingMentalVMax` surfaceSamplingMentalVMaxCtrl;
	floatSliderGrp -e -value `optionVar -q surfaceSamplingMentalFillTextureSeams` surfaceSamplingMentalFillTextureSeamsCtrl;
}


global proc surfaceSamplingDeleteAndShiftMapOptionVars( int $index )
//
// Description: removes $index-th element in the option vars, and rebuilds the UI. 
//
{

	$parentLayout = "surfaceSamplingTopFormFrame";

	// Make sure we're not trying to delete the common settings
	global int $surfaceSamplingFirstOutputMap;
	if( $index < $surfaceSamplingFirstOutputMap )
	{
		return;
	}
	
	// first save the UI settings to the option vars
	surfaceSamplingSetOptionVarsFromUI( $parentLayout ); 

	// shift all the option vars starting at index+1 to index.
	global float $surfaceSamplingAspectRatio[];
	int $arraySize = `optionVar -q "surfaceSamplingOutputArraySize"`;

	int $i = 0;
	for( $i = $index; $i < $arraySize-1; $i++ )
	{
		int $enabled = `optionVar -q ("surfaceSamplingEnableMapOption" + (string)($i+1))`;
		optionVar -intValue ("surfaceSamplingEnableMapOption" + (string)$i) $enabled; 

		float $maxValue = `optionVar -q ("surfaceSamplingMaxValueOption" + (string)($i+1))`;
		optionVar -floatValue ("surfaceSamplingMaxValueOption" + (string)$i) $maxValue;

		int $mapSpace = `optionVar -q ("surfaceSamplingMapSpaceOption" + (string)($i+1))`;
		optionVar -intValue ("surfaceSamplingMapSpaceOption" + (string)$i) $mapSpace;

		int $mapMaterials = `optionVar -q ("surfaceSamplingMapMaterialsOption" + (string)($i+1))`;
		optionVar -intValue ("surfaceSamplingMapMaterialsOption" + (string)$i) $mapMaterials;
		
		int $includeShadows = `optionVar -q ("surfaceSamplingIncludeShadowsOption" + (string)($i+1))`;
		optionVar -intValue ("surfaceSamplingIncludeShadowsOption" + (string)$i) $includeShadows;
		
		string $name = `optionVar -q ("surfaceSamplingFileNameOption" + (string)($i+1))`;
		optionVar -stringValue ("surfaceSamplingFileNameOption" + (string)$i) $name;

		int $mapExtension = `optionVar -q ("surfaceSamplingExtensionOption" + (string)($i+1))`;
		optionVar -intValue ("surfaceSamplingExtensionOption" + (string)$i) $mapExtension;
		
		int $bitsPerChannel = `optionVar -q ("surfaceSamplingMentalBitsPerChannel" + (string)($i+1))`;
		optionVar -intValue ("surfaceSamplingMentalBitsPerChannel" + (string)$i) $bitsPerChannel;		

		int $optimization = `optionVar -q ("surfaceSamplingMentalOptimOption" + (string)($i+1))`;
		optionVar -intValue ("surfaceSamplingMentalOptimOption" + (string)$i) $optimization;		

		int $useCommonOutputSettings = `optionVar -q ("surfaceSamplingUseCommonOutputSettingsField" + (string)($i+1))`;
		optionVar -intValue ("surfaceSamplingUseCommonOutputSettingsField" + (string)$i) $useCommonOutputSettings;

		int $typeIndex = `optionVar -q ("surfaceSamplingType" + (string)($i+1))`;
		optionVar -intValue ("surfaceSamplingType" + (string)$i) $typeIndex;

		string $customShaderName = `optionVar -q ("surfaceSamplingCustomShaderName" + (string)($i+1))`;
		optionVar -stringValue ("surfaceSamplingCustomShaderName" + (string)$i) $customShaderName;

		int $orthogonalReflection = `optionVar -q ("surfaceSamplingOrthReflectionOption" + (string)($i+1))`;
		optionVar -intValue ("surfaceSamplingOrthReflectionOption" + (string)$i) $orthogonalReflection;
		
		string $camName = `optionVar -q ("surfaceSamplingCameraName" + (string)($i+1))`;
		optionVar -stringValue ("surfaceSamplingCameraName" + (string)$i) $camName;
		
		int $mapWidth = `optionVar -q ("surfaceSamplingMapWidthOption" + (string)($i+1))`;
		optionVar -intValue ("surfaceSamplingMapWidthOption" + (string)$i) $mapWidth;

		int $mapHeight = `optionVar -q ("surfaceSamplingMapHeightOption" + (string)($i+1))`;
		optionVar -intValue ("surfaceSamplingMapHeightOption" + (string)$i) $mapHeight;

		int $lockAspect = `optionVar -q ("surfaceSamplingLockAspectRatioOption" + (string)($i+1))`;
		optionVar -intValue ("surfaceSamplingLockAspectRatioOption" + (string)$i) $lockAspect; 

		int $postBake = `optionVar -q ("surfaceSamplingPostBakeOption" + (string)($i+1))`;
		optionVar -intValue ("surfaceSamplingPostBakeOption" + (string)$i) $postBake;

		// we will have to adjust the "aspectRatio" array too.
		$surfaceSamplingAspectRatio[$i] = $surfaceSamplingAspectRatio[($i+1)];
	}

	$surfaceSamplingAspectRatio[$arraySize-1] = -1; // Hmmm is there a way to delete elements in arrays in MEL?

	// delete the end
	deleteMapOptionVars( $arraySize - 1 );
	
	// resize the array
	$arraySize--;
	optionVar -intValue surfaceSamplingOutputArraySize $arraySize;

	// rebuild the UI
	surfaceSamplingSetUIFromOptionVars( $parentLayout, false );
}


global proc addMapUIFrame( int $type )
{
	global int $surfaceSamplingOutputArraySize;
	global string $surfaceSamplingMapTypeNames[];

	setParent surfaceSampingOutputsColumn;
	buildMapOutputFrameByType( $type, $surfaceSamplingOutputArraySize++ );
}


proc buildOutputsFrame()
{
	global int $surfaceSamplingNormalType;
	global int $surfaceSamplingDisplacementType;
	global int $surfaceSamplingDiffuseColorType;
	global int $surfaceSamplingLitAndShadeColorType;
	global int $surfaceSamplingAlphaType;
	global int $surfaceSamplingAmbientOcclusionType;

	frameLayout 
		-collapsable true
		-collapse false
		-label (uiRes("m_performSurfaceSampling.kOutputs"))
		-marginHeight 6
		surfaceSamplingOutputsFrame;	

	columnLayout -rs 1 surfaceSampingOutputsColumn ;

	rowLayout -nc 7 
		-cat 1 "right" 5
		-cat 2 "right" 5
		-cat 3 "right" 5
		-cat 4 "right" 5
		-cat 5 "right" 5
		-cat 6 "right" 5;

	iconTextButton -style "iconAndTextVertical"
		-label (uiRes("m_performSurfaceSampling.kNormalOutput"))
		-image1 "normalMap_64.png"
		-ann (uiRes("m_performSurfaceSampling.kAddNormalMap"))
		-c "addMapUIFrame 0";

	iconTextButton -style "iconAndTextVertical"
		-label (uiRes("m_performSurfaceSampling.kDisplacementOutput"))
		-image1 "displacementMap_64.png"
		-ann (uiRes("m_performSurfaceSampling.kAddDisplacementMap"))
		-c "addMapUIFrame 1";

	iconTextButton -style "iconAndTextVertical"
		-label (uiRes("m_performSurfaceSampling.kDiffuseOutput"))
		-image1 "diffuseMap_64.png"
		-ann (uiRes("m_performSurfaceSampling.kAddDiffuseMap"))
		-c "addMapUIFrame 2";

	iconTextButton -style "iconAndTextVertical"
		-label (uiRes("m_performSurfaceSampling.kLitAndShadedColorOutput"))
		-image1 "litshadedMap_64.png"
		-ann (uiRes("m_performSurfaceSampling.kAddLitAndShadedColorMap"))
		-c "addMapUIFrame 3";

	iconTextButton -style "iconAndTextVertical"
		-label (uiRes("m_performSurfaceSampling.kAlphaOutput"))
		-image1 "transparentMap_64.png"
		-ann (uiRes("m_performSurfaceSampling.kAddAlphaMap"))
		-c "addMapUIFrame 4";

	iconTextButton -style "iconAndTextVertical"
		-label (uiRes("m_performSurfaceSampling.kAmbientOcclusionOutput"))
		-image1 "occlusionMap_64.png"
		-ann (uiRes("m_performSurfaceSampling.kAddAmbientOcclusionMap"))
		-c "addMapUIFrame 5"
		-visible 0
		ambientOcclusionOutputIcontTextButton;

	iconTextButton -style "iconAndTextVertical"
		-label (uiRes("m_performSurfaceSampling.kCustomOutput"))
		-image1 "customMap_64.png"
		-ann (uiRes("m_performSurfaceSampling.kAddCustomMap"))
		-c "addMapUIFrame 6"
		-visible 0
		customOutputIcontTextButton;

	setParent ..;

	setParent ..;
	setParent ..;
}


proc buildConnectMapsFrame()
{
	frameLayout 
		-collapsable true
		-collapse false
		-label (uiRes("m_performSurfaceSampling.kConnectOutputMaps"))
		-marginHeight 6
		surfaceSamplingConnectMapsFrame;
		
	columnLayout;
	
	checkBoxGrp
		-numberOfCheckBoxes 1
		-value1 1
		-label (uiRes("m_performSurfaceSampling.kConnectMapsToShader"))
		-onc "radioButtonGrp -e -enable 1 surfaceSamplingShaderConnection"
		-ofc "radioButtonGrp -e -enable 0 surfaceSamplingShaderConnection"
		surfaceSamplingEnableShaderConnection;
	
	radioButtonGrp -numberOfRadioButtons 2
		-select 1
 		-label (uiRes("m_performSurfaceSampling.kConnectMapsTo"))
 		-labelArray2 (uiRes("m_performSurfaceSampling.kConnectToNewShader")) 
 					 (uiRes("m_performSurfaceSampling.kConnectToAssignedShader"))
 		-vertical
 		surfaceSamplingShaderConnection;
 		
 	setParent ..;
	setParent ..;
}


global proc surfaceSamplingSetSearchSpace( int $space)
{
	global string $surfaceSamplingTargetList[];
	global int $surfaceSamplingTargetListSize;
	global int $surfaceSamplingTargetNumElements;
	global string $surfaceSamplingSourceList[];
	global int $surfaceSamplingSourceListSize;
	global int $surfaceSamplingSourceNumElements;
	
	// Update the option var as any subsequent surfaces added have
	// their UI driven off this option var
	//
	if( $space < 0) $space = 0;
	optionVar -intValue surfaceSamplingTransferSpaceOption ($space + 1);
	
	// If the target UI exists
	//
	if( `control -exists surfaceSamplingTargetHeadings`)
	{
		// Remove the old optional column headings
		//
		if( `control -exists surfaceSamplingTargetUVSpaceHeading`) deleteUI surfaceSamplingTargetUVSpaceHeading;
		if( `control -exists surfaceSamplingDisplayHeading`) deleteUI surfaceSamplingDisplayHeading;
		if( `control -exists surfaceSamplingEnvelopeHeading`) deleteUI surfaceSamplingEnvelopeHeading;

		// Add the column headings for the options of this search space
		//
		setParent surfaceSamplingTargetHeadings;
		if( $space == 2)
		{
			text -fn "boldLabelFont" -label (uiRes("m_performSurfaceSampling.kTargetUVSpace")) surfaceSamplingTargetUVSpaceHeading;
		}
		else
		{
			text -al "left" -fn "boldLabelFont" -label (uiRes("m_performSurfaceSampling.kDisplay")) surfaceSamplingDisplayHeading;
			text -al "left" -fn "boldLabelFont" -label (uiRes("m_performSurfaceSampling.kSearchEnvelope")) surfaceSamplingEnvelopeHeading;
		}
		
		// Now for each target
		//
		int $target = 0;
		while( $target < $surfaceSamplingTargetListSize)
		{
			// Remove the optional UI 
			//
			if( `control -exists ("surfaceSamplingTargetUVSpaceMenu" + (string)$target)`) deleteUI ("surfaceSamplingTargetUVSpaceMenu" + (string)$target);
			if( `control -exists ("surfaceSamplingTargetDisplayMenu" + (string)$target)`) deleteUI ("surfaceSamplingTargetDisplayMenu" + (string)$target);
			if( `control -exists ("surfaceSamplingSearchOffsetSlider" + (string)$target)`) deleteUI ("surfaceSamplingSearchOffsetSlider" + (string)$target);
			
			// And add the UI widgets for the desired search space
			//
			setParent ("surfaceSamplingTargetEntryLayout" + (string)$target);
			if( $space == 2)
			{
				// UV transfer space
				//	
				surfaceSamplingBuildUVDropdown( $surfaceSamplingTargetList[ $target * $surfaceSamplingTargetNumElements], ("surfaceSamplingTargetUVSpaceMenu" + (string)$target));
			}
			else
			{
				// World/Object space == ray casting
				//
				surfaceSamplingAddTargetRayCastOptions( $target);
			}
			
			$target++;
		}	
	}

	// If the source UI exists
	//
	if( `control -exists surfaceSamplingSourceHeadings`)
	{
		// Remove the old optional column headings
		//
		if( `control -exists surfaceSamplingSourceUVSpaceHeading`) deleteUI surfaceSamplingSourceUVSpaceHeading;

		// Add the column headings for the options of this search space
		//
		setParent surfaceSamplingSourceHeadings;
		if( $space == 2)
		{
			text -fn "boldLabelFont" -label (uiRes("m_performSurfaceSampling.kSourceUVSpace")) surfaceSamplingSourceUVSpaceHeading;
		}
		else
		{
		}
		
		// Now for each source
		//
		int $source = 0;
		while( $source < $surfaceSamplingSourceListSize)
		{
			// Remove the optional UI 
			//
			if( `control -exists ("surfaceSamplingSourceUVSpaceMenu" + (string)$source)`) deleteUI ("surfaceSamplingSourceUVSpaceMenu" + (string)$source);
			
			// And add the UI widgets for the desired search space
			//
			setParent ("surfaceSamplingSourceEntryLayout" + (string)$source);
			if( $space == 2)
			{
				// UV transfer space
				//	
				surfaceSamplingBuildUVDropdown( $surfaceSamplingSourceList[ $source * $surfaceSamplingSourceNumElements], ("surfaceSamplingSourceUVSpaceMenu" + (string)$source));
			}
			else
			{
			}
			
			$source++;
		}	
	}

}


proc buildTargetSurfaceFrame()
{
	global int $surfaceSamplingTargetListSize;
	global int $surfaceSamplingTargetNumElements;
	
	// Create the list of destination surfaces
	//
	frameLayout 
		-collapsable true
		-collapse false
		-label (uiRes("m_performSurfaceSampling.kTargetSurfaces"))
		-marginHeight 6
		surfaceSamplingTargetSurfaceFrame;
	columnLayout;
	columnLayout surfaceSamplingTargetSurfaceLayout;

	// Headings
	rowColumnLayout  -cat 1 "left" 10 -nc 4 
							-columnWidth 1 120
							-columnWidth 2 120
							-columnWidth 3 100 
							-columnWidth 4 150 surfaceSamplingTargetHeadings;
	text -al "left" -w 100 -fn "boldLabelFont" -label (uiRes("m_performSurfaceSampling.kName"));
	text -al "left" -fn "boldLabelFont" -label (uiRes("m_performSurfaceSampling.kTargetUVSet"));
	setParent ..;
	rowColumnLayout  -cat 1 "left" 10 -nc 1;
	separator -hr true -h 12;
	setParent ..;

	// Buttons	
	setParent ..;
	rowColumnLayout  -cat 1 "left" 10 -nc 1;
	separator -hr true -h 12;
	setParent ..;
	rowLayout -nc 3 -cw3 150 150 150 -cl3 "center" "center" "center";
	button -label (uiRes("m_performSurfaceSampling.kAddSelectedButton")) -c "string $selection[] = `ls -sl -o`; for( $name in $selection) surfaceSamplingAddTargets( $name, true )";
	button -label (uiRes("m_performSurfaceSampling.kRemoveSelectedButton")) -c "string $selection[] = `ls -sl -o`; for( $name in $selection) surfaceSamplingRemoveTargetByPath( $name)";
	button -label (uiRes("m_performSurfaceSampling.kClearAllButton")) -c "global int $surfaceSamplingTargetListSize; while( $surfaceSamplingTargetListSize > 0) surfaceSamplingRemoveTarget( $surfaceSamplingTargetListSize - 1)";
	setParent ..;
	
	setParent ..;
	setParent ..;
}


proc buildSourceSurfaceFrame()
{
	global int $surfaceSamplingSourceListSize;
	global int $surfaceSamplingSourceNumElements;
	
	// Create the list of source surfaces
	//
	frameLayout 
		-collapsable true
		-collapse true
		-label (uiRes("m_performSurfaceSampling.kSourceSurfaces"))
		-marginHeight 6
		surfaceSamplingSrcSurfaceFrame;
	columnLayout;
	columnLayout surfaceSamplingSrcSurfaceLayout;
	
	// Headings
	rowColumnLayout  -cat 1 "left" 10 -nc 2 
							-columnWidth 1 200
							-columnWidth 2 120
							surfaceSamplingSourceHeadings;
	text -al "left" -w 100 -fn "boldLabelFont" -label (uiRes("m_performSurfaceSampling.kNameSS"));
	setParent ..;
	rowColumnLayout  -cat 1 "left" 10 -nc 1;
	separator -hr true -h 12;
	setParent ..;

	// Surfaces	
	surfaceSamplingWildcardSourcesOption( true );
	
	// Buttons	
	setParent ..;
	rowColumnLayout  -cat 1 "left" 10 -nc 1;
	separator -hr true -h 12;
	setParent ..;
	rowLayout -nc 4 -cw4 110 110 110 110 -cl4 "center" "center" "center" "center";
	button -label (uiRes("m_performSurfaceSampling.kAddSelectedButtons")) -c "string $selection[] = `ls -sl -o`; for( $name in $selection) surfaceSamplingAddSource( $name, true )";
	button -label (uiRes("m_performSurfaceSampling.kAddUnselectedButtons")) -c "	string $selection[] = `ls -sl -o`; string $allShapes[] = `ls -g -v -ni`; for( $shape in $allShapes) { int $isSelected = 0; for( $s in $selection) { if( $shape == $s) { $isSelected = 1; break; } } if( $isSelected == 0) surfaceSamplingAddSource( $shape, true ); } ";
	button -label (uiRes("m_performSurfaceSampling.kRemoveSelectedButtons")) -c "string $selection[] = `ls -sl -o`; for( $name in $selection) surfaceSamplingRemoveSourceByPath( $name)";
	button -label (uiRes("m_performSurfaceSampling.kClearAllButtons")) -c "global int $surfaceSamplingSourceListSize; while( $surfaceSamplingSourceListSize > 0) surfaceSamplingRemoveSource( $surfaceSamplingSourceListSize - 1)";
	setParent ..;	
	setParent ..;	
	setParent ..;	
}


proc buildAdvancedOptionsFrame()
{
	frameLayout 
		-collapsable true
		-collapse true
		-label (uiRes("m_performSurfaceSampling.kAdvancedOptions"))
		-marginHeight 6
		-bv true
		surfaceSamplingAdvancedFrame;	

	columnLayout;

		optionMenuGrp -label (uiRes("m_performSurfaceSampling.kSearchMethod")) surfaceSamplingSearchMethodMenu;
		{
			menuItem -label (uiRes("m_performSurfaceSampling.kClosettoenvelope"));
			menuItem -label (uiRes("m_performSurfaceSampling.kInsideenvelopethenoutside"));
			menuItem -label (uiRes("m_performSurfaceSampling.kInsideenvelopeonly"));
		}

		floatSliderGrp
			-label (uiRes("m_performSurfaceSampling.kMaxSearchDepth"))
			-min 0.0
			-max 100.0
			-value 30.0
			surfaceSamplingMaxSearchDistanceField;

		checkBoxGrp
			-label (uiRes("m_performSurfaceSampling.kDeleteEnvelopesonBake"))
			-value1 on
			surfaceSamplingDeleteCagesField;

		optionMenuGrp -visible on -label (uiRes("m_performSurfaceSampling.kMatchUsing")) surfaceSamplingMatchBasedOnMenu;
		{
			menuItem -label (uiRes("m_performSurfaceSampling.kGeometryNormals")) surfaceSamplingGeometryNormalsItem;
			menuItem -label (uiRes("m_performSurfaceSampling.kSurfaceNormals")) surfaceSamplingSurfaceNormalsItem;
		}

	setParent ..;
	setParent ..;
}

proc buildMayaCommonOutputFrame()
{
	frameLayout 
		-collapsable true
		-collapse true
		-label (uiRes("m_performSurfaceSampling.kMayaCommonOutput"))
		-marginHeight 6
		surfaceSamplingMayaCommonOutputFrame;	

	columnLayout;

	global int $surfaceSamplingMayaCommonSettingsIndex;
	buildCommonOutputSettingsWidgets( $surfaceSamplingMayaCommonSettingsIndex, true, false );

	separator; 

	optionMenuGrp 
		-label (uiRes("m_performSurfaceSampling.kTransferIn")) 
		-changeCommand "surfaceSamplingSetSearchSpace( `optionMenuGrp -q -select surfaceSamplingTransferSpaceMenu` - 1 )"
		surfaceSamplingTransferSpaceMenu;
	{
		menuItem -label (uiRes("m_performSurfaceSampling.kWorldSpace")) surfaceSamplingWorldSpaceTransferItem;
		menuItem -label (uiRes("m_performSurfaceSampling.kObjectSpace")) surfaceSamplingObjectSpaceTransferItem;
		menuItem -label (uiRes("m_performSurfaceSampling.kUVSpace")) surfaceSamplingUVSpaceTransferItem;
	}

	optionMenuGrp -label (uiRes("m_performSurfaceSampling.kSamplingQuality")) surfaceSamplingSuperSamplingMenu;
	{
		menuItem -label (uiRes("m_performSurfaceSampling.kPreview")) surfaceSamplingVeryLowQualitySamplingItem;
		menuItem -label (uiRes("m_performSurfaceSampling.kLow")) surfaceSamplingLowQualitySamplingItem;
		menuItem -label (uiRes("m_performSurfaceSampling.kMedium")) surfaceSamplingMediumQualitySamplingItem;
		menuItem -label (uiRes("m_performSurfaceSampling.kHigh")) surfaceSamplingHighQualitySamplingItem;
	}

	floatSliderGrp
		-label (uiRes("m_performSurfaceSampling.kFilterSize"))
		-min 1.0
		-max 8.0
		-value 3.0
		surfaceSamplingFilterSizeField;

	optionMenuGrp -label (uiRes("m_performSurfaceSampling.kFilterType")) surfaceSamplingFilterTypeMenu;
	{
		menuItem -label (uiRes("m_performSurfaceSampling.kGaussian")) surfaceSamplingGaussianFilterItem;
		menuItem -label (uiRes("m_performSurfaceSampling.kTriangular")) surfaceSamplingTriangularFilterItem;
		menuItem -label (uiRes("m_performSurfaceSampling.kBox")) surfaceSamplingBoxFilterItem;	
	}

	intFieldGrp
		-label (uiRes("m_performSurfaceSampling.kFillTextureSeams"))
		-numberOfFields 1
		-value1 1
		surfaceSamplingFillTextureSeamsField;

	checkBoxGrp
		-label (uiRes("m_performSurfaceSampling.kIgnoreMirroredFaces"))
		-value1 off
		surfaceSamplingIgnoreMirroredFacesField;

	checkBoxGrp
		-label (uiRes("m_performSurfaceSampling.kFlipU"))
		-value1 off
		surfaceSamplingFlipUField;

	checkBoxGrp
		-label (uiRes("m_performSurfaceSampling.kFlipV"))
		-value1 off
		surfaceSamplingFlipVField;

	setParent ..;
	setParent ..;
}


global proc MentalUVRangeChangeCB( int $index )
{
	floatSliderGrp -edit -enable ($index==3) surfaceSamplingMentalUMinCtrl;
	floatSliderGrp -edit -enable ($index==3) surfaceSamplingMentalUMaxCtrl;
	floatSliderGrp -edit -enable ($index==3) surfaceSamplingMentalVMinCtrl;
	floatSliderGrp -edit -enable ($index==3) surfaceSamplingMentalVMaxCtrl;
}


proc buildMentalCommonSettingsFrame()
{
	frameLayout 
		-collapsable true
		-collapse true
		-label (uiRes("m_performSurfaceSampling.kMentalCommonOutput"))
		-marginHeight 6
		-visible 0
		surfaceSamplingMentalCommonOutput;	

	columnLayout;

	global int $surfaceSamplingMentalCommonSettingsIndex;
	buildCommonOutputSettingsWidgets( $surfaceSamplingMentalCommonSettingsIndex, true, true );
	
	separator;
	
	optionMenuGrp 
		-label (uiRes("m_performSurfaceSampling.kMentalTransferIn")) 
		surfaceSamplingMentalTransferSpaceCtrl;
		menuItem -label (uiRes("m_performSurfaceSampling.kMentalWorldSpace")) ;
		menuItem -label (uiRes("m_performSurfaceSampling.kMentalObjectSpace")) ;

	optionMenuGrp -e -select 1 surfaceSamplingMentalTransferSpaceCtrl;	

   intSliderGrp -label (uiRes("m_performSurfaceSampling.kNumberOfSamples"))
        -min 1 -max 4
        -fieldMinValue 1 -fieldMaxValue 64
        surfaceSamplingMentalSamplesCtrl;    
        
	optionMenuGrp -label (uiRes("m_performSurfaceSampling.kTextureNormalDirection"))
		surfaceSamplingMentalNormalDirectionCtrl;
		menuItem -label (uiRes("m_performSurfaceSampling.kTextureNormalDirectionFaceCamera"));
		menuItem -label (uiRes("m_performSurfaceSampling.kTextureNormalDirectionSurfaceFront"));
		menuItem -label (uiRes("m_performSurfaceSampling.kTextureNormalDirectionSurfaceBack"));

	optionMenuGrp -e -select 2 surfaceSamplingMentalNormalDirectionCtrl;
		
    checkBoxGrp -label1 (uiRes("m_performSurfaceSampling.kTextureBakeAlpha"))
        surfaceSamplingMentalAlphaCtrl; 

    optionMenuGrp -label (uiRes("m_performSurfaceSampling.kTextureAlphaMode"))
        surfaceSamplingMentalAlphaModeCtrl;
        menuItem -label (uiRes("m_performSurfaceSampling.kTextureAlphaModePassThrough"));
        menuItem -label (uiRes("m_performSurfaceSampling.kTextureAlphaModeSurfaceTransparency"));
        menuItem -label (uiRes("m_performSurfaceSampling.kTextureAlphaModeLuminanceSurfaceColor"));
        menuItem -label (uiRes("m_performSurfaceSampling.kTextureAlphaModeCoverage"));

    separator;

    floatSliderGrp -label (uiRes("m_performSurfaceSampling.kTextureFinalGatherQuality"))
		-min 0	-max 2 -value 1
		-fieldMinValue 0 -fieldMaxValue 100
		surfaceSamplingMentalFinalGatherQualityCtrl;
	floatSliderGrp -label (uiRes("m_performSurfaceSampling.kTextureFinalGatherReflect"))
		-min 0	-max 1 -value 0
		-fieldMinValue 0 -fieldMaxValue 1
		surfaceSamplingMentalFinalGatherReflectCtrl;	
    separator;

    optionMenuGrp -label (uiRes("m_performSurfaceSampling.kTextureUVRange"))
        -cc "MentalUVRangeChangeCB( `optionMenuGrp -q -select surfaceSamplingMentalUVRangeCtrl` )"
        surfaceSamplingMentalUVRangeCtrl;
        menuItem -label (uiRes("m_performSurfaceSampling.kTextureUVRangeNormal")); 
        menuItem -label (uiRes("m_performSurfaceSampling.kTextureUVRangeEntireRange")); 
        menuItem -label (uiRes("m_performSurfaceSampling.kTextureUVRangeUserSpecified")); 

    floatSliderGrp -label (uiRes("m_performSurfaceSampling.kTextureUMin"))
        -min 0 -max 1
        -fieldMinValue -10000 -fieldMaxValue 10000
		-enable false
        surfaceSamplingMentalUMinCtrl;

    floatSliderGrp -label (uiRes("m_performSurfaceSampling.kTextureUMax"))
        -min 0 -max 1
        -fieldMinValue -10000 -fieldMaxValue 10000
		-enable false
        surfaceSamplingMentalUMaxCtrl;

    floatSliderGrp -label (uiRes("m_performSurfaceSampling.kTextureVMin"))
        -min 0 -max 1
        -fieldMinValue -10000 -fieldMaxValue 10000
		-enable false
		surfaceSamplingMentalVMinCtrl;

    floatSliderGrp -label (uiRes("m_performSurfaceSampling.kTextureVMax"))
        -min 0 -max 1
        -fieldMinValue -10000 -fieldMaxValue 10000
		-enable false
        surfaceSamplingMentalVMaxCtrl;

    floatSliderGrp -label (uiRes("m_performSurfaceSampling.kTextureFillTextureSeams"))
        -min 0 -max 3
        -fieldMinValue 0 -fieldMaxValue 32
        surfaceSamplingMentalFillTextureSeamsCtrl;

	setParent ..;
	setParent ..;
}


proc surfaceSamplingOptionWindow()
{
	global string $gSurfaceSamplerMayaFileExtensions[];
	global int $surfaceSamplingSourceListSize;
	global int $surfaceSamplingSourceNumElements;
	global int $surfaceSamplingTargetListSize;
	global int $surfaceSamplingTargetNumElements;
	global int $surfaceSamplingOutputArraySize;
	global int $surfaceSamplingFirstOutputMap;

	// Name of the command for this option box.
	string $commandName = "surfaceSampling";

	// Build the option box actions.
	string $callback = ( $commandName + "Callback" );
	string $setup = ( "surfaceSamplingSetUIFromOptionVars" );

	// Remove any existing UI to avoid duplicate element names
	if( `window -q -exists OptionBoxWindow` )
		deleteUI OptionBoxWindow;

	// Reset our counters 
	$surfaceSamplingTargetListSize = 0;
	$surfaceSamplingSourceListSize = 0;
	$surfaceSamplingOutputArraySize = $surfaceSamplingFirstOutputMap;

	// set the names
	setMapTypeStrings();

	// STEP 1: Get the option box
	string $layout = getOptionBox();
	setParent $layout;
	
	//	STEP 2:  Pass the command name to the option box.
	setOptionBoxCommandName( "surfaceSampler" );

	//	STEP 3:  Activate the default UI template.
	setUITemplate -pushTemplate DefaultTemplate;

	//	STEP 4: Create option box contents.
	string $scrollLayout = `scrollLayout`;
	string $formLayout = `formLayout surfaceSamplingTopFormFrame`;

	buildTargetSurfaceFrame();
	buildSourceSurfaceFrame();
	buildOutputsFrame();
	buildConnectMapsFrame();
	buildAdvancedOptionsFrame();
	buildMayaCommonOutputFrame();
	buildMentalCommonSettingsFrame();
	surfaceSamplingSetSearchSpace( (`optionVar -q surfaceSamplingTransferSpaceOption` - 1) );

	formLayout -e
	
		-attachForm surfaceSamplingTargetSurfaceFrame "top" 0
		-attachForm surfaceSamplingTargetSurfaceFrame "left" 0
		-attachForm surfaceSamplingTargetSurfaceFrame "right" 0

		-attachControl surfaceSamplingSrcSurfaceFrame "top" 0 surfaceSamplingTargetSurfaceFrame
		-attachForm surfaceSamplingSrcSurfaceFrame "left" 0
		-attachForm surfaceSamplingSrcSurfaceFrame "right" 0

		-attachControl surfaceSamplingOutputsFrame "top" 0 surfaceSamplingSrcSurfaceFrame
		-attachForm surfaceSamplingOutputsFrame "left" 0
		-attachForm surfaceSamplingOutputsFrame "right" 0
		
		-attachControl surfaceSamplingConnectMapsFrame "top" 0 surfaceSamplingOutputsFrame
		-attachForm surfaceSamplingConnectMapsFrame "left" 0
		-attachForm surfaceSamplingConnectMapsFrame "right" 0

		-attachControl surfaceSamplingMayaCommonOutputFrame "top" 0 surfaceSamplingConnectMapsFrame
		-attachForm surfaceSamplingMayaCommonOutputFrame "left" 0
		-attachForm surfaceSamplingMayaCommonOutputFrame "right" 0

		-attachControl surfaceSamplingMentalCommonOutput "top" 0 surfaceSamplingMayaCommonOutputFrame
		-attachForm surfaceSamplingMentalCommonOutput "left" 0
		-attachForm surfaceSamplingMentalCommonOutput "right" 0

		-attachControl surfaceSamplingAdvancedFrame "top" 0 surfaceSamplingMentalCommonOutput
		-attachForm surfaceSamplingAdvancedFrame "left" 0
		-attachForm surfaceSamplingAdvancedFrame "right" 0

		$formLayout;

	//	Step 5: Deactivate the default UI template.
	setUITemplate -popTemplate;

	//	STEP 5.1: Add the target Surfaces	
	//	(This screws up the layout if done when the targets frame is constructed)
	//
	string $targets[] = `ls -sl -o`;
	if( size( $targets) == 0 )
	{
		// If there's nothing selected when trying to enter the tool, use the last set of sources/targets 
		// that were setup
		//
		string $sources[];
		if( `optionVar -exists "surfaceSamplingSourceList"`)
			$sources = `optionVar -q "surfaceSamplingSourceList"`;
		if( `optionVar -exists "surfaceSamplingTargetList"`)
			$targets = `optionVar -q "surfaceSamplingTargetList"`;
		for( $name in $targets)
		{
			if( size( `ls $name` ) > 0 ) 
			{
				surfaceSamplingAddTargets( $name, true );	// check for dupes to avoid multiple entries when envelopes are present!
			}
		}
		for( $name in $sources)
		{
			if( size( `ls $name` ) > 0 ) 
			{
				surfaceSamplingAddSource( $name, true );
			}
		}
	}
	else
	{
		for( $name in $targets)
		{
			surfaceSamplingAddTargets( $name, true );	// check for dupes to avoid multiple entries when envelopes are present
		}
	}


	//	Step 6: Customize the buttons.  
	//	'Apply' button.
	string $applyBtn = getOptionBoxApplyBtn();
	button -edit
		-label (uiRes("m_performSurfaceSampling.kBake"))
		-command ( $callback + " " + $formLayout + " " + 1 )
		$applyBtn;

	//	'Save' button.
	string $applyAndCloseBtn = getOptionBoxApplyAndCloseBtn();
	button -edit 
		-label (uiRes("m_performSurfaceSampling.kBakeandClose"))
		-command ( $callback + " " + $formLayout + " " + 1 + "; hideOptionBox" )
		$applyAndCloseBtn;

	//	'Reset' button.
	string $resetBtn = getOptionBoxResetBtn();
	button -edit 
		-command ( $setup + " " + $formLayout + " " + 1 )
		$resetBtn;

	//	'Close' button.
	string $closeBtn = getOptionBoxCloseBtn();
	button -edit 
		-command ( $callback + " " + $formLayout + " " + 0 + "; hideOptionBox" )
		$closeBtn;

	//	Step 7: Set the option box title 
	setOptionBoxTitle (uiRes("m_performSurfaceSampling.kTransferMaps"));
	setOptionBoxHelpTag("SurfaceSampler");	

	//	Step 9: Set the current values of the option box.
	eval ( ( $setup + " " + $formLayout + " " + 0 ) );	
	
	//	Step 10: Show the option box.
	showOptionBox();

	// Give a chance to third party plugins to expose extra UI in
	// the Transfer Maps section.
	callbacks -executeCallbacks -hook controlTransferMapsVisibility "1";
}


global proc string addFileTexture( string $filename)
{
	global string $gSurfaceSamplerMayaFileExtensions[];

	string $ls[] = `ls -sl -o`;

	int $projection = ( `optionVar -q create2dTextureType` == "projection" );
	int $stencil = ( `optionVar -q create2dTextureType` == "stencil" );
	int $placement = `optionVar -q -createTexturesWithPlacement`;
	int $shadingGroup = `optionVar -q createMaterialsWithShadingGroup`;
	string $file = renderCreateNode( "-asTexture", "", "file", "", $projection, $stencil, $placement, $shadingGroup, 0, "" );
	setAttr -type "string" ( $file + ".fileTextureName" ) $filename;

	select $ls;

	return $file;
}


global proc connectToShader( string $file, string $plug, string $shaderAttr, string $channel)
{
	global string $surfaceSamplingTargetList[];
	global int $surfaceSamplingTargetListSize;
	global int $surfaceSamplingTargetNumElements;
	
	// For each target surface
	//
	int $target = 0;
	while( $target < $surfaceSamplingTargetListSize)
	{
		// Grab the path of this target
		//
		string $path = $surfaceSamplingTargetList[ $target * $surfaceSamplingTargetNumElements];
		
		// Get the shading engines assigned to this surface
		//
		string $shadingEngines[] = `listSets -ets -o $path -t 1`;
		for( $shadingEngine in $shadingEngines)
		{		
			// Get the shaders connected to the shading engine
			//
			string $shader[] = `listConnections ($shadingEngines[0] + "." + $shaderAttr)`;
			
			// If there is no shader connected here, try creating one
			//
			if( size( $shader ) == 0)
			{
				if( $shaderAttr == "displacementShader")
					$shader[0] = `shadingNode -asShader displacementShader`;
				else if( $shaderAttr == "surfaceShader")
					$shader[0] = `shadingNode -asShader lambert`;
				if( size( $shader ) > 0 )
					connectAttr( $shader[0] + "." + $channel, $shadingEngines[0] + "." + $shaderAttr);
			}

			// If we have a shader ...
			//
			if( size( $shader ) > 0 )
			{
				// Does our target channel exist on this shader?
				//
				if( attributeExists( $channel, $shader[0]))
				{
					// Disconnect any existing inputs
					//
					string $oldInputs[] = `listConnections -plugs true -source true -destination false ( $shader[0] + "." + $channel )`;
					if( size( $oldInputs ) > 0)	
						disconnectAttr ( $oldInputs[0] ) ( $shader[0] + "." + $channel );
					
					// Hook our map up
					//
					connectAttr ( $plug ) ( $shader[0] + "." + $channel );
	
					// Find the shape and uv set and link them together
					//
					string $shapes[] = `listRelatives -path -shapes $path`;
					if ( `size $shapes` != 0 )
					{
						string $uvSets[] = `polyUVSet -q -allUVSets $shapes[0]`;
						string $uvSet = getSelectedUVSet( $path, $target, "surfaceSamplingOutputUVSetMenu");
						for ( $i = 0; $i < `size $uvSets`; $i++ )
							if ( $uvSets[$i] == $uvSet ) 
								uvLink -make -uvs ($shapes[0] + ".uvSet[" + $i + "].uvSetName") -t $file;
					}
				}
			}
		}		
		$target++;
	}
}


global proc postSurfaceSampling()
{
	// Iterate over each output map
	//
	string $ls[] = `ls -sl -o`;
	global string $surfaceSamplingTargetList[];
	global int $surfaceSamplingTargetListSize;
	global int $surfaceSamplingTargetNumElements;
	global int $surfaceSamplingOutputArraySize;
	global int $surfaceSamplingMayaCommonSettingsIndex;
	global int $surfaceSamplingMentalCommonSettingsIndex;
	global int $surfaceSamplingFirstOutputMap;

	global int $surfaceSamplingNormalType;
	global int $surfaceSamplingDisplacementType;
	global int $surfaceSamplingDiffuseColorType;
	global int $surfaceSamplingLitAndShadeColorType;
	global int $surfaceSamplingAlphaType;
	global int $surfaceSamplingAmbientOcclusionType;
	global int $surfaceSamplingCustomType;

	// Should we assign a new "test" shader to our targets?
	//
	int $enableShaderConnection = `optionVar -q surfaceSamplingShaderConnectionOption`;
	if( $enableShaderConnection == 1)
	{
		// Create a new shader
		//
		string $shader = `shadingNode -asShader lambert`;
		string $sg = `sets -renderable true -noSurfaceShader true -empty -name ($shader + "SG")`;
		connectAttr -f ($shader + ".outColor") ($sg + ".surfaceShader");
		
		// Now assign it to all our target surfaces
		//
		int $target = 0;
		while( $target < $surfaceSamplingTargetListSize)
		{
			assignSG $shader $surfaceSamplingTargetList[ $target * $surfaceSamplingTargetNumElements];
			$target++;
		}
	}

	// Should we connect everything up to the shading network?
	//
	if( $enableShaderConnection > 0)
	{
		// Ensure we create one one node for each unique texture
		//
		string $textureNodes[];
		
		int $i = $surfaceSamplingFirstOutputMap;
		while( $i < $surfaceSamplingOutputArraySize)
		{
			if( `optionVar -q ("surfaceSamplingEnableMapOption" + (string)$i)`)
			{
				// Create/find a file texture node for this file
				//
				string $filename = `optionVar -q ("surfaceSamplingFileNameOption" + (string)$i)`;
				int $mapType = `optionVar -q ("surfaceSamplingType" + (string)$i)`;
				string $file = "";
				for( $node in $textureNodes)
				{
					if( `getAttr ($node + ".fileTextureName")` == $filename)
					{
						$file = $node;
						// print( "Reusing node " + $file + " for file " + $filename + "\n");
					}
				}
				if( size( $file) == 0)
				{
					$file = addFileTexture( $filename);
					$textureNodes[ size( $textureNodes)] = $file;
					// print( "Allocated new node " + $file + " for file " + $filename + " of type " + $mapType + "\n");
				}
				
				// Now work out how to hook it up based on the map type
				//
				if( $mapType == $surfaceSamplingNormalType)
				{
					// Normals
					// Insert a bump2d node between the texture and the shader
					string $bump = `shadingNode -asUtility bump2d`;
					connectAttr ($file + ".outAlpha") ($bump + ".bumpValue");

					int $space = `optionVar -q ("surfaceSamplingMapSpaceOption" + (string)$i)`;
					if ($space == 1) // object normal
						setAttr ($bump + ".bumpInterp") 2;
					if ($space == 2) // tangent normal space 
						setAttr ($bump + ".bumpInterp") 1;

					connectToShader( $file, $bump + ".outNormal", "surfaceShader", "normalCamera");
				}
				else if( $mapType == $surfaceSamplingDisplacementType )
				{
					// Displacement		
					// The displacement map stores +/- of the MaxValue encoded into 
					// a byte. This means that 0.0 = -MaxValue, and 1.0 = +MaxValue. \
					// So we need to set the colour gain to 2 x MaxValue, and the 
					// colour offset to -MaxValue to map this back into the correct range.
					float $maxValue = `optionVar -q ("surfaceSamplingMaxValueOption" + (string)$i)`;
					setAttr ($file + ".colorGain") -type double3 ($maxValue * 2.0) ($maxValue * 2.0) ($maxValue * 2.0);
					setAttr ($file + ".colorOffset") -type double3 ($maxValue * -1.0) ($maxValue * -1.0) ($maxValue * -1.0);
					setAttr ($file + ".alphaGain") ($maxValue * 2.0);
					setAttr ($file + ".alphaOffset") ($maxValue * -1.0);
					connectToShader( $file, $file + ".outAlpha", "displacementShader", "displacement");
				}
				else if( $mapType == $surfaceSamplingLitAndShadeColorType )
				{
					// Connect to color
					connectToShader( $file, $file + ".outColor", "surfaceShader", "ambientColor");
					if( `getAttr ($file + ".fileHasAlpha")`)
						connectToShader( $file, $file + ".outTransparency", "surfaceShader", "transparency");
				}
				else if( $mapType == $surfaceSamplingAlphaType )
				{
					if( `getAttr ($file + ".fileHasAlpha")`)
					{
						// Connect to alpha
						// print( "Hooking up alpha on " + $file + "\n");
						connectToShader( $file, $file + ".outTransparency", "surfaceShader", "transparency");
					}
					else
					{
						// Connect to transparency
						// print( "Hooking up transparency on " + $file + "\n");
						connectToShader( $file, $file + ".outColor", "surfaceShader", "transparency");
						setAttr ($file + ".colorGain") -type double3 -1 -1 -1;
						setAttr ($file + ".colorOffset") -type double3 1 1 1;
					}
				}
				else if( $mapType == $surfaceSamplingAmbientOcclusionType )
				{
					// Hack alert: Currently ambient occlusion is strictly a grey scale
					// This will need to change if we ever allow users to sample the environment color
					// or use custom dark and light colors.
					//
					connectToShader( $file, $file + ".outColor.outColorR", "surfaceShader", "diffuse");
				}
				else
				{
					// Connect to color
					connectToShader( $file, $file + ".outColor", "surfaceShader", "color");
				}
			}		
			$i++;
		}
	}
	select $ls;
}

global proc string createSurfaceSampleBakeSet(string $shader, int $index )
//
//	Currently only works for texture bake sets
//
{
	global string $gSurfaceSamplerMentalFileExtensions[];
	
	string $firstName = "surfaceSamplerAmbOccBakeSet1";
	string $bakeSet = createBakeSet( $firstName, "textureBakeSet" );
	
	// Hard code some options needed for transfer maps
	//
    setAttr ($bakeSet+".bakeToOneMap") 1;	// only one map per bakeset
	setAttr ($bakeSet + ".colorMode") 4;	// bake custom shader
	connectAttr ($shader + ".message") ($bakeSet + ".customShader");

	// Common settings
	//
	global int $surfaceSamplingMentalCommonSettingsIndex;
	int $indexForCommonSettings = $index;

	if( `optionVar -q ("surfaceSamplingUseCommonOutputSettingsField" + (string) $index )` )
		$indexForCommonSettings = $surfaceSamplingMentalCommonSettingsIndex;

	setAttr ($bakeSet + ".xResolution") `optionVar -q ("surfaceSamplingMapWidthOption" + (string)$indexForCommonSettings)`;
	setAttr ($bakeSet + ".yResolution") `optionVar -q ("surfaceSamplingMapHeightOption" + (string)$indexForCommonSettings)`;
	setAttr ($bakeSet + ".bitsPerChannel") `optionVar -q ("surfaceSamplingMentalBitsPerChannel" + (string)$index)` ;

	int $extension = `optionVar -q ("surfaceSamplingExtensionOption" + (string)$index)`;
	setAttr ($bakeSet + ".fileFormat") $extension;

	string $name = stripExtension( `optionVar -q ("surfaceSamplingFileNameOption" + (string)$index)`, 1);
	setAttr -type "string" ($bakeSet + ".prefix") $name;	
				
	// Write the full path back to the environment variable to make sure we always
	// hook the file texture node up to the file that was just written (in case old
	// prefs or UI focus anomolies leave the file name without the correct extension)
	//
	optionVar -stringValue ("surfaceSamplingFileNameOption" + (string)$index) ($name + "." + $gSurfaceSamplerMentalFileExtensions[ $extension]);

	// Bakeset options 
	//
	int $intValue = 0;
	int $floatValue = 0.0;	
	$intValue = `optionVar -q surfaceSamplingMentalNormalDirection` - 1;
	setAttr ($bakeSet+".normalDirection") $intValue;

	$intValue = `optionVar -q surfaceSamplingMentalSamples`;
    setAttr ($bakeSet+".samples") $intValue; 
    
    $intValue = `optionVar -q surfaceSamplingMentalAlpha`;
    setAttr ($bakeSet+".bakeAlpha") $intValue;

    $intValue = `optionVar -q surfaceSamplingMentalAlphaMode`;
    setAttr ($bakeSet+".alphaMode") $intValue;

    $floatValue = `optionVar -q surfaceSamplingMentalFinalGatherQuality`;
    setAttr ($bakeSet+".finalGatherQuality") $floatValue;
    
    $floatValue = `optionVar -q surfaceSamplingMentalFinalGatherReflect`;
    setAttr ($bakeSet+".finalGatherReflect") $floatValue;
    
    $intValue = `optionVar -q surfaceSamplingMentalUVRange` - 1;
    setAttr ($bakeSet+".uvRange") $intValue;

    $floatValue = `optionVar -q surfaceSamplingMentalUMin`;
    setAttr ($bakeSet+".uMin") $floatValue;

    $floatValue = `optionVar -q surfaceSamplingMentalUMax`;
    setAttr ($bakeSet+".uMax") $floatValue;

    $floatValue = `optionVar -q surfaceSamplingMentalVMin`;
    setAttr ($bakeSet+".vMin") $floatValue;

    $floatValue = `optionVar -q surfaceSamplingMentalVMax`;
    setAttr ($bakeSet+".vMax") $floatValue;

    $floatValue = `optionVar -q surfaceSamplingMentalFillTextureSeams`;
    setAttr ($bakeSet+".fillTextureSeams") $floatValue;

	return $bakeSet;
}

proc int arrayMatch( string $array[], string $match )
{
    for ($item in $array)
        if ($item == $match)
            return true;

    return false;
}

global proc copyOverScalarValues(string $sourceNode, string $destinationNode)
{
    // Copy the scalar values

    string $originalAttrs[] =
        `listAttr -scalar -multi -read -visible $sourceNode`;

    string $replaceAttrs[] =
        `listAttr -scalar -multi -write -visible $destinationNode`;

    for ($attr in $originalAttrs) {
        if (arrayMatch($replaceAttrs, $attr)) {
            float $value = `getAttr ($sourceNode+"."+$attr)`;
            catch(`setAttr ($destinationNode+"."+$attr) $value`);
        }
    }
}

global proc performSurfaceSampling( int $action )
{
	switch ( $action )
	{
		case 0:
			surfaceSamplingCreateOrResetOptionVars( 0 );

			if( haveMayaMaps() )
			{
				string $cmd = surfaceSamplingGenerateCmd();
				print( $cmd + "\n");
				eval( $cmd );
			}

			// Give a chance to third party plugins to expose generate
			// custom maps.
			callbacks -executeCallbacks -hook performTransferMapsSampling;

			postSurfaceSampling();
			break;

		case 1:
			surfaceSamplingOptionWindow();
			break;
	}
}


global proc surfaceSamplingCallback( string $parent, int $doIt )
//
// Description:
//		Handle the user clicking "Bake" etc
//
{
	// Set all our controlling option vars from the current UI
	//
	surfaceSamplingSetOptionVarsFromUI( $parent);
	
	// Store the current source and target lists
	//
	global string $surfaceSamplingTargetList[];
	global int $surfaceSamplingTargetListSize;
	global int $surfaceSamplingTargetNumElements;
	int $target = 0;
	optionVar -clearArray "surfaceSamplingTargetList";
	while( $target < $surfaceSamplingTargetListSize)
	{
		string $path = $surfaceSamplingTargetList[ $target * $surfaceSamplingTargetNumElements];
		if( size( `ls $path` ) > 0 ) 
			optionVar -stringValueAppend "surfaceSamplingTargetList" $path;
		$target++;
	}	

	global string $surfaceSamplingSourceList[];
	global int $surfaceSamplingSourceListSize;
	global int $surfaceSamplingSourceNumElements;
	int $source = 0;
	optionVar -clearArray "surfaceSamplingSourceList";
	while( $source < $surfaceSamplingSourceListSize)
	{
		string $path = $surfaceSamplingSourceList[ $source * $surfaceSamplingSourceNumElements];
		if( size( `ls $path` ) > 0 ) 
			optionVar -stringValueAppend "surfaceSamplingSourceList" $path;
		$source++;
	}	
	

	// Reset the visibility of our targets and Envelopes
	//
	$target = 0;
	while( $target < $surfaceSamplingTargetListSize)
	{
		string $path = $surfaceSamplingTargetList[ $target * $surfaceSamplingTargetNumElements];
		if( size( `ls $path` ) > 0 ) 
		{
			showHidden( $path );
			string $Envelope = surfaceSamplingGetCage( $target, false );
			if( size( $Envelope ) > 0) 
				hide( $Envelope );
			if( `optionMenu -exists ("surfaceSamplingTargetDisplayMenu" + (string)$target)` )
				optionMenu -e -value (uiRes("m_performSurfaceSampling.kSurface")) ("surfaceSamplingTargetDisplayMenu" + (string)$target);
		}
		$target++;
	}	
	
	// Execute the command if we've been told to
	//
	if ($doIt) 
	{
			performSurfaceSampling 0; 
			addToRecentCommandQueue "performSurfaceSampling 0" "Surface Sampling";
	}
	
	// Now delete our Envelopes if the window is closing and we're set to
	// delete them
	//
	if( `checkBoxGrp -exists surfaceSamplingDeleteCagesField` &&
		`checkBoxGrp -q -value1 surfaceSamplingDeleteCagesField` == on)
	{
		$target = 0;
		while( $target < $surfaceSamplingTargetListSize)
		{
			string $Envelope = surfaceSamplingGetCage( $target, false );
			if( size( $Envelope ) > 0) 
			{
				string $transform[] = `listRelatives -path -parent $Envelope`;
				delete( $transform[0] );
			}
			$target++;
		}	
	}		
}


