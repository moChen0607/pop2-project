// Copyright (C) 1997-2014 Autodesk, Inc., and/or its licensors.
// All rights reserved.
//
// The coded instructions, statements, computer programs, and/or related
// material (collectively the "Data") in these files contain unpublished
// information proprietary to Autodesk, Inc. ("Autodesk") and/or its licensors,
// which is protected by U.S. and Canadian federal copyright law and by
// international treaties.
//
// The Data is provided for use exclusively by You. You have the right to use,
// modify, and incorporate this Data into other products for purposes authorized 
// by the Autodesk software license agreement, without fee.
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND. AUTODESK
// DOES NOT MAKE AND HEREBY DISCLAIMS ANY EXPRESS OR IMPLIED WARRANTIES
// INCLUDING, BUT NOT LIMITED TO, THE WARRANTIES OF NON-INFRINGEMENT,
// MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE, OR ARISING FROM A COURSE 
// OF DEALING, USAGE, OR TRADE PRACTICE. IN NO EVENT WILL AUTODESK AND/OR ITS
// LICENSORS BE LIABLE FOR ANY LOST REVENUES, DATA, OR PROFITS, OR SPECIAL,
// DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES, EVEN IF AUTODESK AND/OR ITS
// LICENSORS HAS BEEN ADVISED OF THE POSSIBILITY OR PROBABILITY OF SUCH DAMAGES.

//
//
//  Creation Date:  Nov, 1999
//
//	Procedure Name:
//		doExportClipArgList
//
//	Description:
//		Export a clip
//
//	Input Arguments:
//	$version: The version of this option box.  Used to know how to 
//	interpret the $args array.
//  
//	$args
//	Version 1
//  [0] 	$editor: name of TraxEditor window or "" if none
//	Version 2
//  [0] 	$editor: name of TraxEditor window or "" if none
//  [1] 	$clipName: name of clipName. If specified, this clip overrides the selected clips.
//
//
global string $expClipEditor = "";
global string $expClipName = "";

global proc int
clipEditorExportClip(string $fileName, string $fileType)
{
	global string $expClipEditor;
	global string $expClipName;

	if ($fileName == "") {
		error( (uiRes("m_doExportClipArgList.kNoFileNameSpecified")) );
		return 0;
	}

	if (`about -evalVersion`) {
		$fileType = "mayaPLE";
	}
	
	if ($fileType == "ma") {
		$fileType = "mayaAscii";
	} else if ($fileType == "mb") {
		$fileType = "mayaBinary";
	} else if ($fileType != "mayaBinary" && $fileType != "mayaAscii" && $fileType != "mayaPLE") {
		string $errMsg = (uiRes("m_doExportClipArgList.kInvalidFileTypeErr"));
		$errMsg = `format -s $fileType $errMsg`;
		error($errMsg);
		return 0;
	}
	
	int $ii;
	string $selClips[];
	if ($expClipName != "") {
		$selClips[0] = $expClipName;
	}
	else {
		$selClips = getSelectedClips("noOptions");
	}
	if (size($selClips) == 0) {
		error( (uiRes("m_doExportClipArgList.kSelectClipsExportErr")) );
	}

	string $sourceClips[];
	string $sourceClipsAll[];
	for ($clipName in $selClips) {
		string $sourceClipName = `clip -q -scn $clipName`;
		if ($sourceClipName != $clipName) {
			copyAbsoluteChannelsClipData($sourceClipName, $clipName);
		}

		int $found = AWNumberOfOccurrencesInStringArray($sourceClipName,$sourceClips);
		if (0 == $found) {
			$sourceClips[size($sourceClips)] = $sourceClipName;
		}
	}

	if (size($sourceClips) == 0) {
		error( (uiRes("m_doExportClipArgList.kFoundNoSourceErr")) );
		return 0;
	}
	
	// save the current selection to restore it at the end
	//
	string $sel[] = `ls -sl`;

	// create the command string
	//
	string $result[];
	string $isolateCmd = "clip -isolate";
	string $clipNames = "";
	for ($clip in $sourceClips) {
		$clipNames += (" -name "+$clip);
	}
	$isolateCmd += $clipNames;
	catch($result = eval($isolateCmd));

	if (size($result)) {
		// Cache the current prompt state of the file command and temporarily set it the 
		// file command to NOT prompt users about overwriting files.
		// This is safe to do since doExportClipArgList (defined below) uses fileBrowser 
		// to display a file dialog allowing the user to select (or enter) a file name.
		// If the users enters the name of an existing file, the dialog will take care of
		// confirm whether or not the file should be overwritten. If the user selects NOT
		// to overwrite the file, the dialog will continue to be display until the user 
		// either presses cancel or enters a new valid name.
		int $state = `file -q -prompt`;
		file -prompt 0;

		select -r $result;
		file -f -type $fileType -exportSelected -channels true -constructionHistory true $fileName;
		$lib = `ls -type clipLibrary $result`;
		if (size($lib))
			delete $lib;

		// reset the state of the file command at the time the helper was called.
		file -prompt $state;
	}

	// restore selection
	//
	select -r $sel;

	if (size($result) == 0) 
		error( (uiRes("m_doExportClipArgList.kUnableToExportErr")) );

	return 1;
}

global proc
doExportClipArgList( string $version, string $args[] )
{
	int $versionNo = $version;

	global string $expClipEditor;
	global string $expClipName;
	$expClipEditor  = $args[0];

	if ($versionNo > 1) {
		$expClipName  = $args[1];
	} else {
		$expClipName = "";
	}

	string $sc[] = (size($expClipName)) ?
		{ $expClipName } : 
		getSelectedClips("noOptions");

	if (size($sc) == 0)
		error( (uiRes("m_doExportClipArgList.kSelectTheClipErr")) );

	string $fileRule = `workspace -q -fre "clips"`;
	string $buffer[];
	tokenize($fileRule,";",$buffer);
	if (size($buffer) == 0) {
		$buffer[0] = "clips";
	}

	for ($buf in $buffer) {
		string $clipsDir = (`workspace -q -rd`+$buf+"\/");
		if (`file -q -ex $clipsDir`) {
			workspace -dir $clipsDir;
			break;
		}
	}

	// bring up the file browser dialog so that they can choose a file name
	//
	fileBrowser("clipEditorExportClip",(uiRes("m_doExportClipArgList.kExportClip")),"ma",1);
}
