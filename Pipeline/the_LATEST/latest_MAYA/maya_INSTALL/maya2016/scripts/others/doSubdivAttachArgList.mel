// Copyright (C) 1997-2014 Autodesk, Inc., and/or its licensors.
// All rights reserved.
//
// The coded instructions, statements, computer programs, and/or related
// material (collectively the "Data") in these files contain unpublished
// information proprietary to Autodesk, Inc. ("Autodesk") and/or its licensors,
// which is protected by U.S. and Canadian federal copyright law and by
// international treaties.
//
// The Data is provided for use exclusively by You. You have the right to use,
// modify, and incorporate this Data into other products for purposes authorized 
// by the Autodesk software license agreement, without fee.
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND. AUTODESK
// DOES NOT MAKE AND HEREBY DISCLAIMS ANY EXPRESS OR IMPLIED WARRANTIES
// INCLUDING, BUT NOT LIMITED TO, THE WARRANTIES OF NON-INFRINGEMENT,
// MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE, OR ARISING FROM A COURSE 
// OF DEALING, USAGE, OR TRADE PRACTICE. IN NO EVENT WILL AUTODESK AND/OR ITS
// LICENSORS BE LIABLE FOR ANY LOST REVENUES, DATA, OR PROFITS, OR SPECIAL,
// DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES, EVEN IF AUTODESK AND/OR ITS
// LICENSORS HAS BEEN ADVISED OF THE POSSIBILITY OR PROBABILITY OF SUCH DAMAGES.

//
//
//  Description:
//      Functions called from "Subdiv Attach".
//

proc int simulatePerformPolySewEdge( float $fval, int $ivSM, int $ivWS)
{
	// looks exactly like performPolySewEdge, but with custom args 
	string $cmd = "";
	$cmd=("polySewEdge -t " + $fval + " -tx " + $ivSM + " -ws " + $ivWS);
	// Get the current value of the "Convert Selection" option var. Then
	// set the value of the optionVar to do the selection conversion and
	// finally set it back to the original value, after the operation has
	// been performed. This so that the operation succeeds when the object
	// (not edges) is selected and "Convert Selection" is not toggled on
	// bug #149414.
	//
	int $origConvertSelVarValue = `optionVar -query polyAutoConvertAction`;
	optionVar -intValue polyAutoConvertAction 1;
	polyPerformAction $cmd e 0;
	// Set the "Convert Selection" option var back to original state.
	//
	optionVar -intValue polyAutoConvertAction $origConvertSelVarValue;
	return 0;
}

//
//  Procedure Name:
//      doSubdivAttachArgList
//
//  Description:
//		This is the actual function that gets called from "Subdiv Attach" 
//      option box.
//
//  Input Arguments:
//	    $version: The version of this option box.  This is used to know how to 
//	              interpret the $args array.
//
//      history (args[0])
//      sew edge threshold (args[1])  (aka $fval)
//      sew map edge (args[2])			(aka $ivSM)
//      sew edge world space (args[3])  (aka $ivWS)
//
//  Return Value:
//      0 if we succeeded, >0 otherwise.
//
//  Note:  
//
global proc int doSubdivAttachArgList( string $version, string $args[] )
{
	int $status = 1;

	if( size($args) < 1 ) {
		string $msg = (uiRes("m_doSubdivAttachArgList.kWrongNumberOfArgs"));
		error($msg);
		return $status;
	}

	global int $gSelectSubdivSurface;

	// attach all subd's
	string $list[] = `filterExpand -ex 1 -fp 1 -sm $gSelectSubdivSurface`; 
	int $len = size($list);

	if( $len < 2) {
		string $msg = (uiRes("m_doSubdivAttachArgList.kSelectError"));
		error ($msg);
		return $status;
	}

	int $globalHist = $args[0];
	float $fval = $args[1];
	int $ivSM = $args[2];
	int $ivWS = $args[3];
	int $delOrig = $args[4];
	string $subd1 = $list[0];
	string $subd2 = $list[1];

	int $whichMode = `subdiv -q -proxyMode $subd1`;
	if( 2 == $whichMode ) {
		string $msg = (uiRes("m_doSubdivAttachArgList.kHistoryError"));
		error($msg);
		return $status;
	}
	else if( 1 == $whichMode ) {
		string $msg = (uiRes("m_doSubdivAttachArgList.kProxyError"));
		error($msg);
		return $status;
	}

	$whichMode = `subdiv -q -proxyMode $subd2`;
	if( 2 == $whichMode ) {
		string $msg = uiRes("m_doSubdivAttachArgList.kHistoryError");
		error( $msg );
		return $status;
	}
	else if( 1 == $whichMode ) {
		string $msg = uiRes("m_doSubdivAttachArgList.kProxyError");
		error( $msg );
		return $status;
	}

	waitCursor -st on;
	// trace( "// Processing " + $subd1 + " ...\n" );
	string $res1 = subdGivenIntoPolyMode( $subd1, $globalHist, 0, 0, 1 );
	waitCursor -st off;

	// trace( "// Processing " + $subd2 + " ...\n" );
	waitCursor -st on;
	string $res2 = subdGivenIntoPolyMode( $subd2, $globalHist, 0, 0, 1 );
	waitCursor -st off;

	// trace( "// Combining " + $res1 + " and " + $res2 + " ...\n" );
	waitCursor -st on;
	// Perform the unite operation with history toggled on.. This is
	// much more efficient because deleting history results in a couple
	// of very expensive data (including blindData) computations.
	// Part of bug #148350.
	//
	string $newPoly[] = `polyUnite -ch 1 $res1 $res2`;
	waitCursor -st off;
	if( size($newPoly) > 0 ) {
		// Too much stuff going on; we have to just go with
		// the Sew edge and hope for the best...
		select -r $newPoly[0];
		// trace( "// Merging multiple edges on " + $newPoly[0] + " ...\n" );
		waitCursor -st on;

		simulatePerformPolySewEdge( $fval, $ivSM, $ivWS );
		waitCursor -st off;
		select -r $newPoly[0];

		// trace( "// Creating the resulting subdivision surface.\n" );
		waitCursor -st on;
		doSubdivCreate( "3", { "1", "0", "10000", "128", "1" } );

		// Now delete the temporary polys that were created to perform
		// the unite operation.
		//
		delete $res1 $res2;

		if( $delOrig ) {
			// Delete the original surfaces.. They get deleted along with
			// their parent transform, if the parent transform does not have
			// any other children.. Else, the surface gets deleted, leaving
			// the parent transform untouched. All this happens only if there
			// is no instancing above the shape..
			//
			string $parents[] = `listRelatives -parent $subd1`;
			if( size($parents) == 1 ) {
				string $children[] = `listRelatives -children $parents[0]`;
				if( size($children) == 1 ) {
					// Parent transform has one child.. Delete both the
					// transform and child (subd surface)..
					//
					delete $parents[0];
				}
				else {
					// Parent transform has multiple children.. Play it safe
					// and just delete the subd surface..
					//
					delete $subd1;
				}
			}
			else {
				string $msg = (uiRes("m_doSubdivAttachArgList.kCantDelete"));
				warning($msg);
			}
			// Repeat this for $subd2
			//
			$parents = `listRelatives -parent $subd2`;
			if( size($parents) == 1 ) {
				$children = `listRelatives -children $parents[0]`;
				if( size($children) == 1 ) {
					// Parent transform has one child.. Delete both the
					// transform and child (subd surface)..
					//
					delete $parents[0];
				}
				else {
					// Parent transform has multiple children.. Play it safe
					// and just delete the subd surface..
					//
					delete $subd2;
				}
			}
			else {
				string $msg = uiRes("m_doSubdivAttachArgList.kCantDelete");
				warning($msg);
			}
		}
		waitCursor -st off;
		$status = 0;
	}
	else {
		string $msg = (uiRes("m_doSubdivAttachArgList.kCombineFailed"));
		error( $msg );
	}
	setSelectMode objects Objects;

	return $status;
}


