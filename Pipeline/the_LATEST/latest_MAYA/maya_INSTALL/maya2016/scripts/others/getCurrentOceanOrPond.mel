// Copyright (C) 1997-2014 Autodesk, Inc., and/or its licensors.
// All rights reserved.
//
// The coded instructions, statements, computer programs, and/or related
// material (collectively the "Data") in these files contain unpublished
// information proprietary to Autodesk, Inc. ("Autodesk") and/or its licensors,
// which is protected by U.S. and Canadian federal copyright law and by
// international treaties.
//
// The Data is provided for use exclusively by You. You have the right to use,
// modify, and incorporate this Data into other products for purposes authorized 
// by the Autodesk software license agreement, without fee.
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND. AUTODESK
// DOES NOT MAKE AND HEREBY DISCLAIMS ANY EXPRESS OR IMPLIED WARRANTIES
// INCLUDING, BUT NOT LIMITED TO, THE WARRANTIES OF NON-INFRINGEMENT,
// MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE, OR ARISING FROM A COURSE 
// OF DEALING, USAGE, OR TRADE PRACTICE. IN NO EVENT WILL AUTODESK AND/OR ITS
// LICENSORS BE LIABLE FOR ANY LOST REVENUES, DATA, OR PROFITS, OR SPECIAL,
// DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES, EVEN IF AUTODESK AND/OR ITS
// LICENSORS HAS BEEN ADVISED OF THE POSSIBILITY OR PROBABILITY OF SUCH DAMAGES.

//
//
//  Creation Date:  2002
//
// Description: Get selected or sole ocean shader
//	

proc int isUsablePond( string $fluid ){
	int $solver = getAttr ($fluid + ".solver");
	if( $solver < 2 ){
		return false;
	}
	int $is2d 		 = getAttr ($fluid + ".is2d");
	if( $is2d == 0 ){ return false; }

	int $heightField = getAttr ($fluid + ".heightField");
	if( !$heightField ){ return false; }

	int $opacityInput = getAttr ($fluid + ".opacityInput");
	if( $opacityInput != 5 ){ return false; }

	int $densityMethod = getAttr ($fluid + ".densityMethod");
	if( $densityMethod != 2 ){ return false; }

	return( true );
}

proc string[] getPondFluids() {
	string $pondFluids[];
	string $fluids[] = `ls -dag -type fluidShape`;
	for(  $i = 0; $i < size( $fluids ); $i++ ){
		if( isUsablePond( $fluids[$i] ) ){
			$pondFluids[size($pondFluids)] = $fluids[$i];
		}
	}
	return  $pondFluids;
}

global proc string getCurrentOceanOrPond()
{
	// if there is exactly one ocean or pond in the scene, use it

	string $shaders[] = `ls -type oceanShader`;
	string $fluids[] = getPondFluids();
	int $numThings = size($shaders) + size($fluids);
	if( $numThings == 0 ){
		warning((uiRes("m_getCurrentOceanOrPond.kNoOceanOrPOnd")));
		return( "" );
	}
	// If only one shader or pond then use it
	if( $numThings == 1 ){
		if( size( $shaders ) == 1 ){
			return( $shaders[0] );
		} else {
			return( $fluids[0] );
		}
	}

	// There is more than one, so we need to disambiguate using the selection
	// if there there is more than one ocean and/or pond selected, 
	// we will look for the first ocean or pond selected


	// First check for selected oceanShaders 
	string $sel[] = `ls -sl -type oceanShader`;
	if( size($sel) > 0 ){
		return( $sel[0] );
	}

	// next check for selected objects with ocean shaders or selected ponds
	string $sel[] = `ls -sl -dag -type shape`;
	int $i;
	for( $i = 0; $i < size( $sel ); $i++ ){
		string $nType = `nodeType $sel[$i]`;
		if( $nType == "heightField" ){
			string $con[] = `listConnections ($sel[$i] + ".displacement")`;
			if( size( $con ) > 0){
				$nType = `nodeType $con[0]`;
				if( $nType == "oceanShader" ){
					return( $con[0] );
				}
			}
		} else if( $nType == "fluidShape" ){
			// is it a fluid shape that is a pond (and not already an ocean wake)
			if( isUsablePond( $sel[$i] ) ){
				return( $sel[$i] );
			}

		} else {
			string $con[] = `listConnections ($sel[$i] + ".instObjGroups[0]")`;
			if( size( $con ) > 0 ){
				string $con2[] = `listConnections ($con[0] + ".displacementShader")`;
				if( size( $con2 ) > 0 ){
					$nType = `nodeType $con2[0]`;
					if( $nType == "oceanShader" ){
						return( $con2[0] );
					}
				}
			}
		}
	}

	warning((uiRes("m_getCurrentOceanOrPond.kTooManyOceansOrPonds")));
	return( "" );	
}
