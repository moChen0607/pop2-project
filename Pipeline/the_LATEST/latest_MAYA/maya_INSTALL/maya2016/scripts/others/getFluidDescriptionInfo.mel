// Copyright (C) 1997-2014 Autodesk, Inc., and/or its licensors.
// All rights reserved.
//
// The coded instructions, statements, computer programs, and/or related
// material (collectively the "Data") in these files contain unpublished
// information proprietary to Autodesk, Inc. ("Autodesk") and/or its licensors,
// which is protected by U.S. and Canadian federal copyright law and by
// international treaties.
//
// The Data is provided for use exclusively by You. You have the right to use,
// modify, and incorporate this Data into other products for purposes authorized 
// by the Autodesk software license agreement, without fee.
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND. AUTODESK
// DOES NOT MAKE AND HEREBY DISCLAIMS ANY EXPRESS OR IMPLIED WARRANTIES
// INCLUDING, BUT NOT LIMITED TO, THE WARRANTIES OF NON-INFRINGEMENT,
// MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE, OR ARISING FROM A COURSE 
// OF DEALING, USAGE, OR TRADE PRACTICE. IN NO EVENT WILL AUTODESK AND/OR ITS
// LICENSORS BE LIABLE FOR ANY LOST REVENUES, DATA, OR PROFITS, OR SPECIAL,
// DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES, EVEN IF AUTODESK AND/OR ITS
// LICENSORS HAS BEEN ADVISED OF THE POSSIBILITY OR PROBABILITY OF SUCH DAMAGES.

proc string[] getAttrDataForNode(string $node)
//
// Return a string array containing the values of the keyable and channelBox
// attributes for the given node.	
//
{
	string $result[];
	int $count = 0;

	if (`objExists ($node+".nts")`) {
		string $notes = `getAttr ($node+".nts")`;
		if (size($notes) > 0) {
			$result[$count] = ("Notes ("+$node+"): "+$notes);
			$count++;
		}
	}
	
	string $cbAttrs[] = `listAttr -scalar -channelBox $node`;
	for ($cbAttr in $cbAttrs) {
		float $val = `getAttr ($node+"."+$cbAttr)`;
		$result[$count] = ($node+"."+$cbAttr+"="+$val);
		$count++;
	}

	string $keyAttrs[] = `listAttr -multi -scalar -keyable -hasData $node`;
	for ($keyAttr in $keyAttrs) {
		float $val = `getAttr ($node+"."+$keyAttr)`;
		$result[$count] = ($node+"."+$keyAttr+"="+$val);
		$count++;
	}

	return $result;
}

proc string[] getAttrDataForManyNodes(string $nodes[])
{
	string $result[];
	for ($node in $nodes) {
		string $info[];
		$info = getAttrDataForNode($node);
		$result = stringArrayCatenate($result,$info);
	}
	return $result;
}

proc string[] getConnectedNodesOfType(string $node, string $type)
{
	string $conn[] = `listConnections -type $type $node`;
	string $result[] = `stringArrayRemoveDuplicates $conn`;
	return $result;
}


proc string[] getInfoForFluid(string $fluid)
{
	string $result[];

	string $dimAttrs[] = { "autoResize", "dimensionsW","dimensionsH", "dimensionsD" };
	int $count = 0;
	for ($dimAttr in $dimAttrs) {
		float $val = `getAttr ($fluid+"."+$dimAttr)`;
		$result[$count] = ($fluid+"."+$dimAttr+"="+$val);
		$count++;
	}

	string $fluidData[] = getAttrDataForNode($fluid);
	$result = stringArrayCatenate($result,$fluidData);

	string $emitterNodes[] = getConnectedNodesOfType($fluid,"fluidEmitter");	
	string $emitInfo[] = getAttrDataForManyNodes($emitterNodes);
	$result = stringArrayCatenate($result,$emitInfo);

	return $result;
	
}

global
proc string[] getFluidDescriptionInfo(string $obj)
{
	string $fluids[];
	if ($obj == "selected") {
		$fluids = getFluidObjectsToCache(0);
	} else {
		$fluids[0] = $obj;
	}

	string $info[];
	string $result[];
	for ($fluid in $fluids) {
		$result[size($result)] = ("Fluid Info for "+$fluid+":");
		clear($info);
		$info = getInfoForFluid($fluid);
		$result = stringArrayCatenate($result,$info);
	}
	return $result;

}
