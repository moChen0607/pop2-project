// Copyright (C) 1997-2014 Autodesk, Inc., and/or its licensors.
// All rights reserved.
//
// The coded instructions, statements, computer programs, and/or related
// material (collectively the "Data") in these files contain unpublished
// information proprietary to Autodesk, Inc. ("Autodesk") and/or its licensors,
// which is protected by U.S. and Canadian federal copyright law and by
// international treaties.
//
// The Data is provided for use exclusively by You. You have the right to use,
// modify, and incorporate this Data into other products for purposes authorized 
// by the Autodesk software license agreement, without fee.
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND. AUTODESK
// DOES NOT MAKE AND HEREBY DISCLAIMS ANY EXPRESS OR IMPLIED WARRANTIES
// INCLUDING, BUT NOT LIMITED TO, THE WARRANTIES OF NON-INFRINGEMENT,
// MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE, OR ARISING FROM A COURSE 
// OF DEALING, USAGE, OR TRADE PRACTICE. IN NO EVENT WILL AUTODESK AND/OR ITS
// LICENSORS BE LIABLE FOR ANY LOST REVENUES, DATA, OR PROFITS, OR SPECIAL,
// DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES, EVEN IF AUTODESK AND/OR ITS
// LICENSORS HAS BEEN ADVISED OF THE POSSIBILITY OR PROBABILITY OF SUCH DAMAGES.


//  Description:
//    Create and control an Artisan brush which can be used for doing common
//	  operations on components of polygonal surface. This script has been 
//	  updated for use with Maya 4.5.
//
//  Usage:
// - this should be mapped to the "o" hotkey by default
// - if not (existing users will not get the mapping if something was already 
//	 assigned to "o") go to hotkey editor and scroll to the Artisan section. 
//	 There should be two new entries there starting with "PolyBrush...". Assign
//   the press and release of a key to the corresponding press and release 
//	 command.
// - in a 3d view, press the hotkey and left mouse button to bring up marking
//   menu
//   - "Poly Brush" will create (if necessary) and switch to an instance
//     of the Artisan Paint Selection Tool which has been setup to do
//     operations on polygonal components
//   - the rest of the options correspond to various operations that
//     can be done on polygonal components
//   - if the current operation has an associated option box, the marking
//     menu will have an extra menu item which will bring it up 
// - the middle mouse button will bring up the "Poly UV Brush" marking
//	 menu
//
//  Notes:
// -	If you want to use one or more modifier keys (Ctrl, Alt, Shift) in combination
//	with another key to bring up the marking menu, you have to do two things:
//	1)	Type "polyBrushControl -5 <mod key identifier>" into the command line
//		where <mod key identifier> is:
//			0 if you don't want any modifier keys (this is the default)
//			1 if you want the Alt key modifier
//			2 if you want the Ctrl key modifier
//			4 if you want the Shift key modifier
//		If you want more than one modifier key, add up the numbers associated
//		with the modifier keys and use that as <mod key identifier>
//	2)	Go to the hotkey editor and change the "Poly Brush Operation..." entries
//		to correspond to the choices made in 1)
//


proc setPolyBrushOptions(
	int	$forceFactorySettings
)
{
	if ($forceFactorySettings || !`optionVar -exists polyBrushOperation`)
		optionVar -intValue polyBrushOperation 19;
	if ($forceFactorySettings || !`optionVar -exists polyUVBrushOperation`)
		optionVar -intValue polyUVBrushOperation 8;
	if ($forceFactorySettings || !`optionVar -exists polyBrushMMModKeys`)
		optionVar -intValue polyBrushMMModKeys 0;
}

//  Procedure Name:
//      pbEdgeMask
//
//  Description:
//      This procedure is called by initStrokeProcs and 
//		initUVStrokeProcs. It puts artisan in select edges
//		mode.

global proc pbEdgeMask()
{
	setComponentPickMask "Line" true;
}

//  Procedure Name:
//      pbFacetMask
//
//  Description:
//      This procedure is called by initStrokeProcs and 
//		initUVStrokeProcs. It puts artisan in select faces
//		mode.

global proc pbFacetMask()
{
	setComponentPickMask "Facet" true;
}

//  Procedure Name:
//      pbVertexMask
//
//  Description:
//      This procedure is called by initStrokeProcs and 
//		initUVStrokeProcs. It puts artisan in select vertices
//		mode.

global proc pbVertexMask()
{
	setComponentPickMask "Point" true;
}

//  Procedure Name:
//      pbUVMask
//
//  Description:
//      This procedure is called by initStrokeProcs and 
//		initUVStrokeProcs. It puts artisan in select UVs
//		mode.
//
//		Artisan cannot select UVs as of v4.5 so this is
//		not called but left commented out for the day
//		when UVs are handled.
/*
global proc pbUVMask()
{
	setComponentPickMask "UV" true;
}
*/

//  Procedure Name:
//      pbVertexFaceMask
//
//  Description:
//      This procedure is called by initStrokeProcs and 
//		initUVStrokeProcs. It puts artisan in select 
//		vertex face mode.
//
//		Artisan cannot select vertex faces as of v4.5 so 
//		this is not called but left commented out for the day
//		when they are handled.
/*
global proc pbVertexFaceMask()
{
	setComponentPickMask "VertexFace" true;
}
*/

//  Procedure Name:
//      evalPolyCmd
//
//  Description:
//      This procedure queries the state of construction
//		history and sets the construction history flag
//		for some of the marking menu items. The affected 
//		procedures follow this one.
//
//		See pbHarden for an example.
//
//		I think this is obsolete.

proc evalPolyCmd(
	string	$cmdBase
)
{
	string	$cmd = $cmdBase +  " -ch `constructionHistory -q -tgl`";

	evalEcho $cmd;
}

//  Procedure Name:
//      pbHarden
//
//  Description:
//      This procedure will harden the painted edges. 
//		Hardening is a specific option of polySoftEdge
//		requiring this explicit procedure.	
//
//		The angle is set to 0 to be hard.

global proc pbHarden()
{
	polySoftEdge -a 0 -ws 1;
}

//  Procedure Name:
//      pbSoften
//
//  Description:
//      This procedure will soften the painted edges. 
//		Softening is a specific option of polySoftEdge
//		requiring this explicit procedure.
//
//		The angle is set to 180 to be soft.

global proc pbSoften()
{
	polySoftEdge -a 180 -ws 1;
}

//  Procedure Name:
//      pbReverseNormal
//
//  Description:
//      This procedure will reverse the normals of
//		painted faces. 
//
//	Arguments:
//		$mode
//			0: reverse 
//			1: propagate 
//			2: conform 
//			3: reverse and cut 
//			4: reverse and propagate 
//
//		Only modes 3 and 4 are currently used as
//		the other modes are being phased out. Only
//		mode 4 is actually called.
//
//	This item is a good candidate for removal if more
//	space is required on the marking menu.

global proc pbReverseNormal(
	int	$mode
)
{
	polyNormal -nm $mode;
}

//  Procedure Name:
//      pbSelectionConstraints
//
//  Description:
//      This procedure will is used for the selection
//		menu items. The option box for any select mode
//		will be the selection constraints window.

global proc pbSelectionConstraints(
	int	$mode
)
{
	if ( $mode == 1 ) {
		openSelectionConstraintWindow();
	}
}

//  Procedure Name:
//      pb3dPaint
//
//  Description:
//      This procedure is used for 3d paint
//		tool. The 3d paint runtime commands do not use
//		an argument but one is required to fit the
//		the style 
//
//	Arguments:
//		$mode
//			0: tool
//			1: tool options

global proc pb3dPaint(
	int	$mode
)
{
	if ($mode == 0){
		Art3dPaintTool;
	}
	else if ($mode == 1){
		Art3dPaintToolOptions;
	}
}

//  Procedure Name:
//      pbColorPaint
//
//  Description:
//      This procedure is used for CPV paint
//		tool. The CPV paint runtime commands do not use
//		an argument but one is required to fit the
//		the style 
//
//	Arguments:
//		$mode
//			0: tool
//			1: tool options

global proc pbColorPaint(
	int	$mode
)
{
	if ($mode == 0){
		PaintVertexColorTool;
	}
	else if ($mode == 1){
		PaintVertexColorToolOptions;
	}
}

//  Procedure Name:
//      pbSculpt
//
//  Description:
//      This procedure is used for paint sculpting
//		tool. The sculpt paint runtime commands do not use
//		an argument but one is required to fit the
//		the style 
//
//	Arguments:
//		$mode
//			0: tool
//			1: tool options

global proc pbSculpt(
	int	$mode
)
{
	if ($mode == 0){
		SculptGeometryTool;
	}
	else if ($mode == 1){
		SculptGeometryToolOptions;
	}
}

//  Procedure Name:
//      pbUVCameraProjection
//
//  Description:
//      This procedure will project UVs based on the current camera. 


global proc pbUVCameraProjection()
{
	polyProjection -type Planar -md p;
}

//  Procedure Name:
//      addPolyBrushProcs
//
//  Description:
//      This procedure adds all the marking menu items to the
//		global string $pbStrokeProcs[]. Every operation has a 
//		UI name and two procs: preStroke and postStroke
//
//	Arguments:
//		$uiName: the name appearing in the marking menu
//		$preStrokeProc: the command to run before painting
//		$postStrokeProc: the command to run after painting
//
//	Example:
//		addPolyBrushProcs( "Triangulate", "pbFacetMask", "polyTriangulate" );
//
//		This adds the triangulate menu item. The pre stroke proc
//		is pbFacetMask because the triangulate command works on
//		faces. The post stroke proc is polyTriangulate - the MEL 
//		command to triangulate faces.

global string $pbStrokeProcs[];
global int $pbStrokeProcsInited = false;

proc addPolyBrushProcs(
	string	$uiName,
	string	$preStrokeProc,
	string	$postStrokeProc
)
{
	global string	$pbStrokeProcs[];

	int		 $n = size( $pbStrokeProcs );

	$pbStrokeProcs[$n  ]=$uiName;
	$pbStrokeProcs[$n+1]=$preStrokeProc;
	$pbStrokeProcs[$n+2]=$postStrokeProc;
}

//  Procedure Name:
//      addPolyUVBrushProcs
//
//  Description:
//      This procedure adds all the marking menu items to the
//		global string $pbUVStrokeProcs[]. Every operation has a 
//		UI name and two procs: preStroke and postStroke
//
//	Arguments:
//		$uiName: the name appearing in the marking menu
//		$preStrokeProc: the command to run before painting
//		$postStrokeProc: the command to run after painting
//
//	Example:
//		See addPolyBrushProcs above as the syntax is the same.
//
//		This procedure exists for the MMB which controls the
//		UV commands.

global string $pbUVStrokeProcs[];
global int $pbUVStrokeProcsInited = false;

proc addPolyUVBrushProcs(
	string	$uiName,
	string	$preStrokeProc,
	string	$postStrokeProc
)
{
	global string	$pbUVStrokeProcs[];

	int		 $n = size( $pbUVStrokeProcs );

	$pbUVStrokeProcs[$n  ]=$uiName;
	$pbUVStrokeProcs[$n+1]=$preStrokeProc;
	$pbUVStrokeProcs[$n+2]=$postStrokeProc;
}

//  Procedure Name:
//      initStrokeProcs
//
//  Description:
//      This procedure creates all the stroke procedures for the 
//		LMB marking menu (the poly tools). Each command is added
//		to the global string $pbStrokeProcs[] and is called as a
//		menuItem in the polyBrushMM procedure.
//

proc initStrokeProcs()
{
	global string	$pbStrokeProcs[];

	clear( $pbStrokeProcs );

	addPolyBrushProcs( (uiRes("m_polyBrushControl.kHarden")),					"pbEdgeMask",	"pbHarden" );					// 0
	addPolyBrushProcs( (uiRes("m_polyBrushControl.kSoften")),					"pbEdgeMask",	"pbSoften" );					// 1
	addPolyBrushProcs( (uiRes("m_polyBrushControl.kSetNormalAngle")),	"pbEdgeMask",	"polySoftEdgeWin" );		// 2
	addPolyBrushProcs( (uiRes("m_polyBrushControl.kTriangulate")),		"pbFacetMask",	"polyTriangulate" );				// 3
	addPolyBrushProcs( (uiRes("m_polyBrushControl.kQuadrangulate")),	"pbFacetMask",	"performPolyQuadrangulate %" );	// 4
	addPolyBrushProcs( (uiRes("m_polyBrushControl.kSmooth")),					"pbFacetMask",	"performPolySmooth %" );		// 5
	addPolyBrushProcs( (uiRes("m_polyBrushControl.kMergeVertices")),	"pbVertexMask",	"performPolyMerge %" );	// 6
	addPolyBrushProcs( (uiRes("m_polyBrushControl.kAddDivisionsFaces")) ,"pbFacetMask",	"performPolySubdivide \"f\" %" );	// 7
	addPolyBrushProcs( (uiRes("m_polyBrushControl.kAddDivisionsEdges")) ,"pbEdgeMask",	"performPolySubdivide \"e\" %" );	// 8
	addPolyBrushProcs( (uiRes("m_polyBrushControl.kCollapseFaces")),	"pbFacetMask",	"polyCollapseFacet" );			// 9
	addPolyBrushProcs( (uiRes("m_polyBrushControl.kCollapseEdgges")),	"pbEdgeMask",	"polyCollapseEdge" );				// 10
	addPolyBrushProcs( (uiRes("m_polyBrushControl.kDeleteFaces")),		"pbFacetMask",	"doDelete" );				// 11
	addPolyBrushProcs( (uiRes("m_polyBrushControl.kDeleteEdges")),		"pbEdgeMask",	"DeleteEdge" );					// 12
	//	The following item is not used but remains so that the
	//	numbering scheme is not disturbed.
	addPolyBrushProcs( "Reverse (Obsolete)",						"pbFacetMask",	"pbReverseNormal 0" );			// 13
	addPolyBrushProcs( (uiRes("m_polyBrushControl.kReversePropagate")),	"pbFacetMask",	"pbReverseNormal 4" );			// 14
	addPolyBrushProcs( (uiRes("m_polyBrushControl.kReverse")),				"pbFacetMask",	"performPolyNormal % -1 0;" );	// 15
	addPolyBrushProcs( (uiRes("m_polyBrushControl.kDeleteVertices")),	"pbVertexMask",	"polyDeleteVertex" );			// 16
	addPolyBrushProcs( (uiRes("m_polyBrushControl.kSelectFaces")),		"pbFacetMask",	"pbSelectionConstraints %" );	// 17
	addPolyBrushProcs( (uiRes("m_polyBrushControl.kSelectEdges")),		"pbEdgeMask",	"pbSelectionConstraints %" );	// 18
	addPolyBrushProcs( (uiRes("m_polyBrushControl.kSelectVertices")),	"pbVertexMask",	"pbSelectionConstraints %" );	// 19
	addPolyBrushProcs( (uiRes("m_polyBrushControl.kCopyFaceInfo")),	"pbFacetMask",	"performPolyCopyPaste % 1" );	// 20
	addPolyBrushProcs( (uiRes("m_polyBrushControl.kPasteFaceInfo")),	"pbFacetMask",	"performPolyCopyPaste % 2" );	// 21
	addPolyBrushProcs( (uiRes("m_polyBrushControl.kMergeEdges")),			"pbEdgeMask",	"performPolyMerge %" );		// 22
	addPolyBrushProcs( (uiRes("m_polyBrushControl.kExtractFaces")),		"pbFacetMask",	"performPolyChipOff % 0" );		// 23
	addPolyBrushProcs( (uiRes("m_polyBrushControl.kDuplicateFaces")),	"pbFacetMask",	"performPolyChipOff % 1" );		// 24
	addPolyBrushProcs( (uiRes("m_polyBrushControl.kExtrudeFaces")),		"pbFacetMask",	"performPolyExtrude %" );		// 25
	addPolyBrushProcs( (uiRes("m_polyBrushControl.kBevel")),					"pbEdgeMask",	"performPolyBevel %" );			// 26
	//	The following two items; are not yet implemented in artisan
	//	and are invisible to the user. Maintained to not disturb
	//	the numbering scheme.;
	addPolyBrushProcs( (uiRes("m_polyBrushControl.kSelectUVs")),			"pbUVMask",		"pbSelectionConstraints %" );	// 27
	addPolyBrushProcs( (uiRes("m_polyBrushControl.kSelectVertexFaces")),	"pbVertexFaceMask",	"pbSelectionConstraints %" );	// 28
	addPolyBrushProcs( (uiRes("m_polyBrushControl.kAverageNormals")),	"pbVertexMask",	"performPolySetNormal  %" );	// 29				
	addPolyBrushProcs( (uiRes("m_polyBrushControl.kSetVertexNormal")),		"pbVertexMask",	"performPolyAverageNormal %" );	// 30
	addPolyBrushProcs( (uiRes("m_polyBrushControl.kSetToFace")),			"pbVertexMask",	"performPolySetToFaceNormal %" );	// 31
	addPolyBrushProcs( (uiRes("m_polyBrushControl.kFlipEdges")),			"pbEdgeMask",	"polyFlipEdge" );				// 32
	addPolyBrushProcs( (uiRes("m_polyBrushControl.kSculptPolygons")),	"pbVertexMask",	"pbSculpt %" );					// 33
	addPolyBrushProcs( (uiRes("m_polyBrushControl.kAverageVertices")),"pbVertexMask",	"performPolyAverageVertex %" );	// 34
	addPolyBrushProcs( (uiRes("m_polyBrushControl.kReduce")),					"pbFacetMask",	"performPolyReduce %" );	// 35
	addPolyBrushProcs( (uiRes("m_polyBrushControl.kCleanup")),				"pbFacetMask",	"performPolyCleanup %" );	// 36
	addPolyBrushProcs( (uiRes("m_polyBrushControl.kCutFaces")),				"pbFacetMask",	"performPolyCut %" );	// 37
	addPolyBrushProcs( (uiRes("m_polyBrushControl.kSplitVertices")),	"pbVertexMask",	"polySplitVertex" );	// 38
	addPolyBrushProcs( (uiRes("m_polyBrushControl.kPokeFace")),				"pbFacetMask",	"performPolyPoke %" );	// 39
	addPolyBrushProcs( (uiRes("m_polyBrushControl.kWedgeFace")),			"pbFacetMask",	"performPolyWedgeFace %" );	// 40
	addPolyBrushProcs( (uiRes("m_polyBrushControl.kSplitFaces")),			"pbFacetMask",	"SplitPolygonTool" );		// 41
	addPolyBrushProcs( (uiRes("m_polyBrushControl.kExtrudeEdges")),		"pbEdgeMask",	"performPolyExtrude %" );		// 42
}

//  Procedure Name:
//      initUVStrokeProcs
//
//  Description:
//      This procedure creates all the stroke procedures for the 
//		MMB marking menu (the UV tools). Each command is added
//		to the global string $pbUVStrokeProcs[] and is called as a
//		menuItem in the polyBrushMM procedure.
//

proc initUVStrokeProcs()
{
	global string	$pbUVStrokeProcs[];

	clear( $pbUVStrokeProcs );
	addPolyUVBrushProcs( (uiRes("m_polyBrushControl.kCopyFaceInfoUV")),		"pbFacetMask",	"performPolyCopyPaste % 1" );	// 0
	addPolyUVBrushProcs( (uiRes("m_polyBrushControl.kPasteFaceInfoUV")),		"pbFacetMask",	"performPolyCopyPaste % 2" );	// 1
	addPolyUVBrushProcs( (uiRes("m_polyBrushControl.kSetToFaceUV")),			"pbVertexMask",	"performPolySetToFaceNormal %" );	// 2
	addPolyUVBrushProcs( (uiRes("m_polyBrushControl.kPaint3D")),					"pbFacetMask",	"pb3dPaint %" );				// 3
	addPolyUVBrushProcs( (uiRes("m_polyBrushControl.kSetColorKey")),		"pbVertexMask",	"setPolyColorKeyframe" );		// 4
	addPolyUVBrushProcs( (uiRes("m_polyBrushControl.kPrelightMaya")),		"pbFacetMask",	"performPrelight %" );			// 5
	addPolyUVBrushProcs( (uiRes("m_polyBrushControl.kApplyColor")),			"pbVertexMask",	"performApplyColor %" );		// 6
	addPolyUVBrushProcs( (uiRes("m_polyBrushControl.kPaintColor")),			"pbVertexMask",	"pbColorPaint %" );				// 7
	// the performPolyProjection command brings up the wrong option box for planar projection
	// so we use the performPolyProjectionArgList instead
	addPolyUVBrushProcs( (uiRes("m_polyBrushControl.kPlanarMapping")),		"pbFacetMask",	"performPolyProjectionArgList \"1\" {\"%\", \"Planar\", \"ls -sl\", \"0\"} \"\"" );// 8
	addPolyUVBrushProcs( (uiRes("m_polyBrushControl.kCylindricalMapping")),	"pbFacetMask",	"performPolyProjection cylindrical %" );	// 9
	addPolyUVBrushProcs( (uiRes("m_polyBrushControl.kSphericalMapping")),"pbFacetMask",	"performPolyProjection spherical %" );	// 10
	addPolyUVBrushProcs( (uiRes("m_polyBrushControl.kAutomaticMapping")),"pbFacetMask",	"performPolyAutoProj %" );		// 11
	addPolyUVBrushProcs( (uiRes("m_polyBrushControl.kBestPlaneMapping")),		"pbFacetMask",	"setToolTo polyBestPlaneTexturingContext" );	// 12
	addPolyUVBrushProcs( (uiRes("m_polyBrushControl.kCameraMapping")),		"pbFacetMask",	"pbUVCameraProjection" );		// 13
	addPolyUVBrushProcs( (uiRes("m_polyBrushControl.kNormalizeUVs")),		"pbFacetMask",	"performPolyForceUV normalize %" );		// 14
	addPolyUVBrushProcs( (uiRes("m_polyBrushControl.kUnitizeUVs")),			"pbFacetMask",	"performPolyForceUV unitize %" );		// 15
	addPolyUVBrushProcs( (uiRes("m_polyBrushControl.kFlipUVs")),					"pbFacetMask",	"performPolyForceUV flip %" );		// 16
	// the following mask should be UV but is not yet implemented for artisan
	// so, select verts and convert to UVs
	// same applies for straighten and relax
	addPolyUVBrushProcs( (uiRes("m_polyBrushControl.kRotateUVs")),				"pbFacetMask",	"ConvertSelectionToUVs; performPolyRotateUVs %" );	// 17
	addPolyUVBrushProcs( (uiRes("m_polyBrushControl.kMapUVBorder")),		"pbFacetMask",	"performPolyUntangleUV map  %" );// 18
	addPolyUVBrushProcs( (uiRes("m_polyBrushControl.kStraigtenUVBorder")),		"pbFacetMask",	"ConvertSelectionToUVs; performPolyStraightenUV %" );// 19
	addPolyUVBrushProcs( (uiRes("m_polyBrushControl.kRelaxUVs")),				"pbFacetMask",	"ConvertSelectionToUVs; performPolyUntangleUV relax  %" );// 20
	addPolyUVBrushProcs( (uiRes("m_polyBrushControl.kLayoutUVs")),				"pbFacetMask",	"performPolyLayoutUV %" );		// 21
	addPolyUVBrushProcs( (uiRes("m_polyBrushControl.kCutUVs")),					"pbEdgeMask",	"polyMapCut" );		// 22
	addPolyUVBrushProcs( (uiRes("m_polyBrushControl.kSewUVs")),					"pbEdgeMask",	"polyMapSew" );		// 23
	addPolyUVBrushProcs( (uiRes("m_polyBrushControl.kMoveAndSewUVs")),	"pbEdgeMask",	"performPolyMapSewMove %" );		// 24
	//see above note for merge UVs
	addPolyUVBrushProcs( (uiRes("m_polyBrushControl.kMergeUVs")),				"pbVertexMask",	"ConvertSelectionToUVs; performPolyMergeUV %" );		// 25
	addPolyUVBrushProcs( (uiRes("m_polyBrushControl.kDeleteUVs")),				"pbFacetMask",	"polyMapDel" );		// 26

}

global proc pbSetCurrentOperation(
	int	$op
)
{
	setPolyBrushOptions( false );

	optionVar -intValue polyBrushOperation $op;
	polyBrushControl -0 0;
	polyBrushControl -3 0;
}

global proc pbUVSetCurrentOperation(
	int	$op
)
{
	setPolyBrushOptions( false );

	optionVar -intValue polyUVBrushOperation $op;
	polyUVBrushControl -0 0;
	polyUVBrushControl -3 0;
}

//  Procedure Name:
//      polyBrushMenuItem
//
//  Description:
//      This procedure adds the menu items as called from
//		the polyBrushMM proc. The $procIdx is the index
//		of the command in $pbStrokeProcs.

proc polyBrushMenuItem(
	string	$radialPosition,
	int		$procIdx
)
{
	global string	$pbStrokeProcs[];

	menuItem -radialPosition $radialPosition -l $pbStrokeProcs[$procIdx * 3] 
		-command ("pbSetCurrentOperation " + $procIdx);
}

//  Procedure Name:
//      polyUVBrushMenuItem
//
//  Description:
//      This procedure adds the menu items as called from
//		the polyBrushMM proc. The $procIdx is the index
//		of the command in $pbUVStrokeProcs.

proc polyUVBrushMenuItem(
	string	$radialPosition,
	int		$procIdx
)
{
	global string	$pbUVStrokeProcs[];

	menuItem -radialPosition $radialPosition -l $pbUVStrokeProcs[$procIdx * 3] 
		-command ("pbUVSetCurrentOperation " + $procIdx);
}

//  Procedure Name:
//      polyBrushMM
//
//  Description:
//      This procedure builds the marking menus. The UV menu is
//		built first for the MMB. The poly menu is built afterwards
//		for the LMB.

proc polyBrushMM()
{
	deletePopupMenu();
	setPolyBrushOptions( false );

	// - $modKeysNeeded == 0 --> no modifier keys needed
	// - $modKeysNeeded == 1 --> alt modifier key needed
	// - $modKeysNeeded == 2 --> ctrl modifier key needed
	// - $modKeysNeeded == 4 --> shift modifier key needed
	//
	int		$modKeysNeeded = `optionVar -query polyBrushMMModKeys`;
	int		$modKeys[3];
	int		$mk;

	for ( $mk = 0; $mk < 3; $mk++ ) {
		$modKeys[$mk] = $modKeysNeeded % 2;
		$modKeysNeeded /= 2;
	}

	//	build MMB menu for UV commands
	popupMenu -mm 1 -b 2 -p `findPanelPopupParent`
		-alt $modKeys[0] -ctl $modKeys[1] -sh $modKeys[2] tempMM2;

		menuItem -rp "W" -l (uiRes("m_polyBrushControl.kColorTexture")) -subMenu true;
			polyUVBrushMenuItem "N"	 0;	//copy
			polyUVBrushMenuItem "NE" 1;	//paste
			polyUVBrushMenuItem "W"	 3;	//3d paint
			polyUVBrushMenuItem "SW" 4;	//set key
			polyUVBrushMenuItem "S"  5;	//prelight
			polyUVBrushMenuItem "SE" 6;	//apply color
			polyUVBrushMenuItem "E"  7;	//paint color
		setParent -menu ..;
		menuItem -rp "S" -l (uiRes("m_polyBrushControl.kUVProjection")) -subMenu true;
			polyUVBrushMenuItem "W"	 8;	//planar
			polyUVBrushMenuItem "N"  9;	//cylindrical
			polyUVBrushMenuItem "E" 10;	//spherical
			polyUVBrushMenuItem "S" 11;	//auto
			polyUVBrushMenuItem "SW" 12;//best plane
			polyUVBrushMenuItem "SE" 13;//camera
		setParent -menu ..;
		menuItem -rp "E" -l (uiRes("m_polyBrushControl.kModifyUVs")) -subMenu true;
			polyUVBrushMenuItem "W"  14;//normalize
			polyUVBrushMenuItem "NW" 15;//unitize
			polyUVBrushMenuItem "N"  16;//flip
			polyUVBrushMenuItem "NE" 17;//rotate
			polyUVBrushMenuItem "E"  18;//map
			polyUVBrushMenuItem "SE" 19;//straighten
			polyUVBrushMenuItem "SW" 20;//relax
			polyUVBrushMenuItem "S"  21;//layout
		setParent -menu ..;
		menuItem -rp "SW" -l (uiRes("m_polyBrushControl.kCutSew")) -subMenu true;
			polyUVBrushMenuItem "W" 22;	//cut
			polyUVBrushMenuItem "E" 23;	//sew
			polyUVBrushMenuItem "S" 24;	//move/sew
			polyUVBrushMenuItem "N" 25;	//merge
			polyUVBrushMenuItem "NW" 26;//delete
		setParent -menu ..;

		global string	$pbUVStrokeProcs[];

		int		$currentUVOp = `optionVar -query polyUVBrushOperation`;
		int		$procUVIdx = 3 * $currentUVOp;	// UI name
		string	$polyUVBrushName = (uiRes("m_polyBrushControl.kPolyUVBrushName"));
		
		if ( $procUVIdx >= 0 && $procUVIdx < size( $pbUVStrokeProcs ) ) {
			$polyUVBrushName = `format -s $pbUVStrokeProcs[$procUVIdx] $polyUVBrushName`;

			// add menu to get at current operation's option box if it has one
			//
			if ( `polyUVBrushControl -4 0` ) {
				string $str = (uiRes("m_polyBrushControl.kOptions"));
				menuItem -rp "NE"
					-l (`format -stringArg $pbUVStrokeProcs[$procUVIdx] $str`)
					-c "polyUVBrushControl -4 1";
			}
		}

		menuItem -rp "N" -l $polyUVBrushName -c "polyUVBrushControl -3 0";

	setParent -m ..;

	//build LMB menu for mesh ops
	popupMenu -mm 1 -b 1 -p `findPanelPopupParent`
		-alt $modKeys[0] -ctl $modKeys[1] -sh $modKeys[2] tempMM;
		menuItem -rp "S" -l (uiRes("m_polyBrushControl.kNormals")) -subMenu true;
			polyBrushMenuItem "NE"	0;	//harden
			polyBrushMenuItem "N"	2;	//soften/harden
			polyBrushMenuItem "NW"	1;	//soften
			polyBrushMenuItem "SW"	14;	//reverse and propagate
			polyBrushMenuItem "W"	15;	//reverse
			polyBrushMenuItem "S"	29;	//set vertex normal
			polyBrushMenuItem "SE"	30;	//avg normal
			polyBrushMenuItem "E"	31;	//set to face
		setParent -menu ..;
		menuItem -rp "E" -l (uiRes("m_polyBrushControl.kDecreaseComplexity")) -subMenu true;
			polyBrushMenuItem "NW" 9;
			polyBrushMenuItem "NE" 10;
			polyBrushMenuItem "SW" 11;
			polyBrushMenuItem "SE" 12;
			polyBrushMenuItem "S" 16;
			polyBrushMenuItem "W" 6;
			polyBrushMenuItem "E" 22;
			polyBrushMenuItem "N" 4;
		setParent -menu ..;
		menuItem -rp "W" -l (uiRes("m_polyBrushControl.kIncreaseComplexity")) -subMenu true;
			polyBrushMenuItem "SW" 3;
			polyBrushMenuItem "SE" 5;
			polyBrushMenuItem "W" 8;
			polyBrushMenuItem "E" 7;
			polyBrushMenuItem "NW" 42;
			polyBrushMenuItem "NE" 24;
			polyBrushMenuItem "N" 25;
			polyBrushMenuItem "S" 26;
		setParent -menu ..;
		menuItem -rp "SE" -l (uiRes("m_polyBrushControl.kSelection")) -subMenu true;
			polyBrushMenuItem "N" 18;	//edges
			polyBrushMenuItem "W" 19;	//vert
			polyBrushMenuItem "S" 17;	//face
			//	UVs and vertFaces aren't currently supported by paint select
			//	uncomment the next 2 lines when they are so that they are
			//	available for users
			//	polyBrushMenuItem "E" 27;	//UV
			//	polyBrushMenuItem "SW" 28;	//vertex/face
		setParent -menu ..;
		menuItem -rp "SW" -l (uiRes("m_polyBrushControl.kModify")) -subMenu true;
			polyBrushMenuItem "NW" 32;	//flip
			polyBrushMenuItem "W" 23;	//extract
			polyBrushMenuItem "S" 34;	//average verts
			polyBrushMenuItem "SE" 40;	//wedge
			polyBrushMenuItem "E" 41;	//split face
			polyBrushMenuItem "N" 37;	//cut
			polyBrushMenuItem "NE" 38;	//split vert
			polyBrushMenuItem "SW" 39;	//poke
		setParent -menu ..;
		menuItem -rp "NW" -l (uiRes("m_polyBrushControl.kMeshOperations")) -subMenu true;
			polyBrushMenuItem "N" 35;	//reduce
			polyBrushMenuItem "W" 36;	//cleanup
			polyBrushMenuItem "S" 33;	//sculpt

		setParent -menu ..;

		global string	$pbStrokeProcs[];

		int		$currentOp = `optionVar -query polyBrushOperation`;
		int		$procIdx = 3 * $currentOp;	// UI name

		string	$polyBrushName = (uiRes("m_polyBrushControl.kPolyBrushName"));
	
		if ( $procIdx >= 0 && $procIdx < size( $pbStrokeProcs ) ) {
			$polyBrushName = `format -s $pbStrokeProcs[$procIdx] $polyBrushName`;

			// add menu to get at current operation's option box if it has one
			//
			if ( `polyBrushControl -4 0` ) {
				string $str = (uiRes("m_polyBrushControl.kOptions"));
				menuItem -rp "NE"
					-l (`format -s $pbStrokeProcs[$procIdx] $str`)
					-c "polyBrushControl -4 1";
			}
		}

		menuItem -rp "N" -l $polyBrushName -c "polyBrushControl -3 0";

	setParent -m ..;

}

// This was copied from initContexts.mel
//
proc rememberCtxSettings( string $ctxName )
//
// This method sees if an optionVar has been defined
// for the tool.  If it has, the string it contains
// is evaluated to set the tool settings.  SuperContexts
// should not be saved this way, since they have no
// particular settings.
//
{
	if ( `optionVar -exists $ctxName` ){
		string $cmd = `optionVar -q $ctxName`;
		catch( `eval($cmd)` );
	} else {
		// create an empty option var so that this
		// will be saved.
		optionVar -sv $ctxName "";
	}
}

proc switchToPolyBrushTool(
	int		$showToolProperties
)
{
	global string $pbPolyBrushToolCtx;
	
	if ( $pbPolyBrushToolCtx == "" ) {
		$pbPolyBrushToolCtx=`eval "artSelectCtx -i1 \"artSelect.png\" -ads false pbPolyBrushContext"`;
		rememberCtxSettings $pbPolyBrushToolCtx;			
	}

	string	$cmd;

	$cmd  = "ArtPaintSelectTool;artSelectCtx -e";
	$cmd += " -bsc \"polyBrushControl -2 0\"";
	$cmd += " -asc \"polyBrushControl -2 1\"";
	$cmd +=	" " + $pbPolyBrushToolCtx;
	eval $cmd;

	setToolTo $pbPolyBrushToolCtx;
	if ( $showToolProperties ) {
		toolPropertyWindow;
	}
}

proc switchToPolyUVBrushTool(
	int		$showToolProperties
)
{
	global string $pbPolyUVBrushToolCtx;
	
	if ( $pbPolyUVBrushToolCtx == "" ) {
		$pbPolyUVBrushToolCtx=`eval "artSelectCtx -i1 \"artSelect.png\" -ads false pbPolyUVBrushContext"`;
		rememberCtxSettings $pbPolyUVBrushToolCtx;			
	}

	string	$cmd;

	$cmd  = "ArtPaintSelectTool;artSelectCtx -e";
	$cmd += " -bsc \"polyUVBrushControl -2 0\"";
	$cmd += " -asc \"polyUVBrushControl -2 1\"";
	$cmd +=	" " + $pbPolyUVBrushToolCtx;
	eval $cmd;

	setToolTo $pbPolyUVBrushToolCtx;
	if ( $showToolProperties ) {
		toolPropertyWindow;
	}
}

//  Procedure Name:
//      polyUVBrushControl
//
//  Description:
//      This procedure controls the operation for the UV tools.
//
// $operation == -5 --> set required modifier keys for marking menu
// - $opMode == 0 --> no mod keys
// - $opMode == 1 --> alt key
// - $opMode == 2 --> ctrl key
// - $opMode == 4 --> shift key
// - for more than one modifier keys, set $opMode to sum of above opMode's
// $operation == -4 --> current operation option box
// - $opMode == 0 --> does it have option box
// - $opMode == 1 --> open option box
// $operation == -3 --> switch to poly brush tool
// - $opMode is ignored
// $operation == -2 --> use $current operation
// - $opMode == 0 --> run pre stroke command
// - $opMode == 1 --> run post stroke command
// $operation == -1 --> create marking menu
// - $opMode == 0 --> no modifier keys needed
// - $opMode == 1 --> alt modifier key needed
// - $opMode == 2 --> ctrl modifier key needed
// - $opMode == 4 --> shift modifier key needed
// $operation >= 0 --> run specified operation
// - $opMode == 0 --> run pre stroke command
// - $opMode == 1 --> run post stroke command
//

global proc int polyUVBrushControl(
	int		 $operation,
	int		 $opMode
)
{
	global string	$pbUVStrokeProcs[];
	global int		$pbUVStrokeProcsInited;
	setPolyBrushOptions( false );
	
	if ( ! $pbUVStrokeProcsInited ) {
		initStrokeProcs();
		$pbUVStrokeProcsInited = true;
	}

	int		$rc = true;
	int		$currentOp = `optionVar -query polyUVBrushOperation`;
	int		$procIdx;

	if ( $operation == -5 ) {
		optionVar -intValue polyUVBrushMMModKeys $opMode;
	} else if ( $operation == -4 ) {
		$procIdx = 3 * $currentOp + 2;		// post stroke command

		if ( $procIdx >= 0 && $procIdx < size( $pbUVStrokeProcs ) ) {
			// check if the post stroke command can bring up option box
			//
			$rc = `gmatch $pbUVStrokeProcs[$procIdx] "*%*"`; 

			if ( $rc && $opMode == 1 ) {
				// generate the command to bring up option box and execute
				//
				string	$cmd = `substitute "%" $pbUVStrokeProcs[$procIdx] "1"`;
				
				eval $cmd;
			}
		} else {
			$rc = false;
		}
	} else if ( $operation == -3 ) {
		switchToPolyUVBrushTool false;

		// do the pre stroke command for current operation
		//
		$operation = $currentOp;
		$opMode = 0;
	} else if ( $operation == -2 ) {
		$operation = $currentOp;
	} else if ( $operation == -1 ) {
		polyBrushMM;
	}

	$procIdx = 3 * $operation + ($opMode ? 1 : 0) + 1;

	if ( $procIdx >= 0 && $procIdx < size( $pbUVStrokeProcs )
	  && size( $pbUVStrokeProcs[$procIdx] ) > 0
	  && ( $opMode == 0 || size(`ls -sl`) > 0 ) ) {
		string	$cmd = $pbUVStrokeProcs[$procIdx];

		if ( $opMode == 1 ) { 
			// tell the command to run command on selected components
			//
			$cmd = `substitute "%" $cmd "0"`;
		}
		eval $cmd;
	}

	return $rc;
}

//  Procedure Name:
//      polyBrushControl
//
//  Description:
//      This procedure controls the operation for the poly tools.
//
// $operation == -5 --> set required modifier keys for marking menu
// - $opMode == 0 --> no mod keys
// - $opMode == 1 --> alt key
// - $opMode == 2 --> ctrl key
// - $opMode == 4 --> shift key
// - for more than one modifier keys, set $opMode to sum of above opMode's
// $operation == -4 --> current operation option box
// - $opMode == 0 --> does it have option box
// - $opMode == 1 --> open option box
// $operation == -3 --> switch to poly brush tool
// - $opMode is ignored
// $operation == -2 --> use $current operation
// - $opMode == 0 --> run pre stroke command
// - $opMode == 1 --> run post stroke command
// $operation == -1 --> create marking menu
// - $opMode == 0 --> no modifier keys needed
// - $opMode == 1 --> alt modifier key needed
// - $opMode == 2 --> ctrl modifier key needed
// - $opMode == 4 --> shift modifier key needed
// $operation >= 0 --> run specified operation
// - $opMode == 0 --> run pre stroke command
// - $opMode == 1 --> run post stroke command
//

global proc int polyBrushControl(
	int		 $operation,
	int		 $opMode
)
{
	global string	$pbStrokeProcs[];
	global int		$pbStrokeProcsInited;

	setPolyBrushOptions( false );

	if ( ! $pbStrokeProcsInited ) {
		initStrokeProcs();
		initUVStrokeProcs();
		$pbStrokeProcsInited = true;
	}

	int		$rc = true;
	int		$currentOp = `optionVar -query polyBrushOperation`;
	int		$procIdx;

	if ( $operation == -5 ) {
		optionVar -intValue polyBrushMMModKeys $opMode;
	} else if ( $operation == -4 ) {
		$procIdx = 3 * $currentOp + 2;		// post stroke command

		if ( $procIdx >= 0 && $procIdx < size( $pbStrokeProcs ) ) {
			// check if the post stroke command can bring up option box
			//
			$rc = `gmatch $pbStrokeProcs[$procIdx] "*%*"`; 

			if ( $rc && $opMode == 1 ) {
				// generate the command to bring up option box and execute
				//
				string	$cmd = `substitute "%" $pbStrokeProcs[$procIdx] "1"`;
				
				eval $cmd;
			}
		} else {
			$rc = false;
		}
	} else if ( $operation == -3 ) {
		switchToPolyBrushTool false;

		// do the pre stroke command for current operation
		//
		$operation = $currentOp;
		$opMode = 0;
	} else if ( $operation == -2 ) {
		$operation = $currentOp;
	} else if ( $operation == -1 ) {
		polyBrushMM;
	}

	$procIdx = 3 * $operation + ($opMode ? 1 : 0) + 1;

	if ( $procIdx >= 0 && $procIdx < size( $pbStrokeProcs )
	  && size( $pbStrokeProcs[$procIdx] ) > 0
	  && ( $opMode == 0 || size(`ls -sl`) > 0 ) ) {
		string	$cmd = $pbStrokeProcs[$procIdx];

		if ( $opMode == 1 ) { 
			// tell the command to run command on selected components
			//
			$cmd = `substitute "%" $cmd "0"`;
		}
		eval $cmd;
	}

	return $rc;
}
