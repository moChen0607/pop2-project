// Copyright (C) 1997-2014 Autodesk, Inc., and/or its licensors.
// All rights reserved.
//
// The coded instructions, statements, computer programs, and/or related
// material (collectively the "Data") in these files contain unpublished
// information proprietary to Autodesk, Inc. ("Autodesk") and/or its licensors,
// which is protected by U.S. and Canadian federal copyright law and by
// international treaties.
//
// The Data is provided for use exclusively by You. You have the right to use,
// modify, and incorporate this Data into other products for purposes authorized 
// by the Autodesk software license agreement, without fee.
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND. AUTODESK
// DOES NOT MAKE AND HEREBY DISCLAIMS ANY EXPRESS OR IMPLIED WARRANTIES
// INCLUDING, BUT NOT LIMITED TO, THE WARRANTIES OF NON-INFRINGEMENT,
// MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE, OR ARISING FROM A COURSE 
// OF DEALING, USAGE, OR TRADE PRACTICE. IN NO EVENT WILL AUTODESK AND/OR ITS
// LICENSORS BE LIABLE FOR ANY LOST REVENUES, DATA, OR PROFITS, OR SPECIAL,
// DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES, EVEN IF AUTODESK AND/OR ITS
// LICENSORS HAS BEEN ADVISED OF THE POSSIBILITY OR PROBABILITY OF SUCH DAMAGES.

//
//
//  ==================== expressionEditor.mel ==========
//
//  SYNOPSIS
//      Create and show a text dialog for creating and editing
//		expressions
//
//  CONTENTS
//		
//  PROCEDURES TO CREATE THE EXPRESSION EDITOR UI AND TOGGLE BETWEEN LAYOUTS.  
//		These are in expressionEditor.mel
//
//	EEmakeMenubar			Make the menubar menus.
//	EEmakeFilterPopup		Make filter popup menu.
//	EEcreateWin()			Create the expression editor window
//  EEpostConfirm			Post a confirm dialog.
//	EEswitchSelectLayout	Switch between select-by-expr/obj modes.
//  EEswitchRulesForm       Make visible/invisible rules form
//
//
//   EXPRESSION EDITOR QUERY PROCEDURES
//		These are in expressionEditor.mel
//
//  EEgetCurrTypeList       Get/return list of all objects of specified type.
//  EEgetExpressionList		Get/return list of all expressions in the scene.
//	EEgetAttrFromNode		Get the attribute from the node, if it's there.
//  EEgetEditorMessage		Return a message re WINEDITOR.
//	EEisValidNodeName		Is user-typed node name valid?
//	EEexprNameExists		Does user-typed expression node name exist?
//	EEcheckValidExprName	Is user-typed expression node name valid?
//	EEnodeIsInList			Is the node in the current node list?
//	EEattrIsInList			Is the attribute in the current attribute list?
//
//	EXPRESSION EDITOR UI EDIT AND LIST MANAGEMENT PROCEDURES:
//		These are in expressionEditor.mel
//
//	EEsetCreateMode			Set the editor to create mode.
//  EEsetEditMode			Set the editor to edit mode.
//	EEclearAllControls		Clear name textfields and menus.
//	EEresetFilterToAll		Set object filter to dag or dependency nodes.
//	EEresetExpressionName	Reset the expression name textfield
//	EEresetNodeControls		Reset controls for a new selected node.
//	EErebuildNodeList		Rebuild the node selection list.
//	EErebuildAttrList     	Rebuild the attribute list.
//	EEupdateExprList		Update the list of expressions.
//  EEaddNodeToList			Add a node to the node list.
//  EEremoveNodeFromList	Remove a node from the node list.
//  EEselectNodeInList		Select a node in the node list.
//	EEnewSelectedNode		Make the node selected and load its attrlist.
//	EEnewSelectedAttr		Load a new attribute into the editor.
//	EEloadNewNodeAttr		Load a new new node and its expression.
//	EEdisplayAttrExpr		Display the expression of the current attribute.
//	EEdisplayNoExpression	Reset controls when attr has no expression.
//
//	EEregisterExpressions	Register expressions to get expr changed msgs.
//
//
//	CORE PROCEDURES
//		These are in expressionEditor.mel
//
//	EEupdateWindow			Update the window at creation/show time.
//  expressionEditor()		Create or display the expression editor  (main)
//
//  PROCEDURES TO HANDLE ONLY REGULAR EXPRESSIONS
//		These are all in expressions.mel
//
//	EEexpressionCmd			Print the expression command just issued.
//	EEapplyExpression		Create or edit the expression
//	EErestoreExpression		Restore the current expression from the node.
//  EEobjectListChanged		User selected a non-particle obj in the node list.
//  EEexpressionListChanged	User selected a new expression in the node list.
//	EEdisplayExpression		Display an expression.
//
// PROCEDURES TO HANDLE ONLY PARTICLE EXPRESSION
//		These are all in dynExpressions.mel
//
//	EEdynExpressionCmd		Print the expression command just issued.
//	EEapplyParticleExpression	Create or edit the particle expression
//	EErestoreParticleExpression	Restore curr particle expression from node.
//  EEparticleListChanged	User selected a particle in the node list.
//	EEdisplayParticleExpression	Display a particle expression.
//	EEisParticle			Is the node a particle?
//	EEisDynExpression		Is the particle expression a dynExpression?
//	EEisValidDynAttr		Is the particle attribute a valid one to show?
//	EEgetParticleExpression Get the p. expression from the particle
//	EEonlyLaunchParticleEditor Launch a text editor for a particle expression.
//
//  EXPRESSION EDITOR UI CONTROL CALLBACKS:
//		These are all in expressionEdCallbacks.mel
//
//	EEapplyCB				Create/Edit the expression.
//	EEdeleteCB				Delete the expression.
//	EErestoreCB				Restore the expression.
//	EEclearCB				Clear the text area.
//  EEcloseCB				Close the window.
//	EEanimatedCB			Callback for animated checkbox.
//	EEunitConversionCB		Callback for unit conversion radio group.
//	EEexprNameTextCB		Callback for expression name textfield.
//	EEdefaultNodeCB			Callback for default node name textfield.
//	EEselectedNodeAttrCB	Callback for node-attribute name textfield.
//	EEnewExpressionCB		Callback for "New Expression" Button.
//	EEnodeListCB			User selected something (sngl click) in node list.
//	EEnodeListDblClickCB	User selected something (dbl click) in node list
//	EEattrListCB			User selected something (sngl click)in attr list.
//	EEattrListDblClickCB	User selected something (dbl click) in attr list.
//	EEselectFilterCB		User selected something in the Select menu.
//	EEobjFilterCB			User selected something in the Obj Filter menu.
//	EEattrFilterCB			User selected something in the Attr Filter menu.
//  	EEeditorCB				User selected something in editors opt menu.
//  	EEexecuteOnCB				User selected something in execute on opt menu.
//	EErulesCB				User selected a rules radio button.
//
//	EXPRESSION EDITOR MESSAGE CALLBACKS
//		These are in expressionEdCallbacks.mel
//		These are called from TexprEdListenAction.cc
//
//  EEactiveListChanged   	Callback for active list changed.
//  EEnodeAdded 			Callback for a node added to a scene.
//  EEnodeRemoved 			Callback for a node removed from the scene.
//	EEparticleExpressionCreated	Callback for particle expression created.
//	EEparticleExpressionDeleted	Callback for particle expression deleted.
//	EEexpressionCreated		Callback for expression created.
//	EEexpressionEdited		Callback for expression edited.
//	EEparticleExpressionEdited	Callback for particle expression edited.
//  EEnodeNameChanged 		Callback for a node name change in the scene.
//  EEattributeAdded      	Callback for attribute added to selected node.
//  EEattributeRemoved    	Callback for attribute removed from selected node.
//
//  EXPRESSION EDITOR TEXT EDITOR AND FAM HANDLING ROUTINES
//		These are in expressionEdTextEditor.mel
//
//	EEdoLaunch				Do the launch of the user's text editor of choice.
//	EElaunchEditor			Launch a text editor for a regular expression.
//	EElaunchParticleEditor	Launch a text editor for a particle expression
//	EEgetFileExpression		Callback from TexprEdFamAction.cc when the user
//							writes text editor file to disk.  Read file.
//  EEupdateParticleFileExpression  Update a particle expression from a text editor file.
//  EEupdateFileExpression  Update a regular expression from a text editor file.
//  EEdeleteStringElement	Delete an element from a string array.
//  EEdeleteIntElement		Delete an element from an int array.
//  EEdeleteEditorFile		Callback from TexprEdFamAction.cc when user
//                             dismisses a text editor.  Delete the file.
//

// ******************************************************************
//
//					EXPRESSION EDITOR GLOBAL VARIABLES
//
// ******************************************************************
// 
global int $EEcreateMode = 1;   // 1 = creating; 0 = editing

// Some of these globals are needed, because if in text editor mode,
// the controls cannot be queried, since the Expression Editor window
// won't be created when calling up the Expression Editor from the
// Attribute Editor or Channel Editor.
//
global int $EEobjIsParticle = 0;
global int $EEexpressionType = 1;
global int $EEcurrentEditor = 1;
global int $EEdoLaunchTextEd = 0;
global string $EEcurrExpressionName;
global string $EEorigExpressionName;
global int $EEeditedInEditor = 0;

global string $EEcurrSelectedNode;

// Currently active menu/filter modes.
//
global string $EEnodeMode = "object";
global string $EEcurrNodeFilter = "allSelected";
global string $EEcurrAttrFilter = "all";

// List of all files in text editors that are editing a particle expression.
//
global string $EEcurrParticleFiles[];

// Index into EEcurrFiles and EEcurrParticleFiles of the file whose
// expression is currently being displayed in the expression editor.
//
global int	  $EEpExpressionInEditor = -1;
global int	  $EEexpressionInEditor = -1;

global int    $EEfilesLoaded = 0;

global int    $EEfilesLoaded = 0;

global string $EEMathFunction[];
global string $EEVectorFunction[];
global string $EEConversionFunction[];
global string $EERandomFunction[];
global string $EEArrayFunction[];
global string $EECurveFunction[];


global proc
EEinitializeFunctionTables()
{
	int $EEFunctionTablesInitialized;

	if ($EEFunctionTablesInitialized) {
		return;
	}


	// begin Math Functions ----  Count 28
	// Each block contains:
	//	a string for the name of the function (this should NOT be localized)
	//	a string for the annotation
	//	(which should be localized if it contains named parameters)
	global string $EEMathFunction[];
	
	$EEMathFunction[0] = "abs()";
	$EEMathFunction[1] = "float abs(float) / int abs(int) / vector abs(vector)";

	$EEMathFunction[2] = "acos()";
	$EEMathFunction[3] = (uiRes("m_expressionEditor.kAcos"));

	$EEMathFunction[4] = "acosd()";
	$EEMathFunction[5] = (uiRes("m_expressionEditor.kAcosd"));

	$EEMathFunction[6] = "asin()";
	$EEMathFunction[7] = (uiRes("m_expressionEditor.kAsin"));

	$EEMathFunction[8] = "asind()";
	$EEMathFunction[9] = (uiRes("m_expressionEditor.kAsind"));

	$EEMathFunction[10] = "atan()";
	$EEMathFunction[11] = (uiRes("m_expressionEditor.kAtan"));

	$EEMathFunction[12] = "atand()";
	$EEMathFunction[13] = (uiRes("m_expressionEditor.kAtand"));

	$EEMathFunction[14] = "atan2()";
	$EEMathFunction[15] = (uiRes("m_expressionEditor.kAtan2"));

	$EEMathFunction[16] = "atan2d()";
	$EEMathFunction[17] = (uiRes("m_expressionEditor.kAtan2d"));

	$EEMathFunction[18] = "clamp()";
	$EEMathFunction[19] = (uiRes("m_expressionEditor.kClamp"));

	$EEMathFunction[20] = "ceil()";
	$EEMathFunction[21] = (uiRes("m_expressionEditor.kCeil"));

	$EEMathFunction[22] = "cos()";
	$EEMathFunction[23] = (uiRes("m_expressionEditor.kCos"));

	$EEMathFunction[24] = "cosd()";
	$EEMathFunction[25] = (uiRes("m_expressionEditor.kCosd"));

	$EEMathFunction[26] = "exp()";
	$EEMathFunction[27] = (uiRes("m_expressionEditor.kExp"));

	$EEMathFunction[28] = "floor()";
	$EEMathFunction[29] = (uiRes("m_expressionEditor.kFloor"));

	$EEMathFunction[30] = "hypot()";
	$EEMathFunction[31] = (uiRes("m_expressionEditor.kHypot"));

	$EEMathFunction[32] = "log()";
	$EEMathFunction[33] = (uiRes("m_expressionEditor.kLog"));

	$EEMathFunction[34] = "log10()";
	$EEMathFunction[35] = (uiRes("m_expressionEditor.kLog10"));

	$EEMathFunction[36] = "min()";
	$EEMathFunction[37] = (uiRes("m_expressionEditor.kMin"));

	$EEMathFunction[38] = "max()";
	$EEMathFunction[39] = (uiRes("m_expressionEditor.kMax"));

	$EEMathFunction[40] = "pow()";
	$EEMathFunction[41] = (uiRes("m_expressionEditor.kPow"));

	$EEMathFunction[42] = "sign()";
	$EEMathFunction[43] = (uiRes("m_expressionEditor.kSign"));

	$EEMathFunction[44] = "sin()";
	$EEMathFunction[45] = (uiRes("m_expressionEditor.kSin"));

	$EEMathFunction[46] = "sind()";
	$EEMathFunction[47] = (uiRes("m_expressionEditor.kSind"));

	$EEMathFunction[48] = "sqrt()";
	$EEMathFunction[49] = (uiRes("m_expressionEditor.kSqrt"));

	$EEMathFunction[50] = "tan()";
	$EEMathFunction[51] = (uiRes("m_expressionEditor.kTan"));

	$EEMathFunction[52] = "tand()";
	$EEMathFunction[53] = (uiRes("m_expressionEditor.kTand"));

	$EEMathFunction[54] = "trunc()";
	$EEMathFunction[55] = (uiRes("m_expressionEditor.kTrunc"));
	// end Math Functions ----

	// begin Vector Functions ----  Count 6
	// Each block contains:
	//	a string for the name of the function (this should NOT be localized)
	//	a string for the annotation (which should be localized)
	global string $EEVectorFunction[];

	$EEVectorFunction[0] = "angle()";
	$EEVectorFunction[1] = (uiRes("m_expressionEditor.kAngle"));

	$EEVectorFunction[2] = "cross()";
	$EEVectorFunction[3] = (uiRes("m_expressionEditor.kCross"));

	$EEVectorFunction[4] = "dot()";
	$EEVectorFunction[5] = (uiRes("m_expressionEditor.kDot"));

	$EEVectorFunction[6] = "mag()";
	$EEVectorFunction[7] = (uiRes("m_expressionEditor.kMag"));

	$EEVectorFunction[8] = "rot()";
	$EEVectorFunction[9] = (uiRes("m_expressionEditor.kRot"));

	$EEVectorFunction[10] = "unit()";
	$EEVectorFunction[11] = (uiRes("m_expressionEditor.kUnit"));
	// end Vector Functions ----

	// begin Conversion Functions ----  Count 4
	// Each block contains:
	//	a string for the name of the function (this should NOT be localized)
	//	a string for the annotation (which should be localized)
	global string $EEConversionFunction[];

	$EEConversionFunction[0] = "deg_to_rad()";
	$EEConversionFunction[1] = (uiRes("m_expressionEditor.kDeg2Rad"));

	$EEConversionFunction[2] = "rad_to_deg()";
	$EEConversionFunction[3] = (uiRes("m_expressionEditor.kRad2Deg"));

	$EEConversionFunction[4] = "hsv_to_rgb()";
	$EEConversionFunction[5] = (uiRes("m_expressionEditor.kHsv2Rgb"));

	$EEConversionFunction[6] = "rgb_to_hsv()";
	$EEConversionFunction[7] = (uiRes("m_expressionEditor.kRgb2Hsv"));
	// end Conversion Functions ----

	// begin Random Number Functions ----  Count 6
	// Each block contains:
	//	a string for the name of the function (this should NOT be localized)
	//	a string for the annotation
	//	(which should be localized only if it contains named parameters)
	global string $EERandomFunction[];

	$EERandomFunction[0] = "gauss()";
	$EERandomFunction[1] = "float gauss(float) / vector gauss(float, float) / vector gauss(vector)";
        
	$EERandomFunction[2] = "noise()";
	$EERandomFunction[3] = "float noise(float) / float noise(float, float) / float noise(vector)";

	$EERandomFunction[4] = "dnoise()";
	$EERandomFunction[5] = "vector dnoise(vector)";

	$EERandomFunction[6] = "rand()";
	$EERandomFunction[7] = "float rand(float [,float]) / vector rand(vector [,vector])";

	$EERandomFunction[8] = "sphrand()";
	$EERandomFunction[9] = "vector sphrand(float) / vector sphrand(vector)";

	$EERandomFunction[10] = "seed()";
	$EERandomFunction[11] = "int seed(int)";
	// end Random Number Functions ----
	
	// begin  Array Functions ----  Count 3
	// Each block contains:
	//	a string for the name of the function (this should NOT be localized)
	//	a string for the annotation (which should be localized)
	global string $EEArrayFunction[];

	$EEArrayFunction[0] = "clear()";
	$EEArrayFunction[1] = "int clear(array)";

	$EEArrayFunction[2] = "size()";
	$EEArrayFunction[3] = "int size(array) / int size(string)";

	$EEArrayFunction[4] = "sort()";
	$EEArrayFunction[5] = "array sort(array)";
	// end Array Functions ----

	// begin  Curve Functions ----  Count 4
	// Each block contains:
	//	a string for the menu item of the function
	//	(this should be localized where it contains words
	//	other than the function name)
	//	a string for name of the function to insert in the expression
	//	  (this must NOT be localized)
	//	a string for the annotation
	//	(which should be localized where it contains parameter names)
	// This block has distinct elements for the menu label
	// (the first string in each set)
	// and the literal string to insert in the expression (the second)
	// in order to distinguish between the 2 overloaded versions of hermite().
	global string $EECurveFunction[];

	$EECurveFunction[0] = "linstep()";
	$EECurveFunction[1] = "linstep()";
	$EECurveFunction[2] = (uiRes("m_expressionEditor.kLinstep"));

	$EECurveFunction[3] = "smoothstep()";
	$EECurveFunction[4] = "smoothstep()";
	$EECurveFunction[5] = (uiRes("m_expressionEditor.kSmoothstep"));

	$EECurveFunction[6] = (uiRes("m_expressionEditor.kHermiteVector"));
	$EECurveFunction[7] = "hermite()";
	$EECurveFunction[8] = (uiRes("m_expressionEditor.kHermiteVectorSignature"));

	$EECurveFunction[9] = (uiRes("m_expressionEditor.kHermiteScalar"));
	$EECurveFunction[10] = "hermite()";
	$EECurveFunction[11] = (uiRes("m_expressionEditor.kHermiteScalarSignature"));
	// end Curve Functions ----

	$EEFunctionTablesInitialized = 1;
}


// ******************************************************************
//
//				EXPRESSION EDITOR UI CREATION PROCEDURES
//
// ******************************************************************

//  ================ EEmakeMenubar ================
//
//  SYNOPSIS
//		Make the menus for the expression editor.
//
global proc EEmakeMenubar()
{
	global string $EEnodeMode;
	global string $EEcurrNodeFilter;
	global string $EEcurrAttrFilter;


	menu -label (uiRes("m_expressionEditor.kSelectFilter")) 
		-familyImage "menuIconSelectFilter.png";
		radioMenuItemCollection;
		menuItem -label (uiRes("m_expressionEditor.kByExprName"))  
			-radioButton ($EEnodeMode == "expression")
			-command ("EEselectFilterCB expression")
			EEexprModeMenuItem;
		menuItem -label (uiRes("m_expressionEditor.kByObjAttrName"))  
			-radioButton ($EEnodeMode == "object")
			-command ("EEselectFilterCB object") 
			EEobjModeMenuItem;
		menuItem -label (uiRes("m_expressionEditor.kByScriptNodeName")) 
			-radioButton ($EEnodeMode == "scriptNode")
			-command ("EEselectFilterCB scriptNode")
			EEscriptNodeModeMenuItem;
		setParent -menu ..;
		
	menu -label (uiRes("m_expressionEditor.kObjFilter"))  
		-familyImage "menuIconObjectFilter.png"
		EEobjFilterMenu;
		radioMenuItemCollection;
			menuItem -label (uiRes("m_expressionEditor.kSelectedObjs"))  
				-radioButton ($EEcurrNodeFilter == "allSelected")  
				-command ("EEobjFilterCB allSelected")
				EEallSelectedMenuItem;
			menuItem -label (uiRes("m_expressionEditor.kDagObjs"))  
				-radioButton ($EEcurrNodeFilter == "dagObjects")  
				-command ("EEobjFilterCB dagObjects")
				EEdagObjMenuItem;
			menuItem -label (uiRes("m_expressionEditor.kGeomObjs"))  
				-radioButton ($EEcurrNodeFilter == "geometry") 
				-command ("EEobjFilterCB geometry");
			menuItem -label (uiRes("m_expressionEditor.kTransforms"))  
				-radioButton ($EEcurrNodeFilter == "transforms")  
				-command ("EEobjFilterCB transforms");
			menuItem -label (uiRes("m_expressionEditor.kDGNodes"))  
				-radioButton ($EEcurrNodeFilter == "depNodes") 
				-command ("EEobjFilterCB depNodes")
				EEdepNodeMenuItem;
			menuItem -label (uiRes("m_expressionEditor.kLights"))  
				-radioButton ($EEcurrNodeFilter == "lights") 
				-command ("EEobjFilterCB lights");
			menuItem -label (uiRes("m_expressionEditor.kCameras"))  
				-radioButton ($EEcurrNodeFilter == "cameras") 
				-command ("EEobjFilterCB cameras");
			menuItem -label (uiRes("m_expressionEditor.kShaders"))  
				-radioButton ($EEcurrNodeFilter == "shaders") 
				-command ("EEobjFilterCB shaders");

		if (`isTrue "DynamicsUIExists"`)
		{
			menuItem -label (uiRes("m_expressionEditor.kDynamics"))  -subMenu true;
				menuItem -label (uiRes("m_expressionEditor.kParticles"))  
					-radioButton ($EEcurrNodeFilter == "particles") 
					-command ("EEobjFilterCB particles");
				menuItem -label (uiRes("m_expressionEditor.kEmitters"))  
					-radioButton ($EEcurrNodeFilter == "emitters") 
					-command ("EEobjFilterCB emitters");
				menuItem -label (uiRes("m_expressionEditor.kSprings"))  
					-radioButton ($EEcurrNodeFilter == "springs") 
					-command ("EEobjFilterCB springs");
				menuItem -label (uiRes("m_expressionEditor.kGravityFields"))  
					-radioButton ($EEcurrNodeFilter == "gravity") 
					-command ("EEobjFilterCB gravity");
				menuItem -label (uiRes("m_expressionEditor.kDragFields"))  
					-radioButton ($EEcurrNodeFilter == "drag") 
					-command ("EEobjFilterCB drag");
				menuItem -label (uiRes("m_expressionEditor.kAirFields"))  
					-radioButton ($EEcurrNodeFilter == "air") 
					-command ("EEobjFilterCB air");
				menuItem -label (uiRes("m_expressionEditor.kNewtonFields"))  
					-radioButton ($EEcurrNodeFilter == "newton") 
					-command ("EEobjFilterCB newton");
				menuItem -label (uiRes("m_expressionEditor.kRadialFields"))  
					-radioButton ($EEcurrNodeFilter == "radial") 
					-command ("EEobjFilterCB radial");
				menuItem -label (uiRes("m_expressionEditor.kTurbulenceFields"))  
					-radioButton ($EEcurrNodeFilter == "turbulence") 
					-command ("EEobjFilterCB turbulence");
				menuItem -label (uiRes("m_expressionEditor.kUniformFields"))  
					-radioButton ($EEcurrNodeFilter == "uniform") 
					-command ("EEobjFilterCB uniform");
				menuItem -label (uiRes("m_expressionEditor.kVortexFields"))  
					-radioButton ($EEcurrNodeFilter == "vortex") 
					-command ("EEobjFilterCB vortex");
				menuItem -label (uiRes("m_expressionEditor.kRigidBodies"))  
					-radioButton ($EEcurrNodeFilter == "rigidBody") 
					-command ("EEobjFilterCB rigidBody");
				menuItem -label (uiRes("m_expressionEditor.kRigidConstraints"))  
					-radioButton ($EEcurrNodeFilter == "rigidConstraint") 
					-command ("EEobjFilterCB constraint");
			setParent -menu ..;
		}

		if (`isTrue "KinematicsExists"`)
		{
			menuItem -label (uiRes("m_expressionEditor.kKinematics"))  -subMenu true;
				menuItem -label (uiRes("m_expressionEditor.kJoints"))  
					-radioButton ($EEcurrNodeFilter == "joint") 
					-command ("EEobjFilterCB joints");
				menuItem -label (uiRes("m_expressionEditor.kHandles"))  
					-radioButton ($EEcurrNodeFilter == "handle") 
					-command ("EEobjFilterCB handles");
				menuItem -label (uiRes("m_expressionEditor.kIKSystems"))  
					-radioButton ($EEcurrNodeFilter == "ikSystem") 
					-command ("EEobjFilterCB ikSystems");
				menuItem -label (uiRes("m_expressionEditor.kIKSolvers"))  
					-radioButton ($EEcurrNodeFilter == "ikSolver") 
					-command ("EEobjFilterCB ikSolvers");
			setParent -menu ..;
		}


		if (`isTrue "DeformersExists"`)
		{
			menuItem -label (uiRes("m_expressionEditor.kDeformers"))  -subMenu true;
				menuItem -label (uiRes("m_expressionEditor.kJointLattice"))  
					-radioButton ($EEcurrNodeFilter == "jointLattice") 
					-command ("EEobjFilterCB jointLattice");
				menuItem -label (uiRes("m_expressionEditor.kBlendShape"))  
					-radioButton ($EEcurrNodeFilter == "blendShape") 
					-command ("EEobjFilterCB blendShape");
				menuItem -label (uiRes("m_expressionEditor.kBoneLattice"))  
					-radioButton ($EEcurrNodeFilter == "boneLattice") 
					-command ("EEobjFilterCB boneLattice");
				menuItem -label (uiRes("m_expressionEditor.kCluster"))  
					-radioButton ($EEcurrNodeFilter == "cluster") 
					-command ("EEobjFilterCB cluster");
				menuItem -label (uiRes("m_expressionEditor.kLattice"))  
					-radioButton ($EEcurrNodeFilter == "lattice") 
					-command ("EEobjFilterCB lattice");
				menuItem -label (uiRes("m_expressionEditor.kSculpt"))  
					-radioButton ($EEcurrNodeFilter == "sculpt") 
					-command ("EEobjFilterCB sculpt");
				menuItem -label (uiRes("m_expressionEditor.kWire"))  
					-radioButton ($EEcurrNodeFilter == "wire") 
					-command ("EEobjFilterCB wire");
			setParent -menu ..;
		}

		setParent -menu ..;
		
	menu -label (uiRes("m_expressionEditor.kAttributeFilter"))  
		-familyImage "menuIconAttributeFilter.png"
		EEattrFilterMenu;
		radioMenuItemCollection;
		menuItem -label (uiRes("m_expressionEditor.kAll"))  
			-radioButton ($EEcurrAttrFilter == "all") 
			-command ("EEattrFilterCB all")
			EEallAttrsMenuItem;
		menuItem -label (uiRes("m_expressionEditor.kConnToExprs"))  
			-radioButton ($EEcurrAttrFilter == "expr") 
			-command ("EEattrFilterCB expr")
			EEselAttrsMenuItem;
	setParent -menu ..;

global string $EEMathFunction[];
global string $EEVectorFunction[];
global string $EERandomFunction[];
global string $EEConversionFunction[];
global string $EEArrayFunction[];
global string $EECurveFunction[];

	//
	// Make sure all the function tables are filled in before we use them.
	//
	EEinitializeFunctionTables();

	int $i = 0, $limit;

	menu -label (uiRes("m_expressionEditor.kInsertFuncs"))  EEInsertFuncMenu;
		// Math Functions
		//
		menuItem -label (uiRes("m_expressionEditor.kMathFuncs"))
			-subMenu true EEmathMI;
		$limit = size($EEMathFunction);
		for ($i = 0; $i < $limit; $i+=2) {	
			// Note that these menu items & annotations are
			// appropriately localized when the tables are built
			menuItem -label $EEMathFunction[$i]
				-command ("EEmathFuncCB " + $i)
				-annotation $EEMathFunction[$i+1];
		}
		setParent -menu ..;

		// Random Functions
		//
		menuItem -label (uiRes("m_expressionEditor.kRandomFuncs"))
			-subMenu true EErandMI;
		$limit = size($EERandomFunction);
		for ($i = 0; $i < $limit; $i+=2) {	
			// Note that these menu items & annotations are
			// appropriately localized when the tables are built
			menuItem -label $EERandomFunction[$i]
				-command ("EErandFuncCB " + $i)
				-annotation $EERandomFunction[$i+1];
		}
		setParent -menu ..;

		// Vector Functions
		//
		menuItem -label (uiRes("m_expressionEditor.kVectorFuncs"))
			-subMenu true EEvectMI;
		$limit = size($EEVectorFunction);
		for ($i = 0; $i < $limit; $i+=2) {	
			// Note that these menu items & annotations are
			// appropriately localized when the tables are built
			menuItem -label $EEVectorFunction[$i]
				-command ("EEvectFuncCB " + $i)
				-annotation $EEVectorFunction[$i+1];
		}
		setParent -menu ..;

		// Conversion Functions
		//
		menuItem
			-label (uiRes("m_expressionEditor.kConversionFuncs"))
			-subMenu true EEconvMI;
		$limit = size($EEConversionFunction);
		for ($i = 0; $i < $limit; $i+=2) {	
			// Note that these menu items & annotations are
			// appropriately localized when the tables are built
			menuItem -label $EEConversionFunction[$i]
				-command ("EEconvFuncCB " + $i)
				-annotation $EEConversionFunction[$i+1];
		}
		setParent -menu ..;

		// Array Functions
		//
		menuItem -label (uiRes("m_expressionEditor.kArrayFuncs"))
			-subMenu true EEarrayMI;
		$limit = size($EEArrayFunction);
		for ($i = 0; $i < $limit; $i+=2) {	
			// Note that these menu items & annotations are
			// appropriately localized when the tables are built
			menuItem -label $EEArrayFunction[$i]
				-command ("EEarrayFuncCB " + $i)
				-annotation $EEArrayFunction[$i+1];
		}
		setParent -menu ..;

		// Curve Functions
		// This block has distinct elements for the menu label
		// (the first string in each set)
		// and the literal string to insert in the expression (the second)
		// in order to distinguish between the 2 overloaded
		// versions of hermite().
        //
        menuItem -label (uiRes("m_expressionEditor.kCurveFuncs"))
				-subMenu true EEcurveMI;
        $limit = size($EECurveFunction);
		for ($i = 0; $i < $limit; $i+=3) {	
			// Note that these menu items & annotations are
			// appropriately localized when the tables are built
			menuItem -label $EECurveFunction[$i]
				-command ("EEcurveFuncCB " + $i)
				-annotation $EECurveFunction[$i+2];
        }
        setParent -menu ..;

	setParent -menu ..;

	menu -label (uiRes("m_expressionEditor.kHelp"))
		-helpMenu true EEhelpMenuItem;
		menuItem -label (uiRes("m_expressionEditor.kHelpExprEd")) 
			-enableCommandRepeat false
			-command "showHelp ExpressionEditor";

	setParent -menu ..;
		
}	// EEmakeMenubar


//  ================ EEmakeFilterPopup ================
//
//  SYNOPSIS
//		Make the popup menu for the object filter.
//
global proc	EEmakeFilterPopup()
{
	popupMenu EEnodePOP;

	menuItem -label (uiRes("m_expressionEditor.kSelectFilter"))
		-subMenu true EEselectFilterPopMenu;
		menuItem -label (uiRes("m_expressionEditor.kByExprName"))
			-command ("EEselectFilterCB expression");
		menuItem -label (uiRes("m_expressionEditor.kByObjAttrName"))
			-command ("EEselectFilterCB object") ;
		menuItem -label (uiRes("m_expressionEditor.kByScriptNodeName"))
			-command ("EEselectFilterCB scriptNode");
	setParent -menu ..;

	menuItem -label (uiRes("m_expressionEditor.kObjFilter"))
		-subMenu true EEobjFilterPopMenu;
			menuItem -label (uiRes("m_expressionEditor.kSelectedObjs"))
				-command ("EEobjFilterCB allSelected");
			menuItem -label (uiRes("m_expressionEditor.kDagObjs"))
				-command ("EEobjFilterCB dagObjects");
			menuItem -label (uiRes("m_expressionEditor.kGeomObjs"))
				-command ("EEobjFilterCB geometry");
			menuItem -label (uiRes("m_expressionEditor.kTransforms"))
				-command ("EEobjFilterCB transforms");
			menuItem -label (uiRes("m_expressionEditor.kDGNodes"))
				-command ("EEobjFilterCB depNodes");
			menuItem -label (uiRes("m_expressionEditor.kLights"))
				-command ("EEobjFilterCB lights");
			menuItem -label (uiRes("m_expressionEditor.kCameras"))
				-command ("EEobjFilterCB cameras");
			menuItem -label (uiRes("m_expressionEditor.kShaders"))
				-command ("EEobjFilterCB shaders");

		if (`isTrue "DynamicsUIExists"`)
		{
			menuItem -label (uiRes("m_expressionEditor.kDynamics")) -subMenu true;
				menuItem -label (uiRes("m_expressionEditor.kParticles"))
					-command ("EEobjFilterCB particles");
				menuItem -label (uiRes("m_expressionEditor.kEmitters"))
					-command ("EEobjFilterCB emitters");
				menuItem -label (uiRes("m_expressionEditor.kSprings"))
					-command ("EEobjFilterCB springs");
				menuItem -label (uiRes("m_expressionEditor.kGravityFields"))
					-command ("EEobjFilterCB gravity");
				menuItem -label (uiRes("m_expressionEditor.kDragFields"))
					-command ("EEobjFilterCB drag");
				menuItem -label (uiRes("m_expressionEditor.kAirFields"))
					-command ("EEobjFilterCB air");
				menuItem -label (uiRes("m_expressionEditor.kNewtonFields"))
					-command ("EEobjFilterCB newton");
				menuItem -label (uiRes("m_expressionEditor.kRadialFields"))
					-command ("EEobjFilterCB radial");
				menuItem -label (uiRes("m_expressionEditor.kTurbulenceFields"))
					-command ("EEobjFilterCB turbulence");
				menuItem -label (uiRes("m_expressionEditor.kUniformFields"))
					-command ("EEobjFilterCB uniform");
				menuItem -label (uiRes("m_expressionEditor.kVortexFields"))
					-command ("EEobjFilterCB vortex");
				menuItem -label (uiRes("m_expressionEditor.kRigidBodies"))
					-command ("EEobjFilterCB rigidBody");
				menuItem -label (uiRes("m_expressionEditor.kRigidConstraints"))
					-command ("EEobjFilterCB constraint");
			setParent -menu ..;
		}


		if (`isTrue "KinematicsExists"`)
		{
			menuItem -label (uiRes("m_expressionEditor.kKinematics")) -subMenu true;
				menuItem -label (uiRes("m_expressionEditor.kJoints"))
					-command ("EEobjFilterCB joints");
				menuItem -label (uiRes("m_expressionEditor.kHandles"))
					-command ("EEobjFilterCB handles");
				menuItem -label (uiRes("m_expressionEditor.kIKSystems"))
					-command ("EEobjFilterCB ikSystems");
				menuItem -label (uiRes("m_expressionEditor.kIKSolvers"))
					-command ("EEobjFilterCB ikSolvers");
			setParent -menu ..;
		}

		if (`isTrue "DeformersExists"`)
		{
			menuItem -label (uiRes("m_expressionEditor.kDeformers")) -subMenu true;
				menuItem -label (uiRes("m_expressionEditor.kJointLattice"))
					-command ("EEobjFilterCB jointLattice");
				menuItem -label (uiRes("m_expressionEditor.kBlendShape"))
					-command ("EEobjFilterCB blendShape");
				menuItem -label (uiRes("m_expressionEditor.kBoneLattice"))
					-command ("EEobjFilterCB boneLattice");
				menuItem -label (uiRes("m_expressionEditor.kCluster"))
					-command ("EEobjFilterCB cluster");
				menuItem -label (uiRes("m_expressionEditor.kLattice"))
					-command ("EEobjFilterCB lattice");
				menuItem -label (uiRes("m_expressionEditor.kSculpt"))
					-command ("EEobjFilterCB sculpt");
				menuItem -label (uiRes("m_expressionEditor.kWire"))
					-command ("EEobjFilterCB wire");
			setParent -menu ..;
		}

		setParent -menu ..;

	menuItem -label (uiRes("m_expressionEditor.kAttributeFilter"))
		-subMenu true EEattrFilterPopMenu;
		menuItem -label (uiRes("m_expressionEditor.kAll"))
			-command ("EEattrFilterCB all");
		menuItem -label (uiRes("m_expressionEditor.kConnToExprs"))
			-command ("EEattrFilterCB expr");
	setParent -menu ..;

global string $EEMathFunction[];
global string $EEVectorFunction[];
global string $EERandomFunction[];
global string $EEConversionFunction[];
global string $EEArrayFunction[];
global string $EECurveFunction[];

	//
	// Make sure all the function tables are filled in before we use them.
	//
	EEinitializeFunctionTables();

	int $i = 0, $limit;

	menuItem -label (uiRes("m_expressionEditor.kInsertFuncs")) 
		-subMenu true EEInsertFuncPopMenu;
		// Math Functions
		//
		menuItem -label (uiRes("m_expressionEditor.kMathFuncs")) -subMenu true;
		$limit = size($EEMathFunction);
		for ($i = 0; $i < $limit; $i+=2) {	
			// Note that these menu items & annotations are
			// appropriately localized when the tables are built
			menuItem -label $EEMathFunction[$i]
				-command ("EEmathFuncCB " + $i)
				-annotation $EEMathFunction[$i+1];
		}
		setParent -menu ..;

		// Random Functions
		//
		menuItem -label (uiRes("m_expressionEditor.kRandomFuncs")) -subMenu true;
		$limit = size($EERandomFunction);
		for ($i = 0; $i < $limit; $i+=2) {	
			// Note that these menu items & annotations are
			// appropriately localized when the tables are built
			menuItem -label $EERandomFunction[$i]
				-command ("EErandFuncCB " + $i)
				-annotation $EERandomFunction[$i+1];
		}
		setParent -menu ..;

		// Vector Functions
		//
		menuItem -label (uiRes("m_expressionEditor.kVectorFuncs")) -subMenu true;
		$limit = size($EEVectorFunction);
		for ($i = 0; $i < $limit; $i+=2) {	
			// Note that these menu items & annotations are
			// appropriately localized when the tables are built
			menuItem -label $EEVectorFunction[$i]
				-command ("EEvectFuncCB " + $i)
				-annotation $EEVectorFunction[$i+1];
		}
		setParent -menu ..;

		// Conversion Functions
		//
		menuItem -label (uiRes("m_expressionEditor.kConversionFuncs"))
			-subMenu true;
		$limit = size($EEConversionFunction);
		for ($i = 0; $i < $limit; $i+=2) {	
			// Note that these menu items & annotations are
			// appropriately localized when the tables are built
			menuItem -label $EEConversionFunction[$i]
				-command ("EEconvFuncCB " + $i)
				-annotation $EEConversionFunction[$i+1];
		}
		setParent -menu ..;

		// Array Functions
		//
		menuItem -label (uiRes("m_expressionEditor.kArrayFuncs")) -subMenu true;
		$limit = size($EEArrayFunction);
		for ($i = 0; $i < $limit; $i+=2) {	
			// Note that these menu items & annotations are
			// appropriately localized when the tables are built
			menuItem -label $EEArrayFunction[$i]
				-command ("EEarrayFuncCB " + $i)
				-annotation $EEArrayFunction[$i+1];
		}
		setParent -menu ..;

		// Curve Functions
		// This block has distinct elements for the menu label
		// (the first string in each set)
		// and the literal string to insert in the expression (the second)
		// in order to distinguish between the 2 overloaded
		// versions of hermite().
        //
        menuItem -label (uiRes("m_expressionEditor.kCurveFuncs")) -subMenu true;
        $limit = size($EECurveFunction);
        for ($i = 0; $i < $limit; $i+=3) {
			// Note that these menu items & annotations are
			// appropriately localized when the tables are built
            menuItem -label $EECurveFunction[$i]
				-command ("EEcurveFuncCB " + $i)
				-annotation $EECurveFunction[$i+2];
        }
        setParent -menu ..;

	setParent -menu ..;

}	// EEmakeFilterPopup


//
//  ================ EEcreateWin ================
//
//  SYNOPSIS
//      Create the expression editor window and its layout,
//		and register the callbacks.
//
global proc EEcreateWin(string $winName)
{
	global int $EEcurrentEditor;
	global int $EEexpressionType;

    // Create a new dialog and base container (mainForm).
    //
    int $wndHeight = 540;
    // adjust the window height 
    // so that all the controls get displayed correctly
    if(`about -mac`)
    	$wndHeight = 600;
    	
    window  
		-title (uiRes("m_expressionEditor.kExpressionEditor"))  
		-iconName (uiRes("m_expressionEditor.kExpressions"))  
		-menuBar true 
		-width 620 -height $wndHeight
		-resizeToFitChildren false
		$winName;

	EEmakeMenubar();

	frameLayout -borderVisible false -collapsable false -labelVisible false 
		-marginWidth 10 
		-marginHeight 10
		EEmainFrame;
	formLayout -numberOfDivisions 100 EEmainForm;

    // Create the popup menu for the filters
    //
	EEmakeFilterPopup();

	// Create the Selection layout
	//
	formLayout -numberOfDivisions 100 EEselectionForm;

	// Attach the selection form to the main form 
	//
	formLayout -edit 
		-attachForm EEselectionForm right 0
		-attachForm EEselectionForm left  0
		-attachForm EEselectionForm top   0
		EEmainForm;

	columnLayout -adjustableColumn true EEselectionCL;
	formLayout -edit 
		-attachForm EEselectionCL left 0
		-attachForm EEselectionCL right 0
		EEselectionForm;

	text -align "center" -label (uiRes("m_expressionEditor.kCreatingExpr"))
		EEceModeT;

    // Create the expression name form and textfield.  Use text and 
	// textField instead of textFieldGrp, in order to line the label
	// and textfield up on the left side.
    //
	formLayout -numberOfDivisions 100 EEexprNameForm;

	text -width 180 -align "left" -label (uiRes("m_expressionEditor.kExpressionName"))  EEexprNameLabel;
	textField 
		-changeCommand "EEexprNameTextCB"
		-width 200 
		EEexprNameT;
	formLayout -edit
		-attachForm EEexprNameLabel "left" 0 
		-attachForm EEexprNameLabel "top" 8
		-attachControl EEexprNameT "left" 4 EEexprNameLabel
		-attachOppositeControl EEexprNameT "top" 0 EEexprNameLabel
		EEexprNameForm;

	// Create the "New Expression" button.
	//
	button -label (uiRes("m_expressionEditor.kNewExpr"))  
	 	-command ("EEnewExpressionCB 1")
	 	-width 125 -height 28 
		-enable false
	 	EEnewExpButton;
    formLayout -edit 
	 	-attachControl EEnewExpButton left 4 EEexprNameT
	 	-attachOppositeControl EEnewExpButton top 0 EEexprNameT
		-attachForm EEnewExpButton bottom 2
		EEexprNameForm;

	// Back up to EESelectionCL
	//
	setParent ..;

	// Make the selection frame -- the Node and Attributes Lists.
	//
    frameLayout -label (uiRes("m_expressionEditor.kSelection")) 
		-labelVisible true
		-collapsable true
		-collapse false -marginHeight 4
        EEselectionF;

	// Create the selection scrolled lists
	//
	formLayout -numberOfDivisions 100 EEselectFiltForm;

	formLayout -numberOfDivisions 100 EEnodeForm;

	formLayout -edit
		-attachForm EEnodeForm 		left 	0
		-attachForm EEnodeForm 		top 	0
		-attachPosition EEnodeForm		right	-2 50
		EEselectFiltForm;

	text -align "left" -label (uiRes("m_expressionEditor.kObjects"))  EEselectNamesL;
	formLayout -edit
		-attachForm EEselectNamesL left 5
		-attachForm EEselectNamesL top 	2
		EEnodeForm;

	textScrollList -allowMultiSelection false -numberOfRows 6 
		-doubleClickCommand "EEnodeListDblClickCB"
		-selectCommand "EEnodeListCB"
		EEnodeList;
	//	set the scroll list height, 
	//	so that the scroll bars appear properly
	if (`about -mac`) {
		int $EEnodeListHeight = 110;
		textScrollList -edit 
			-height $EEnodeListHeight
			EEnodeList;
	}

	formLayout -edit
		-attachForm EEnodeList left 	5
		-attachForm EEnodeList right 	0
		-attachForm EEnodeList bottom 	0
		-attachControl EEnodeList top 		2 EEselectNamesL
		EEnodeForm;

	// Back up to EEselectFiltForm
	//
	setParent ..;

	// Make the attribute list
	//
	formLayout -numberOfDivisions 100 EEattrListForm;

	formLayout -edit
		-attachForm EEattrListForm 	top 	0
		-attachForm EEattrListForm 	right 	0
		-attachPosition EEnodeForm 		left 	0 	0 
		-attachPosition EEnodeForm 		right 	0 	50
		-attachPosition EEattrListForm 	left 	2 	50 
		-attachPosition EEattrListForm 	right 	0 	100
		EEselectFiltForm;

	text -align "left" -label (uiRes("m_expressionEditor.kAttributes"))  EEattrNamesL;
	formLayout -edit
		-attachForm EEattrNamesL left 	0
		-attachForm EEattrNamesL top 	2
		EEattrListForm;

	textScrollList -allowMultiSelection false -numberOfRows 6 
		-selectCommand "EEattrListCB"
		-doubleClickCommand "EEattrListDblClickCB"
		EEattrList;

	//	set the scroll list height, 
	//	so that the scroll bars appear properly
	if (`about -mac`) {
		int $EEattrListHeight = 110;
		textScrollList -edit 
			-height $EEattrListHeight
			EEattrList;
	}
	
	formLayout -edit
		-attachForm EEattrList left 	0  
		-attachForm EEattrList right 	5
	    -attachForm EEattrList bottom 	0
		-attachControl EEattrList top 		2 EEattrNamesL
		EEattrListForm;

	setParent EEselectionCL;

	//	Create two tabs, one for expressions and the other for 
	//	script nodes.
	tabLayout -tabsVisible false -innerMarginWidth 0 -innerMarginHeight 0
		EEoptionsTab;
	columnLayout -adjustableColumn true -rowSpacing 5 EEexprOptsCL;

	// Create the textfields for the selected and default nodes.
	//
	textFieldGrp -label (uiRes("m_expressionEditor.kSelectedObjAndAttr"))  
		-changeCommand "EEselectedNodeAttrCB"
		-columnWidth 1 180
		EEselNameT;

	textFieldGrp -label (uiRes("m_expressionEditor.kDefaultObj"))  
		-changeCommand "EEdefaultNodeCB"
		-columnWidth 1 180
		EEdefNameT;

	radioButtonGrp
		-numberOfRadioButtons 3
		-label (uiRes("m_expressionEditor.kConvertUnits")) 
			-label1 (uiRes("m_expressionEditor.kConvertAll")) 
			-label2 (uiRes("m_expressionEditor.kConvertNone")) 
			-label3 (uiRes("m_expressionEditor.kConvertAngular")) 
			-columnWidth 1 180 
			-columnWidth 2 160 
			-columnWidth 3 150 
			-select 1
			-onCommand1 ("EEunitConversionCB all")
			-onCommand2 ("EEunitConversionCB none")
			-onCommand3 ("EEunitConversionCB angularOnly")
		EEunitsRBG;

	radioButtonGrp
		-numberOfRadioButtons 3
		-label (uiRes("m_expressionEditor.kParticle")) 
			-label1 (uiRes("m_expressionEditor.kRuntimeBeforeDynamics")) 
			-label2 (uiRes("m_expressionEditor.kRuntimeAfterDynamics")) 
			-label3 (uiRes("m_expressionEditor.kCreation")) 
			-columnWidth 1 180
			-columnWidth 2 160 
			-columnWidth 3 150 
			-onCommand1 ("EErulesCB runtimeBeforeDynamics")
			-onCommand2 ("EErulesCB runtimeAfterDynamics")
			-onCommand3 ("EErulesCB creation")
		EErulesRBG;

	// runtime before dynamics if $EEexpressionType = 1
	// runtime after  dynamics if $EEexpressionType = 2
	// creation                if $EEexpressionType = 3
	radioButtonGrp -edit -select $EEexpressionType EErulesRBG;


	rowLayout -numberOfColumns 2
		-columnWidth 1 180
		-columnAlign 1 "right"
		-columnWidth 2 290
		-columnAlign 2 "left"
		-columnAttach 1 "both" 10
		-columnAttach 2 "left" 0
		EEeditorRow2;

	text -label (uiRes("m_expressionEditor.kEvaluation"))  -align "right";

	optionMenu -label ""
        -changeCommand EEanimatedCB
        EEanimTypeOM;

        menuItem -label (uiRes("m_expressionEditor.kOnDemand"))  EEbasicItem;
		menuItem -label (uiRes("m_expressionEditor.kAlways"))  EEanimItem;
		menuItem -label (uiRes("m_expressionEditor.kAfterCloth"))  EEanimNCBItem;

	setParent EEoptionsTab;

	//	Create the UI for script nodes.
	//
	columnLayout -adjustableColumn false -rowSpacing 5 EEscriptOptsCL;

	textFieldGrp -label (uiRes("m_expressionEditor.kSelectedNode"))  
		-changeCommand "EEselectedScriptCB"
		-columnWidth 1 180
		EEselScriptNodeNameT;

	rowLayout -numberOfColumns 2
		-columnWidth 1 180
		-columnAlign 1 "right"
		-columnWidth 2 290
		-columnAlign 2 "left"
		-columnAttach 1 "both" 10
		-columnAttach 2 "left" 0
		EEscriptNodeTypeRowL;

	text -label (uiRes("m_expressionEditor.kExecuteOn"))  -align "right";

	attrEnumOptionMenu -label ""
		-enumeratedItem 0 (uiRes("m_expressionEditor.kDemand"))
		-enumeratedItem 1 (uiRes("m_expressionEditor.kOpenClose"))
		-enumeratedItem 2 (uiRes("m_expressionEditor.kGUIOPenClose"))
		-enumeratedItem 3 (uiRes("m_expressionEditor.kUIConfig"))
		-enumeratedItem 4 (uiRes("m_expressionEditor.kSoftwareRender"))
		-enumeratedItem 5 (uiRes("m_expressionEditor.kSoftwareFrameRender"))
		-enumeratedItem 6 (uiRes("m_expressionEditor.kSceneConfig"))
		-enumeratedItem 7 (uiRes("m_expressionEditor.kTimeChanged"))
		-changeCommand "EEexecuteOnCB \"#1\""
		EEscriptNodeTypeAOM;
	setParent ..;

	radioButtonGrp
		-numberOfRadioButtons 2
		-label (uiRes("m_expressionEditor.kScript")) 
			-label1 (uiRes("m_expressionEditor.kBefore")) 
			-label2 (uiRes("m_expressionEditor.kAfter")) 
			-columnWidth 1 180 
			-columnWidth 2 100 
			-columnWidth 3 110 
			-onCommand1 ("EEbeforeAfterScriptCB")
			-onCommand2 ("EEbeforeAfterScriptCB")
			-select 1
			EEscriptRBG;
			
	radioButtonGrp
		-numberOfRadioButtons 2
		-label (uiRes("m_expressionEditor.kReferenceEdits")) 
			-label1 (uiRes("m_expressionEditor.kRecord")) 
			-label2 (uiRes("m_expressionEditor.kIgnore")) 
			-columnWidth 1 180 
			-columnWidth 2 100 
			-columnWidth 3 110 
			-onCommand1 ("EEreferenceEdtisCB 0")
			-onCommand2 ("EEreferenceEdtisCB 1")
			-select 1
			-enable false
			EEscriptNodeRefEditsRBG;

	rowLayout -numberOfColumns 2
		-columnWidth 1 180
		-columnAlign 1 "right"
		-columnWidth 2 290
		-columnAlign 2 "left"
		-columnAttach 1 "both" 10
		-columnAttach 2 "left" 0
		EEeditorRowL;

	text -label "";
	button 	-label (uiRes("m_expressionEditor.kTestScript"))
			-width 100 -command "EEscriptNodeTestCB" EEscriptNodeTestButton;
	setParent ..;

	tabLayout -edit -selectTabIndex 1 EEoptionsTab;
	setParent EEmainForm;

	// Create the form for the multi-line scrolled text widget.
	//
	formLayout -numberOfDivisions 100 EEtextForm;

	// Attach the text form to the main form on right and left.
	//
	formLayout -edit 
		-attachForm EEtextForm right 0
		-attachForm EEtextForm left 0
		-attachForm EEtextForm bottom 0
		EEmainForm;

	// Attach the top of the text form to the bottom of the
	// selection form.
	//
	formLayout -edit
		-attachControl EEtextForm top 0 EEselectionForm 
		EEmainForm;

	rowLayout -numberOfColumns 2
		-columnWidth 1 180
		-columnAlign 1 "right"
		-columnWidth 2 290
		-columnAlign 2 "left"
		-columnAttach 1 "both" 10
		-columnAttach 2 "left" 0
		EEeditorRowL;

	text -label (uiRes("m_expressionEditor.kEditor"))  -align "right";

	// The evaluation version of Maya cannot launch external programs
	// so it cannot edit expressions with an external editor.
	//
	int $allowExtEdit = ! `about -evalVersion`;

	optionMenu -label "" 
		-changeCommand EEeditorCB
		EEeditorOM;

		menuItem -label (uiRes("m_expressionEditor.kUseExpressionEditor"))  EEexprEdItem;
		if (`about -mac`) {
			menuItem -enable $allowExtEdit
				-label (uiRes("m_expressionEditor.kTextEdit"))  EETextEditItem;
		} else if (`about -nt`) {
			menuItem -enable $allowExtEdit -label (uiRes("m_expressionEditor.kTextEditor"))  EEotherItem;
			// change the default width so that it works with
			// either large or small fonts.
			float $factor = 1.3;
			if("ja_JP" == `about -uiLanguage`)
				$factor = 1.6;
			int $w = `optionMenu -query -width EEeditorOM`;
			optionMenu -edit -w (int($w*$factor)) EEeditorOM;
		}
		else if (`about -linux`)
		{
			menuItem -enable $allowExtEdit -label (uiRes("m_expressionEditor.kEmacs"))  EEemacsItem;
			menuItem -enable $allowExtEdit -label (uiRes("m_expressionEditor.kGvim"))  EEgvimItem;
			menuItem -enable $allowExtEdit -label (uiRes("m_expressionEditor.kVi"))  EEviItem;
			menuItem -enable $allowExtEdit -label (uiRes("m_expressionEditor.kVim"))  EEvimItem;
			menuItem -enable $allowExtEdit -label (uiRes("m_expressionEditor.kXedit"))  EExeditItem;
			menuItem -enable $allowExtEdit -label (uiRes("m_expressionEditor.kXemacs"))  EExemacsItem;
			menuItem -enable $allowExtEdit -label (uiRes("m_expressionEditor.kOther"))  EEotherItem;
		}

	if ( `optionVar -exists EEexprEdTextEditor` && $allowExtEdit )
		$EEcurrentEditor = `optionVar -query EEexprEdTextEditor`;

	if ($EEcurrentEditor != 1)
		optionMenu -edit -select $EEcurrentEditor EEeditorOM;

	setParent ..;

	// Create the single-line text widget
	//	for displaying the method signature.
	//
    textField -text  "" 
                 -width 200 -editable false EEhelpField;

	// Create the multi-line scrolled text widget.
	//
	text -label (uiRes("m_expressionEditor.kExpression"))  EEtextLabel;

	string $path = `scrollField -wordWrap false EEmultiText`;

	// Attach the textfield to the form.
	//
	formLayout -edit
		-attachForm EEeditorRowL top 	0
		-attachForm EEeditorRowL left 	0 
	 	-attachControl EEtextLabel  top 	4 EEeditorRowL
		-attachForm EEtextLabel  left 	0
	 	-attachControl EEmultiText  top 	4 EEtextLabel
	 	-attachForm EEmultiText  left 	0
	 	-attachForm EEmultiText  right 	0
		-attachForm EEmultiText  bottom 30
	 	-attachControl EEhelpField  top 	4 EEmultiText
	 	-attachForm EEhelpField  left 	0
	 	-attachForm EEhelpField  right 	0
		-attachForm EEhelpField  bottom 0
	 	EEtextForm;

	setParent ..;

	// Create the buttons at the bottom of the window. 
	//
	// Create the form for the apply, update and clear buttons 
	//
	formLayout -numberOfDivisions 100 EEbuttonsForm;

	// Attach the form to its parent, except on the top
	//
	formLayout -edit
		-attachForm EEbuttonsForm bottom 5
		-attachForm EEbuttonsForm left 	 0
		-attachForm EEbuttonsForm right  0
		EEmainForm;

	// Attach the bottom of the text form to the top of the
	// buttons form
	//
	formLayout -edit
		-attachControl EEtextForm bottom 5 EEbuttonsForm 
		EEmainForm;

	// Lay out the buttons evenly across the form.
	//
    button -label (uiRes("m_expressionEditor.kCreate"))  -height 26 EEapplyButton;
    button -label (uiRes("m_expressionEditor.kDelete"))  -height 26 -enable false EEdeleteButton;
	button -label (uiRes("m_expressionEditor.kReload"))  -height 26 -enable false EErestoreButton;
    button -label (uiRes("m_expressionEditor.kClear"))   -height 26 EEclearButton;
    button -label (uiRes("m_expressionEditor.kClose"))   -height 26 EEcloseButton;

    formLayout -edit
        -attachForm EEapplyButton left  5
        -attachPosition EEapplyButton right 3 20

        -attachPosition EEdeleteButton left  2 20
        -attachPosition EEdeleteButton right 3 40

        -attachPosition EErestoreButton left  2 40
        -attachPosition EErestoreButton right 3 60

        -attachPosition EEclearButton left  2 60
        -attachPosition EEclearButton right 3 80

        -attachPosition EEcloseButton left  2 80
        -attachForm EEcloseButton right 5
        EEbuttonsForm;

   		 setParent ..;
	setParent ..;
	
	if (`about -mac`)
	{
		setParent ..;
		setParent ..;
	}

	// Register the callbacks 
	//
	button -edit -command "EEapplyCB" EEapplyButton;
	button -edit -command "EEdeleteCB" EEdeleteButton;
	button -edit -command "EErestoreCB" EErestoreButton;
	button -edit -command "EEclearCB" EEclearButton;
    button -edit -command "EEcloseCB" EEcloseButton;

}	// EEcreateWin


//  ================ EEpostConfirm ================
//
//  SYNOPSIS
//      Post a confirm dialog with theMessage.
//
global proc EEpostConfirm(string $theMessage)
{
	confirmDialog -title (uiRes("m_expressionEditor.kEarning")) 
		-messageAlign "left"
		-message $theMessage
		-button (uiRes("m_expressionEditor.kCloseButton")) 
		-cancelButton (uiRes("m_expressionEditor.kCloseButton"));

}	// EEpostConfirm


//  ================ EEswitchSelectLayout ================
//
//  SYNOPSIS
//      Called when the Select Filter menu is changed.
//
global proc EEswitchSelectLayout(string $whichMethod)
{
	global string $EEnodeMode;

	if ($EEnodeMode == "scriptNode" || $whichMethod == "scriptNode") 
	{
		textField -edit -text "" EEexprNameT;
	}

	$EEnodeMode = $whichMethod;

	if ($whichMethod == "expression")
	{
		text -edit -label (uiRes( "m_expressionEditor.kExpressionName") )  EEexprNameLabel;
		button -edit -label (uiRes( "m_expressionEditor.kNewExpr") )  EEnewExpButton;

		text -edit -label (uiRes( "m_expressionEditor.kExpressions") )  EEselectNamesL;
		text -edit -enable false EEattrNamesL;
		// Disable the filters menu and Selected Attribute textfield
		//
		menu -edit -enable false EEobjFilterMenu; 
		menu -edit -enable false EEattrFilterMenu; 
		menu -edit -enable false EEobjFilterPopMenu; 
		menu -edit -enable false EEattrFilterPopMenu; 
		textFieldGrp -edit -text "" EEselNameT;
		textFieldGrp -edit -enable false EEselNameT;

		text -edit -label (uiRes( "m_expressionEditor.kExpression") )  EEtextLabel;

		tabLayout -edit -selectTabIndex 1 EEoptionsTab;
	}
	else if ($whichMethod == "object")
	{
		text -edit -label (uiRes( "m_expressionEditor.kExpressionName") )  EEexprNameLabel;
		button -edit -label (uiRes( "m_expressionEditor.kNewExpr") )  EEnewExpButton;

		text -edit -label (uiRes( "m_expressionEditor.kObjects") )  EEselectNamesL;
		text -edit -enable true EEattrNamesL;

		// Enable the filter menus  and Selected Attribute textfield
		//
		menu -edit -enable true EEobjFilterMenu; 
		menu -edit -enable true EEattrFilterMenu; 
		menu -edit -enable true EEobjFilterPopMenu; 
		menu -edit -enable true EEattrFilterPopMenu; 
		textFieldGrp -edit -enable true EEselNameT;

		text -edit -label (uiRes( "m_expressionEditor.kExpression") )  EEtextLabel;

		tabLayout -edit -selectTabIndex 1 EEoptionsTab;
	}
	else 
	{
		// Set the Editor for script nodes.
		//
		text -edit -label (uiRes("m_expressionEditor.kScriptNodeName"))  EEexprNameLabel;
		button -edit -label (uiRes("m_expressionEditor.kNewScriptName"))  EEnewExpButton;

		text -edit -label (uiRes("m_expressionEditor.kScriptNodes"))  EEselectNamesL;
		text -edit -enable false EEattrNamesL;

		menu -edit -enable false EEobjFilterMenu; 
		menu -edit -enable false EEattrFilterMenu; 
		menu -edit -enable false EEobjFilterPopMenu; 
		menu -edit -enable false EEattrFilterPopMenu; 
		textFieldGrp -edit -text "" EEselNameT;
		textFieldGrp -edit -enable false EEselNameT;

		textFieldGrp -edit -enable true EEselScriptNodeNameT;
		text -edit -label (uiRes( "m_expressionEditor.kScript") )  EEtextLabel;

		tabLayout -edit -selectTabIndex 2 EEoptionsTab;
	}

}	// EEswitchSelectLayout


//  ================ EEswitchRulesForm ================
//
//  SYNOPSIS
//      Enable/disable some controls when switching between
//		particle and non-particle objects.
//
global proc EEswitchRulesForm(int $enable) 
{
	if ($enable)
	{
		radioButtonGrp -edit -enable true EErulesRBG;
		radioButtonGrp -edit -enable false EEunitsRBG;
		optionMenu -edit -enable false EEanimTypeOM;
	}
	else
	{
		radioButtonGrp -edit -enable false EErulesRBG;
		radioButtonGrp -edit -enable true EEunitsRBG;
		optionMenu -edit -enable true EEanimTypeOM;
	}
}


// *****************************************************************
//
//				EXPRESSION EDITOR QUERY PROCEDURES
//
// ******************************************************************


//  ================ EEgetCurrTypeList ================
//
//  SYNOPSIS
//     Get and return thelist of all objects in the scene
// 	   of the specified type.
//
global proc string[] EEgetCurrTypeList(string $currType)
{
	string $nodeList[];

	switch($currType)
	{
		case "allSelected": $nodeList = `ls -selection`;
							break;
		case "dagObjects":	$nodeList = `ls -dagObjects`;	
							break;
		case "geometry":	$nodeList = `ls -geometry`;	
							break;
		case "transforms":	$nodeList = `ls -transforms`;	
							break;
		case "lights":		$nodeList = `ls -lights`;	
							break;
		case "cameras":		$nodeList = `ls -cameras`;	
							break;
		case "shaders":		$nodeList = `ls -materials`;	
							break;
		case "depNodes":	$nodeList = `ls -dependencyNodes`;	
							break;
		case "joints":		$nodeList = `ls -type joint`;	
							break;
		case "handles":		$nodeList = `ls -type ikHandle`;	
							break;
		case "ikSystems":	$nodeList = `ls -type ikSystem`;	
							break;
		case "ikSolvers":	$nodeList = `ls -type ikSolver`;
							break;
		case "jointLattice":$nodeList = `ls -type jointLattice`;	
							break;
		case "blendShape":	$nodeList = `ls -type blendShape`;	
							break;
		case "boneLattice": $nodeList = `ls -type boneLattice`;	
							break;
		case "cluster":		$nodeList = `ls -type cluster`;	
							break;
		case "lattice":		$nodeList = `ls -type ffd`;	
							break;
		case "sculpt":		$nodeList = `ls -type sculpt`;	
							break;
		case "wire":		$nodeList = `ls -type wire`;	
							break;
		case "scriptNode":	$nodeList = `ls -type script`;	
							break;
	}

	if (`isTrue "DynamicsUIExists"`)
	{
		switch($currType)
		{
			case "particles":	$nodeList = `ls -type particle`;	
								break;
			case "emitters":	$nodeList = `ls -type pointEmitter`;	
								break;
			case "springs":		$nodeList = `ls -type spring`;	
								break;
			case "gravity":		$nodeList = `ls -type gravityField`;	
								break;
			case "drag":		$nodeList = `ls -type dragField`;	
								break;
			case "air":			$nodeList = `ls -type airField`;	
								break;
			case "newton":		$nodeList = `ls -type newtonField`;	
								break;
			case "radial":		$nodeList = `ls -type radialField`;	
								break;
			case "turbulence":	$nodeList = `ls -type turbulenceField`;	
								break;
			case "uniform":		$nodeList = `ls -type uniformField`;	
								break;
			case "vortex":		$nodeList = `ls -type vortexField`;	
								break;
			case "rigidBody":	$nodeList = `ls -type rigidBody`;	
								break;
			case "constraint":	$nodeList = `ls -type rigidConstraint`;	
								break;
		}
	}

	return $nodeList;

}	// EEgetCurrTypeList


//  ================ EEgetExpressionList ================
//
//
//  SYNOPSIS
//     Get and return the list of all expressions in the scene.
//
global proc string[] EEgetExpressionList()
{
	string $nodeList[];
	string $exprList[];

	// Get all the expression nodes.
	//
	$nodeList = `ls -type expression`;

	// Get all the particles that own expressions.
	//
	if (`isTrue "DynamicsUIExists"`)
	{

		string $particles[] = `ls -type particle`;
		string $attrs[];
		string $expr;

		int $pi, $ai, $exprCount = 0;
		for($pi = 0; $pi < size($particles); $pi++)
		{
			//
			// During file import AND referencing, Maya is put into
			// a new namespace, and the file is read into that space,
			// and all references to an object by name are considered
			// relative to that namespace.  It can be thought of as
			// a directory structure.  The "ls" command, however, always
			// returns the names relative to the global or root namespace.
			// Therefore, if we try to access them using those names, and
			// we are not in that global namespace, then we get "Object
			// not found" errors.  To get around this, we prepend ":" to
			// the names from "ls".  This tells Maya that this name is
			// to be considered relative to the global namespace.
			// It is only needed here, since it is only relavent to NEW
			// nodes nodes, and only this particle expression code actually
			// tries to use the names.
			//
			string $fullNamespaceName = (":"+$particles[$pi]);
			$expr = `dynExpression -query -runtimeBeforeDynamics $fullNamespaceName`;
			if (size($expr) == 0)
			{
				$expr = `dynExpression -query -runtimeAfterDynamics $fullNamespaceName`;
			}
			if (size($expr) == 0)
			{
				$expr = `dynExpression -query -creation $fullNamespaceName`;
			}
			if (size($expr) > 0)
			{
				$exprList[$exprCount] = $particles[$pi];
				$exprCount++;
			}
		}
	
		int $ei, $ni;
		for ($ei = 0, $ni = size($nodeList); 
		 	$ei < size($exprList);  
		 	$ei++, $ni++)
	
		{
			$nodeList[$ni] = $exprList[$ei];
		}
	}

	return $nodeList;

}	// EEgetExpressionList


//  ================ EEgetAttrFromNode ================
//
//  SYNOPSIS
//
//		Find out if the current selected object has the
//		specified attribute.  If so, add it the the attributes
//		scrolled list, and return its index; if not, return -1.
//
global proc int EEgetAttrFromNode(string $attrName)
{
	global int $EEobjIsParticle;

	int $i, $found;
	int $attrIndex = -1;
	string $attrs[], $attrsShort[];

	string $selectedObj[] = `textScrollList -query -selectItem EEnodeList`;

	// First look in the list of attribute long and short names.
	//
	$attrs = `listAttr -scalar -visible -connectable -unlocked -multi $selectedObj[0]`;

	$attrsShort = `listAttr -shortNames -scalar -visible -connectable -unlocked -multi $selectedObj[0]`;
	$found = 0;
	for ($i = 0; $i < size($attrs); $i++)
	{
		if ($attrs[$i] == $attrName || $attrsShort[$i] == $attrName)
		{
			$found = 1;
			// Make sure the long name is the one put in the attr list.
			//
			$attrName = $attrs[$i];
			break;
		}
	}

	// If not found, and if it's a particle, look in the list of array
	// attributes, long and short names.
	//
	if (!$found && $EEobjIsParticle)
	{
		clear($attrs);
		clear($attrsShort);

		$attrs = `listAttr -array -visible -connectable -unlocked -multi $selectedObj[0]`;
		$attrsShort = `listAttr -shortNames -array -visible -connectable -unlocked -multi $selectedObj[0]`;

		for ($i = 0; $i < size($attrs); $i++)
		{
			if ($attrs[$i] == $attrName || $attrsShort[$i] == $attrName)
			{
				$found = 1;
				// Make sure the long name is the one put in the attr list.
				//
				$attrName = $attrs[$i];
				break;
			}
		}
	}

	// If the user typed a valid attribute name, put it in the
	// current attributes list and return the index (1-based).
	//
	if ($found)
	{
		textScrollList -edit -append $attrName EEattrList;
		$attrIndex = `textScrollList -query -numberOfItems EEattrList`;
	}

	clear($attrs);
	clear($attrsShort);
	clear($selectedObj);

	return $attrIndex;

}	// EEgetAttrFromNode


//  ================ EEgetEditorMessage ================
//
//  SYNOPSIS
//      Return message re WINEDITOR.  Called by editorCB if the user
//		chooses "Other" in the option menu.
//
global proc string EEgetEditorMessage()
{
	return (uiRes("m_expressionEditor.kWayTooLongEditorMessage"));

}


//  ================ EEisValidNodeName ================
//
//  SYNOPSIS
//      Make sure the node name sent in is valid.
//
global proc int EEisValidNodeName(string $nodeName)
{
	string $result[] = `ls $nodeName`;

	int $status = 1;

	if (size($result) == 0)
	{
		
		string $invalidObjFormat = (uiRes("m_expressionEditor.kInvalidObjName"));
		string $invalidObjStr = `format -stringArg $nodeName $invalidObjFormat`;
		warning $invalidObjStr;
		$status = 0;
	}
	else if (size($result) > 1)
	{
		string $multipleObjectsMatchFormat = (uiRes("m_expressionEditor.kMultObjsMatch"));
		string $multipleObjsMatch = `format -stringArg $nodeName $multipleObjectsMatchFormat`;
		warning $multipleObjsMatch;
		$status = 0;
	}

	clear($result);
	return $status;

}	// EEisValidNodeName


//  ================ EEexprNameExists ================
//
//  SYNOPSIS
//      Return if the name is of an existing expression
//
global proc int EEexprNameExists(string $exprName)
{
	string $allExprNames[] = EEgetExpressionList();
	int $i, $numExpressions;
	$numExpressions = size($allExprNames);

	int $nameExists = 0;

	for ($i = 0; $i < $numExpressions; $i++)
	{
		if ($allExprNames[$i] == $exprName)
		{
			$nameExists = 1;
			break;
		}
	}
	clear($allExprNames);

	return $nameExists;
}


//  ================ EEcheckValidExprName ================
//
//  SYNOPSIS
//      Make sure the expression name sent in is valid.
//
global proc int EEcheckValidExprName(string $exprName)
{
	global string $EEcurrExpressionName;
	int $nameValid = 1;
	$exprName = `textField -query -text EEexprNameT`;

	// The user can only name a new expression or change the
	// name of an expression being edited;  so if the name
	// the user typed is already the name of an expression node
	// then it is not valid, so remove it and restore the
	// previous name.
	//
	int $nameExists = EEexprNameExists($exprName);

	if ($nameExists)
	{
		$nameValid = 0;
		string $nameAlreadyUsedFormat = (uiRes("m_expressionEditor.kNameAlreadyUsed"));
		string $nameAlreadyUsedStr = `format -stringArg $exprName $nameAlreadyUsedFormat`;
		warning $nameAlreadyUsedStr;

		// Name already exists, so is not valid to reuse, so restore the
		// previous name, or blank the field if there was no name.
		//
		if (size($EEcurrExpressionName) > 0)
			textField -edit -text $EEcurrExpressionName EEexprNameT;
		else
			textField -edit -text "" EEexprNameT; 
	}

	return $nameValid;

}	// EEcheckValidExprName


//  ================ EEnodeIsInList ================
//
//  SYNOPSIS
//		Return the index of the node in the scrolled list.
//		or -1 if it's not there.
//
global proc int EEnodeIsInList(string $nodeName)
{
	// If there is no object list, return "Not found".
	//
	if (`textScrollList -query -numberOfItems EEnodeList` == 0)
	{
		return -1;
	}

	// Get the list of object names.
	//
	string $listObjs[] = `textScrollList -query -allItems EEnodeList`;
	int $currentObjSize = size($listObjs);

	int $objIndex = -1;
	int $i;
	for ($i = 0; $i < $currentObjSize; $i++)
	{
		if ($nodeName == $listObjs[$i]) 
		{
			// Found it; return the position in the list
			//
			$objIndex = $i;
			break;
		}
	}

	clear($listObjs);

	return $objIndex;

}	// EEnodeIsInList


//  ================ EEattrIsInList ================
//
//  SYNOPSIS
//
//		Return the index of the attribute in the scrolled list.
//		or -1 if it's not there.
//
global proc int EEattrIsInList(string $attrName)
{
	global int $EEobjIsParticle;

	string $listAttrsShort[];
	int $i;

	// If there is no attribute list, return "Not found".
	//
	if (`textScrollList -query -numberOfItems EEattrList` == 0)
		return -1;

	// Will need to test short and long name, so get the selected
	// object name to get the short list;  but get the long list from
	// the attribute list.  It was made using the same listAttr 
	// call, without -sn.
	//
	string $selectedObj[] = `textScrollList -query -selectItem EEnodeList`;
	string $listAttrs[] = `textScrollList -query -allItems EEattrList`;

	$listAttrsShort = `listAttr -shortNames -scalar -visible -connectable -unlocked -multi -keyable $selectedObj[0]`;

	// If the object is a particle, we also want to get the array
	// attributes.
	//
	if ($EEobjIsParticle)
	{
		string $arrayAttrsShort[];
		int $attrSize;
		$arrayAttrsShort = `listAttr -shortNames -array -visible -connectable -unlocked -multi $selectedObj[0]`;
		$attrSize = size($arrayAttrsShort);
		$listAttrSize = size($listAttrsShort);

		for ($i = 0; $i < $attrSize; $i++)
		{
			$listAttrsShort[$listAttrSize] = $arrayAttrsShort[$i];
			$listAttrSize++;
		}
	}

	$listAttrSize = size($listAttrs);

	int $attrIndex = -1;
	for ($i = 0; $i < $listAttrSize; $i++)
	{
		if (($attrName == $listAttrs[$i]) ||
			($attrName == $listAttrsShort[$i]))
		{
			// Found it; return the position in the list (the
			// list is 1-based)
			//
			$attrIndex = $i + 1;
			break;
		}
	}
	clear($selectedObj);
	clear($listAttrs);
	clear($listAttrsShort);

	return $attrIndex;

}	// EEattrIsInList


// *****************************************************************
//
//		EXPRESSION EDITOR UI EDIT AND LIST MANAGEMENT PROCEDURES
//
// ******************************************************************


//  ================ EEsetCreateMode ================
//
//  SYNOPSIS
//     Set the editor state to create mode.
//
global proc EEsetCreateMode(string $createMessage)
{
	global int $EEcreateMode;
	global string $EEnodeMode;

	string $particle   = (uiRes("m_expressionEditor.kCreatingPart"));
	string $expression = (uiRes("m_expressionEditor.kCreatingExpr"));
	string $script     = (uiRes("m_expressionEditor.kCreatingScript"));
		
	switch( $createMessage ) {
		case "Creating Particle Expression":
			$createMessage = $particle;
			break;
		case "Creating Expression":
			$createMessage = $expression;
			break;
		case "Creating Script Node":
			$createMessage = $script;
			break;
		default:
			string $fmt = (uiRes("m_expressionEditor.kInvCreate"));
			error `format -s $createMessage $fmt`;
			break;
	}

	$EEcreateMode = 1;
	text -edit -label $createMessage EEceModeT;
    button -edit -label (uiRes( "m_expressionEditor.kCreate") )
		-width 100 -height 26 EEapplyButton;
	button -edit -enable false EEdeleteButton;
	button -edit -enable false EErestoreButton;

	if ($EEnodeMode == "scriptNode")
	{
		//	ScriptNodes: These controls can not be queried. To eliminate any
		//	confusion, these control are disabled during creation.
		//
		attrEnumOptionMenu -edit -enable false EEscriptNodeTypeAOM;
		
		// EEscriptNodeRefEditsRBG has two selection items. One is "Record" and the other is "ignore".
		// EEscriptNodeRefEditsRBG was created with selection "Record" by default.
		// The selection should correspond to the attribute value "ignoreReferenceEdits" of the scriptNode.
		// Get the correct attribute value "ignoreReferenceEdits" of the selected scriptNode, 
		// make sure the ui selection item keeps consistent with this value.
		// 
		string $selScriptNodes[] = `textScrollList -q -si EEnodeList`;
		string $currentScriptNodeName = $selScriptNodes[0];
		int $scriptNodeRefEditsSelectedItemValue = 1; // Value 1 corresponds to selection "Record".

		if ((size($currentScriptNodeName)) > 0)
		{
			string $ignoreReferenceEditsAttrExpression = $currentScriptNodeName + ".ignoreReferenceEdits";
			int $ignoreReferenceEditsValue = `getAttr  $ignoreReferenceEditsAttrExpression`;
			if ($ignoreReferenceEditsValue)
			{
				$scriptNodeRefEditsSelectedItemValue = 2;
			}
			
			radioButtonGrp -edit -select $scriptNodeRefEditsSelectedItemValue EEscriptNodeRefEditsRBG;
		}

		radioButtonGrp -edit -enable false EEscriptNodeRefEditsRBG;
	}

}	// EEsetCreateMode


//  ================ EEsetEditMode ================
//
//  SYNOPSIS
//     Set the editor state to edit mode.
//
global proc EEsetEditMode(string $editMessage)
{
	global int $EEcreateMode;
	global string $EEnodeMode;

	string $particle   = (uiRes("m_expressionEditor.kEditParticle"));
	string $partExpr   = (uiRes("m_expressionEditor.kEditPartExpr"));
	string $script 	   = (uiRes("m_expressionEditor.kEditScript"));
	string $scriptNode = (uiRes("m_expressionEditor.kEditScriptNode"));
	string $expression = (uiRes("m_expressionEditor.kEditExpression"));
	
	switch( $editMessage ) {
		case "Editing ParticleExpression":
			$editMessage = $particle;
			break;
		case "Editing Particle Expression":
			$editMessage = $partExpr;
			break;
		case "Editing Script":
			$editMessage = $script;
			break;
		case "Editing Script Node":
			$editMessage = $scriptNode;
			break;
		case "Editing Expression":
			$editMessage = $expression;
			break;
		default:
			string $fmt = (uiRes("m_expressionEditor.kInvEdit"));
			error `format -s $editMessage $fmt`;
			break;
	}

	$EEcreateMode = 0;
	text -edit -label $editMessage EEceModeT;
	button -edit -enable true EErestoreButton;
    button -edit -label (uiRes("m_expressionEditor.kEdit"))  -width 100 -height 26 EEapplyButton;
	button -edit -enable true EEdeleteButton;

	if ($EEnodeMode == "scriptNode") 
	{
		//	ScriptNodes: These control can not be queried. To eliminate any
		//	confusion, these control are disabled during creation.
		//
		attrEnumOptionMenu -edit -enable true EEscriptNodeTypeAOM;
		radioButtonGrp -edit -enable true EEscriptNodeRefEditsRBG;
	}
}	// EEsetEditMode


//  ================ EEclearAllControls ================
//
//  SYNOPSIS
//     Clear all the expression, node, attribute names/lists
//
global proc EEclearAllControls()
{
	global int $EEobjIsParticle;
	global int $EEpExpressionInEditor;
	global int $EEexpressionInEditor ;
	global string $EEcurrExpressionName;
	global string $EEorigExpressionName;
	global string $EEnodeMode;

	// Only clear the expression name if it exists, as otherwise the
	// user may have typed a new name to use it for the future.
	// Before clearing it, unregister the expression if it is registered.
	//
	string $exprName = `textField -query -text EEexprNameT`;
	if (EEisParticle($exprName) ||
		size($exprName) && 
		(EEexprNameExists($exprName) || EEscriptNameExists($exprName)))
	{
		EEresetExpressionName("");
	}

	textFieldGrp -edit -text "" EEselNameT;
	textFieldGrp -edit -text "" EEdefNameT;
	scrollField -edit -text "" EEmultiText;

	optionMenu -edit -select 2 EEanimTypeOM;

	radioButtonGrp -edit -select 1 EEunitsRBG;

	if ($EEnodeMode != "scriptNode") 
	{
		if ($EEobjIsParticle)
			EEsetCreateMode( "Creating Particle Expression" );
		else
			EEsetCreateMode( "Creating Expression" );
	} 
	else 
	{
		EEsetCreateMode( "Creating Script Node" );
	}

	$EEcurrExpressionName = "";
	$EEorigExpressionName = "";

	// Nothing in editor means no expressions in files are
	// currently in the editor.
	//
	$EEpExpressionInEditor = -1;
	$EEexpressionInEditor = -1;

	//	Some script node controls
	textFieldGrp -edit -text "" EEselScriptNodeNameT;

}	// EEclearAllControls


//  ================ EEresetFilterToAll ================
//
//  SYNOPSIS
//		Reset the filter to "all dependency nodes" and rebuild
//		the object list
//
global proc EEresetFilterToAll(string $nodeName)
{
	global string $EEcurrNodeFilter;
	global string $EEnodeMode;

	// Check and see if the object selected is in the dag list,
	// if so, reset to it, otherwise reset to dependency nodes.
	//
	string $nodeList[] = `ls -dagObjects`;	
	int $i;
	int $found = 0;

	if (size($nodeName) > 0)
	{
		for ($i = 0; $i < size($nodeList); $i++)
		{
			if ($nodeName == $nodeList[$i])
			{
				$found = 1;
				break;
			}
		}
	}
	if ($found || size($nodeName) == 0)
	{
		$EEcurrNodeFilter = "dagObjects";
		menuItem -edit -radioButton true EEdagObjMenuItem;
	}
	else
	{
		$EEcurrNodeFilter = "depNodes";
		menuItem -edit -radioButton true EEdepNodeMenuItem;
	}
	$EEnodeMode = "object";
	EErebuildNodeList("object");

}	// EEresetFilterToAll



//  ================ EEresetNodeControls ================
//
//  SYNOPSIS
//     Reset controls for a new selected object.
//
global proc EEresetNodeControls(string $nodeName)
{
	global int $EEobjIsParticle;
	global string $EEnodeMode;
    
	textFieldGrp -edit -text $nodeName -enable true EEselNameT;

	if (EEisParticle($nodeName))
	{
		$EEobjIsParticle = 1;
		EEswitchRulesForm(1);
		textFieldGrp -edit -text "" -enable false EEdefNameT;
		text -edit -enable false EEexprNameLabel;
		EEresetExpressionName("");

		textField -edit  -enable false EEexprNameT;
		EEsetCreateMode("Creating Particle Expression");
	}
	else
	{
		$EEobjIsParticle = 0;
		EEswitchRulesForm(0);
		text -edit -enable true EEexprNameLabel;

		// Only clear the expression name if it exists, as otherwise the
		// user may have typed a new name to use it for the future.
		//
		string $exprName = `textField -query -text EEexprNameT`;

		if ($EEnodeMode == "scriptNode") 
		{
			textFieldGrp -edit -text "" -enable false EEdefNameT;
			if (size($exprName) && EEscriptNameExists($exprName))
			{
				EEresetExpressionName("");
				EEsetCreateMode("Creating Script Node");
			}
		}
		else 
		{
			textFieldGrp -edit -text $nodeName -enable true EEdefNameT;
			if (size($exprName) && EEexprNameExists($exprName))
			{
				EEresetExpressionName("");
				EEsetCreateMode("Creating Expression");
			}
		}

		textField -edit -enable true EEexprNameT;
	}

	if ($EEnodeMode == "scriptNode") 
	{
		textFieldGrp -edit -text $nodeName -enable true EEselScriptNodeNameT;
	} 
	else 
	{
		//  Load the name of the objects attributes into the editor's list.
		//
		textFieldGrp -edit -text $nodeName -enable true EEselNameT;
		EErebuildAttrList($nodeName);
	}

}	// EEresetNodeControls


//  ================ EErebuildNodeList ================
//
//  SYNOPSIS
//		Rebuild the list of objects for the expression editor
//
global proc EErebuildNodeList(string $whichList)
{
	global string $EEcurrNodeFilter;
	global string $EEcurrSelectedNode;
	global string $EEorigExpressionName;
	global string $EEcurrExpressionName;
	global int $EEcreateMode;
	global int $EEobjIsParticle;

	int $i;

	string $nodeList[];

	// First pick up the current and orig expression names, so we can
	// reinstate, if desired.
	//
	string $currExprName = `textField -query -text EEexprNameT`;

	string $origExprName = $EEorigExpressionName;

	// Clear the old object and attribute lists. But first, make
	// sure messages have been stopped for them.
	//
	$nodeList = `textScrollList -query -allItems EEnodeList`;
	for ($i = 0; $i < size($nodeList); $i++)
	{
		EEremoveNodeFromList($nodeList[$i], 1);
	}
	$EEcurrSelectedNode = "";

	textScrollList -edit -removeAll EEattrList;

	// Get the list of expression or objects of the selected type.
	//
	if ($whichList == "expression")
		$nodeList = EEgetExpressionList();
	else if ($whichList == "scriptNode") 
		$nodeList = EEgetCurrTypeList("scriptNode");
	else
		$nodeList = EEgetCurrTypeList($EEcurrNodeFilter);

	if (size($nodeList) == 0)
	{
		EEclearAllControls();
		return;
	}

	// Make the object list in the UI, and register to listen to
	// changes in each node.
	//
	string $newNode;
	string $prevNewNode;

	for ($i = 0; $i < size($nodeList); $i++)
	{
		string $buffer[];
		tokenize($nodeList[$i], ".", $buffer);

		// If the buffer has more than two items in it, the first item
		// will be the node name and the others attribute names, 
		// e.g. "cv".  So, strip $nodeName to just the node name,
		// and the rest  will go into the attr list.
		//
		if (size($buffer) >= 2 )
		{
			$newNode = $buffer[0];
			if ($newNode != $prevNewNode)
			{
				EEaddNodeToList($newNode);
				$prevNewNode = $newNode;
			}
		}
		else
		{
			EEaddNodeToList($nodeList[$i]);
		}
	}

	string $currObjAttrName;

	if ($whichList == "expression")
	{
		// If switching to expression mode, and an expression is
		// in the editor, make it the selected item in the list,
		// otherwise clear all controls.
		//
		// Get the name of the obj.attr the expression is connected to
		//
		if (size($currExprName) > 0 && !$EEcreateMode)
		{
			if ($EEobjIsParticle)
			{
				// Expression name and obj.attr name are the same for
				// particles.
				//
				$currObjAttrName = $currExprName;
			}
			else
			{
				string $objAttr[] = 
					`listConnections -source false -destination true -shapes true -plugs true  -skipConversionNodes true  $currExprName`;
				$currObjAttrName = $objAttr[0];
			}
			EEselectNodeInList($currExprName);

			textFieldGrp -edit -text $currObjAttrName EEselNameT;
			$EEorigExpressionName = $origExprName;
			$EEcurrExpressionName = $currExprName;
		}
		else
		{
			EEclearAllControls();
		}
	}
	else if ($whichList == "object")
	{
		// If switching to object/filter mode, and an object is in the 
		// editor, if it's in the new list, make it the selected item 
		// in the list, build its attribute list, and make the current
		// attribute selected.  If it's not in the list, make the
		// first item in the new list selected and get its attribute list.
		//
		$currObjAttrName = `textFieldGrp -query -text EEselNameT`;

		if (size($currObjAttrName) > 0)
		{
			string $buffer[];
			tokenize($currObjAttrName, ".", $buffer);
			$currentObj = $buffer[0];
			$currentAttr = $buffer[1];

			if (EEnodeIsInList($currentObj) > -1)
			{
				EEnewSelectedNode($currentObj);

				if ((size($currentAttr) > 0) && 
					(($attrListIndex = EEattrIsInList($currentAttr)) > -1))
				{
					EEnewSelectedAttr($attrListIndex);
				}
				return;
			}
		}
		EEclearAllControls();

		// Either there's no object name current or the current one
		// is not in the new list, so if there is an object list, make
		// the first item selected, build its attribute list, and set
		// the object name in the selected obj/attr textfield.
		//
		if (`textScrollList -query -numberOfItems EEnodeList` > 0)
		{
			textScrollList -edit -selectIndexedItem 1 EEnodeList;
			string $theObj[] = `textScrollList -query -selectItem EEnodeList`;
			EEnewSelectedNode($theObj[0]);
		}
	} 
	else
	{
		// If switching to script node mode, and an object is in the 
		// editor, if it's in the new list, make it the selected item 
		// in the list.  If it's not in the list, make the
		// first item in the new list selected and get its attribute list.
		//
		string $currNodeName = `textField -query -text EEexprNameT`;

		if (size($currNodeName) > 0)
		{
			EEnewSelectedNode($currNodeName);

			if (!$EEcreateMode)
			{
				textFieldGrp -edit -text $currNodeName EEselScriptNodeNameT;
				$EEorigExpressionName = $origExprName;
				$EEcurrExpressionName = $currExprName;
			}
		}
		else
		{
			EEclearAllControls();
		}
	}

	clear($nodeList);
	
}	// EErebuildNodeList


//  ================ EErebuildAttrList ================
//
//  SYNOPSIS
//		Rebuild the list of attributes for the expression editor
//
global proc	EErebuildAttrList(string $nodeName)
{
	if ($nodeName == "") return;

	global string $EEcurrAttrFilter;
	global int $EEobjIsParticle;

	int $i;

	// Get the object's attribute list; clear the current
	// attribute list from the attribute scroll list, and put 
	// the new list in the control, and the object name in
	// the editor default object textfield.
	//
	string $objAttrs[] = `listAttr -scalar -visible -connectable -unlocked -multi -keyable $nodeName`;

	if ($EEobjIsParticle)
	{
		string $arrayAttrs[];
		int $attrSize;

		$arrayAttrs = `listAttr -array -visible -connectable -unlocked -multi $nodeName`;
		$arrayAttrSize = size($arrayAttrs);
		$attrSize = size($objAttrs);

		for ($i = 0; $i < $arrayAttrSize; $i++)
		{
			$objAttrs[$attrSize] = $arrayAttrs[$i];
			$attrSize++;
		}
	}

	textScrollList -edit -removeAll EEattrList;

	if ($EEcurrAttrFilter == "all")
	{
		for ($i = 0; $i < size($objAttrs); $i++)
		{
			if (!$EEobjIsParticle || EEisValidDynAttr($objAttrs[$i]))
				textScrollList -edit -a $objAttrs[$i] EEattrList;
		}
	}
	else
	{
		// List only attributes that have expressions.
		// Find out if there's an expression node connected to the
		// attribute, if there is one, add the attribute to the
		// list.
		//
		string $objAttrName;
		string $exprName[];
		string $particleExpr;

		for ($i = 0; $i < size($objAttrs); $i++)
		{
			if (!$EEobjIsParticle)
			{
				$objAttrName = ($nodeName+"."+$objAttrs[$i]);
				$exprName = 
					`listConnections -source true -destination false -type "expression"  -scn true  $objAttrName`;
				if (size($exprName[0]) > 0)
				{
					textScrollList -edit -append $objAttrs[$i] EEattrList;
				}
			}
			else
			{
				$particleExpr =	`dynExpression -query -runtimeBeforeDynamics $nodeName`;
				if (size($particleExpr) == 0)
				{
					$particleExpr = `dynExpression -query -runtimeAfterDynamics $nodeName`;
				}
				if (size($particleExpr) == 0)
				{
					$particleExpr = `dynExpression -query -creation $nodeName`;
				}
				if (size($particleExpr) > 0)
				{
					textScrollList -edit -append $objAttrs[$i] EEattrList;
				}
			}
		}
	}
}	// EErebuildAttrList


// 
//  ================ EEupdateExprList ================
//
//  SYNOPSIS
//		Update the expression list when a name has changed.
//
global proc EEupdateExprList()
{
	global string $EEorigExpressionName;
	global string $EEcurrExpressionName;
	global string $EEnodeMode;

	// If the user has changed the expression name, and is in
	// select-by-expression mode, update the list with the new
	// name.
	//
	if ($EEorigExpressionName != $EEcurrExpressionName)
	{
   		if ($EEnodeMode == "expression" || $EEnodeMode == "scriptNode")
		{
			EEremoveNodeFromList($EEorigExpressionName, 0);

			EEaddNodeToList($EEcurrExpressionName);

			// Select the node.
			//
			EEselectNodeInList($EEcurrExpressionName);

		}
		$EEorigExpressionName = $EEcurrExpressionName;
	}

}	// EEupdateExprList


//  ================ EEaddNodeToList ================
//
//  SYNOPSIS
//
//		Add a node to the expression/object list, if it's not already
//		there.
//
global proc EEaddNodeToList(string $nodeName)
{
	// Listen for changes in the node, then add it.
	//
	expressionEditorListen -ln $nodeName;

	if (EEnodeIsInList($nodeName) == -1)
		textScrollList -edit -append $nodeName EEnodeList;

}	// EEaddNodeToList


//  ================ EEremoveNodeFromList ================
//
//  SYNOPSIS
//
//		Remove a node from the expression/object list.
//
global proc EEremoveNodeFromList(string $nodeName, int $removeExpr)
{
	global string $EEorigExpressionName;
	global string $EEcurrExpressionName;
	global string $EEcurrSelectedNode;

	// Stop listening for changes in the node, then remove it.
	//
	expressionEditorListen -stopListenForName $nodeName;

	string $selected[] = `textScrollList -query -selectItem EEnodeList`;
	if (size($selected) > 0 && $nodeName == $selected[0])
	{
		expressionEditorListen -stopListenForAttr $nodeName;

		// If the flag says to, remove the
		// expression from the expression field.
		//
		if ($removeExpr)
		{
			EEresetExpressionName("");
			$EEcurrExpressionName = "";
			$EEorigExpressionName = "";
			$EEcurrSelectedNode = "";
		}
	}

	if (EEnodeIsInList($nodeName) > -1)
		textScrollList -edit -removeItem $nodeName EEnodeList;

}	// EEremoveNodeFromList


//  ================ EEselectNodeInList ================
//
//  SYNOPSIS
//
//		Select a node in the expression/object list.
//
global proc EEselectNodeInList(string $nodeName)
{
	global string $EEcurrSelectedNode;
	global string $EEnodeMode;

	// Stop listening for attribute changes in the current selected
	// selected object; select the new node and set it up to
	// listen for attribute changes.
	//
	if (size($EEcurrSelectedNode) > 0)
	{
		expressionEditorListen -stopListenForAttr $EEcurrSelectedNode;
	}
	textScrollList -edit -selectItem $nodeName EEnodeList;

	// If in expression mode, then the selected node is an
	// expression, so also should go in the expression name
	// field.
	//
	if ($EEnodeMode == "expression" || $EEnodeMode == "scriptNode")
		textField -edit -text $nodeName EEexprNameT;

	$EEcurrSelectedNode = $nodeName;
	expressionEditorListen -listenForAttr $nodeName;

}	// EEselectNodeInList


// 
//  ================ EEnewSelectedNode ================
//
//  SYNOPSIS
//      Make the object selected, and load its
//		attribute list into the editor's attribute list.
//
global proc EEnewSelectedNode(string $nodeName)
{
	int $EEobjIsParticle;

	EEclearAllControls();
	EEresetNodeControls($nodeName);

	// Show the object selected, and register it to get attribute
	// added/removed messages.
	//
	EEselectNodeInList($nodeName);

	// If the new node is a particle, get its expression, if it has
	// one.
	//
	if (EEisParticle($nodeName))
	{
		string $particleExpr = EEgetParticleExpression($nodeName, "");
		if (size($particleExpr) == 0)
			EEdisplayNoExpression($nodeName);
		else
			EEdisplayParticleExpression($nodeName, $particleExpr);
	}

}	// EEnewSelectedNode


//  ================ EEnewSelectedAttr ================
//
//  SYNOPSIS
//      Load a new attribute from the attribute list into the editor.
//
global proc EEnewSelectedAttr(int $attrIndex)
{
	// Get the selected object
	//
	string $selectedObj[] = `textScrollList -query -selectItem EEnodeList`;

	//	Make the attribute  selected and put the object.attribute 
	//  name in the selected object/attribute textfield; 
	//
	textScrollList -edit -selectIndexedItem $attrIndex EEattrList;
	textScrollList -edit -showIndexedItem $attrIndex EEattrList;

	// Make sure we have the long name of the attribute.
	//
	string $names[] = `textScrollList -query -selectItem EEattrList`;
	string $attrName = $names[0];

	EEloadNewNodeAttr($selectedObj[0], $attrName);

}	// EEnewSelectedAttr


//  ================ EEloadNewNodeAttr ================
//
//  SYNOPSIS
//
//		Load a new object.attribute and its expression into
//		the editor.
//
global proc EEloadNewNodeAttr(string $nodeName, string $attrName)
{
	global int $EEobjIsParticle;
	string $objAttrName;

	$objAttrName = ($nodeName+"."+$attrName);

	// Display the expression for this attribute, if there is one.
	//
	EEdisplayAttrExpr($objAttrName);

	textFieldGrp -edit -text $objAttrName EEselNameT;

	// User may have sent in a short name, so find the attribute in the list
	// checking both short and long names, then select it.
	//
	if (($attrListIndex = EEattrIsInList($attrName)) > -1)
	{
		textScrollList -edit -selectIndexedItem $attrListIndex EEattrList;
		textScrollList -edit -showIndexedItem $attrListIndex EEattrList;
	}

}	// EEloadNewNodeAttr


//  ================ EEdisplayAttrExpr ================
//
//  SYNOPSIS
//      Display the expression connected to the current
//      object.attribute in the scrolled textfield, and
//		put the name in the expression name textfield.
//
global proc EEdisplayAttrExpr(string $objAttrName)
{
	global int $EEobjIsParticle;

	if (!$EEobjIsParticle)
	{
		string $exprName[] = 
			`listConnections -source true -destination false -type "expression" -scn true $objAttrName`;

		// If the obj.attr has an expression,  load it; otherwise
		// clear and reset the controls.
		//
		if (size($exprName[0]) == 0)
			EEdisplayNoExpression($objAttrName);
		else
			EEdisplayExpression($exprName[0]);

		clear($exprName);
	}
	else
	{
		string $particleExpr;
		string $buffer[];
		tokenize($objAttrName, ".", $buffer);

		$particleExpr = EEgetParticleExpression($buffer[0], $buffer[1]);

		if (size($particleExpr) == 0)
		{
			EEdisplayNoExpression($objAttrName);
			EEswitchRulesForm(1);
		}
		else
		{
			if (EEisDynExpression($objAttrName))
			{
				EEdisplayParticleExpression($buffer[0], $particleExpr);
				EEswitchRulesForm(1);
			}
			else
			{
				string $exprName[] = 
					`listConnections -source true -destination false -type "expression" -scn true $objAttrName`;
				EEdisplayExpression($exprName[0]);
				EEswitchRulesForm(0);
			}
		}
	}

}	// EEdisplayAttrExpr


//  ================ EEdisplayNoExpression ================
//
//  SYNOPSIS
//      Set the controls for no expression.
//
//
global proc EEdisplayNoExpression(string $objAttrName)
{
	global int $EEcurrentEditor;
	global int $EEdoLaunchTextEd;
	global string $EEcurrExpressionName;
	global string $EEorigExpressionName;
	global int $EEobjIsParticle;
	global int $EEexpressionInEditor;
	global int $EEpExpressionInEditor;
	global string $EEnodeMode;

	// Only clear the expression name if it exists or is a particle
	// name, as otherwise the user may have typed a new name to use it
	// for the future.
	//
	string $exprName = `textField -query -text EEexprNameT`;

	int $isParticle = EEisParticle($exprName);
	if ( (size($exprName)) && 
		 ($isParticle || EEexprNameExists($exprName))) 
	{
		// First, unregister the current expression, if it is
		// eligible.
		//
		EEresetExpressionName("");
	}

	if ($EEnodeMode == "scriptNode") 
	{
		EEresetExpressionName("");
	}

	scrollField -edit -text "" EEmultiText;
	radioButtonGrp -edit -select 1 EEunitsRBG;

	string $buffer[];
	tokenize($objAttrName, ".", $buffer);

	if ($EEobjIsParticle)
	{
		EEsetCreateMode("Creating Particle Expression");

		if ($EEcurrentEditor != 1 && $EEdoLaunchTextEd)
		{
			EElaunchParticleEditor("", $buffer[0]);
			scrollField -edit -enable false EEmultiText;
		}
		textFieldGrp -edit -text "" -enable false EEdefNameT;

		// For a particle , the expression name must be the name of the
		// particle, so put it in the expression name textfield now.
		//
		EEresetExpressionName($buffer[0]);
	}
	else
	{
		if ($EEnodeMode == "scriptNode")
		{
			textFieldGrp -edit -text "" -enable false EEdefNameT;
			EEsetCreateMode("Creating Script Node");
		} 
		else 
		{
			EEsetCreateMode("Creating Expression");

			// Set default to current obj
			//
			textFieldGrp -edit -text $buffer[0] EEdefNameT;
			optionMenu -edit -select 2 EEanimTypeOM;
		}

		if ($EEcurrentEditor != 1 && $EEdoLaunchTextEd)
		{
			EElaunchEditor($objAttrName, "", "");
			scrollField -edit -enable false EEmultiText;
		}
		else
		{
			scrollField -edit -enable true EEmultiText;
		}
	}
	if ($EEnodeMode == "scriptNode") 
	{
		textFieldGrp -edit -text "" EEselScriptNodeNameT;
	} 
	else 
	{
		textFieldGrp -edit -text $objAttrName EEselNameT;
	}

	if (!$EEdoLaunchTextEd)
	{
		$EEexpressionInEditor = -1;
		$EEpExpressionInEditor = -1;
	}

	$EEdoLaunchTextEd = 0;
	$EEcurrExpressionName = "";
	$EEorigExpressionName = "";


}	// EEdisplayNoExpression


//  ================ EEregisterExpressions ================
//
//  SYNOPSIS
//      Register all expressions in the scene to receive
//      expression changed messages.
//
//
global proc EEregisterExpressions()
{
	int $i;

	string $expressions[] = `ls -type expression`;
	for ($i = 0; $i < size($expressions); $i++)
	{
	 	expressionEditorListen -listenForExpression $expressions[$i];
	}
	clear($expressions);

	if (`isTrue "DynamicsUIExists"`)
	{
		$expressions = `ls -type particle`;	
		for ($i = 0; $i < size($expressions); $i++)
		{
	 		expressionEditorListen -listenForExpression $expressions[$i];
		}
	}
	clear($expressions);
}


// ******************************************************************
//
//				EXPRESSION EDITOR CORE PROCEDURES
//
// ******************************************************************

//  ================ EEupdateWindow ================
//
//  SYNOPSIS
//      Update the Expression Editor -- called when the Editor is
//      created or shown.  The expression to be put in the
//		window is that connected to nodeName.attrName 
//
//
global proc EEupdateWindow(string $nodeName, string $attrName)
{
	global string $EEcurrNodeFilter;
	global string $EEnodeMode;

	string $buffer[];

	// If an object name has been sent in, set the editor
	// to object mode and selected mode.
	//
	if (size($nodeName) > 0)
	{
		if (EEisScriptNode($nodeName))
		{
			$EEnodeMode = "scriptNode";
		} 
		else 
		{
			$EEnodeMode = "object";
			$EEcurrNodeFilter = "allSelected";
			menuItem -edit -radioButton true EEallSelectedMenuItem;
		}
	}

	if ($EEnodeMode == "scriptNode") 
	{
		EEswitchSelectLayout("scriptNode");
	}

	if ($EEnodeMode == "object") {
	 	button -edit -enable false EEnewExpButton;
	} else {
	 	button -edit -enable true EEnewExpButton;
	}

	// Rebuild the object list. 
	// 
	EErebuildNodeList($EEnodeMode);

	// If an object name was sent in, load it.
	//
	if (size($nodeName) > 0)
	{
		// If it is not in the list, add it and make it the
		// selected one; and get its attribute list.
		//
		if (EEnodeIsInList($nodeName) == -1)
		{
			EEaddNodeToList($nodeName);

			EEnewSelectedNode($nodeName);

			if ($EEnodeMode != "scriptNode")
			{
				// Load nodeName's attribute list.
				//
				if (size($attrName) > 0) 
				{
					int $attrListIndex;
					if (($attrListIndex = EEattrIsInList($attrName)) == -1)
					{
						// If the attribute name as been sent in, put it in the list
						// and select it even if it is not an attribute we don't usually
						// put in the list, e.g. it is not keyable.
						//
						textScrollList -edit -append $attrName EEattrList;
						$attrListIndex = `textScrollList -query -numberOfItems EEattrList`;
					}
					EEnewSelectedAttr($attrListIndex);
				}
			}
		}
		else
		{
			// If the node is in the list, load it and the specified
			// attribute, if there is one.
			// 
			// But first, if an attribute name is sent in and is not in the
			// attr list, add it.
			// 
			EEnewSelectedNode($nodeName);

			if (size($attrName) > 0)
			{
				int $attrListIndex;
				if (($attrListIndex = EEattrIsInList($attrName)) == -1)
				{
					textScrollList -edit -append $attrName EEattrList;
					$attrListIndex = `textScrollList -query -numberOfItems EEattrList`;
				}

				EEnewSelectedAttr($attrListIndex);
			}
		}
	}

	EEregisterExpressions();

}	// EEupdateWindow


//  ================ expressionEditor ================
//
//  SYNOPSIS
//      Create and show an expression editor text dialog.
//
//
global proc expressionEditor(string $particleMode, string $nodeName, string $attrName)
{
	global int $EEcurrentEditor;
	global int $EEexpressionType;
	global int $EEfilesLoaded;

	if (!$EEfilesLoaded)
	{
		source expressions.mel;
		source dynExpressions.mel;
		source expressionEdCallbacks.mel;
		source expressionEdTextEditor.mel;
		source scriptNodes.mel;

		$EEfilesLoaded = 1;
	}
	
	// Check that nodeName exists and attrName is valid.
	//
	if (size($nodeName) > 0)
	{
		if (!`objExists $nodeName`)
		{
			string $nameDoesNotExistFormat = (uiRes("m_expressionEditor.kNameDoesNotExist"));
			string $nameDoesNotExistStr = `format -stringArg $nodeName $nameDoesNotExistFormat`;
			warning $nameDoesNotExistStr;
			$nodeName = "";
			$attrName = "";
		}
	}
	else
	{
		// If there is no nodeName, make sure attrName is also blank.
		//
		$attrName = "";
	}

	if (size($nodeName) > 0 && size($attrName) > 0)
	{
		// If attrName is not an attribute for nodeName, don't use it.
		//
		if (size(`ls ($nodeName + "." + $attrName)`) == 0)
		{
			string $attrDoesNotExistFormat = (uiRes("m_expressionEditor.kAttrDoesNotExist"));
			string $attrDoesNotExistStr = `format -stringArg $attrName -stringArg $nodeName $attrDoesNotExistFormat`;
			warning $attrDoesNotExistStr;
			$attrName = "";
		}
		else
		{
			if (size($particleMode) == 0)
			{
				// If the attribute cannot be set in an expression, don't 
				// put it in the editor.
				//
				string $attrs[] = 
					`listAttr -scalar -multi -string $attrName $nodeName`;
				if (size($attrs) == 0)
				{
					string $attrCannotBeModifiedFormat = (uiRes("m_expressionEditor.kAttrCannotBeModified"));
					string $attrCannotBeModifiedStr = `format -stringArg $attrName $attrCannotBeModifiedFormat`;
					warning $attrCannotBeModifiedStr;
					$attrName = "";
				}
			}
		}
	}
    string  $EEWin = "expressionEditorWin";
	int $callListen = 0;

	if ($particleMode == "runtimeBeforeDynamics")
		$EEexpressionType = 1;
	else if ($particleMode == "runtimeAfterDynamics")
		$EEexpressionType = 2;
	else if ($particleMode == "creation")
		$EEexpressionType = 3;

	if ( `optionVar -exists EEexprEdTextEditor` )
		$EEcurrentEditor = `optionVar -query EEexprEdTextEditor`;

	if (size($nodeName) > 0 && 
		size($attrName) > 0 && 
		$EEcurrentEditor != 1)
	{
		if (EEisParticle($nodeName))
		{
			// Find out if the attribute is connected to a TdnExpression.
			// If it is, treat it like a non-particle attribute.
			//
			string $objAttr = $nodeName + "." + $attrName;

			if (EEisDynExpression($objAttr))
				EEonlyLaunchParticleEditor($nodeName, $attrName);
			else
				EEonlyLaunchEditor($nodeName, $attrName);
		}
		else if (EEisScriptNode($nodeName))
		{
			EEonlyLaunchScriptEditor($nodeName, $attrName);
		}
		else
		{
			EEonlyLaunchEditor($nodeName, $attrName);
		}
		return;
	}

    if (! `window -exists $EEWin`)
    {
        EEcreateWin($EEWin);
		$callListen = 1;
    }

	EEupdateWindow($nodeName, $attrName);

	// runtime before dynamics if $$EEexpressionType == 1
	// runtime after  dynamics if $$EEexpressionType == 2
	// creation                if $$EEexpressionType == 3
	radioButtonGrp -edit -select $EEexpressionType EErulesRBG;

	if ($callListen)
		expressionEditorListen();
	
	// Open/display the editor.
	//
	showWindow $EEWin;

}	// expressionEditor

