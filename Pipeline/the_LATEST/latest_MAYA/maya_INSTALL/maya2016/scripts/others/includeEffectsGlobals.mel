// Copyright (C) 1997-2014 Autodesk, Inc., and/or its licensors.
// All rights reserved.
//
// The coded instructions, statements, computer programs, and/or related
// material (collectively the "Data") in these files contain unpublished
// information proprietary to Autodesk, Inc. ("Autodesk") and/or its licensors,
// which is protected by U.S. and Canadian federal copyright law and by
// international treaties.
//
// The Data is provided for use exclusively by You. You have the right to use,
// modify, and incorporate this Data into other products for purposes authorized 
// by the Autodesk software license agreement, without fee.
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND. AUTODESK
// DOES NOT MAKE AND HEREBY DISCLAIMS ANY EXPRESS OR IMPLIED WARRANTIES
// INCLUDING, BUT NOT LIMITED TO, THE WARRANTIES OF NON-INFRINGEMENT,
// MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE, OR ARISING FROM A COURSE 
// OF DEALING, USAGE, OR TRADE PRACTICE. IN NO EVENT WILL AUTODESK AND/OR ITS
// LICENSORS BE LIABLE FOR ANY LOST REVENUES, DATA, OR PROFITS, OR SPECIAL,
// DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES, EVEN IF AUTODESK AND/OR ITS
// LICENSORS HAS BEEN ADVISED OF THE POSSIBILITY OR PROBABILITY OF SUCH DAMAGES.

global proc includeEffectsGlobals()
{
	//
	// This proc does not do anything.  Its purpose
	// is to force this script to be sourced only
	// if it needs to be.  By having the following
	// line at the top of the user's MEL script,
	// then all of these procs become available
	// to the script:
	//
	// includeEffectsGlobals();
	//
}

/////////////////////////////////////////////////////////////////////
//
// Array Procedures
//
/////////////////////////////////////////////////////////////////////

global proc string[] appendSingleToStringArray( string $base[], string $add )
//
// Description:
//
//    This proc appends a single item to an array.
//
{
	$base[size($base)] = $add;
	return $base;
}

global proc float[] appendSingleToFloatArray( float $base[], float $add )
//
// Description:
//
//    This proc appends a single item to an array.
//
{
	$base[size($base)] = $add;
	return $base;
}

global proc int[] appendSingleToIntArray( int $base[], int $add )
//
// Description:
//
//    This proc appends a single item to an array.
//
{
	$base[size($base)] = $add;
	return $base;
}

global proc vector[] appendSingleToVectorArray( vector $base[], vector $add )
//
// Description:
//
//    This proc appends a single item to an array.
//
{
	$base[size($base)] = $add;
	return $base;
}

global proc string[] appendArrayToStringArray( string $base[], string $add[] )
//
// Description:
//
//    This proc appends one array to another.
//
{
	int $i;
	for( $i = 0; $i < size($add); $i ++ )
	{
		$base[size($base)] = $add[$i];
	}

	return $base;
}

global proc float[] appendArrayToFloatArray( float $base[], float $add[] )
//
// Description:
//
//    This proc appends one array to another.
//
{
	int $i;
	for( $i = 0; $i < size($add); $i ++ )
	{
		$base[size($base)] = $add[$i];
	}

	return $base;
}

global proc vector[] appendArrayToVectorArray( vector $base[], vector $add[] )
//
// Description:
//
//    This proc appends one array to another.
//
{
	int $i;
	for( $i = 0; $i < size($add); $i ++ )
	{
		$base[size($base)] = $add[$i];
	}

	return $base;
}

global proc int[] appendArrayToIntArray( int $base[], int $add[] )
//
// Description:
//
//    This proc appends one array to another.
//
{
	int $i;
	for( $i = 0; $i < size($add); $i ++ )
	{
		$base[size($base)] = $add[$i];
	}

	return $base;
}

global proc int findInStringArray( string $value, string $array[] )
{
	int $i;
	for( $i = 0; $i < size( $array ); $i ++ )
	{
		if( $array[$i] == $value )
		{
			return $i;
		}
	}

	return -1;
}

global proc int indexInIntegerList( int $item, int $list[] )
//
// Searches for $item in $list and if found, returns its index.
// If item not found, returns -1;
{
	int $result = -1;
	int $j;

	for ( $j = size($list)-1; $j >= 0; $j-- )
	{
		if ( $item == $list[$j] )
		{
			$result = $j;
			break;
		}
	}
	return $result;
}


global proc int indexInList( string $item, string $list[] )
//
// Description:
//   If $item appears in $list, returns its index. Otherwise returns -1.
//
{
	int $result = -1;
	int $count = size($list);
	int $j;
	for ( $j = 0; $j < $count; $j++ )
	{
		if ( $item == $list[ $j ] )
		{
			$result = $j;
			break;
		}
	}
	return $result;
}


global proc string getUnexcludedItem( string $list[], string $excludedList[] )
//
// Description:
//  Return an item from $list which is NOT in $excludedList.
// If there is no such item, return an empty string.
// The routine does a linear search through the list of candidates and
// will always return the first eligible item.
{
	string $result = "";
	int $count = size($list);
	int $i;
	for ( $i = 0; $i < $count; $i++ )
	{
		if ( indexInList($list[$i], $excludedList) == -1 )
		{
			$result = $list[$i];
			break;
		}
	}
	return $result;
}



global proc string getUnexcludedIntegerItem( int $list[], int $excludedList[] )
//
// Description:
//  Return index of an item from $list which is NOT in $excludedList.
// If there is no such item, return -1. Note that we return an index, not the item itself.
// The routine does a linear search through the list of candidates and
// will always return the first eligible item.
{
	int $result = -1;
	int $count = size($list);
	int $i;
	for ( $i = 0; $i < $count; $i++ )
	{
		if ( indexInIntegerList($list[$i], $excludedList) == -1 )
		{
			$result = $i;
			break;
		}
	}
	return $result;
}


global proc string getMatchingItem( string $list[], string $matchList[] )
//
// Description:
//  Return an item from $list which is also in $excludedList.
// If there is no such item, return an empty string.
// The routine does a linear search through the list of candidates and
// will always return the first eligible item.
// This routine is the inverse of getUnexcludedItem.
{
	string $result = "";
	int $count = size($list);
	int $i;
	for ( $i = 0; $i < $count; $i++ )
	{
		if ( indexInList( $list[$i], $matchList ) >= 0 )
		{
			$result = $list[$i];
			break;
		}
	}
	return $result;
}

global proc string[] intersectSets( string $set1[], string $set2[] )
//
// Returns a string array holding all the lements which are in both 
// $set1 and $set2, i.e. the set intersection.
{
	string $result[];
	clear( $result );

	int $i;
	int $resultCount = 0;
	int $count1 = size( $set1 );
	for ($i = 0; $i < $count1; $i++)
	{
		// If this item is also in the other set, add it to the result
		//
		if (indexInList( $set1[$i], $set2 ) >= 0)
		{
			$result[ $resultCount++ ] = $set1[$i];
		}

	}
	return $result;
}

/////////////////////////////////////////////////////////////////////
//
// DAG Procedures
//
/////////////////////////////////////////////////////////////////////


global proc int objectIsEmpty( string $object )
//
// Description:
//   returns 1 if face count of $object is 0, false otherwise
{
	int $result = 0;

	int $faceCount[] = `polyEvaluate -face $object`;
	if ( $faceCount[0] == 0 )
		$result = 1;

	return $result;
}

global proc float boundingBoxVolume( string $object )
//
//  Determine the volume of the bounding box of the given object.
//
{
	float $volume = 0.0;

	if ( objectExists( $object ) )
	{
		// Get the bounding box of the object.
		//
		$bbAttr = $object + ".boundingBoxMin";
		$minBB  = `getAttr $bbAttr`;
		$bbAttr = $object + ".boundingBoxMax";
		$maxBB  = `getAttr $bbAttr`;

		// Determine the volume of the bounding box.
		//
		$volume = ($maxBB[0]-$minBB[0]) * ($maxBB[1]-$minBB[1]) * ($maxBB[2]-$minBB[2]);
	}

	return $volume;
}

global proc int objectExists( string $object )
{
	string $list[] = `ls $object`;

	if ( size($list) > 0 )
	{
		return true;
	}

	return false;
}



global proc string[] getShapesFromObjects( string $objects[], int $includeIntermediates )
//
// Description:
//
//    This procedure takes a list of objects, and returns all of the
// shapes at or below those object in the DAG.  If the $includeIntermediate
// argument is zero, then all intermediate objects will be skipped.
//
{
	string $result[];
	clear( $result );

	int $i;
	for( $i = 0; $i < size( $objects ); $i ++ )
	{
		string $shapes[] = getShapesFromObject( $objects[$i], $includeIntermediates );
		$result = appendArrayToStringArray( $result, $shapes );
	}

	return $result;
}

global proc string[] getShapesFromObject( string $object, int $includeIntermediates )
//
// Description:
//
//    This procedire will return all of the shapes at or below the
// given object in the DAG.  If the $includeIntermediate argument is
// zero, then all intermediate objects will be skipped.
//
{
	string $result[];
	clear( $result );

	string $dagObject[] = `ls -shapes $object`;
	//
	// If $object is already a shape then we can just return
	// the list of shapes with the same name.
	//
	if( size($dagObject) > 0 )
	{
		$result = $dagObject;
	}
	else
	//
	// Otherwise, we find all of the transforms that match the
	// name $object, and find all of the shapes beneath each
	// of them.
	//
	{
		string $transforms[] = `ls -type transform $object`;
		int $i;
		for( $i = 0; $i < size( $transforms ); $i ++ )
		{
			string $shapes[] = `ls -dag -shapes $transforms[$i]`;
			//
			// If we want intermediate objects as well, then we
			// do not need to filter this list.  We can just append
			// it to the current list of shapes.
			//
			if( $includeIntermediates == 1 )
			{
				$result = appendArrayToStringArray( $result, $shapes );
			}
			else
			//
			// If we do not want intermediate objects, then we only
			// append the anmes of shapes that are not intermediate.
			//
			{
				int $j;
				for( $j = 0; $j < size( $shapes ); $j ++ )
				{
					if( isObjectIntermediate( $shapes[$j] ) == 0 )
					{
						$result = appendSingleToStringArray( $result, $shapes[$j] );
					}
				}
			}
		}
	}

	return $result;
}

global proc string getShapeFromObject( string $object, int $whichShape, int $includeIntermediates )
//
// Description:
//
//    This procedure will get all of the shapes at and below
// the given object in the dag.  Then it will return the shape
// specified by the $whichShape argument.  If the
// $includeIntermediates argument is zero, then all intermediate
// shapes will be skipped.
//
{
	string $result = "";
	string $shapes[] = getShapesFromObject( $object, $includeIntermediates );

	if( $whichShape < size($shapes) )
	{
		$result = $shapes[$whichShape];
	}

	return $result;
}

global proc int isValidPolyObject( string $object )
{
	int $result = false;
	if (size($object) > 0)
	{
		string $tmp[] = `ls $object`;
		if (size($tmp[0]) > 0)
		{
			string $shapeName = getShapeFromObject( $object, 0, 0 );
			if (size($shapeName) > 0)
			{
				if (nodeType( $shapeName ) == "mesh")
					$result = true;
			}
		}
	}
	return $result;
}

global proc int isObjectVisible( string $object )
//
// Description:
//
//    This procedure examines the given object's path in the DAG
// and determines whether or not any part of the path is invisible.
// If it finds an invisible parent, then this object is also not visible,
// and it returnes 0.  If all of the parents are visible, and the object
// itself is visible, then the procedure returns 1.  If more than one
// object exists with the given name, then 1 is returned if ANY of them
// are visible.
//
{
	if( `objExists $object` == 0 )
	{
		return 0;
	}

	int $result = 0;
	string $fullPaths[] = `ls -long $object`;
	int $pathCount = size( $fullPaths );
	int $i;
	for( $i = 0; $i < $pathCount; $i ++ )
	{
		string $parents[];
		tokenize( $fullPaths[$i], "|", $parents );
		int $thisPathVisible = 1;
		int $j;
		string $thisPath = "";
		for( $j = 0; $j < size($parents); $j ++ )
		{
			$thisPath += ("|"+$parents[$j]);
			string $testPath = $thisPath;
			if( substring( $testPath, size($testPath)-1, size($testPath) ) == "->" )
			{
				$testPath = substring( $testPath, 1,  size($testPath)-2 );
			}
			int $vis = `getAttr ($testPath+".visibility")`;
			if( $vis == 0 )
			{
				$thisPathVisible = 0;
				break;
			}
		}

		if( $thisPathVisible == 1 )
		{
			$result = 1;
		}
	}

	return $result;
}

global proc int isObjectIntermediate( string $object )
//
// Description:
//
//    This procedure examines the given object's path in the DAG
// and determines whether or not any part of the path is intermediate.
// If it finds an intermediate parent, then this object is also intermediate,
// and it returnes 1.  If none of the parents are intermediate, and the object
// itself is not intermediate, then the procedure returns 0.  If more than one
// object exists with the given name, then 1 is returned if ANY of them
// are intermediate.
//
{
	if( `objExists $object` == 0 )
	{
		return 0;
	}

	int $result = 0;
	string $fullPaths[] = `ls -long $object`;
	int $pathCount = size( $fullPaths );
	int $i;
	for( $i = 0; $i < $pathCount; $i ++ )
	{
		string $parents[];
		tokenize( $fullPaths[$i], "|", $parents );
		int $thisPathIntermediate = 0;
		int $j;
		string $thisPath = "";
		for( $j = 0; $j < size($parents); $j ++ )
		{
			$thisPath += ("|"+$parents[$j]);
			string $testPath = $thisPath;
			if( substring( $testPath, size($testPath)-1, size($testPath) ) == "->" )
			{
				$testPath = substring( $testPath, 1,  size($testPath)-2 );
			}
			int $int = `getAttr ($testPath+".intermediateObject")`;
			if( $int == 1 )
			{
				$thisPathIntermediate = 1;
				break;
			}
		}

		if( $thisPathIntermediate == 1 )
		{
			$result = 1;
		}
	}

	return $result;
}

global proc int isObjectTemplated( string $object )
//
// Description:
//
//    This procedure examines the given object's path in the DAG
// and determines whether or not any part of the path is templated.
// If it finds a templated parent, then this object is also templated,
// and it returnes 1.  If none of the parents are templated, and the object
// itself is not templated, then the procedure returns 0.  If more than one
// object exists with the given name, then 1 is returned if ANY of them
// are templated.
//
{
	if( `objExists $object` == 0 )
	{
		return 0;
	}

	int $result = 0;
	string $fullPaths[] = `ls -long $object`;
	int $pathCount = size( $fullPaths );
	int $i;
	for( $i = 0; $i < $pathCount; $i ++ )
	{
		string $parents[];
		tokenize( $fullPaths[$i], "|", $parents );
		int $thisPathTemplated = 0;
		int $j;
		string $thisPath = "";
		for( $j = 0; $j < size($parents); $j ++ )
		{
			$thisPath += ("|"+$parents[$j]);
			string $testPath = $thisPath;
			if( substring( $testPath, size($testPath)-1, size($testPath) ) == "->" )
			{
				$testPath = substring( $testPath, 1,  size($testPath)-2 );
			}
			int $temp = `getAttr ($testPath+".template")`;
			if( $temp == 1 )
			{
				$thisPathTemplated = 1;
				break;
			}
		}

		if( $thisPathTemplated == 1 )
		{
			$result = 1;
		}
	}

	return $result;
}

global proc int isObjectInUnderWorld( string $object )
//
// Description:
//
//    This procedure checks to see if the given object is in the
// underworld of some other object in the scene.  This is done
// by looking for the underworld path symbol "->" in the full path
// of the object.  For now, this is the only way that I know how
// to check this.
//
{
	if( `objExists $object` == 0 )
	{
		return 0;
	}

	string $fullPaths[] = `ls -long $object`;
	string $match = match( "->", $fullPaths[0] );
	if( $match == "->" )
	{
		return 1;
	}
	else
	{
		return 0;
	}
}

/////////////////////////////////////////////////////////////////////
//
// Object Procedures
//
/////////////////////////////////////////////////////////////////////

global proc string createDecomposeMatrixNode()
//
// Description:
//		This procedure will load a plug-in, matrixNodes.so, and then
// create a decomposeMatrix node of the plug-in. loadPlugin may issue
// a warning if the plug-in has already been loaded. Any such warning
// may be safely ignored.
//
{
	string $node = "";

	// Load plugin matrixNodes.so, then create a plugin node.
	//
	if( `pluginInfo -query -loaded matrixNodes` == 0 )
	{
		if( catch(`loadPlugin -quiet "matrixNodes"`) )
		{
			error( (uiRes("m_includeEffectsGlobals.kCantLoadPlugin")) );
			return $node;
		}
	}

	// Create a decomposeMatrix node.
	//
	$node = `createNode decomposeMatrix`;

	return $node;
}


global proc string superDuplicateCurve( string $curve )
//
// Description:
//
//    This procedure duplicates the given curve in such a way that
// ALL phsical modifications to the original curve are pass on to
// the duplicate curve.  The only changes that are not passed on
// are changes to the number of spans and the degree.  Therefore,
// using the addToCurve tool will not also add new CV's to the
// duplicated curve.
//
{
	string $result = "";
	if( `objExists $curve` == 0 )
	{
		string $fmt = (uiRes("m_includeEffectsGlobals.kNoObject"));
		error( `format -s $curve $fmt` );
		return $result;
	}

	string $curveShape = getShapeFromObject( $curve, 0, 0 );
	if( $curveShape == "" )
	{
		string $fmt = (uiRes("m_includeEffectsGlobals.kNoShape"));
		error( `format -s $curve $fmt` );
		return $result;
	}

	if( `objectType $curveShape` != "nurbsCurve" )
	{
		string $fmt = (uiRes("m_includeEffectsGlobals.kNoCurve"));
		error( `format -s $curve $fmt` );
		return "";
	}

	//
	// If the original object is in the underworld, then
	// display an error message and return.  This effect
	// will not work on underworld objects, because their
	// topology changes as they move on the parent object.
	// This effect cannot handle changing topology, since
	// direct connections are made.
	//
	if( isObjectInUnderWorld( $curveShape ) == 1 )
	{
		string $fmt = (uiRes("m_includeEffectsGlobals.kCurveUnderworld"));
		error( `format -s $curve $fmt` );
		return "";
	}

	// create a plugin node: decomposeMatrix.
	//
	string $dMatrix = createDecomposeMatrixNode();
	if( `objectType $dMatrix` != "decomposeMatrix" )
	{
		error( (uiRes("m_includeEffectsGlobals.kCantCreateNode")) );
		return "";
	}

	//
	// First, we duplicate the original curve, without
	// keeping the construction history.  We rename
	// this new curve so that it is identified.
	//
	string $dups[] = `duplicateCurve -ch 0 $curveShape`;
	string $dup = $dups[0];
	select $dup;
	rename "superDuplicatedCurve1";
	$dups = `ls -sl`;
	$dup = $dups[0];

	string $dupShape = getShapeFromObject( $dup, 0, 0 );

	// Connect oringinal curve shape with duplicated one.
	//
	string $from = ($curveShape+".local");
	string $to = ($dupShape+".create");
	connectAttr -f $from $to;

	// Connect oringinal surface shape with decomposeMatrix node.
	//
	$from = ($curveShape+".worldMatrix[0]");
	$to = ($dMatrix+".inputMatrix");
	connectAttr -f $from $to;

	// Connect decomposeMatrix node with duplicated surface shape.
	//
	$from = ($dMatrix+".outputTranslate");
	$to = ($dup+".translate");
	connectAttr -f $from $to;

	$from = ($dMatrix+".outputRotate");
	$to = ($dup+".rotate");
	connectAttr -f $from $to;

	$from = ($dMatrix+".outputScale");
	$to = ($dup+".scale");
	connectAttr -f $from $to;

	$from = ($dMatrix+".outputShear");
	$to = ($dup+".shear");
	connectAttr -f $from $to;

	$result = $dup;
	select $result;
	return $result;
}


global proc string superDuplicateSurface( string $surface )
//
// Description:
//
//    This procedure duplicates the given surface in such a way that
// all phsical modifications to the original one are pass on to
// the duplicate one.  The only changes that are not passed on
// are changes to the number of spans and the degree.
//
{
	string $result = "";
	if( `objExists $surface` == 0 )
	{
		error( `format -s $surface (uiRes("m_includeEffectsGlobals.kNoObject"))` );
		return $result;
	}

	string $surfaceShape = getShapeFromObject( $surface, 0, 0 );
	if( $surfaceShape == "" )
	{
		error( `format -s $surface (uiRes("m_includeEffectsGlobals.kNoShape"))` );
		return $result;
	}

	if( `objectType $surfaceShape` != "nurbsSurface" )
	{
		error( `format -s $surface (uiRes("m_includeEffectsGlobals.kNoCurve"))` );
		return $result;
	}

	// create a plugin node: decomposeMatrix.
	//
	string $dMatrix = createDecomposeMatrixNode();
	if( `objectType $dMatrix` != "decomposeMatrix" )
	{
		error( uiRes("m_includeEffectsGlobals.kCantCreateNode") );
		return "";
	}

	// First, we duplicate original surface, without keeping the construction
	// history. We rename this new nurbs surface so that it can be identified.
	//
	string $dups[] = `duplicate -name "superDuplicatedSurface" $surfaceShape`;
	string $dup = $dups[0];
	string $dupShape = getShapeFromObject( $dup, 0, 0 );

	// Connect oringinal surface shape with duplicated one.
	//
	string $from = ($surfaceShape+".local");
	string $to = ($dupShape+".create");
	connectAttr -f $from $to;

	// Connect oringinal surface shape with decomposeMatrix node.
	//
	$from = ($surfaceShape+".worldMatrix[0]");
	$to = ($dMatrix+".inputMatrix");
	connectAttr -f $from $to;

	// Connect decomposeMatrix node with duplicated surface shape.
	//
	$from = ($dMatrix+".outputTranslate");
	$to = ($dup+".translate");
	connectAttr -f $from $to;

	$from = ($dMatrix+".outputRotate");
	$to = ($dup+".rotate");
	connectAttr -f $from $to;

	$from = ($dMatrix+".outputScale");
	$to = ($dup+".scale");
	connectAttr -f $from $to;

	$from = ($dMatrix+".outputShear");
	$to = ($dup+".shear");
	connectAttr -f $from $to;

	$result = $dup;
	select $result;
	return $result;
}

global proc string getUniqueAttrName( string $object, string $attrName )
{
	string $uniqueAttr = $attrName;

	if( `objExists $object` == 0 )
	{
		return "";
	}

	if( $attrName == "" )
	{
		return "";
	}

	string $pieces[];
	clear $pieces;

	int $pieceCount = tokenize( $attrName, "#", $pieces);
	if( $pieceCount == 0 )
	{
		return "";
	}
	else if( $pieceCount == 1 )
	{
		if( substring( $attrName, size($attrName), size($attrName ) ) != "#" ) 
		{
			if( `attributeQuery -node $object -exists $pieces[0]` == 0 )
			{
				return $pieces[0];
			}
		}
	}

	int $currentValue = 1;
	int $done = 0;
	while( $done == 0 )
	{
		string $testString = "";
		int $i;
		for( $i = 0; $i < $pieceCount; $i ++ )
		{
			$testString += $pieces[$i];
			if( $i == 0 )
			{
				$testString += $currentValue;
			}
		}

		if( `attributeQuery -node $object -exists $testString` == 0 )
		{
			$done = 1;
			$uniqueAttr = $testString;
		}

		$currentValue ++;
	}

	return $uniqueAttr;
}

global proc string addMarkingAttribute( string $object, string $attrName, int $multi )
{
	if( `objExists $object` == 0 )
	{
		string $fmt = (uiRes("m_includeEffectsGlobals.kObjectInexistant"));
		error( `format -s $object $fmt` );
	}

	string $newName = getUniqueAttrName( $object, $attrName );
	if( $multi == 0 )
		addAttr -at message -ln $newName $object;
	else
		addAttr -at message -multi -indexMatters 0 -ln $newName $object;

	return $newName;
}

global proc string markObjectWithAttribute( string $markedObject, string $markingObject, string $attribute )
{
	if( `objExists $markedObject` == 0 )
	{
		string $fmt = (uiRes("m_includeEffectsGlobals.kCantMark"));
		warning( `format -s $markedObject $fmt` );
		return "";
	}

	if( `objExists $markingObject` == 0 )
	{
		string $fmt = (uiRes("m_includeEffectsGlobals.kCantUse"));
		warning( `format -s $markingObject -s $markedObject $fmt` );
		return "";
	}

	if( `attributeQuery -node $markingObject -exists $attribute` == 0 )
	{
		// warning("Attribute, \""+$attribute+"\", does not exist, adding it as non-multi to \""+$markingObject+"\".");
		$attribute = addMarkingAttribute( $markingObject, $attribute, 0 );
	}

	if( `attributeQuery -node $markingObject -multi $attribute` == 1 )
	{
		connectAttr -nextAvailable ($markedObject+".message") ($markingObject+"."+$attribute);
	}
	else
	{
		connectAttr -f ($markedObject+".message") ($markingObject+"."+$attribute);
	}

	return $attribute;
}

global proc string[] getMarkedObjects( string $object, string $attribute )
{
	string $result[];
	clear( $result );

	if( `objExists $object` == 0 )
	{
		string $fmt = (uiRes("m_includeEffectsGlobals.kObjInexistant"));
		warning( `format -s $object $fmt` );
		return $result;
	}

	if( `attributeQuery -node $object -exists $attribute` == 0 )
	{
		string $fmt = (uiRes("m_includeEffectsGlobals.kAttrInexistant"));
		warning( `format -s $object -s $attribute $fmt` );
		return $result;
	}

	$result = `listConnections -shapes true -source true -destination false ($object+"."+$attribute)`;
	return $result;
}

/////////////////////////////////////////////////////////////////////
//
// Selection Procedures
//
/////////////////////////////////////////////////////////////////////

global proc string[] getSelectedList( string $type )
//
// Description:
//
//    This procedure will return the objects from the
// selection list filtered by the string passed in.
// Currently, this procedure does not return any
// components selected.
//
{
	string $selection[];
	clear( $selection );
	if( $type == "all" )
	{
		$selection = `ls -objectsOnly -sl`;
	}
	else if( $type == "shapes" )
	{
		$selection = `ls -objectsOnly -shapes -sl`;
	}
	else if( $type == "transforms" )
	{
		$selection = `ls -objectsOnly -transforms -sl`;
	}
	else if( $type == "allShapes" )
	//
	// This option will return all of the shapes at or
	// under the selected objects in the DAG.
	//
	{
		$selection = `ls -objectsOnly -dag -shapes -sl`;
	}
	else if( $type == "geometry" )
	//
	// This option will return all of the geometry shapes
	// that are currently selected.
	//
	{
		$selection = `ls -objectsOnly -geometry -sl`;
	}
	else if( $type == "allGeometry" )
	//
	// This option will return all of the geometry shapes
	// at or under the selected objects in the DAG.
	//
	{
		$selection = `ls -objectsOnly -dag -allPaths -geometry -sl`;
	}
	else if( $type == "allPolys" )
	//
	// This option will return all of the polygonal shapes
	// at or under the selected objects in the DAG.
	//
	{
		$selection = `ls -objectsOnly -dag -allPaths -geometry -type mesh -sl`;
	}
	else if( $type == "allNurbs" )
	//
	// This option will return all of the nurbs surface shapes
	// at or under the selected objects in the DAG.
	//
	{
		$selection = `ls -objectsOnly -dag -allPaths -geometry -type nurbsSurface -sl`;
	}
	else if( $type == "allCurves" )
	//
	// This option will return all of the nurbs curves shapes
	// at or under the selected objects in the DAG.
	//
	{
		$selection = `ls -objectsOnly -dag -allPaths -geometry -type nurbsCurve -sl`;
	}
	else
	//
	// This option lets that calling procedure or script specify the
	// type of selected objects to return.
	//
	{
		$selection = `ls -type $type -sl`;
	}

	return $selection;
}

global proc string getSelectedObject( int $whichOne )
{
	string $sl[] = `ls -sl`;
	int $s = size( $sl );
	if( $whichOne >= $s )
	{
		return "";
	}

	return $sl[$whichOne];
}

/////////////////////////////////////////////////////////////////////
//
// String Procedures
//
/////////////////////////////////////////////////////////////////////

global proc string removeStartAndEndWhiteSpace( string $in )
//
// Description:
//
//    This proc removes any spaces, tabs, or newlines from the start and
// end of a string.  Then the resulting string is returned.
//
{
	if( size( $in ) == 0 )
		return $in;

	//
	// First remove all white space from the beginning of
	// the string.
	//
	while( ( substring( $in, 1, 1 ) == " " ) ||
			( substring( $in, 1, 1 ) == "\t" ) ||
			( substring( $in, 1, 1 ) == "\n" ) )
	{
		$in = substring( $in, 2, size($in) );
	}

	//
	// Now remove all white space from the end of the string.
	//
	while( ( substring( $in, size($in), size($in) ) == " " ) ||
			( substring( $in, size($in), size($in) ) == "\t" ) ||
			( substring( $in, size($in), size($in) ) == "\n" ) )
	{
		$in = substring( $in, 1, size($in) - 1 );
	}

	return $in;
}

global proc string removeAllWhiteSpace( string $in )
//
// Description:
//
//    This procedire removes all spaces, tabs, and newlines from
// the given string.  The result is returned.
//
{
	//
	// First we remove all of the spaces from the string.
	//
	string $last = $in;
	string $out = substitute( " ", $last, "" );
	while( $last != $out )
	{
		$last = $out;
		$out = substitute( " ", $last, "" );
	}

	//
	// Then we remove all of the tabs from the string.
	//
	$last = $out;
	$out = substitute( "\t", $last, "" );
	while( $last != $out )
	{
		$last = $out;
		$out = substitute( "\t", $last, "" );
	}

	//
	// Now we remove all of the newlines from the string.
	//
	$last = $out;
	$out = substitute( "\n", $last, "" );
	while( $last != $out )
	{
		$last = $out;
		$out = substitute( "\n", $last, "" );
	}

	return $out;
}

global proc lockTranslation( string $group )
{
	setAttr -lock 1 ($group+".translateX");
	setAttr -lock 1 ($group+".translateY");
	setAttr -lock 1 ($group+".translateZ");
	setAttr -keyable 0 ($group+".translateX");
	setAttr -keyable 0 ($group+".translateY");
	setAttr -keyable 0 ($group+".translateZ");
}

global proc unlockTranslation( string $group )
{
	setAttr -lock 0 ($group+".translateX");
	setAttr -lock 0 ($group+".translateY");
	setAttr -lock 0 ($group+".translateZ");
	setAttr -keyable 1 ($group+".translateX");
	setAttr -keyable 1 ($group+".translateY");
	setAttr -keyable 1 ($group+".translateZ");
}

global proc lockRotation( string $group )
{
	setAttr -lock 1 ($group+".rotateX");
	setAttr -lock 1 ($group+".rotateY");
	setAttr -lock 1 ($group+".rotateZ");
	setAttr -keyable 0 ($group+".rotateX");
	setAttr -keyable 0 ($group+".rotateY");
	setAttr -keyable 0 ($group+".rotateZ");
}

global proc unlockRotation( string $group )
{
	setAttr -lock 0 ($group+".rotateX");
	setAttr -lock 0 ($group+".rotateY");
	setAttr -lock 0 ($group+".rotateZ");
	setAttr -keyable 1 ($group+".rotateX");
	setAttr -keyable 1 ($group+".rotateY");
	setAttr -keyable 1 ($group+".rotateZ");
}

global proc lockScale( string $group )
{
	setAttr -lock 1 ($group+".scaleX");
	setAttr -lock 1 ($group+".scaleY");
	setAttr -lock 1 ($group+".scaleZ");
	setAttr -keyable 0 ($group+".scaleX");
	setAttr -keyable 0 ($group+".scaleY");
	setAttr -keyable 0 ($group+".scaleZ");
}

global proc unlockScale( string $group )
{
	setAttr -lock 0 ($group+".scaleX");
	setAttr -lock 0 ($group+".scaleY");
	setAttr -lock 0 ($group+".scaleZ");
	setAttr -keyable 1 ($group+".scaleX");
	setAttr -keyable 1 ($group+".scaleY");
	setAttr -keyable 1 ($group+".scaleZ");
}

global proc lockShear( string $group )
{
	setAttr -lock 1 ($group+".shearXY");
	setAttr -lock 1 ($group+".shearXZ");
	setAttr -lock 1 ($group+".shearYZ");
	setAttr -keyable 0 ($group+".shearXY");
	setAttr -keyable 0 ($group+".shearXZ");
	setAttr -keyable 0 ($group+".shearYZ");
}

global proc unlockShear( string $group )
{
	setAttr -lock 0 ($group+".shearXY");
	setAttr -lock 0 ($group+".shearXZ");
	setAttr -lock 0 ($group+".shearYZ");
	setAttr -keyable 1 ($group+".shearXY");
	setAttr -keyable 1 ($group+".shearXZ");
	setAttr -keyable 1 ($group+".shearYZ");
}

global proc lockTransformations( string $group )
{
	lockTranslation( $group );
	lockRotation( $group );
	lockScale( $group );
	lockShear( $group );
}

global proc unlockTransformations( string $group )
{
	unlockTranslation( $group );
	unlockRotation( $group );
	unlockScale( $group );
	unlockShear( $group );
}


/////////////////////////////////////////////////////////////////////
//
// Debugging Procedures
//
/////////////////////////////////////////////////////////////////////


global proc debugPrintIntegerArray( string $label, int $list[] )
{
	print( $label );
	int $j;

	for ( $j = 0; $j < size($list); $j++ )
	{
		print( $list[$j] + " " );
	}
	print("\n");
}

global proc debugPrintStringArray( string $label, string $list[] )
{
	print( $label );
	int $j;

	for ( $j = 0; $j < size($list); $j++ )
	{
		print( $list[$j] + " " );
	}
	print("\n");
}

global proc saveEffectStateToFile( string $fileName )
//
// Saves the current state of the effect to a binary file called $fileName.mb.
// Renames the current scene to this name.
{
	string $fmt = (uiRes("m_includeEffectsGlobals.kSavingScene"));
	print( `format -s $fileName $fmt` );
	file -rename $fileName;
	file -f -save -type "mayaBinary";
}

global proc breakExecution( string $out )
//
// Breaks execution by introducing an intentional runtime error.
// First, outputs string $out.  This is like a breakpoint, exept you cannot continue from it.
{
	string $fmt = (uiRes("m_includeEffectsGlobals.kBreakingExecution"));
	print( `format -s $out $fmt` );
	string $foo = `ls`;	
}

