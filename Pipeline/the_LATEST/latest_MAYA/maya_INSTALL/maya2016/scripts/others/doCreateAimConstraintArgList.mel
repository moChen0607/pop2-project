// Copyright (C) 1997-2014 Autodesk, Inc., and/or its licensors.
// All rights reserved.
//
// The coded instructions, statements, computer programs, and/or related
// material (collectively the "Data") in these files contain unpublished
// information proprietary to Autodesk, Inc. ("Autodesk") and/or its licensors,
// which is protected by U.S. and Canadian federal copyright law and by
// international treaties.
//
// The Data is provided for use exclusively by You. You have the right to use,
// modify, and incorporate this Data into other products for purposes authorized 
// by the Autodesk software license agreement, without fee.
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND. AUTODESK
// DOES NOT MAKE AND HEREBY DISCLAIMS ANY EXPRESS OR IMPLIED WARRANTIES
// INCLUDING, BUT NOT LIMITED TO, THE WARRANTIES OF NON-INFRINGEMENT,
// MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE, OR ARISING FROM A COURSE 
// OF DEALING, USAGE, OR TRADE PRACTICE. IN NO EVENT WILL AUTODESK AND/OR ITS
// LICENSORS BE LIABLE FOR ANY LOST REVENUES, DATA, OR PROFITS, OR SPECIAL,
// DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES, EVEN IF AUTODESK AND/OR ITS
// LICENSORS HAS BEEN ADVISED OF THE POSSIBILITY OR PROBABILITY OF SUCH DAMAGES.

//
//	Procedure Name:
//		doCreateAimConstraintArgList
//
//	Description:
//		Create a Aim constraint
//
//	Input Arguments:
//	$version: The version of this option box.  Used to know how to 
//	interpret the $args array.
//		"1" : first verison of shot creation command
//  
//	$args
//	Version 1
//	[0]		$maintainOffset : whether to maintain offset
//	[1]		$rx				: if maintain offset is off, the x value of rotation component
//	[2]		$ry				: if maintain offset is off, the y value of rotation component
//	[3]		$rz				: if maintain offset is off, the z value of rotation component
//	[4]		$aimVectorX		: x component of the aim vector
//	[5]		$aimVectorY		: y component of the aim vector
//	[6]		$aimVectorZ		: z component of the aim vector
//	[7]		$upVectorX		: x component of the up vector
//	[8]		$upVectorY		: y component of the up vector
//	[9]		$upVectorZ		: z component of the up vector
//	[10]	$worldUpVectorX		: x component of the world up vector
//	[11]	$worldUpVectorY		: y component of the world up vector
//	[12]	$worldUpVectorZ		: z component of the world up vector
//	[13]	$weight		: the weight to use for the Aim constraint
//	[14]	$worldUpType	: string indicating the world up type
//	[15]	$worldUpObject	: if worldUpType is "object" then provide the name of the world up object
//	[16]	$axisX			: if true to skip constraining on X axis
//	[17]	$axisY			: if true to skip constraining on Y axis
//	[18]	$axisZ			: if true to skip constraining on Z axis
//  [19]	$animLayer		: if a layer is specified, the anim layer to put this constraint on.
//  [20]	$overrideMode	: whether to set the layer to override mode.

//
//	Return Value:
//		none
//

global proc
doCreateAimConstraintArgList( string $version, string $args[] )
{
	
	if( $version == 1 && size($args) != 21 )
	{
		print (uiRes("m_doCreateAimConstraintArgList.kAimConstraintArgListWrongLength"));

		return;
	}	
	
	float $aimVector[];
	float $upVector[];
	float $worldUpVector[];
	
	
	int $maintainOffset = $args[0];
	float $rx = $args[1];
	float $ry = $args[2];
	float $rz = $args[3];		
	$aimVector[0] = $args[4];
	$aimVector[1] = $args[5];
	$aimVector[2] = $args[6];
	$upVector[0] = $args[7];
	$upVector[1] = $args[8];
	$upVector[2] = $args[9];
	$worldUpVector[0] = $args[10];
	$worldUpVector[1] = $args[11];
	$worldUpVector[2] = $args[12];
	float $weight = $args[13];
	string $worldUpType = $args[14];
	string $worldUpObject = $args[15];	
	int $axisX = $args[16];
	int $axisY = $args[17];
	int $axisZ = $args[18];	
	string $animLayer = $args[19];
	int $overrideMode = $args[20];
	
	string $cmd = "aimConstraint";
	

	if ($maintainOffset) {
		$cmd = ($cmd + " -mo");
	} else {
		//	rotation offset values
		//		
		$cmd = ($cmd + " -offset " + $rx + " " + $ry + " " + $rz );
	}		

	$cmd = ($cmd 
			+ " -weight " + $weight
			+ " -aimVector " 
			+ $aimVector[0] + " " + $aimVector[1] + " " + $aimVector[2]
			+ " -upVector " 
			+ $upVector[0] + " " + $upVector[1] + " " + $upVector[2]
		);

	// world up related options
		
	$cmd = ($cmd  + " -worldUpType " + "\"" + $worldUpType + "\"" );
	switch ( $worldUpType )
	{
	case "scene":
	case "none":
		break;
	case "object":
		
		$cmd = ($cmd  + " -worldUpObject " + $worldUpObject);
		break;
	case "objectrotation":		
		$cmd = ($cmd  + " -worldUpVector " 
				+ $worldUpVector[0] + " "
				+ $worldUpVector[1] + " "
				+ $worldUpVector[2]);		
		$cmd = ($cmd  + " -worldUpObject " + $worldUpObject);
		break;
	case "vector":		
		$cmd = ($cmd  + " -worldUpVector " 
				+ $worldUpVector[0] + " "
				+ $worldUpVector[1] + " "
				+ $worldUpVector[2]);
		break;
	}

	// AnimLayer    
	if( size($animLayer)>0 && size(`ls -type animLayer $animLayer`) > 0 )
	{
		if(!askUserIfLayerModeChangeIsOK($animLayer,$overrideMode))
			return;
		
		if($overrideMode)
		{
			animLayer -e -override 1 $animLayer;
		}
		else
		{
			animLayer -e -override 0 $animLayer;
		}
		
		$cmd = ($cmd + " -layer " + $animLayer );		
	}

	// Axis values
	//

	// The axis values are inverted so that they represent
	// which axes to *skip* as opposed to which axes are on.	
	// If any of these values is true, that means that one
	// or more axes are to be skipped.
	if ($axisX)
		$cmd = ($cmd + " -skip x");
	if ($axisY)
		$cmd = ($cmd + " -skip y");
	if ($axisZ)
		$cmd = ($cmd + " -skip z");
		
	evalEcho($cmd);	
			
}
