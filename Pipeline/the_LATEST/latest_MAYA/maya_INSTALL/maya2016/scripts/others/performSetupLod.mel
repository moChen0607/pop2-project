// Copyright (C) 1997-2014 Autodesk, Inc., and/or its licensors.
// All rights reserved.
//
// The coded instructions, statements, computer programs, and/or related
// material (collectively the "Data") in these files contain unpublished
// information proprietary to Autodesk, Inc. ("Autodesk") and/or its licensors,
// which is protected by U.S. and Canadian federal copyright law and by
// international treaties.
//
// The Data is provided for use exclusively by You. You have the right to use,
// modify, and incorporate this Data into other products for purposes authorized 
// by the Autodesk software license agreement, without fee.
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND. AUTODESK
// DOES NOT MAKE AND HEREBY DISCLAIMS ANY EXPRESS OR IMPLIED WARRANTIES
// INCLUDING, BUT NOT LIMITED TO, THE WARRANTIES OF NON-INFRINGEMENT,
// MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE, OR ARISING FROM A COURSE 
// OF DEALING, USAGE, OR TRADE PRACTICE. IN NO EVENT WILL AUTODESK AND/OR ITS
// LICENSORS BE LIABLE FOR ANY LOST REVENUES, DATA, OR PROFITS, OR SPECIAL,
// DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES, EVEN IF AUTODESK AND/OR ITS
// LICENSORS HAS BEEN ADVISED OF THE POSSIBILITY OR PROBABILITY OF SUCH DAMAGES.

proc int isAlreadyConnected( string $transforms[] ) 
{
	// Returns 1 if one of the transforms has lodVisibility attribute
	// already connected to.  Otherwise, returns 0.
	//
	int $numTransforms = size($transforms);

	int $i;
	for( $i = 0; $i < $numTransforms; $i++ ) {
		if( `connectionInfo -id ($transforms[$i] + ".lodVisibility")` > 0 ) {
			return 1;
		}
	}

	return 0;
}

global proc string[] performSetupLod()
//
//	Description:
//		This script sets up a "lod" node and connects a 
//		camera with initial threshold values based on the current
//		camera distance.  Threshold values are chosen such that
//		the middle level is first displayed.
//
//		The user must select:
//			1. zero or one camera. If zero, the current camera is taken
//			2. at least 1 transform as lod Level
//				The transforms must be selected in
//				order: highest to lowest resolution.
//
{
	int $errors = 0;
	string $result[];
	string $lodGroup;

	//-------------------------------------------------------
	// Parse the selected objects: camera + transforms or group
	//-------------------------------------------------------

	// Get list of selected dag objects
	//
	string $sel[] = `ls -sl -tr`;

	// Check at least something has been selected
	int $numSelectedItems = size($sel);
	if($numSelectedItems < 1) {
	    error( (uiRes("m_performSetupLod.kSelectAtLeastOne")));
		return $result;
	}

	int $numTransforms = 0;

	// get the camera. If none selected, use the currently active camera
	//
	string $selShapes[] = `listRelatives -s $sel`;
	string $camerasSh[] = `ls -ca $selShapes`;
	string $camera;
	if( size($camerasSh) == 0 ) {
	    // get current camera
		$camera = `lookThru -q`;
		$numTransforms = $numSelectedItems;
	} else if( size($camerasSh) == 1 ) {
	    string $cameras[] = `listRelatives -parent $camerasSh[0]`;
		$camera = $cameras[0];
		$numTransforms = $numSelectedItems - 1;
	} else if( size($camerasSh) > 1 ) {
		error( (uiRes("m_performSetupLod.kSelectOnlyOneCamera")));
		return $result;
	}

	// If the camera is orthographic, store its view vector
	//
	int $isOrtho = `getAttr ($camera + ".orthographic")`;
	float $viewVector[] = nurbsViewDirectionVector( 1 );

	string $transforms[];
	string $groupName = ""; // the group object containing all the transforms

	// make sure the camera is not the only thing selected
	if($numTransforms < 1) {
	    error( (uiRes("m_performSetupLod.kSelectTransformAndCamera")));
		return $result;
	}

	// User has selected more than one transform besides the camera. 
	// Treat each separately from a list of the transforms, and check 
	// none of them are currently grouped. If any are grouped, display
	// error message and abort.
	int $numTr = 0;
	for($i=0; $i<$numSelectedItems; $i++) {
		if($sel[$i] != $camera) {
			$transforms[$numTr++] = $sel[$i];
			string $relatives[] = `listRelatives -parent $sel[$i]`;
			if(size($relatives) > 0) {
				string $errFormat = (uiRes("m_performSetupLod.kHasParent"));
				string $errMsg = `format -stringArg	$sel[$i] $errFormat`;
				error $errMsg;
				return $result;
			}
		}
	}
	
	// check that transforms aren't already connected under an lod group
	if( isAlreadyConnected($transforms) > 0 ) {
		error( (uiRes("m_performSetupLod.kSomeTransformsChildrenOfGroup")));
		return $result;
	}
	
	// create new transform group here and add the transforms as children
	$lodGroup = `createNode -n "lodGroup#" lodGroup`;
	parent $transforms $lodGroup;
	
	if( $isOrtho ) {
		// connect the camera's orthographic width to the lod group.
		// The lod group takes a matrix that indicates how far away the
		// camera is from the lod group.  In the case of an ortho camera,
		// the matrix has a translate value that is a function of 
		// the camera's orthographic width.
		//
		// The translate value is found by:
		//  translate =  (def. camera dist)*(ortho width)/(def. ortho width);
		//  default camera distance is 100 (along the view vector)
		//  default orthographic width is 30
		// So a factor of 3.3333 is applied with the "multDoubleLinear"node

		string $matrixNode = `createNode fourByFourMatrix`; 
		string $multNode = `createNode multDoubleLinear`;
		connectAttr ($matrixNode + ".output") ($lodGroup + ".cameraMatrix");
		setAttr ($multNode + ".input2") 3.3333;

		if( ($viewVector[2] > $viewVector[0]) &&
			($viewVector[2] > $viewVector[1])) {
			// For front camera, whose view vector is in the Z direction,
			// use the camera's ortho width to set the "translate Z" value
			// in the matrix.
			//
			connectAttr ($multNode + ".output") ($matrixNode + ".i32");
			connectAttr ($camera + ".orthographicWidth") 
				($multNode + ".input1");

		} else if( ($viewVector[1] > $viewVector[0]) &&
				  ($viewVector[1] > $viewVector[2])) {
			// For top camera, whose view vector is in the Y direction,
			// use the camera's ortho width to set the "translate Y" value
			// in the matrix.
			//
			connectAttr ($multNode + ".output") ($matrixNode + ".i31");
			connectAttr ($camera + ".orthographicWidth") 
				($multNode + ".input1");
		} else {
			// For side camera, whose view vector is in the X direction,
			// use the camera's ortho width to set the "translate X" value
			// in the matrix.
			//
			connectAttr ($multNode + ".output") ($matrixNode + ".i30");
			connectAttr ($camera + ".orthographicWidth") 
				($multNode + ".input1");
		}

	} else {
		// connect camera's world space matrix to lodGroup node
		string $cameraSh[] = `listRelatives -children $camera`;
		connectAttr ($cameraSh[0] + ".worldMatrix") 
			($lodGroup + ".cameraMatrix");
	}

	// get current camera distance. This will be used to choose some
	// reasonable initial values for the thresholds
	float $cameraDistance = getAttr ($lodGroup + ".distance");

	// assign initial threshold distances using inverse-square law
	// set the middle selected transform to be the one that will be
	// visible at the current camera distance. 
	if ( $numTransforms > 1 ) {
		int $numThresholds = $numTransforms - 1;
		int $midElement    = ($numThresholds-2) / 2;

		float	$distances[];
		for( $i = 0; $i < $numThresholds; $i++ ) {
   			$distances[$i] = ($i+1) * ($i+1);
		}

	    float $meanDist = ($distances[$midElement] + $distances[$midElement+1])/2.0;
		float $scaling  = $cameraDistance / $meanDist;

		// set the thresholds putting the middle resolution node in the middle
		for( $i = 0; $i < $numThresholds; $i++ ) {
	    	setAttr ($lodGroup + ".threshold[" + $i + "]") 
				($distances[$i] * $scaling);
		}
	}

	// initialize each transform's LOD lodVisibility to Off
	for( $i = 0; $i < $numTransforms; $i ++ ) {
		setAttr ($lodGroup + ".displayLevel[" + $i + "]") 0;
	}

	// enable worldspace setting by default so grouping the lod node
	// will still work as expected
	setAttr ($lodGroup + ".worldSpace") 1;

	// explicitly select the threshold node and group 
	select -r $lodGroup;

	// return the group
	string $retval[];
	$retval[0] = $lodGroup;
	return $retval;
}
