// Copyright (C) 1997-2014 Autodesk, Inc., and/or its licensors.
// All rights reserved.
//
// The coded instructions, statements, computer programs, and/or related
// material (collectively the "Data") in these files contain unpublished
// information proprietary to Autodesk, Inc. ("Autodesk") and/or its licensors,
// which is protected by U.S. and Canadian federal copyright law and by
// international treaties.
//
// The Data is provided for use exclusively by You. You have the right to use,
// modify, and incorporate this Data into other products for purposes authorized 
// by the Autodesk software license agreement, without fee.
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND. AUTODESK
// DOES NOT MAKE AND HEREBY DISCLAIMS ANY EXPRESS OR IMPLIED WARRANTIES
// INCLUDING, BUT NOT LIMITED TO, THE WARRANTIES OF NON-INFRINGEMENT,
// MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE, OR ARISING FROM A COURSE 
// OF DEALING, USAGE, OR TRADE PRACTICE. IN NO EVENT WILL AUTODESK AND/OR ITS
// LICENSORS BE LIABLE FOR ANY LOST REVENUES, DATA, OR PROFITS, OR SPECIAL,
// DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES, EVEN IF AUTODESK AND/OR ITS
// LICENSORS HAS BEEN ADVISED OF THE POSSIBILITY OR PROBABILITY OF SUCH DAMAGES.

//
//
//  Creation Date:  Apr, 2000
//
//	Procedure Name:
//		doImportClipArgList
//
//	Description:
//		Import a clip
//
//	Input Arguments:
//	$version: The version of this option box.  Used to know how to 
//	interpret the $args array.
//  
//	$args
//	Version 1
//   - none
//	Version 2
//   - $args[0] : (true/false) import clips onto character or not
//	Version 3
//   - $args[0] : (true/false) import clips onto character or not
//   - $args[1] : (true/false) schedule character clips on timeline (only
//                valid if $args[0] is also true
//	Version 4
//   - $args[0] : (true/false) import clips onto character or not
//   - $args[1] : (true/false) schedule character clips on timeline (only
//                valid if $args[0] is also true
//   - $args[2] : optional, name of character to import to
//	Version 5
//	 - $args[3]	: track to paste to (-1 means next available)
//	 - $args[4]	: group to paste to
//
//
global int $gImportClipToCharacter = 0;
global int $gScheduleClipOnCharacter = 0;
global string $gImportToCharacter = "";
global string $gImportClipArgs[];

global proc int
clipEditorImportClip(string $fileName, string $fileType)
//
// Import the specified file. If gImportClipToCharacter is true,
// copy the clips to the character. Otherwise, place the clips in
// the "Unused Clips and Poses" folder in visor.	
//
// If gScheduleClipOnCharacter is true, schedule the clip at the current
// time.
//
{
	global int $gImportClipToCharacter;
	global int $gScheduleClipOnCharacter;
	global string $gImportToCharacter;
	global string $gImportClipArgs[];

	if ($fileName == "") {
		error (uiRes("m_doImportClipArgList.kNoFileName"));
		return 0;
	}

	string $preSourceClips[] = `clip -q -allSourceClips`;
	int $preClipCount = size($preSourceClips);
	string $characters[];
	if (size($gImportToCharacter) == 0) {
		$characters = getCharactersForAction();
	} else {
		$characters[0] = $gImportToCharacter;
		$gImportToCharacter = "";
	}

	// reference the file into a namespace so we can figure out
	// which clips came from the imported file
	//
	string $tmpNamespace = "clipImportTmp";
	string $oldNamespace = `namespaceInfo -cur`;
	if ($oldNamespace != ":") {
		$oldNamespace = (":"+$oldNamespace);
	}
	namespace -set ":";
	file -r -namespace $tmpNamespace -options "v=0;p=17" $fileName;
	namespace -set (":"+$tmpNamespace);
	string $nameSpaceNodes[] = `namespaceInfo -lod`;

	namespace -set $oldNamespace;
	
	if ($gImportClipToCharacter) {

		// copy the included clips to the specified characters
		//
		string $sch = " -sc 0 ";
		if ($gScheduleClipOnCharacter) {
			float $currentTime = `currentTime -q`;
			$sch = (" -sc 1 -s "+$currentTime+" ");
		}

		int $versionNo = $gImportClipArgs[0];
		int $toTrack = -1;
		string $toGroup;
		if ($versionNo >= 1) {
			$toTrack = $gImportClipArgs[1];
			$toGroup = $gImportClipArgs[2];
		}

		string $clips[] = `ls -type animClip $nameSpaceNodes`;

		// copy the files onto the selected characters
		//
		for ($clip in $clips) {
			if (`getAttr ($clip+".clipInstance")` != 0)
				continue;

				for ($character in $characters) {

				// Copy the clip and attempt to paste it. 
					clip -copy $clip;

					string $newClips[];

				string $fmt = ( "clip -paste " + $sch + " -mm ^1s " + $character );

				// First, attempt to paste the clip using the 'byNodeName' method
				string $cmd = `format -s "byNodeName" $fmt`;
					if (catch($newClips = `evalEcho $cmd`)) {
					// If this fails, attempt to past using 'byAttrName'
					$cmd = `format -s "byAttrName" $fmt`;
						catch($newClips = `evalEcho $cmd`);
					}

					if (($toGroup != "") || ($toTrack != -1)) {
						$scheduler = `character -query -scheduler $character`;
						for ($newClip in $newClips) {
							$clipIndex = getClipIndex ($newClip, $scheduler);
							if ($toGroup != "") {
								if ($toTrack != -1) {
									clipSchedule -group true -groupIndex $clipIndex -track $toTrack -groupName $toGroup $scheduler;
								}
								else {
									clipSchedule -group true -groupIndex $clipIndex -groupName $toGroup $scheduler;
								}
							}
							else if ($toTrack != -1) {
								clipSchedule -clipIndex $clipIndex -track $toTrack $scheduler;
							}
						}
					}

				// Make sure that any clips that are imported into the scene are
				// correctly appended to the graph for ghosting
				{
					string $scheduler = `character -query -scheduler $character`;
					ghostAppendedClip( $scheduler, { "", $newClips[0] }, 0 );
				}

				// Rename the new clip with a more meaningful name based on the filename.
				if ( size( $newClips[0] ) && size( $fileName ) )
				{
					// Determine the file extension and path prefix if they are present
					string $name = basenameEx( fromNativePath( $fileName ) );
					if ( size( $name ) )
						rename $newClips[0] $name;
				}
				
			}
		}

	} else {
		string $clipLibs[] = `ls -type clipLibrary $nameSpaceNodes`;
		if (size($clipLibs) > 0) {
			// copy the info into the new name space
			//
			select -r $clipLibs;
			duplicate -un;
		}
	}

	// remove the reference
	//
	file -rr $fileName;
	
	string $postSourceClips[] = `clip -q -allSourceClips`;
    int $postClipCount = size($postSourceClips);
	int $result = 1;
	if ($postClipCount == $preClipCount) {
		$result = 0;
		error (uiRes("m_doImportClipArgList.kFileContainsNoClip"));
	} else {
		int $newClips = $postClipCount-$preClipCount;
		string $newClipsString = string($newClips);
		string $printMsg = (uiRes("m_doImportClipArgList.kImportedClips"));
		$printMsg = `format -s $newClipsString $printMsg`;
		print($printMsg);
	}

	return $result;
}

global proc
doImportClipArgList( string $version, string $args[] )
{
	global int $gImportClipToCharacter;
	global int $gScheduleClipOnCharacter;
	global string $gImportToCharacter;
	global string $gImportClipArgs[];

	$gImportClipArgs[0] = "0";
	string $sel[] = `ls -sl`;

	int $versionNo = $version;
	if ($versionNo > 1) {
		$gImportClipToCharacter = $args[0];
		if ($versionNo > 2) {
			$gScheduleClipOnCharacter = $args[1];
		}
		if ($versionNo > 3) {
			if (size($args) > 2) {
				$gImportToCharacter = $args[2];
			} else {
				$gImportToCharacter = "";
			}
		}
		int $toTrack = -1;
		string $toGroup;
		if ($versionNo >= 5) {
			$toTrack = $args[3];
			$toGroup = $args[4];
		}
		$gImportClipArgs[0] = "1";
		$gImportClipArgs[1] = $toTrack;
		$gImportClipArgs[2] = $toGroup;
		if ($gImportClipToCharacter && size($gImportToCharacter) == 0) {
			string $characters[] = getCharactersForAction();
			if (size($characters) == 0) {
				error (uiRes("m_doImportClipArgList.kSelectCharactersToImport"));
				return;
			}
		}
	} else {
		$gImportClipToCharacter = 0;
		$gScheduleClipOnCharacter = 0;
		$gImportToCharacter = "";
	}

	string $clipsDir = (`workspace -q -rd`+"clips\/");
	if (`file -q -ex $clipsDir`) {
		workspace -dir $clipsDir;
	}

	// bring up the file browser dialog so the user can choose files to import
	//
	string $importClip = (uiRes("m_doImportClipArgList.kImportClip"));
	fileBrowser("clipEditorImportClip",$importClip,"ma",5);

	// restore the selection
	//
	if (size($sel) > 0)
		select -r $sel;

}
