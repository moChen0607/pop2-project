// Copyright (C) 1997-2014 Autodesk, Inc., and/or its licensors.
// All rights reserved.
//
// The coded instructions, statements, computer programs, and/or related
// material (collectively the "Data") in these files contain unpublished
// information proprietary to Autodesk, Inc. ("Autodesk") and/or its licensors,
// which is protected by U.S. and Canadian federal copyright law and by
// international treaties.
//
// The Data is provided for use exclusively by You. You have the right to use,
// modify, and incorporate this Data into other products for purposes authorized 
// by the Autodesk software license agreement, without fee.
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND. AUTODESK
// DOES NOT MAKE AND HEREBY DISCLAIMS ANY EXPRESS OR IMPLIED WARRANTIES
// INCLUDING, BUT NOT LIMITED TO, THE WARRANTIES OF NON-INFRINGEMENT,
// MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE, OR ARISING FROM A COURSE 
// OF DEALING, USAGE, OR TRADE PRACTICE. IN NO EVENT WILL AUTODESK AND/OR ITS
// LICENSORS BE LIABLE FOR ANY LOST REVENUES, DATA, OR PROFITS, OR SPECIAL,
// DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES, EVEN IF AUTODESK AND/OR ITS
// LICENSORS HAS BEEN ADVISED OF THE POSSIBILITY OR PROBABILITY OF SUCH DAMAGES.

//
//

// Make sure these procedures are defined so the menu commands below will
// be recognized.
// source "buildCameraSetLookthruMenu.mel";

global proc buildOtherPanelSubItemsNow (string $subMenuName, string $panelName)
{
    string $state[];
    int $count = 0;
	string $label;

    string $panels[] = `getPanel -allPanels`;

    for ($panel in $panels) {
        string $type = `getPanel -typeOf $panel`;
		$label = `panel -q -label $panel`;		
		
		// Skip Top, Front, Side, and Persp Panels
		//
        if (($type != "modelPanel" ||
			 ( (localizedPanelLabel("Top View")) != $label && (localizedPanelLabel("Front View")) != $label &&
			 (localizedPanelLabel("Side View")) != $label && (localizedPanelLabel("Persp View")) != $label)) &&
			$type != "emptyPanel") 
		{
			string $realType;
			if ($type == "scriptedPanel") {
				$realType = `scriptedPanel -q -type $panel`;
				// Don't want obsolete panels
				//
				if ( `scriptedPanelType -q -obsolete $realType` )
				{
					continue;
				}
			} else {
				$realType = $type;
			}

            if ($realType == "hyperGraphPanel")
            {
                // We don't show hyperGraphPanel in this list. 
                //
                continue;
            }

			if ( ( $realType == "blendShapePanel")
					&& (!`licenseCheck -m "edit" -typ "complete"`)) {
				//
				// The user needs a Maya Complete license to use
				// the BlendShape panel, so don't
				// bother offerring it as a choice (would just
				// bring up a useless blank panel anyway)
				continue;
			}

			// For now the preload reference editor should only be accessible
			// through the File > Open Scene Option Box
			//
			if ( $realType == "preloadReferenceEditorPanel" ) {
				continue;
			}

            $state[$count++] = $panel;
            $state[$count++] = `panel -q -to $panel`;
        }
    }

    // Rebuild menu
    //
	setParent -m $subMenuName;

	popupMenu -e -deleteAllItems $subMenuName;

    string $command;
	string $item;
	int    $kNumItemsPerDivider = 3;

	$count = 0;
	int $continueCheck = 0;
	int $createNodeCheck = 0;
	int $nodeEditorCheck = 0;
    for ($i in $panels) {
		//	bug 201782: preloadReferenceEditorPanel's use of continue exposed this bug.
		//	It was there for Complete already I suspect. Using continue fooled the count
		//	and mod operation.
		//
		if (($continueCheck == 0) && ($count > 0) && ($count%$kNumItemsPerDivider == 0)) {
			menuItem -divider true;
		}

        $command = `getPanel -typeOf $i`;
		$label = `panel -q -label $i`;
		
		// Skip Top, Front, Side, and Persp Panels
		//
       if (($command != "modelPanel" ||
			 ( (localizedPanelLabel("Top View")) != $label && (localizedPanelLabel("Front View")) != $label &&
			 (localizedPanelLabel("Side View")) != $label && (localizedPanelLabel("Persp View")) != $label)) &&
			$command != "emptyPanel") 
		{
			string $realType;
			if ($command == "scriptedPanel") {
				$realType = `scriptedPanel -q -type $i`;
			} else {
				$realType = $command;
			}

            if ($realType == "hyperGraphPanel")
            {
				$continueCheck = 1;
                continue;
            }

			// The user needs a Maya Complete license to use
			// the BlendShape panel, so don't
			// bother offerring it as a choice (would just
			// bring up a useless blank panel anyway)
			//
			if ( ( $realType == "blendShapePanel")
					&& (!`licenseCheck -m "edit" -typ "complete"`)) {
				$continueCheck = 1;
				continue;
			}

			// For now the preload reference editor should only be accessible
			// through the File > Open Scene Option Box
			//
			if ( $realType == "preloadReferenceEditorPanel" ) {
				$continueCheck = 1;
				continue;
			}

			// Don't put more than the first Create Node panel
			// in the menu (the first is the only one to reside
			// in the main window panels, the rest are independent
			// windows)
			//
			if( $realType == "createNodePanel" ) {
				if($createNodeCheck) {
					continue;
				} else {
					$createNodeCheck = 1;
				}
			}

			// Don't put more than the first Node Editor panel
			// in the menu (the first is the only one to reside
			// in the main window panels, the rest are independent
			// windows)
			//
			if( $realType == "nodeEditorPanel" ) {
				if($nodeEditorCheck) {
					continue;
				} else {
					$nodeEditorCheck = 1;
				}
			}

			// Don't want to see webBrowserPanel - deprecated
			//
			if ( $realType == "webBrowserPanel" )
			{
				continue;
			}
			$item = `menuItem -label $label -ecr false
				-c ($command+" -e -rp "+$panelName+" "+$i)`;

			// Highlight profiler
			if ( $realType == "profilerPanel" )
			{
				menuItem -e -version "2016" $item;
			}

			if (`panel -q -to $i`) {
				menuItem -e -enable false $item;
			}

			$continueCheck = 0;
			$count++;

		}
    }
}

global proc buildNamedArrangementsNow( string $menuName ) 
{
	string $configLabel;
	string $arrs[];
	int $i;
	int $nArr = 0;

	menu -e -deleteAllItems $menuName;
	setParent -m $menuName;

	$arrs = `getPanel -allConfigs`;
	$nArr = size($arrs);

	for ($i = 0; $i < $nArr; $i++) {
		$configLabel = `panelConfiguration -q -label $arrs[$i]`;
		if (localizedPanelLabel("Current Layout") != $configLabel) {
			menuItem -label $configLabel 
				-annotation (uiRes("m_buildPanelPopupMenu.kChangeLayoutAnnot"))
				-c ("setNamedPanelLayout \"" + $configLabel + "\"");
		}
	}

    menuItem -divider true;
	menuItem -label (uiRes("m_buildPanelPopupMenu.kEditLayouts")) 
		-annotation (uiRes("m_buildPanelPopupMenu.kEditLayoutsAnnot"))
		-c "panelEditor(uiRes(\"m_panelEditor.kLayouts\"))";
}
	
global proc tearOffCopyItemCmd(string $panelType, string $srcPanel) {

	string $cmd;
	string $type;

	if ("scriptedPanel" == $panelType) {
		$type = `scriptedPanel -q -type $srcPanel`;
		$cmd = ("scriptedPanel -toc "+ $srcPanel +" -type "+ $type);
		
	} else {
		$cmd = ($panelType + " -toc " + $srcPanel);
	}
	$newName = `eval $cmd`;

	panel -e -label (localizedPanelLabel(`interToUI $newName`)) $newName;
}

// To allow the addition of new categories into the Panels pulldown
// we keep a list of user-specified additions. The user adds a new
// category by calling addPanelCategory() and removes it via
// removePanelCategory(). Whenever the Panels pulldown is redrawn,
// a new button labelled using the category name is drawn.
//
global string $categoryName[];			// Name of category.
global string $categoryInsertAfter[];	// Button to insert after.
global string $categoryCmd[];			// MEL command for button.

// Description:  This procedure is called when user wants to tear
//      off a panel to put the content in a window.
//
global proc panelTearOff(string $paneType, string $panelName)
{
    // Make a special case for hyper graph panel.
    //
    if ($paneType == "scriptedPanel" && 
        `scriptedPanel -query -type $panelName` == "hyperGraphPanel")
    {
        hyperGraphWindow($panelName, "");
        return;
    }
    
    // For non-hyper-graph-panel, do a simple tear off.
    //
    string $cmd = $paneType + " -e -to " + $panelName; 
    eval($cmd);
}

global proc buildPanelItemsNow ( string $panelName, string $menuName )
{
	global string $categoryName[];
	global string $categoryInsertAfter[];
	global string $categoryCmd[];

	string $panelControl = `panel -q -control $panelName`;

	// if the menu name is specified, use it.  Otherwise, assume
	// it is the pop-up menu and build the name appropriately.
	//
	string $popMenuName;
	if ( $menuName == "" ){
		$popMenuName = ($panelControl + "|" + $panelName + "Pop1");
	} else {
		$popMenuName = $menuName;
	}
	string $panelType = `getPanel -typeOf $panelName`;
	string $itemName;

	setParent -m $popMenuName;	

    // The camera commands depend on the panel having focus for
    // getting the camera in the view.
    setFocus $panelName;

	if (0 != `menu -q -numberOfItems $popMenuName`) {
        if ($panelType == "modelPanel" && $menuName == "")
            menuItem -e -label `modelPanel -q -camera $panelName` menuTitle;

		menu -e -deleteAllItems $popMenuName;
    }

	// Titles are only needed for pop-up menu
	//
	if ( $menuName == "" ){
    	if ($panelType == "modelPanel"){
        	menuItem -label `modelPanel -q -camera $panelName` menuTitle;
		}
    	else {
        	menuItem -label `panel -q -label $panelName` menuTitle;
		}
		menuItem -divider true;
		menuItem -divider true;
	}

	string $menu;
	$menu = `menuItem -label (uiRes("m_buildPanelPopupMenu.kPerspective")) -subMenu true`;
	menuItem -e -postMenuCommand
   		("buildPerspLookthruMenu "+$menu+" "+$panelName) $menu;
	setParent -m ..;

	$menu = `menuItem -label (uiRes("m_buildPanelPopupMenu.kStereo")) -subMenu true`;
	menuItem -e -postMenuCommand
		("buildStereoLookthruMenu "+$menu+" "+$panelName) $menu;
	setParent -m ..;

	$menu = `menuItem -label (uiRes("m_buildPanelPopupMenu.kOrthographic")) -subMenu true`;
	menuItem -e -postMenuCommand
   		("buildOrthoLookthruMenu "+$menu+" "+$panelName) $menu;
	setParent -m ..;

    $menu = `menuItem -label (uiRes("m_buildPanelPopupMenu.kLookThroughSelected"))
        -command ("lookThroughSelected 0 " + $panelName)`;
        
	// If a cameraSet is being viewed disable this menu item.
	string $cameraSetUsed = false;
	if ($panelType == "modelPanel")
	{
		string $chosenCameraSet = `modelEditor -q -cameraSet $panelName`;
		if ($chosenCameraSet != "")
		{
			$cameraSetUsed = true;
			menuItem -e -enable false $menu;
		}
	}


	$menu = `menuItem -optionBox true
		-annotation (uiRes("m_buildPanelPopupMenu.kLookThroughAnnot"))
		-c ("lookThroughSelected 1 " + $panelName )`;
	if ($cameraSetUsed)
		menuItem -e -enable false $menu;


	if ( `getenv ENABLE_DEFAULT_VIEWPORT_CAMERA_SETS` == 1 ) { 
    	$menu = `menuItem -label (uiRes("m_buildPanelPopupMenu.kCameraSet")) -subMenu true`;
   		menuItem -e -postMenuCommand
     	  	("buildCameraSetLookthruMenu "+$menu+" "+$panelName) $menu;
    	setParent -m ..;
	}

	menuItem -divider true;

	$menu = `menuItem -label (uiRes("m_buildPanelPopupMenu.kPanel")) -subMenu true`;
	menuItem -e -postMenuCommand
        ("buildOtherPanelSubItemsNow "+$menu+" "+$panelName) $menu;
	setParent -m ..;

    // Hypergraph panels
    //
    $menu = `menuItem -label (uiRes("m_buildPanelPopupMenu.kHypergraphPanel")) -subMenu true`;
    menuItem -e -postMenuCommand
        ("buildPanelHypergraphSubMenu "+$menu+" "+$panelName) $menu;
    setParent -m ..;

    menuItem -label (uiRes("m_buildPanelPopupMenu.kLayouts")) -subMenu true -tearOff true;
        menuItem -label (localizedPanelLabel("Single Pane")) -command "SingleViewArrangement"
			-annotation (getRunTimeCommandAnnotation("SingleViewArrangement"));

        menuItem -label (localizedPanelLabel("Two Panes Side by Side")) -command "TwoSideBySideViewArrangement"
			-annotation (getRunTimeCommandAnnotation("TwoSideBySideViewArrangement"));
		menuItem -label (localizedPanelLabel("Two Panes Stacked")) -command "TwoStackedViewArrangement"
			-annotation (getRunTimeCommandAnnotation("TwoStackedViewArrangement"));

		menuItem -label (localizedPanelLabel("Three Panes Split Top")) -command "ThreeTopSplitViewArrangement"
			-annotation (getRunTimeCommandAnnotation("ThreeTopSplitViewArrangement"));
        menuItem -label (localizedPanelLabel("Three Panes Split Left")) -command "ThreeLeftSplitViewArrangement"
			-annotation (getRunTimeCommandAnnotation("ThreeLeftSplitViewArrangement"));
        menuItem -label (localizedPanelLabel("Three Panes Split Bottom")) -command "ThreeBottomSplitViewArrangement"
			-annotation (getRunTimeCommandAnnotation("ThreeBottomSplitViewArrangement"));
        menuItem -label (localizedPanelLabel("Three Panes Split Right")) -command "ThreeRightSplitViewArrangement"
			-annotation (getRunTimeCommandAnnotation("ThreeRightSplitViewArrangement"));

		menuItem -label (localizedPanelLabel("Four Panes")) -command "FourViewArrangement"
			-annotation (getRunTimeCommandAnnotation("FourViewArrangement"));

		menuItem -divider true;

		menuItem -label (uiRes("m_buildPanelPopupMenu.kPreviousArrangement")) -command "PreviousViewArrangement"
			-annotation (getRunTimeCommandAnnotation("PreviousViewArrangement"));
        menuItem -label (uiRes("m_buildPanelPopupMenu.kNextArrangement")) -command "NextViewArrangement"
			-annotation (getRunTimeCommandAnnotation("NextViewArrangement"));

	setParent -menu ..;

	$menu = `menuItem -label (uiRes("m_buildPanelPopupMenu.kSavedLayouts")) -subMenu true`;
	menuItem -e -pmc ("buildNamedArrangementsNow " + $menu) $menu;
	setParent -m ..;


	menuItem -divider true;

	string $cmd = "panelTearOff " + $panelType + " " + $panelName + "; fillEmptyPanes;";
	string $evalCmd = "evalDeferred(\"" + $cmd + "\");";
	menuItem -label (uiRes("m_buildPanelPopupMenu.kTearOff")) -ecr false -c $evalCmd;
	$itemName = `menuItem -label (uiRes("m_buildPanelPopupMenu.kTearOffCopy")) -ecr false 
						-c ("tearOffCopyItemCmd " +$panelType + " " + $panelName)`;
	if (`panel -q -iu $panelName`) {
		menuItem -e -enable false $itemName;
	}

	menuItem -divider true;

	menuItem -label (uiRes("m_buildPanelPopupMenu.kPanelEditor")) -c "panelEditor \"Panels\"";
	
	//	Create Context Sensitive Help Menu.
	//
	if (hasContextHelpProc($panelName))
	{
		doHelpSubMenu $panelName $menuName;
	}//if

	// At this point, menu has just been created, add any additional
	// user-defined categories.
	//
	int	$i, $j;
	int	$nc = size( $categoryName );
	string $insertAfter = "";
	for ( $i = 0; $i < $nc; $i++ ) {
		// Find the button to insert after.
		//
		string $items[] = `menu -q -ia $popMenuName`;
		int $ni = size( $items );
		for ( $j = 0; $j < $ni; $j++ ) {
			int $divider = `menuItem -q -d $items[$j]`;
			if ( $divider ) {
				continue;
			}
			string $label = `menuItem -q -l $items[$j]`;
			if ( $label == $categoryInsertAfter[$i] ) {
				$insertAfter = $items[$j];
				break;
			}
		}

		// Add the new button after the "insert after" button.
		if ( $j >= $ni ) {
			string $msg = (uiRes("m_buildPanelPopupMenu.kCategoryNotFound"));
			error `format -s $categoryInsertAfter[$i] $msg`;
			return;
		}
		$menu = `menuItem -l $categoryName[$i] -subMenu true -ia $insertAfter`;
		menuItem -e -postMenuCommand
			($categoryCmd[$i]+" "+$menu+" "+$panelName) $menu;
		setParent -m ..;
	}
}

global proc buildPanelPopupMenu (string $panelName) {

	// Build the common menu if it has not already been
	// built. (and this is not a torn-off panel)
	//
	if ( !`panel -q -tearOff $panelName` ) {
		string $panelControl = `panel -q -control $panelName`;
		if ( `menuBarLayout -exists $panelControl` ){
			setParent $panelControl;
			string $ma[] = `menuBarLayout -q -menuArray $panelControl`;
			int $found = 0;
			int $i;
			for ( $i=0; $i<size($ma) && $found == 0; $i++ ){
				if ( $ma[$i] == "Panels" ){
					$found = 1;
				}
			}
			if ( $found == 0 ){
				setParent $panelControl;
				string $menuName = `menu -helpMenu true 
							-allowOptionBoxes 1
							-label (uiRes("m_buildPanelPopupMenu.kPanels")) 
							-familyImage "menuIconPanels.png"
							Panels`;
				menu -e -pmc ("buildPanelItemsNow "+$panelName+" "+$menuName) $menuName;
			}
		}
	} else {
		string $panelControl = `panel -q -control $panelName`;
		if ( `menuBarLayout -exists $panelControl` ){
			setParent $panelControl;
			string $ma[] = `menuBarLayout -q -menuArray $panelControl`;
			int $found = 0;
			int $i;
			//	 Check for existing Help Menu.
			//
			for ( $i=0; $i<size($ma) && $found == 0; $i++ ){
				if ( $ma[$i] == "HelpMenu" ){
					$found = 1;
				}
			}
			if ( $found == 0 ){
				doHelpMenu($panelName,$panelControl);
			}
		}
	}
}
