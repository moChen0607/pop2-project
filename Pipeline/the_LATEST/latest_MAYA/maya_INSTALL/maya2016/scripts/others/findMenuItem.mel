// Copyright (C) 1997-2014 Autodesk, Inc., and/or its licensors.
// All rights reserved.
//
// The coded instructions, statements, computer programs, and/or related
// material (collectively the "Data") in these files contain unpublished
// information proprietary to Autodesk, Inc. ("Autodesk") and/or its licensors,
// which is protected by U.S. and Canadian federal copyright law and by
// international treaties.
//
// The Data is provided for use exclusively by You. You have the right to use,
// modify, and incorporate this Data into other products for purposes authorized 
// by the Autodesk software license agreement, without fee.
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND. AUTODESK
// DOES NOT MAKE AND HEREBY DISCLAIMS ANY EXPRESS OR IMPLIED WARRANTIES
// INCLUDING, BUT NOT LIMITED TO, THE WARRANTIES OF NON-INFRINGEMENT,
// MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE, OR ARISING FROM A COURSE 
// OF DEALING, USAGE, OR TRADE PRACTICE. IN NO EVENT WILL AUTODESK AND/OR ITS
// LICENSORS BE LIABLE FOR ANY LOST REVENUES, DATA, OR PROFITS, OR SPECIAL,
// DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES, EVEN IF AUTODESK AND/OR ITS
// LICENSORS HAS BEEN ADVISED OF THE POSSIBILITY OR PROBABILITY OF SUCH DAMAGES.

//
//
// Creation Date: Oct 1999
//
//<doc>
//<name findMenuItem>
//
//<synopsis>
//		findMenuItem;
//
//<description>
//		Displays a window that takes a text string and searches
//		the main Maya window menus for that string. 
//<P>
//		The search can be slow if Maya has just started as the
//		menus need to be built before they can be searched.
//
//<returns>
//		None.
//
//<examples>
//
//	findMenuItem;
//
//</doc>

proc int menuInMenuSet( string $menuSet, string $menu ){

	// Get the list of menus in the set
	string $menusArray[] = `menuSet -query -menuArray $menuSet`;

	int $i;
	int $menusArraySize = size($menusArray);

	// Go through all the menus in the set ...
	for ($i = 0; $i < $menusArraySize; $i++) {
		
		if( $menu == $menusArray[$i] ){
			return true;
		}
	}

	// If we get to this point we could not find the menu
	return false;
}

global proc string getMenuSetPrefix( string $menu ){

	// Get the list of menu sets	
	string $menuSetList[] = `menuSet -allMenuSets`;

	// Search for the menu
	for ( $aMenuSet in $menuSetList ){
		if( $aMenuSet == "commonMenuSet" ){
			if( menuInMenuSet( $aMenuSet, $menu ) ){
				return "";	// Don't use a prefix for the common menuset
			}
		} else {
			if( menuInMenuSet( $aMenuSet, $menu ) ){
				return ("[" + `menuSet -query -label $aMenuSet` + "] ");
			}
		}
	}
	
	// If we get to this point we could not find the menu set
	return "";
}

global proc int searchOneMenu( string $rootMenu, string $thisMenu, string $searchString, string $path)
{
	global string $gMainWindow;
	setParent $gMainWindow;

	int $numItems = `menu -q -ni $thisMenu`;
	if ($numItems == 0) { 
		// Try to build the menu
		string $pmCmd = `menu -q -pmc $thisMenu`;
		catch(eval($pmCmd));
		$numItems = `menu -q -ni $thisMenu`;
	}

	if ($numItems == 0) return 0;

	int $gotOne = 0;
	
	string $items[] = `menu -q -ia $thisMenu`;
	setParent -m $thisMenu;
	for ($i=0; $i < $numItems; ++$i) {

		// Handle option boxes
		if (`menuItem -q -iob $items[$i]`) continue;
		// Handle the dividers
		if (`menuItem -q -d $items[$i]`) continue;

		string $label = `menuItem -q -l $items[$i]`;
		string $menuLabel;

		if (!`checkBox -q -v searchCaseSensitive`) {
			$menuLabel = tolower ($label);
		} else {
			$menuLabel = $label;
		}
		// Remove the ... on menu items
		$menuLabel = substituteAllString($menuLabel, ".", "");

		if (`gmatch $menuLabel $searchString`) {
			
			if( !startsWith($path, "[" ) ){
				// getMenuSetPrefix is time consuming, so we only add the menu set
				// prefix to the path if we have found a match
				$path = getMenuSetPrefix( $rootMenu ) + $path;
			}
			
			scrollField -edit -it ($path+$label+"\n") 
				searchResultsTextField;
			$gotOne = 1;
		} 
		
		if (`menuItem -q -sm $items[$i]`) {
			// Check for submenus
			string $newPath = $path+$label+"->";
			if (searchOneMenu( $rootMenu, $items[$i], $searchString, $newPath)) {
				$gotOne = 1;
			}
		}
		setParent -m ..;
	}
	return $gotOne;
}

global proc int oldMenuSearch (string $searchString)
{
	int $retVal = false;
	float $version = `getApplicationVersionAsFloat`;
	string $msg;
	string $renamedPrefix;
	string $movedPrefix;
	string $removedPrefix;

	// Note: The missing break statements in the outer loop	are intentional
	// If the item isn't found for the current version, look at old versions.
	// Additions to this should always put new versions at the top.

	switch ($version) { 	

	// Maya 8.0 cases
	//
	case 8.0:
		$retVal = true;
		
		global string $gPolygonsSelectMenu;
		global string $gPolygonsMeshMenu;
		global string $gPolygonsEditMeshMenu;
		global string $gPolygonsProxyMenu;
		global string $gPolygonsNormalsMenu;
		global string $gPolygonsColorMenu;
		global string $gPolygonsCreateUVsMenu;
		global string $gPolygonsEditUVsMenu;
		
		string $windowLocCmd	= "getMenuSetPrefix( $gMainWindowMenu )";
		string $selectLocCmd 	= "getMenuSetPrefix( $gPolygonsSelectMenu )";
		string $meshLocCmd 		= "getMenuSetPrefix( $gPolygonsMeshMenu )";
		string $editMeshLocCmd 	= "getMenuSetPrefix( $gPolygonsEditMeshMenu )";
		string $proxyLocCmd 	= "getMenuSetPrefix( $gPolygonsProxyMenu )";
		string $normalsLocCmd 	= "getMenuSetPrefix( $gPolygonsNormalsMenu )";
		string $colorLocCmd		= "getMenuSetPrefix( $gPolygonsColorMenu )";
		string $createUVsLocCmd = "getMenuSetPrefix( $gPolygonsCreateUVsMenu )";
		string $editUVsLocCmd 	= "getMenuSetPrefix( $gPolygonsEditUVsMenu )";
		
		$renamedPrefix 	= (uiRes("m_findMenuItem.kRenamedPrefix8"));
		$movedPrefix 	= (uiRes("m_findMenuItem.kMovedPrefix8"));
		$removedPrefix 	= (uiRes("m_findMenuItem.kRemovedPrefix8"));
		
		switch ($searchString) {
			//
			// Renamed items
			//
			
			// Select menu renames
			//
			
			case "*selection constraints*":
				$msg = 	$renamedPrefix + 
						eval( $editMeshLocCmd ) + 
						(uiRes("m_findMenuItem.kNewPolySelectionConstraints"));
				break;

			// Edit Mesh menu renames
			//
			case "*extrude face*":
			case "*extrude edge*":
			case "*extrude vertex*":
				$msg = 	$renamedPrefix + 
						eval( $editMeshLocCmd ) + 
						(uiRes("m_findMenuItem.kNewPolyExtrude"));
				break;
			
			case "*bridge edge*":
				$msg = 	$renamedPrefix + 
						eval( $editMeshLocCmd ) + 
						(uiRes("m_findMenuItem.kNewPolyBrEdge"));
				break;

			case "*move component*":
				$msg = 	$renamedPrefix + 
						eval( $editMeshLocCmd ) +  
						(uiRes("m_findMenuItem.kNewPolyMoveComp"));
				break;

			case "*poke faces*":
				$msg = 	$renamedPrefix + 
						eval( $editMeshLocCmd ) + 
						(uiRes("m_findMenuItem.kNewPolyPokeFaces"));
				break;
				
			case "*wedge faces*":
				$msg = 	$renamedPrefix + 
						eval( $editMeshLocCmd ) +  
						(uiRes("m_findMenuItem.kNewPolyWedgeFaces"));
				break;

			case "*split vertex*":
				$msg = 	$renamedPrefix + 
						eval( $editMeshLocCmd ) +  
						(uiRes("m_findMenuItem.kNewPolySplitVtx"));
				break;

			case "*merge vertices*":
			case "*merge multiple edges*":
				$msg = 	$renamedPrefix + 
						eval( $editMeshLocCmd ) + 
						(uiRes("m_findMenuItem.kNewPolyMrgVtxEdges"));
				break;

			case "*delete edge*":
			case "*delete vertex*":
				$msg = 	$renamedPrefix + 
						eval( $editMeshLocCmd ) +  
						(uiRes("m_findMenuItem.kNewPolyDeleteEdgVtx"));
				break;
				
			case "*subdivide*":
				$msg = 	$renamedPrefix + 
						eval( $editMeshLocCmd ) +  
						(uiRes("m_findMenuItem.kNewSubdivide"));
				break;

			case "*split edge ring tool*":
				$msg = 	$renamedPrefix + 
						eval( $editMeshLocCmd ) + 
						(uiRes("m_findMenuItem.kNewPolySplEdgRngTool"));
				break;

			case "*duplicate edge loop tool*":
				$msg = 	$renamedPrefix + 
						eval( $editMeshLocCmd ) + 
						(uiRes("m_findMenuItem.kNewPolyDuplicateEdgeLoopTool"));
				break;			

			// Mesh menu renames
			//
			
			case "*transfer*":
				$msg = 	$renamedPrefix + 
						eval( $meshLocCmd ) + 
						(uiRes("m_findMenuItem.kNewPolyTransfer"));
				break;			

			// Proxy menu renames
			//
			case "*subdiv polygons*":
				$msg = 	$renamedPrefix + 
						eval( $proxyLocCmd ) + 
						(uiRes("m_findMenuItem.kNewPolySubdivPolyTool"));
				break;
				
			case "*unmirror subdiv polygons*":
				$msg = 	$renamedPrefix + 
						eval( $proxyLocCmd ) + 
						(uiRes("m_findMenuItem.kNewPolyUnmirrorSubdivPolyTool"));
				break;

			case "*poly crease tool*":
				$msg = 	$renamedPrefix + 
						eval( $proxyLocCmd ) + 
						(uiRes("m_findMenuItem.kNewPolyCreaseTool"));
				break;
			case "*soften/harden*":
				string $normalsLoc = eval( $normalsLocCmd );
				$msg = 	$renamedPrefix + 
						$normalsLoc + 
						(uiRes("m_findMenuItem.kNewPolySoftHarden1")) + 
						$normalsLoc +
						(uiRes("m_findMenuItem.kNewPolySoftHarden2")) + 
						$normalsLoc +
						(uiRes("m_findMenuItem.kNewPolySoftHarden3"));
				break;

			// Color menu renames
			//
			case "*set vertex color key*":
				$msg = 	$renamedPrefix + 
						eval( $colorLocCmd ) + 
						(uiRes("m_findMenuItem.kNewPolySetKeyframeForVertexColor"));
				break;

			// Create UVs menu renames
			
			case "*create uvs based on camera*":
				$msg = 	$renamedPrefix + 
						eval( $createUVsLocCmd ) + 
						(uiRes("m_findMenuItem.kNewPolyCameraMapping"));
				break;
				
			// Edit UVs menu renames
			//
			case "*normalize uvs*":
				$msg = 	$renamedPrefix + 
						eval( $editUVsLocCmd ) + 
						(uiRes("m_findMenuItem.kNewPolyNormalizeUVs"));
				break;
				
			case "*unitize uvs*":
				$msg = 	$renamedPrefix + 
						eval( $editUVsLocCmd ) + 
						(uiRes("m_findMenuItem.kNewPolyUnitizeUVs"));
				break;

			case "*flip uvs*":
				$msg = 	$renamedPrefix + 
						eval( $editUVsLocCmd ) + 
						(uiRes("m_findMenuItem.kNewPolyFlipUVs"));
				break;

			case "*rotate uvs*":
				$msg = 	$renamedPrefix + 
						eval( $editUVsLocCmd ) + 
						(uiRes("m_findMenuItem.kNewPolyRotateUVs"));
				break;
			case "*grid uvs*":
				$msg = 	$renamedPrefix + 
						eval( $editUVsLocCmd ) + 
						(uiRes("m_findMenuItem.kNewPolyGridUVs"));
				break;

			case "*align uvs*":
				$msg = 	$renamedPrefix + 
						eval( $editUVsLocCmd ) + 
						(uiRes("m_findMenuItem.kNewPolyAlignUVs"));
				break;

			case "*relax uvs*":
				$msg = 	$renamedPrefix + 
						eval( $editUVsLocCmd ) + 
						(uiRes("m_findMenuItem.kNewPolyRelaxUVs"));
				break;

			case "*unfold uvs*":
				$msg = 	$renamedPrefix + 
						eval( $editUVsLocCmd ) + 
						(uiRes("m_findMenuItem.kNewPolyUnfoldUVs"));
				break;

			case "*layout uvs*":
				$msg = 	$renamedPrefix + 
						eval( $editUVsLocCmd ) +  
						(uiRes("m_findMenuItem.kNewPolyLayoutUVs"));
				break;

			case "*cut uvs*":
				$msg = 	$renamedPrefix + 
						eval( $editUVsLocCmd ) + 
						(uiRes("m_findMenuItem.kNewPolyCutUVs"));
				break;

			case "*sew uvs*":
				$msg = 	$renamedPrefix + 
						eval( $editUVsLocCmd ) + 
						(uiRes("m_findMenuItem.kNewPolySewUVs"));
				break;

			case "*move and sew uvs*":
				$msg = 	$renamedPrefix + 
						eval( $editUVsLocCmd ) + 
						(uiRes("m_findMenuItem.kNewPolyMoveAndSewUVs"));
				break;

			// Tool option items
			//
			case "*convert selection*":
			case "*create meshes single sided*":
			case "*smart command settings*":
				$msg = 	$movedPrefix +
						eval( $windowLocCmd ) + 
						(uiRes("m_findMenuItem.kNewPolyToolOptions"));
				break;

			// Removed items
			//
			case "*keep new	faces planar*":
				$msg = 	$removedPrefix +
						(uiRes("m_findMenuItem.kNewPolyNewFacesPlanar")); 
				break;

			default:
				$retVal = false;
				break;
		}
		
		if ($retVal) break;

	// Maya 7.0, 6.5, 6.0, 5.0 cases
	//
	case 7.0:
	case 6.5:
	case 6.0:
	case 5.0:

	// Maya 4.0 cases
	//
	case 4.0:
		$retVal = true;
		
		$renamedPrefix 	= (uiRes("m_findMenuItem.kRenamedPrefix4"));
		$removedPrefix 	= (uiRes("m_findMenuItem.kRemovedPrefix4"));
		
		switch ($searchString) {
			//
			// Removed items
			//
			case "*layer bar*":
			case "*display layer editor*":
				$msg = 	$removedPrefix +
						(uiRes("m_findMenuItem.kDisplayLayerEditor"));
				break;

			case "*uninstall current settings*":
				$msg = 	$renamedPrefix + 
						(uiRes("m_findMenuItem.kUninstallCurrentSettings"));
				break;

			default:
				$retVal = false;
				break;
		}

		if ($retVal) break;

	// Maya 3.0 cases
	//
	case 3.0:
		$retVal = true;
		
		$renamedPrefix 	= (uiRes("m_findMenuItem.kRenamedPrefix3"));
		$removedPrefix 	= (uiRes("m_findMenuItem.kRemovedPrefix3"));
		
		switch ($searchString) {
			//
			// Removed items
			//
			case "*create display layer*":
				$msg = 	$removedPrefix + 
						(uiRes("m_findMenuItem.kCreateDisplayLayer"));
				break;

			// No helpful suggestions for these
			case "*shading groups*":
			case "*show edits one level finer*":
			case "*run-up and cache*":
			case "*cache current frame*":
				$msg = $removedPrefix;
				break;

			case "*reverse and propagate*":
				$msg = 	$removedPrefix +
						(uiRes("m_findMenuItem.kReverseAndPropagate"));
				break;

			case "*nurbs geometry*":
				$msg = 	$removedPrefix +
						(uiRes("m_findMenuItem.kNurbsGeometry"));
				break;

			case "*add air*":
			case "*add drag*":
			case "*add gravity*":
			case "*add newton*":
			case "*add radial*":
			case "*add turbulence*":
			case "*add uniform*":
			case "*add vortex*":
				$msg = 	$removedPrefix +
						(uiRes("m_findMenuItem.kAttachFields"));
				break;

			//
			// Renamed items
			//
			case "*add emitter*":
				$msg = 	$renamedPrefix +
						(uiRes("m_findMenuItem.kAddEmitter"));
				break;
			case "*connect to field*":
				$msg = 	$renamedPrefix +
						(uiRes("m_findMenuItem.kConnectToField"));
				break;
			case "*connect to emitter*":
				$msg = 	$renamedPrefix +
						(uiRes("m_findMenuItem.kConnectToEmitter"));
				break;
			case "*connect to collision*":
				$msg = 	$renamedPrefix +
						(uiRes("m_findMenuItem.kConnectToCollision"));
				break;
			case "*add to owner*":
				$msg = 	$renamedPrefix +
						(uiRes("m_findMenuItem.kAddToOwner"));
				break;
			case "*scene caching*":
				$msg = 	$renamedPrefix +
						(uiRes("m_findMenuItem.kSceneCaching"));
				break;
			case "*show only viewing panes*":
				$msg = 	$renamedPrefix +
						(uiRes("m_findMenuItem.kViewingPanes"));
				break;
			case "*show all panes*":
				$msg = 	$renamedPrefix +
						(uiRes("m_findMenuItem.kShowAllPanes"));
				break;
			case "*display poly count*":
				$msg = 	$renamedPrefix +
						(uiRes("m_findMenuItem.kDisplayPolyCount"));
				break;
			case "*set normal*":
				$msg = 	$renamedPrefix +
						(uiRes("m_findMenuItem.kSetNormal"));
				break;
			case "*show edits at current level*":
				$msg = 	$renamedPrefix +
						(uiRes("m_findMenuItem.kShowEditsAtCurrentLevel"));
				break;
			case "*refine display region*":
				$msg = 	$renamedPrefix +
						(uiRes("m_findMenuItem.kRefineDisplayRegion"));
				break;
			case "*expand display region*":
				$msg = 	$renamedPrefix +
						(uiRes("m_findMenuItem.kExpandDisplayRegion"));
				break;

			case "*ui preferences*":
			case "*general preferences*":
				$msg = 	$renamedPrefix +
						(uiRes("m_findMenuItem.kPreferences"));
				break;
		
			default:
				$retVal = false;
				break;
		}
		if ($retVal) break;
	}
	
	if ($retVal) {
		scrollField -edit -insertText ($msg + "\n") searchResultsTextField;
	}
	
	return $retVal;
}

global proc searchAllMenus (string $searchStringArg)
{
	if ($searchStringArg == "") {
		scrollField -edit 
			-text (uiRes("m_findMenuItem.kEnterAString"))
			searchResultsTextField;
		return;
	}

	// Clear any old searches
	scrollField -edit -clear searchResultsTextField;
	
	string $searchString;
	if (!`checkBox -q -v searchCaseSensitive`) {
		$searchString = tolower($searchStringArg);
	} else {
		$searchString = $searchStringArg;
	}
	$searchString = "*"+$searchString+"*";

	global string $gSearchLastString;
	$gSearchLastString = $searchStringArg;
	
	global string $gMainWindow;
	int $numMenus = `window -q -nm $gMainWindow`;

	// This should never tbe true
	if ($numMenus < 1 ) exit;

	waitCursor -state on;
	
	string $aMenu;
	string $menuLabel;
    string $menuList[] = `window -q -ma $gMainWindow`;
	
    // Append all menu from the viewport
    string $modelPanelLayoutName = `modelPanel -q -control modelPanel1`;
    string $modelPanelMenuList[] = `menuBarLayout  -q -menuArray $modelPanelLayoutName`;	
    appendStringArray($menuList, $modelPanelMenuList, size($modelPanelMenuList));    
    
    string $path;
	int $gotOne = 0;
	int $gotOldOne = 0;

	for ($aMenu in $menuList) {

		// Make sure nothing really strange is going on
		if (!`menu -exists $aMenu`) continue;

		$menuLabel = `menu -q -l $aMenu`;
			
		// Skip the hotbox menus
		string $s = match("Hotbox", $menuLabel);
		if ($s == "Hotbox") continue;
		if ($aMenu == "HotBoxRecentCommandsMenu") continue;

		$path = $menuLabel+"->";
		if (searchOneMenu($aMenu, $aMenu, $searchString, $path)) {
			$gotOne = 1;
		}
	}

	// Add newline between results and old menu items
	if( $gotOne ){
		scrollField -edit -insertText "\n" searchResultsTextField;
	}
		
	// Search for old menu items
	$gotOldOne = `oldMenuSearch ($searchString)`;

	// Add newline between results and No more matches found message
	if( $gotOldOne ){
		scrollField -edit -insertText "\n" searchResultsTextField;
	}

	if( $gotOne || $gotOldOne ){
		scrollField -edit 
			-insertText (uiRes("m_findMenuItem.kNoMatches"))
			searchResultsTextField;
	} else {
		// If nothing was found then help a little
		scrollField -edit 
			-text (uiRes("m_findMenuItem.kUseWildcard"))
			searchResultsTextField;
	}
	
	waitCursor -state off;
}


global proc findMenuItem ()
{
	global string $gSearchLastString = "";

	//	If the window already exists then just show it and return.
	//
	if (`window -exists menuSearchWindow`) {
		showWindow menuSearchWindow;
		return;
	}

	window 
		-title (uiRes("m_findMenuItem.kFindMenuItem"))
		-iconName (uiRes("m_findMenuItem.kFindMenu"))
		-w 435 -h 250
		menuSearchWindow;
		
	formLayout searchForm;
		text -label (uiRes("m_findMenuItem.kEnterSearchString")) searchDirections;

		textField 
			-cc "searchAllMenus (`textField -q -tx searchStringField`)"
			searchStringField;

		checkBox -label (uiRes("m_findMenuItem.kCaseSensitiveSearch")) -v false searchCaseSensitive;

		scrollField -editable false -height 250 searchResultsTextField;

		button -label (uiRes("m_findMenuItem.kClose"))
			-c "window -e -visible false menuSearchWindow"
			searchCloseButton;

	setParent ..;
	
	int $spacing = 5;
	formLayout -e
		-af searchDirections "left" $spacing
		-af searchDirections "top" $spacing
		
		-af searchStringField "left" $spacing
		-ac searchStringField "top" $spacing searchDirections
		-af searchStringField "right" $spacing
		
		-af searchCaseSensitive "left" $spacing
		-ac searchCaseSensitive "top" 1 searchStringField
		-af searchCaseSensitive "right" $spacing
		
		-af searchResultsTextField "left" $spacing
		-af searchResultsTextField "right" $spacing
		-ac searchResultsTextField "top" 0 searchCaseSensitive
		-ac searchResultsTextField "bottom" $spacing searchCloseButton
		
		-af searchCloseButton "left" $spacing
		-af searchCloseButton "right" $spacing
		-an searchCloseButton "top" 
		-af searchCloseButton "bottom" $spacing
		
		searchForm;
		
	showWindow menuSearchWindow;
}
