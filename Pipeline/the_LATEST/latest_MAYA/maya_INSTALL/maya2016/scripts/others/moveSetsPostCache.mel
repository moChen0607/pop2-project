// Copyright (C) 1997-2014 Autodesk, Inc., and/or its licensors.
// All rights reserved.
//
// The coded instructions, statements, computer programs, and/or related
// material (collectively the "Data") in these files contain unpublished
// information proprietary to Autodesk, Inc. ("Autodesk") and/or its licensors,
// which is protected by U.S. and Canadian federal copyright law and by
// international treaties.
//
// The Data is provided for use exclusively by You. You have the right to use,
// modify, and incorporate this Data into other products for purposes authorized 
// by the Autodesk software license agreement, without fee.
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND. AUTODESK
// DOES NOT MAKE AND HEREBY DISCLAIMS ANY EXPRESS OR IMPLIED WARRANTIES
// INCLUDING, BUT NOT LIMITED TO, THE WARRANTIES OF NON-INFRINGEMENT,
// MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE, OR ARISING FROM A COURSE 
// OF DEALING, USAGE, OR TRADE PRACTICE. IN NO EVENT WILL AUTODESK AND/OR ITS
// LICENSORS BE LIABLE FOR ANY LOST REVENUES, DATA, OR PROFITS, OR SPECIAL,
// DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES, EVEN IF AUTODESK AND/OR ITS
// LICENSORS HAS BEEN ADVISED OF THE POSSIBILITY OR PROBABILITY OF SUCH DAMAGES.


//
//  Description:
//	This method is called to move groupParts nodes for components
//  sets after the cache so that they get included in the cache.
//
//  Input Arguments:
//	  	$shape: the shape of interest
//
proc int checkIsTransform(string $obj)
{
	string $nt[] = `ls -type transform $obj`;
	return size($nt);
}

proc int checkIsDeformerSet(string $obj)
{
	string $conns[] = `listConnections -type geometryFilter $obj`;
	return size($conns);
}

global proc
moveSetsPostCache(string $shape)
{
	string $setsAll[] = `listConnections -type objectSet $shape`;
	string $sets[] = stringArrayRemoveDuplicates($setsAll);

	string $setNames[];
	int $setMemCount[];
	string $setMembers[];

	string $parent[] = `listRelatives -path -parent $shape`;
	string $uniqueName[] = `ls $shape`;
	
	// loop through the sets looking for component sets and save their members
	//
	for ($setName in $sets) {
		int $memCount = 0;

		if (checkIsDeformerSet($setName)) {
			continue;
		}

		string $members[] = `sets -q $setName`;
		for ($mem in $members) {
			string $buff[];
			tokenize($mem,".",$buff);

			if (size($buff) > 1) {
				string $toMatch = checkIsTransform($buff[0]) ? $parent[0] : $uniqueName[0];
				string $matching = `match $toMatch $mem`;
				if (size($matching) == size($toMatch)) {
					$setMembers[size($setMembers)] = $mem;
					if (0 == $memCount) {
						$setNames[size($setNames)] = $setName;
					}
					$memCount++;
				}
			}
		}
		if ($memCount > 0) {
			$setMemCount[size($setMemCount)] = $memCount;
		}
	}

	int $ii, $jj;
	int $index = 0;
	int $setCount = size($setNames);

	for ($ii = 0; $ii < $setCount; $ii++) {
		string $setName = $setNames[$ii];
		for ($jj = 0; $jj < $setMemCount[$ii]; $jj++, $index++) {
			string $flattened[] = `ls -flatten $setMembers[$index]`;
			for ($flatItem in $flattened) {
				sets -rm $setName $flatItem;
			}
		}
	}
	
	$index = 0;
	for ($ii = 0; $ii < $setCount; $ii++) {	
		string $setName = $setNames[$ii];
		for ($jj = 0; $jj < $setMemCount[$ii]; $jj++, $index++) {
			sets -forceElement $setName $setMembers[$index];
		}
	}
}
