// Copyright (C) 1997-2014 Autodesk, Inc., and/or its licensors.
// All rights reserved.
//
// The coded instructions, statements, computer programs, and/or related
// material (collectively the "Data") in these files contain unpublished
// information proprietary to Autodesk, Inc. ("Autodesk") and/or its licensors,
// which is protected by U.S. and Canadian federal copyright law and by
// international treaties.
//
// The Data is provided for use exclusively by You. You have the right to use,
// modify, and incorporate this Data into other products for purposes authorized 
// by the Autodesk software license agreement, without fee.
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND. AUTODESK
// DOES NOT MAKE AND HEREBY DISCLAIMS ANY EXPRESS OR IMPLIED WARRANTIES
// INCLUDING, BUT NOT LIMITED TO, THE WARRANTIES OF NON-INFRINGEMENT,
// MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE, OR ARISING FROM A COURSE 
// OF DEALING, USAGE, OR TRADE PRACTICE. IN NO EVENT WILL AUTODESK AND/OR ITS
// LICENSORS BE LIABLE FOR ANY LOST REVENUES, DATA, OR PROFITS, OR SPECIAL,
// DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES, EVEN IF AUTODESK AND/OR ITS
// LICENSORS HAS BEEN ADVISED OF THE POSSIBILITY OR PROBABILITY OF SUCH DAMAGES.


//
//  Procedure Name:
//      createImportedImagePlane
//
//  Description:
//      Creates an image plane with the file name provided and
//		connects the node to one or more camera shapes
//
//  Input Arguments:
//      imageName : image file name from the browser
//      type : file type
//
//  Return Value:
//      Returns 1 so that the file browser will close.
//
global proc int createImportedMovieImagePlane (string $cameraList[],
                                          string $imageName,
                                          string $type)
{
	// Check whether an image filename was provided 

	if ( $imageName != "" ) {

		if (size($cameraList)) {
			// query orthographic flag
			int $isOrtho = `camera -q -o $cameraList[0]`;

			// create imageplane shape.
			string $newImagePlane[] = createImagePlane($cameraList[0]);

			// set the image plane type to movie file
			setAttr ($newImagePlane[1] + ".type") 2;

			// NOTE: if you changing the way that the attributes
			// for a movie get setup then a similar change
			// needs to be made in the AEassignImageCB script

			// connect to the time line
			setAttr ($newImagePlane[1] + ".useFrameExtension") 1;

			// assign the imageName to the imagePlane
			setAttr ($newImagePlane[1] + ".imageName")
				-type "string" $imageName; 
				
			int $pixmapSize[] = `imagePlane -q -iz $newImagePlane[1]`;
			float $width = (float)$pixmapSize[0] / 100;
			imagePlane -e -w $width $newImagePlane[1];	
	
			// set up expression 
			$nodeAttr = $newImagePlane[1] + ".frameExtension";
			
			// shouldn't happen as it is a new image plane, but make sure that
			// there isn't something attached to it already
			//
			if ( `connectionInfo -isDestination $nodeAttr` == false ) {
				expression -s ($nodeAttr + "=frame" )  ;
			}
        }
	}

    return 1;
}


//  Procedure Name:
//      importImagePlane
//
//  Description:
//      Imports an movie file as an image plane for one or more cameras
//
global proc importMovieImagePlane( string $cameraList[] )
{  	
    if (size($cameraList)) 
    {
        // Set the current working directory to the project's
        // sourceimage directory
	
        string $workspace = `workspace -q -fullName`; 	

        setWorkingDirectory $workspace "image" "movie";
	
		string $cameraListString = stringArrayToString($cameraList, "\",\"");
		$cameraListString = "{ \"" + $cameraListString + "\" }";

        string $cmd = ("createImportedMovieImagePlane " + $cameraListString);

        string $open = (uiRes("m_importMovieImagePlane.kOpen"));
        fileBrowser ($cmd, $open, "movie", 0);        
    }
}
