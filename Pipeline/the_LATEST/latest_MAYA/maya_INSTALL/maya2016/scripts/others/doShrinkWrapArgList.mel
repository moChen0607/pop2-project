// Copyright (C) 1997-2014 Autodesk, Inc., and/or its licensors.
// All rights reserved.
//
// The coded instructions, statements, computer programs, and/or related
// material (collectively the "Data") in these files contain unpublished
// information proprietary to Autodesk, Inc. ("Autodesk") and/or its licensors,
// which is protected by U.S. and Canadian federal copyright law and by
// international treaties.
//
// The Data is provided for use exclusively by You. You have the right to use,
// modify, and incorporate this Data into other products for purposes authorized 
// by the Autodesk software license agreement, without fee.
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND. AUTODESK
// DOES NOT MAKE AND HEREBY DISCLAIMS ANY EXPRESS OR IMPLIED WARRANTIES
// INCLUDING, BUT NOT LIMITED TO, THE WARRANTIES OF NON-INFRINGEMENT,
// MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE, OR ARISING FROM A COURSE 
// OF DEALING, USAGE, OR TRADE PRACTICE. IN NO EVENT WILL AUTODESK AND/OR ITS
// LICENSORS BE LIABLE FOR ANY LOST REVENUES, DATA, OR PROFITS, OR SPECIAL,
// DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES, EVEN IF AUTODESK AND/OR ITS
// LICENSORS HAS BEEN ADVISED OF THE POSSIBILITY OR PROBABILITY OF SUCH DAMAGES.

//
//  Description:
//      Procedures to create a shrink wrap deformer
//

proc string[] getSelectedSurfs( int $ignoreLast )
//
// Description:
//     Loops through the selection list and finds all the shapes
//     that are below the transforms.  It fills an array with 
//     the parent transforms of all these shapes. 
//
{
	string $surfs[];

	// Get the selection list
	//
	string $selectedItems[] = `ls -sl`;
	int $numSelected = size($selectedItems);

	int $ii;
	int $last = $numSelected;
	if ( $ignoreLast )
		$last -= 1;
	int $surfCount = 0;
	string $buffer[];
	for($ii=0;$ii < $last; $ii++)
	{
		clear($buffer);
		string $trans = $selectedItems[$ii];
		int $numTokens = tokenize($selectedItems[$ii],".",$buffer);
		if ($numTokens > 0) {
			$trans = $buffer[0];
		}
		string $isShape[] = `ls -type controlPoint -type particle $trans`;
		if (0 == size($isShape)) {
			if ($numTokens > 1) {
				// a component was selected
				//
				int $jj;
				int $foundSurf = 0;
				for ($jj = 0; $jj < $surfCount; $jj++) {
					clear($buffer);
					int $numTokens = tokenize($surfs[$jj],".",$buffer);
					if ($numTokens > 1) {
						if ($buffer[0] == $trans) {
							$surfs[$jj] = ($surfs[$jj]+" "+$selectedItems[$ii]);
							$foundSurf = 1;
							break;
						}
					}
				}
				if (! $foundSurf) {
					$surfs[$surfCount++] = $selectedItems[$ii];
				}
			} else {
				string $surfShapes[] = `ls -dag -type controlPoint -type particle $trans`;
				string $surf;
				for($surf in $surfShapes)
				{
					// Disregard intermediate objects
					//
					int $io = `getAttr ($surf+".io")`;
					if (!$io)
					{
						string $parentL[] = `listRelatives -path -p $surf`;
						$surfs[$surfCount++] = $parentL[0];
					}
				}
			}
		} else {
			string $rel[] = `listRelatives -path -p $trans`;
			$surfs[$surfCount++] = ($rel[0]+"|"+$trans);
		}
	}
	return $surfs;
}

proc string getTargetMesh(string $targetTrans)
//
// Description:
//       Checks if there are any mesh objects
//       under the given transform
{
	// Find all the shapes under the given transform
	//
	string $shapes[] = `ls -dag -shapes $targetTrans`;

	// Find if at least one of them is an allowable target type
	//
	string $shape;
	for($shape in $shapes)
	{
		int $io = `getAttr ($shape+".io")`;
		if ($io == 1)
			continue;

		string $type = `nodeType($shape)`;
		if ($type == "mesh")
		{
			return $shape;
		}

	}

	error( (uiRes("m_doShrinkWrapArgList.kInfluenceObjects")));

	return "";
}

proc string getInnerShape(string $targetTrans)
//
// Description:
//       Checks if there are any suitable objects
//       under the given transform
{
	// Find all the shapes under the given transform
	//
	string $shapes[] = `ls -dag -shapes $targetTrans`;

	// Find if at least one of them is an allowable target type
	//
	string $shape;
	for($shape in $shapes)
	{
		int $io = `getAttr ($shape+".io")`;
		if ($io == 1)
			continue;

		string $type = `nodeType($shape)`;
		if ($type == "mesh" || $type == "nurbsCurve" || $type == "nurbsSurface")
		{
			return $shape;
		}

	}

	error( (uiRes("m_doShrinkWrapArgList.kInnerObjects")));

	return "";
}

proc string[] createShrinkWrap( int $projection, int $closestIfNoIntersection, int $reverse, int $bidirectional, 
								int $boundingBoxCenter, int $axisReference, int $alongX, int $alongY, int $alongZ,
								float $offset, float $targetInflation, int $singleNode )
//
//  Description:
//		Creates a new shrink wrap node for the selected geometries
//      and connect a target object (the last element of the 
//      selection list). 
{
	string $returnStr[];

	// Get the selection list
	//
	string $selectedItems[] = `ls -sl`;
	int $numSelected = size($selectedItems);
	
	if ($numSelected < 2)
	{
		error( (uiRes("m_doShrinkWrapArgList.kSelectAtLeast")));
		return $returnStr;
	}

	// The influence object is always the last element of the 
	// selection list
	//
	string $target = $selectedItems[$numSelected-1];
	string $targetMesh = getTargetMesh( $target );

	int $ii;
	
	// Find all the surf transforms that have been selected
	//
	string $selectedSurfs[] = getSelectedSurfs( 1 );
	int $numSurfs = size($selectedSurfs);

	if ($numSurfs == 0)
	{
		error( (uiRes("m_doShrinkWrapArgList.kNoDeformableSel")));
		return $returnStr;
	}

	// Create the shrinkwrap deformer for first surface,
	// then add the remaining surfaces.
	//
	string $shrinkwrapNode = "";
	for($ii=0; $ii < $numSurfs; $ii++)
	{
		string $surface = $selectedSurfs[$ii];
		string $surfaceShape = $surface;
		string $buffer[];
		int $numTokens = tokenize($surface," ",$buffer);
		if ($numTokens > 0) {
			string $bufferNew[];
			$numTokens = tokenize($buffer[0],".",$bufferNew);
			if ($numTokens > 0) {
				$buffer = `listRelatives -path -ni -type controlPoint -type particle $bufferNew[0]`;
				$surfaceShape = $buffer[0];
			}
		}

		if ( $ii == 0 || $singleNode == 0 )
		{
			string $shrinkwrapNodeL[];
			if (catch($shrinkwrapNodeL =  evalEcho("deformer -type shrinkWrap "+$surface)) ||
				size($shrinkwrapNodeL) == 0)
			{
				string $errFormat = (uiRes("m_doShrinkWrapArgList.kFailedToCreateShrinkWrap"));
				string $errMsg = `format -stringArg $surface $errFormat`;
				error( $errMsg );
				continue;
			}
			$shrinkwrapNode = $shrinkwrapNodeL[0];
	
			// Set the shrinkwrap parameters
			//
			setAttr ($shrinkwrapNode + ".projection") $projection;
			setAttr ($shrinkwrapNode + ".closestIfNoIntersection") $closestIfNoIntersection;
			setAttr ($shrinkwrapNode + ".reverse") $reverse;
			setAttr ($shrinkwrapNode + ".bidirectional") $bidirectional;
			setAttr ($shrinkwrapNode + ".boundingBoxCenter") $boundingBoxCenter;
			setAttr ($shrinkwrapNode + ".axisReference") $axisReference;
			setAttr ($shrinkwrapNode + ".alongX") $alongX;
			setAttr ($shrinkwrapNode + ".alongY") $alongY;
			setAttr ($shrinkwrapNode + ".alongZ") $alongZ;
			setAttr ($shrinkwrapNode + ".offset") $offset;
			setAttr ($shrinkwrapNode + ".targetInflation") $targetInflation;
			
			// Add the target object
			//
			connectAttr ($targetMesh + ".w") ($shrinkwrapNode + ".tgt");
			// connect up the smooth target attributes
			// so the smoothed target follows the target shape's settings
			//
			connectAttr ($targetMesh + ".co") ($shrinkwrapNode + ".co");
			connectAttr ($targetMesh + ".suv") ($shrinkwrapNode + ".suv");
			connectAttr ($targetMesh + ".kb") ($shrinkwrapNode + ".kb");
			connectAttr ($targetMesh + ".bnr") ($shrinkwrapNode + ".bnr");
			connectAttr ($targetMesh + ".khe") ($shrinkwrapNode + ".khe");
			connectAttr ($targetMesh + ".peh") ($shrinkwrapNode + ".peh");
			connectAttr ($targetMesh + ".kmb") ($shrinkwrapNode + ".kmb");
			
			$returnStr[$ii] = $shrinkwrapNode;
		}
		else
		{
			if ( catch( evalEcho("deformer -e -g " + $surface + " " + $shrinkwrapNode) ) )
			{
				string $errFormat = (uiRes("m_doShrinkWrapArgList.kFailedToAddToShrinkWrap"));
				string $errMsg = `format -stringArg $surface -stringArg $shrinkwrapNode $errFormat`;
				error( $errMsg );
				continue;
			}
		}
		
	}

	return $returnStr;
}

proc string[]  findShrinkWrapFromSurf( string $surfTrans, int $future )
//
// Description:
//     This procedure returns the shrinkwrap nodes that are associated
//     with the given surface
// 
{
	string $shrinkwraps[];

	string $histList[] = `listHistory -f $future $surfTrans`;
	string $hist;
	int $shrinkwrapCount = 0;
	for($hist in $histList)
	{
		if (nodeType($hist) == "shrinkWrap")
			$shrinkwraps[$shrinkwrapCount++] = $hist;
	}
	
	return $shrinkwraps;
}

proc string[] findAllSelectedShrinkWrapNodes( int $ignoreLast )
//
// Description:
//     Returns a list of all the shrinkwrap nodes that are associated 
//     with the current selection list.
//     The list returned also contains any shrinkwrap nodes that might be in the 
//     selection list
// 
{
	string $shrinkwrapNodeList[];
	int $shrinkwrapCount = 0;

	// Get a complete list of the selected surfaces
	//
	string $selectedSurfs[] = getSelectedSurfs( $ignoreLast );
	int $numSurfs = size($selectedSurfs);
	
	// find the shrinkwrap node(s) associated with each selected surface
	//
	int $ii;
	for($ii=0; $ii < $numSurfs; $ii++)
	{
		string $surf = $selectedSurfs[$ii];
		string $surfShrinkWraps[] = findShrinkWrapFromSurf( $surf, 0 );
		if (size($surfShrinkWraps)==0)
		{
			string $errFormat = (uiRes("m_doShrinkWrapArgList.kNoShrinkWrapDeformer"));
			string $errMsg = `format -stringArg $surf $errFormat`;
			error( $errMsg );
			continue;
		}
		string $surfShrinkWrap;
		for ($surfShrinkWrap in $surfShrinkWraps)
			$shrinkwrapNodeList[$shrinkwrapCount++] = $surfShrinkWrap;
	}

	// Get any items in the selection list that are shrinkwrap nodes
	// 
	string $selectedShrinkWrapNodes[] = `ls -sl -type shrinkWrap`;
	string $selectedShrinkWrap;
	for($selectedShrinkWrap in $selectedShrinkWrapNodes)
		$shrinkwrapNodeList[$shrinkwrapCount++] = $selectedShrinkWrap;

	return $shrinkwrapNodeList;

}

proc string[] setCommon( string $attr )
{
	string $returnStr[];

	// Get the selection list
	//
	string $selectedItems[] = `ls -sl`;
	int $numSelected = size($selectedItems);

	if ($numSelected < 2)
	{
		error( (uiRes("m_doShrinkWrapArgList.kSelectSurfaceOrShrinkWrap")));
		return $returnStr;
	}

	// The target object is always the last element of the selection list
	//
	string $target = $selectedItems[$numSelected-1];
	string $targetMesh;
	if ( $attr == ".tgt" )
		$targetMesh	= getTargetMesh( $target );
	else
		$targetMesh	= getInnerShape( $target );
	string $type = `nodeType($targetMesh)`;
	string $worldSpaceAttr;
	if ( $type == "mesh" )
		$worldSpaceAttr = ".w";
	else
		$worldSpaceAttr = ".ws";

	// Get all the corresponding shrinkwrap nodes
	//
	string $shrinkwrapNodeList[] = findAllSelectedShrinkWrapNodes( 1 );
	
	// add the target
	//
	for ( $shrinkwrapNode in $shrinkwrapNodeList )
	{
		string $conns[] = `listConnections -s 1 -d 0 -p 1 ($shrinkwrapNode + $attr)`;
		for ( $conn in $conns )
		{
			disconnectAttr $conn ($shrinkwrapNode + $attr);
		}
		connectAttr ($targetMesh + $worldSpaceAttr) ($shrinkwrapNode + $attr);
	}
	
	return $shrinkwrapNodeList;
}

proc string[] setTarget()
{
	return setCommon( ".tgt" );
}

proc string[] setInnerObject()
{
	return setCommon( ".in" );
}

proc string[] removeCommon( string $attr )
{
	// Get all the selected shrinkwrap nodes
	//
	string $shrinkwrapNodeList[] = findAllSelectedShrinkWrapNodes( 0 );
	
	// disconnect the target
	//
	for ( $shrinkwrapNode in $shrinkwrapNodeList )
	{
		string $conns[] = `listConnections -s 1 -d 0 -p 1 ($shrinkwrapNode + $attr)`;
		for ( $conn in $conns )
		{
			disconnectAttr $conn ($shrinkwrapNode + $attr);
		}
	}
	
	return $shrinkwrapNodeList;
}

proc string[] removeTarget()
{
	return removeCommon( ".tgt" );
}

proc string[] removeInnerObject()
{
	return removeCommon( ".in" );
}

proc string[] addSurfaces()
{
	string $returnStr[];

	// Get the selection list
	//
	string $selectedItems[] = `ls -sl`;
	int $numSelected = size($selectedItems);

	if ($numSelected < 2)
	{
		error( (uiRes("m_doShrinkWrapArgList.kSelectSurfaceAndShrinkWrap")));
		return $returnStr;
	}

	// The target object is always the last element of the selection list
	//
	string $target = $selectedItems[$numSelected-1];
	string $surfShrinkWraps[] = findShrinkWrapFromSurf( $target, 1 );
	if (size($surfShrinkWraps)==0)
	{
		string $errFormat = (uiRes("m_doShrinkWrapArgList.kNoShrinkWrapDeformerForTarget"));
		string $errMsg = `format -stringArg $target $errFormat`;
		error( $errMsg );
		return $returnStr;
	}

	// Get all the surfaces to add
	//
	string $selectedSurfs[] = getSelectedSurfs( 1 );
	
	// Add the surfaces
	//
	string $surf;
	for ( $surf in $selectedSurfs )
	{
		string $cmd = "deformer -e -g " + $surf + " " + $surfShrinkWraps[0];
		evalEcho( $cmd );
	}
	
	return $surfShrinkWraps;
}

proc string[] removeSurfaces()
{
	string $shrinkwrapNodeList[];
	int $shrinkwrapCount = 0;

	// Get a complete list of the selected surfaces
	//
	string $selectedSurfs[] = getSelectedSurfs( 0 );
	int $numSurfs = size($selectedSurfs);
	
	// find the shrinkwrap node(s) associated with each selected surface
	//
	int $ii;
	for($ii=0; $ii < $numSurfs; $ii++)
	{
		string $surf = $selectedSurfs[$ii];
		string $surfShrinkWraps[] = findShrinkWrapFromSurf( $surf, 0 );
		if (size($surfShrinkWraps)==0)
		{
			string $errFormat = (uiRes("m_doShrinkWrapArgList.kNoShrinkWrapDeformerForSurface"));
			string $errMsg = `format -stringArg $surf $errFormat`;
			error( $errMsg );
			continue;
		}
		// remove the surface from the shrinkwrap node
		//
		string $surfShrinkWrap;
		for ($surfShrinkWrap in $surfShrinkWraps)
		{
			$shrinkwrapNodeList[$shrinkwrapCount++] = $surfShrinkWrap;
						
			string $cmd = "deformer -e -rm -g " + $surf + " " + $surfShrinkWrap;
			evalEcho( $cmd );
		}
	}

	return $shrinkwrapNodeList;
}

global proc string [] doShrinkWrapArgList( string $version,
									 string $args[] )
//  Description:
//		Starting point of all wrap operations
//
//  Input Arguments:
//      version:  The version used.
//		args[]:
//   Version 1:	
//        	[0]	: operation:  	1 - Create a new shrinkwrap
//								2 - Set target object
//								3 - Remove target object
//								4 - Set inner object
//								5 - Remove inner object
//								6 - Add surfaces
//								7 - Remove surfaces
//			[1]	: projection
//			[2]	: closestIfNoIntersection
//			[3]	: reverse
//			[4]	: bidirectional
//			[5]	: boundingBoxCenter
//			[6]	: axisReference
//			[7]	: alongX
//			[8]	: alongY
//			[9]	: alongZ
//			[10]: offset
//			[11]: targetInflation
//			[12]: singleNode
//
//  Return Value:
//      [string] The name of the shrinkwrap node involved in the operation
//
{
	int $operation = $args[0];

	switch ( $operation )
	{
	case 1:
		int $projection = $args[1];
		int $closestIfNoIntersection = $args[2];
		int $reverse = $args[3];
		int $bidirectional = $args[4];
		int $boundingBoxCenter = $args[5];
		int $axisReference = $args[6];
		int $alongX = $args[7];
		int $alongY = $args[8];
		int $alongZ = $args[9];
		float $offset = $args[10];
		float $targetInflation = $args[11];
		int $singleNode = $args[12];
		return createShrinkWrap( $projection, $closestIfNoIntersection, $reverse, $bidirectional, 
								 $boundingBoxCenter, $axisReference, $alongX, $alongY, $alongZ, $offset, $targetInflation,
								 $singleNode );
	case 2:
		return setTarget();
	case 3:
		return removeTarget();
	case 4:
		return setInnerObject();
	case 5:
		return removeInnerObject();
	case 6:
		return addSurfaces();
	case 7:
		return removeSurfaces();
	}
}
