// Copyright (C) 1997-2014 Autodesk, Inc., and/or its licensors.
// All rights reserved.
//
// The coded instructions, statements, computer programs, and/or related
// material (collectively the "Data") in these files contain unpublished
// information proprietary to Autodesk, Inc. ("Autodesk") and/or its licensors,
// which is protected by U.S. and Canadian federal copyright law and by
// international treaties.
//
// The Data is provided for use exclusively by You. You have the right to use,
// modify, and incorporate this Data into other products for purposes authorized 
// by the Autodesk software license agreement, without fee.
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND. AUTODESK
// DOES NOT MAKE AND HEREBY DISCLAIMS ANY EXPRESS OR IMPLIED WARRANTIES
// INCLUDING, BUT NOT LIMITED TO, THE WARRANTIES OF NON-INFRINGEMENT,
// MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE, OR ARISING FROM A COURSE 
// OF DEALING, USAGE, OR TRADE PRACTICE. IN NO EVENT WILL AUTODESK AND/OR ITS
// LICENSORS BE LIABLE FOR ANY LOST REVENUES, DATA, OR PROFITS, OR SPECIAL,
// DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES, EVEN IF AUTODESK AND/OR ITS
// LICENSORS HAS BEEN ADVISED OF THE POSSIBILITY OR PROBABILITY OF SUCH DAMAGES.

//
//  Procedure Name:
//      ghostAppendedClip
//
//  Description:
//      This function makes sure the clipGhost node n/w is up to date
//      after an operation (e.g., splitting or duplicating) that can 
//      add an additional clip. To determine if a ghost should be added
//      we check if the original node that was split or duplicated had a
//      ghost. If it did, a ghost is added for the new clip as well. 
//      Otherwise, we setup the n/w correctly to permit a ghost to be 
//      added in the future.
//
// Input Arguments:
//      $sch         : The name of the scheduler managing the clips
//      $newClips[0] : The original clip that was duped/split
//      $newClips[1] : The new clip created as part of the operation
//      $option      : 0 - Do nothing
//                     1 - Copy Translation/Rotation offsets to new clip
//                     2 - Match clips so that new clip starts where old clip ends
//

proc string getOffsetObject( string $character )
{
    string $element = "";
    if ( size( $character ) )
    {
        string $object[] = `character -q -aoo $character`;
        if ( size( $object ) )
            $element = $object[0];
    }
    return $element;
}

proc matchClips( string $clips[] )
{
    string $character = getClipCharacter( $clips[0] );
    if ( size( $character ) == 0 )
        return;

    string $element = getOffsetObject( $character );
    if ( size($element) )
        clipMatching -mt 1 -mr 1 -cs $clips[1] 0.0 -cd $clips[0] 1.0 $character $element;
}

global proc ghostAppendedClip( string $scheduler, string $newClips[], int $option )
{
    // If the provided scheduler is invalid, bail. Don't issue a warning
    // as this can happen under various "normal" workflows.
    if (size($scheduler) == 0)
        return;

    // Check if the character has an offset object. If so, this is an
    // indication that other clips in the scene may be ghosted. To 
    // ensure that ghosting will also work correctly on this new
    // clip, run the procedure that 'sanitizes' clips, reusing the
    // current offset object. If some channels on the new clip are in
    // relative mode, the user will also be queried to see if these
    // channels should be changed to absolute.
    // 
    if ( size( $newClips[1] ) )
    {
        string $character[] = `clipSchedule -q -character $scheduler`;
        if ( size( $character ) )
        {
            string $offset = getOffsetObject( $character[0] );
            if ( size( $offset ) )
                verifyClipsAreValid( $character[0], $offset );
        }
    }

    // Get the clipToGhost node for the scheduler
    string $clipToGhost = getClipToGhostForScheduler($scheduler);
    if (size( $clipToGhost ) == 0)
        return;

    // Make sure the depend graph is modified to account for 
    // changes in clip order
    ghostReorderConnections($scheduler);

    // Hook up the new node to the clipToGhost node
    connectClipAndClipToGhost($newClips[1], $clipToGhost, $scheduler);

    // Next, create a clip ghost on the new clip
    performCreateClipGhost({ $newClips[1] });

    // If there is no original clip, or the original clip was not ghosted, bail.
    if (size($newClips[0]) == 0 ||
        clipsAreGhosted( { $newClips[0] } ) == false)
        return;

    // Copy the number of intermediate poses from the original clip onto the new clip
    string $ghost = getGhostShapeForClip($newClips[0]);
    if (size($ghost))
    {
        int $n = `getAttr ( $ghost + ".intermediatePoses")`;
        $ghost = getGhostShapeForClip($newClips[1]);
        if (size($ghost))
            setAttr ( $ghost + ".intermediatePoses") $n;
    }

    switch($option)
    {
        case 2:
            matchClips  $newClips; 
            return;

        case 1:
        default:
            return;
    }
}
