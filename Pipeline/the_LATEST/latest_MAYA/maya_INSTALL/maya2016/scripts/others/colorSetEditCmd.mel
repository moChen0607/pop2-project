// Copyright (C) 1997-2014 Autodesk, Inc., and/or its licensors.
// All rights reserved.
//
// The coded instructions, statements, computer programs, and/or related
// material (collectively the "Data") in these files contain unpublished
// information proprietary to Autodesk, Inc. ("Autodesk") and/or its licensors,
// which is protected by U.S. and Canadian federal copyright law and by
// international treaties.
//
// The Data is provided for use exclusively by You. You have the right to use,
// modify, and incorporate this Data into other products for purposes authorized 
// by the Autodesk software license agreement, without fee.
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND. AUTODESK
// DOES NOT MAKE AND HEREBY DISCLAIMS ANY EXPRESS OR IMPLIED WARRANTIES
// INCLUDING, BUT NOT LIMITED TO, THE WARRANTIES OF NON-INFRINGEMENT,
// MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE, OR ARISING FROM A COURSE 
// OF DEALING, USAGE, OR TRADE PRACTICE. IN NO EVENT WILL AUTODESK AND/OR ITS
// LICENSORS BE LIABLE FOR ANY LOST REVENUES, DATA, OR PROFITS, OR SPECIAL,
// DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES, EVEN IF AUTODESK AND/OR ITS
// LICENSORS HAS BEEN ADVISED OF THE POSSIBILITY OR PROBABILITY OF SUCH DAMAGES.


//  Procedure Name:
//		renameColorSet
//
//  Description:
//		Renames the specified CPV set by popping a window for the user to enter
//		a new name.
//
//  Input Arguments:
//      $currentColorSetName:	the name of the colorSet to rename
//
//  Return Value:
//      None.
//
global proc renameColorSet( string $currentColorSetName ) {

	string $baseSetName = $currentColorSetName;
	string $buffer[];
	if (tokenize($currentColorSetName,"()", $buffer) > 1) {
		$baseSetName = $buffer[0];
	}

	// Prompt the user for a new colorSet name
	//
	string $ok     = (uiRes("m_colorSetEditCmd.kOk"));
	string $cancel = (uiRes("m_colorSetEditCmd.kCancel"));
	string $result = `promptDialog 
		-title (uiRes("m_colorSetEditCmd.kRenameColorSet"))
		-message (uiRes("m_colorSetEditCmd.kEnterNewColorSetName"))
		-text $baseSetName
		-button $ok 
		-button $cancel 
		-defaultButton $ok 
		-cancelButton $cancel 
		-dismissString $cancel`;

	// If the result was "OK", then proceed
	//
	if ( $result == $ok ) {

		// Query the promptDialog for the name the
		// user typed in - note: there is no checking
		// being done for illegal characters, spaces,
		// etc.  This should be added.
		//
		string $newColorSetName = `promptDialog -q`;
		if (gmatch($newColorSetName, "*(*") || gmatch($newColorSetName, "*)*")) {
			string $badNaming = (uiRes("m_colorSetEditCmd.kColorSetBadNaming"));
			error $badNaming;
			return;
		}

		string $cmd = ("polyColorSet -rename -colorSet "+$baseSetName+
					   " -newColorSet "+$newColorSetName);
		evalEcho $cmd;
	} 
}



//  Procedure Name:
//		colorSetEditCmd
//
//  Description:
//		Creates the commands for editting multiple CPV sets.
//
//  Input Arguments:
//      $cmd:	the command to process. Valid commands are new, rename, delete,
//				copy, setCurrent
//		$scrollList:	the name of the scrollList from the colorSetEditor. If
//				this is "none" then the commands are being called from the 
//				pulldown menu items.
//
//  Return Value: 
//      None.
//
global proc colorSetEditCmd( string $cmd, string $scrollList ) 
{
	colorSetEditCmdNew($cmd, $scrollList, 0, "RGBA", 0);
}



//  Procedure Name:
//		colorSetEditCmdNew
//
//  Description:
//		Creates the commands for editting multiple CPV sets.
//
//  Input Arguments:
//      $cmd: the command to process. Valid commands are new, rename, delete,
//	      copy, setCurrent
//	$scrollList: the name of the scrollList from the colorSetEditor. If
//		     this is "none" then the commands are being called from the 
//		     pulldown menu items.
//	$clamped: the color set is in 0 to 1 range
//	$representation: A, RGB, RGBA
//	$sharing: 0 = "shared", 1 = "perInstanceShared", or 2 = "perInstanceUnshared"
//
//  Return Value: 
//      None.
//
global proc colorSetEditCmdNew( string $cmd, string $scrollList,
								int $clamped, string $representation,
								int $sharing ) 
{
	source "artAttrColorPerVertexCallback.mel";

	//	typically, user will have transform selected so find mesh shapes
	//
	string $objects[] = `listRelatives -s -noIntermediate -fullPath -type "mesh"`; 

	//	if there is nothing, check to see if shapes are selected
	//
	if (!`size $objects`)
		$objects = `ls -sl -type "mesh"`;

	//	if there is still nothing, check to see if components are selected
	//
	if (!`size $objects`)
		$objects = `listRelatives  -p -noIntermediate -fullPath -type "mesh"`;

	if (`size $objects`){

		string $selSets[];
		//	if $scrollList == "none" we are working on
		//	current set on current mesh 
		//
		string $tmpArray[];
		if ($scrollList != "none"){
			$selSets = `textScrollList -q -si $scrollList`;
			int $i;
			if (size($selSets) == 0)
			{
				// If selSets is empty the following loop will not
				// execute, and selSets[] will be empty when we
				// try to use it later.
				
				$selSets[0] = $scrollList;
			}
			else
			{
				for($i=0; $i < size($selSets); $i++) {
					tokenize($selSets[$i], "()", $tmpArray);
					string $acs[] = `polyColorSet -colorSet $tmpArray[0] -q -pi`;
					$selSets[$i] = $acs[0];
					if ($selSets[$i] == $tmpArray[0]) {
						if (size($tmpArray) > 1) {
							$representation = $tmpArray[1];
						}
					} else {
						if (size($tmpArray) > 2) {
							$representation = $tmpArray[2];
						}
					}
				}
			}
		} else {
			$selSets = `polyColorSet -q -currentColorSet`;
		}
		string $mergeWarning = (uiRes("m_colorSetEditCmd.kMergeColorSetsWarn")) ;
		switch( $cmd ) {
		case "new":
			//	create a new set on each active mesh
			//
			string $cmd = ("polyColorSet -create -clamped "+$clamped);
			$cmd += (" -rpt "+$representation+" -colorSet \"colorSet\"");
			if ($sharing > 0) {
				$cmd += (" -perInstance true");
				if ($sharing == 2) {
					$cmd += (" -unshared");
				}
			}
			evalEcho $cmd;
			if (`window -exists colorSetEditor`) 
				updateColorSetEditor;
			break;
		case "rename":
			//	Rename the selected set
			//
			renameColorSet $selSets[0];
			if (`window -exists colorSetEditor`) 
				updateColorSetEditor;
			break;
		case "delete":
			//	Delete the selected sets
			//
			for( $set in $selSets ) {
				string $cmd = ("polyColorSet -delete -colorSet \""+$set+"\"");
				for ($obj in $objects) {
					$cmd += (" "+$obj);
				}
				evalEcho $cmd;
			}
			if (`window -exists colorSetEditor`) 
				updateColorSetEditor;
			break;
			
		case "modify":
			//	Modify the selected set
			//
			for( $set in $selSets ) {
				string $node[] = `polyColorMod -bcn $set $objects`;
				showEditor($node[0]);
			}
			
			if (`window -exists colorSetEditor`) 
				updateColorSetEditor;
			break;

		case "copy":
			//	copy selected cpv set
			//
			if( size( `ls -sl` ) == 0 ) {
				string $copyWarning = (uiRes("m_colorSetEditCmd.kCopyColorSetWarning"));
				warning( `format -s $selSets[0] $copyWarning` );
				return;
			}
			for ($set in $selSets){
				polyColorSet -copy -colorSet $set ;
			}
			if (`window -exists colorSetEditor`) 
				updateColorSetEditor;
			break;
		case "setCurrent":
			//	set the selected cpv set current
			//  Note: if we have two meshes selected, we don't want to
			//  operate on non-existent color sets)
			//
			string $cmd = ("polyColorSet -currentColorSet -colorSet \""+$selSets[0]+"\"");
			evalEcho $cmd;
			break;
		case "merge":
			//	merge the selected cpv sets
			//
			if( size($selSets) < 2 || size($selSets) > 2 ) {
				warning( $mergeWarning );
				return;
			}

			int $blendMode = `optionMenu -q -select colorSetBlendMode`;
			int $blend =  0; // "alpha";  // default setting
			float $weight1 = 0;
			float $weight2 = 0;
			float $weight3 = 0;
			float $weight4 = 0;

			switch ($blendMode){
				case 1:
					$blend = 0; // "alpha";
					break;
				case 2:
					$blend = 1; // "multiply"; 
					break;
				case 3:
					$blend = 7; // "multiplyRGBA"; 
					break;		
				case 4:
					$blend = 2; // "add"; 
					break;
				case 5:
					$blend = 3; // "subtract";
					break;
				case 6:
					$blend = 4; // "linear";
					$weight1 = 0.5;
					break;
				case 7:
					$blend = 5; // "bilinear";
					$weight1 = 0.5;
					$weight2 = 1.0;
					break;
				case 8:
					$blend = 6; // "colorChannel";
					$weight1 = 0.5;
					$weight2 = 0.5;
					$weight3 = 0.5;
					$weight4 = 0.5;
					break;
			}

			polyBlendColor -bcn $selSets[1]
				-src $selSets[0] 
				-dst $selSets[0]
				-bfn $blend 
				-bwa $weight1
				-bwb $weight2
				-bwc $weight3
				-bwd $weight4;

			polyColorSet -delete -colorSet $selSets[1] $objects;

			if (`window -exists colorSetEditor`) 
				updateColorSetEditor;
			break;
		case "blend":
			//	blend the selected cpv sets
			//
			if( size($selSets) < 2 || size($selSets) > 2 ) {
				warning( $mergeWarning );
				return;
			}
			int $blendMode = `optionMenu -q -select colorSetBlendMode`;
			int $blend;
			float $weight1 = 0;
			float $weight2 = 0;
			float $weight3 = 0;
			float $weight4 = 0;

			switch ($blendMode){
				case 1:
					$blend = 0; // "alpha";
					break;
				case 2:
					$blend = 1; // "multiply"; 
					break;
				case 3: 
					$blend = 7; // "multiplyRGBA"; 
					break;					
				case 4:
					$blend = 2; // "add"; 
					break;
				case 5:
					$blend = 3; // "subtract";
					break;
				case 6:
					$blend = 4; // "linear";
					$weight1 = 0.5;
					break;
				case 7:
					$blend = 5; // "bilinear";
					$weight1 = 0.5;
					$weight2 = 1.0;
					break;
				case 8:
					$blend = 6; //"colorChannel";
					$weight1 = 0.5;
					$weight2 = 0.5;
					$weight3 = 0.5;
					$weight4 = 0.5;
					break;
			}

			string $newSet[] = `polyColorSet -create -clamped $clamped -rpt $representation -colorSet "blendedColorSet"`;
			polyBlendColor -bcn $selSets[1]
				-src $selSets[0] 
				-dst $newSet[0]
				-bfn $blend 
				-bwa $weight1
				-bwb $weight2
				-bwc $weight3
				-bwd $weight4
				;
			if (`window -exists colorSetEditor`) 
				updateColorSetEditor;
			break;
		
		}

		if (`currentCtx` == "artAttrColorPerVertexContext")
			artAttrColorPerVertexValues("artAttrColorPerVertexContext");
	}
}
