// Copyright (C) 1997-2014 Autodesk, Inc., and/or its licensors.
// All rights reserved.
//
// The coded instructions, statements, computer programs, and/or related
// material (collectively the "Data") in these files contain unpublished
// information proprietary to Autodesk, Inc. ("Autodesk") and/or its licensors,
// which is protected by U.S. and Canadian federal copyright law and by
// international treaties.
//
// The Data is provided for use exclusively by You. You have the right to use,
// modify, and incorporate this Data into other products for purposes authorized 
// by the Autodesk software license agreement, without fee.
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND. AUTODESK
// DOES NOT MAKE AND HEREBY DISCLAIMS ANY EXPRESS OR IMPLIED WARRANTIES
// INCLUDING, BUT NOT LIMITED TO, THE WARRANTIES OF NON-INFRINGEMENT,
// MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE, OR ARISING FROM A COURSE 
// OF DEALING, USAGE, OR TRADE PRACTICE. IN NO EVENT WILL AUTODESK AND/OR ITS
// LICENSORS BE LIABLE FOR ANY LOST REVENUES, DATA, OR PROFITS, OR SPECIAL,
// DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES, EVEN IF AUTODESK AND/OR ITS
// LICENSORS HAS BEEN ADVISED OF THE POSSIBILITY OR PROBABILITY OF SUCH DAMAGES.

//
//
//  Creation Date:  May 16, 2002
//
//
// Description:
//
//
//
//

global string $updateUIProcs[];


// Description: Returns a string identifying the current renderer.
//
global proc string currentRenderer()
{
	return `getAttr defaultRenderGlobals.currentRenderer`;
}


// Description: Sets the currentRenderer attribute to the specified renderer.
//
global proc int setCurrentRenderer(string $renderer)
{
	if( assertIsValidRenderer($renderer) )
	{
		// Matched. Set attribute and return success
		setAttr "defaultRenderGlobals.currentRenderer" -type "string" $renderer;
		return 1;
	}
	return 0;
}

//
// Description: Check currentRenderer exists.
//              Defaults to "mayaSoftware" if the renderer
// 				does not exist.
//

global proc verifyCurrentRenderer()
{
	// Verify that the current renderer is actually available.
	// It is possible that we have loaded a new scene in which the current
	// renderer was set to some renderer which is no longer available.
	//
	string $currentRenderer = currentRenderer();

	// Old code that sets currentRenderer to preferredRenderer
	// is moved to TrenderBasket::setCurrentRendererCallback

	if (!`renderer -exists $currentRenderer`)
	{
		string $msg = (uiRes("m_supportRenderers.kUnavailableRenderer"));
		string $defaultRenderer = "mayaSoftware";
		warning(`format -stringArg $currentRenderer $msg`);

        {
			setAttr
				"defaultRenderGlobals.currentRenderer"
				-type "string"
            	$defaultRenderer;
        }
	}
}

// Description: called when the currentRenderer attribute is changed
//				All render related UI changes are done here
//
global proc int rendererChanged()
{
    if (!`about -batch`)
    {
		if ((currentRenderer() == "mayaHardware") &&
			(! `hwRender -q -limitedRenderSupport`))
		{
			warning (uiRes("m_supportRenderers.kInsufficientGraphics"));
		}

		// Do additional UI changes here
		//
        updateRendererUI();
    }

	return 1;
}

// Description: Used to register an update UI procedure (a proc that
// updates any renderer specific UI created in that script)
//
// Returns: None
//
global proc registerUpdateRendererUIProc(string $procName)
{
	global string $updateUIProcs[];

	int $lastIdx = size($updateUIProcs);
	$updateUIProcs[$lastIdx] = $procName;
}


// Description: Calls procedures within the UI modules to update their respective
//				renderer related UI
//
global proc updateRendererUI()
{
	// We only update the UI if it actually exists. If we are in batch
	// mode, the UI does not exist.
	//
	if (!`about -batch`)
	{
		global string $updateUIProcs[];

		for ($i = 0; $i < size($updateUIProcs); $i++)
		{
			eval $updateUIProcs[$i];
		}
	}
}

// Description: raises an error if the renderer specified does not exists
//
global proc int assertIsValidRenderer(string $renderer)
{
	if(!`renderer -exists $renderer`)
	{
		string $msg = (uiRes("m_supportRenderers.kInvalidRenderer"));
		error -showLineNumber true `format -stringArg $renderer $msg`;
		return 0;
	}
	return 1;
}

global proc rendererSceneOpenedCallback()
{
	//
	// Description:
	//	This procedure is called when a scene is opened (which also happens on
	//	File->New).
	//	This procedure calls procedures which initialize the current renderer
	//	attribute and refresh rendering related UI correspondingly.
	//

	// make sure that currentRenderer is available
	//
	verifyCurrentRenderer();

	// Set up a scriptJob to react when the value of the
	// attribute changes.
	//
	scriptJob
        -killWithScene
		-attributeChange
			"defaultRenderGlobals.currentRenderer"
			"rendererChanged;";

	// Call the rendererChanged() procedure explicitly since the
	// verifyCurrentRenderer() procedure call above may have changed
	// the current renderer.
	//
	rendererChanged();

	// mental ray file compatibility
	if(!`about -evalVersion` && `exists mentalrayCompatibility` ) {
		mentalrayCompatibility;
	}
}

//
// Description: Called when a selection is made in the current renderer option
// menu. Sets the current renderer.
//
// Returns: None
//
global proc updateCurrentRendererSel(string $menu)
{
	string $selRenderer = `optionMenu -query -value $menu`;
	string $renderers[] = `renderer -query -namesOfAvailableRenderers`;
	string $rendererUIName = "";

	for ($i = 0; $i < size($renderers); $i += 1)
	{
        $rendererUIName = `renderer -query -rendererUIName $renderers[$i]`;
		if($selRenderer == $rendererUIName)
			break;
	}

	// If the select renderer is not installed, produce error
	//
	if($i == size($renderers))
	{
		error 	-showLineNumber	true
	       		($rendererUIName + " does not exist ");
	}
	else
	{
		setCurrentRenderer($renderers[$i]);
        string $cmd = "loadPreferredRenderGlobalsPreset(\"" + $renderers[$i] + "\")";
        evalDeferred $cmd;  
	}
}

// Description:  This procedure is called to initialize the
//  defaultRenderGlobals.currentRenderer dynamic attribute if it does
//  not exist yet, and set up callbacks for renderer related actions
//  which need to be executed during SceneOpened.
//
global proc setupRendererSceneOpenedCallback()
{
    // Create the defaultRenderGlobals.currentRenderer dynamic attribute
    // if it does not exist yet.
    //
    verifyCurrentRenderer();

    // Invoke the scene opened callback explicitly, since the event has already
    // occurred by the time this script is sourced during Maya startup. We want
    // everything that procedure does to also happen during startup.
    //
    evalDeferred rendererSceneOpenedCallback;

    // Set up a script job to call the scene opened callback whenever a new scene
    // is opened.
    //
    evalDeferred "scriptJob -event SceneOpened rendererSceneOpenedCallback;";
}

global proc string[] rendererListRenderTargetSupport()
{
    string $rtRenderers[] = { "mentalRay" };

    return $rtRenderers;
}

global proc int rendererRenderTargetSupport(string $renderer)
{
    string $renderers[] = rendererListRenderTargetSupport();

    for ($r in $renderers) {
       if ($r == $renderer) {
         return true;
       }
    }
    return false;
}

global proc int renderTargetHasInput(string $rt)
{
  if ($rt == "") {
    error((uiRes("m_supportRenderers.kEmptyRenderTarget")));
  }
  string $colorAttr = ($rt + ".color");
  string $alphaAttr = ($rt + ".alpha");
  string $colorSrc = `connectionInfo -sfd $colorAttr`;
  string $alphaSrc = `connectionInfo -sfd $alphaAttr`;
  int $hasInput = (size($colorSrc) > 0) || (size($alphaSrc) > 0);
  return $hasInput;
}

global proc renderTargetWarnIfNoInput(string $rt)
{
  if ($rt != "" && !renderTargetHasInput($rt)) {
    string $msg =
      (uiRes("m_supportRenderers.kRenderTargetHasNoInput"));
    $msg = `format -stringArg $rt $msg`;
    warning ($msg);
  }
}

//
//  Procedure Name:
//      checkOGSRendererDevice
//
//  Description:
//		Check the current renderer device.
//
//  Input Arguments:
//      string - Current editor panel
//
//  Return Value:
//      string - Name of the OGS renderer device. If not OGS, return "";
//

global proc string checkOGSRendererDevice(string $editor)
{
	return `modelEditor -q -rdn $editor`;		
}

//
//  Procedure Name:
//      onscreenPlayblastSupported
//
//  Description:
//		Check if the current renderer device support onscreen playblast.
//		OGS/DX mode do not support.
//
//  Input Arguments:
//      string - Current editor panel
//
//  Return Value:
//      int -	1: Support onscreen playblast;
//				0: Not support onscreen playblast;
//
global proc int onscreenPlayblastSupported(string $editor)
{
	int $onScreen = 1;	
	string $currentRendererDevice = checkOGSRendererDevice($editor);
	if ($currentRendererDevice == "VirtualDeviceDx11") {
		$onScreen = 0;
	}
	return $onScreen;
}