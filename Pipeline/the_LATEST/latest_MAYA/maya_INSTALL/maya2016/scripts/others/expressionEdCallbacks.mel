// Copyright (C) 1997-2014 Autodesk, Inc., and/or its licensors.
// All rights reserved.
//
// The coded instructions, statements, computer programs, and/or related
// material (collectively the "Data") in these files contain unpublished
// information proprietary to Autodesk, Inc. ("Autodesk") and/or its licensors,
// which is protected by U.S. and Canadian federal copyright law and by
// international treaties.
//
// The Data is provided for use exclusively by You. You have the right to use,
// modify, and incorporate this Data into other products for purposes authorized 
// by the Autodesk software license agreement, without fee.
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND. AUTODESK
// DOES NOT MAKE AND HEREBY DISCLAIMS ANY EXPRESS OR IMPLIED WARRANTIES
// INCLUDING, BUT NOT LIMITED TO, THE WARRANTIES OF NON-INFRINGEMENT,
// MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE, OR ARISING FROM A COURSE 
// OF DEALING, USAGE, OR TRADE PRACTICE. IN NO EVENT WILL AUTODESK AND/OR ITS
// LICENSORS BE LIABLE FOR ANY LOST REVENUES, DATA, OR PROFITS, OR SPECIAL,
// DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES, EVEN IF AUTODESK AND/OR ITS
// LICENSORS HAS BEEN ADVISED OF THE POSSIBILITY OR PROBABILITY OF SUCH DAMAGES.

//
//
//  ==================== expressionEdCallbacks.mel ==========
//
//  SYNOPSIS
//
//  CONTENTS
//		(The procs are in the file in the order listed here.)
//
//	Expression Editor Procedures:
//
//
//  Expression Editor UI control callbacks:
//
//	EEapplyCB				Create/Edit the expression.
//	EEdeleteCB				Delete the expression.
//	EErestoreCB				Restore the expression.
//	EEclearCB				Clear the text area.
//  EEcloseCB				Close the window.
//	EEanimatedCB			Callback for animated checkbox.
//	EEunitConversionCB		Callback for unit conversion radio group.
//	EEexprNameTextCB		Callback for expression name textfield.
//	EEdefaultNodeCB			Callback for default node name textfield.
//	EEselectedNodeAttrCB	Callback for node-attribute name textfield.
//	EEnewExpressionCB		Callback for "New Expression" Button.
//	EEnodeListCB			User selected something (sngl click) in node list.
//	EEnodeListDblClickCB	User selected something (dbl click) in node list
//	EEattrListCB			User selected something (sngl click)in attr list.
//	EEattrListDblClickCB	User selected something (dbl click) in attr list.
//	EEselectFilterCB		User selected something in the Select menu.
//	EEobjFilterCB			User selected something in the Obj Filter menu.
//	EEattrFilterCB			User selected something in the Attr Filter menu.
//  EEeditorCB				User selected something in editors opt menu.
//	EErulesCB				User selected a rules radio button.
//	EEmathFuncCB()      	User selected a math function menu.
//	EEvectFuncCB()			User selected a vector function menu.
//	EEconvFuncCB()			User selected a conversion function menu.
//	EEarrayFuncCB()			User selected a array function menu.
//	EErandFuncCB()      	User selected a random number function menu.
//
//	Expression Editor Message Callbacks
//		These are called from TexprEdListenAction.cc
//
//  EEactiveListChanged   	Callback for active list changed.
//  EEnodeAdded 			Callback for a node added to a scene.
//  EEnodeRemoved 			Callback for a node removed from the scene.
//  EEnodeNameChanged 		Callback for a node name change in the scene.
//  EEattributeAdded      	Callback for attribute added to selected node.
//  EEattributeRemoved    	Callback for attribute removed from selected node.
//	EEexpressionCreated		Callback for expression created.
//	EEexpressionEdited		Callback for expression edited.
//	EEparticleExpressionCreated	Callback for particle expression created.
//	EEparticleExpressionDeleted	Callback for particle expression deleted.
//	EEparticleExpressionEdited	Callback for particle expression edited.
//	EEclearExpresionEditor		Callback for file new/open to clear editor.
//	EEresetExpressionEditor		Callback for file open to rebuild the editor.


// ******************************************************************
//
//					EXPRESSION EDITOR CALLBACKS
//
// 
//  ================ EEapplyCB ================
//
//  SYNOPSIS
//      Create the expression in the editor and connect it to
//		to the current selected attribute or
//		replace its current expression with the newly edited one.
//
//
global proc EEapplyCB()
{
	global int $EEobjIsParticle;
	global int $EEcreateMode;
	global string $EEnodeMode;

	string $theText;
	string	$noExpressionWarning = (uiRes("m_expressionEdCallbacks.kNoExprToCreate"));

	// Get the value of the text and create or edit the expression node 
	//
	$theText = `scrollField -query -text EEmultiText`;

	if (size($theText) == 0 && $EEcreateMode)
	{
		warning $noExpressionWarning;
		return;
	}

	if (size($theText) > 0)
	{
		int $lastIndex = size($theText);
		string $firstChar = substring($theText, 1, 1);
		string $lastChar = substring($theText, $lastIndex, $lastIndex);

		// Strip the final carriage returns and spaces.
		//
		while ($lastChar == "\n" || $lastChar == " ")
		{
			if ($lastIndex == 1)
			{
				$theText = "";
				break;
			}
			else
			{
				$theText = substring($theText, 1, size($theText) - 1);
				$lastIndex = $lastIndex - 1;
				$lastChar = substring($theText, $lastIndex, $lastIndex);
			}
		}

		if (size($theText) == 0 && $EEcreateMode)
		{
			warning $noExpressionWarning;
			return;
		}

		// If there are quotes surrounding the expression, strip 
		// them 
		//
		if ($firstChar == "\"")
		{
			$theText = substring ($theText, 2, size($theText));
		}
		if ($lastChar == "\"")
		{
			$theText = substring ($theText, 1, size($theText) - 1);
		}
	}

	
	if ($EEobjIsParticle)
	{
		string $objAttrName = `textFieldGrp -query -text EEselNameT`;
		string $buffer[];
		tokenize($objAttrName, ".", $buffer);
		string $nodeName = $buffer[0];
        	string $inputConnections[] = `listConnections -plugs on -destination off -source on ($nodeName + ".deformedPosition")`;
		if( size($inputConnections) > 0 ) {
			warning (uiRes("m_expressionEdCallbacks.kDeformedparticlesNoExpr"));
			return;
		}

		if ($EEcreateMode)
		{
			EEapplyParticleExpression($theText);
		}
		else
		{
			// If there's no attribute selected, we are definitely
			// doing a dynExprression.  If there is one selected,
			// we have to find out what kind of expression it is
			// connected to.
			//
			int $isDynExpression = 1;
			if (size($buffer[1]))
				$isDynExpression = EEisDynExpression($objAttrName);

			if ($isDynExpression)
				EEapplyParticleExpression($theText);
			else
				EEapplyExpression($theText);
		}
	}
	else
	{
		if ($EEnodeMode == "scriptNode") 
		{
			EEapplyScript($theText);
		} 
		else 
		{
			EEapplyExpression($theText);
		}
	}

}	// EEapplyCB



//  ================ EErestoreCB ================
//
//  SYNOPSIS
//      Restore the expression in the expression node to the
//		editor text area.
//
//
global proc EErestoreCB()
{
	global int $EEobjIsParticle;
	global string $EEnodeMode;

	string $currObjAttrName;

	if ($EEnodeMode == "expression")
	{
		EErestoreExpression();
	}
	else if ($EEnodeMode == "scriptNode")
	{
		EErestoreScript();
	}
	else
	{
		if ($EEobjIsParticle)
		{
			EErestoreParticleExpression();
		}
		else
		{
			EErestoreExpression();
		}
	}

}	// EErestoreCB


//  ================ EEclearCB ================
//
//  SYNOPSIS
//      Clear the text.
//
//
global proc EEclearCB()
{
	scrollField -edit -text "" EEmultiText;

}	// EEclearCB


//  ================ EEcloseCB =================
//
//  SYNOPSIS
//      Close the expression editor window
//
//
global proc EEcloseCB()
{
    deleteUI expressionEditorWin;

}   // EEcloseCB


//  ================ EEanimatedCB ================
//
//  SYNOPSIS
//      Called when the animated checkbox is changed.
//
global proc EEanimatedCB()
{
	global int $EEcreateMode;
	global int $EEeditedInEditor;
	global string $EEcurrExpressionName;

	// If in edit mode, reset the expression animated value immediately.
	//
	if (!$EEcreateMode)
	{
		int $anType = `optionMenu -query -select EEanimTypeOM`; 
		$EEeditedInEditor = 1;

		int $optionVal = $anType - 1; // Since command's option is 0 based
	
		evalEcho("expression -edit -alwaysEvaluate " + $optionVal + " " + $EEcurrExpressionName);
	}

}	// EEanimatedCB


//  ================ EEunitConversionCB ================
//
//  SYNOPSIS
//      Called when the unit conversion radio set is changed.
//
global proc EEunitConversionCB(string $thePref)
{
	global int $EEcreateMode;
	global int $EEobjIsParticle;
	global int $EEeditedInEditor;
	global string $EEcurrExpressionName;

	// If in edit mode, reset the expression unit conversion preference
	// immediately.
	//
	if (!$EEcreateMode)
	{
		if (!$EEobjIsParticle)
		{
			$EEeditedInEditor = 1;
			evalEcho("expression -edit -unitConversion "+$thePref+" "+$EEcurrExpressionName);
		}
	}

}	// EEunitConversionCB


//  ================ EEexprNameTextCB ================
//
//  SYNOPSIS
//      Called when the expression name textfield is changed.
//
global proc EEexprNameTextCB()
{
	global string $EEcurrExpressionName;
	global string $EEcurrFileExprName[];
	global int	  $EEexpressionInEditor;
	global int $EEcreateMode;
	global int $EEcurrentEditor;
	global int $EEeditedInEditor;
	global string $EEnodeMode;

	string $exprName = `textField -query -text EEexprNameT`;

	// If $exprName == "" and in edit mode, then return text field 
	// to what it was
	//
	if( $exprName == "" && !$EEcreateMode)
	{
		if (size($EEcurrExpressionName) > 0)
		{
           	textField -edit -text $EEcurrExpressionName EEexprNameT;
		}
       	else
		{
           	textField -edit -text "" EEexprNameT;
		}
		return;
	}

	// If $exprName == $currExpressionName, it means either
	// that the new name has already been processed, or the
	// field was touched but nothing changed.  So just return.
	// (The former can happen if the user does not press carriage
	// return, and then selects "Apply", because there is
	// no focus-out callback available in ELF.)
	//
	if ($exprName == $EEcurrExpressionName)
		return;

	// If the name the user typed is already the name of an
	// expression node then it is not valid; the EEcheckValidExprName
	// proc will remove it and restore the previous name, and return
	// 0.
	//
	int $nameValid;
	if ($EEnodeMode == "scriptNode")
	{
		if ($nameValid = EEcheckValidScriptName($exprName)) 
		{
			if (!$EEcreateMode)
			{
				//	 If in edit mode, rename the script
				//
				$EEeditedInEditor = 1;
				$exprName = 
					evalEcho("rename "+$EEcurrExpressionName+" "+$exprName);
				
				textFieldGrp -edit -text $exprName EEselScriptNodeNameT;

				// If the user is in a text editor mode, have to update to
				// the new expression name in the file array.
				//
				if ($EEexpressionInEditor > -1 && $EEcurrentEditor != 1)
				{
					if ($EEcurrFileExprName[$EEexpressionInEditor] == $EEcurrExpressionName)
						$EEcurrFileExprName[$EEexpressionInEditor] = $exprName;
				}

				$EEcurrExpressionName = $exprName;
				textField -edit -text $EEcurrExpressionName EEexprNameT;

				if (EEscriptNameExists($exprName))
					EEupdateExprList();
			}
		}
	}
	else 
	{
		if ($nameValid = EEcheckValidExprName($exprName))
		{
			// If in edit mode, rename the expression immediately.
			if (!$EEcreateMode)
			{
				$EEeditedInEditor = 1;
				$exprName = evalEcho("expression -edit -name \""+$exprName+"\" "+$EEcurrExpressionName+"\n");

				// If the user is in a text editor mode, have to update to
				// the new expression name in the file array, if this is
				// not a particle expression.
				//
				if ($EEexpressionInEditor > -1 && $EEcurrentEditor != 1)
				{
					if ($EEcurrFileExprName[$EEexpressionInEditor] == $EEcurrExpressionName)
						$EEcurrFileExprName[$EEexpressionInEditor] = $exprName;
				}
			}
			$EEcurrExpressionName = $exprName;
			textField -edit -text $EEcurrExpressionName EEexprNameT;

			// If the user is in select-by-expression mode, update the
			// list of expressions with the new name, if the new name
			// is an existing expression.  Otherwise the user is creating
			// a name for a new expression.
			//
			if (EEexprNameExists($exprName))
				EEupdateExprList();
		}
	}

}	// EEexprNameTextCB

//  ================ EEdefaultNodeCB ================
//
//  SYNOPSIS
//      Called when the Default Object name textfield is changed.
//
global proc EEdefaultNodeCB()
{
	global int $EEcreateMode;
	global int $EEeditedInEditor;
	global string $EEcurrExpressionName;

    string  $newObjName;

    // Get the newly typed Object name
    //
   	$newObjName = `textFieldGrp -query -text EEdefNameT`;

	if (size($newObjName) == 0)
	{
		textFieldGrp -edit -text "" EEdefNameT;
		return;
	}
	if (!EEisValidNodeName($newObjName))
	{
		textFieldGrp -edit -text "" EEdefNameT;
		return;
	}
	if (!$EEcreateMode)
	{
		$EEeditedInEditor = 1;
		evalEcho("expression -edit -object "+$newObjName+" "+$EEcurrExpressionName+"\n");
	}

}	// EEdefaultNodeCB


//  ================ EEselectedNodeAttrCB ================
//
//  SYNOPSIS
//      Called when the selected object.attribute name textfield 
//		is changed.
//
global proc EEselectedNodeAttrCB()
{
    string $currentAttrs[];
	string $nodeNames[], $names[];
	int $attrListIndex;
	
	string $objAttrName = `textFieldGrp -query -text EEselNameT`;
	string $buffer[];
	tokenize($objAttrName, ".", $buffer);
	string $nodeName = $buffer[0];
	string $attrName = $buffer[1];
	string $notAnAttrFormat = (uiRes("m_expressionEdCallbacks.kNotAndAttr"));

	if (size($nodeName) == 0 && size($attrName) == 0)
	{
		// The textfield is empty, so deselect everything
		// and clear controls.
		//
		EEclearAllControls();

		textScrollList -edit -deselectAll EEnodeList;
		textScrollList -edit -deselectAll EEattrList;

        return;
	}

	if (size($attrName) == 0 )
	{
		// There's only one name in the textfield:  start out by
		// assuming it's an attribute name.
		//
		$attrName = $nodeName;

		// If the name is in the attribute list for the currently
		// selected object, load it.
		//
		if ((($attrListIndex = EEattrIsInList($attrName)) > -1) ||
			(($attrListIndex = EEgetAttrFromNode($attrName)) > -1))
		{
			EEnewSelectedAttr($attrListIndex);

			// Get the name of the current object and long name of the
			// newly typed attribute for future reference.
			//
			$names = `textScrollList -query -selectItem EEnodeList`;
			$nodeName = $names[0];
			$names = `textScrollList -query -selectItem EEattrList`;
			$attrName = $names[0];

		}
		else 
		{
			// The name is not in the attribute list, so it must
			// be an object name.  Deselect the selected attribute
			// in the attribute list;  clear the controls (the obj
			// name will be re-instated later); if the name is in
			// the object list, make it selected, and build its
			// attribute list.
			//
			textScrollList -edit -deselectAll EEattrList;
			EEclearAllControls();

			if (EEnodeIsInList($nodeName) > -1)
			{
				EEnewSelectedNode($nodeName);
				$attrName = "";
			}
			else 
			{
				// Name is not in object list. Check if it's a valid
				// object in the scene and if it is:
				// Reset the filter to all dag objs or dep nodes, rebuild
				// the object list, make the new object selected, and
				// build its attribute list.
				//
				if (EEisValidNodeName($nodeName))
				{
					EEresetFilterToAll($nodeName);
					EEnewSelectedNode($nodeName);
					$attrName = "";
				}
				else
				{
					// Reset the textfield with the current obj/attr name,
					// if there is one .
					//
					string $names[];
					$names = `textScrollList -query -selectItem EEnodeList`;
					$nodeName = $names[0];
					$names = `textScrollList -query -selectItem EEattrList`;
					$attrName = $names[0];
				}
			}
		}
	}
	else 
	{
		// User typed object.attribute 

		// Is the object currently selected in the object list?
		//
		$nodeNames = `textScrollList -query -selectItem EEnodeList`;
		if ($nodeName == $nodeNames[0])
		{
			// Make the newly typed attribute selected, if it's really
			// an attribute of the currently selected object.
			//
			if ((($attrListIndex = EEattrIsInList($attrName)) > -1) ||
				(($attrListIndex = EEgetAttrFromNode($attrName)) > -1))
			{
				EEnewSelectedAttr($attrListIndex);
				$names = `textScrollList -query -selectItem EEattrList`;
				$attrName = $names[0];
			}
			else 
			{
				string $notAnAttr = `format -stringArg $attrName -stringArg $nodeName $notAnAttrFormat`;
				warning $notAnAttr;
			}
		}
		else if (EEnodeIsInList($nodeName) > -1)
		{
			// User typed an object, and it is in the object list.  So
			// make it selected, and build its attribute list.  Then
			// make the newly typed attribute selected, if it's a 
			// valid attribute name.
			//
			EEnewSelectedNode($nodeName);

			if ((($attrListIndex = EEattrIsInList($attrName)) > -1) ||
				(($attrListIndex = EEgetAttrFromNode($attrName)) > -1))
			{
				EEnewSelectedAttr($attrListIndex);
				$names = `textScrollList -query -selectItem EEattrList`;
				$attrName = $names[0];
			}
			else 
			{
				string $notAnAttr = `format -stringArg $attrName -stringArg $nodeName $notAnAttrFormat`;
				warning $notAnAttr;
			}
		}
		else 
		{
			// User typed an object name that's not in the object list. 
			// If it's a valid object, reset filter to all dag objs or
			// dep nodes (for consistency in lists), rebuild the object
			// list, make the new object selected, and build its
			// attribute list.
			//
			if (EEisValidNodeName($nodeName))
			{
				EEresetFilterToAll($nodeName);
				EEnewSelectedNode($nodeName);
				if (($attrListIndex = EEattrIsInList($attrName)) > -1)
				{
					EEnewSelectedAttr($attrListIndex);
					$names = `textScrollList -query -selectItem EEattrList`;
					$attrName = $names[0];
				}
				else 
				{
						string $notAnAttr = `format -stringArg $attrName -stringArg $nodeName $notAnAttrFormat`;
						warning $notAnAttr;
				}
			}
		}
	}

	// Re-write the textfield to make sure the long attribute name is 
	// in it.
	//
	if (size($attrName) > 0)
	{
		string $newString = $nodeName+"."+$attrName;
		textFieldGrp -edit -text $newString  EEselNameT;
	}

	clear($buffer);
	clear($currentAttrs);
	clear($nodeNames);

}	// EEselectedNodeAttrCB



//  ================ EEnewExpressionCB ================
//
//  SYNOPSIS
//      Called when the "New Expression" button is selected.
//
global proc EEnewExpressionCB(int $launchEditor)
{
	global string $EEnodeMode;
	global int $EEobjIsParticle;
	global int $EEcurrentEditor;
	global int $EEdoLaunchTextEd;

	string $currObjAttr;
	string $buffer[];

	if ( $EEobjIsParticle)
		$currObjAttr = `textFieldGrp -query -text EEselNameT`;
	else
		$currObjAttr = `textFieldGrp -query -text EEdefNameT`;

	tokenize($currObjAttr, ".", $buffer);

	if ($EEnodeMode == "object")
	{
		// If in object mode and the current selected attribute already
		// is connected to an expression, then the new expression will
		// be unrelated to it, so deselect it.
		//
		string $expression = `scrollField -query -text EEmultiText`;
		if (size($expression) > 0)
			textScrollList -edit -deselectAll EEattrList;
	}
	else
	{
		textScrollList -edit -deselectAll EEnodeList;
	}

	if ($EEcurrentEditor != 1 && $launchEditor)
		$EEdoLaunchTextEd = 1;

	// When user choose to new a script node, we should set the radio button EEscriptNodeRefEditsRBG
	// to the default item "Record".
	// The default value indicates that reference edits will be recorded during the execution of
	// the script node.
	// 
	radioButtonGrp -edit -select 1 EEscriptNodeRefEditsRBG;
		
	EEdisplayNoExpression($buffer[0]);

}	// EEnewExpressionCB


//  ================ EEdeleteCB ================
//
//  SYNOPSIS
//      Delete the expression in the editor.
//
//
global proc EEdeleteCB()
{
	global int $EEobjIsParticle;
	global int $EEexpressionType;
	global string $EEnodeMode;
	global int $EEcreateMode;

	if ($EEcreateMode)
	{
		warning (uiRes("m_expressionEdCallbacks.kNothingToDelete"));
		return;
	}

	// Delete the expression.
	//
	if ($EEobjIsParticle)
	{
		// To delete a particle expression, just blank it out.
		//
		string $objAttrName = `textFieldGrp -query -text EEselNameT`;
		string $buffer[];
		tokenize($objAttrName, ".", $buffer);
		string $nodeName = $buffer[0];
		string $attrName = $buffer[1];

		EEdynExpressionCmd($EEexpressionType, "", $nodeName);
	}
	else
	{
		// Get the expression name, and call delete on it.
		//
		string $exprName = `textField -query -text EEexprNameT`;
		evalEcho("delete "+$exprName);
	}

	// Re-set to new expression mode
	//
	EEnewExpressionCB(0);

}	// EEdeleteCB

//  ================ EEnodeListCB ================
//
//  SYNOPSIS
//      Something in the scrolled text list of nodes is selected.
//
global proc EEnodeListCB()
{
	global string $EEcurrSelectedNode;
	global string $EEnodeMode;
	global int $EEobjIsParticle;
	global int $EEdoLaunchTextEd;
	global int $EEpExpressionInEditor;
	global int $EEexpressionInEditor;

	string $nodeName[];

	$nodeName = `textScrollList -query -selectItem EEnodeList`;

	// Here and below have to take into account that the user may
	// have clicked (esp. double-clicked) on the node that is 
	// currently already in the editor.  In that case, the only
	// thing that needs to be done is launch a text editor, if the
	// the user double-clicked.
	//
	if ($nodeName[0] != $EEcurrSelectedNode)
	{
		// Stop the attribute changed message for the previous selection.
		//
		if (size($EEcurrSelectedNode) > 0)
			expressionEditorListen -sla $EEcurrSelectedNode;

		// Whatever text editor file may have been for the current
		// expression, it isn't now, because a new node was selected.
		//
		$EEpExpressionInEditor = -1;
		$EEexpressionInEditor = -1;

		// Start the attribute changed message for the new selection
		//
		expressionEditorListen -listenForAttr $nodeName[0];
	}

	if (EEisParticle($nodeName[0]))
	{
		$EEobjIsParticle = 1;
		EEparticleListChanged($nodeName[0]);
	}
	else
	{
		$EEobjIsParticle = 0;
		if ($EEnodeMode == "object")
			EEobjectListChanged($nodeName[0]);
		else if ($EEnodeMode == "scriptNode")
		{
			attrEnumOptionMenu -edit 
				-attribute ($nodeName[0] + ".scriptType") EEscriptNodeTypeAOM;

			EEscriptListChanged($nodeName[0]);
		}
		else
			EEexpressionListChanged($nodeName[0]);
	}

	$EEcurrSelectedNode = $nodeName[0];
	$EEdoLaunchTextEd = 0;

	clear ($nodeName);

}	// EEnodeListCB


//  ================ EEnodeListDblClickCB ================
//
//  SYNOPSIS
//      Something in the scrolled text list of nodes is selected with
//		double click
//
global proc EEnodeListDblClickCB()
{
	global int $EEdoLaunchTextEd;

	$EEdoLaunchTextEd = 1;

	EEnodeListCB();

}	// EEnodeListDblClickCB


//  ================ EEattrListCB ================
//
//  SYNOPSIS
//      Something in the scrolled text list of attributes is selected.
//
global proc EEattrListCB()
{
	global int $EEobjIsParticle;
	global int $EEcurrentEditor;
	global int $EEdoLaunchTextEd;

	string $nodeName[], $attrName[];

	// Get the newly selected attribute name, and the current object
	// name in the list, and load them.
	//
	$attrName = `textScrollList -query -selectItem EEattrList`;
	$nodeName = `textScrollList -query -selectItem EEnodeList`;

	EEloadNewNodeAttr($nodeName[0], $attrName[0]);

}	// EEattrListCB


//  ================ EEattrListDblClickCB ================
//
//  SYNOPSIS
//      Something in the scrolled text list of attributes is selected
//		with double click.
//
global proc EEattrListDblClickCB()
{
	global int $EEdoLaunchTextEd;
	string $nodeName[], $attrName[];

	$EEdoLaunchTextEd = 1;

	EEattrListCB();

}	// EEattrListDblClickCB


//  ================ EEselectFilterCB ================
//
//  SYNOPSIS
//      Called when the "Select Filter" menu is changed.
//
global proc EEselectFilterCB(string $whichMethod)
{
	// Set up the requested layout.
	//
	EEswitchSelectLayout($whichMethod);

	EErebuildNodeList($whichMethod);

	if ($whichMethod == "object")
	 	button -edit -enable false EEnewExpButton;
	else	
	 	button -edit -enable true EEnewExpButton;

}	// EEselectFilterCB


//  ================ EEobjFilterCB ================
//
//  SYNOPSIS
//      Called when the Object Filter menu is changed.
//
global proc EEobjFilterCB(string $whichFilter)
{
	global string $EEnodeMode;
	global string $EEcurrNodeFilter;

	$EEcurrNodeFilter = $whichFilter;

    if ($EEnodeMode == "object")
		EErebuildNodeList($EEnodeMode);

}	// EEobjFilterCB


//  ================ EEattrFilterCB ================
//
//  SYNOPSIS
//      Called when the Attribute Filter menu is changed.
//
global proc EEattrFilterCB(string $whichFilter)
{
	global string $EEnodeMode;
	global string $EEcurrAttrFilter;

	$EEcurrAttrFilter = $whichFilter;

    if ($EEnodeMode == "object")
	{
		// Rebuild the attribute list if there is a selected
		// object in the object list.  If there was a selected
		// attribute in the list and it is still in the list,
		// make it selected again.
		//
		string $selAttr[] = `textScrollList -query -selectItem EEattrList`;
		string $selObj[] = `textScrollList -query -selectItem EEnodeList`;

		if (size($selObj[0]) > 0) 
			EErebuildAttrList($selObj[0]);

		if (size($selAttr[0]) > 0)
		{
			if (EEattrIsInList($selAttr[0]) > -1)
				textScrollList -edit -selectItem $selAttr[0] EEattrList;
		}
	}

}	// EEattrFilterCB


//  ================ EEeditorCB ================
//
//  SYNOPSIS
//      Called when the Editor Type option menu is changed.
//
global proc EEeditorCB()
{
	global int $EEcurrentEditor;
	global int $EEobjIsParticle;

	string $buffer[];
	string $winEditor;
	string $theEditor, $theMessage;

	$EEcurrentEditor = `optionMenu -query -select EEeditorOM`; 

	if (`about -linux`)
	{
		switch($EEcurrentEditor)
		{
			case 1:	$theEditor = "Expression";
					break;
			case 2:	$theEditor = "emacs";
					break;
			case 3:	$theEditor = "gvim";
					break;
			case 4:	$theEditor = "vi";
					break;
			case 5:	$theEditor = "vim";
					break;
			case 6:	$theEditor = "xedit";
					break;
			case 7:	$theEditor = "xemacs";
					break;
			case 8:	$theMessage = EEgetEditorMessage();
					$winEditor = getenv("WINEDITOR");
					if (size($winEditor) == 0)
						$theMessage = 
							$theMessage + "Currently \"WINEDITOR\" is not set.";
					else
						$theMessage = 
							$theMessage + "\"WINEDITOR\" is now set to \"" + $winEditor + "\".";
					EEpostConfirm($theMessage);
					if (size($winEditor) > 0)
					{
						tokenize($winEditor, " ", $buffer);
						$theEditor = $buffer[0];
					}
					else
					{
						warning (uiRes("m_expressionEdCallbacks.kUseOtherEditor"));
						optionMenu -edit -select 1 EEeditorOM;
						scrollField -edit -enable true EEmultiText;
						return;
					}
					break;
		}
	}

	// First test that the editor exists in the user's path.  If
	// it doesn't, send a message and revert to the Expression
	// Editor.
	//
	if ($EEcurrentEditor == 1)
	{
		// User is switching back to edit in the Expression Editor:
		// Check that the current expression is not already in a
		// text editor.  If it is, don't switch, and warn the user
		// to dismiss the text editor first.
		//
		string $expressionName = `textField -query -text EEexprNameT`;
		int $index = -1;
		if (size($expressionName))
		{
			if ($EEobjIsParticle)
			{
				if (size($expressionName))
					$index = EEexpressionIsInTextEditor($expressionName, 1);
			}
			else
			{
				if (size($expressionName))
					$index = EEexpressionIsInTextEditor($expressionName, 0);
			}
			if ($index > -1)
			{
				// The current expression is in a text editor.
				//
				warning (uiRes("m_expressionEdCallbacks.kExprInTextEditor"));

			}
		}
		if ($index > -1)
			scrollField -edit -enable false EEmultiText;
		else
			scrollField -edit -enable true EEmultiText;
	}

}	// EEeditorCB


//  ================ EEexecuteOnCB ================
//
//  SYNOPSIS
//      Called when the menu item is changed.
//
global proc EEexecuteOnCB(string $enum)
{
	global string $EEcurrSelectedNode;
	global string $EEnodeMode;

	if( $EEnodeMode == "scriptNode" ) {
		int $val = 0;
		if( $enum == (uiRes("m_expressionEditor.kDemand")) ) {
			$val = 0;
		} else if( $enum == (uiRes("m_expressionEditor.kOpenClose")) ) {
			$val = 1;
		} else if( $enum == (uiRes("m_expressionEditor.kGUIOPenClose")) ) {
			$val = 2;
		} else if( $enum == (uiRes("m_expressionEditor.kUIConfig")) ) {
			$val = 3;
		} else if( $enum == (uiRes("m_expressionEditor.kSoftwareRender")) ) {
			$val = 4;
		} else if( $enum == (uiRes("m_expressionEditor.kSoftwareFrameRender")) ) {
			$val = 5;
		} else if( $enum == (uiRes("m_expressionEditor.kSceneConfig")) ) {
			$val = 6;
		} else if( $enum == (uiRes("m_expressionEditor.kTimeChanged")) ) {
			$val = 7;
		}
		if( $val == 7 ) {
			radioButtonGrp -edit -select 1   EEscriptRBG;
			radioButtonGrp -edit -enable off EEscriptRBG;
			EErestoreCB();
		} else {
			radioButtonGrp -edit -enable on EEscriptRBG;
		}
		evalEcho ("setAttr " + $EEcurrSelectedNode + ".scriptType " + $val);
	}
}	// EEexecuteOnCB

//  ================ EEreferenceEdtisCB ================
//
//  SYNOPSIS
//      Called when the radio button group of reference edits option is changed.
//
global proc EEreferenceEdtisCB(int $enum)
{
	global string $EEcurrSelectedNode;
	global string $EEnodeMode;
	
	if( $EEnodeMode == "scriptNode" ) {
		if ($EEcurrSelectedNode != "") {
			evalEcho ("setAttr " + $EEcurrSelectedNode + ".ignoreReferenceEdits " + $enum);
		}
	}
}	// EEreferenceEdtisCB



//  ================ EErulesCB ================
//
//  SYNOPSIS
//      Called when the rules radio button is changed.
//
global proc EErulesCB(string $whichRule)
{
	global int $EEexpressionType;
	string $EEnodeMode;
	string $particleExpr;

	string $objAttrName = `textFieldGrp -query -text EEselNameT`;
	string $buffer[];
	tokenize($objAttrName, ".", $buffer);

	// runtime before dynamics if $EEexpressionType == 1
	// runtime after  dynamics if $EEexpressionType == 2
	// creation                if $EEexpressionType == 3
	if( $whichRule == "runtimeBeforeDynamics" )
		$EEexpressionType = 1;
	else if( $whichRule == "runtimeAfterDynamics" )
		$EEexpressionType = 2;
	else
		$EEexpressionType = 3;

	$particleExpr = EEgetParticleExpression($buffer[0], "");

	if (size($particleExpr) > 0)
	{
		scrollField -edit -text $particleExpr EEmultiText;
		EEsetEditMode("Editing ParticleExpression");
	}
	else
	{
		scrollField -edit -text "" EEmultiText;
		EEsetCreateMode("Creating Particle Expression");
	}

	// Putting a new expression in the editor, so enable multiText
	// if the expression is not already in a file.
	//
	int $index = EEexpressionIsInTextEditor($buffer[0], 1);
	if ($index == -1)
		scrollField -edit -enable true EEmultiText;
	else
		scrollField -edit -enable false EEmultiText;

}	// EErulesCB

//  ================ EEmathFuncCB ================
//
//  SYNOPSIS
//      Called when the math function is selected
//
global proc EEmathFuncCB(int $index)
{
	global	string $EEMathFunction[];

	scrollField -edit -insertText $EEMathFunction[$index] EEmultiText;
	textField -edit -text $EEMathFunction[$index+1] EEhelpField;

}	// EEmathFuncCB

//  ================ EEvectFuncCB ================
//
//  SYNOPSIS
//      Called when the vector function is selected
//
global proc EEvectFuncCB(int $index)
{
	global	string $EEVectorFunction[];

	scrollField -edit -insertText $EEVectorFunction[$index] EEmultiText;
	textField -edit -text $EEVectorFunction[$index+1] EEhelpField;

}	// EEvectFuncCB

//  ================ EEconvFuncCB ================
//
//  SYNOPSIS
//      Called when the conversion function is selected 
//
global proc EEconvFuncCB(int $index)
{
	global	string $EEConversionFunction[];

	scrollField -edit -insertText $EEConversionFunction[$index] EEmultiText;
	textField -edit -text $EEConversionFunction[$index+1] EEhelpField;

}	// EEconvFuncCB

//  ================ EEarrayFuncCB ================
//
//  SYNOPSIS
//      Called when the array function is selected 
//
global proc EEarrayFuncCB(int $index)
{
	global	string $EEArrayFunction[];

	scrollField -edit -insertText $EEArrayFunction[$index] EEmultiText;
	textField -edit -text $EEArrayFunction[$index+1] EEhelpField;

}	// EEarrayFuncCB

//  ================ EErandFuncCB ================
//
//  SYNOPSIS
//      Called when the random function is selected 
//
global proc EErandFuncCB(int $index)
{
	global	string $EERandomFunction[];

	scrollField -edit -insertText $EERandomFunction[$index] EEmultiText;
	textField -edit -text $EERandomFunction[$index+1] EEhelpField;

}	// EErandFuncCB

//  ================ EEcurveFuncCB ================
//
//  SYNOPSIS
//      Called when the curve function is selected 
//	This block has distinct elements for the menu label
//	(the first string in each set)
//	and the literal string to insert in the expression (the second)
//	in order to distinguish between the 2 overloaded
//	versions of hermite().
//
global proc EEcurveFuncCB(int $index)
{
	global	string $EECurveFunction[];

	scrollField -edit -insertText $EECurveFunction[$index+1] EEmultiText;
	textField -edit -text $EECurveFunction[$index+2] EEhelpField;

}	// EEcurveFuncCB


// ******************************************************************
//
//					EXPRESSION EDITOR MESSAGE CALLBACKS
//
//   These procs are called from TexprEdListenAction.cc, when
//   messages are received that there are active list or database
//	 changes
//
//  ================ EEactiveListChanged ================
//
//  SYNOPSIS
//      The active (selection) list has changed. So update the
//		object list.
//
//
global proc EEactiveListChanged()
{
	global string $EEnodeMode;
	global string $EEcurrNodeFilter;

	// If the current filter is "allSelected", rebuild the
	// list.  (If not "allSelected", no need to change.  Messages that
	// objects have been added/removed are handled elsewhere.
	//
	if (`window -exists "expressionEditorWin"`)
	{
		if ($EEnodeMode == "object" && $EEcurrNodeFilter == "allSelected")
		{
			EErebuildNodeList($EEnodeMode);
		}
	}
}	// EEactiveListChanged


//  ================ EEnodeAdded ================
//
//  SYNOPSIS
//      A node has been added to the scene.  Update the
//		object/attribute list, if needed.
//
//
global proc EEnodeAdded(string $nodeName)
{
	global string $EEnodeMode;
	global string $EEcurrNodeFilter;

	if (!`window -exists "expressionEditorWin"`)
	{
		return;
	}

	string $nodeList[];
	int $i;

	// If the new node is a particle or expression, we have to register
	// to listen for creation/deletion of expressions.
	//
	if (EEisParticle($nodeName) || EEisExpression($nodeName))
	 	expressionEditorListen -le $nodeName;

	// If in expression mode, get the name of all expressions.
	// If in object mode, get the name of all objects of the type 
	// that is currently being displayed.  If the new node is in
	// the list, add it to the text scroll list.  
	//
	if ($EEnodeMode == "expression")
	{
		$nodeList = EEgetExpressionList();
	} 
	else if ($EEnodeMode == "scriptNode") 
	{
		$nodeList = EEgetCurrTypeList("scriptNode");
	}
	else
	{
		$nodeList = EEgetCurrTypeList($EEcurrNodeFilter);
	}

	for ($i = 0; $i < size($nodeList); $i++)
	{
		if ($nodeName == $nodeList[$i])
		{
			EEaddNodeToList($nodeName);
			break;
		}
	}

	// If in object mode and a new expression node has been created,
	// and it has been connected to the currently selected object.attr,
	// then load it into the editor.
	//
	if ($EEnodeMode == "object" && EEisExpression($nodeName)) 
	{
		// Get the selected obj.attr.  If there is one, and it is
		// connected to nodeName, then display the expression
		//
		string $selectedNode[] = `textScrollList -query -selectItem EEnodeList`;
		string $selectedAttr[] = `textScrollList -query -selectItem EEattrList`;
		if (size($selectedNode) && size($selectedAttr))
		{
			string $objAttr = $selectedNode[0] +"."+$selectedAttr[0];

			string $exprName[] = 
				`listConnections -source true -destination false -type "expression" -skipConversionNodes true $objAttr`;

			// If the obj.attr is connected to the expression node, 
			// load it.
			//
			if ($exprName[0] == $nodeName)
				EEdisplayExpression($objAttr);
		}
	}

}	// EEnodeAdded


//  ================ EEnodeRemoved ================
//
//  SYNOPSIS
//      A node has been removed from the scene.  Remove it
//		from the object/attribute list, if needed.
//
//
global proc EEnodeRemoved(string $nodeName)
{
	global string $EEnodeMode;
	global int $EEobjIsParticle;

	if (!`window -exists "expressionEditorWin"`)
	{
		return;
	}

	string $objectList[] = `textScrollList -query -allItems EEnodeList`;

	// If the node is a particle or expression, unregister it to receive
	// expression changed messages.
	//
	if (EEisParticle($nodeName) || EEisExpression($nodeName))
	 	expressionEditorListen -stopListenForExpression $nodeName;

	// If the deleted node is in the list, remove it.  If it
	// is the selected node, clear the attribute list, and
	// make nothing selected in the node list.
	//
	int $i;
	int $nodeWasInList = 0;
	for($i = 0; $i < size($objectList); $i++)
	{
		if ($nodeName == $objectList[$i])
		{
			string $selected[] = `textScrollList -query -selectItem EEnodeList`;
			EEremoveNodeFromList($nodeName, 1);
			$nodeWasInList = 1;
			if ($nodeName == $selected[0])
			{
				textScrollList -edit -removeAll EEattrList;

				// At this point nothing is selected, so put the editor
				// in create non-particle mode (non-particle so the user
				// can use the "New Expression" button.)
				//
				EEclearAllControls();
				if ($EEobjIsParticle)
				{
					$EEobjIsParticle = 0;
					if ($EEnodeMode == "scriptNode") 
					{
						EEsetCreateMode("Creating Script Node");
					} 
					else 
					{
						EEsetCreateMode("Creating Expression");
					}
					EEswitchRulesForm(0);
					textFieldGrp -edit -text "" -enable true EEdefNameT;
					text -edit -enable true EEexprNameLabel;
				}
			}
			break;
		}
	}
	// If the node was not in the node list, it could still, if it
	// was an expression, have been connected to the current obj.attr.
	// So, if in object mode and the node just deleted was an expression,
	// if it is in the editor, remove it.
	//
	// NEW
	if (!$nodeWasInList &&
		EEisExpression($nodeName)  &&
		$EEnodeMode == "object")
	{
		string $exprName = `textField -query -text EEexprNameT`;
		if ($exprName == $nodeName)
			EEdisplayNoExpression($nodeName);
	}

}	// EEnodeRemoved


//  ================ EEnodeNameChanged ================
//
//  SYNOPSIS
//      The name of a node has been changed, so reflect the change
//		in the list.
//
//
global proc EEnodeNameChanged(string $oldNodeName, string $newNodeName)
{
	global string $EEnodeMode;

	if (!`window -exists "expressionEditorWin"`)
		return;

	// Find the old name in the object list, get its index, and find out if it 
	// is selected.
	// Remove the old name from the list and add the new name in the same spot
	// If it is selected, select it and change the name in the selected object
	// textfield, and the default textfield if it is there.
	//
	string $nodeList[] = `textScrollList -query -allItems EEnodeList`;
	int $selected[] = `textScrollList -query -selectIndexedItem EEnodeList`;
	int $renamedNode;

	int $i;
	for ($i = 0; $i < size($nodeList); $i++)
	{
		if ($oldNodeName == $nodeList[$i])
		{
			// Found the old node name in the scrolled list of nodes.
			// So remove it, and replace it with the new name.
			//
			int $index = $i + 1;
			textScrollList -edit -removeIndexedItem $index EEnodeList;
			textScrollList -edit -appendPosition $index $newNodeName EEnodeList;
			if ($selected[0] == $index)
			{
				// The renamed node is the one selected in the list, so now
				// select the new name, and put it in the Expression Name
				// textfield..
				//
				textScrollList -edit -selectIndexedItem $index EEnodeList;

				// If in object mode, reset the selected and default textfields
				// if the renamed object is the one selected in the editor.
				//
				if ($EEnodeMode == "object")
				{
					string $objAttrName = `textFieldGrp -query -text EEselNameT`;
					string $buffer[];
					tokenize($objAttrName, ".", $buffer);
					$objAttrName = $newNodeName;
					if (size($buffer) == 2)
						$objAttrName = $objAttrName + "." + $buffer[1];
					textFieldGrp -edit -text $objAttrName EEselNameT;
					string $defObjName = `textFieldGrp -query -text EEdefNameT`;
					if (size($defObjName) > 0)
						textFieldGrp -edit -text $newNodeName EEdefNameT;
				}

				if ($EEnodeMode == "scriptNode")
				{
					textFieldGrp -edit -text $newNodeName EEselNameT;
				}
			}
		}
	}

	// If the new node name is an expression name and is currently
	// in the Expression Name textfield, then put the new name in
	// the field.
	//
	string $currExprName = `textField -query -text EEexprNameT`;

	if ($oldNodeName == $currExprName)
	{
		textField -edit -text $newNodeName EEexprNameT;
	}

}	// EEnodeNameChanged


//  ================ EEattributeAdded ================
//
//  SYNOPSIS
//      An attribute has been added to a node.  So add it to
//		the Attributes list, if this node is selected, and if
//		the attribute meets the requirements.
//
//
global proc EEattributeAdded(string $nodeName, string $attributeName)
{
	if (!`window -exists "expressionEditorWin"`)
		return;

	string $selectedNode[] = `textScrollList -query -selectItem EEnodeList`;

	if ($nodeName == $selectedNode[0])
	{
		// If the node is a particle, eliminate a few attributes we
		// don't want in the editor.
		//
		if (EEisParticle($nodeName))
		{
			if (EEisValidDynAttr($attributeName))
				textScrollList -edit -append $attributeName EEattrList;
		}
		else
			textScrollList -edit -append $attributeName EEattrList;
	}

}	// EEattributeAdded


//  ================ EEattributeRemoved ================
//
//  SYNOPSIS
//      An attribute has been removed to the node.  So remove it 
//		from the Attributes list, if this node is selected.
//
global proc EEattributeRemoved(string $nodeName, string $attributeName)
{

	if (!`window -exists "expressionEditorWin"`)
		return;

	string $selectedNode[] = `textScrollList -query -selectItem EEnodeList`;
	string $selectedAttr[] = `textScrollList -query -selectItem EEattrList`;

	if ($nodeName == $selectedNode[0])
	{
		// Remove the attribute from the list, if it is in the list.
		//
		string $listAttrs[] = `textScrollList -query -allItems EEattrList`;
		int $i;
		for ($i = 0; $i < size($listAttrs); $i++)
		{
			if ($listAttrs[$i] == $attributeName)
			{
				textScrollList -edit -removeItem $attributeName EEattrList;
				if ($attributeName == $selectedAttr[0])
				{
					// If the removed attribute was the selected one, clear
					// the controls and set the first attribute in the list
					// to be selected.
					//
					EEclearAllControls();
					textScrollList -edit -selectIndexedItem 1 EEattrList;
				}
				break;
			}
		}
	}

}	// EEattributeRemoved


//  ================ EEexpressionCreated ================
//
//  SYNOPSIS
//      An expression has been created from outside the editor.  
//		If it's in the editor, reload it.
//
//
global proc EEexpressionCreated(string $expressionName)
{
	global int $EEeditedInEditor;
	global string $EEnodeMode;

	if (!`window -exists "expressionEditorWin"`)
		return;

	if ($EEeditedInEditor)
	{
		$EEeditedInEditor = 0;
		return;
	}

	// If the obj.attr this expression is connected to is in the
	// editor, load it.
	//
	if ($EEnodeMode == "object")
	{
		string $selectedNode[] = `textScrollList -query -selectItem EEnodeList`;
		string $selectedAttr[] = `textScrollList -query -selectItem EEattrList`;
		if (size($selectedNode) && size($selectedAttr))
		{
			string $selObjAttr = $selectedNode[0] +"."+$selectedAttr[0];
			string $objAttr[] = 
			`listConnections -source false -destination true -shapes true -plugs true  -skipConversionNodes true  $expressionName`;

			if ($selObjAttr == $objAttr[0])
			{
				EEdisplayExpression($expressionName);
			}
		}
	}

}	// EEexpressionCreated


//  ================ EEexpressionEdited ================
//
//  SYNOPSIS
//      An expression has been edited from outside the editor.  
//		If it's in the editor, reload it.
//
//
global proc EEexpressionEdited(string $expressionName)
{
	global int $EEeditedInEditor;

	if (!`window -exists "expressionEditorWin"`)
		return;

	if ($EEeditedInEditor)
	{
		$EEeditedInEditor = 0;
		return;
	}

	// If the expression is in the editor, reload it.
	//
	string $currExprName = `textField -query -text EEexprNameT`;

	if ($expressionName == $currExprName)
	{
		EEdisplayExpression($expressionName);
	}

}	// EEexpressionEdited


//  ================ EEparticleExpressionCreated ================
//
//  SYNOPSIS
//		Called from TexprEdListenAction.
//      A particle expression has been created from outside the editor.
//		If in "Expression" mode, add it to the node list.  If needed,
//		load the new expression.
//
//
global proc EEparticleExpressionCreated(string $which, string $nodeName)
{
	global string $EEnodeMode;
	global int $EEeditedInEditor;

	if (!`window -exists "expressionEditorWin"`)
		return;

	if ($EEeditedInEditor)
	{
		$EEeditedInEditor = 0;
		return;
	}

	// A particle has just had its first expression created.
	// If in expression mode, add the particle to the node list.
	// If in object mode and the particle is selected, bring in
	// its expression, and put the editor in edit mode.
	//
	if ($EEnodeMode == "expression" && $which == "first")
	{
		EEaddNodeToList($nodeName);
	}
	else
	{
		string $selected[] = `textScrollList -query -selectItem EEnodeList`;
		if ($selected[0] == $nodeName)
		{
			string $particleExpr = 
				EEgetParticleExpression($nodeName, "");

			if (size($particleExpr) > 0)
			{
				scrollField -edit -text $particleExpr EEmultiText;
				EEsetEditMode("Editing ParticleExpression");
			}
		}
	}

}	// EEparticleExpressionCreated


//  ================ EEparticleExpressionDeleted ================
//
//  SYNOPSIS
//      A particle expression has been deleted from outside the
//		expression editor.  If in "Expression" mode, remove it from 
//		the node list.  If selected, remove it from the expression
//		textfield and name field.
//
//
global proc EEparticleExpressionDeleted(string $which, string $nodeName)
{
	global string $EEnodeMode;
	global int $EEexpressionType;

	if (!`window -exists "expressionEditorWin"`)
		return;

	string $selected[] = `textScrollList -query -selectItem EEnodeList`;

	// A particle has just had its last expression deleted.
	// If in expression mode, remove the particle from the node list.
	// If in object mode and the particle is selected, delete the
	// expression, and put the editor in create mode.
	//
	if ($EEnodeMode == "expression" && $which == "all")
	{
		EEremoveNodeFromList($nodeName, 1);
		EEclearAllControls();
	}
	else
	{
		if ($selected[0] == $nodeName)
		{
			if (($which == "runtimeBeforeDynamics" && $EEexpressionType == 1) ||
			    ($which == "runtimeAfterDynamics"  && $EEexpressionType == 2) ||
			    ($which == "creation"              && $EEexpressionType == 3) ||
			    ($which == "all"))
			{
				EEdisplayNoExpression($nodeName);
			}
		}
	}

}	// EEparticleExpressionDeleted


//  ================ EEparticleExpressionEdited ================
//
//  SYNOPSIS
//      A particle expression has been edited from outside the
//		editor.  If it's in the editor, reload it.
//
//
global proc EEparticleExpressionEdited(string $which, string $nodeName)
{
	global int $EEexpressionType;
	global int $EEeditedInEditor;

	if (!`window -exists "expressionEditorWin"` )
		return;

	if ($EEeditedInEditor)
	{
		$EEeditedInEditor = 0;
		return;
	}

	// If the expression is in the editor, reload it.
	//
	string $currExprName = `textField -query -text EEexprNameT`;

	if ($nodeName == $currExprName)
	{
		if (($which == "runtimeBeforeDynamics" && $EEexpressionType == 1) ||
		    ($which == "runtimeAfterDynamics"  && $EEexpressionType == 2) ||
		    ($which == "creation"              && $EEexpressionType == 3)  )
		{
			string $expression = EEgetParticleExpression($nodeName, "");

			scrollField -edit -text $expression EEmultiText;
		}
	}

}	// EEparticleExpressionEdited



//  ================ EEclearExpressionEditor ================
//
//  SYNOPSIS
//      Clear the editor.  This is called when there is a file new or file
//		open, after the old scene has been removed, so we want to clear the
//		editor, but not try to remove client messages.  But we do need to
//		clear up FAM connections if the user has left an external test editor
//		up.
//
global proc EEclearExpressionEditor()
{
	global string $EEorigExpressionName;
	global string $EEcurrExpressionName;
	global string $EEcurrSelectedNode;
	global string $EEnodeMode;

	global int $EEpExpressionInEditor;
	global int $EEexpressionInEditor;
	global int $EEobjIsParticle;

	global string $EEcurrFiles[];
	global string $EEcurrFileExprName[];
	global int    $EEcurrFileCreateMode[];   // 1 = creating; 0 = editing
	global string $EEcurrFileDefObj[];
	global string $EEcurrParticleFiles[];

	if (!`window -exists "expressionEditorWin"` )
		return;

	// If there are editors left up with files from the scene being deleted,
	// delete the expression file to force call to FAM to clean up.  This will
	// not take down the editor, but it will at least disconnect it from FAM,
	// since its contents are not longer in the scene.  Note too that this
	// will delete the edit file but not the .EXE file.  It can't be fully
	// removed because if the editor is up, it is a running process, and FAM
	// doesn't get called.  So here delete the expression file through normal
	// channels, which will break its FAM connection and clean up the EE
	// internal structures. When the user does dismiss the external text editor,
	// the .EXE file will get removed and FAM will be called to disconnect it
	// from monitoring.
	//
	if (size($EEcurrFiles) > 0)
	{
		for ($i = 0; $i < size($EEcurrFiles); $i++)
		{
			EEdeleteEditorFile($EEcurrFiles[$i]);
		}
	}

	if (size($EEcurrParticleFiles) > 0)
	{
		for ($i = 0; $i < size($EEcurrParticleFiles); $i++)
		{
			EEdeleteEditorFile($EEcurrParticleFiles[$i]);
		}
	}

	$EEpExpressionInEditor = -1;
	$EEexpressionInEditor = -1;

	// Clear the old object and attribute lists.
	//
	textScrollList -edit -removeAll EEnodeList;
	textScrollList -edit -removeAll EEattrList;

	// Clear the expression name, selected object name, default object name
	// textfields.
	//
	textField -edit -text "" EEexprNameT;
	textFieldGrp -edit -text "" EEselNameT;
	textFieldGrp -edit -text "" EEdefNameT;

	// Clear the expression scrolled text field.
	//
	scrollField -edit -text "" EEmultiText;

	// Reset some buttons.
	//
	optionMenu -edit -select 2 EEanimTypeOM;
	radioButtonGrp -edit -select 1 EEunitsRBG;

	// Set in create mode.
	//
	if ($EEnodeMode == "scriptNode")
		EEsetCreateMode("Creating Script Node");
	else
		EEsetCreateMode("Creating Expression");

	// If in particle expression mode, switch to regular expression mode.
	//
	if ($EEobjIsParticle)
	{
		$EEobjIsParticle = 0;
		EEswitchRulesForm(0);
		text -edit -enable true EEexprNameLabel;
	}

	$EEcurrSelectedNode = "";
	$EEcurrExpressionName = "";
	$EEorigExpressionName = "";

}	// EEclearExpressionEditor



//  ================ EEresetExpressionEditor ================
//
//  SYNOPSIS
//      Clear the editor.  This is called when there is a file new or file
//		open, after the old scene has been removed, so we want to clear the
//		editor, but not try to remove client messages.  
//
global proc EEresetExpressionEditor()
{
	if (!`window -exists "expressionEditorWin"` )
		return;

	global string $EEnodeMode;

	// Clear the editor;
	//
	EEclearExpressionEditor();

	// Rebuild it if required.
	//
	EErebuildNodeList($EEnodeMode);

}	// EEresetExpressionEditor
