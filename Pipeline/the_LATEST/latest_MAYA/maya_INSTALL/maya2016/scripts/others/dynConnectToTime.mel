// Copyright (C) 1997-2014 Autodesk, Inc., and/or its licensors.
// All rights reserved.
//
// The coded instructions, statements, computer programs, and/or related
// material (collectively the "Data") in these files contain unpublished
// information proprietary to Autodesk, Inc. ("Autodesk") and/or its licensors,
// which is protected by U.S. and Canadian federal copyright law and by
// international treaties.
//
// The Data is provided for use exclusively by You. You have the right to use,
// modify, and incorporate this Data into other products for purposes authorized 
// by the Autodesk software license agreement, without fee.
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND. AUTODESK
// DOES NOT MAKE AND HEREBY DISCLAIMS ANY EXPRESS OR IMPLIED WARRANTIES
// INCLUDING, BUT NOT LIMITED TO, THE WARRANTIES OF NON-INFRINGEMENT,
// MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE, OR ARISING FROM A COURSE 
// OF DEALING, USAGE, OR TRADE PRACTICE. IN NO EVENT WILL AUTODESK AND/OR ITS
// LICENSORS BE LIABLE FOR ANY LOST REVENUES, DATA, OR PROFITS, OR SPECIAL,
// DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES, EVEN IF AUTODESK AND/OR ITS
// LICENSORS HAS BEEN ADVISED OF THE POSSIBILITY OR PROBABILITY OF SUCH DAMAGES.


//<doc>
//<name dynConnectToTime>
//<owner "Autodesk">
//
//<synopsis>
//		dynConnectToTime
//
//<returns>
//		None.	
//
//<description>
//      For each selected particle, nParticle, nCloth, nucleus or emitter object, if that object's
//      current time attribute has no incoming connection,
//      this action makes a connection from time1.outTime.
//      This action is useful when you have duplicated a particle or emitter
//      object without duplicating connections, or in some other
//      way broken the object's input to current time,
//      and you want to re-establish the default input from time1.
//
//<flags>
//	None.
//
//<examples>
//  dynConnectToTime;
//</doc>



proc connectObjectToTime( string $objName )
//
// Connect the object's currentTime attribute to time1.
// Objects must have a "current time" attribute.
{
		// Is there a connection into currentTime?
		// Get list of connected plugs, see if
		// node name + "currentTime" is in the list.
		//
		string $typeName = `nodeType $objName`;
		string $currTimePlug = $objName + ".currentTime";
		if ( ($typeName == "cacheFile") || ($typeName == "oceanShader"))
		{
			$currTimePlug = $objName + ".time";
		}		

		string $conn[] = `listConnections -p true -c true $objName`;

		int $i;
		int $connectionExists = 0;
		string $connectedTo = "";
		for ( $i= 0; $i < size($conn); $i++)
		{
			// If one of the connected plugs is the current time
			// plug, then a connection exists and we are not
			// supposed to make one.
			//
			if ($conn[ $i ] == $currTimePlug)
			{
				$connectionExists = 1;
				$connectedTo = $conn[$i + 1];
				break;
			}
		}
		
		// If no connection into currentTime was found, make one now
		//
		if ($connectionExists == 0)
		{
			string $cmd = "connectAttr time1.outTime " + $currTimePlug;
			evalEcho $cmd;
		}
		else
		{
			string $warnFormat = (uiRes("m_dynConnectToTime.kAlreadyConnected"));
			string $warnMsg = `format -stringArg $objName -stringArg $connectedTo $warnFormat`;
			warning $warnMsg;
			if ($connectedTo != "time1.outTime")
			{
				warning( (uiRes("m_dynConnectToTime.kPleaseBreakThisConn")));
			}
		}
}



global proc dynConnectToTime() 
//
//  Get the list of selected objects, get all particle shapes or emitters which are 
//  selected or are children of selected transforms, and call connectObjectToTime
//  to make the connection for each.
{
	// Get the full selection list.
	//
	string $list[] = `ls -sl`;
	int $i;
	for ($i = 0; $i < size($list); $i++)
	{
	    // if this is a particle shape or emitter, make the connection
	    //
        if ( (`nodeType $list[$i]` == "particle") ||
			 (`nodeType $list[$i]` == "nParticle")  ||
			 (`nodeType $list[$i]` == "nCloth")  ||
			 (`nodeType $list[$i]` == "nucleus")  ||
			 (`nodeType $list[$i]` == "nRigid")  ||
			 (`nodeType $list[$i]` == "dynamicConstraint")  ||
			 (`nodeType $list[$i]` == "geoConnector")  ||
			 (`nodeType $list[$i]` == "fluidShape")  ||
			 (`nodeType $list[$i]` == "fluidTexture2D")  ||
			 (`nodeType $list[$i]` == "fluidTexture3D")  ||
			 (`nodeType $list[$i]` == "oceanShader")  ||
			 (`nodeType $list[$i]` == "cacheFile")  ||
			 (`nodeType $list[$i]` == "hairSystem")  ||
			 (`nodeType $list[$i]` == "fluidEmitter")  ||
			 (`nodeType $list[$i]` == "pointEmitter") )
	    {
			connectObjectToTime( $list[$i] );		
	    }
	    else
	    {
			// Otherwise, walk through its children.
			// Add to list any particle shapes we find.
			//	
			string $childList[] = `listRelatives -s $list[$i]`;
			int $j;
	    	for ($j = 0; $j < size($childList); $j++)
	    	{
		    	if ((`nodeType $childList[$j]` == "particle") ||
		    		(`nodeType $childList[$j]` == "nParticle") ||
		    		(`nodeType $childList[$j]` == "nCloth") ||
		    		(`nodeType $childList[$j]` == "nucleus") ||
				(`nodeType $childList[$j]` == "nRigid")  ||
				(`nodeType $childList[$j]` == "dynamicConstraint")  ||
				(`nodeType $childList[$j]` == "fluidShape")  ||
				(`nodeType $childList[$j]` == "fluidTexture2D")  ||
				(`nodeType $childList[$j]` == "fluidTexture3D")  ||
				(`nodeType $childList[$j]` == "hairSystem")  ||
		    	    (`nodeType $childList[$j]` == "fluidEmitter") ||
		    	    (`nodeType $childList[$j]` == "pointEmitter"))
		    	{
					connectObjectToTime( $childList[$j] );		
	    	  	}
				else
				{
					string $warnFormat = (uiRes("m_dynConnectToTime.kIsNotAParticleOrEmit"));
					string $warnMsg = `format -stringArg $childList[$j] $warnFormat`;
					warning $warnMsg;
				}
			}
	    }
	}
}

