// Copyright (C) 1997-2014 Autodesk, Inc., and/or its licensors.
// All rights reserved.
//
// The coded instructions, statements, computer programs, and/or related
// material (collectively the "Data") in these files contain unpublished
// information proprietary to Autodesk, Inc. ("Autodesk") and/or its licensors,
// which is protected by U.S. and Canadian federal copyright law and by
// international treaties.
//
// The Data is provided for use exclusively by You. You have the right to use,
// modify, and incorporate this Data into other products for purposes authorized 
// by the Autodesk software license agreement, without fee.
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND. AUTODESK
// DOES NOT MAKE AND HEREBY DISCLAIMS ANY EXPRESS OR IMPLIED WARRANTIES
// INCLUDING, BUT NOT LIMITED TO, THE WARRANTIES OF NON-INFRINGEMENT,
// MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE, OR ARISING FROM A COURSE 
// OF DEALING, USAGE, OR TRADE PRACTICE. IN NO EVENT WILL AUTODESK AND/OR ITS
// LICENSORS BE LIABLE FOR ANY LOST REVENUES, DATA, OR PROFITS, OR SPECIAL,
// DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES, EVEN IF AUTODESK AND/OR ITS
// LICENSORS HAS BEEN ADVISED OF THE POSSIBILITY OR PROBABILITY OF SUCH DAMAGES.

//
//
//  Creation Date:  Mar 14, 1997
//
//  Description:
//      This script is prepares selected surfaces for stitch operation
//
//  Input Arguments:
//      None.
//
//  Return Value:
//      True if something was prepared, false otherwise.
//

proc int needToDoThisOne( string $surfaceNode )
//
// Description:
//     If the object has stitch in its history before
//     any shape nodes, we don't need the stitch node
//     again.
{
	string $one, $histList[];
	int $i, $n, $result;

	$histList = `listHistory $surfaceNode`;

	$n = size($histList);
	$result = true;
	for( $i=1; $i<$n; $i+=1 ) {
		$one = `nodeType $histList[$i]`;
		if( "stitchSrf" == $one ) {
			$result = false;
			break;
		}
		else if( "nurbsSurface" == $one ) {
			break;
		}
	}
	return $result;
}

proc prepareSurfaceToStitch( string $given )
{
	string $stitchNode, $origNode, $tmp[];
	string $parentNode, $surfaceNode;
	int $i, $n;

	$parentNode = "";
	$surfaceNode = "";
	if( "nurbsSurface" == `nodeType $given` ) {
		$tmp = `listRelatives -p $given`;
		if( size($tmp) > 0 ) {
			$parentNode = $tmp[0];
		}
		$surfaceNode = $given;
	}
	else {
		$parentNode = $given;
		$tmp = `listRelatives -s $given`;
		$n = size($tmp);
		for( $i=0; $i<$n; $i+=1 ) {
			$surfaceNode = $tmp[$i];
			if( ! `getAttr ($surfaceNode + ".io")` ) break;
			$surfaceNode = "";
		}
	}

	if( ("" == $parentNode) || ("" == $surfaceNode) ) {
		warning (`format -s $given (uiRes("m_prepareSurfacesToStitch.kWarningCannotPrepare"))` ) ;
		return;
	}

	// We really want the nodes, not the paths:
	$tmp = `ls -dagObjects $parentNode`;
	if( size($tmp) > 0 ) $parentNode = $tmp[0];
	$tmp = `ls -dagObjects $surfaceNode`;
	if( size($tmp) > 0 ) $surfaceNode = $tmp[0];

	if( ("" == $parentNode) || ("" == $surfaceNode) ) {
		warning (`format -s $given (uiRes("m_prepareSurfacesToStitch.kWarningCannotPrepare"))` );
		return;
	}

	if( !needToDoThisOne( $surfaceNode )) {
		warning (`format -s $surfaceNode (uiRes("m_prepareSurfacesToStitch.kWarningAlreadyPrepared"))` );
		return;
	}

	// create a stitch node
	//
	if( catch( $stitchNode = `createNode stitchSrf` ) ) {
		error ( (uiRes("m_prepareSurfacesToStitch.kErrorFailedCreatingStitchNode")) );
		return;
	} 

	// make internal objects
	setAttr ($surfaceNode + ".io") true;

	// rename
	$origNode = $surfaceNode + "Original";
	$origNode = `rename $surfaceNode $origNode`;

	// make the result under the same parent:
	$surfaceNode = `createNode nurbsSurface -n $surfaceNode -p $parentNode`;

	// connect to the same shader as the original:
	string $origIog = $origNode + ".iog";
	string $nodeIog = $surfaceNode + ".iog";
	string $shadeDsm[] = `listConnections $origIog`;
	if( size($shadeDsm) > 0 ) {
		if( catch( `connectAttr $nodeIog ($shadeDsm[0] + ".dsm") -na` )) {
			warning ( (uiRes("m_prepareSurfacesToStitch.kWarningFailedToConnectToShadingGroup")) );
		}
	}

	// Plugs for connections:
	string $onOrigToStitch = $origNode + ".ws[0]";
	string $onStitchFromOrig = $stitchNode + ".is";
	string $onStitchToRes = $stitchNode + ".os";
	string $onResFromStitch = $surfaceNode + ".cr";

	int $failed = false;
	if( catch( `connectAttr $onOrigToStitch $onStitchFromOrig` ) ) {
		$failed = true;
		error ( (uiRes("m_prepareSurfacesToStitch.kErrorFailedToConnectToStitchInput")) );
	} 

	if( catch( `connectAttr $onStitchToRes $onResFromStitch` ) ) {
		$failed = true;
		error ( (uiRes("m_prepareSurfacesToStitch.kErrorFailedToConnectToStitchOutput")) );
	}

	if( $failed ) {
		delete $surfaceNode;
		delete $stitchNode;
		rename $origNode $surfaceNode;
	}
}

global proc int prepareSurfacesToStitch()
//
//	Description :
//     Go through all the surfaces and prepare them for stitch
{
	// runfilter on the selected items looking for nurbs 
	// surfaces.
	//
	string $selLst[] = `ls -sl` ;
	global int $gSelectNurbsSurfacesBit ;
	string $sList[] = `filterExpand -ex 1 -sm $gSelectNurbsSurfacesBit $selLst`;

	int $len = size($sList) ;
	if( $len  == 0 ) {
		error ( (uiRes("m_prepareSurfacesToStitch.kErrorSelectSurfaces")) );
		return 0 ;
	}

	int $i;
	for( $i=0; $i<$len; $i+=1 ) {
		prepareSurfaceToStitch( $sList[$i] );
	}
	return 1;
}
