// Copyright (C) 1997-2014 Autodesk, Inc., and/or its licensors.
// All rights reserved.
//
// The coded instructions, statements, computer programs, and/or related
// material (collectively the "Data") in these files contain unpublished
// information proprietary to Autodesk, Inc. ("Autodesk") and/or its licensors,
// which is protected by U.S. and Canadian federal copyright law and by
// international treaties.
//
// The Data is provided for use exclusively by You. You have the right to use,
// modify, and incorporate this Data into other products for purposes authorized 
// by the Autodesk software license agreement, without fee.
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND. AUTODESK
// DOES NOT MAKE AND HEREBY DISCLAIMS ANY EXPRESS OR IMPLIED WARRANTIES
// INCLUDING, BUT NOT LIMITED TO, THE WARRANTIES OF NON-INFRINGEMENT,
// MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE, OR ARISING FROM A COURSE 
// OF DEALING, USAGE, OR TRADE PRACTICE. IN NO EVENT WILL AUTODESK AND/OR ITS
// LICENSORS BE LIABLE FOR ANY LOST REVENUES, DATA, OR PROFITS, OR SPECIAL,
// DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES, EVEN IF AUTODESK AND/OR ITS
// LICENSORS HAS BEEN ADVISED OF THE POSSIBILITY OR PROBABILITY OF SUCH DAMAGES.

//
//
// Creation Date:  Oct 1, 2004
//
//  Procedure Name:
//      proxyAdd
//
//  Description:
//      Adds a reference node as a proxy.
//
//  Input Arguments:
//      Name of reference node
//
//  Return Value:
//      None.
//


proc string proxyAddManager( string $currentRefName )
//
//	Description:
//
//		Given a valid reference node name, we create a proxy manager and hook
//	up the proxy manager to the reference node. Note that currentRefName must
//	be a valid reference node name (we don't check here!) and that it must not
//	already be associated with a proxy manager (we don't check that here
//	either!).
//
{
	$proxyManager = `createNode proxyManager`;
	// Set the name of the proxy manager to something similar to that of
	// the current reference.
	//
	string $proxyTag = $currentRefName;
	int $length = size( $proxyTag );
	if( $length > 1 ){
		// If the last two characters are RN, remove them before appending
		// PM.
		//
		if( substring( $proxyTag, $length-1, $length ) == "RN" ){
			$proxyTag = substring( $proxyTag, 1, $length-2);
		}
	}
	string $proxyName = ($proxyTag + "PM");
	$proxyManager = `rename $proxyManager $proxyName`;

	// Set proxy tag for current reference to proxyManager's name
	//
	//setAttr ($currentRefName + ".proxyTag") -type "string" $proxyTag;
	string $currTag = `getAttr ($currentRefName + ".proxyTag")`;
	if( $currTag == "" ){
		// An empty string gets turned into the string "original". This also
		// happens in proxyTags.mel, so if you change it here, change it there
		// too! TODO Replace by a global constant of some sort so we don't have
		// to do worry about it.
		//
		setAttr ($currentRefName + ".proxyTag") -type "string" (uiRes("m_proxyAdd.kOriginal"));
	}

	// Let's hook up the first proxyList entry of the manager to the
	// current reference.
	//
	connectAttr ($proxyManager + ".proxyList[0]") ($currentRefName + ".proxyMsg" );

	// Since this is the active proxy, let's remember it as such. Recall that
	// the active proxy points to the entry in the proxyList that is the active
	// one, and not directly to the reference node (to avoid a fan-in).
	//
	connectAttr ($proxyManager + ".activeProxy") ($proxyManager + ".proxyList[0]");
	// If this proxy set is created with shared edits, the original reference
	// initially owns the edits.
	//
	if( `optionVar -query proxyOptionsSharedEdits`){
		connectAttr ($currentRefName + ".proxyMsg") ($proxyManager + ".sharedEditsOwner");
	}
	return( $proxyManager );
}

global proc proxyAdd(string $currentRefName, string $newFileName, string $proxyTag)
//
//	Description:
//
//		Given an existing reference with reference node currentRefName, and the
//	reference with associated file newFileName, add the latter and hook it up
//	to the proxy manager for currentRefName. If no proxy manager already
//	exist, we first create one and hook it up to the currentRefName.
//
{	
	if( !`exists isValidReference` || !`exists proxyManagerTag` ||
		!`exists uniqueTag` || !`exists usedTag` || !`exists shortNameProxy`){
		eval("source \"proxyUtils.mel\"");
	}
	global string $gReferenceEditorPanel;

	// First, check if the currentRefName corresponds to a valid reference
	//
	// First, check if the currentProxyName corresponds to a valid reference
	//
	if( isValidReference( $currentRefName ) == 0 ){

		string $errorMsg= (uiRes("m_proxyAdd.kNotProxy"));
		error(`format -s $currentRefName $errorMsg`);
		return;
	}
	
	string $warningMsg = isOperationAllowedOnReference("addProxy", $currentRefName);
	if($warningMsg != "")
	{
		warning $warningMsg;
		return;
	}
	
	string $currentFileName = `referenceQuery -filename $currentRefName`;
	if ( size($currentFileName) > 0 && 
		 !`file -q -uns $currentFileName` )
	{
		error (uiRes("m_proxyAdd.kRenamedPrefixCantHaveProxies"));
		return;
	}

	// Next, check if the reference node already has a proxy manager.
	//
	string $proxyPlug = `connectionInfo -sfd ($currentRefName + ".proxyMsg")`;
	string $proxyManager;
	if( $proxyPlug == "" ){
		// No proxy manager, let's add one.
		//		
		$proxyManager = proxyAddManager( $currentRefName );
	} else {
		$proxyManager = `plugNode $proxyPlug`;
	}
	// Make sure we use a unique tag
	//
	if( $proxyTag == "" || usedTag( $proxyManager, $proxyTag ) ){		
		$proxyTag = uniqueTag( $proxyManager );
		string $msgFormat = (uiRes("m_proxyAdd.kInvalidTag"));
		warning(`format -s $proxyTag $msgFormat`);
	}
	string $refConnections[] = `listConnections -t reference ($proxyManager + ".proxyList")`;
	int $numProxies = `size($refConnections)`;

	// If we can successfully retrieve the filename of the current reference,
	// we'll use the same namespace; otherwise, we'll set the namespace to the
	// proxyTag.
	//
	string $namespace = proxyManagerTag( $proxyManager );	
	string $proxyTail = shortNameProxy($proxyTag);
	string $newRefName = ($namespace + $proxyTail + "RN");	
	string $phnsMapping[];
	if( $currentFileName != "" ){
		$phnsMapping = `file -q -mns $currentFileName`;
		$namespace = `file -q -ns $currentFileName`;
	}

	// Make sure any new proxies use the same sharing options
	// as the first reference.
	//
	string $sharedNodes[] = `file -q -sharedNodes $currentFileName`;	
	string $sharedNodeFlags;
	string $sharedNodeType;
	for ( $sharedNodeType in $sharedNodes )
	{
		if ( "displayLayers" == $sharedNodeType )
		{
			$sharedNodeFlags += " -shd \"displayLayers\"";
		}
		else if ( "shadingNetworks" == $sharedNodeType )
		{
			$sharedNodeFlags += " -shd \"shadingNetworks\"";
		}
	}

	// Add the new proxy reference in an unloaded state.
	//
	string $cmd = ("file -r -proxyManager \"" + $proxyManager + "\" -proxyTag \"" + $proxyTag+"\"");
	$cmd += (" -dr 1 -rfn \"" + $newRefName + "\" -namespace \"" + $namespace + "\" " + $sharedNodeFlags);
	int $phnsCount = size($phnsMapping);
	for ($ii = 0; $ii < $phnsCount; $ii+=2) {
		$cmd += ("-mns \""+$phnsMapping[$ii]+"\" \""+$phnsMapping[$ii+1]+"\" ");
	}
	$cmd += (" \"" + $newFileName + "\"");
	eval($cmd);

	// Set proxy tag for new reference to newRefName
	//
	setAttr ($newRefName + ".proxyTag") -type "string" $proxyTag;

	// Finally, hook it up to the proxy manager
	//
	connectAttr ($proxyManager + ".proxyList[" + $numProxies  + "]") ($newRefName + ".proxyMsg" );

	// Force a refresh of the reference editor panel
	//
	sceneEditor -edit -rr $gReferenceEditorPanel;
}
