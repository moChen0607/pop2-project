// Copyright (C) 1997-2014 Autodesk, Inc., and/or its licensors.
// All rights reserved.
//
// The coded instructions, statements, computer programs, and/or related
// material (collectively the "Data") in these files contain unpublished
// information proprietary to Autodesk, Inc. ("Autodesk") and/or its licensors,
// which is protected by U.S. and Canadian federal copyright law and by
// international treaties.
//
// The Data is provided for use exclusively by You. You have the right to use,
// modify, and incorporate this Data into other products for purposes authorized 
// by the Autodesk software license agreement, without fee.
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND. AUTODESK
// DOES NOT MAKE AND HEREBY DISCLAIMS ANY EXPRESS OR IMPLIED WARRANTIES
// INCLUDING, BUT NOT LIMITED TO, THE WARRANTIES OF NON-INFRINGEMENT,
// MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE, OR ARISING FROM A COURSE 
// OF DEALING, USAGE, OR TRADE PRACTICE. IN NO EVENT WILL AUTODESK AND/OR ITS
// LICENSORS BE LIABLE FOR ANY LOST REVENUES, DATA, OR PROFITS, OR SPECIAL,
// DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES, EVEN IF AUTODESK AND/OR ITS
// LICENSORS HAS BEEN ADVISED OF THE POSSIBILITY OR PROBABILITY OF SUCH DAMAGES.

//
//  Procedure Name:
//      cameraMakeNode
//
//  Description:
//      Creates extra camera nodes for the center of interest and up vector.
//
//  Input Arguments:
//      count - Number of nodes to create.
//      camera - The camera transform name. Pass "" to use selection.
//
//  Return Value:
//      None.
//

//
//  Procedure Name:
//      createLocator
//
proc string createLocator(string $name, float $position[])
{
	string $buffer[];
	int $len = `tokenize $name "|" $buffer`;
	string $baseName = $buffer[$len-1];
    string $targets[] = `spaceLocator -name $baseName -position 0 0 0`;
    string $target = "|"+$targets[0];

    // Set locator to have screen space icon. The target is created
    // directly under the world. Prefix by "|", listRelatives will
    // fail otherwise if another locator has the same name under
    // another transform.
    string $targetShapes[] = `listRelatives -path $target`;
    string $targetShape = $targetShapes[0];
    setAttr ($targetShape+".visibility") false;
    setAttr ($target+".displayRotatePivot") true;

    move -absolute $position[0] $position[1] $position[2];

    return $target;
}

// Connect the camera to the lookAt node.
proc connectCamera(string $camera, string $cameraShape, string $lookAt)
{
    connectAttr ($camera+".pim") ($lookAt+".constraintParentInverseMatrix");
    connectAttr ($camera+".t") ($lookAt+".constraintTranslate");
    connectAttr ($camera+".rp") ($lookAt+".constraintRotatePivot");
    connectAttr ($camera+".rpt") ($lookAt+".constraintRotateTranslate");

    connectAttr ($lookAt+".constraintRotateX") ($camera+".rotateX");
    connectAttr ($lookAt+".constraintRotateY") ($camera+".rotateY");
    connectAttr ($lookAt+".constraintRotateZ") ($camera+".rotateZ");
    connectAttr ($lookAt+".distanceBetween") ($cameraShape+".centerOfInterest");
}

//
//  Procedure Name:
//      doLookAt
//
proc string[] doLookAt( string $camera )
{
    string $shapes[] = `listRelatives -shapes -path $camera`;

    // Compute the center of interest in world space
    //
    float $coi[] = `camera -q -worldCenterOfInterest $camera`;

	string $buffer[];
	int $len = `tokenize $camera "|" $buffer`;
	string $cameraName = $buffer[$len-1];
    string $target = createLocator($cameraName+"_aim", $coi);

    string $lookAt = `createNode -name ($cameraName+"_group") "lookAt"`;

    // Fix for BUG 118280, the two node camera used to use "Scene Up"; but
    // this is problematic because if the camera is loaded into a scene with
    // a different up axis, the camera will have a different orientation than
    // the one it had been created for it.
    //

	connectAttr ($target+".tx") ($lookAt+".target[0].targetTranslateX");
    connectAttr ($target+".ty") ($lookAt+".target[0].targetTranslateY");
    connectAttr ($target+".tz") ($lookAt+".target[0].targetTranslateZ");
    connectAttr ($target+".rp") ($lookAt+".target[0].targetRotatePivot");
    connectAttr ($target+".rpt") ($lookAt+".target[0].targetRotateTranslate");
    connectAttr ($target+".pm") ($lookAt+".target[0].targetParentMatrix");

	if (catch(connectCamera($camera, $shapes[0], $lookAt))) {
		delete $target $lookAt;
		string $mess = "Cannot connect camera ^1s to the lookAt node. Some attributes may be locked.";
		error(`format -stringArg $camera $mess`);
	}

    // Orient the camera depending on users current up axis preferences.
    setAttr ".worldUpType" 3;
    if (`upAxis -q -axis` == "z") {
        setAttr ".worldUpVector" -type double3 0 0 1;
    }
    else {
        setAttr ".worldUpVector" -type double3 0 1 0;
    }

    setAttr ".aimVector" -type double3 0 0 -1;

    // Parent
	// The camera unique path may change, if there is another camera
	// of the same name in the scene.
    string $res[] = `parent $camera $lookAt`;
	$camera = $res[0];
    parent $target $lookAt;

    return {$lookAt, $camera};
}

//
//  Procedure Name:
//      doSelect
//
proc doSelect( string $camera )
{
    string $view = getCameraNode( "view", $camera );
    string $up = getCameraNode( "up", $camera );

    string $selects = $camera;
    if ($up != "") $selects += " " + $up;
    if ($view != "") $selects += " " + $view;

    eval ("select "+$selects);
}

//
//  Procedure Name:
//      cameraMakeNode
//
global proc string cameraMakeNode (int $count, string $camera)
{
    if ($camera == "") {
        string $selected[] = `ls -selection`;
        $camera = $selected[0];
    }

    string $lookAt = getCameraNode( "lookAt", $camera );
    string $view = getCameraNode( "view", $camera );
    string $up = getCameraNode( "up", $camera );

    switch ($count) {
    case 1:
		// ungrouping the camera may change its path, if multiple
		// cameras with the same name exist in the scene. We create a
		// temp set to identify the camera, and update the name after
		// ungrouping.

		if ($lookAt != "") {
			string $tempSet = `sets $camera`;
			string $tempSetDel = `sets -empty`;
			if ($view != "") sets -addElement $tempSetDel $view;
			if ($up != "")   sets -addElement $tempSetDel $up;

			ungroup $lookAt;
			string $content[] = `sets -query $tempSet`;

			// Update the camera name, and the view / up
			$camera = $content[0];

			$content = `sets -query $tempSetDel`;
			if (size($content) > 0)
				delete $content;

			delete $tempSet;
			// delete $tempSetDel; This set is automatically removed when
			// all elements are deleted.
		}
		break;

    case 2:
        // Does a look at already exist?
        if ($lookAt != "") {
            // Is there already an up?
            if ($up != "") delete $up;
        }
        else {
			string $nodes[];
			// Do not remove the catch here, it will break the AE
			// otherwise.

			if (catch($nodes = doLookAt($camera))) {
				break;
			}
			$camera = $nodes[1];
        }

        break;

    case 3:
        // Does a look at not already exist?
        if ($lookAt == "") {
			string $nodes[];
			if (catch($nodes = doLookAt($camera))){
				break;
			}
			$lookAt = $nodes[0];
			$camera = $nodes[1];
        }

		// Begin computing the up in world space.
		//

        float $upOrigin[] = `camera -q -worldUp $camera`;
        float $eye[] = `camera -q -position $camera`;

        $upOrigin[0] = $upOrigin[0] * 2.0 + $eye[0];
        $upOrigin[1] = $upOrigin[1] * 2.0 + $eye[1];
        $upOrigin[2] = $upOrigin[2] * 2.0 + $eye[2];

        //
        // End computing the up in world space

        string $up = createLocator($camera+"_up", $upOrigin);
        connectAttr ($up+".wm") ($lookAt+".worldUpMatrix");

        // Put the up node under the look at
        parent $up $lookAt;

        setAttr ($lookAt+".worldUpType") 1; // Use object

        break;
    }
    doSelect( $camera );

	return $camera;
}
