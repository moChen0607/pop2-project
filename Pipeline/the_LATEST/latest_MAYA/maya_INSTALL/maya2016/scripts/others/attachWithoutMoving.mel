// Copyright (C) 1997-2014 Autodesk, Inc., and/or its licensors.
// All rights reserved.
//
// The coded instructions, statements, computer programs, and/or related
// material (collectively the "Data") in these files contain unpublished
// information proprietary to Autodesk, Inc. ("Autodesk") and/or its licensors,
// which is protected by U.S. and Canadian federal copyright law and by
// international treaties.
//
// The Data is provided for use exclusively by You. You have the right to use,
// modify, and incorporate this Data into other products for purposes authorized 
// by the Autodesk software license agreement, without fee.
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND. AUTODESK
// DOES NOT MAKE AND HEREBY DISCLAIMS ANY EXPRESS OR IMPLIED WARRANTIES
// INCLUDING, BUT NOT LIMITED TO, THE WARRANTIES OF NON-INFRINGEMENT,
// MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE, OR ARISING FROM A COURSE 
// OF DEALING, USAGE, OR TRADE PRACTICE. IN NO EVENT WILL AUTODESK AND/OR ITS
// LICENSORS BE LIABLE FOR ANY LOST REVENUES, DATA, OR PROFITS, OR SPECIAL,
// DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES, EVEN IF AUTODESK AND/OR ITS
// LICENSORS HAS BEEN ADVISED OF THE POSSIBILITY OR PROBABILITY OF SUCH DAMAGES.

//
//
//  Creation Date:  Jul 31, 2000
//
//  Description:
//    Attach 2 surfaces by creating another patch between them.
//    Keeps the original shape of the two surfaces unchanged.
//
//    Approach:
//       Build a third surface between the two original surfaces
//       Attach the third surface to the two originals so it
//         joins with tangent continuity.
//	     Delete history on the output surface. 
//
//    The end result is tangent continuous with multiple knots where
//    the original surfaces ended. Because of the multiple knots, the
//    surface cannot be guaranteed to remain smooth
//	  under deformation.

global proc attachWithoutMoving()
{
	// Get the select list.
	string $selList[] = `ls -sl`;

	// Run filter to select only NURBS isoparms
	global int $gSelectIsoparmsBit ;
	string $crvList[] = `filterExpand -ex true 
		-sm $gSelectIsoparmsBit`;
	int $len = size($crvList) ;
	if( $len != 2 ) {
		error (uiRes("m_attachWithoutMoving.kAttchSrfcsNoMoveInvalSelection"));
		return;
	}

	// get the surfaces that own the isoparms
	string $srfs[] = `listRelatives -parent $crvList`;
	if(!strcmp($srfs[0], $srfs[1])) {
		error (uiRes("m_attachWithoutMoving.kAttchSrfcsNoMoveImproperSelection"));
		return;
	}

	// first build a loft surface between these two isoparms
	string $loft1[] = eval("loft -ch 0 -u 1 -c 0 -ar 1 -d 3 -ss 1 -rn 0 -po 0 -rsn true " 
						   + $crvList[0] + " " + $crvList[1]);

	// then align and attach the new surface to the first original
	alignSurface  -ch off -rpo on -at true -kmk true -pct 5 -tc true -tct 2 -ts1 1 -ts2 1 -cc false 
		$srfs[0]  $loft1[0];

	// then align and attach the second surface to this surface
	alignSurface  -ch off -rpo on -at true -kmk true -pct 5 -tc true -tct 2 -ts1 1 -ts2 1 -cc false 
		$srfs[1]  $srfs[0];

	// delete history on final surface
	delete -ch $srfs[1];

	// delete the stuff left over
	delete $srfs[0] $loft1[0];
}
