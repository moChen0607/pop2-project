// Copyright (C) 1997-2014 Autodesk, Inc., and/or its licensors.
// All rights reserved.
//
// The coded instructions, statements, computer programs, and/or related
// material (collectively the "Data") in these files contain unpublished
// information proprietary to Autodesk, Inc. ("Autodesk") and/or its licensors,
// which is protected by U.S. and Canadian federal copyright law and by
// international treaties.
//
// The Data is provided for use exclusively by You. You have the right to use,
// modify, and incorporate this Data into other products for purposes authorized 
// by the Autodesk software license agreement, without fee.
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND. AUTODESK
// DOES NOT MAKE AND HEREBY DISCLAIMS ANY EXPRESS OR IMPLIED WARRANTIES
// INCLUDING, BUT NOT LIMITED TO, THE WARRANTIES OF NON-INFRINGEMENT,
// MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE, OR ARISING FROM A COURSE 
// OF DEALING, USAGE, OR TRADE PRACTICE. IN NO EVENT WILL AUTODESK AND/OR ITS
// LICENSORS BE LIABLE FOR ANY LOST REVENUES, DATA, OR PROFITS, OR SPECIAL,
// DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES, EVEN IF AUTODESK AND/OR ITS
// LICENSORS HAS BEEN ADVISED OF THE POSSIBILITY OR PROBABILITY OF SUCH DAMAGES.

//
//
//  Creation Date:  Jan 17, 2005
//

global proc string findRootJoint(string $joint)
//
//  Description:
//      Given a joint, finds the root joint of the skeleton hierarchy.
//
{
	string $parent[] = `listRelatives -p -pa $joint`;
	if((size($parent)>0) && (`nodeType $parent[0]` == "joint")) 
		return findRootJoint($parent[0]);	
	else
		return $joint;

}


proc string findHikEffectorFromJoint(string $root)
//
//  Description:
//      Given the root, find and return the name of the 1st
//  HikEffector found to be associated with the root or any
//  of its descendant joints.  If none are found, return the
//  empty string.
//
{
    
	//is there a connection to an effector?
	string $plug = $root + ".message";
	string $connectedNodes[] = `listConnections -type hikEffector -s 0 -d 1 $plug`;
	if(size($connectedNodes)>0)
	    return $connectedNodes[0];	    	

	//now process all the children...
	string $children[] = `listRelatives -pa -allDescendents -type joint $root`;
	for( $child in $children) {		
		$plug = $child + ".message";
	    $connectedNodes = `listConnections -type hikEffector -s 0 -d 1 $plug`;
	    if(size($connectedNodes)>0)
	        return $connectedNodes[0];	    		    
	}	
	return "";    
}



proc addEffectorsFromJointToArray(string $joint,string $effectorsArray[])
//
//  Description:
//      Given a joint, if the joint is connected to HIKEffectors, add
//  those effectors to effectorsArray.
{       
    //is there a connection to an effector?
	string $plug = $joint + ".message";
	string $connectedNodes[] = `listConnections -type hikEffector -s 0 -d 1 $plug`;	
	for ($node in $connectedNodes) {		
		$effectorsArray[size($effectorsArray)] = $node;			
	}	
	
}

proc int isJointPinned(string $joint)
//
//  Description:
//      Given a joint, if the joint is connected to HIKEffectors, and any of those
//  effectors are pinned, then return 1.  Otherwise return 0.
{
    string $effectors[];
    addEffectorsFromJointToArray($joint,$effectors);
    if(size($effectors) > 0) {                	    
        for($effector in $effectors) {
	        string $plug = $effector + ".pinning" ;
	        int $pinned = `getAttr $plug`;
	        if($pinned != 0) {
	            //yes we're pinned.
	            return 1;
	        }	    	    
	    }
	}
	return 0;
}

global proc int getEffectorTranslatePinState(string $obj)
{
	int $translatePinned = false;

	if (`objectType $obj` != "hikEffector")
		return $translatePinned;

	string $plug = $obj + ".pinning";
	int $pinned = `getAttr $plug`;
	if ($pinned == 1 ||  $pinned == 3)
	{
		$translatePinned = true;
	}

	return $translatePinned;
}

global proc setEffectorTranslatePinState(string $obj, int $pinTranslate)
// Sets the translate pin state without affecting the current rotate pin state
{
	if (`objectType $obj` != "hikEffector")
		return;

	// Determine the new pin state based on the previous pin state
	// and the new translate pin state

	string $plug = $obj + ".pinning";
	int $pinned = `getAttr $plug`;
	switch ($pinned)
	{
		case 0: // Currently nothing pinned
			if ($pinTranslate)
				$pinned = 1;
			break;
		case 1: // Currently translate pinned
			if (!$pinTranslate)
				$pinned = 0;
			break;
		case 2: // Currently rotate pinned
			if ($pinTranslate)
				$pinned = 3;
			break;
		case 3:  // Currently both translate and rotate pinned
			if (!$pinTranslate)
				$pinned = 2;
			break;
		default:
			print ((uiRes("m_loadFullBodyIKFunctions.kUnexpectedPinningState")));
			break;
	}

	//print ("New pinned state is " + $pinned + " for translate " + $pinTranslate + "\n");
	setAttr $plug $pinned;
}

global proc int getEffectorRotatePinState(string $obj)
{
	int $rotatePinned = false;

	if (`objectType $obj` != "hikEffector")
		return $rotatePinned;
	
	string $plug = $obj + ".pinning";
	int $pinned = `getAttr $plug`;
	if ($pinned == 2 ||  $pinned == 3)
	{
		$rotatePinned = true;
	}

	return $rotatePinned;
}

global proc setEffectorRotatePinState(string $obj, int $pinRotate)
// Sets the rotate pin state without affecting the current translate pin state
{
	if (`objectType $obj` != "hikEffector")
		return;

	// Determine the new pin state based on the previous pin state
	// and the new rotate pin state

	string $plug = $obj + ".pinning";
	int $pinned = `getAttr $plug`;
	switch ($pinned)
	{
		case 0: // Currently nothing pinned
			if ($pinRotate)
				$pinned = 2;
			break;
		case 1: // Currently translate pinned
			if ($pinRotate)
				$pinned = 3;
			break;
		case 2: // Currently rotate pinned
			if (!$pinRotate)
				$pinned = 0;
			break;
		case 3:  // Currently both translate and rotate pinned
			if (!$pinRotate)
				$pinned = 1;
			break;
		default:
			print `uiRes("m_loadFullBodyIKFunctions.kUnexpectedPinningState")`;
			break;
	}

	//print ("New pinned state is " + $pinned + " for rotate " + $pinRotate + "\n");
	setAttr $plug $pinned;
}


proc int findJointsAndEffectorsUpToPin(string $joint,string $jointsUpToPin[],string $effectorsUpToPin[])
//
//  Description:
//      Given a joint, go up the hierarchy from it, adding any joints and effectors along the way to 
//  the corresponding arrays.  We stop when we find an effector that is pinned.
{
    $jointsUpToPin[size($jointsUpToPin)] = $joint;
    addEffectorsFromJointToArray($joint,$effectorsUpToPin);        	
	
	string $parent[] = `listRelatives -p -pa $joint`;
	if((size($parent)>0) && (`nodeType $parent[0]` == "joint")) {
	    if(isJointPinned($parent[0])) {            
            $jointsUpToPin[size($jointsUpToPin)] = $parent[0];                        
            addEffectorsFromJointToArray($parent[0],$effectorsUpToPin);                        
	        return 1;
        }
        else {
            return findJointsAndEffectorsUpToPin($parent[0],$jointsUpToPin,$effectorsUpToPin);
        }        
	}
	else {
	    error( (uiRes("m_loadFullBodyIKFunctions.kUnableToKeyToPin")) );
	    return 0;
	}	            
}


global proc addJointAndEffector(string $joint,string $jointsArray[],
                                    string $effectorsArray[])
//
//  Description:
//      Add the joint and any effector it is connected to into the corresponding
//  arrays.
//                                    
{
    $jointsArray[size($jointsArray)] = $joint;
    addEffectorsFromJointToArray($joint,$effectorsArray);            
}                                    


proc int jointIdInArray(string $name,int $arrayOfIds[])
{
    string $plug = $name + ".hikNodeID";
    int $jointId = `getAttr $plug`;
    for($id in $arrayOfIds) {
        if($jointId == $id) {            
            return 1;                        
        }
    }
    return 0;
}


proc int findJointWithHikId(string $root,int $hikNodeId,
                            string $bodyPartJoints[],
                            string $bodyPartEffectors[])
//  Description:
//      Given the root, traverse the entire hierarchy looking for a joint with
//  hikNodeId.  If it is found, the joint is added to bodyPartJoints, and the
//  associated effector(s) if any, will be added to bodyPartEffectors.
//  Returns whether the joint with hikNodeId was found or not.                            
{
    //go down.
     string $kids[] = `listRelatives -ad -pa $root`;
     for($kid in $kids) {
        if(`nodeType $kid` == "joint") {
            string $plug = $kid + ".hikNodeID";
            int $jointId = `getAttr $plug`;
            if($jointId == $hikNodeId) {
                addJointAndEffector($kid,$bodyPartJoints,$bodyPartEffectors);
                return 1;
            }
        }
    }
    return 0;
     
}                            

global proc int findBodyPartsToKey(string $joint,string $bodyPartJoints[],string $bodyPartEffectors[])
//
//  Description:
//      Given a joint, find the related joints and effectors of the bodypart to which they all
//  belong.
//
{
            
    string $plug = $joint + ".hikNodeID";
    int $jointId = `getAttr $plug`;
    string $root = findRootJoint($joint);
    
    int $hipsNodeId = 1;
    int $leftHipNodeId = 2;
    int $leftKneeNodeId = 3;
    int $leftAnkleNodeId = 4; 
    int $rightHipNodeId =5;
    int $rightKneeNodeId =6;
    int $rightAnkleNodeId =7;
    int $spine0NodeId =8;
    int $leftShoulderNodeId =9;
    int $leftElbowNodeId = 10;
    int $leftWristNodeId = 11;
    int $rightShoulderNodeId =12;
    int $rightElbowNodeId =13;
    int $rightWristNodeId =14;
    int $headNodeId =15;
    int $leftFootNodeId = 16;
    int $rightFootNodeId = 17;
    int $leftCollarNodeId = 18;
    int $rightCollarNodeId = 19;
        
    int $neckNodeId = 20;
    int $leftHandNodeId = 21;
    int $rightHandNodeId = 22;
    
    int $spine1NodeId = 23;
    int $spine2NodeId = 24;
    int $spine3NodeId = 25;
    int $spine4NodeId = 26;
    int $spine5NodeId = 27;
    int $spine6NodeId = 28;
    int $spine7NodeId = 29;
    int $spine8NodeId = 30;
    int $spine9NodeId = 31;
    
    int $neck1NodeId = 32;
    int $neck2NodeId = 33;
    int $neck3NodeId = 34;
    int $neck4NodeId = 35;
    int $neck5NodeId = 36;
    int $neck6NodeId = 37;
    int $neck7NodeId = 38;
    int $neck8NodeId = 39;    
    int $neck9NodeId = 40;
    int $leftHipRollNodeId = 41;
    int $leftKneeRollNodeId = 42;
    int $rightHipRollNodeId = 43;
    int $rightKneeRollNodeId = 44;
    int $leftShoulderRollNodeId = 45;
    int $leftElbowRollNodeId = 46;
    int $rightShoulderRollNodeId = 47;
    int $rightElbowRollNodeId = 48 ;
    
    int $leftThumbANodeId = 50;
    int $leftThumbBNodeId = 51;
    int $leftThumbCNodeId = 52;
    int $leftThumbDNodeId = 53;
    
    int $leftIndexANodeId = 54;
    int $leftIndexBNodeId = 55;
    int $leftIndexCNodeId = 56;
    int $leftIndexDNodeId = 57;        
    
    int $leftMiddleANodeId = 58;
    int $leftMiddleBNodeId = 59;
    int $leftMiddleCNodeId = 60;
    int $leftMiddleDNodeId = 61;
    
    int $leftRingANodeId = 62;
    int $leftRingBNodeId = 63;
    int $leftRingCNodeId = 64;
    int $leftRingDNodeId = 65;
    
    int $leftPinkyANodeId = 66;
    int $leftPinkyBNodeId = 67;    
    int $leftPinkyCNodeId = 68;
    int $leftPinkyDNodeId = 69;
    
    int $leftExtraFingerANodeId =70;
    int $leftExtraFingerBNodeId =71;
    int $leftExtraFingerCNodeId =72;
    int $leftExtraFingerDNodeId =73;
    
    int $rightThumbANodeId = 74;
    int $rightThumbBNodeId = 75;
    int $rightThumbCNodeId = 76;
    int $rightThumbDNodeId = 77;
    
    int $rightIndexANodeId = 78;
    int $rightIndexBNodeId = 79;
    int $rightIndexCNodeId = 80;
    int $rightIndexDNodeId = 81;
    
    int $rightMiddleANodeId = 82;
    int $rightMiddleBNodeId = 83;
    int $rightMiddleCNodeId = 84;
    int $rightMiddleDNodeId = 85;
    
    int $rightRingANodeId =86;
    int $rightRingBNodeId =87;
    int $rightRingCNodeId =88;
    int $rightRingDNodeId =89;
    
    int $rightPinkyANodeId = 90;
    int $rightPinkyBNodeId = 91;
    int $rightPinkyCNodeId = 92;
    int $rightPinkyDNodeId = 93;
    
    int $rightExtraFingerANodeId = 94;
    int $rightExtraFingerBNodeId = 95;
    int $rightExtraFingerCNodeId = 96;
    int $rightExtraFingerDNodeId = 97;
    
    int $leftFootThumbANodeId = 98;
    int $leftFootThumbBNodeId = 90;
    int $leftFootThumbCNodeId = 100;
    int $leftFootThumbDNodeId = 101;
    
    int $leftFootIndexANodeId = 102;
    int $leftFootIndexBNodeId = 103;
    int $leftFootIndexCNodeId = 104;
    int $leftFootIndexDNodeId = 105;
    
    int $leftFootMiddleANodeId = 106;
    int $leftFootMiddleBNodeId = 107;
    int $leftFootMiddleCNodeId = 108;
    int $leftFootMiddleDNodeId = 109;
    
    int $leftFootRingANodeId = 110;
    int $leftFootRingBNodeId = 111;
    int $leftFootRingCNodeId = 112;
    int $leftFootRingDNodeId = 113;
    
    int $leftFootPinkyANodeId = 114;
    int $leftFootPinkyBNodeId = 115;
    int $leftFootPinkyCNodeId = 116;
    int $leftFootPinkyDNodeId = 117;
    
    int $leftFootExtraFingerANodeId = 118;
    int $leftFootExtraFingerBNodeId = 119;
    int $leftFootExtraFingerCNodeId = 120;
    int $leftFootExtraFingerDNodeId = 121;
    
    int $rightFootThumbANodeId = 122;
    int $rightFootThumbBNodeId = 123;
    int $rightFootThumbCNodeId = 124;
    int $rightFootThumbDNodeId = 125;
    
    int $rightFootIndexANodeId = 126;
    int $rightFootIndexBNodeId = 127;
    int $rightFootIndexCNodeId = 128;
    int $rightFootIndexDNodeId = 129;
    
    int $rightFootMiddleANodeId = 130;
    int $rightFootMiddleBNodeId = 131;
    int $rightFootMiddleCNodeId = 132;
    int $rightFootMiddleDNodeId = 133;
    
    int $rightFootRingANodeId = 134;
    int $rightFootRingBNodeId = 135;
    int $rightFootRingCNodeId = 136;
    int $rightFootRingDNodeId = 137;
    
    int $rightFootPinkyANodeId = 138;
    int $rightFootPinkyBNodeId = 139;
    int $rightFootPinkyCNodeId = 140;
    int $rightFootPinkyDNodeId = 141;
    
    int $rightFootExtraFingerANodeId = 142;
    int $rightFootExtraFingerBNodeId = 143;
    int $rightFootExtraFingerCNodeId = 144;
    int $rightFootExtraFingerDNodeId = 145;
    
    int $numFound = 0;
    //left arm.
    if($jointId == $leftCollarNodeId || 
       $jointId == $leftShoulderNodeId || 
       $jointId == $leftShoulderRollNodeId ||
       $jointId == $leftElbowNodeId ||
       $jointId == $leftElbowRollNodeId ||
       $jointId == $leftWristNodeId ||
       $jointId == $leftHandNodeId) {        
        $numFound += findJointWithHikId($root,$leftCollarNodeId,$bodyPartJoints,$bodyPartEffectors);
        $numFound += findJointWithHikId($root,$leftShoulderNodeId,$bodyPartJoints,$bodyPartEffectors);
        $numFound += findJointWithHikId($root,$leftShoulderRollNodeId,$bodyPartJoints,$bodyPartEffectors);
        $numFound += findJointWithHikId($root,$leftElbowNodeId,$bodyPartJoints,$bodyPartEffectors);
        $numFound += findJointWithHikId($root,$leftElbowRollNodeId,$bodyPartJoints,$bodyPartEffectors);
        $numFound += findJointWithHikId($root,$leftWristNodeId,$bodyPartJoints,$bodyPartEffectors);
        $numFound += findJointWithHikId($root,$leftHandNodeId,$bodyPartJoints,$bodyPartEffectors);        
    }
    //right arm.
    else if($jointId == $rightCollarNodeId || 
            $jointId == $rightShoulderNodeId || 
            $jointId == $rightShoulderRollNodeId ||
            $jointId == $rightElbowNodeId ||
            $jointId == $rightElbowRollNodeId ||
            $jointId == $rightWristNodeId ||
            $jointId == $rightHandNodeId) {        
        $numFound += findJointWithHikId($root,$rightCollarNodeId,$bodyPartJoints,$bodyPartEffectors);
        $numFound += findJointWithHikId($root,$rightShoulderNodeId,$bodyPartJoints,$bodyPartEffectors);
        $numFound += findJointWithHikId($root,$rightShoulderRollNodeId,$bodyPartJoints,$bodyPartEffectors);
        $numFound += findJointWithHikId($root,$rightElbowNodeId,$bodyPartJoints,$bodyPartEffectors);
        $numFound += findJointWithHikId($root,$rightElbowRollNodeId,$bodyPartJoints,$bodyPartEffectors);
        $numFound += findJointWithHikId($root,$rightWristNodeId,$bodyPartJoints,$bodyPartEffectors);
        $numFound += findJointWithHikId($root,$rightHandNodeId,$bodyPartJoints,$bodyPartEffectors);        
    }        
    //left leg
    else if($jointId == $leftHipNodeId || 
            $jointId == $leftHipRollNodeId || 
            $jointId == $leftKneeNodeId ||
            $jointId == $leftKneeRollNodeId ||
            $jointId == $leftAnkleNodeId ||
            $jointId == $leftFootNodeId) {        
        $numFound += findJointWithHikId($root,$leftHipNodeId,$bodyPartJoints,$bodyPartEffectors);
        $numFound += findJointWithHikId($root,$leftHipRollNodeId,$bodyPartJoints,$bodyPartEffectors);
        $numFound += findJointWithHikId($root,$leftKneeNodeId,$bodyPartJoints,$bodyPartEffectors);
        $numFound += findJointWithHikId($root,$leftKneeRollNodeId,$bodyPartJoints,$bodyPartEffectors);
        $numFound += findJointWithHikId($root,$leftAnkleNodeId,$bodyPartJoints,$bodyPartEffectors);
        $numFound += findJointWithHikId($root,$leftFootNodeId,$bodyPartJoints,$bodyPartEffectors);        
    } 
    //right leg
    else if($jointId == $rightHipNodeId || 
            $jointId == $rightHipRollNodeId || 
            $jointId == $rightKneeNodeId ||
            $jointId == $rightKneeRollNodeId ||
            $jointId == $rightAnkleNodeId ||
            $jointId == $rightFootNodeId) {        
        $numFound += findJointWithHikId($root,$rightHipNodeId,$bodyPartJoints,$bodyPartEffectors);
        $numFound += findJointWithHikId($root,$rightHipRollNodeId,$bodyPartJoints,$bodyPartEffectors);
        $numFound += findJointWithHikId($root,$rightKneeNodeId,$bodyPartJoints,$bodyPartEffectors);
        $numFound += findJointWithHikId($root,$rightKneeRollNodeId,$bodyPartJoints,$bodyPartEffectors);
        $numFound += findJointWithHikId($root,$rightAnkleNodeId,$bodyPartJoints,$bodyPartEffectors);
        $numFound += findJointWithHikId($root,$rightFootNodeId,$bodyPartJoints,$bodyPartEffectors);        
    }
    //neck and head.    
    else if($jointId == $headNodeId || 
            $jointId == $neckNodeId || 
            ($jointId >= $neck1NodeId && $jointId <= $neck9NodeId)) {
        $numFound += findJointWithHikId($root,$headNodeId,$bodyPartJoints,$bodyPartEffectors);
        $numFound += findJointWithHikId($root,$neckNodeId,$bodyPartJoints,$bodyPartEffectors);
        $numFound += findJointWithHikId($root,$neck1NodeId,$bodyPartJoints,$bodyPartEffectors);
        $numFound += findJointWithHikId($root,$neck2NodeId,$bodyPartJoints,$bodyPartEffectors);
        $numFound += findJointWithHikId($root,$neck3NodeId,$bodyPartJoints,$bodyPartEffectors);
        $numFound += findJointWithHikId($root,$neck4NodeId,$bodyPartJoints,$bodyPartEffectors);        
        $numFound += findJointWithHikId($root,$neck5NodeId,$bodyPartJoints,$bodyPartEffectors);
        $numFound += findJointWithHikId($root,$neck6NodeId,$bodyPartJoints,$bodyPartEffectors);
        $numFound += findJointWithHikId($root,$neck7NodeId,$bodyPartJoints,$bodyPartEffectors);
        $numFound += findJointWithHikId($root,$neck8NodeId,$bodyPartJoints,$bodyPartEffectors);
        $numFound += findJointWithHikId($root,$neck9NodeId,$bodyPartJoints,$bodyPartEffectors);                
    }
    //spine
    else if($jointId == $spine0NodeId ||
            ($jointId >= $spine1NodeId && $jointId <= $spine9NodeId)) {
        $numFound += findJointWithHikId($root,$spine0NodeId,$bodyPartJoints,$bodyPartEffectors);
        $numFound += findJointWithHikId($root,$spine1NodeId,$bodyPartJoints,$bodyPartEffectors);        
        $numFound += findJointWithHikId($root,$spine2NodeId,$bodyPartJoints,$bodyPartEffectors);
        $numFound += findJointWithHikId($root,$spine3NodeId,$bodyPartJoints,$bodyPartEffectors);
        $numFound += findJointWithHikId($root,$spine4NodeId,$bodyPartJoints,$bodyPartEffectors);        
        $numFound += findJointWithHikId($root,$spine5NodeId,$bodyPartJoints,$bodyPartEffectors);
        $numFound += findJointWithHikId($root,$spine6NodeId,$bodyPartJoints,$bodyPartEffectors);
        $numFound += findJointWithHikId($root,$spine7NodeId,$bodyPartJoints,$bodyPartEffectors);
        $numFound += findJointWithHikId($root,$spine8NodeId,$bodyPartJoints,$bodyPartEffectors);
        $numFound += findJointWithHikId($root,$spine9NodeId,$bodyPartJoints,$bodyPartEffectors);
                
    }        
    //hips
    else if($jointId == $hipsNodeId ) {
        addJointAndEffector($joint,$bodyPartJoints,$bodyPartEffectors);
        $numFound = 1;
    }    
    //left thumb
    else if($jointId >= $leftThumbANodeId && $jointId <= $leftThumbDNodeId ) {
        $numFound += findJointWithHikId($root,$leftThumbANodeId,$bodyPartJoints,$bodyPartEffectors);
        $numFound += findJointWithHikId($root,$leftThumbBNodeId,$bodyPartJoints,$bodyPartEffectors);
        $numFound += findJointWithHikId($root,$leftThumbCNodeId,$bodyPartJoints,$bodyPartEffectors);
        $numFound += findJointWithHikId($root,$leftThumbDNodeId,$bodyPartJoints,$bodyPartEffectors);
    }
    //left index
    else if($jointId >= $leftIndexANodeId && $jointId <= $leftIndexDNodeId ) {
        $numFound += findJointWithHikId($root,$leftIndexANodeId,$bodyPartJoints,$bodyPartEffectors);
        $numFound += findJointWithHikId($root,$leftIndexBNodeId,$bodyPartJoints,$bodyPartEffectors);
        $numFound += findJointWithHikId($root,$leftIndexCNodeId,$bodyPartJoints,$bodyPartEffectors);
        $numFound += findJointWithHikId($root,$leftIndexDNodeId,$bodyPartJoints,$bodyPartEffectors);        
    }
    //left middle
    else if($jointId >= $leftMiddleANodeId && $jointId <= $leftMiddleDNodeId ) {
        $numFound += findJointWithHikId($root,$leftMiddleANodeId,$bodyPartJoints,$bodyPartEffectors);
        $numFound += findJointWithHikId($root,$leftMiddleBNodeId,$bodyPartJoints,$bodyPartEffectors);
        $numFound += findJointWithHikId($root,$leftMiddleCNodeId,$bodyPartJoints,$bodyPartEffectors);
        $numFound += findJointWithHikId($root,$leftMiddleDNodeId,$bodyPartJoints,$bodyPartEffectors);        
    }
    //left ring
    else if($jointId >= $leftRingANodeId && $jointId <= $leftRingDNodeId ) {
        $numFound += findJointWithHikId($root,$leftRingANodeId,$bodyPartJoints,$bodyPartEffectors);
        $numFound += findJointWithHikId($root,$leftRingBNodeId,$bodyPartJoints,$bodyPartEffectors);
        $numFound += findJointWithHikId($root,$leftRingCNodeId,$bodyPartJoints,$bodyPartEffectors);
        $numFound += findJointWithHikId($root,$leftRingDNodeId,$bodyPartJoints,$bodyPartEffectors);        
    }
    //left pinky
    else if($jointId >= $leftPinkyANodeId && $jointId <= $leftPinkyDNodeId ) {
        $numFound += findJointWithHikId($root,$leftPinkyANodeId,$bodyPartJoints,$bodyPartEffectors);
        $numFound += findJointWithHikId($root,$leftPinkyBNodeId,$bodyPartJoints,$bodyPartEffectors);
        $numFound += findJointWithHikId($root,$leftPinkyCNodeId,$bodyPartJoints,$bodyPartEffectors);
        $numFound += findJointWithHikId($root,$leftPinkyDNodeId,$bodyPartJoints,$bodyPartEffectors);        
    }
    //left extra
    else if($jointId >= $leftExtraFingerANodeId && $jointId <= $leftExtraFingerDNodeId ) {
        $numFound += findJointWithHikId($root,$leftExtraFingerANodeId,$bodyPartJoints,$bodyPartEffectors);
        $numFound += findJointWithHikId($root,$leftExtraFingerBNodeId,$bodyPartJoints,$bodyPartEffectors);
        $numFound += findJointWithHikId($root,$leftExtraFingerCNodeId,$bodyPartJoints,$bodyPartEffectors);
        $numFound += findJointWithHikId($root,$leftExtraFingerDNodeId,$bodyPartJoints,$bodyPartEffectors);        
    }
    //left foot thumb
    else if($jointId >= $leftFootThumbANodeId && $jointId <= $leftFootThumbDNodeId ) {
        $numFound += findJointWithHikId($root,$leftFootThumbANodeId,$bodyPartJoints,$bodyPartEffectors);
        $numFound += findJointWithHikId($root,$leftFootThumbBNodeId,$bodyPartJoints,$bodyPartEffectors);
        $numFound += findJointWithHikId($root,$leftFootThumbCNodeId,$bodyPartJoints,$bodyPartEffectors);
        $numFound += findJointWithHikId($root,$leftFootThumbDNodeId,$bodyPartJoints,$bodyPartEffectors);        
    }
    //left foot index    
    else if($jointId >= $leftFootIndexANodeId && $jointId <= $leftFootIndexDNodeId ) {
        $numFound += findJointWithHikId($root,$leftFootIndexANodeId,$bodyPartJoints,$bodyPartEffectors);
        $numFound += findJointWithHikId($root,$leftFootIndexBNodeId,$bodyPartJoints,$bodyPartEffectors);
        $numFound += findJointWithHikId($root,$leftFootIndexCNodeId,$bodyPartJoints,$bodyPartEffectors);
        $numFound += findJointWithHikId($root,$leftFootIndexDNodeId,$bodyPartJoints,$bodyPartEffectors);        
    }
    //left foot middle
    else if($jointId >= $leftFootMiddleANodeId && $jointId <= $leftFootMiddleDNodeId ) {
        $numFound += findJointWithHikId($root,$leftFootMiddleANodeId,$bodyPartJoints,$bodyPartEffectors);
        $numFound += findJointWithHikId($root,$leftFootMiddleBNodeId,$bodyPartJoints,$bodyPartEffectors);
        $numFound += findJointWithHikId($root,$leftFootMiddleCNodeId,$bodyPartJoints,$bodyPartEffectors);
        $numFound += findJointWithHikId($root,$leftFootMiddleDNodeId,$bodyPartJoints,$bodyPartEffectors);        
    }
    //left foot ring
    else if($jointId >= $leftFootRingANodeId && $jointId <= $leftFootRingDNodeId ) {
        $numFound += findJointWithHikId($root,$leftFootRingANodeId,$bodyPartJoints,$bodyPartEffectors);
        $numFound += findJointWithHikId($root,$leftFootRingBNodeId,$bodyPartJoints,$bodyPartEffectors);
        $numFound += findJointWithHikId($root,$leftFootRingCNodeId,$bodyPartJoints,$bodyPartEffectors);
        $numFound += findJointWithHikId($root,$leftFootRingDNodeId,$bodyPartJoints,$bodyPartEffectors);        
    }
    //left foot pinky
    else if($jointId >= $leftFootPinkyANodeId && $jointId <= $leftFootPinkyDNodeId ) {
        $numFound += findJointWithHikId($root,$leftFootPinkyANodeId,$bodyPartJoints,$bodyPartEffectors);
        $numFound += findJointWithHikId($root,$leftFootPinkyBNodeId,$bodyPartJoints,$bodyPartEffectors);
        $numFound += findJointWithHikId($root,$leftFootPinkyCNodeId,$bodyPartJoints,$bodyPartEffectors);
        $numFound += findJointWithHikId($root,$leftFootPinkyDNodeId,$bodyPartJoints,$bodyPartEffectors);        
    }
    //left foot extra
    else if($jointId >= $leftFootExtraFingerANodeId && $jointId <= $leftFootExtraFingerDNodeId ) {
        $numFound += findJointWithHikId($root,$leftFootExtraFingerANodeId,$bodyPartJoints,$bodyPartEffectors);
        $numFound += findJointWithHikId($root,$leftFootExtraFingerBNodeId,$bodyPartJoints,$bodyPartEffectors);
        $numFound += findJointWithHikId($root,$leftFootExtraFingerCNodeId,$bodyPartJoints,$bodyPartEffectors);
        $numFound += findJointWithHikId($root,$leftFootExtraFingerDNodeId,$bodyPartJoints,$bodyPartEffectors);        
    }
    
    //right thumb
    else if($jointId >= $rightThumbANodeId && $jointId <= $rightThumbDNodeId ) {
        $numFound += findJointWithHikId($root,$rightThumbANodeId,$bodyPartJoints,$bodyPartEffectors);
        $numFound += findJointWithHikId($root,$rightThumbBNodeId,$bodyPartJoints,$bodyPartEffectors);
        $numFound += findJointWithHikId($root,$rightThumbCNodeId,$bodyPartJoints,$bodyPartEffectors);
        $numFound += findJointWithHikId($root,$rightThumbDNodeId,$bodyPartJoints,$bodyPartEffectors);
    }
    //right index
    else if($jointId >= $rightIndexANodeId && $jointId <= $rightIndexDNodeId ) {
        $numFound += findJointWithHikId($root,$rightIndexANodeId,$bodyPartJoints,$bodyPartEffectors);
        $numFound += findJointWithHikId($root,$rightIndexBNodeId,$bodyPartJoints,$bodyPartEffectors);
        $numFound += findJointWithHikId($root,$rightIndexCNodeId,$bodyPartJoints,$bodyPartEffectors);
        $numFound += findJointWithHikId($root,$rightIndexDNodeId,$bodyPartJoints,$bodyPartEffectors);        
    }
    //right middle
    else if($jointId >= $rightMiddleANodeId && $jointId <= $rightMiddleDNodeId ) {
        $numFound += findJointWithHikId($root,$rightMiddleANodeId,$bodyPartJoints,$bodyPartEffectors);
        $numFound += findJointWithHikId($root,$rightMiddleBNodeId,$bodyPartJoints,$bodyPartEffectors);
        $numFound += findJointWithHikId($root,$rightMiddleCNodeId,$bodyPartJoints,$bodyPartEffectors);
        $numFound += findJointWithHikId($root,$rightMiddleDNodeId,$bodyPartJoints,$bodyPartEffectors);        
    }
    //right ring
    else if($jointId >= $rightRingANodeId && $jointId <= $rightRingDNodeId ) {
        $numFound += findJointWithHikId($root,$rightRingANodeId,$bodyPartJoints,$bodyPartEffectors);
        $numFound += findJointWithHikId($root,$rightRingBNodeId,$bodyPartJoints,$bodyPartEffectors);
        $numFound += findJointWithHikId($root,$rightRingCNodeId,$bodyPartJoints,$bodyPartEffectors);
        $numFound += findJointWithHikId($root,$rightRingDNodeId,$bodyPartJoints,$bodyPartEffectors);        
    }
    //right pinky
    else if($jointId >= $rightPinkyANodeId && $jointId <= $rightPinkyDNodeId ) {
        $numFound += findJointWithHikId($root,$rightPinkyANodeId,$bodyPartJoints,$bodyPartEffectors);
        $numFound += findJointWithHikId($root,$rightPinkyBNodeId,$bodyPartJoints,$bodyPartEffectors);
        $numFound += findJointWithHikId($root,$rightPinkyCNodeId,$bodyPartJoints,$bodyPartEffectors);
        $numFound += findJointWithHikId($root,$rightPinkyDNodeId,$bodyPartJoints,$bodyPartEffectors);        
    }
    //right extra
    else if($jointId >= $rightExtraFingerANodeId && $jointId <= $rightExtraFingerDNodeId ) {
        $numFound += findJointWithHikId($root,$rightExtraFingerANodeId,$bodyPartJoints,$bodyPartEffectors);
        $numFound += findJointWithHikId($root,$rightExtraFingerBNodeId,$bodyPartJoints,$bodyPartEffectors);
        $numFound += findJointWithHikId($root,$rightExtraFingerCNodeId,$bodyPartJoints,$bodyPartEffectors);
        $numFound += findJointWithHikId($root,$rightExtraFingerDNodeId,$bodyPartJoints,$bodyPartEffectors);        
    }
    //right foot thumb
    else if($jointId >= $rightFootThumbANodeId && $jointId <= $rightFootThumbDNodeId ) {
        $numFound += findJointWithHikId($root,$rightFootThumbANodeId,$bodyPartJoints,$bodyPartEffectors);
        $numFound += findJointWithHikId($root,$rightFootThumbBNodeId,$bodyPartJoints,$bodyPartEffectors);
        $numFound += findJointWithHikId($root,$rightFootThumbCNodeId,$bodyPartJoints,$bodyPartEffectors);
        $numFound += findJointWithHikId($root,$rightFootThumbDNodeId,$bodyPartJoints,$bodyPartEffectors);        
    }
    //right foot index    
    else if($jointId >= $rightFootIndexANodeId && $jointId <= $rightFootIndexDNodeId ) {
        $numFound += findJointWithHikId($root,$rightFootIndexANodeId,$bodyPartJoints,$bodyPartEffectors);
        $numFound += findJointWithHikId($root,$rightFootIndexBNodeId,$bodyPartJoints,$bodyPartEffectors);
        $numFound += findJointWithHikId($root,$rightFootIndexCNodeId,$bodyPartJoints,$bodyPartEffectors);
        $numFound += findJointWithHikId($root,$rightFootIndexDNodeId,$bodyPartJoints,$bodyPartEffectors);        
    }
    //right foot middle
    else if($jointId >= $rightFootMiddleANodeId && $jointId <= $rightFootMiddleDNodeId ) {
        $numFound += findJointWithHikId($root,$rightFootMiddleANodeId,$bodyPartJoints,$bodyPartEffectors);
        $numFound += findJointWithHikId($root,$rightFootMiddleBNodeId,$bodyPartJoints,$bodyPartEffectors);
        $numFound += findJointWithHikId($root,$rightFootMiddleCNodeId,$bodyPartJoints,$bodyPartEffectors);
        $numFound += findJointWithHikId($root,$rightFootMiddleDNodeId,$bodyPartJoints,$bodyPartEffectors);        
    }
    //right foot ring
    else if($jointId >= $rightFootRingANodeId && $jointId <= $rightFootRingDNodeId ) {
        $numFound += findJointWithHikId($root,$rightFootRingANodeId,$bodyPartJoints,$bodyPartEffectors);
        $numFound += findJointWithHikId($root,$rightFootRingBNodeId,$bodyPartJoints,$bodyPartEffectors);
        $numFound += findJointWithHikId($root,$rightFootRingCNodeId,$bodyPartJoints,$bodyPartEffectors);
        $numFound += findJointWithHikId($root,$rightFootRingDNodeId,$bodyPartJoints,$bodyPartEffectors);        
    }
    //right foot pinky
    else if($jointId >= $rightFootPinkyANodeId && $jointId <= $rightFootPinkyDNodeId ) {
        $numFound += findJointWithHikId($root,$rightFootPinkyANodeId,$bodyPartJoints,$bodyPartEffectors);
        $numFound += findJointWithHikId($root,$rightFootPinkyBNodeId,$bodyPartJoints,$bodyPartEffectors);
        $numFound += findJointWithHikId($root,$rightFootPinkyCNodeId,$bodyPartJoints,$bodyPartEffectors);
        $numFound += findJointWithHikId($root,$rightFootPinkyDNodeId,$bodyPartJoints,$bodyPartEffectors);        
    }
    //right foot extra
    else if($jointId >= $rightFootExtraFingerANodeId && $jointId <= $rightFootExtraFingerDNodeId ) {
        $numFound += findJointWithHikId($root,$rightFootExtraFingerANodeId,$bodyPartJoints,$bodyPartEffectors);
        $numFound += findJointWithHikId($root,$rightFootExtraFingerBNodeId,$bodyPartJoints,$bodyPartEffectors);
        $numFound += findJointWithHikId($root,$rightFootExtraFingerCNodeId,$bodyPartJoints,$bodyPartEffectors);
        $numFound += findJointWithHikId($root,$rightFootExtraFingerDNodeId,$bodyPartJoints,$bodyPartEffectors);        
    }    
    
    return ($numFound > 0);
}


global proc findHikEffectors(string $itemIn,string $effectors[])
//
//  Description:
//      Checks if itemIn or the current selection is a hikEffector.  
//      If so, return the name effector.  If not, return the empty string.
//
{    
    string $selItems[] = `ls -sl`;
    if(size($itemIn) > 0) {
        $selItems[size($selItems)] = $itemIn;
	}
        
    for ($item in $selItems) {
        if(`objectType $item` == "hikEffector")
        {
            $effectors[size($effectors)] = $item;
        } else if (`objectType $item` == "joint") {
			string $eff = findHikEffectorFromJoint($item);
			if (size($eff)) {
				$effectors[size($effectors)] = $eff;
			}
        }                      
    }    
}

global proc findAllDescendentJointsAndEffectors(string $root,string $joints[],string $effectors[])
//
//  Description:
//      Given a the root joint, traverse the hierarchy, adding to
//  the return arrays the names of all joints and effectors those
//  joints might be connected to.
//
{
	
	$joints[size($joints)] = $root;
	//is there a connection to an effector?
	string $plug = $root + ".message";
	string $connectedNodes[] = `listConnections -type hikEffector -s 0 -d 1 $plug`;
	for ($node in $connectedNodes) {		
		$effectors[size($effectors)] = $node;			
	}			

	//now process all the children...
	string $children[] = `listRelatives -pa -allDescendents -type joint $root`;
	for( $child in $children) {
		$joints[size($joints)] = $child;
		$plug = $child + ".message";
	    $connectedNodes = `listConnections -type hikEffector -s 0 -d 1 $plug`;
	    for ($node in $connectedNodes) {		
		    $effectors[size($effectors)] = $node;			    
	    }
	}	
}

proc int keyJoints(string $joints[])
//
//  Description:
//      Given an array of joints, key their rotations using the minimizeRotation flag.
{
    string $names = "{";
    int $total = 0;
    //set keys on rotation of all joints.
    for ($joint in $joints) {
        string $quotedName = "\"" + $joint + "\",";
        $names += $quotedName;    
    }
    $names = substring($names,1,size($names)-1);
    $names += "}";
    
    string $cmd = "setKeyframe -at rotate -minimizeRotation 1 " + $names;
    $total = evalEcho ($cmd);
    return $total;
}

proc setEffectorLockedState(string $effectors[],int $lock)
//
//  Description:
//      The waist, lefthip and righthip effectors has their translation attributes locked. 
//      We'll have to unlock it here so we can key the translation and then re-lock it after.
//
{
    int $leftHipEffId = 16;
    int $rightHipEffId = 17;
    int $waistEffId = 9;
    string $txPlug;
    string $tyPlug;
    string $tzPlug;
    for ($effector in $effectors) {
		if (`referenceQuery -isNodeReferenced $effector`) {
			// the lock state cannot be modified on referenced nodes
			//
			continue;
		}
		
        string $effIdPlug = $effector + ".effectorID";
        int $effId = `getAttr $effIdPlug`;
        if($effId == $leftHipEffId || $effId == $rightHipEffId || $effId == $waistEffId) {
            $txPlug = $effector + ".tx";
            $tyPlug = $effector + ".ty";
            $tzPlug = $effector + ".tz";
            if($lock) {
                setAttr -lock on $txPlug;
                setAttr -lock on $tyPlug;
                setAttr -lock on $tzPlug;
            }
            else {
                setAttr -lock off $txPlug;
                setAttr -lock off $tyPlug;
                setAttr -lock off $tzPlug;
            }
        }
    }    
}

proc int keyEffectorsTranslationRotation(string $effectors[], int $keyType)
//
//  Description:
//      Given an array of effectors set keys on their rotation and translation.
//  	For ikKey, fkKey (keyType == 1, keyType == 2), then the tangent type is linear.
//  	For fkKey no reach (keyType == 3), then tangent type is global default.
{
    
    int $total = 0;
    string $names = "{";    
       
    setEffectorLockedState($effectors,0);
    for ($effector in $effectors) {        
        string $quotedName = "\"" + $effector + "\",";
        $names += $quotedName;    
    }
    $names = substring($names,1,size($names)-1);
    $names += "}";

	string $cmd;

	switch ($keyType)
	{
		case 1:
		case 2:
		    $cmd = "setKeyframe -at translate -itt linear -ott linear " + $names;
    		$total = $total + evalEcho ($cmd);        
    		$cmd = "setKeyframe -at rotate -minimizeRotation 1 -itt linear -ott linear " + $names;
    		$total = $total + evalEcho ($cmd);   
			break;
		case 3:
		    $cmd = "setKeyframe -at translate " + $names;
    		$total = $total + evalEcho ($cmd);        
    		$cmd = "setKeyframe -at rotate -minimizeRotation 1 " + $names;
    		$total = $total + evalEcho ($cmd);
			break;
		default:
		    print ((uiRes("m_loadFullBodyIKFunctions.kUnsupportedCase")));
	}    
    
    return $total;
}




proc int keyReachForEffector(string $plug, int $setIKKey, int $valueToKey)
//
//	Description:
//		Set a key on the reach value of one particular effector.
//  For ikKey (setIKKey == true), then the tangent type is -stepNext
//  For fkKey (setIKKey == false), then tangent type is -step
//
{
    int $total = 0;   	
    	
    //bug 227657 setKeyframe does not appear to be setting the tangent type correctly
    //when a key already exists.  Remove any existing key at the current time before
    //calling setKeyframe.
    int $curTime = `currentTime -q`;
    cutKey -clear -t $curTime $plug;
    
    setAttr $plug $valueToKey;	
	if ($setIKKey) {
	    $total += `setKeyframe -ott stepNext $plug`;
	}
	else {
	    $total += `setKeyframe -ott step $plug`;		
	}
	
	return $total;
}


proc int keyReach(string $activeEffector,string $effectors[], int $setIkKey)
//
//	Description:
//		Set key on the reach value of effectors.  The 1st effector in
//	the array is understood to be the "active" effector - the one the
//	user is currently manipulating.
//
{
    int $total = 0;
	if(size($effectors)<=0)
		return $total;   	
	
	string $attrs[] = {".reachTranslation",".reachRotation"};	

    for($attr in $attrs) {
	    for($eff in $effectors) {
		    string $plug = $eff + $attr;
		    if($eff == $activeEffector) {
			    $total = $total + keyReachForEffector($plug,$setIkKey,$setIkKey);
		    }
		    else {
			    $total = $total + keyReachForEffector($plug,$setIkKey,0);
		    }
	    }
	}		
	
	return $total;	

}

global proc int setKeysOnAllJointsAndHikEffectors(string $hikEffectors[],int $setFullBodyKeys,int $keyType)
//
//  Description:
//      Given the name of an hikEffector in $hikEffector, find and set keys on
//      all the joints and other hikEffectors in the full body ik system.
//
//		$setFullBodyKeys 1/2/3/4 :
//            if 1, set keys on all effectors and joints,
//            if 2, set keys on all effectors and joints of body part.
//            if 3, set keys on joints and effectors until 
//                a pinned ancestor is encountered.
//            if 4, set keys on the selected effector.
//      $keyType 1/2/3:
//			  if 1, set key on reach value of 1 for selected effector in body part
//                  other effectors get value of 0, tangent is stepNext
//            if 2, set key on reach value of 0 for all effectors in body part, 
//                  tangent is step
//            if 3, do not key reach value, do not explicitly set the tangent types
//
{
    int $total = 0;    
    int $count = 0;

	int $setIKKey = false;
	if ($keyType == 1)
	{
		$setIKKey = true;
	}

    string $hikHandlesAlreadyKeyed[];
    for($hikEffector in $hikEffectors) {
        
        
        //1st get the joint associated with this effector:
        string $plug = $hikEffector + ".fkjoint";
        string $jointName[] = `listConnections -s 1 -d 0 $plug`;
        if(size($jointName)<1) {
            error( (uiRes("m_loadFullBodyIKFunctions.kEffectorNotConnectedErr")) );
            return $total;
        }
        
        string $bodyPartJoints[] = {};
        string $bodyPartEffectors[] = {};
        if(findBodyPartsToKey($jointName[0],$bodyPartJoints,$bodyPartEffectors)==0) {        
            error( (uiRes("m_loadFullBodyIKFunctions.kUnableToIdentifyPartErr")) );
            return $total;
        }
        
        string $effectorHandlePlug = $hikEffector + ".handle";
        string $result[] = `listConnections -type hikHandle $effectorHandlePlug`;
        if(size($result) < 1) {
            error( (uiRes("m_loadFullBodyIKFunctions.kUnableToFindHikHandleErr")) );
            return $total;
        }
       
        int $handleAlreadyKeyed = 0;
                
        if(stringArrayContains($result[0],$hikHandlesAlreadyKeyed))
            $handleAlreadyKeyed = 1;
        
               
        if($setFullBodyKeys == 1 && !$handleAlreadyKeyed) {
            
            $hikHandlesAlreadyKeyed[size($hikHandlesAlreadyKeyed)] = $result[0];
            //key all
            string $rootJoint = findRootJoint($jointName[0]);
            string $joints[];
            string $effectors[];
            findAllDescendentJointsAndEffectors($rootJoint,$joints,$effectors);
            $total = $total + keyJoints($joints);
            $total = $total + keyEffectorsTranslationRotation($effectors, $keyType);            
            for ($joint in $joints) {                      
                string $plug = $joint + ".hikNodeID";
                int $jointId = `getAttr $plug`;                
                int $hipsNodeId = 1;
                if($jointId == $hipsNodeId) {
                    setKeyframe -at translate $joint;
                }
            }
        }
        else if($setFullBodyKeys == 2) {        
            //key body part
            $total = $total + keyJoints($bodyPartJoints);
            $total = $total + keyEffectorsTranslationRotation($bodyPartEffectors, $keyType);                      
            for ($bodyPartJoint in $bodyPartJoints) {                      
                string $plug = $bodyPartJoint + ".hikNodeID";
                int $jointId = `getAttr $plug`;                
                int $hipsNodeId = 1;
                if($jointId == $hipsNodeId) {
                    setKeyframe -at translate $bodyPartJoint;
                }
            }
        }
        else if($setFullBodyKeys == 3) {
            //key to pin
            string $jointsUpToPin[] = {};
            string $effectorsUpToPin[] = {};
            if(findJointsAndEffectorsUpToPin($jointName[0],$jointsUpToPin,$effectorsUpToPin)) {
                $total = $total + keyJoints($jointsUpToPin);
                $total = $total + keyEffectorsTranslationRotation($effectorsUpToPin, $keyType);
            }              
        }
        else if($setFullBodyKeys == 4) {
            //key selected.            
            string $effectors[];            
            $effectors[0] = $hikEffector;
            
                
            $total = $total + keyEffectorsTranslationRotation($effectors, $keyType);
			if ($keyType != 3)
			{                        
            	$total = $total + keyReach($hikEffector,$effectors,$setIKKey); 
			}
        }

        if($setFullBodyKeys != 4 && $keyType != 3)
		{
            $total = $total + keyReach($hikEffector,$bodyPartEffectors,$setIKKey); 
        }        
    }  
        
    return $total;
}


global proc string filterForHikEffectors(string $selectionConnection,int $wantHikEffectors)
//  Description:
//      Filters the current selection for hikEffectors.  If wantHikEffectors is true,
//      the names returned are all hikEffectors.  If it's false, then the names
//      returned will not contain any hikEffectors.
//
{
    string $names = "{";
    string $selItems[] = expandSelectionConnectionAsArray($selectionConnection);
    for ($item in $selItems) {
        if($wantHikEffectors) {
            if(`objectType $item` == "hikEffector")
            {
                string $quotedName = "\"" + $item + "\",";
                $names += $quotedName; 
            }
        }
        else {
            if(`objectType $item` != "hikEffector")
            {
                string $quotedName = "\"" + $item + "\",";
                $names += $quotedName; 
            }
        }
    }
    if(size($names)>1)
        $names = substring($names,1,size($names)-1);
    $names += "}";   
    return $names;
}

global proc int isFullBodyIKObject(string $object,int $checkForFK)
//
//  Description:
//      Returns whether an object is part of a FBIK system.
{
    if(`objectType $object` == "hikEffector")
    {
        string $handlePlug = $object + ".handle";
        string $conns[] = `listConnections -type hikHandle $handlePlug`;
        if(size($conns) > 0)
            return 1;
        else
            return 0;       
    }    
    else if(`objectType $object` == "joint")
    {
		string $nodeAttrList[];
		if(tokenize($object,".",$nodeAttrList) > 1)
			return 0;        
							
		// Only try to cnx if the attr exists.
		//
		if(attributeExists("message",$nodeAttrList[0]))
		{
			string $plug = $nodeAttrList[0] + ".message";
			string $connectedNodes[] = `listConnections -type hikHandle -plugs 1 -s 0 -d 1 $plug`;
			if(size($connectedNodes)>0) {
				if($checkForFK) {
					if(`match "fkjoints" $connectedNodes[0]` != "")
						return 1;
				}
				else
					return 1;	        
			}
		}
    }
    return 0;        
}


proc string[] findAllObjectsInFBIKSystem(string $object,string $allEffectors[])
//
//  Description:
//      Given that $object is part of a FBIK system, finds and returns the
//  rest of the keyable objects in the system.
{
    string $ret[];
    string $joint;
        
    if(`objectType $object` == "hikEffector")
    {
        string $plug = $object + ".fkjoint";
        string $jointName[] = `listConnections -s 1 -d 0 $plug`;
        if(size($jointName)<1) {
            error( uiRes("m_loadFullBodyIKFunctions.kEffectorNotConnectedErr") );
            return $ret;
        }
        $joint = $jointName[0];        
    }    
    else if(`objectType $object` == "joint")
    {
        $joint = $object;
    }
    
    string $rootJoint = findRootJoint($joint);
    string $joints[];
    string $effectors[];
    findAllDescendentJointsAndEffectors($rootJoint,$joints,$effectors);
    
    for($j in $joints) {
        $ret[size($ret)] = $j;
    }    
    for($e in $effectors) {
        $ret[size($ret)] = $e;
        $allEffectors[size($allEffectors)] = $e;
    }    
    return $ret;        
}


proc string[] findFBIKBodyPart(string $object,string $allEffectors[])
//
//  Description:
//      Given that $object is part of a FBIK system, finds and returns the
//  rest of the body part the object belongs to.
{
    string $ret[];
    string $joint;
        
    if(`objectType $object` == "hikEffector")
    {
        string $plug = $object + ".fkjoint";
        string $jointName[] = `listConnections -s 1 -d 0 $plug`;
        if(size($jointName)<1) {
            error( uiRes("m_loadFullBodyIKFunctions.kEffectorNotConnectedErr") );
            return $ret;
        }
        $joint = $jointName[0];        
    }    
    else if(`objectType $object` == "joint")
    {
        $joint = $object;
    }
    string $bodyPartJoints[];
    string $bodyPartEffectors[];
    findBodyPartsToKey($joint,$bodyPartJoints,$bodyPartEffectors);
    
    for($j in $bodyPartJoints) {
        $ret[size($ret)] = $j;
    }    
    for($e in $bodyPartEffectors) {
        $ret[size($ret)] = $e;
        $allEffectors[size($allEffectors)] = $e;
    }    
    return $ret;        
}

proc string[] findFBIKSelectedPart(string $object,string $allEffectors[])
//
//  Description:
//      Given that $object is part of a FBIK system, finds and returns the
//  effector or joint associated with this object.
{
    string $ret[];
    string $joint;
        
    if(`objectType $object` == "hikEffector")
    {
        string $plug = $object + ".fkjoint";
        string $jointName[] = `listConnections -s 1 -d 0 $plug`;
        if(size($jointName)<1) {
            error( uiRes("m_loadFullBodyIKFunctions.kEffectorNotConnectedErr") );
            return $ret;
        }
        $joint = $jointName[0];          
    }    
    else if(`objectType $object` == "joint")
    {
        $joint = $object;
        
    }
    string $bodyPartEffectors[];
    addJointAndEffector($joint,$ret,$bodyPartEffectors);
    for($e in $bodyPartEffectors) {
        $ret[size($ret)] = $e;
        $allEffectors[size($allEffectors)] = $e;
    }    
    return $ret;    
}

proc string getObjectsToClearKeys(string $allEffectors[],string $whichTypeOfKey)
//
//  Description:
//      Returns a string representing the names of the objects which should have
//  their keys cleared at this time. 
{
    string $objects[] = `ls -sl`;
    string $retObjects[];
    loadFullBodyIKFunctions();
    for($object in $objects) {
        int $objInRetList = AWNumberOfOccurrencesInStringArray ($object,$retObjects);        
        
        if($objInRetList == 0 && isFullBodyIKObject($object,0)) {
            string $sourceObject = $object;
            if(`objectType $object` == "joint") {
                //The object might be an input skeleton joint.  We need to check for this,
                //and if so, we need to get the FK joint underneath instead.
                string $joint = $object;
                string $jointRxPlug = $joint + ".rx";           
                string $characterNodeNames[] = `listConnections -type character -s 1 -d 0 $jointRxPlug`;
                if(size($characterNodeNames) == 0 ) {
                    //The user has selected a input skeleton joint.  In this case we
                    //need to find the associated fk joint.
                    string $jointMsgPlug = $joint + ".msg";           
                    string $hikHandlePlug[] = `listConnections -type hikHandle -s 0 -d 1 -p true $jointMsgPlug`;
                    if(size($hikHandlePlug) > 0) {
                        string $nodeAttrList[];
                        tokenize($hikHandlePlug[0],".",$nodeAttrList);
                        string $fkjointAttr = ".fk" + $nodeAttrList[1];
                        string $hikHandleFkPlug = $nodeAttrList[0] + $fkjointAttr;                
                        string $fkJoint[] = `listConnections -type joint -s 1 -d 0 $hikHandleFkPlug`;
                        if(size($fkJoint) > 0) 
                        {
                            $sourceObject = $fkJoint[0];
                        }
                        else
                            continue;                    
                    }                                                            
                }
            }
                        
            $retObjects[size($retObjects)] = $sourceObject;            
            
            string $fbikObjects[];
            if($whichTypeOfKey == "all") {            
                $fbikObjects = findAllObjectsInFBIKSystem($sourceObject,$allEffectors);
            }
            else if($whichTypeOfKey == "bodypart") {
                $fbikObjects = findFBIKBodyPart($sourceObject,$allEffectors);
            }
            else if($whichTypeOfKey == "selected") {
                $fbikObjects = findFBIKSelectedPart($sourceObject,$allEffectors);
            }
             
            for($fbikObject in $fbikObjects) {
                int $found = AWNumberOfOccurrencesInStringArray ($fbikObject,$retObjects);                
                if($found == 0) {
                    $retObjects[size($retObjects)] = $fbikObject;
                }
            }
        }                                
    }
    
    string $members = "{";    
    int $count = 0;
    for ($item in $retObjects) {
       if ($count != 0) {
          $members = $members + ", ";
       }
       $members = $members + "\"" + $item + "\"";
       $count++;
    }
    $members = $members + "}";
    return ($members);
}

proc resetSpecialEffectorChannels(string $effectors[],string $cmd)
//
//  Description:
//      The leftHip, rightHip, and waist effectors have their translation
//  channels locked (and marked not keyable) - at least in releases prior to Maya 2008.
//  This was a bad idea that caused many complications, including with
//  clearing keys for effectors.  This was a legacy function to
//  do special case handling for clearing keys for the above named
//  effectors.  Starting from Maya 2008, we will not lock those translation
//  channels any longer.  Here we should just mark the tranlation of these effectors
//  keyable, so any legacy rigs will have the right behavior when it comes to
//  clearing keys.
//
{
    int $leftHipEffId = 16;
    int $rightHipEffId = 17;
    int $waistEffId = 9;
    string $members = "{";
    int $count = 0;
    for ($effector in $effectors) {
        string $effIdPlug = $effector + ".effectorID";
        int $effId = `getAttr $effIdPlug`;
        if($effId == $leftHipEffId || $effId == $rightHipEffId || $effId == $waistEffId) {
            string $txPlug = $effector + ".tx";
            string $tyPlug = $effector + ".ty";
            string $tzPlug = $effector + ".tz";
            
            if(`getAttr -k $txPlug` == 0)
                setAttr -k on $txPlug;    
            if(`getAttr -k $tyPlug` == 0)                
                setAttr -k on $tyPlug;   
            if(`getAttr -k $tzPlug` == 0)     
                setAttr -k on $tzPlug;                
        }
    }    
}

global proc addEffectorAttrsToBodyPart(string $effs[])
//
//  Description:
//      Assuming each effector in effs is already properly 
//  hooked up, add its attributes to the character node 
//  representing the bodypart this effector is associated
//  with.
{    
    for($eff in $effs) {    
        //don't bother with this effector if it's already hooked up.
        string $effRxPlug = $eff + ".rx";
        string $effCharacterNodeNames[] = `listConnections -type character -s 1 -d 0 $effRxPlug`;
        if(size($effCharacterNodeNames) > 0)
            continue;
        
        //Find the fk joint associated with this effector.
        string $plug = $eff + ".fkjoint";
        string $jointName[] = `listConnections -s 1 -d 0 $plug`;
        if(size($jointName)<1) {
            error( uiRes("m_loadFullBodyIKFunctions.kEffectorNotConnectedErr") );
            return;
        }
        //locate the character node the fk joint is hooked up to, if any.
        string $jointRxPlug = $jointName[0] + ".rx";           
        string $characterNodeNames[] = `listConnections -type character -s 1 -d 0 $jointRxPlug`;
        if(size($characterNodeNames) > 0) {
            string $rxPlug = $eff + ".rx";
            string $ryPlug = $eff + ".ry";
            string $rzPlug = $eff + ".rz";
            string $txPlug = $eff + ".tx";
            string $tyPlug = $eff + ".ty";
            string $tzPlug = $eff + ".tz";
            string $reachTPlug = $eff + ".reachTranslation";
            string $reachRPlug = $eff + ".reachRotation";
                        
            character -edit -forceElement $characterNodeNames[0] $rxPlug $ryPlug $rzPlug $txPlug $tyPlug $tzPlug $reachTPlug $reachRPlug;
        }
        
    }        	
}

global proc clearFBIKKeyFromTimeSlider(string $whichTypeOfKey)
//
// Description:
//      Removes FBIK keys for objects controlled by Full Body IK.
//  $whichTypeOfKey can be:
//  "all" - Removes all FBIK keys
//  "bodypart" - Removes FBIK keys on the selected body part(s)
//  "selected" - Removes FBIK keys on the selected object(s)
{
    global string $gPlayBackSlider;
    string $timeSliderDisplay = `timeControl -q -showKeys $gPlayBackSlider`;
	if ($timeSliderDisplay != "active") {
		return;
	}
	
	string $cmd = ("cutKey -clear -iub false -an objects -t " + 
				   `timeControl -q -range $gPlayBackSlider` +
				   " -o keys");


    string $allEffectors[];
	string $members; 			    
    $members = getObjectsToClearKeys($allEffectors,$whichTypeOfKey);		        
    resetSpecialEffectorChannels($allEffectors,$cmd);
    if (($members == "") || ($members == "{}")) {
		warning ( (uiRes("m_loadFullBodyIKFunctions.kNoObjectsSelected")) );
	}
	else {
		eval ($cmd + " " + $members);
	}	
}

proc
string getTopParent(string $obj)
//
// Return the root of the hierarchy containing the specified object.
//
{
	string $parent;
	string $parents[] = `listRelatives -pa -p $obj`;
	if (size($parents) > 0) {
		$parent = getTopParent($parents[0]);
	} else {
		$parent = $obj;
	}
	return $parent;
}

proc
string getEffForJoint(string $obj)
//
// Return the nearest effector to the selected joint.
//
{
	string $eff;
	string $conns[] = `listConnections -type hikEffector ($obj+".message")`;
	if (size($conns) > 0) {
		return $conns[0];
	}
	
	string $parent;
	string $parents[] = `listRelatives -pa -p $obj`;
	if (size($parents) > 0) {
		$eff = getEffForJoint($parents[0]);
	}
	return $eff;
}

global proc string[] getEffectorsForJoints(string $jts[])
{
	string $effs[];
	for ($jt in $jts) {
		string $jtEff = getEffForJoint($jt);
		if (size($jtEff) > 0) {
			$effs[size($effs)] = $jtEff;
		}
	}
	return $effs;
}	

global proc string[] getFKJointsForEffectors(string $effs[])
{
	string $fkJoints[];
	for ($eff in $effs) {
		string $conns[] = `listConnections ($eff+".fkjoint")`;
		if (size($conns) > 0) {
			$fkJoints[size($fkJoints)] = $conns[0];
		}
	}
	return $fkJoints;
}

global proc string[] getParentsForFKJoints(string $fkJoints[])
{
	string $parents[];
	for ($fkj in $fkJoints) {
		string $topParent = getTopParent($fkj);
		if (0 == AWNumberOfOccurrencesInStringArray($topParent,$parents)) {
			$parents[size($parents)] = $topParent;
		}
	}
	return $parents;
}

global proc loadFullBodyIKFunctions()
//
// Description:
//      Dummy function to allow the above functions to be loaded on demand.
{
}
