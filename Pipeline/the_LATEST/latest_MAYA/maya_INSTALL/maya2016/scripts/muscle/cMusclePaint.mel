// Copyright (C) 1997-2014 Autodesk, Inc., and/or its licensors.
// All rights reserved.
//
// The coded instructions, statements, computer programs, and/or related
// material (collectively the "Data") in these files contain unpublished
// information proprietary to Autodesk, Inc. ("Autodesk") and/or its licensors,
// which is protected by U.S. and Canadian federal copyright law and by
// international treaties.
//
// The Data is provided for use exclusively by You. You have the right to use,
// modify, and incorporate this Data into other products for purposes authorized 
// by the Autodesk software license agreement, without fee.
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND. AUTODESK
// DOES NOT MAKE AND HEREBY DISCLAIMS ANY EXPRESS OR IMPLIED WARRANTIES
// INCLUDING, BUT NOT LIMITED TO, THE WARRANTIES OF NON-INFRINGEMENT,
// MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE, OR ARISING FROM A COURSE 
// OF DEALING, USAGE, OR TRADE PRACTICE. IN NO EVENT WILL AUTODESK AND/OR ITS
// LICENSORS BE LIABLE FOR ANY LOST REVENUES, DATA, OR PROFITS, OR SPECIAL,
// DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES, EVEN IF AUTODESK AND/OR ITS
// LICENSORS HAS BEEN ADVISED OF THE POSSIBILITY OR PROBABILITY OF SUCH DAMAGES.

// --------------------------------------------------------------------------

eval("source \"artAttrCallback.mel\";") ;		// REQUIRED!

/*
 * Global Vars
 */
global string $cMusclePaint_slots[] ;
global int $cMusclePaint_mIdx ;
global int $cMusclePaint_mode ;	// sticky or slide? or dir?
global string $cMusclePaint_modeStr ;	// String representing mode for use with commands
global int $cMusclePaint_normalize ; 	// normalize?
global string $cMusclePaint_polyGeo ;	// Name of poly geo we are painting on, if it is a poly.
global string $cMusclePaint_mS ;		// Muscle System for easier crap...sigh.
global string $cMusclePaint_mD ;		// Muscle System for easier crap...sigh.

global string $cMusclePaint_ForceMS ;	// For a certain muscleSystem node for the object when more than one exists?
global int $cMusclePaint_allowSave ;	// Allow save of state?


// Global wt stuff
string $cMusclePaint_wtNames[] = { "sticky", "stickyb", "stickyc", "sliding", "direction", "smartregiona",   "smartregionb",   "smartbulk",   "smartbulkangular",   "smartbulkwiden",    "smartslide",  "smartslideangular",  "smartsmooth",   "smartwrinkle", "smartflatten",  "smartvolumize",   "force", "jiggle", "cycle", "rest", "relax", "wrinkle",  "smooth", "smoothcompress",  "smoothexpand",  "selfcollision",  "selfrigidity",  "selfVolumize" };
string $cMusclePaint_wtLabels[] = {(uiRes("m_cMusclePaint.kSticky")),
	(uiRes("m_cMusclePaint.kStickyB")),
	(uiRes("m_cMusclePaint.kStickyC")),
	(uiRes("m_cMusclePaint.kSliding")),
	(uiRes("m_cMusclePaint.kDirection")),
	(uiRes("m_cMusclePaint.kSmartRegionA")),
	(uiRes("m_cMusclePaint.kSmartRegionB")),
	(uiRes("m_cMusclePaint.kSmartBulk")),
	(uiRes("m_cMusclePaint.kSmartBulkAngular")),
	(uiRes("m_cMusclePaint.kSmartBulkWiden")),
	(uiRes("m_cMusclePaint.kSmartSlide")),
	(uiRes("m_cMusclePaint.kSmartSlideAngular")),
	(uiRes("m_cMusclePaint.kSmartSmooth")),
	(uiRes("m_cMusclePaint.kSmartWrinkle")),
	(uiRes("m_cMusclePaint.kSmartFlatten")),
	(uiRes("m_cMusclePaint.kSmartVolumize")),
	(uiRes("m_cMusclePaint.kForce")),
	(uiRes("m_cMusclePaint.kJiggle")),
	(uiRes("m_cMusclePaint.kCycle")),
	(uiRes("m_cMusclePaint.kRest")),
	(uiRes("m_cMusclePaint.kRelax")),
	(uiRes("m_cMusclePaint.kWrinkle")),
	(uiRes("m_cMusclePaint.kSmooth")),
	(uiRes("m_cMusclePaint.kSmoothCompress")),
	(uiRes("m_cMusclePaint.kSmoothExpand")),
	(uiRes("m_cMusclePaint.kSelfCollision")),
	(uiRes("m_cMusclePaint.kSelfRigidity")),
	(uiRes("m_cMusclePaint.kSelfVolumize")) };
int $cMusclePaint_wtNormalize[] = {1,         1,          1,        0,             0,           0,                0,                0,            0,                      0,                0,                 0,                 0,                0,               0,              0,             0,         0,        0,     0,      0,       0,            0 ,        0,                0,                0,                0,                 0         } ;
int $cMusclePaint_wtCnt = size($cMusclePaint_wtNames) ;




// --------------------------------------------------------------------------


/*
 * cMusclePaint()
 *
 */
global proc cMusclePaint()
{
	global string $cMusclePaint_ForceMS ;

	// First off make sure this thing has a Maya Muscle applied!
	//
    string $objs[] = `ls -sl` ;

	// For first one just get obj in case component is chosen.
	if ($objs[0] != "")
		{
		string $parts[] ;
		tokenize($objs[0], ".", $parts);
		$objs[0] = $parts[0] ;
		}

    if ($objs[0] != "" && nodeType($objs[0]) != "transform")		// If a shape try to get xform then instead.
		{
		if (nodeType($objs[0]) == "cMuscleSystem")
			{
			string $geos[] = `deformer -q -geometry $objs[0]` ;
			$objs[0] = $geos[0] ;
			}
		$objs = `listRelatives -parent -ni $objs` ;
		}
		
    if (size($objs) <= 0)		// Now do real check...
    	{
    	error -sl 0 (uiRes("m_cMusclePaint.kMustSelectMuscleDeformerGeometry")) ;
    	}
		
    string $hist[] = `listHistory -pdo true -il 1 $objs`;
    string $mSs[] = `ls -type "cMuscleSystem" $hist` ;
    string $mS = $mSs[0] ;
    

		
	// Get the xform node for whatever we are working with.
    string $xform = $objs[0] ;
    if (nodeType($objs[0]) != "transform")
    	{
    	string $xforms[] = `listRelatives -parent $objs[0]`; 
    	$xform = $xforms[0] ;
    	}

    string $nurbs[] = `listRelatives -shapes -ni -type "nurbsSurface" $xform`;
    string $mesh[] = `listRelatives -shapes -ni -type "mesh" $xform`;
    string $subd[] = `listRelatives -shapes -ni -type "subdiv" $xform`;
    string $shape = "" ;
    string $shapeAttr = "" ;
    if (size($nurbs) > 0)
    	{
        $shape = $nurbs[0] ;
        $shapeAttr = "worldSpace" ;
        }
    else if (size($mesh) > 0)
    	{
        $shape = $mesh[0] ;
        $shapeAttr = "worldMesh" ;
        }
    else if (size($subd) > 0)
    	{
        $shape = $subd[0] ;
        $shapeAttr = "worldSubdiv" ;
        }
    

    if ($mS == "")
    	{
    	error -sl 0 (uiRes("m_cMusclePaint.kNoMuscleFound")) ;
    	}

	if (size($mSs) > 1)
		{
			// If it looks like we have more than one muscle system on the object, then force
			//	a delete of the display, so that if we are picking a different mS to paint on 
			//  the mD will be rebuilt no matter what anyhow.
		string $mDs[] = `listRelatives -shapes -ni -type "cMuscleDisplay" $xform` ;
		if (size($mDs) > 0)
			delete $mDs ;
		
		if ($cMusclePaint_ForceMS != "")
			{
			$mS = $cMusclePaint_ForceMS ;	// use this one instead!
			$cMusclePaint_ForceMS = "" ;	// Reset it!	
			}
		}		
		

	// See if it has a cMuscleDisplay made yet...and if not, make and connect it.
    string $mDs[] = `listRelatives -shapes -ni -type "cMuscleDisplay" $xform` ;
    string $mD = $mDs[0] ;
    if (size($mDs) <= 0)
        {
        $mD = `createNode "cMuscleDisplay" -p $xform -n ("cMuscleDisplayShape#")`;
        connectAttr -f ($mS+".message") ($mD+".msgSystem") ;
//        connectAttr -f ($shape+"."+$shapeAttr) ($mD+".geoIn") ;
        connectAttr -f ($mS+".outputGeometry[0]") ($mD+".geoIn") ;
/*
		connectAttr -f ($mS+".stickyWeightListMus") ($mD+".stickyWeightListMus") ;
        connectAttr -f ($mS+".stickyWeightListMusB") ($mD+".stickyWeightListMusB") ;
        connectAttr -f ($mS+".stickyWeightListMusC") ($mD+".stickyWeightListMusC") ;
        connectAttr -f ($mS+".weightListMus") ($mD+".weightListMus") ;
        connectAttr -f ($mS+".weightListDir") ($mD+".weightListDir") ;
        connectAttr -f ($mS+".weightsForce") ($mD+".weightsForce") ;
        connectAttr -f ($mS+".jiggle") ($mD+".jiggle") ;
        connectAttr -f ($mS+".cycle") ($mD+".cycle") ;
        connectAttr -f ($mS+".rest") ($mD+".rest") ;
        connectAttr -f ($mS+".weightsRelax") ($mD+".weightsRelax") ;
        connectAttr -f ($mS+".weightsWrinkle") ($mD+".weightsWrinkle") ;
        connectAttr -f ($mS+".weightsSmooth") ($mD+".weightsSmooth") ;
        connectAttr -f ($mS+".weightsSmoothCompress") ($mD+".weightsSmoothCompress") ;
        connectAttr -f ($mS+".weightsSmoothExpand") ($mD+".weightsSmoothExpand") ;
        connectAttr -f ($mS+".weightsSelfCollision") ($mD+".weightsSelfCollision") ;
        connectAttr -f ($mS+".weightsSelfRigidity") ($mD+".weightsSelfRigidity") ;
        connectAttr -f ($mS+".weightsSelfVolumize") ($mD+".weightsSelfVolumize") ;
*/
		
		// Template so people don't accidentally select.
		setAttr ($mD+".template") 1;
		select -r $objs ; 
        }

		
		
//    cMusclePaint_makeWindow($objs[0], $xform, $mS, $mD) ; // Make the window to choose what we are painting.
    cMusclePaint_makeWindow($shape, $xform, $mS, $mD) ; // Make the window to choose what we are painting.

}

// --------------------------------------------------------------------------

/*
 * cMusclePaint_toolSetup()
 *
 * This procedure should be set as the "Tool Setup Cmd" in the 
 * Setup tab of the Maya Artisan Script Paint tool's tool settings
 * window. The tool context is supplied as an argument.
 */
global proc cMusclePaint_toolSetup( string $context )
{
    global string $cMusclePaint_modeStr ;	

    
    // initialize all the other commands in this scriptable 
    // paint tool context.
    // 
     artUserPaintCtx -e
	    -ic "cMusclePaint_init"
	    -fc "cMusclePaint_finalize"
	    -svc "cMusclePaint_setValue"
	    -gvc "cMusclePaint_getValue"
	    -gsc ""
	    -cc ""
	    -tcc ""
	    -gac ""
		-i1 "cMuscle_skin_paint.png" 
	    -colorfeedback false
	    -miv 0.0 
	    -mxv 1.0 
	    -clamp "both"
	    -cll 0.0
	    -clu 1.0
	    -dl false
//		-usepressure true
//		-mappressure "Opacity"
		-beforeStrokeCmd ""
	    $context ;

//		print ("toolSetup: "+$context+"\n") ;
		

}


// --------------------------------------------------------------------------

/*
 * cMusclePaint_init()
 *
 * This is the "Initialize Cmd". This procedure is called once
 * for every selected surface when an intial click is received
 * on any surface. The argument is the name of the surface. This
 * procedure returns a string which indicates to the scriptable
 * tool how to behave for the duration of the stroke. 
 */
global proc string cMusclePaint_init( string $name )
{
    global string $cMusclePaint_slots[] ;

    int $slot=0 ;
    
/*	
    string $hist[] = `listHistory -pdo true -il 1 $name`;
    string $mSs[] = `ls -type "cMuscleSystem" $hist` ;
    string $mS = $mSs[0] ;
 */
 	string $mS = `textField -q -tx tfSys` ; // Now make work with any # of system nodes... 

    // Find a free slot index...
    //
    while ($cMusclePaint_slots[$slot] != "")
        {
		++$slot ;
		}
        
    
    $cMusclePaint_slots[$slot] = $mS ;    // store Maya Muscle name for this thing


	// Return an argument string which:
	// - tells the tool what surface ID to use for this surface
	// - indicates that values should be distributed on a 20x20
	//   grid on the surface
	// - indicate that the associated world space position
	//   should also be passed to the "Set Value Cmd".
	//
    return ( "-id "+$slot ) ;
    
}

// --------------------------------------------------------------------------

/*
 * cMusclePaint_finalize() -
 *
 * This is the "Finalize Cmd". This procedure is called at the
 * end of the stroke. It is passed the surface ID, that was
 * generated by the "Initialize Cmd".
 */
global proc cMusclePaint_finalize( int $slot )
{
    global string $cMusclePaint_slots[] ;
    global string $cMusclePaint_modeStr ;	

    if ($slot >= 0)
		{
        $cMusclePaint_slots[$slot] = "";
		}

}

// --------------------------------------------------------------------------

/*
 * cMusclePaint_debug() - Little print routine.
 */
proc cMusclePaint_debug( string $msg )
{
    print ("// "+$msg+" //\n") ;
}

// --------------------------------------------------------------------------

global proc string cMusclePaint_getStampProfile()
{
	string $profile = eval("artUserPaintCtx -q -stampProfile `currentCtx`");
	return $profile ;	
}


// --------------------------------------------------------------------------

global proc cMusclePaint_setStampProfile(string $profile)
{
	// Make sure UI looks right...
	symbolCheckBox -e -v false cbGaussian ;
	symbolCheckBox -e -v false cbPolyBrush ;
    symbolCheckBox -e -v false cbSolid ;
	symbolCheckBox -e -v false cbRectBrush ;
//	symbolCheckBox -e -v false cbArtFileBrush ;

	switch ( $profile ) 
		{
		case "gaussian":
			symbolCheckBox -e -v true cbGaussian;
			break;
		case "poly":
			symbolCheckBox -e -v true cbPolyBrush;
			break;
		case "solid":
			symbolCheckBox -e -v true cbSolid;
			break;
		case "square":
			symbolCheckBox -e -v true cbRectBrush;
			break;
		case "lastFile":
		case "shape":
//			symbolCheckBox -e -v true artFileBrushChBx;
			break;
		}

		
	// Set the stamp profile. 
	artUserPaintCtx -e -stampProfile $profile `currentCtx`;	
}

// --------------------------------------------------------------------------

/*
 * cMusclePaint_setOpacity() - Sets opacity for paint stuff
 */
global proc cMusclePaint_setOpacity()
{
    float $opac = `floatSliderGrp -q -v fsgOpacity` ;	// What value to set?
		
	// Update artisan to use this value
	artUserPaintCtx -e -opacity $opac `currentCtx` ;

}

// --------------------------------------------------------------------------

global proc string cMusclePaint_getRadius()
{
	float $rad = eval("artUserPaintCtx -q -radius `currentCtx`");
	return $rad ;	
}

// --------------------------------------------------------------------------

/*
 * cMusclePaint_setRadius() - Sets opacity for paint stuff
 */
global proc cMusclePaint_setRadius()
{
    float $rad = `floatSliderGrp -q -v fsgRadius` ;	// What value to set?
		
	// Update artisan to use this value
	artUserPaintCtx -e -radius $rad `currentCtx` ;

}

// --------------------------------------------------------------------------

global proc cMusclePaint_setTablet()
{
	int $mode = `optionMenu -q -sl optTablet` ;
	
	switch ($mode)
		{
		case 1:		// Off
			artUserPaintCtx -e -usepressure 0 `currentCtx` ;
			break ;
		
		case 2:		// Opacity
			artUserPaintCtx -e -usepressure 1 -mappressure "Opacity" `currentCtx` ;
			break ;

		case 3:		// Radius
			artUserPaintCtx -e -usepressure 1 -mappressure "Radius" `currentCtx` ;
			break ;

		case 4:		// Both
			artUserPaintCtx -e -usepressure 1 -mappressure "Both" `currentCtx` ;
			break ;
		}

}

// --------------------------------------------------------------------------

global proc cMusclePaint_setRefl()
{
	int $mode = `optionMenu -q -sl optRefl` ;
	
	switch ($mode)
		{
		case 1:		// Off
			artUserPaintCtx -e -reflection 0 `currentCtx` ;
			break ;
		
		case 2:		// X-Axis
			artUserPaintCtx -e -reflection 1 -ra "x" `currentCtx` ;
			break ;

		case 3:		// Y-Axis
			artUserPaintCtx -e -reflection 1 -ra "y" `currentCtx` ;
			break ;

		case 4:		// Z-Axis
			artUserPaintCtx -e -reflection 1 -ra "z" `currentCtx` ;
			break ;
		}

}

// --------------------------------------------------------------------------

global proc cMusclePaint_setProject()
{
	int $mode = `checkBox -q -v cbProject`;
	
	if ($mode)
		artUserPaintCtx -e -paintmode "screen" -projective 1 `currentCtx` ;
	else
		artUserPaintCtx -e -paintmode "tangent" -projective 0 `currentCtx` ;
}

// --------------------------------------------------------------------------

/*
 * cMusclePaint_setValue()
 *
 * This is the "Set Value Cmd". It is called everytime a value
 * on the surface is changed. A surface ID, a grid index
 * on the surface and the value associated with that grid index
 * is passed. There can be additional arguments depending on the
 * options generated by the return value of the "Initialize Cmd".
 */ 
global proc cMusclePaint_setValue( int $slot, int $index, float $val)
{
    global string $cMusclePaint_slots[] ;
    global int $cMusclePaint_mIdx ;

    global int $cMusclePaint_mode ;	// sticky or slide?
    global string $cMusclePaint_modeStr ;	
    global int $cMusclePaint_normalize ; 	// normalize?
    
//    cMusclePaint_debug ( "cMusclePaint_setValue ("+$slot+", "+ $index + ", "+$val+")") ;

    if ( $slot >= 0 && $cMusclePaint_slots[$slot] != "") 
		{
	    cMuscleWeight -v $val -normalize $cMusclePaint_normalize -wt $cMusclePaint_modeStr -pi $index -mi $cMusclePaint_mIdx  -system  $cMusclePaint_slots[$slot] ;
//		print ("// Set PointIDX="+$index+" MuscleIDX="+$cMusclePaint_mIdx+" WtVal="+$val+" ("+$cMusclePaint_modeStr+") //\n") ;
		}
}

// --------------------------------------------------------------------------

/*
 * cMusclePaint_getValue()
 *
 * This is the "Get Value Cmd". It is called everytime a value
 * on the surface is needed by the scriptable paint tool. A
 * surface ID and a grid index is passed in. This procedure should
 * return the value for this grid location on the specified surface.
 */ 
global proc float cMusclePaint_getValue( int $slot, int $index )
{
    global string $cMusclePaint_slots[] ;
    global int $cMusclePaint_mIdx ;

    global int $cMusclePaint_mode ;	// sticky or slide?
    global string $cMusclePaint_modeStr ;	
    global int $cMusclePaint_normalize ; 	// normalize?

//    cMusclePaint_debug ( "cMusclePaint_getValue ("+$slot+", "+ $index + ")") ;

    if ( $slot >= 0 && $cMusclePaint_slots[$slot] != "" ) 
		{
		float $vals[] ;
		float $val ;
		$vals = `cMuscleWeight -wt $cMusclePaint_modeStr -pi $index -mi $cMusclePaint_mIdx  -system  $cMusclePaint_slots[$slot] -q `;
		return $vals[0] ;
		}

    return 0.0 ;
}


// --------------------------------------------------------------------------

/*
 * cMusclePaint_manualWeight() - Manually weight muscle from slider to sel pts.
 *	Not paint mode, but more like component editor
 *
 *	$live:	0=slider val change, but don't update
 *		1=slider val change, and do update
 *		2=flood/set value button pressed.
 */
global proc cMusclePaint_manualWeight(int $live)
{
    global int $cMusclePaint_mIdx ;
    global int $cMusclePaint_mode ;		
    global string $cMusclePaint_modeStr ;	
    global int $cMusclePaint_normalize ; 	// normalize?
	global string $cMusclePaint_mS ;		// Muscle System for easier crap...sigh.

    float $val = `floatSliderGrp -q -v fsgWt` ;	// What value to set?
    string $mS = `textField -q -tx tfSys`;    	// What system are we working on?


    if (`checkBox -q -v cbPaint`)
    	{
		if (`currentCtx -q` != "artUserPaintContext")
			return ;
		
		
    	// Update artisan to use this value
		artUserPaintCtx -e -value $val `currentCtx` ;
    	
    	if ($live == 2)
    	    {
    		// do a "Flood"
			artUserPaintCtx -e -clear `currentCtx` ;
			}
    	
    	}
    else if ($live > 0)
    	{
		// Not in paint mode...so do a component stuff

		
	    // What cv's selected?
		string $sel[] = `ls -sl -flatten` ;

	    // Are there actually components selected?
		if (size($sel) <= 0 || gmatch($sel[0], "*.*") != 1)
			return ;

		if ($cMusclePaint_mIdx < 0)
			return ;

	    	// Now set weights for whatever it is that is chosen!
		cMuscleWeight -system  $cMusclePaint_mS -normalize $cMusclePaint_normalize -wt $cMusclePaint_modeStr -mi $cMusclePaint_mIdx -v $val ;
		}
}


    
// --------------------------------------------------------------------------

/*
 * cMusclePaint_setLockWtsSel() - Sets locks weights to on or off for whatever is chosen
 *	in the tsl.
 */
global proc cMusclePaint_setLockWtsSel(string $tsl, string $mS, int $state)
{
    global string $cMusclePaint_modeStr ;	

    string $xforms[] = cMusclePaint_getSelItemsFromList($tsl) ;
    string $xform ;

   
    for ($xform in $xforms)
    	{
    	string $mOs[] = `listRelatives -ni -shapes -type "cMuscleObject" $xform`;
    	string $mO = $mOs[0] ;
		string $mDirs[] = `listRelatives -ni -shapes -type "cMuscleDirection" $xform`;
    	string $mDir = $mDirs[0] ;
		string $mSmarts[] = `listRelatives -ni -shapes -type "cMuscleSmartCollide" $xform`;
    	string $mSmart = $mSmarts[0] ;
    	
    	// Is it a muscle or dir?
    	string $node = $mO ;
    	if ($mDir != "" && $cMusclePaint_modeStr == "direction")
    	    $node = $mDir ;
    	else if ($mSmart != "" && substring($cMusclePaint_modeStr, 1, 5) == "smart" )
    	    $node = $mSmart ;
	
		cMuscleWeight -system  $mS -muscle $node -wt $cMusclePaint_modeStr -lock $state ;	// Edit lock
    	}
    	
    cMusclePaint_refreshList($mS, $tsl) ;
}


// --------------------------------------------------------------------------

/*
 * cMusclePaint_selChanged() - Called when selection changes.
 */
global proc cMusclePaint_selChanged()
{
    global int $cMusclePaint_mIdx ;
    global int $cMusclePaint_mode ;		
    global string $cMusclePaint_modeStr ;	
    global int $cMusclePaint_normalize ; 	// normalize?
	global string $cMusclePaint_mS ;		// Muscle System for easier crap...sigh.

    string $mS = `textField -q -tx tfSys`;    	// What system are we working on?

	// What cv's selected?
    string $sel[] = `ls -sl -flatten` ;

	// Are there actually components selected?
    if (size($sel) <= 0 || gmatch($sel[0], "*.*") != 1)
        return ;

    if ($cMusclePaint_mIdx < 0 && $cMusclePaint_mode <= 15)	// sticky stickyb stickyc sliding direction smart...
    	return ;
		
	// Get weights of everything chosen right now
    float $wt ;
    float $wts[] = `cMuscleWeight -system  $cMusclePaint_mS -wt $cMusclePaint_modeStr -mi $cMusclePaint_mIdx -q -v` ;
    	// And average them.
    float $avgWt = 0.0 ;
    for ($wt in $wts)
    	$avgWt += $wt ;		// add
    $avgWt /= size($wts) ;	// and avg

	if (!`checkBox -q -v cbPaint`)
		{
		// And update slider to show average of what is chosen.
		floatSliderGrp -e -v $avgWt fsgWt ;
		}
}

// --------------------------------------------------------------------------

/*
 * cMusclePaint_changeDrawState() - Since draw is not just on/off, set to be proper
 */
global proc cMusclePaint_changeDrawState(string $mD)
{
    global int $cMusclePaint_mode ;	// sticky or slide?
    global string $cMusclePaint_modeStr ;	
	global string $cMusclePaint_polyGeo ;
	
    int $draw = `checkBox -q -v cbDraw`;
    
    if ($draw == 0)
		{
        setAttr ($mD+".draw") 0 ;
		if ($cMusclePaint_polyGeo != "")
			polyOptions -cm "none" -cs $draw $cMusclePaint_polyGeo ;
		}
    else if ($draw == 1)
		{
        setAttr ($mD+".draw") ($cMusclePaint_mode + 1) ;
		if ($cMusclePaint_polyGeo != "")
			polyOptions -cm "none" -cs $draw $cMusclePaint_polyGeo ;
		}
    
}

// --------------------------------------------------------------------------

/*
 * cMusclePaint_makeGeoMenu() - Make a popup menu that can easily load any Maya Muscle
 *		deformed geo into the paint ui.
 */
global proc cMusclePaint_makeGeoMenu(string $win, string $mD)
{
	global string $cMusclePaint_mS ;		// Muscle System for easier crap...sigh.

    setParent -menu pmGeoMenu ;
    popupMenu -e -deleteAllItems pmGeoMenu ;         // erase first

	// First list all Maya Muscle nodes in the scene...
    string $mSs[] = `ls -type "cMuscleSystem" "*"` ;
    string $mS ;
    
    	// Now go thru each one...
    for ($mS in $mSs)
        {
        // And figure out what geo it is deforming...
        string $geos[] = `cMuscleQuery -system $mS -geometry` ;
        // From that get the parent xform.
        string $xforms[] = `listRelatives -parent $geos` ;
        
        menuItem -l ($xforms[0]+" ("+$mS+")") -c ("global string $cMusclePaint_ForceMS = \""+$mS+"\" ; select -r "+$xforms[0]+"; deleteUI -wnd cMusclePaintWin ; cMusclePaint_closeWin(\""+$win+"\",\""+$mD+"\"); evalDeferred(\"cMusclePaint();\"); ") ; 
		
        }

}


// --------------------------------------------------------------------------

/*
 * cMusclePaint_makeWindow() - Makes a window to handle muscle selections
 *	in conjunction with script paint.
 */
global proc cMusclePaint_makeWindow(string $shape, string $xform, string $mS, string $mD)
{
    global string $cMusclePaint_slots[] ;

    global int $cMusclePaint_mode ;		// sticky or slide or dir?
    global int $cMusclePaint_lastMode ; 
    global int $cMusclePaint_normalize ; 	// normalize?
	global string $cMusclePaint_mS ;		// Muscle System for easier crap...sigh.
	global string $cMusclePaint_mD ;		// Muscle System for easier crap...sigh.
	global int $cMusclePaint_wtNormalize[] ;
	global int $cMusclePaint_wtCnt ;
	global string $cMusclePaint_wtLabels[] ;

	global int $cMusclePaint_allowSave ;	// Allow save of state?

	$cMusclePaint_allowSave = 0 ;	// Don't allow save until we are fully initialized!
	
	// Store it!
	$cMusclePaint_mS  = $mS ;
	$cMusclePaint_mD  = $mD ;

	
    if (`window -q -ex cMusclePaintWin`)
        deleteUI -wnd cMusclePaintWin ;
        
    $cMusclePaint_lastMode = -1;	// reset 
    

	// Auto set normalize on or off.
	$cMusclePaint_normalize = $cMusclePaint_wtNormalize[ $cMusclePaint_mode ] ;


	// Generate a nice name
    string $win = ("cMusclePaintWin") ;

	string $msg = (uiRes("m_cMusclePaint.kMusclePaintWindow"));
    window -w 280 -h 550 -t ($msg) $win ;
//    scrollLayout -cr 1 -hst 18 -vst 18 ;
    
    string $form = `formLayout`;
    
    text -l (uiRes("m_cMusclePaint.kMusclePaintGeo")) 
		-al "right" 
		-font "boldLabelFont" 
		-w 60 txGeo ;
    textField -tx $xform -ed false tfGeo ;
    button -l "<<<"
		-w 28 
		-ann (uiRes("m_cMusclePaint.kMusclePaintGeoAnnot")) 
		-c ("deleteUI -wnd cMusclePaintWin ; cMusclePaint_closeWin(\""+$win+"\",\""+$mD+"\"); evalDeferred(\"cMusclePaint();\"); ") btnLoadGeo ;
    
    popupMenu -button 3 -pmc ("cMusclePaint_makeGeoMenu(\""+$win+"\",\""+$mD+"\");") -p tfGeo pmGeoMenu ;
    
    text -l (uiRes("m_cMusclePaint.kMusclePaintNode")) 
		-al "right" 
		-font "boldLabelFont" 
		-w 60 txSys ; 
    textField -tx $mS -ed false tfSys ;

    popupMenu -button 3 -p tfSys pmSysMenu ;
	menuItem -l (uiRes("m_cMusclePaint.kEnableMuscleSystemDeformation")) 
		-c ("setAttr \""+$mS+".envelope\" 1.0 ; ") ;
	menuItem -l (uiRes("m_cMusclePaint.kDisableMuscleSystemDeformation")) 
		-c ("setAttr \""+$mS+".envelope\" 0.0 ; ") ;
	menuItem -divider true ;
	menuItem -l (uiRes("m_cMusclePaint.kEnableSticky")) 
		-c ("setAttr \""+$mS+".enableSticky\" 1 ; ") ;
	menuItem -l (uiRes("m_cMusclePaint.kDisableSticky")) 
		-c ("setAttr \""+$mS+".enableSticky\" 0 ; ") ;
	menuItem -divider true ;
	menuItem -l (uiRes("m_cMusclePaint.kEnableSliding")) 
		-c ("setAttr \""+$mS+".enableSliding\" 1 ; ") ;
	menuItem -l (uiRes("m_cMusclePaint.kDisableSliding")) 
		-c ("setAttr \""+$mS+".enableSliding\" 0 ; ") ;
	menuItem -divider true ;
	menuItem -l (uiRes("m_cMusclePaint.kEnableForce")) 
		-c ("setAttr \""+$mS+".enableForce\" 1 ; ") ;
	menuItem -l (uiRes("m_cMusclePaint.kDisableForce")) 
		-c ("setAttr \""+$mS+".enableForce\" 0 ; ") ;
	menuItem -divider true ;
	menuItem -l (uiRes("m_cMusclePaint.kEnableDisplace")) 
		-c ("setAttr \""+$mS+".enableDisplace\" 1 ; ") ;
	menuItem -l (uiRes("m_cMusclePaint.kDisableDisplace")) 
		-c ("setAttr \""+$mS+".enableDisplace\" 0 ; ") ;
	menuItem -divider true ;
	menuItem -l (uiRes("m_cMusclePaint.kEnableJiggle")) 
		-c ("setAttr \""+$mS+".enableJiggle\" 1 ; ") ;
	menuItem -l (uiRes("m_cMusclePaint.kDisableJiggle")) 
		-c ("setAttr \""+$mS+".enableJiggle\" 0 ; ") ;
	menuItem -divider true ;
	menuItem -l (uiRes("m_cMusclePaint.kEnableRelax")) 
		-c ("setAttr \""+$mS+".enableRelax\" 1 ; ") ;
	menuItem -l (uiRes("m_cMusclePaint.kDisableRelax")) 
		-c ("setAttr \""+$mS+".enableRelax\" 0 ; ") ;
	menuItem -divider true ;
	menuItem -l (uiRes("m_cMusclePaint.kEnableSmooth")) 
		-c ("setAttr \""+$mS+".enableSmooth\" 1 ; ") ;
	menuItem -l (uiRes("m_cMusclePaint.kDisableSmooth")) 
		-c ("setAttr \""+$mS+".enableSmooth\" 0 ; ") ;
	menuItem -divider true ;
	menuItem -l (uiRes("m_cMusclePaint.kEnableSmartCollision")) 
		-c ("setAttr \""+$mS+".smartCollision\" 1 ; ") ;
	menuItem -l (uiRes("m_cMusclePaint.kDisableSmartCollision")) 
		-c ("setAttr \""+$mS+".smartCollision\" 0 ; ") ;
	menuItem -divider true ;
	menuItem -l (uiRes("m_cMusclePaint.kEnableSelfCollision")) 
		-c ("setAttr \""+$mS+".selfCollision\" 1 ; ") ;
	menuItem -l (uiRes("m_cMusclePaint.kDisableSelfCollision")) 
		-c ("setAttr \""+$mS+".selfCollision\" 0 ; ") ;


    separator -style "single" -w 200 -h 5 sep0;
    

    radioButtonGrp 
    	-nrb 4
    	-labelArray4 (uiRes("m_cMusclePaint.kPaintModeReplace"))
			(uiRes("m_cMusclePaint.kPaintModeAdd"))
			(uiRes("m_cMusclePaint.kPaintModeScale"))
			(uiRes("m_cMusclePaint.kPaintModeSmooth"))
    	-sl 1
    	-cw4 70 50 63 70 
    	-on1 ("cMusclePaint_setPaintOnOff(); artAttrPaintOperation artUserPaintCtx Replace ;") 
    	-on2 ("cMusclePaint_setPaintOnOff(); artAttrPaintOperation artUserPaintCtx Add ;") 
    	-on3 ("cMusclePaint_setPaintOnOff(); artAttrPaintOperation artUserPaintCtx Scale ;") 
    	-on4 ("cMusclePaint_setPaintOnOff(); artAttrPaintOperation artUserPaintCtx Smooth ;") 
    	rbgPaintMode ;

	// Copied from art3dPaintProperties.mel from Maya scripts others		
	symbolCheckBox -w 26 -h 26 -i "cMusclePaintGaussian.png"  
		-ann (uiRes("m_cMusclePaint.kGaussianBrushProfile")) 
		-cc ("cMusclePaint_setStampProfile(\"gaussian\"); cMusclePaint_saveState() ;") cbGaussian;
	symbolCheckBox -w 26 -h 26 -i "cMusclePaintSoft.png" 
		-ann (uiRes("m_cMusclePaint.kSoftBrushProfile"))  
		-cc ("cMusclePaint_setStampProfile(\"poly\"); cMusclePaint_saveState() ;") cbPolyBrush ;
	symbolCheckBox -w 26 -h 26 -i "cMusclePaintSolid.png" 
		-ann (uiRes("m_cMusclePaint.kSolidBrushProfile"))  
		-cc ("cMusclePaint_setStampProfile(\"solid\"); cMusclePaint_saveState() ;") cbSolid ;
	symbolCheckBox -w 26 -h 26 -i "cMusclePaintSquare.png"
		-ann (uiRes("m_cMusclePaint.kSquareBrushProfile")) 
		-cc ("cMusclePaint_setStampProfile(\"square\"); cMusclePaint_saveState() ;") cbRectBrush ;

		
    floatSliderGrp -l (uiRes("m_cMusclePaint.kOpactiy")) 
    	-field true
		-cw3 55 65 100 -adj 3 -cal 1 "right"
       	-minValue 0.0 -maxValue 1.0
       	-fieldMinValue 0.0 -fieldMaxValue 1.0
    	-pre 3
       	-value 1.0 
    	-cc "cMusclePaint_setPaintOnOff() ; cMusclePaint_setOpacity();"  
//    	-dc "cMusclePaint_setOpacity();"
    	fsgOpacity ;
    popupMenu -button 3 -p fsgOpacity ;
        menuItem -l "0.0" -c ("floatSliderGrp -e -v 0.0 fsgOpacity ; cMusclePaint_setPaintOnOff() ; cMusclePaint_setOpacity();") ;
        menuItem -l "0.1" -c ("floatSliderGrp -e -v 0.1 fsgOpacity ; cMusclePaint_setPaintOnOff() ; cMusclePaint_setOpacity();") ;
        menuItem -l "0.2" -c ("floatSliderGrp -e -v 0.2 fsgOpacity ; cMusclePaint_setPaintOnOff() ; cMusclePaint_setOpacity();") ;
        menuItem -l "0.3" -c ("floatSliderGrp -e -v 0.3 fsgOpacity ; cMusclePaint_setPaintOnOff() ; cMusclePaint_setOpacity();") ;
        menuItem -l "0.4" -c ("floatSliderGrp -e -v 0.4 fsgOpacity ; cMusclePaint_setPaintOnOff() ; cMusclePaint_setOpacity();") ;
        menuItem -l "0.5" -c ("floatSliderGrp -e -v 0.5 fsgOpacity ; cMusclePaint_setPaintOnOff() ; cMusclePaint_setOpacity();") ;
        menuItem -l "0.6" -c ("floatSliderGrp -e -v 0.6 fsgOpacity ; cMusclePaint_setPaintOnOff() ; cMusclePaint_setOpacity();") ;
        menuItem -l "0.7" -c ("floatSliderGrp -e -v 0.7 fsgOpacity ; cMusclePaint_setPaintOnOff() ; cMusclePaint_setOpacity();") ;
        menuItem -l "0.8" -c ("floatSliderGrp -e -v 0.8 fsgOpacity ; cMusclePaint_setPaintOnOff() ; cMusclePaint_setOpacity();") ;
        menuItem -l "0.9" -c ("floatSliderGrp -e -v 0.9 fsgOpacity ; cMusclePaint_setPaintOnOff() ; cMusclePaint_setOpacity();") ;
        menuItem -l "1.0" -c ("floatSliderGrp -e -v 1.0 fsgOpacity ; cMusclePaint_setPaintOnOff() ; cMusclePaint_setOpacity();") ;


    floatSliderGrp -l (uiRes("m_cMusclePaint.kRadius")) 
    	-field true
		-cw3 45 55 100 -adj 3 -cal 1 "right"
       	-minValue 0.0 -maxValue 100.0
       	-fieldMinValue 0.0 -fieldMaxValue 10000000.0
    	-pre 3
       	-value 1.0
    	-cc "cMusclePaint_setRadius();"  
//    	-dc "cMusclePaint_setOpacity();"
    	fsgRadius ;

    popupMenu -button 3 -p fsgRadius ;
        menuItem -l "0.01" -c ("floatSliderGrp -e -v 0.01 fsgRadius ; cMusclePaint_setRadius();") ;
        menuItem -l "0.1" -c ("floatSliderGrp -e -v 0.1 fsgRadius ; cMusclePaint_setRadius();") ;
        menuItem -l "0.5" -c ("floatSliderGrp -e -v 0.5 fsgRadius ; cMusclePaint_setRadius();") ;
        menuItem -l "1.0" -c ("floatSliderGrp -e -v 1.0 fsgRadius ; cMusclePaint_setRadius();") ;
        menuItem -l "5.0" -c ("floatSliderGrp -e -v 5.0 fsgRadius ; cMusclePaint_setRadius();") ;
        menuItem -l "10.0" -c ("floatSliderGrp -e -v 10.0 fsgRadius ; cMusclePaint_setRadius();") ;
        menuItem -l "100.0" -c ("floatSliderGrp -e -v 100.0 fsgRadius ; cMusclePaint_setRadius();") ;
        menuItem -l "1000.0" -c ("floatSliderGrp -e -v 1000.0 fsgRadius ; cMusclePaint_setRadius();") ;

		
	text -l (uiRes("m_cMusclePaint.kStylus")) txTablet ;
    optionMenu optTablet;
    	menuItem -l (uiRes("m_cMusclePaint.kStylusOff")) ;
    	menuItem -l (uiRes("m_cMusclePaint.kStylusOpacity")) ;
    	menuItem -l (uiRes("m_cMusclePaint.kStylusRadius")) ;
    	menuItem -l (uiRes("m_cMusclePaint.kStylusBoth")) ;
    	optionMenu -e -sl (1) -cc ("cMusclePaint_setPaintOnOff() ; cMusclePaint_setTablet();") optTablet ;
		
	text -l (uiRes("m_cMusclePaint.kReflect")) txRefl ;
    optionMenu optRefl;
    	menuItem -l (uiRes("m_cMusclePaint.kReflectOff")) ;
    	menuItem -l (uiRes("m_cMusclePaint.kReflectXAxis")) ;
    	menuItem -l (uiRes("m_cMusclePaint.kReflectYAxis")) ;
    	menuItem -l (uiRes("m_cMusclePaint.kReflectZAxis")) ;
    	optionMenu -e -sl (1) -cc ("cMusclePaint_setPaintOnOff() ; cMusclePaint_setRefl();")  optRefl ;
		
	checkBox -l (uiRes("m_cMusclePaint.kProject")) 
		-v 0 
		-cc ("cMusclePaint_setPaintOnOff() ; cMusclePaint_setProject();") cbProject ;
			
		
    separator -w 200 -h 3 sepPnt;


		
    checkBox -l (uiRes("m_cMusclePaint.kPaint")) 
		-v 1 cbPaint ;	// -cc set later below
    
    text -l (uiRes("m_cMusclePaint.kPaintWeights")) 
		-w 50 
		-al "left" txWts;
    string $opt = `optionMenu optPaintWtMode`;
	int $i ;
	for ($i=0; $i < $cMusclePaint_wtCnt; ++$i)
		menuItem -l ($cMusclePaint_wtLabels[ $i ]) ;
/*
		menuItem -l "Sticky" ;
    	menuItem -l "StickyB" ;
    	menuItem -l "StickyC" ;
    	menuItem -l "Sliding" ;
    	menuItem -l "Direction" ;
    	menuItem -l "Force" ;
    	menuItem -l "Jiggle" ;
    	menuItem -l "Cycle" ;
    	menuItem -l "Rest" ;
    	menuItem -l "Relax" ;
    	menuItem -l "Wrinkle" ;
    	menuItem -l "Smooth" ;
*/
    	optionMenu -e -sl ($cMusclePaint_mode+1) $opt ;
    
    string $chkNormal = `checkBox -l (uiRes("m_cMusclePaint.kNormalize")) -v ($cMusclePaint_normalize) cbPaintNormalize`;
    
    separator -w 200 -h 3 sep1;

    string $wtcmd0 = "cMusclePaint_manualWeight(0);" ;
    string $wtcmd1 = "cMusclePaint_manualWeight(1);" ;
    string $wtcmd2 = "cMusclePaint_manualWeight(2);" ;
    floatSliderGrp -l (uiRes("m_cMusclePaint.kWeight")) 
    	-field true
		-cw3 50 60 100 -adj 3 -cal 1 "right"
       	-minValue 0.0 -maxValue 1.0
       	-fieldMinValue 0.0 -fieldMaxValue 1.0
    	-pre 3
       	-value 1.0 
    	-cc ("cMusclePaint_setPaintOnOff(); "+$wtcmd1)
    	-dc $wtcmd1 
    	fsgWt ;
    popupMenu -button 3 -p fsgWt ;
        menuItem -l "0.0" -c ("floatSliderGrp -e -v 0.0 fsgWt; cMusclePaint_setPaintOnOff() ; "+$wtcmd1) ;
        menuItem -l "0.1" -c ("floatSliderGrp -e -v 0.1 fsgWt; cMusclePaint_setPaintOnOff() ; "+$wtcmd1) ;
        menuItem -l "0.2" -c ("floatSliderGrp -e -v 0.2 fsgWt; cMusclePaint_setPaintOnOff() ; "+$wtcmd1) ;
        menuItem -l "0.3" -c ("floatSliderGrp -e -v 0.3 fsgWt; cMusclePaint_setPaintOnOff() ; "+$wtcmd1) ;
        menuItem -l "0.4" -c ("floatSliderGrp -e -v 0.4 fsgWt; cMusclePaint_setPaintOnOff() ; "+$wtcmd1) ;
        menuItem -l "0.5" -c ("floatSliderGrp -e -v 0.5 fsgWt; cMusclePaint_setPaintOnOff() ; "+$wtcmd1) ;
        menuItem -l "0.6" -c ("floatSliderGrp -e -v 0.6 fsgWt; cMusclePaint_setPaintOnOff() ; "+$wtcmd1) ;
        menuItem -l "0.7" -c ("floatSliderGrp -e -v 0.7 fsgWt; cMusclePaint_setPaintOnOff() ; "+$wtcmd1) ;
        menuItem -l "0.8" -c ("floatSliderGrp -e -v 0.8 fsgWt; cMusclePaint_setPaintOnOff() ; "+$wtcmd1) ;
        menuItem -l "0.9" -c ("floatSliderGrp -e -v 0.9 fsgWt; cMusclePaint_setPaintOnOff() ; "+$wtcmd1) ;
        menuItem -l "1.0" -c ("floatSliderGrp -e -v 1.0 fsgWt; cMusclePaint_setPaintOnOff() ; "+$wtcmd1) ;
    
		
		
    checkBox -l (uiRes("m_cMusclePaint.kLiveUpdate")) 
		-v 1 
		-en false 
		-ofc ("floatSliderGrp -e -cc (\""+$wtcmd0+"\") -dc (\""+$wtcmd0+"\") fsgWt; ") 
		-onc ("floatSliderGrp -e -cc (\""+$wtcmd1+"\") -dc (\""+$wtcmd1+"\") fsgWt; ") cbLiveUpdate ;
    button -l (uiRes("m_cMusclePaint.kSetWeightFlood")) 
		-h 18 
		-c $wtcmd2 btnSetWt ;


    separator -w 200 -h 3 sepTSL;
    string $tsl = `textScrollList -w 200 -ams true -nr 20 tslMusclePaint` ;

    popupMenu -button 3 -p $tsl ;
		menuItem -l (uiRes("m_cMusclePaint.kSelectAll")) 
			-c ("int $nItems = `textScrollList -q -ni "+$tsl+"`; if ($nItems>0) { for ($i=0;$i<$nItems;++$i) { textScrollList -e -sii ($i+1) "+$tsl+";}  } ") 
			-ann (uiRes("m_cMusclePaint.kSelectAllAnnot")) ;
		menuItem -l (uiRes("m_cMusclePaint.kSelectNone")) 
			-c ("int $nItems = `textScrollList -q -ni "+$tsl+"`; if ($nItems>0) { for ($i=0;$i<$nItems;++$i) { textScrollList -e -dii ($i+1) "+$tsl+";}  } ") 
			-ann (uiRes("m_cMusclePaint.kSelectNoneAnnot")) ;
		menuItem -divider true ;
		menuItem -l (uiRes("m_cMusclePaint.kSelectPointsFromHighlighted")) 
			-c ("cMusclePaint_selectCVsFromNodes(\""+$mS+"\", \""+$mD+"\", \""+$tsl+"\", \""+$shape+"\"); ") 
			-ann (uiRes("m_cMusclePaint.kSelectPointsFromHighlightedAnnot")) ;    
		menuItem -l (uiRes("m_cMusclePaint.kHighlightFromSelectedPoints")) 
			-c ("cMusclePaint_selectNodesFromCVs(\""+$mS+"\", \""+$mD+"\", \""+$tsl+"\", \""+$shape+"\"); ") 
			-ann (uiRes("m_cMusclePaint.kHighlightFromSelectedPointsAnnot")) ; 
		menuItem -divider true ;
        menuItem -l (uiRes("m_cMusclePaint.kEnableLockHoldWeights")) 
			-c ("cMusclePaint_setLockWtsSel(\""+$tsl+"\", \""+$mS+"\", 1); ") 
			-ann (uiRes("m_cMusclePaint.kEnableLockHoldWeightsAnnot")) ;
        menuItem -l (uiRes("m_cMusclePaint.kDisableLockHoldWeights")) 
			-c ("cMusclePaint_setLockWtsSel(\""+$tsl+"\", \""+$mS+"\", 0); ") 
			-ann (uiRes("m_cMusclePaint.kDisableLockHoldWeightsAnnot")) ;

	
    text -l (uiRes("m_cMusclePaint.kFilter")) txFilter ;
    textField -tx "*" -cc ("cMusclePaint_adjustFilter(0, \""+$mS+"\", \""+$tsl+"\");") -ec ("cMusclePaint_adjustFilter(0, \""+$mS+"\", \""+$tsl+"\");") tfFilter ;

    popupMenu -p tfFilter ;
        menuItem -l (uiRes("m_cMusclePaint.kFilterAll")) 
			-c ("cMusclePaint_adjustFilter(1, \""+$mS+"\", \""+$tsl+"\"); ") ;
        menuItem -l (uiRes("m_cMusclePaint.kFilterHighLightedNodes")) 
			-c ("cMusclePaint_adjustFilter(2, \""+$mS+"\", \""+$tsl+"\"); ") ;


    string $chkDraw = `checkBox 
						-l (uiRes("m_cMusclePaint.kDraw")) 
						-v 1 
						-cc ("cMusclePaint_changeDrawState(\""+$mD+"\"); cMusclePaint_saveState() ;") cbDraw`;

    string $chkGray = `checkBox -l (uiRes("m_cMusclePaint.kGray")) 
						-v 0 cbGray `;
    connectControl $chkGray ($mD+".grayscale") ;
    
    string $isgPnt = `intSliderGrp -l (uiRes("m_cMusclePaint.kPointSize")) 
						-field false 
						-min 1 
						-max 64 
						-cw 1 90
						-adj 2 isgPtSize` ;
    connectControl $isgPnt ($mD+".ptSize") ;

    float $colA[] = `getAttr ($mD+".colorA")` ;
    float $colB[] = `getAttr ($mD+".colorB")` ;
    float $colC[] = `getAttr ($mD+".colorC")` ;
    string $colACmd = ("float $col[] = `colorSliderGrp -q -rgb csgA` ;  setAttr (\""+$mD+".colorA\") $col[0] $col[1] $col[2] ; ");
    string $colBCmd = ("float $col[] = `colorSliderGrp -q -rgb csgB` ;  setAttr (\""+$mD+".colorB\") $col[0] $col[1] $col[2] ; ");
    string $colCCmd = ("float $col[] = `colorSliderGrp -q -rgb csgC` ;  setAttr (\""+$mD+".colorC\") $col[0] $col[1] $col[2] ; ");
    colorSliderGrp -label (uiRes("m_cMusclePaint.kColorA")) 
		-rgb $colA[0] $colA[1] $colA[2] 
		-cc $colACmd 
		-dc $colACmd 
		-cw3 20 20 50 
		-adj 3 
		-h 18 
		-cal 1 "right" csgA ;
    colorSliderGrp -label (uiRes("m_cMusclePaint.kColorB")) 
		-rgb $colB[0] $colB[1] $colB[2] 
		-cc $colBCmd 
		-dc $colBCmd 
		-cw3 20 20 50 
		-adj 3 
		-h 18 
		-cal 1 "right" csgB ;
    colorSliderGrp -label (uiRes("m_cMusclePaint.kColorC")) 
		-rgb $colC[0] $colC[1] $colC[2] 
		-cc $colCCmd 
		-dc $colCCmd 
		-cw3 20 20 50 
		-adj 3 
		-h 18 
		-cal 1 "right" csgC ;

    
    string $bcls = `button -w 200 
						-l (uiRes("m_cMusclePaint.kClose")) 
						-c ("cMusclePaint_saveState() ;  deleteUI -wnd cMusclePaintWin ;")` ;
    
    formLayout -e
    
    	-af txGeo "top" 3 
    	-an txGeo "bottom"
    	-af txGeo "left" 0 
    	-an txGeo "right" 

    	-af tfGeo "top" 0 
    	-an tfGeo "bottom"
    	-ac tfGeo "left" 0 txGeo
    	-ac tfGeo "right" 0 btnLoadGeo

    	-af btnLoadGeo "top" 0 
    	-an btnLoadGeo "bottom"
    	-an btnLoadGeo "left" 
    	-af btnLoadGeo "right" 5

    	-ac txSys "top" 3 tfGeo
    	-an txSys "bottom"
    	-af txSys "left" 0 
    	-an txSys "right" 

    	-ac tfSys "top" 0 tfGeo
    	-an tfSys "bottom"
    	-ac tfSys "left" 0 txSys
    	-af tfSys "right" 5

    	-ac sep0 "top" 0 tfSys
    	-an sep0 "bottom"
    	-af sep0 "left" 0 
    	-af sep0 "right" 0
    	
		
    	-ac cbGaussian "top" 3 sep0
    	-an cbGaussian "bottom"
    	-af cbGaussian "left" 0 
    	-an cbGaussian "right" 

    	-ac cbPolyBrush "top" 3 sep0
    	-an cbPolyBrush "bottom"
    	-ac cbPolyBrush "left" 3  cbGaussian
    	-an cbPolyBrush "right" 

    	-ac cbSolid "top" 3 sep0
    	-an cbSolid "bottom"
    	-ac cbSolid "left" 3  cbPolyBrush
    	-an cbSolid "right" 
		
    	-ac cbRectBrush "top" 3 sep0
    	-an cbRectBrush "bottom"
    	-ac cbRectBrush "left" 3  cbSolid
    	-an cbRectBrush "right" 
		
    	-ac fsgOpacity "top" 3 sep0
    	-an fsgOpacity "bottom"
    	-ac fsgOpacity "left" 3  cbRectBrush
    	-af fsgOpacity "right" 5 
		
		
    	-ac fsgRadius "top" 6 cbGaussian
    	-an fsgRadius "bottom"
    	-af fsgRadius "left" 3 
    	-af fsgRadius "right" 5
		
		
    	-ac txTablet "top" 6 fsgRadius
    	-an txTablet "bottom"
    	-af txTablet "left" 3 
    	-an txTablet "right"

    	-ac optTablet "top" 3 fsgRadius
    	-an optTablet "bottom"
    	-ac optTablet "left" 3 txTablet 
    	-an optTablet "right"
		
    	-ac txRefl "top" 6 fsgRadius
    	-an txRefl "bottom"
    	-ac txRefl "left" 3 optTablet
    	-an txRefl "right" 
		
    	-ac optRefl "top" 3 fsgRadius
    	-an optRefl "bottom"
    	-ac optRefl "left" 3 txRefl
    	-an optRefl "right" 

		-ac cbProject "top" 6 fsgRadius
    	-an cbProject "bottom"
    	-ac cbProject "left" 5 optRefl
    	-an cbProject "right" 


    	-ac sepPnt "top" 0 optTablet
    	-an sepPnt "bottom"
    	-af sepPnt "left" 0 
    	-af sepPnt "right" 0
		
		
		
    	-ac cbPaint "top" 5 sepPnt
    	-an cbPaint "bottom"
    	-af cbPaint "left" 5 
    	-an cbPaint "right"

    	-ac txWts "top" 5 sepPnt
    	-an txWts "bottom"
    	-ac txWts "left" 0 cbPaint
    	-an txWts "right"

    	-ac $opt "top" 2 sepPnt
    	-an $opt "bottom"
    	-ac $opt "left" 0 txWts
    	-an $opt "right"

    	-ac $chkNormal "top" 6 sepPnt
    	-an $chkNormal "bottom"
    	-ac $chkNormal "left" 8 $opt 
    	-af $chkNormal "right" 0

        
    	-ac sep1 "top" 0 $opt
    	-an sep1 "bottom"
    	-af sep1 "left" 0 
    	-af sep1 "right" 0
    	
		-ac fsgWt "top" 2 sep1
    	-an fsgWt "bottom" 
    	-af fsgWt "left" 0 
    	-af fsgWt "right" 0

       	-ac cbLiveUpdate "top" 5 fsgWt
    	-an cbLiveUpdate "bottom" 
    	-af cbLiveUpdate "left" 5
    	-an cbLiveUpdate "right"

		-ac btnSetWt "top" 4 fsgWt
		-an btnSetWt "bottom" 
		-ac btnSetWt "left" 0 cbLiveUpdate
		-af btnSetWt "right" 5
		
		
		-ac rbgPaintMode "top" 4 btnSetWt
		-an rbgPaintMode "bottom" 
		-af rbgPaintMode "left" 5
		-af rbgPaintMode "right" 5
	

		

    	-ac sepTSL "top" 3 rbgPaintMode
    	-an sepTSL "bottom"
    	-af sepTSL "left" 0 
    	-af sepTSL "right" 0

    	-ac $tsl "top" 2 sepTSL
    	-ac $tsl "bottom" 4 tfFilter
    	-af $tsl "left" 5 
    	-af $tsl "right" 5


    	-an txFilter "top" 
    	-ac txFilter "bottom" 7 $chkDraw 
    	-af txFilter "left" 5 
    	-an txFilter "right" 
		
    	-an tfFilter "top" 
    	-ac tfFilter "bottom" 4 $chkDraw 
    	-ac tfFilter "left" 5 txFilter
    	-af tfFilter "right" 5 

		
    	-an $chkDraw "top" 
    	-ac $chkDraw "bottom" 4 csgA 
    	-af $chkDraw "left" 5 
    	-an $chkDraw "right" 

    	-an $chkGray "top"
    	-ac $chkGray "bottom" 4 csgA
    	-ac $chkGray "left" 3 $chkDraw
    	-an $chkGray "right" 

    	-an $isgPnt "top" 
    	-ac $isgPnt "bottom" 1 csgA
    	-ac $isgPnt "left" -5 $chkGray
    	-af $isgPnt "right" 0


    	-an csgA "top"
    	-ac csgA "bottom" 4 $bcls
    	-af csgA "left" 5 
    	-ap csgA "right" 0 33

    	-an csgB "top" 
    	-ac csgB "bottom" 4 $bcls
    	-ac csgB "left" 0 csgA
    	-ap csgB "right" 0 66

    	-an csgC "top" 
    	-ac csgC "bottom" 4 $bcls
    	-ac csgC "left" 0 csgB
    	-af csgC "right" 0


    	-an $bcls "top" 
    	-af $bcls "bottom" 5
    	-af $bcls "left" 5 
    	-af $bcls "right" 5


	$form ;    
    


    string $closeCmd = ("cMusclePaint_closeWin(\""+$win+"\",\""+$mD+"\")") ;	// since we use for both button and scriptjob

    string $pickCmd = ("cMusclePaint_selMus(\""+$mS+"\", \""+$mD+"\",  \""+$shape+"\", \""+$tsl+"\"); ") ;
        
    checkBox -e -cc ($pickCmd+" cMusclePaint_setPaintOnOff(); ") cbPaint ;

    checkBox -e -cc ("global int $cMusclePaint_normalize ; $cMusclePaint_normalize = `checkBox -q -v "+$chkNormal+"`; ") $chkNormal ;
    
    optionMenu -e -cc ("cMusclePaint_changeMode(\""+$opt+"\", \""+$chkNormal+"\", \""+$mS+"\", \""+$mD+"\",  \""+$shape+"\", \""+$tsl+"\");") $opt;

    textScrollList -e  -sc $pickCmd $tsl ;


    showWindow $win ;	// Must do this before resize or Linux doesn't work!

    int $w = `window -q -w $win`;	// widget window so form resizes right
    window -e -w ($w+1) $win ;
    window -e -w ($w) $win ;


    
    	// Make a job for diff pts selected wt update
    scriptJob -e "SelectionChanged" "cMusclePaint_selChanged()" -p $win ;
    	// Make a shutdown script job
    scriptJob -uiDeleted $win $closeCmd ;

    // Set initial mode and selection and fill.
    cMusclePaint_changeMode($opt, $chkNormal, $mS, $mD, $shape, $tsl) ;
//    cMusclePaint_selMus($mS, $mD, $shape, $tsl) ;	// start first one

	cMusclePaint_restoreState($mS, $mD, $shape, $tsl) ;

}

// --------------------------------------------------------------------------


/*
 * cMusclePaint_adjustFilter() - Adjust the text filter somehow
 */
global proc cMusclePaint_adjustFilter(int $mode, string $mS, string $tsl)
{
    switch ($mode)
    	{
    	case 0:
    	    // User change
    	    break ;

    	case 1:			// ALL
    	    textField -e -tx "*" tfFilter ;
    	    break ;

    	case 2:			// Filter Highlighted
    	    string $filterStr = "" ;
			string $nodes[] = cMusclePaint_getSelItemsFromList($tsl) ;
			int $nNodes = size($nodes) ;
			int $i ;
			for ($i=0; $i < $nNodes; ++$i)
				$filterStr += ($nodes[$i] + " " ) ;
			textField -e -tx $filterStr tfFilter ;
			break ;

    	}

    cMusclePaint_refreshList($mS, $tsl) ; 	// Now refresh list
}

// --------------------------------------------------------------------------

/*
 * cMusclePaint_passesFilter() - Returns true if the str passes the filters, false otherwise.
 */
global proc int cMusclePaint_passesFilter(string $str)
{
    string $filterStr = `textField -q -tx tfFilter` ;

    // Easy case, empty or plain * means all, so all are passed.
    if ($filterStr == "" || $filterStr == "*")
    	return 1 ;

    string $filters[] ;
    int $nFilters = tokenize($filterStr, $filters);

    // Do a basic OR type match, if we pass any of them we succeed.
    string $f ;
    for ($f in $filters)
    	{
    	if (gmatch($str, $f) == 1)
    	    return 1 ;
    	}

    return 0 ;
}


// --------------------------------------------------------------------------

/*
 * cMusclePaint_fillList() - Fills the text scroll list with needed items
 *		And selects the first one.
 */
global proc cMusclePaint_fillList(string $mS, string $tsl)
{
    global int $cMusclePaint_mode ; 
    global string $cMusclePaint_modeStr ;	
	global string $cMusclePaint_wtLabels[] ;

    if (`textScrollList -q -numberOfItems $tsl` > 0)
        textScrollList -e -removeAll $tsl ;	// clear it first!

    string $mOs[] ;
	int $mIdxs[] ;
    clear $mOs ;
	clear $mIdxs ;
    if ($cMusclePaint_mode <= 3)
		{
        $mOs = `cMuscleQuery -system  $mS -muscle` ;	// Get all muscles in this system
		$mIdxs = `cMuscleQuery -system  $mS -muscle -index`;	// And their connected index #'s.
		}
    else if ($cMusclePaint_mode == 4)
		{
        $mOs = `cMuscleQuery -system  $mS -direction` ;	// Get all dirs in this system
		$mIdxs = `cMuscleQuery -system  $mS -direction -index`;	// And their connected index #'s.
		}
    else if ($cMusclePaint_mode >= 5 && $cMusclePaint_mode <= 15 )
		{
        $mOs = `cMuscleQuery -system  $mS -smartcollide` ;	// Get all smartCollides in this system
		$mIdxs = `cMuscleQuery -system  $mS -smartcollide -index`;	// And their connected index #'s.
		}
    else 
		{
		string $item = (uiRes("m_cMusclePaint.kPaintModeWeight"));
		$item = `format -stringArg $cMusclePaint_wtLabels[$cMusclePaint_mode] $item`;
		textScrollList -e -append ($item) $tsl ;
		}
    	
    int $nMO = size($mOs) ;
	for ($i=0; $i < $nMO; ++$i)
		{
		string $mO = $mOs[$i] ;
		int $idx = $mIdxs[$i] ;
			
		string $xforms[] = `listRelatives -parent $mO` ;
		string $xform = $xforms[0] ;
	
		// Only let in those passing filter
		if (!cMusclePaint_passesFilter($xform))
			continue ;

		// Is it locked for the mode we are in?
		int $locks[] = `cMuscleWeight -system  $mS -muscle $mO -wt $cMusclePaint_modeStr -q -lock` ;
		int $isLocked = $locks[0] ;	
		
		string $name = ($idx+". ") ;
		$name += $xform ;
		if ($isLocked)
			$name += (uiRes("m_cMusclePaint.kTransformHold")) ;
	
		textScrollList -e -append $name $tsl ; // add to list
		}
 
    if (`textScrollList -q -ni $tsl` > 0)
		textScrollList -e -sii 1 $tsl ;

}


// --------------------------------------------------------------------------

/*
 * cMusclePaint_refreshList() - Like fill...but remembers what was chosen
 *	and then reselects....and rescrolls...
 */
global proc cMusclePaint_refreshList(string $mS, string $tsl)
{
	// So...what is selected now?
    string $origSel[] = cMusclePaint_getSelItemsFromList($tsl) ;	// Store Original Selections, so we can try to reselect at end....
  
    	// Rebuild list.
    cMusclePaint_fillList($mS, $tsl) ;
 	
    	// Now select same stuff
    textScrollList -e -deselectAll $tsl ;

	
	// Now try to restore selection
	//
    int $i ;
    string $o ;
    string $newItems[] = `textScrollList -q -allItems $tsl` ; // Get entire list
    int $nNew = size($newItems) ;
    for ($i=0; $i < $nNew; ++$i)	// Convert new items to short name list only...
    	{
    	string $parts[];
    	tokenize($newItems[$i], $parts) ;
    	$newItems[$i] = $parts[1] ;
    	}
    int $idxToSel[] ;			// What index's should we resel?
    clear $idxToSel ;
    for ($o in $origSel)
        {
        int $idx = -1;
        for ($i=0; $i < $nNew; ++$i)
            {
            if ($newItems[$i] == $o)	// did we find a match?
                {
                $idx = $i ;
                break ;
                }
            }

		// Did we find a match?
		if ($idx != -1)
			$idxToSel[size($idxToSel)] = $idx + 1;	// Store for later, +1 since TSL uses 1 based indexing.
        }

    $idxToSel = `sort $idxToSel` ;	// Sort it in order.

    // At this point $idxToSel has a nice ordered list of index's of the  TSL we want to
    // reselect....or it might be empty.
    for ($i=0; $i < size($idxToSel); ++$i)
         textScrollList -e -sii $idxToSel[$i] $tsl ;	// Reselect each one
    if (size($idxToSel) > 0)
        {
        // Now if we did sel something, scroll to the first one if needed.

        int $numVis = `textScrollList -q -numberOfRows $tsl` ;	// How many can we see?
		if ($idxToSel[0] > $numVis)
			textScrollList -e -showIndexedItem $idxToSel[0] $tsl ;
		}
    else     // End with first item selected if nothing was before.
        {
        if (`textScrollList -q -numberOfItems $tsl` >= 1)
    	    textScrollList -e -sii 1 $tsl ;
    	}	
	

}


// --------------------------------------------------------------------------

/*
 * cMusclePaint_changeMode() - Changes paint mode
 */
global proc cMusclePaint_changeMode(string $opt, string $chkNormal, string $mS, string $mD, string $shape, string $tsl)
{
    global int $cMusclePaint_normalize ; 
    global int $cMusclePaint_mode ; 
    global string $cMusclePaint_modeStr ;	
    global int $cMusclePaint_lastMode ; 
	global string $cMusclePaint_polyGeo ;
    global string $cMusclePaint_wtNames[] ;
    global int $cMusclePaint_wtNormalize[] ;

		// Store poly geom name if it is a poly in fact....    
	$cMusclePaint_polyGeo = "" ;
	string $geos[] = `deformer -q -geometry $mS` ;
	if (nodeType($geos[0]) == "mesh")
		{
		$cMusclePaint_polyGeo = $geos[0] ;
//		print ("// Preparing to edit: "+$geos[0]+" MESH object. //\n") ;
		}

	
	// Get choice
    $cMusclePaint_mode = `optionMenu -q -sl $opt` - 1 ; 

	$cMusclePaint_modeStr = $cMusclePaint_wtNames[ $cMusclePaint_mode ] ;
    // Auto set normalize on or off.
	$cMusclePaint_normalize = $cMusclePaint_wtNormalize[ $cMusclePaint_mode ] ;


    checkBox -e -v $cMusclePaint_normalize $chkNormal ;
    
    // Re-create text list with needed items. if needed.
    if (!( (($cMusclePaint_lastMode <= 3) &&
    	 ($cMusclePaint_mode <= 3)) ||
		 (($cMusclePaint_lastMode >= 5 && $cMusclePaint_lastMode <= 15) &&
    	 ($cMusclePaint_mode >= 5 && $cMusclePaint_mode <= 15 ))		// Get smart change if needed
		 ))
		cMusclePaint_fillList($mS, $tsl) ;	// totally diff, so rebuild all and lose selection
    else
		cMusclePaint_refreshList($mS, $tsl) ;	// else rebuild so hold is correct, but try to keep selection.
    
    $cMusclePaint_lastMode = $cMusclePaint_mode ;
    
    cMusclePaint_selMus($mS, $mD, $shape, $tsl) ;	// start first one
	

}

// --------------------------------------------------------------------------

/*
 * cMusclePaint_setPaintOnOff() - Called when user hits paint on or off
 */
global proc cMusclePaint_setPaintOnOff()
{
	global string $cMusclePaint_mD ;		// Muscle System for easier crap...sigh.
	global string $cMusclePaint_polyGeo ;

    int $paint = `checkBox -q -v cbPaint`;
    int $draw = `checkBox -q -v cbDraw`;

		
    if ($paint)
        {
		string $sel[] = `ls -sl` ;
		string $shape = `textField -q -tx tfGeo`; 
		if (size($sel) <= 0)
			select -r $shape ;  
	    // Now bring up the options and start paint!
		// ScriptPaintToolOptions;	// show tools dialog
		ScriptPaintTool ;	
		artUserPaintCtx -e -tsc "cMusclePaint_toolSetup" `currentCtx`;
			
			
		radioButtonGrp -e -en true rbgPaintMode ;
		checkBox -e -en false cbLiveUpdate ;
		symbolCheckBox -e -en true cbGaussian ;
		symbolCheckBox -e -en true cbPolyBrush ;
		symbolCheckBox -e -en true cbSolid ;
		symbolCheckBox -e -en true cbRectBrush ;
		floatSliderGrp -e -en true fsgOpacity ;
		floatSliderGrp -e -en true fsgRadius ;
		optionMenu -e -en true optTablet ;
		optionMenu -e -en true optRefl ;
		checkBox -e -en true cbProject ;


		// Make sure mode is accurate....
		int $paintMode =`radioButtonGrp -q -sl rbgPaintMode`;
		if ($paintMode == 1)
			artAttrPaintOperation artUserPaintCtx Replace ;
		else if ($paintMode == 2)
			artAttrPaintOperation artUserPaintCtx Add ;
		else if ($paintMode == 3)
			artAttrPaintOperation artUserPaintCtx Scale ;
		else if ($paintMode == 4)
			artAttrPaintOperation artUserPaintCtx Smooth ;
	
		// Update value slider to be driving it as well...
		cMusclePaint_manualWeight(0) ;
	
		// Make sure these other values and ui's match up too...
		string $profile = cMusclePaint_getStampProfile() ;
		cMusclePaint_setStampProfile($profile) ;
		
		float $rad = cMusclePaint_getRadius();
		floatSliderGrp -e -v $rad fsgRadius ;
		
		cMusclePaint_setOpacity() ;
		cMusclePaint_setTablet() ;
		cMusclePaint_setRefl() ;
		cMusclePaint_setProject() ;
		
		
		if ($cMusclePaint_polyGeo != "")
			polyOptions -cm "none" -cs $draw $cMusclePaint_polyGeo ;
		
		changeSelectMode -object ;
		if (size($sel) <= 0)
			select -r $shape ;
		else
			select -r $sel $shape ;
			
		}
    else	// Paint mode off...switch to component type mode.
        {
		radioButtonGrp -e -en false rbgPaintMode ;
		checkBox -e -en true cbLiveUpdate ;
		symbolCheckBox -e -en false cbGaussian ;
		symbolCheckBox -e -en false cbPolyBrush ;
		symbolCheckBox -e -en false cbSolid ;
		symbolCheckBox -e -en false cbRectBrush ;
		floatSliderGrp -e -en false fsgOpacity ;
		floatSliderGrp -e -en false fsgRadius ;
		optionMenu -e -en false optTablet ;
		optionMenu -e -en false optRefl ;
		checkBox -e -en false cbProject ;


			// Totally turn off draw for now...otherwise we'd get wireframe.
		if ($cMusclePaint_polyGeo != "")
			{
			polyOptions -cm "none" -cs $draw $cMusclePaint_polyGeo ;
			}
		
		changeSelectMode -component ;
		}

	// Also save state here since user is doing something... 
	cMusclePaint_saveState() ;
}


// --------------------------------------------------------------------------

/*
 * cMusclePaint_getSelItemsFromList() - Gets items in list, without any (HOLD) at end etc...
 */
global proc string[] cMusclePaint_getSelItemsFromList(string $tsl)
{
    string $items[] = `textScrollList -q -si $tsl`;
    string $item ;
    string $sel[] ;
    
    for ($item in $items)
        {
        string $shorts[] ;
        tokenize($item, $shorts) ;
        
        $sel[ size($sel) ] = $shorts[1] ;	// Just keep short part of name
        }

    return $sel ;
}

// --------------------------------------------------------------------------

/*
 * cMusclePaint_selMus() - Called when a diff muscle is chosen.
 */
global proc cMusclePaint_selMus(string $mS, string $mD, string $shape, string $tsl)
{
    global string $gSelect ;
    global string $gMove ;

    global int $cMusclePaint_mode ;	// sticky or slide?
    global string $cMusclePaint_modeStr ;	
    global int $cMusclePaint_normalize ; 	// normalize?
    
    global int $cMusclePaint_mIdx ;
	global string $cMusclePaint_polyGeo ;

    
    
    string $mO = "" ;
    string $mDir = "" ;
    string $mXforms[] = cMusclePaint_getSelItemsFromList($tsl) ;
    if ($cMusclePaint_mode > 15) 	// force jiggle cycle rest relax wrinkle smooth smoothcompress smoothexpand selfcollision selfrigidity selfvolumize
        {
        $cMusclePaint_mIdx = 0 ;	// Don't need but set so rest of script works...
        }
    else if ($mXforms[0] != "") // is anything even connected/exist in the list?
    	{
    	string $mOs[] = `listRelatives -ni -shapes -type "cMuscleObject" $mXforms[0]`;
    	$mO = $mOs[0] ;
		string $mDirs[] = `listRelatives -ni -shapes -type "cMuscleDirection" $mXforms[0]`;
    	$mDir = $mDirs[0] ;
		string $mSmarts[] = `listRelatives -ni -shapes -type "cMuscleSmartCollide" $mXforms[0]`;
    	$mSmart = $mSmarts[0] ;
    

			// Now we have to get the REAL index this thing is tied to...
			// Because we could have gaps in the connection...so we trace this
			// back to the system we are looking at, and parse out the index #.
			//
		if ($cMusclePaint_mode <= 3 )		// sticky stickyb stickyc sliding
			$cMusclePaint_mIdx = cMuscle_getMusIndex($mO, $mS) ;
		else if ($cMusclePaint_mode == 4)	// direction
			$cMusclePaint_mIdx = cMuscle_getDirIndex($mDir, $mS) ;
		else if ($cMusclePaint_mode >= 5 && $cMusclePaint_mode <= 15)	// smartregiona smartregionb smartbulk smartbulkangular smartbulkwiden smartslide smartslideangular smartsmooth smartwrinkle smartflatten smartvolumize
			$cMusclePaint_mIdx = cMuscle_getSmartCollideIndex($mSmart, $mS) ;
    	}
    else
		$cMusclePaint_mIdx = -1;


    cMusclePaint_changeDrawState($mD) ;	   // Make sure draw is at proper draw state.
    setAttr ($mD+".index") $cMusclePaint_mIdx ;   // show proper weights.
 
	

    setToolTo $gSelect ; 

    cMusclePaint_selChanged() ; 	// Update slider for wt as well...
    
	int $draw = `checkBox -q -v cbDraw`;
	
	cMusclePaint_setPaintOnOff() ; 			// Make sure mode is correct/enable/disable too
		
	// Highlight nodes if possible...
	if ($cMusclePaint_mode >= 0 && $cMusclePaint_mode <= 15)
		{
		if (!`checkBox -q -v cbPaint`)
			hilite -r $mXforms $cMusclePaint_polyGeo ;
		else
			hilite -r $mXforms ;
		}

}

// --------------------------------------------------------------------------

/*
 * cMusclePaint_closeWin() -
 */
global proc cMusclePaint_closeWin(string $win, string $mD)
{
    global string $gSelect ;

	global string $cMusclePaint_polyGeo ;
    
	cMusclePaint_saveState() ;
	
	if ($cMusclePaint_polyGeo != "")
		polyOptions -cm "none" -cs 0 $cMusclePaint_polyGeo ;

	
	// Now if the window exists, we are just "restarting" with a diff geo.
	// so don't do this stuff...
    if (!`window -q -ex cMusclePaintWin`)
    	{
		setAttr ($mD+".draw") 0 ;	// off!
		delete $mD ;
    	setToolTo $gSelect ;	// exit paint
    	}
} 


// --------------------------------------------------------------------------

/*
 * cMusclePaint_saveState() - Save last ui state for recall later.
 */
global proc cMusclePaint_saveState()
{
	global int $cMusclePaint_allowSave ;	// Allow save of state?

	if (!`window -q -ex cMusclePaintWin`)
		{
		return ;
		}
		
	if (!$cMusclePaint_allowSave)
		return ;
	
	
	int $nMode = `radioButtonGrp -q -sl rbgPaintMode` ;
	optionVar -iv "cMusclePaint_mode" $nMode ;
	
	int $live = `checkBox -q -v cbLiveUpdate` ;
	optionVar -iv "cMusclePaint_live" $live ;
	
	int $gauss = `symbolCheckBox -q -v cbGaussian` ;
	optionVar -iv "cMusclePaint_gauss" $gauss ;
	int $poly = `symbolCheckBox -q -v cbPolyBrush` ;
	optionVar -iv "cMusclePaint_poly" $poly ;
	int $solid = `symbolCheckBox -q -v cbSolid` ;
	optionVar -iv "cMusclePaint_solid" $solid ;
	int $rect = `symbolCheckBox -q -v cbRectBrush` ;
	optionVar -iv "cMusclePaint_rect" $rect ;
	
	float $opacity = `floatSliderGrp -q -v fsgOpacity` ;
	optionVar -fv "cMusclePaint_opacity" $opacity ;
	
	float $radius = `floatSliderGrp -q -v fsgRadius` ;
	if (`checkBox -q -v cbPaint` && `currentCtx` == "artUserPaintContext" )		// If in paint mode, attempt to get radius from real ctx vs ui which may not be accurate...
		{
		$radius = cMusclePaint_getRadius() ;
		floatSliderGrp -e -v $radius fsgRadius ;
		}
	optionVar -fv "cMusclePaint_radius" $radius ;

	int $tablet = `optionMenu -q -sl optTablet` ;
	optionVar -iv "cMusclePaint_tablet" $tablet ;
	int $refl = `optionMenu -q -sl optRefl` ;
	optionVar -iv "cMusclePaint_refl" $refl ;

	int $proj = `checkBox -q -v cbProject` ;
	optionVar -iv "cMusclePaint_proj" $proj ;
	
	float $wt = `floatSliderGrp -q -v fsgWt` ;
	optionVar -fv "cMusclePaint_weight" $wt ;
	
	int $ptWtType = `optionMenu -q -sl optPaintWtMode` ;
	optionVar -iv "cMusclePaint_paintWeightType" $ptWtType ;
	
	int $draw = `checkBox -q -v cbDraw` ;
	optionVar -iv "cMusclePaint_draw" $draw ;
	
	int $gray = `checkBox -q -v cbGray` ;
	optionVar -iv "cMusclePaint_gray" $gray ;
	
	int $ptSize = `intSliderGrp -q -v isgPtSize` ;
	optionVar -iv "cMusclePaint_ptSize" $ptSize ;
	
	float $col[3] ;
	$col = `colorSliderGrp -q -rgb csgA` ;
	optionVar -fv "cMusclePaint_colAR" $col[0] ;
	optionVar -fv "cMusclePaint_colAG" $col[1] ;
	optionVar -fv "cMusclePaint_colAB" $col[2] ;
	
	$col = `colorSliderGrp -q -rgb csgB` ;
	optionVar -fv "cMusclePaint_colBR" $col[0] ;
	optionVar -fv "cMusclePaint_colBG" $col[1] ;
	optionVar -fv "cMusclePaint_colBB" $col[2] ;

	$col = `colorSliderGrp -q -rgb csgC` ;
	optionVar -fv "cMusclePaint_colCR" $col[0] ;
	optionVar -fv "cMusclePaint_colCG" $col[1] ;
	optionVar -fv "cMusclePaint_colCB" $col[2] ;
	
	// print ("// Saved cMusclePaint UI Settings. //\n") ;
}

// --------------------------------------------------------------------------

/*
 * cMusclePaint_saveState() - Save last ui state for recall later.
 */
global proc cMusclePaint_restoreState(string $mS, string $mD, string $shape, string $tsl)
{
	global int $cMusclePaint_allowSave ;	// Allow save of state?

	cMusclePaint_setPaintOnOff(); 
	
	int $nMode = 1 ;
	if (`optionVar -exists "cMusclePaint_mode"`)
		$nMode = `optionVar -q "cMusclePaint_mode"` ;
	radioButtonGrp -e -sl $nMode rbgPaintMode ;
	switch ($nMode)
		{
		case 1:
			artAttrPaintOperation artUserPaintCtx Replace ;
			break ;
		case 2:
			artAttrPaintOperation artUserPaintCtx Add ;
			break ;
		case 3:
			artAttrPaintOperation artUserPaintCtx Scale ;
			break ;
		case 4:
			artAttrPaintOperation artUserPaintCtx Smooth ;
			break ;
		}
		
	int $live = 1 ;
	if (`optionVar -exists "cMusclePaint_live"`)
		$live = `optionVar -q "cMusclePaint_live"` ;
	checkBox -e -v $live cbLiveUpdate ;
	
	int $gauss = 0 ;
	int $poly = 1 ;
	int $solid = 0 ;
	int $rect = 0 ;
	if (`optionVar -exists "cMusclePaint_gauss"`)
		$gauss = `optionVar -q "cMusclePaint_gauss"` ;
	if (`optionVar -exists "cMusclePaint_poly"`)
		$poly = `optionVar -q "cMusclePaint_poly"` ;
	if (`optionVar -exists "cMusclePaint_solid"`)
		$solid = `optionVar -q "cMusclePaint_solid"` ;
	if (`optionVar -exists "cMusclePaint_rect"`)
		$rect = `optionVar -q "cMusclePaint_rect"` ;
	symbolCheckBox -e -v $gauss cbGaussian ;
	symbolCheckBox -e -v $poly cbPolyBrush ;
	symbolCheckBox -e -v $solid cbSolid ;
	symbolCheckBox -e -v $rect cbRectBrush ;
	if ($gauss)
		cMusclePaint_setStampProfile("gaussian"); ;
	if ($poly)
		cMusclePaint_setStampProfile("poly");
	if ($solid)
		cMusclePaint_setStampProfile("solid");
	if ($rect)
		cMusclePaint_setStampProfile("square");

	
	float $opacity = 1.0 ;
	if (`optionVar -exists "cMusclePaint_opacity"`)
		$opacity = `optionVar -q "cMusclePaint_opacity"` ;
	floatSliderGrp -e -v $opacity fsgOpacity ;
	cMusclePaint_setOpacity();

	float $radius = 1.0 ;
	if (`optionVar -exists "cMusclePaint_radius"`)
		$radius = `optionVar -q "cMusclePaint_radius"` ;
	floatSliderGrp -e -v $radius fsgRadius ;
	cMusclePaint_setRadius();

	int $tablet = 1 ;
	if (`optionVar -exists "cMusclePaint_tablet"`)
		$tablet = `optionVar -q "cMusclePaint_tablet"` ;
	optionMenu -e -sl $tablet optTablet ;
	cMusclePaint_setTablet() ;

	int $refl = 1 ;
	if (`optionVar -exists "cMusclePaint_refl"`)
		$refl = `optionVar -q "cMusclePaint_refl"` ;
	optionMenu -e -sl $refl optRefl ;
	cMusclePaint_setRefl() ;

	int $proj = 0 ;
	if (`optionVar -exists "cMusclePaint_proj"`)
		$proj = `optionVar -q "cMusclePaint_proj"` ;
	checkBox -e -v $proj cbProject ;
	cMusclePaint_setProject() ;

	float $wt = 1.0 ;
	if (`optionVar -exists "cMusclePaint_weight"`)
		$wt = `optionVar -q "cMusclePaint_weight"` ;
	floatSliderGrp -e -v $wt fsgWt ;
	cMusclePaint_manualWeight(0) ;

	int $ptWtType = 1 ;
	if (`optionVar -exists "cMusclePaint_paintWeightType"`)
		$ptWtType = `optionVar -q "cMusclePaint_paintWeightType"` ;
	optionMenu -e -sl $ptWtType optPaintWtMode ;
	cMusclePaint_changeMode("optPaintWtMode", "cbPaintNormalize", $mS, $mD, $shape, $tsl);

	int $draw = 1 ;
	if (`optionVar -exists "cMusclePaint_draw"`)
		$draw = `optionVar -q "cMusclePaint_draw"` ;
	checkBox -e -v $draw cbDraw ;
	cMusclePaint_changeDrawState($mD) ;
	
	int $gray = 0 ;
	if (`optionVar -exists "cMusclePaint_gray"`)
		$gray = `optionVar -q "cMusclePaint_gray"` ;
	checkBox -e -v $gray cbGray ;
	setAttr ($mD+".grayscale") $gray ;
	
	int $ptSize = 4 ;
	if (`optionVar -exists "cMusclePaint_ptSize"`)
		$ptSize = `optionVar -q "cMusclePaint_ptSize"` ;
	intSliderGrp -e -v $ptSize isgPtSize ;
	setAttr ($mD+".ptSize") $ptSize ;

	float $colR, $colG, $colB ;
	$colR = 1.0 ;
	$colG = 0.0 ;
	$colB = 0.0 ;
	if (`optionVar -exists "cMusclePaint_colAR"`)
		$colR = `optionVar -q "cMusclePaint_colAR"` ;
	if (`optionVar -exists "cMusclePaint_colAG"`)
		$colG = `optionVar -q "cMusclePaint_colAG"` ;
	if (`optionVar -exists "cMusclePaint_colAB"`)
		$colB = `optionVar -q "cMusclePaint_colAB"` ;
	colorSliderGrp -e -rgb $colR $colG $colB csgA ;
	setAttr ($mD+".colorA") $colR $colG $colB ;

	$colR = 1.0 ;
	$colG = 1.0 ;
	$colB = 0.0 ;
	if (`optionVar -exists "cMusclePaint_colBR"`)
		$colR = `optionVar -q "cMusclePaint_colBR"` ;
	if (`optionVar -exists "cMusclePaint_colBG"`)
		$colG = `optionVar -q "cMusclePaint_colBG"` ;
	if (`optionVar -exists "cMusclePaint_colBB"`)
		$colB = `optionVar -q "cMusclePaint_colBB"` ;
	colorSliderGrp -e -rgb $colR $colG $colB csgB ;
	setAttr ($mD+".colorB") $colR $colG $colB ;

	$colR = 0.0 ;
	$colG = 0.3 ;
	$colB = 0.4 ;
	if (`optionVar -exists "cMusclePaint_colCR"`)
		$colR = `optionVar -q "cMusclePaint_colCR"` ;
	if (`optionVar -exists "cMusclePaint_colCG"`)
		$colG = `optionVar -q "cMusclePaint_colCG"` ;
	if (`optionVar -exists "cMusclePaint_colCB"`)
		$colB = `optionVar -q "cMusclePaint_colCB"` ;
	colorSliderGrp -e -rgb $colR $colG $colB csgC ;
	setAttr ($mD+".colorC") $colR $colG $colB ;

	
	$cMusclePaint_allowSave = 1 ;	// Now it's ok!
	
	print (uiRes("m_cMusclePaint.kRestoredMusclePaintUI")) ;
}

// --------------------------------------------------------------------------

/*
 * cMusclePaint_selectCVsFromNodes() - Selects cvs from highlighted nodes
 */
global proc cMusclePaint_selectCVsFromNodes(string $mS, string $mD, string $tsl, string $shape)
{
	global int $cMusclePaint_mode ;	// sticky or slide? or dir?
    global string $cMusclePaint_modeStr ;	
	
	if ($cMusclePaint_mode <= 15)  // sticky stickyb stickyc sliding direction smart...
		{
		string $nodes[] = cMusclePaint_getSelItemsFromList($tsl) ;
		int $nNodes = size($nodes) ;
	
		select -cl ;
		if ($nNodes <= 0)
			return ;
	
		// So try to get cv's...
		string $comps[] = cMuscle_getCompsFromNodes($mS, $nodes, $shape, $cMusclePaint_mode, $cMusclePaint_modeStr) ;
	
			// And select if we did.
		if (size($comps) > 0)
			select -r $comps ;
		}
	else
		{
			// So try to get cv's...
		string $comps[] = cMuscle_getCompsFromWtMode($mS, $shape, $cMusclePaint_mode, $cMusclePaint_modeStr) ;

			// And select if we did.
		if (size($comps) > 0)
			select -r $comps ;
		}

		
	// Select painting shape too if in paint mode...so this works nice for clipping and continuing to paint etc...
	if (`checkBox -q -v cbPaint`)
		{
		select -add $shape ;
		cMusclePaint_selMus($mS, $mD, $shape, $tsl);		// need to call this so paint re-inits with clipping of selected pts
		}
}


// --------------------------------------------------------------------------


/*
 * cMusclePaint_selectNodesFromCVs() - Selects nodes from selected cvs
 */
global proc cMusclePaint_selectNodesFromCVs(string $mS, string $mD, string $tsl, string $shape)
{
	global int $cMusclePaint_mode ;	// sticky or slide? or dir?
    global string $cMusclePaint_modeStr ;	
	
	if ($cMusclePaint_mode > 15)  // !  sticky stickyb stickyc sliding direction smart...
		return ; 
	
	
	// Start by getting any selected points related to this skinCluster
    string $comps[] = cMuscle_getSelComps($mS, false) ;	// What pts chosen?
    int $nComp = size($comps) ;

	// Unhighlight to start
    textScrollList -e -deselectAll $tsl ;

    if ($nComp <= 0)
        return ;

	// Get all nodes related to the cvs...
    string $nodes[] = cMuscle_getNodesFromComps($mS, $comps, $shape, $cMusclePaint_mode, $cMusclePaint_modeStr ) ;

	
    // Now highlight those...if they are in the list we are looking at...


    // Get all items in the list
    string $j ;
    string $allItems[] = `textScrollList -q -allItems $tsl` ; // Get entire list
    int $nItems = size($allItems) ;
    for ($i=0; $i < $nItems; ++$i)	// Convert items to short name list only...
    	{
    	string $parts[];
    	tokenize($allItems[$i], $parts) ;
    	$allItems[$i] = $parts[1] ;
    	}
    int $idxToSel[] ;				// What index's should we sel?
    clear $idxToSel ;
    for ($node in $nodes)
        {
        int $idx = -1;
        for ($i=0; $i < $nItems; ++$i)
            {
            if ($allItems[$i] == $node)	// did we find a match?
                {
                $idx = $i ;
                break ;
                }
            }

		// Did we find a match?
		if ($idx != -1)
			$idxToSel[size($idxToSel)] = $idx + 1;	// Store for later, +1 since TSL uses 1 based indexing.
		}

    $idxToSel = `sort $idxToSel` ;	// Sort it in order.

	// Unhighlight to start
    textScrollList -e -deselectAll $tsl ;

    for ($i=0; $i < size($idxToSel); ++$i)
         textScrollList -e -sii $idxToSel[$i] $tsl ;	// Reselect each one
    if (size($idxToSel) > 0)
        {
        // Now if we did sel something, scroll to the first one if needed.

        int $numVis = `textScrollList -q -numberOfRows $tsl` ;	// How many can we see?
		if ($idxToSel[0] > $numVis)
			textScrollList -e -showIndexedItem $idxToSel[0] $tsl ;
		}

    
	cMusclePaint_selMus($mS, $mD, $shape, $tsl);		// need to call this so seems as if user did the select. 
}

// --------------------------------------------------------------------------




