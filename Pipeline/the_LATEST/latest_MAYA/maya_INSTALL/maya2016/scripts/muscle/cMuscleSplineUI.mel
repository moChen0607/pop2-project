// Copyright (C) 1997-2014 Autodesk, Inc., and/or its licensors.
// All rights reserved.
//
// The coded instructions, statements, computer programs, and/or related
// material (collectively the "Data") in these files contain unpublished
// information proprietary to Autodesk, Inc. ("Autodesk") and/or its licensors,
// which is protected by U.S. and Canadian federal copyright law and by
// international treaties.
//
// The Data is provided for use exclusively by You. You have the right to use,
// modify, and incorporate this Data into other products for purposes authorized 
// by the Autodesk software license agreement, without fee.
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND. AUTODESK
// DOES NOT MAKE AND HEREBY DISCLAIMS ANY EXPRESS OR IMPLIED WARRANTIES
// INCLUDING, BUT NOT LIMITED TO, THE WARRANTIES OF NON-INFRINGEMENT,
// MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE, OR ARISING FROM A COURSE 
// OF DEALING, USAGE, OR TRADE PRACTICE. IN NO EVENT WILL AUTODESK AND/OR ITS
// LICENSORS BE LIABLE FOR ANY LOST REVENUES, DATA, OR PROFITS, OR SPECIAL,
// DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES, EVEN IF AUTODESK AND/OR ITS
// LICENSORS HAS BEEN ADVISED OF THE POSSIBILITY OR PROBABILITY OF SUCH DAMAGES.

proc string controlType_melToUI(string $mel)
{
	string $ui = $mel;

	if($mel == "cube")
	{
		$ui = (uiRes("m_cMuscleSplineUI.kControlTypeCube")) ;
	} else if ($mel == "circleY")
	{
		$ui = (uiRes("m_cMuscleSplineUI.kControlTypeCircleY")) ;
	} else if ($mel == "null")
	{
		$ui = (uiRes("m_cMuscleSplineUI.kControlTypeNull")) ;
	} else {
		uiToMelMsg("controlType_melToUI", $mel, 0);
	}

	return $ui;
}

proc string controlType_uiToMel(string $ui)
{
	string $mel = $ui;

	if($ui == (uiRes("m_cMuscleSplineUI.kControlTypeCube")))
	{
		$mel = "cube";
	} else if($ui == (uiRes("m_cMuscleSplineUI.kControlTypeCircleY")))
	{
		$mel = "circleY";
	} else if($ui == (uiRes("m_cMuscleSplineUI.kControlTypeNull")))
	{
		$mel = "null";
	} else {
		uiToMelMsg("controlType_uiToMel", $ui, 0);
	}

	return $mel;
}

proc string drivenType_melToUI(string $mel)
{
	string $ui = $mel;

	if($mel == "joint")
	{
		$ui = (uiRes("m_cMuscleSplineUI.kDrivenTypeJoint")) ;
	} else if ($mel == "circleY")
	{
		$ui = (uiRes("m_cMuscleSplineUI.kDrivenTypeCircleY")) ;
	} else if ($mel == "null")
	{
		$ui = (uiRes("m_cMuscleSplineUI.kDrivenTypeNull")) ;
	} else {
		uiToMelMsg("drivenType_melToUI", $mel, 0);
	}

	return $ui;
}

proc string drivenType_uiToMel(string $ui)
{
	string $mel = $ui;

	if($ui == (uiRes("m_cMuscleSplineUI.kDrivenTypeJoint")))
	{
		$mel = "joint";
	} else if($ui == (uiRes("m_cMuscleSplineUI.kDrivenTypeCircleY")))
	{
		$mel = "circleY";
	} else if($ui == (uiRes("m_cMuscleSplineUI.kDrivenTypeNull")))
	{
		$mel = "null";
	} else {
		uiToMelMsg("drivenType_uiToMel", $ui, 0);
	}

	return $mel;
}

// --------------------------------------------------------------------------

// --------------------------------------------------------------------------
//	UI Procs
// --------------------------------------------------------------------------

// --------------------------------------------------------------------------

/*
 * cMuscleSplineUI() - UI For Spline Setup
 */
global proc cMuscleSplineUI()
{
    if (!`pluginInfo -q -loaded "MayaMuscle"`)
		error (uiRes("m_cMuscleSplineUI.kMustLoadMusclePlugin"));
	
    if (`window -q -ex cMuscleSplineUIWin`)
        {
        showWindow cMuscleSplineUIWin ;
        return ;
        }

	window -w 370 
		-h 170 
		-t (uiRes("m_cMuscleSplineUI.kWindowTitleMuscleSpline")) cMuscleSplineUIWin ;
        
    scrollLayout mainMuscleSplineUIScrollLayout;
    formLayout mainSplineForm ;
	
	text -l (uiRes("m_cMuscleSplineUI.kSplineName")) txName ;
	// "Spline" is the default base name for the new spline.
	textField -tx "Spline" tfName ;
	
	intSliderGrp -label (uiRes("m_cMuscleSplineUI.kNumInsertionControls")) 
		-field 1 
		-min 2 
		-max 24 
		-fmn 2 
		-fmx 256 
		-v 3 
		-cw3 120 40 80 
		-adj 3 isgPts ;
	optionMenu -l (uiRes("m_cMuscleSplineUI.kSplineInsertionType")) omPts ;
		menuItem -l (controlType_melToUI("cube")) ;
		menuItem -l (controlType_melToUI("circleY")) ;
		menuItem -l (controlType_melToUI("null")) ;
	optionMenu -e -sl 1 omPts ;
		
	intSliderGrp -label (uiRes("m_cMuscleSplineUI.kNumDriven")) 
		-field 1 
		-min 1 
		-max 64 
		-fmn 1 
		-fmx 256 
		-v 5 
		-cw3 120 40 80 
		-adj 3 isgDrive ;
	optionMenu -l (uiRes("m_cMuscleSplineUI.kSplineDrivenType")) omDrive ;
		menuItem -l (drivenType_melToUI("joint")) ;
		menuItem -l (drivenType_melToUI("circleY")) ;
		menuItem -l (drivenType_melToUI("null")) ;
	optionMenu -e -sl 1 omDrive ;
	
	checkBox -l (uiRes("m_cMuscleSplineUI.kConstrainMidControls")) 
		-v 1 
		-ann (uiRes("m_cMuscleSplineUI.kConstrainMidControlsAnnot")) cbConstrainMid ;
	
	button -l (uiRes("m_cMuscleSplineUI.kCreateMuscleSpline")) 
		-c ("cMuscleSplineUICB();") 
		-ann (uiRes("m_cMuscleSplineUI.kCreateMuscleSplineAnnot")) btnRig ;
		
	formLayout -e
		-af txName "top" 8
    	-an txName "bottom" 
    	-af txName "left" 5
    	-an txName "right" 

		-af tfName "top" 5
    	-an tfName "bottom" 
    	-ac tfName "left" 5 txName
    	-af tfName "right" 5 

		
		-ac isgPts "top" 5 tfName
    	-an isgPts "bottom" 
    	-af isgPts "left" 5
    	-an isgPts "right" 

		-ac omPts "top" 5 tfName
    	-an omPts "bottom" 
    	-ac omPts "left" 5 isgPts
    	-af omPts "right" 5

		-ac isgDrive "top" 5 omPts
    	-an isgDrive "bottom" 
    	-af isgDrive "left" 5
    	-an isgDrive "right" 

		-ac omDrive "top" 5 omPts
    	-an omDrive "bottom" 
    	-ac omDrive "left" 5 isgDrive
    	-af omDrive "right" 5
		
		-ac cbConstrainMid "top" 5 omDrive
    	-an cbConstrainMid "bottom" 
    	-af cbConstrainMid "left" 5
    	-af cbConstrainMid "right" 5
		
		-ac btnRig "top" 5 cbConstrainMid
    	-an btnRig "bottom" 
    	-af btnRig "left" 5
    	-af btnRig "right" 5
		
	
		mainSplineForm ;
		
		
	showWindow cMuscleSplineUIWin ;
}

// --------------------------------------------------------------------------

/*
 * cMuscleSplineUICB() - UI Wrapper
 */
global proc cMuscleSplineUICB()
{
	string $ctrls[];
	string $reads[] ;
	
	string $baseName = `textField -q -tx tfName` ;
	int $nControls = `intSliderGrp -q -v isgPts` ;
	string $controlType = (controlType_uiToMel(`optionMenu -q -v omPts`)) ;
	int $detail = 8 ;
	int $nRead = `intSliderGrp -q -v isgDrive` ;
	string $readType = (drivenType_uiToMel(`optionMenu -q -v omDrive`)) ;
	int $bConstrainMid = `checkBox -q -v cbConstrainMid` ;
	
	// Do actual rigging!	
	string $spline = cMS_makeSpline($baseName, $nControls, $controlType, $detail, $nRead, $readType, $ctrls, $reads, $bConstrainMid) ;

	string $msg = (uiRes("m_cMuscleSplineUI.kGeneratedRig"));
	$msg = `format -stringArg $spline $msg`;
	print $msg ;
}



// --------------------------------------------------------------------------

/*
 * cMuscleSplineDeformerUI() - UI For Deformer Setup
 */
global proc cMuscleSplineDeformerUI()
{
    if (!`pluginInfo -q -loaded "MayaMuscle"`)
		error uiRes("m_cMuscleSplineUI.kMustLoadMusclePlugin");
	
    if (`window -q -ex cMuscleSplineDeformerUIWin`)
        {
        showWindow cMuscleSplineDeformerUIWin ;
        return ;
        }

	window -w 370 
		-h 140 
		-t (uiRes("m_cMuscleSplineUI.kWindowTitleMuscleSplineDeformer")) cMuscleSplineDeformerUIWin ;
        
    formLayout mainSplineDefForm ;
	
	text -l (uiRes("m_cMuscleSplineUI.kSplineDeformerName")) txName ;
	// "Muscle" is the default base name for the new muscle.
	textField -tx "Muscle" tfName ;
	
	intSliderGrp -label (uiRes("m_cMuscleSplineUI.kNumControls")) -field 1 -min 2 -max 24 -fmn 2 -fmx 256 -v 3 -cw3 75 40 80 -adj 3 isgPts ;
	optionMenu -l (uiRes("m_cMuscleSplineUI.kSplineDeformerControlType")) omPts ;
		menuItem -l (controlType_melToUI("cube")) ;
		menuItem -l (controlType_melToUI("circleY")) ;
		menuItem -l (controlType_melToUI("null")) ;
	optionMenu -e -sl 1 omPts ;
	
	checkBox -l (uiRes("m_cMuscleSplineUI.kMakeMuscleObject")) -v 1 cbMakeMuscle ;
		
	button -l (uiRes("m_cMuscleSplineUI.kSetupMuscleSpline")) 
		-c ("cMuscleSplineDeformerUICB();") 
		-ann (uiRes("m_cMuscleSplineUI.kSetupMuscleSplineAnnot")) btnRig ;
		
	formLayout -e
		-af txName "top" 8
    	-an txName "bottom" 
    	-af txName "left" 5
    	-an txName "right" 

		-af tfName "top" 5
    	-an tfName "bottom" 
    	-ac tfName "left" 5 txName
    	-af tfName "right" 5 

		
		-ac isgPts "top" 5 tfName
    	-an isgPts "bottom" 
    	-af isgPts "left" 5
    	-an isgPts "right" 

		-ac omPts "top" 5 tfName
    	-an omPts "bottom" 
    	-ac omPts "left" 5 isgPts
    	-af omPts "right" 5

		
		-ac cbMakeMuscle "top" 5 omPts
    	-an cbMakeMuscle "bottom" 
    	-af cbMakeMuscle "left" 5
    	-af cbMakeMuscle "right" 5
	
		-ac btnRig "top" 5 cbMakeMuscle
    	-an btnRig "bottom" 
    	-af btnRig "left" 5
    	-af btnRig "right" 5
		
	
		mainSplineDefForm ;
		
		
	showWindow cMuscleSplineDeformerUIWin ;
}

// --------------------------------------------------------------------------

/*
 * cMuscleSplineDeformerUICB() - UI Wrapper
 */
global proc cMuscleSplineDeformerUICB()
{
	string $ctrls[];
		
	string $baseName = `textField -q -tx tfName` ;
	int $nControls = `intSliderGrp -q -v isgPts` ;
	string $controlType = (controlType_uiToMel(`optionMenu -q -v omPts`)) ;
	int $makeMuscle = `checkBox -q -v cbMakeMuscle` ;

	string $objs[] = `ls -sl` ;
	if (size($objs) <= 0)
		error -sl 0 (uiRes("m_cMuscleSplineUI.kMustSelectObjectToSetUp")) ;
	
	string $geo = $objs[0] ;
	
	// Do actual rigging!	
	string $def = cMS_makeSplineDeformer($baseName, $nControls, $controlType, $ctrls, $geo, $makeMuscle ) ;
	

	string $msg = (uiRes("m_cMuscleSplineUI.kGeneratedSplineDeformer"));
	$msg = `format -stringArg $def $msg`;
	print ($msg) ;
}

// --------------------------------------------------------------------------

/*
 * cMS_resetSplineDefBasePoseSel() - For sel objects that have a cMuscleSplineDeformer
 *		applied, this will reset their base pose.
 */
global proc cMS_resetSplineDefBasePoseSel()
{
		
    string $objs[] = `ls -sl`;
    
    if (size($objs) <= 0)
        error -sl 0 (uiRes("m_cMuscleSplineUI.kMustSelectMuscleSplineToReset")) ;
	
		// Look for any deformers
    string $hist[] = `listHistory -pdo true -il 1 $objs`;
    string $mSs[] = `ls -type "cMuscleSplineDeformer" $hist` ;
	string $mS ;
	
	for ($mS in $mSs)
		{
		cMS_resetSplineDefBasePose($mS) ;
		string $msg = (uiRes("m_cMuscleSplineUI.kResetBasePose"));
		$msg = `format -stringArg $mS $msg`;
		print ($msg) ;
		}

}

// --------------------------------------------------------------------------

/*
 * cMuscleSplineShapeUI() - UI For Shape Setup
 */
global proc cMuscleSplineDeformerShapeUI()
{
    if (!`pluginInfo -q -loaded "MayaMuscle"`)
		error uiRes("m_cMuscleSplineUI.kMustLoadMusclePlugin");
	
    if (`window -q -ex cMuscleSplineDeformerShapeUIWin`)
        {
        showWindow cMuscleSplineDeformerShapeUIWin ;
        return ;
        }

	window -w 390 
		-h 245 
		-t (uiRes("m_cMuscleSplineUI.kWindowTitleMuscleSplineDeformerShape")) cMuscleSplineDeformerShapeUIWin ;
        
    scrollLayout mainMuscleSplineDeformerShapeUIScrollLayout;
    formLayout -parent mainMuscleSplineDeformerShapeUIScrollLayout mainSplineDefShapeForm ;
	
	text -l (uiRes("m_cMuscleSplineUI.kGeo")) txGeoShape ;
	textField -tx "" tfGeoShape ;
	button -l "<<<" 
		-c ("cMS_loadShapeGeo();") 
		-ann (uiRes("m_cMuscleSplineUI.kGeoLoadSelectedGeoMetry")) btnGeoShape ;
	
	text -l (uiRes("m_cMuscleSplineUI.kDef")) txDefShape ;
	textField -tx "" -ed 0 tfDefShape ;
	
	separator -h 3 sepShape1 ;
	
	button -l (uiRes("m_cMuscleSplineUI.kPrepForSculpt")) 
		-c ("cMS_prepForShapeSculpt();") 
		-ann (uiRes("m_cMuscleSplineUI.kPrepForSculptAnnot")) btnPrep ;
    colorSliderGrp -l "" -rgb 0.28 0.78 0.55 -h 18 -cw3 1 24 60 -adj 3
			-cc ("if (objExists(\"matMuscleShapeCorrected\")) { float $rgb[3] = `colorSliderGrp -q -rgb csgTgtColor`; setAttr -type double3 \"matMuscleShapeCorrected.color\" $rgb[0] $rgb[1] $rgb[2] ; } ") 
			-dc ("if (objExists(\"matMuscleShapeCorrected\")) { float $rgb[3] = `colorSliderGrp -q -rgb csgTgtColor`; setAttr -type double3 \"matMuscleShapeCorrected.color\" $rgb[0] $rgb[1] $rgb[2] ; } ") 
			csgTgtColor ;
	button -l (uiRes("m_cMuscleSplineUI.kCreateNew")) 
		-c ("cMS_createNewShape();") 
		-ann (uiRes("m_cMuscleSplineUI.kCreateNewAnnot")) btnCreate ;
	button -l (uiRes("m_cMuscleSplineUI.kEdit")) 
		-c ("cMS_editShape") 
		-ann (uiRes("m_cMuscleSplineUI.kEditAnnot")) btnEdit ;
	button -l (uiRes("m_cMuscleSplineUI.kRename")) 
		-c ("cMS_renameShape();") 
		-ann (uiRes("m_cMuscleSplineUI.kRenameAnnot")) btnRename ;
	button -l (uiRes("m_cMuscleSplineUI.kDelete")) 
		-c ("cMS_deleteShape();") 
		-ann (uiRes("m_cMuscleSplineUI.kDeleteAnnot")) btnDelete ;
	
	floatSliderGrp -l (uiRes("m_cMuscleSplineUI.kBlend")) -field true -min 0.0 -max 1.0 -v 0.5 -pre 2 -cw3 50 40 120 -adj 3 fsgBlend ;

	separator -h 3 sepShape2 ;
	
	floatSliderGrp -l (uiRes("m_cMuscleSplineUI.kCurrentState")) 
		-en 0 
		-field true 
		-min 
		-1.0 
		-max 1.0 
		-v 0.0 
		-pre 3 
		-cw3 80 50 110 
		-adj 3 fsgState ;
	
	// Make sq/st show
	
	textScrollList -ams false tslShapes ;
		
	formLayout -e
		-af txGeoShape "top" 8
    	-an txGeoShape "bottom" 
    	-af txGeoShape "left" 5
    	-an txGeoShape "right" 

		-af tfGeoShape "top" 5
    	-an tfGeoShape "bottom" 
    	-ac tfGeoShape "left" 5 txGeoShape
    	-ac tfGeoShape "right" 5 btnGeoShape 

		-af btnGeoShape "top" 5
    	-an btnGeoShape "bottom" 
    	-an btnGeoShape "left" 
    	-af btnGeoShape "right" 5 

		
		-ac txDefShape "top" 8 tfGeoShape
    	-an txDefShape "bottom" 
    	-af txDefShape "left" 5
    	-an txDefShape "right" 

		-ac tfDefShape "top" 5 tfGeoShape
    	-an tfDefShape "bottom" 
    	-ac tfDefShape "left" 5 txDefShape
    	-af tfDefShape "right" 5 
	
		
		-ac sepShape1 "top" 5 tfDefShape
    	-an sepShape1 "bottom" 
    	-af sepShape1 "left" 0
    	-af sepShape1 "right" 0 

		
		-ac btnPrep "top" 5 sepShape1
    	-an btnPrep "bottom" 
    	-af btnPrep "left" 0
    	-ap btnPrep "right" 0 25 

		-ac csgTgtColor "top" 5 sepShape1
    	-an csgTgtColor "bottom" 
    	-ap csgTgtColor "left" 0 25
    	-ap csgTgtColor "right" 0 50 

		-ac btnCreate "top" 5 btnPrep
    	-an btnCreate "bottom" 
    	-af btnCreate "left" 0
    	-ap btnCreate "right" 0 25 

		-ac btnEdit "top" 5 btnPrep
    	-an btnEdit "bottom" 
    	-ap btnEdit "left" 0 25
    	-ap btnEdit "right" 0 50 
		
		-ac btnRename "top" 5 btnCreate
    	-an btnRename "bottom" 
    	-af btnRename "left" 0
    	-ap btnRename "right" 0 25 

		-ac btnDelete "top" 5 btnCreate
    	-an btnDelete "bottom" 
    	-ap btnDelete "left" 0 25
    	-ap btnDelete "right" 0 50
		
		-ac fsgBlend "top" 5 btnRename
    	-an fsgBlend "bottom" 
    	-af fsgBlend "left" 0
    	-ap fsgBlend "right" 0 50
		 
		-ac sepShape2 "top" 5 fsgBlend
    	-an sepShape2 "bottom" 
    	-af sepShape2 "left" 0
    	-ap sepShape2 "right" 0 50

		-ac fsgState "top" 5 sepShape2
    	-an fsgState "bottom" 
    	-af fsgState "left" 0
    	-ap fsgState "right" 0 50
		 

		-ac tslShapes "top" 5 sepShape1
    	-af tslShapes "bottom" 5 
    	-ap tslShapes "left" 0 51
    	-af tslShapes "right" 5

		
		mainSplineDefShapeForm ;
		
		
	showWindow cMuscleSplineDeformerShapeUIWin ;
	
	cMS_loadShapeGeo() ;		// Try to do an immediate load
}

// --------------------------------------------------------------------------

/*
 * cMS_loadShapeGeo() - Loads shape geo into field
 */
global proc cMS_loadShapeGeo()
{
	string $objs[] = `ls -sl`;
	
	textField -e -tx "" tfGeoShape ;
	textField -e -tx "" tfDefShape ;
	
	cMS_setupShapeState(0) ;
	
	if ($objs[0] != "")
		{
			// Look for any deformers
		string $hist[] = `listHistory -pdo true -il 1 $objs[0]`;
		string $mSs[] = `ls -type "cMuscleSplineDeformer" $hist` ;
		
		if ($mSs[0] != "")
			{
			textField -e -tx $objs[0] tfGeoShape ;
			textField -e -tx $mSs[0] tfDefShape ;

			connectControl fsgBlend ($mSs[0]+".shapingBlend");
			cMS_setupShapeState(1) ;
			select -r $objs[0] ;
			}
		}
		


	cMS_refreshShapeList() ;
}

// --------------------------------------------------------------------------

/*
 * cMS_setupShapeState() - 
 */
global proc cMS_setupShapeState(int $create)
{
	// First blow away any nodes.
	if (objExists("multpilyDivideSquashShapeState"))
		delete "multpilyDivideSquashShapeState" ;
	if (objExists("plusMinusAverageShapeState"))
		delete "plusMinusAverageShapeState" ;
		
	if ($create)
		{
		string $def = `textField -q -tx tfDefShape` ;
		if ($def == "" || objExists($def) != true)
			return ;
		
		// Make something to make squash negative....
		string $multSquash = `createNode "multiplyDivide" -n ("multpilyDivideSquashShapeState")`;
		connectAttr -f ($def+".pctSquash") ($multSquash+".input1X") ;
		setAttr -type "float3" ($multSquash+".input2") -1.0 -1.0 -1.0 ;
		
		// Add that plus the stretch together
		string $plusState = `createNode "plusMinusAverage" -n ("plusMinusAverageShapeState")` ;
		connectAttr -f ($def+".pctStretch") ($plusState+".input1D[0]") ;
		connectAttr -f ($multSquash+".outputX") ($plusState+".input1D[1]") ;
		
		// And now connect it
		connectControl fsgState ($plusState+".output1D") ;
		floatSliderGrp -e -en 0 fsgState ;
		select -cl ;
		}
}

// --------------------------------------------------------------------------

/*
 * cMS_refreshShapeList() -
 */
global proc cMS_refreshShapeList()
{
    string $geo = `textField -q -tx tfGeoShape` ;
	string $def = `textField -q -tx tfDefShape` ;
	
	textScrollList -e -removeAll tslShapes ;

    if ($geo == "" || objExists($geo) != true || $def == "" || objExists($def) != true)
    	{
    	return ;
    	}
			
	int $nShapes = `getAttr -size ($def+".shapeData")`;
	int $n;
	
	for ($n=0; $n < $nShapes; ++$n)
		{
		string $name = `getAttr ($def+".shapeData["+$n+"].shapeName")`;
		float $len = `getAttr ($def+".shapeData["+$n+"].shapeLength")`;
		int $bActive = `getAttr ($def+".shapeData["+$n+"].shapeActive")`;
		
		if ($bActive)
			{
			string $label = (($n+1)+". "+$name+" ["+$len+"]") ;
			textScrollList -e -append $label tslShapes ;
			}
		}
		
}


// --------------------------------------------------------------------------

// --------------------------------------------------------------------------
//	Real Worker Procs
// --------------------------------------------------------------------------

// --------------------------------------------------------------------------

/*
 * cMS_makeSpline() - Makes a muscle spline rig
 *
 */
global proc string cMS_makeSpline(string $baseName, int $nControls, string $controlType, int $detail,
			int $nRead, string $readType, string $ctrls[], string $reads[], int $bConstrainMid
			)
{
	int $i;
	clear $ctrls ;
	clear $reads ;
	
	string $zero[] ;
	clear $zero ;
	string $cons[] ;
	clear $cons ;

	$baseName = capitalizeString($baseName) ;

	if (objExists("setMUSCLERIGS") != true)
		sets -em -n "setMUSCLERIGS" ;

	string $setRig = ("set"+$baseName+"RIG") ;
	if (objExists($setRig) != true)
		{
		sets -em -n $setRig ;
		sets -in "setMUSCLERIGS" $setRig ;
		}
	


	
	if (objExists("cMuscleSpline"+$baseName) || objExists("grp"+$baseName+"RIG"))
		{
		string $msg = (uiRes("m_cMuscleSplineUI.kConfirmMuscleSplineAlreadyExistMsg"));
		$msg = `format -stringArg $baseName $msg`;
		confirmDialog 
			-t (uiRes("m_cMuscleSplineUI.kConfirmMuscleSplineAlreadyExist"))
			-m $msg
			-ma "left"
			-button (uiRes("m_cMuscleSplineUI.kOK4"))
			;
		string $msg = (uiRes("m_cMuscleSplineUI.kMuscleSplineAlreadyExist"));
		$msg = `format -stringArg $baseName $msg`;
		error -sl 0 ($msg) ;	
		}
	
	// Make master grps
	string $grpMain = `group -em -w -n ("grp"+$baseName+"RIG")` ;
	sets -in $setRig $grpMain ;
	

	// And spline
	string $spline = `createNode "cMuscleSpline" -n ("cMuscleSpline"+$baseName+"Shape")`;
	// Lock Label Attrs
	setAttr -lock 1 ($spline+".DISPLAY") ;
	setAttr -lock 1 ($spline+".TANGENTS") ;
	setAttr -lock 1 ($spline+".LENGTH") ;
	string $xforms[] = `listRelatives -parent $spline` ;
	string $xform = $xforms[0] ;
	parent $xform $grpMain ;
	setAttr ($xform+".inheritsTransform") 0 ;
	setAttr -l 1 -k 0 ($xform+".tx") ;
	setAttr -l 1 -k 0 ($xform+".ty") ;
	setAttr -l 1 -k 0 ($xform+".tz") ;
	setAttr -l 1 -k 0 ($xform+".rx") ;
	setAttr -l 1 -k 0 ($xform+".ry") ;
	setAttr -l 1 -k 0 ($xform+".rz") ;
	setAttr -l 1 -k 0 ($xform+".sx") ;
	setAttr -l 1 -k 0 ($xform+".sy") ;
	setAttr -l 1 -k 0 ($xform+".sz") ;
	connectAttr -f ("time1.outTime") ($spline+".inTime") ;
	// Make these attrs nicely viewable by the user in the channel box.
	addAttr -ln "curLen" -k 1 $spline ;
	addAttr -ln "pctSquash" -k 1 $spline ;
	addAttr -ln "pctStretch" -k 1 $spline ;
	connectAttr -f ($spline+".outLen") ($spline+".curLen") ;
	connectAttr -f ($spline+".outPctSquash") ($spline+".pctSquash") ;
	connectAttr -f ($spline+".outPctStretch") ($spline+".pctStretch") ;
	sets -in $setRig $spline ;

		
	string $grpCtrls = `group -em -w -n ("grp"+$baseName+"CONTROLS")` ;
	parent $grpCtrls $grpMain ;
	setAttr ($grpCtrls+".inheritsTransform") 1 ;
	setAttr -l 1 -k 0 ($grpCtrls+".tx") ;
	setAttr -l 1 -k 0 ($grpCtrls+".ty") ;
	setAttr -l 1 -k 0 ($grpCtrls+".tz") ;
	setAttr -l 1 -k 0 ($grpCtrls+".rx") ;
	setAttr -l 1 -k 0 ($grpCtrls+".ry") ;
	setAttr -l 1 -k 0 ($grpCtrls+".rz") ;
	setAttr -l 1 -k 0 ($grpCtrls+".sx") ;
	setAttr -l 1 -k 0 ($grpCtrls+".sy") ;
	setAttr -l 1 -k 0 ($grpCtrls+".sz") ;
	sets -in $setRig $grpCtrls ;

	
	string $grpDriven = `group -em -w -n ("grp"+$baseName+"DRIVEN")` ;
	parent $grpDriven $grpMain ;
	setAttr ($grpDriven+".inheritsTransform") 0 ;
	setAttr -l 1 -k 0 ($grpDriven+".tx") ;
	setAttr -l 1 -k 0 ($grpDriven+".ty") ;
	setAttr -l 1 -k 0 ($grpDriven+".tz") ;
	setAttr -l 1 -k 0 ($grpDriven+".rx") ;
	setAttr -l 1 -k 0 ($grpDriven+".ry") ;
	setAttr -l 1 -k 0 ($grpDriven+".rz") ;
	setAttr -l 1 -k 0 ($grpDriven+".sx") ;
	setAttr -l 1 -k 0 ($grpDriven+".sy") ;
	setAttr -l 1 -k 0 ($grpDriven+".sz") ;
	sets -in $setRig $grpDriven ;


	
	// Now make the controls
	//
	for ($i=0; $i < $nControls; ++$i)
		{
		string $c[] ;
		string $name = ("iControl"+$baseName+($i+1)) ;
		
		switch ($controlType)
			{
			case "cube":
				$ctrls[$i] = `curve -d 1 -p -0.25 0.25 0.25 -p 0.25 0.25 0.25 -p 0.25 0.25 -0.25 -p -0.25 0.25 -0.25 -p -0.25 0.25 0.25 -p -0.25 -0.25 0.25 -p -0.25 -0.25 -0.25 -p 0.25 -0.25 -0.25 -p 0.25 -0.25 0.25 -p -0.25 -0.25 0.25 -p 0.25 -0.25 0.25 -p 0.25 0.25 0.25 -p 0.25 0.25 -0.25 -p 0.25 -0.25 -0.25 -p -0.25 -0.25 -0.25 -p -0.25 0.25 -0.25 -k 0 -k 1 -k 2 -k 3 -k 4 -k 5 -k 6 -k 7 -k 8 -k 9 -k 10 -k 11 -k 12 -k 13 -k 14 -k 15 -n $name`;
				break ;
				
			case "circleY":
				$c = `circle -c 0 0 0 -nr 0 1 0 -sw 360 -r 0.25 -d 3 -ut 0 -tol 0.01 -s 8 -ch 0 -n $name` ;
				$ctrls[$i] = $c[0]; 
				break ;


			case "null":
			default:
				$ctrls[$i] = `group -em -w -n $name`;
				break ;
			}
			
		xform -a -ws -t 0 $i 0 $ctrls[$i] ;		// Place vertically
		
		// Make a ZERO grp
		$zero[$i] = `group -em -w -n ("grpIControl"+$baseName+($i+1)+"ZERO")` ;
		xform -a -ws -t 0 $i 0 $zero[$i] ;
		// Make a Cons grp
		$cons[$i] = `group -em -w -n ("grpIControl"+$baseName+($i+1)+"Cons")` ;
		xform -a -ws -t 0 $i 0 $cons[$i] ;
		
		// Parent stuff up.
		parent $zero[$i] $grpCtrls ;
		parent $cons[$i] $zero[$i] ;
		parent $ctrls[$i] $cons[$i] ;
		
		sets -in $setRig  $zero[$i] $cons[$i] $ctrls[$i] ;

		
		// Color pretty....
		setAttr ($ctrls[$i]+".overrideEnabled") 1;		// on
		setAttr ($ctrls[$i]+".overrideColor") 17 ;		// yellow

		// Make middle ctrls jiggle by default.
		float $jiggle = 1.0 ;
		if ($i==0 || $i == $nControls-1)
			$jiggle = 0.0 ;

		addAttr -ln "tangentLength" -sn "tanlen" -min 0.0 -dv 1.0 -k 1 $ctrls[$i] ;
		addAttr -ln "jiggle" -sn "jig" -dv $jiggle -k 1 $ctrls[$i] ;
		addAttr -ln "jiggleX" -sn "jigx" -dv $jiggle -k 1 $ctrls[$i] ;
		addAttr -ln "jiggleY" -sn "jigy" -dv (0.25*$jiggle) -k 1 $ctrls[$i] ;
		addAttr -ln "jiggleZ" -sn "jigz" -dv $jiggle -k 1 $ctrls[$i] ;
		addAttr -ln "jiggleImpact" -sn "jigimp" -dv (0.5*$jiggle) -k 1 $ctrls[$i] ;
		addAttr -ln "jiggleImpactStart" -sn "jigimpst" -dv 1000 -k 1 $ctrls[$i] ;
		addAttr -ln "jiggleImpactStop" -sn "jigimpsp" -dv 0.001 -k 1 $ctrls[$i] ;
		addAttr -ln "cycle" -sn "cyc" -min 1.0 -dv 12.0 -k 1 $ctrls[$i] ;
		addAttr -ln "rest" -sn "rst" -min 1.0 -dv 24.0 -k 1 $ctrls[$i] ;

		setAttr -l 1 -k 0 ($ctrls[$i]+".sx") ;
		setAttr -l 1 -k 0 ($ctrls[$i]+".sy") ;
		setAttr -l 1 -k 0 ($ctrls[$i]+".sz") ;
		setAttr -l 1 -k 0 ($ctrls[$i]+".v") ;

		
		// And connect in
		connectAttr -f ($ctrls[$i]+".worldMatrix") ($spline+".controlData["+$i+"].insertMatrix") ;
		connectAttr -f ($ctrls[$i]+".tangentLength") ($spline+".controlData["+$i+"].tangentLength") ;
		connectAttr -f ($ctrls[$i]+".jiggle") ($spline+".controlData["+$i+"].jiggle") ;
		connectAttr -f ($ctrls[$i]+".jiggleX") ($spline+".controlData["+$i+"].jiggleX") ;
		connectAttr -f ($ctrls[$i]+".jiggleY") ($spline+".controlData["+$i+"].jiggleY") ;
		connectAttr -f ($ctrls[$i]+".jiggleZ") ($spline+".controlData["+$i+"].jiggleZ") ;
		connectAttr -f ($ctrls[$i]+".jiggleImpact") ($spline+".controlData["+$i+"].jiggleImpact") ;
		connectAttr -f ($ctrls[$i]+".jiggleImpactStart") ($spline+".controlData["+$i+"].jiggleImpactStart") ;
		connectAttr -f ($ctrls[$i]+".jiggleImpactStop") ($spline+".controlData["+$i+"].jiggleImpactStop") ;
		connectAttr -f ($ctrls[$i]+".cycle") ($spline+".controlData["+$i+"].cycle") ;
		connectAttr -f ($ctrls[$i]+".rest") ($spline+".controlData["+$i+"].rest") ;
		
		} // end of each ctrl
	
		
	string $blend = "" ;
		
	// For each in-between control we will use the constraint group above it and constrain it 
	//	to the top and bottom movers....
	//
	for ($i=1; $bConstrainMid == 1 && $i < $nControls-1; ++$i)
		{
		float $pct = 1.0 * $i / ($nControls-1.0) ;	// What pct weight to the last top one?
		
		
		// Point is just pct inbetween
		pointConstraint -w (1.0-$pct) $ctrls[0] $cons[$i] ; 
		pointConstraint -w ($pct) $ctrls[$nControls-1] $cons[$i] ;
		
		// For aim we want to balance an aim fwd and back...to do that we need to 
		// use a grp fwd and a grp back, then orient between those the right amt.
		// Since we can't mix an aim with a +Y and an aim with a -Y.
		//
		string $grpAimFwd = `group -em -w -n ("grpAimFwd"+$baseName+($i+1))` ;
		cMBld_snap($ctrls[$i], $grpAimFwd, 1, 1 ) ; 
		string $grpAimBack = `group -em -w -n ("grpAimBack"+$baseName+($i+1))` ;
		cMBld_snap($ctrls[$i], $grpAimBack, 1, 1) ; 
		sets -in $setRig $zero[$i] $grpAimFwd $grpAimBack ;
		
		// Make em do right thing
		string $aCons1[] = `aimConstraint -w 1 -aim 0 1 0 -u 1 0 0 -wu 1 0 0 -wut "objectrotation" -wuo $ctrls[($nControls-1)] $ctrls[($nControls-1)] $grpAimFwd` ;
	    string $aCons2[] = `aimConstraint -w 1 -aim 0 -1 0 -u 1 0 0 -wu 1 0 0 -wut "objectrotation" -wuo $ctrls[0] $ctrls[0] $grpAimBack` ;
		sets -in $setRig $aCons1[0] $aCons2[0] ;

		// Now drive the aims with the up info...
		if ($i == 1)
			{
				// Only have to create the first time around....
			if (objExists($spline+".upAxis") != true)
				addAttr -at "enum" -ln ("upAxis") -enumName "X-Axis=0:Z-Axis=1" -k 1 $spline ;
			$blend = `createNode "blendColors" -n ("blendColorsMuscleSplineAim"+$baseName)` ;
			connectAttr -f ($spline+".upAxis") ($blend+".blender") ;
			setAttr -type "float3" ($blend+".color1") 0 0 1 ;
			setAttr -type "float3" ($blend+".color2") 1 0 0 ;
			sets -in $setRig $blend ;
			}
		connectAttr -f ($blend+".output") ($aCons1[0]+".upVector") ;
		connectAttr -f ($blend+".output") ($aCons1[0]+".worldUpVector") ;
		connectAttr -f ($blend+".output") ($aCons2[0]+".upVector") ;
		connectAttr -f ($blend+".output") ($aCons2[0]+".worldUpVector") ;
		
		// We also have to do a similar pt contraint on each aim
		string $pConsFwd[] = `pointConstraint -w (1.0-$pct) $ctrls[0] $grpAimFwd` ; 
		string $pConsFwd[] = `pointConstraint -w ($pct) $ctrls[$nControls-1] $grpAimFwd` ;
		string $pConsBack[] = `pointConstraint -w (1.0-$pct) $ctrls[0] $grpAimBack` ; 
		string $pConsBack[] = `pointConstraint -w ($pct) $ctrls[$nControls-1] $grpAimBack` ;
		sets -in $setRig $pConsFwd[0] $pConsBack[0] ;
		
		
		// Now set up orient
		string $oCons[] ;
		$oCons = `orientConstraint -w (1.0-$pct) $grpAimBack $cons[$i]` ;
//		setAttr ($oCons[0]+".interpType") 0 ;	// No-Flip orient constraint mode...
		setAttr ($oCons[0]+".interpType") 2 ;	// Shortest orient constraint mode...
		$oCons = `orientConstraint -w ($pct) $grpAimFwd $cons[$i]` ;		
//		setAttr ($oCons[0]+".interpType") 0 ;	// No-Flip orient constraint mode...
		setAttr ($oCons[0]+".interpType") 2 ;	// Shortest orient constraint mode...
		sets -in $setRig $oCons[0] ;

		
		// Make ZERO grps for aims, at end so zero at right spot.
		string $grpAimFwdZERO = `group -em -w -n ("grpAimFwd"+$baseName+($i+1)+"ZERO")` ;
		string $grpAimBackZERO = `group -em -w -n ("grpAimBack"+$baseName+($i+1)+"ZERO")` ;
		cMBld_snap($grpAimFwd, $grpAimFwdZERO, 1, 1 ) ; 
		cMBld_snap($grpAimBack, $grpAimBackZERO, 1, 1) ; 
		sets -in $setRig $grpAimFwdZERO $grpAimBackZERO ;

		// Parent these to right place.
		parent $grpAimFwdZERO $zero[$i] ;
		parent $grpAimFwd $grpAimFwdZERO ;
		parent $grpAimBackZERO $zero[$i] ;
		parent $grpAimBack $grpAimBackZERO ;
		



		}

		
		
	// Now make the driven stuff
	//
	for ($i=0; $i < $nRead; ++$i)
		{
		float $u = $i / ($nRead-1.0) ;
		string $name = ("driven"+$baseName+($i+1)) ;
		
		switch ($readType)
			{
			case "joint":
				$reads[$i] = `joint -n $name` ;
				break ;

			case "circleY":
				$c = `circle -c 0 0 0 -nr 0 1 0 -sw 360 -r 1 -d 3 -ut 0 -tol 0.01 -s $detail -ch 0 -n $name` ;
				$reads[$i] = $c[0]; 
				break ;
				
			case "null":
			default:
				$reads[$i] = `group -em -w -n $name`;
				break ;
			
			}
		
		select -cl ;
		addAttr -ln "uValue" -min 0.0 -max 1.0 -dv $u -k 1 $reads[$i] ;
		parent $reads[$i] $grpDriven ;
		
		sets -in $setRig $reads[$i] ;


		// And connect in		
		connectAttr -f ($reads[$i]+".uValue") ($spline+".readData["+$i+"].readU") ;
		connectAttr -f ($reads[$i]+".rotateOrder") ($spline+".readData["+$i+"].readRotOrder") ;
		connectAttr -f ($spline+".outputData["+$i+"].outTranslate") ($reads[$i]+".translate") ;
		connectAttr -f ($spline+".outputData["+$i+"].outRotate") ($reads[$i]+".rotate") ;
		}

		
		
	float $len = `getAttr ($spline+".outLen")`;	// Get current length.
	setAttr ($spline+".lenDefault") ($len) ;	// And make some nice settings
	setAttr ($spline+".lenSquash") ($len*0.5) ;	
	setAttr ($spline+".lenStretch") ($len*2.0) ;
	
	
	select -r $grpMain ;
	return $spline ;
}


// --------------------------------------------------------------------------

/*
 * cMS_makeSplineDeformer() - Makes a muscle spline Deformer rig
 *
 */
global proc string cMS_makeSplineDeformer(string $baseName, int $nControls, string $controlType, string $ctrls[], 
			string $geo, int $makeMuscle
			)
{
	int $i ;
	string $reads[] ;
	
	$baseName = capitalizeString($baseName) ;
	
	if (objExists("setMUSCLERIGS") != true)
		sets -em -n "setMUSCLERIGS" ;

	string $setRig = ("set"+$baseName+"RIG") ;
	if (objExists($setRig) != true)
		{
		sets -em -n $setRig ;
		sets -in "setMUSCLERIGS" $setRig ;
		}
	

		// First make actual spline rig...with constraining on mid movers
	string $spline = cMS_makeSpline($baseName, $nControls, $controlType, 8, 0, "null", $ctrls, $reads, 1) ;
	
	string $grpMains[] = `ls -sl`;
	string $grpMain = $grpMains[0] ;

	// Apply the deformer	
	select -r $geo ;
	string $defs[] = `deformer -type "cMuscleSplineDeformer" $geo` ;
	string $def = $defs[0] ;
	setAttr -lock 1 ($def+".STATE") ;	// Locl the label attrs.
	setAttr -lock 1 ($def+".SHAPING") ;
	setAttr -lock 1 ($def+".SQUASH") ;
	setAttr -lock 1 ($def+".STRETCH") ;

	// For some reason maya wigs out with edit membership when this is done...
	//		which causes reset base and stuff to break...so don't add deformers to set.
	//
	// sets -in $setRig $def ;

	// Now position the controls somewhere reasonable....
	float $posData[6] = `cMuscleSplineBind -endpts $def` ;		//	Where are good start/end pts?


	
	// Mover ZERO groups for nicer behavior.  
	string $parents[] ;
	$parents = `listRelatives -parent $ctrls[0]` ;	// This will be cons grp
	$parents = `listRelatives -parent $parents` ;	// This will be ZERO grp
	string $zeroStart = $parents[0] ;

	$parents = `listRelatives -parent $ctrls[$nControls-1]` ;	// This will be cons grp
	$parents = `listRelatives -parent $parents` ;				// This will be ZERO grp
	string $zeroEnd = $parents[0] ;
	
	xform -a -ws -t $posData[0] $posData[1] $posData[2] $zeroStart ; 	
	xform -a -ws -t $posData[3] $posData[4] $posData[5] $zeroEnd ; 	

		
	// Aim each control to the other and then delete the constraint, so they are oriented right.
	string $tempCons[] ;
	$tempCons = `aimConstraint -w 1 -aim 0 1 0 -u 1 0 0 -wu 1 0 0 -wut "objectrotation" -wuo $ctrls[($nControls-1)] $ctrls[($nControls-1)] $zeroStart` ;
	delete $tempCons ; 	
	$tempCons = `aimConstraint -w 1 -aim 0 -1 0 -u 1 0 0 -wu 1 0 0 -wut "objectrotation" -wuo $ctrls[0] $ctrls[0] $zeroEnd` ;
	delete $tempCons ; 	

	
	
	// Now since we've got everything at the right spot....and probably with new lengths...
	// Reset some of the spline params nicer....
	// 	
	float $len = `getAttr ($spline+".outLen")`;	// Get current length.
	setAttr ($spline+".lenDefault") ($len) ;	// And make some nice settings
	setAttr ($spline+".lenSquash") ($len*0.5) ;	
	setAttr ($spline+".lenStretch") ($len*2.0) ;
	

	
	// Now we have everything in the right spot...
	// So let's connect all the data properly into the deformer 
	for ($i=0; $i < $nControls; ++$i)
		{
	    connectAttr -f ($spline+".outControlData["+$i+"]") ($def+".controlData["+$i+"]") ;
		}
	connectAttr -f ($spline+".outLen") ($def+".curLen") ;
	connectAttr -f ($spline+".outPctSquash") ($def+".pctSquash") ;
	connectAttr -f ($spline+".outPctStretch") ($def+".pctStretch") ;
	connectAttr -f ($spline+".userScale") ($def+".userScale") ;

	cMS_resetSplineDefBasePose($def) ;		// And set up base and binding too!

	
	// Parent GEO somewhere nice too.
	string $grpGEO = `group -em -w -n ("grp"+$baseName+"GEO")` ;
	parent $grpGEO $grpMain ;
	setAttr ($grpGEO+".inheritsTransform") 0 ;
	setAttr -l 1 -k 0 ($grpGEO+".tx") ;
	setAttr -l 1 -k 0 ($grpGEO+".ty") ;
	setAttr -l 1 -k 0 ($grpGEO+".tz") ;
	setAttr -l 1 -k 0 ($grpGEO+".rx") ;
	setAttr -l 1 -k 0 ($grpGEO+".ry") ;
	setAttr -l 1 -k 0 ($grpGEO+".rz") ;
	setAttr -l 1 -k 0 ($grpGEO+".sx") ;
	setAttr -l 1 -k 0 ($grpGEO+".sy") ;
	setAttr -l 1 -k 0 ($grpGEO+".sz") ;
	// Lock GEO down too...
	parent $geo $grpGEO ;
	setAttr -l 1 -k 1 ($geo+".tx") ;
	setAttr -l 1 -k 1 ($geo+".ty") ;
	setAttr -l 1 -k 1 ($geo+".tz") ;
	setAttr -l 1 -k 1 ($geo+".rx") ;
	setAttr -l 1 -k 1 ($geo+".ry") ;
	setAttr -l 1 -k 1 ($geo+".rz") ;
	setAttr -l 1 -k 1 ($geo+".sx") ;
	setAttr -l 1 -k 1 ($geo+".sy") ;
	setAttr -l 1 -k 1 ($geo+".sz") ;
	sets -in $setRig $grpGEO ;

	
	if (objExists("grpMUSCLES") != true)
		{
		group -em -w -n "grpMUSCLES" ;
		}
	parent $grpMain "grpMUSCLES" ;
	
	if ($makeMuscle)
		{   
		select -r $geo ;
		string $mOs[] = cMuscle_makeMuscle(0) ;
		string $mO = $mOs[0] ;
		}

	
	select -r $geo $def ;
	return $def ;	
}

// --------------------------------------------------------------------------

/*
 * cMS_resetSplineDefBasePose() - Given a cMuscleSplineDeformer, assuming
 *		it already has connections into it, this will connect and then disconnect
 *		them into the "Base" attributes to reset the base pose for the deformer.
 *		This will also re-perform a bind to ensure any geo is also then re-weighted 
 *		from the new base positions.
 */
global proc cMS_resetSplineDefBasePose(string $def)
{
	int $nControls = `getAttr -size ($def+".controlData")`;	
	int $i ;
	
	for ($i=0; $i < $nControls; ++$i)
		{
			// What is connected currently?
		string $cons[] = `listConnections -s 1 -d 0 -p 1 -scn 1 ($def+".controlData["+$i+"]")` ;
		
			// And then dup same connection into base, and then break connection.
		connectAttr -f $cons[0] ($def+".controlDataBase["+$i+"]") ;
		disconnectAttr $cons[0] ($def+".controlDataBase["+$i+"]") ;	// Then break base connection!
		}
		
	cMuscleSplineBind -bind $def ;		// And redo bind.
	
}

// --------------------------------------------------------------------------

/*
 * cMS_getSplineFromSplineDef() - Gets the spline that is driving the spline def. 
 */
global proc string cMS_getSplineFromSplineDef(string $def)
{
	string $spline = "" ;
	
	if ($def == "" || objExists($def) != true)
		return $spline ;
	
	// Get the spline node connected into the deformer...
	string $cons[] = `listConnections -s 1 -d 0 -p 0 -scn 1 ($def+".controlData")` ;
	$spline = $cons[0] ;
	
	return $spline ;
}

// --------------------------------------------------------------------------

/*
 * cMS_getControlsFromSplineDef() - Gets the controls from the spline def.
 */
global proc string[] cMS_getControlsFromSplineDef(string $def)
{
	string $ctrls[] ;
	clear $ctrls ;
	
	if ($def == "" || objExists($def) != true)
		return $ctrls ;
	
	string $spline = cMS_getSplineFromSplineDef($def) ;
	
	if ($spline == "" || objExists($spline) != true)
		return $ctrls ;
	
	// Now see what is driving the spline.
	$ctrls = `listConnections -s 1 -d 0 -p 0 -scn 1 ($spline+".controlData")` ;
	$ctrls = stringArrayRemoveDuplicates( $ctrls ) ;
		
	return $ctrls ;
}


// --------------------------------------------------------------------------

// --------------------------------------------------------------------------
//	Shape Procs
// --------------------------------------------------------------------------

// --------------------------------------------------------------------------

/*
 * cMS_storeSplineDefShape() - Actually takes a target and stores it
 *		on the deformer as a new custom shape
 */
global proc cMS_storeSplineDefShape(string $def, string $tgt, int $nShapeIdx, string $name )
{
	float $pctSquash = `getAttr ($def+".pctSquash")` ;		// What is current length?
	float $pctStretch = `getAttr ($def+".pctStretch")` ;		// What is current length?
	float $normalLen = 0.0 ;
	
	// Figure a -1 to 0 to 1 range from squash to stretch.
	if ($pctSquash > 0.0)
		$normalLen = -1.0 * $pctSquash ;
	else
		$normalLen = $pctStretch ;
	
	
	// Disable shaping
	setAttr ($def+".enableShaping") 0 ;
	
	setAttr -type "string" ($def+".shapeData["+$nShapeIdx+"].shapeName") $name ;	
	setAttr ($def+".shapeData["+$nShapeIdx+"].shapeLength") $normalLen ;
	setAttr ($def+".shapeData["+$nShapeIdx+"].shapeActive") 1 ;

	// And now do real work of storing delta's the right way....
	cMuscleSplineBind -si $nShapeIdx -tgt $tgt $def ; 	
		
	// Enable shaping
	setAttr ($def+".enableShaping") 1 ;
	
	// Look at parent of the target shape
	string $pars[] = `listRelatives -parent $tgt` ;
	// And delete target now!
	if ($pars[0] != "")
		delete $pars[0] ;
	   
	// Show main geo again.
	string $geos[] = `deformer -q -geometry $def` ;		// get def shape
	$geos = `listRelatives -parent $geos` ;				// get def xform
	catch(`setAttr ($geos[0]+".v") 1`);

	// And right mode
	changeSelectMode -object ;
	
	if (size($geos) > 0 )
		select -r $geos ;
}


// --------------------------------------------------------------------------

/*
 * cMS_prepForShapeSculpt() - Dup geo and make nice mtl etc so can sculpt
 */
global proc cMS_prepForShapeSculpt()
{
    string $geo = `textField -q -tx tfGeoShape` ;
    if ($geo == "")
    	{
    	warning -sl 0 (uiRes("m_cMuscleSplineUI.kMustChooseSplineDeformerToShape")) ;
    	return ;
    	}

	string $def = `textField -q -tx tfDefShape` ;
    if ($def == "" || objExists($def) != true)
    	{
    	warning -sl 0 (uiRes("m_cMuscleSplineUI.kMustChooseSplineDeformerToShape2")) ;
    	return ;
    	}
		
    if (objExists("muscleShapeCorrectedTgt"))
    	{
    	warning -sl 0 (uiRes("m_cMuscleSplineUI.kWorkInProgressExists")) ;
    	return ;
    	}

    string $dups[] = `duplicate -rr -rc $geo` ;
    string $childs[] = `listRelatives -ni -children -type "transform" -type "joint" $dups`;
    if (size($childs) > 0)
        delete $childs ;
	
		// Delete any unneeded shape crap under this target too.
	string $mOs[] = `listRelatives -ni -shapes -type "cMuscleObject" $dups[0]` ;
	if (size($mOs) > 0)
		delete $mOs ;
    	
    string $tgt = `rename $dups[0] ("muscleShapeCorrectedTgt")`;
    cMS_assignShader($tgt) ;

	// Unlock the target.    
    setAttr -lock false ($tgt+".tx") ; setAttr -lock false ($tgt+".ty") ; setAttr -lock false ($tgt+".tz") ;
    setAttr -lock false ($tgt+".rx") ; setAttr -lock false ($tgt+".ry") ; setAttr -lock false ($tgt+".rz") ;
    setAttr -lock false ($tgt+".sx") ; setAttr -lock false ($tgt+".sy") ; setAttr -lock false ($tgt+".sz") ;

	// Show only target
    setAttr ($tgt+".v") 1 ;
    catch(`setAttr ($geo+".v") 0`);

    select -r $tgt ;
	changeSelectMode -component;
	hilite -r $tgt ;
	print (uiRes("m_cMuscleSplineUI.kReadyForSculpting")) ;
}

// --------------------------------------------------------------------------


/*
 * cMS_assignShader()
 */
global proc cMS_assignShader(string $geo)
{
	// Get shape node
    string $shapes[] = `listRelatives -shapes $geo` ;
    
    string $mat = "matMuscleShapeCorrected" ;

	// check if blendShapeShader exists
    if (objExists($mat) != true)
		{
        $mat = `shadingNode -asShader blinn`;
		$mat = `rename $mat ("matMuscleShapeCorrected")` ;

		sets -renderable true -noSurfaceShader true -empty -name ($mat+"SG") ;
		connectAttr -f ($mat+".outColor") ($mat+"SG.surfaceShader") ;
		
		float $rgb[3] = `colorSliderGrp -q -rgb csgTgtColor` ;
		setAttr ($mat+".color") -type double3 $rgb[0] $rgb[1] $rgb[2] ;
		setAttr ($mat+".specularColor") -type double3 0.2 0.2 0.2 ;
		setAttr ($mat+".reflectivity") 0.0 ;
		setAttr ($mat+".specularRollOff") 0.25 ;
		setAttr ($mat+".eccentricity") 0.60 ;
	
        }

	float $rgb[3] = `colorSliderGrp -q -rgb csgTgtColor` ;
	setAttr ($mat+".color") -type double3 $rgb[0] $rgb[1] $rgb[2] ;
		
		
	// Apply material        
    select -r $geo ;
    sets -e -forceElement ($mat+"SG");    

	
	// This doesn't work...sigh...
	// connectControl csgTgtColor ($mat+".color") ;		// Make sure control is connected to material also.
	
}


// --------------------------------------------------------------------------

/* 
 * cMS_createNewShape() - Creates a new shape
 */
global proc cMS_createNewShape()
{
    string $geo = `textField -q -tx tfGeoShape` ;
    if ($geo == "")
    	{
    	warning -sl 0 (uiRes("m_cMuscleSplineUI.kMustChooseSplineDeformerToShape3")) ;
    	return ;
    	}

	string $def = `textField -q -tx tfDefShape` ;
    if ($def == "" || objExists($def) != true)
    	{
    	warning -sl 0 (uiRes("m_cMuscleSplineUI.kMustChooseSplineDeformerToShape4")) ;
    	return ;
    	}

	string $tgt = "muscleShapeCorrectedTgt" ;
    if (objExists($tgt) != true)
    	{
    	warning -sl 0 (uiRes("m_cMuscleSplineUI.kMustSculptCorrectedShape")) ;
    	return ;
    	}
	
	string $name = "" ;
	
	string $labelOK = (uiRes("m_cMuscleSplineUI.kOK"));
	string $labelCancel = (uiRes("m_cMuscleSplineUI.kCancel"));
	string $ret = `promptDialog -t (uiRes("m_cMuscleSplineUI.kEnterShapeName"))
			-m (uiRes("m_cMuscleSplineUI.kEnterShapeNameMsg"))
			-tx "tgt"
			-ma "left"
			-button $labelOK
			-button $labelCancel
			-defaultButton $labelOK
			-cancelButton $labelCancel
			-dismissString $labelCancel
			`;
	if ($ret != $labelOK)
		return ;
	$name = `promptDialog -q -tx` ;

	if ($name == "")
		$name = "unnamed" ;

	// Find next index
	int $sIdx = cMS_nextAvailableShapeIdx($def) ;
	
	// Get the shape node of target.
	string $tgtShapes[] = `listRelatives -shapes -ni $tgt` ;
	string $tgtShape = $tgtShapes[0] ;
	

	// Now generate actual shape!
	cMS_storeSplineDefShape($def, $tgtShape, $sIdx, $name ) ;

	// Make a userdefined attr for driving the shape manually now...
	//
	addAttr -ln $name -k 1 -min 0.0 -max 1.0 $def ;
	connectAttr -f ($def+"."+$name) ($def+".shapeData["+$sIdx+"].shapeManualTrigger")  ;
	
	
	// Refresh UI
	cMS_refreshShapeList() ;
	
	string $msg = (uiRes("m_cMuscleSplineUI.kGeneratedShape"));
	$msg = `format -stringArg $name $msg`;
	print ($msg) ;
}

// --------------------------------------------------------------------------

/* 
 * cMS_editShape() - Edits a shape
 */
global proc cMS_editShape()
{
    string $geo = `textField -q -tx tfGeoShape` ;
    if ($geo == "")
    	{
    	warning -sl 0 (uiRes("m_cMuscleSplineUI.kMustChooseSplineDeformerToShape5")) ;
    	return ;
    	}

	string $def = `textField -q -tx tfDefShape` ;
    if ($def == "" || objExists($def) != true)
    	{
    	warning -sl 0 (uiRes("m_cMuscleSplineUI.kMustChooseSplineDeformerToShape6")) ;
    	return ;
    	}

	string $tgt = "muscleShapeCorrectedTgt" ;
    if (objExists($tgt) != true)
    	{
    	warning -sl 0 (uiRes("m_cMuscleSplineUI.kMustSculptCorrectedShape2")) ;
    	return ;
    	}
	
	string $name = "" ;
	
	// Find next index
	int $sIdx = -1 ;
	
	// See what is selected
	string $sels[] = `textScrollList -q -selectItem tslShapes` ;
	if (size($sels) <= 0)
		{
		warning -sl 0 (uiRes("m_cMuscleSplineUI.kMustChooseShapeFromListToEdit")) ;
		return ;	
		}
	string $sel = $sels[0] ;
	
	string $parts[] ;
	tokenize($sel, ".[]", $parts) ;		// Now divide up base on period and brackets....
	
	$sIdx = (int)$parts[0] - 1;		// First is #1.  <name> [loc]
	$name = $parts[1] ;			// next then is name.
	
	
	if ($name == "")
		$name = "unnamed" ;

	if ($sIdx < 0)
		return ;
	
	
	// Get the shape node of target.
	string $tgtShapes[] = `listRelatives -shapes -ni $tgt` ;
	string $tgtShape = $tgtShapes[0] ;
	

	// Now generate actual shape!
	cMS_storeSplineDefShape($def, $tgtShape, $sIdx, $name ) ;
	
	// Refresh UI
	cMS_refreshShapeList() ;
	
	string $msg = (uiRes("m_cMuscleSplineUI.kEditedShape"));
	$msg = `format -stringArg $name $msg`;
	print ($msg) ;
}

// --------------------------------------------------------------------------


/*
 * cMS_nextAvailableShapeIdx() - Returns the next avail shape index.
 */
global proc int cMS_nextAvailableShapeIdx(string $def)
{
	int $sIdx = -1 ;
	
	int $testIdx = 0;
	while ($sIdx < 0)
		{
		// See if the pose weight is driven...
		int $bActive = `getAttr ($def+".shapeData["+$testIdx+"].shapeActive")` ;
	
		if ($bActive)
			++$testIdx ;	// prep to try next one.
		else
			$sIdx = $testIdx ;	// Found an available pose slot!
		}

			
	return $sIdx ;
}

// --------------------------------------------------------------------------

/* 
 * cMS_renameShape() - Renames a shape
 */
global proc cMS_renameShape()
{
    string $geo = `textField -q -tx tfGeoShape` ;
    if ($geo == "")
    	{
    	warning -sl 0 (uiRes("m_cMuscleSplineUI.kMustChooseSplineDeformerToShape7")) ;
    	return ;
    	}

	string $def = `textField -q -tx tfDefShape` ;
    if ($def == "" || objExists($def) != true)
    	{
    	warning -sl 0 (uiRes("m_cMuscleSplineUI.kMustChooseSplineDeformerToShape8")) ;
    	return ;
    	}
	
	string $name = "" ;
	
	// Find next index
	int $sIdx = -1 ;
	
	// See what is selected
	string $sels[] = `textScrollList -q -selectItem tslShapes` ;
	if (size($sels) <= 0)
		{
		warning -sl 0 (uiRes("m_cMuscleSplineUI.kMustChooseShapeFromListToEdit2")) ;
		return ;	
		}
	string $sel = $sels[0] ;
	
	string $parts[] ;
	tokenize($sel, ".[]", $parts) ;		// Now divide up base on period and brackets....
	
	$sIdx = (int)$parts[0] - 1;		// First is #1.  <name> [loc]
	$name = $parts[1] ;			// next then is name.
	
	if ($sIdx < 0)
		return ;

	string $labelOK = (uiRes("m_cMuscleSplineUI.kOK2"));
	string $labelCancel = (uiRes("m_cMuscleSplineUI.kCancel2"));
	string $ret = `promptDialog -t (uiRes("m_cMuscleSplineUI.kRenameShape"))
			-m (uiRes("m_cMuscleSplineUI.kRenameShapeMsg"))
			-tx $name
			-ma "left"
			-button $labelOK
			-button $labelCancel
			-defaultButton $labelOK
			-cancelButton $labelCancel
			-dismissString $labelCancel
			`;
	if ($ret != $labelOK)
		return ;
	$name = `promptDialog -q -tx` ;
	
	if ($name == "")
		$name = "unnamed" ;

	// Get old
	string $oldName = `getAttr ($def+".shapeData["+$sIdx+"].shapeName")` ;
	// Set new
	setAttr -type "string" ($def+".shapeData["+$sIdx+"].shapeName") $name ;
	// Rename attr
	if (objExists($def+"."+$oldName)) {
		renameAttr ($def+"."+$oldName) $name ;	
		}
	
	
	cMS_refreshShapeList() ;

	string $msg = (uiRes("m_cMuscleSplineUI.kSetShapeName"));
	$msg = `format -stringArg $name $msg`;
	print ($msg) ;	
	
}

// --------------------------------------------------------------------------


/* 
 * cMS_deleteShape() - Deletes a shape
 */
global proc cMS_deleteShape()
{
    string $geo = `textField -q -tx tfGeoShape` ;
    if ($geo == "")
    	{
    	warning -sl 0 (uiRes("m_cMuscleSplineUI.kMustChooseSplineDeformerToShape9")) ;
    	return ;
    	}

	string $def = `textField -q -tx tfDefShape` ;
    if ($def == "" || objExists($def) != true)
    	{
    	warning -sl 0 (uiRes("m_cMuscleSplineUI.kMustChooseSplineDeformerToShape10")) ;
    	return ;
    	}
	
	string $name = "" ;
	
	// Find next index
	int $sIdx = -1 ;
	
	// See what is selected
	string $sels[] = `textScrollList -q -selectItem tslShapes` ;
	if (size($sels) <= 0)
		{
		warning -sl 0 (uiRes("m_cMuscleSplineUI.kMustChooseShapeFromListToEdit3")) ;
		return ;	
		}
	string $sel = $sels[0] ;
	
	string $parts[] ;
	tokenize($sel, ".[]", $parts) ;		// Now divide up base on period and brackets....
	
	$sIdx = (int)$parts[0] - 1;		// First is #1.  <name> [loc]
	$name = $parts[1] ;			// next then is name.
	
	if ($sIdx < 0)
		return ;

	string $msg = (uiRes("m_cMuscleSplineUI.kDeleteShapeMsg"));
	$msg = `format -stringArg ($sIdx+1) -stringArg $name $msg`;
	string $labelOK = (uiRes("m_cMuscleSplineUI.kOK3"));
	string $labelCancel = (uiRes("m_cMuscleSplineUI.kCancel3"));
	string $ret = `confirmDialog -t (uiRes("m_cMuscleSplineUI.kDeleteShape"))
		-m ($msg)
		-ma "left"
		-button $labelOK
		-button $labelCancel
		-defaultButton $labelCancel
		-cancelButton $labelCancel
		-dismissString $labelCancel
		`;
	if ($ret != $labelOK)
		return ;

	// Get old name
	string $oldName = `getAttr ($def+".shapeData["+$sIdx+"].shapeName")` ;
	// Set name and active value properly.
	setAttr -type "string" ($def+".shapeData["+$sIdx+"].shapeName") "DELETED" ;
	setAttr ($def+".shapeData["+$sIdx+"].shapeActive") 0 ;
	// Delete attr
	if (objExists($def+"."+$oldName)) {
		deleteAttr ($def+"."+$oldName) ;	
		}
	
	
	cMS_refreshShapeList() ;
	
	string $msg = (uiRes("m_cMuscleSplineUI.kDeletedShape"));
	$msg = `format -stringArg ($sIdx+1) -stringArg $name $msg`;
	print ($msg) ;	
	
}

// --------------------------------------------------------------------------

// --------------------------------------------------------------------------
//	Jiggle Cache Procs
// --------------------------------------------------------------------------

// --------------------------------------------------------------------------


/*
 * cMS_delJiggleCacheUI() - Little window to choose what node cache frames to delete
 */
global proc cMS_delJiggleCacheUI()
{
    if (`window -ex cMuscleDeleteJiggleCacheWin`)
        {
        showWindow cMuscleDeleteJiggleCacheWin ;
		return ;
		}
	
	window -w 260 
		-h 90 
		-s true 
		-t (uiRes("m_cMuscleSplineUI.kWindowTitleDeleteJiggleCache")) cMuscleDeleteJiggleCacheWin ;
    formLayout mainForm ;
	
	int $min = `playbackOptions -q -min` ;
	int $max = `playbackOptions -q -max` ;
	
	
 	intFieldGrp -numberOfFields 1
 			-label (uiRes("m_cMuscleSplineUI.kDeleteStart"))
			-cw2 50 100 
			-value1 $min ifgDelStart ;

 	intFieldGrp -numberOfFields 1
 			-label (uiRes("m_cMuscleSplineUI.kDeleteEnd"))
			-cw2 50 100 
			-value1 $max ifgDelEnd ;
			
    	
	button -l (uiRes("m_cMuscleSplineUI.kDeleteJiggleCache")) 
		-c ("cMS_delJiggleCache();") 
		-ann (uiRes("m_cMuscleSplineUI.kDeleteJiggleCacheAnnot")) btnDelCache ; 

	formLayout -e
		-af ifgDelStart "top" 5 
		-an ifgDelStart "bottom" 
		-af ifgDelStart "left" 5 
		-ap ifgDelStart "right" 0 50 
		
		-af ifgDelEnd "top" 5 
		-an ifgDelEnd "bottom" 
		-ap ifgDelEnd "left" 0 50
		-af ifgDelEnd "right" 5 

		-ac btnDelCache "top" 5 ifgDelStart  
		-an btnDelCache "bottom" 
		-af btnDelCache "left" 5
		-af btnDelCache "right" 5 

		mainForm ;
			
			

	showWindow cMuscleDeleteJiggleCacheWin;

	
}

// --------------------------------------------------------------------------

/*
 * cMS_delJiggleCache() - Deletes jiggle spline cache 
 */
global proc cMS_delJiggleCache()
{
	int $min = `intFieldGrp -q -v1 ifgDelStart` ;	
	int $max = `intFieldGrp -q -v1 ifgDelEnd` ;

	if ($min > $max)
		{
		error -sl 0 (uiRes("m_cMuscleSplineUI.kStartFrameLowerThanEndFrame"));
		}
	
    string $objs[] = `ls -sl`;
    
    if (size($objs) <= 0)
        error -sl 0 (uiRes("m_cMuscleSplineUI.kMustSelectMuscleSystemDeformer")) ;

	// Look for a cMuscleSplineDeformer in what is chosen...
    string $hist[] = `listHistory -pdo true -il 1 $objs`;
    string $mSDs[] = `ls -type "cMuscleSplineDeformer" $hist` ;
	string $mSD;
    string $mSTs[] = `ls -type "cMuscleStretch" $hist` ;
	string $mST;
    string $mCRs[] = `ls -type "cMuscleCreator" $hist` ;
	string $mCR;
    
    $mSDs = stringArrayRemoveDuplicates($mSDs) ;
    $mSTs = stringArrayRemoveDuplicates($mSTs) ;
    $mCRs = stringArrayRemoveDuplicates($mCRs) ;
    
    if (size($mSDs) + size($mSTs)  + size($mCRs) <= 0)
        error -sl 0 (uiRes("m_cMuscleSplineUI.kMustSelectMuscleObject")) ;
	
	waitCursor -state on ;
	
	int $t ;
	for ($t=$min; $t <= $max; ++$t)
		{
		for ($mSD in $mSDs)
			{
			string $spline = cMS_getSplineFromSplineDef($mSD) ;	// Get spline node where cache is actually stored.

			// Blow away each cache frame data	 ADD MAX_NEG_FRAMES which is 1024
			removeMultiInstance ($spline+".jiggleFrame["+($t+1024)+"]") ;
			}
		for ($mST in $mSTs)
			{
			// Blow away each cache frame data	 ADD MAX_NEG_FRAMES which is 1024
			removeMultiInstance ($mST+".forceStart["+($t+1024)+"]") ;
			removeMultiInstance ($mST+".forceMid["+($t+1024)+"]") ;
			removeMultiInstance ($mST+".forceEnd["+($t+1024)+"]") ;
			}
		for ($mCR in $mCRs)
			{
			// Blow away each cache frame data	 ADD MAX_NEG_FRAMES which is 1024
			removeMultiInstance ($mCR+".jiggleFrame["+($t+1024)+"]") ;
			}

		}
	refresh ;
	waitCursor -state off ;
		
	// Blow away the window
	deleteUI -wnd cMuscleDeleteJiggleCacheWin ;
}

// --------------------------------------------------------------------------


