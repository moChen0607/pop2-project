// Copyright (C) 1997-2014 Autodesk, Inc., and/or its licensors.
// All rights reserved.
//
// The coded instructions, statements, computer programs, and/or related
// material (collectively the "Data") in these files contain unpublished
// information proprietary to Autodesk, Inc. ("Autodesk") and/or its licensors,
// which is protected by U.S. and Canadian federal copyright law and by
// international treaties.
//
// The Data is provided for use exclusively by You. You have the right to use,
// modify, and incorporate this Data into other products for purposes authorized 
// by the Autodesk software license agreement, without fee.
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND. AUTODESK
// DOES NOT MAKE AND HEREBY DISCLAIMS ANY EXPRESS OR IMPLIED WARRANTIES
// INCLUDING, BUT NOT LIMITED TO, THE WARRANTIES OF NON-INFRINGEMENT,
// MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE, OR ARISING FROM A COURSE 
// OF DEALING, USAGE, OR TRADE PRACTICE. IN NO EVENT WILL AUTODESK AND/OR ITS
// LICENSORS BE LIABLE FOR ANY LOST REVENUES, DATA, OR PROFITS, OR SPECIAL,
// DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES, EVEN IF AUTODESK AND/OR ITS
// LICENSORS HAS BEEN ADVISED OF THE POSSIBILITY OR PROBABILITY OF SUCH DAMAGES.

source "cMuscleHelper.mel" ;
source "cMusclePaint.mel"  ;
source "cMuscleSplineUI.mel" ;		// source before builder!
source "cMuscleBuilder.mel" ; 
source "cMuscleConvertSkin.mel" ;
source "cMuscleSaveWeights.mel" ;
source "cMuscleMirrorWeights" ;
source "cMuscleTransferWeights.mel" ;
source "cMuscleSetupMasterControl.mel" ;
source "cMuscleDisplace.mel" ;
source "cMuscleWeightDefaultUI.mel" ;
source "cMuscleCreatorUI.mel" ;
source "cMuscleSmartCollide.mel" ;
source "cMuscleWeightPruneUI.mel" ;
source "cMuscleSelfCollisionUI.mel" ;


catch(`makePaintable -attrType "multiFloat"  
		-sm "deformer" "cMuscleMirror" "weights" `);

catch(`makePaintable -attrType "multiFloat"  
		-sm "deformer" "cMuscleRelative" "weights" `);

catch(`makePaintable -attrType "multiFloat"  
		-sm "deformer" "cMuscleSplineDeformer" "weights" `);

catch(`makePaintable -attrType "multiFloat"  
		-sm "deformer" "cMuscleStretch" "weights" `);

catch(`makePaintable -attrType "multiFloat"  
		-sm "deformer" "cMuscleSystem" "weights" `);

catch(`makePaintable -attrType "multiFloat" 
		-sm "deformer" "cMuscleMultiCollide" "weights" `);

// --------------------------------------------------------------------------

/*
 * cMuscle() - Main entry.  Assures plugin is loaded.
 */
global proc cMuscle()
{
	cMuscle_load() ;		// do load
	cMuscle_makeMenu() ;	// make/remake menu
}


// --------------------------------------------------------------------------

/*
 * cMuscle_load() - Loads the plugin
 */
global proc cMuscle_load()
{
	string $version = `about -v` ;
	float $vers = (float)(substring($version,1,3)) ;

	// Don't load since now loading plugin auto srcs this script and we don't want a cycle!

}

global proc RefreshMuscleDisplace(string $parent)
{
	// Giving the chance to third parties to add displacement menu items
	//
	string $currentParent = `setParent -q -menu`;
	
	setParent -menu $parent;
	removeMenuItems("CreateMayaMuscleShaderAnchorPoint", "");
	callbacks -executeCallbacks -hook "addMayaMuscleMenuItems" $parent;
	setParent -menu $currentParent;
}
// --------------------------------------------------------------------------

/*
 * build the sub menu items 
 */
proc buildMuscleMenuItems(string $parent)
{
    setParent -menu $parent;
    menuItem -l (uiRes("m_cMuscle.kMusclesBones")) 
				-sm true 
				-to 1 ;
		menuItem -l (uiRes("m_cMuscle.kMuscleCreatorUI"))
					-c ("cMuscle_cMuscleCreatorUI(); ") 
					-ann (uiRes("m_cMuscle.kMuscleCreatorUIAnnot"))
					-i "cMuscle_muscle_creatorUI.png";
		menuItem -l (uiRes("m_cMuscle.kConvertSurfaceToMuscleBone"))
					-c ("cMuscle_makeMuscle(0); ") 
					-ann (uiRes("m_cMuscle.kConvertSurfaceToMuscleBoneAnnot"))
					-i "cMuscle_muscle_convertToMuscle.png" ;
	menuItem -divider true ;
		menuItem -l (uiRes("m_cMuscle.kMakeCapsule"))
					-c ("cMuscle_makeCapsule(0); ") 
					-ann (uiRes("m_cMuscle.kMakeCapsuleAnnot"))
					-i "cMuscle_muscle_makeCapsule.png" ;
		menuItem -l (uiRes("m_cMuscle.kMakeCapsuleWithEndLocator"))
					-c ("cMuscle_makeCapsule(0); cMuscle_makeEndLenReader(); ") 
					-ann (uiRes("m_cMuscle.kMakeCapsuleWithEndLocatorAnnot"))
					-i "cMuscle_muscle_makeCapsuleAndLoc.png" ;
		menuItem -l (uiRes("m_cMuscle.kAddEndLocatorToCapsule"))
					-c ("cMuscle_makeEndLenReader(); ") 
					-ann (uiRes("m_cMuscle.kAddEndLocatorToCapsuleAnnot"))
					-i "cMuscle_muscle_addCapsuleLoc.png" ;
		menuItem -l (uiRes("m_cMuscle.kGeneratePolygonCylindersFromCapsules"))
					-c ("cMuscle_capsuleToPolyCyl(); ") 
					-ann (uiRes("m_cMuscle.kGeneratePolygonCylindersFromCapsulesAnnot"))
					-i "cMuscle_muscle_capToPolyCyl.png" ;
	menuItem -divider true ;
		menuItem -l (uiRes("m_cMuscle.kDeleteMuscleJiggleCache")) 
					-c ("cMS_delJiggleCacheUI(); ") 
					-ann (uiRes("m_cMuscle.kDeleteMuscleJiggleCacheAnnot")) 
					-i "cMuscle_muscle_delJiggleCache.png" ;
		menuItem -l (uiRes("m_cMuscle.kFixInvalidMuscleObjectNodes")) 
					-c ("cM_checkForInvalidMuscleObjects(); ") 
					-ann (uiRes("m_cMuscle.kFixInvalidMuscleObjectNodesAnnot")) 
					-i "cMuscle_muscle_fixInvalid.png" ; ;
		menuItem -l (uiRes("m_cMuscle.kSetupMasterMuscleControl")) 
					-c ("cMuscleSetupMasterControl(); ") 
					-ann (uiRes("m_cMuscle.kSetupMasterMuscleControlAnnot")) 
					-i "cMuscle_muscle_setupMasterCtrl.png" ;
	setParent -menu ".." ;

	menuItem -l (uiRes("m_cMuscle.kMusclesSimple")) 
				-sm true 
				-to 1 ;
		menuItem -l (uiRes("m_cMuscle.kMuscleBuilderUI")) 
					-c ("cMuscleBuilder(); ") 
					-ann (uiRes("m_cMuscle.kMuscleBuilderUIAnnot")) 
					-i "cMuscle_muscle_muscleBuilder.png";
		menuItem -l (uiRes("m_cMuscle.kSetMuscleParameters")) 
					-c ("cMuscleBuilder(); tabLayout -e -selectTabIndex 4 bldTabs ;") 
					-ann (uiRes("m_cMuscle.kSetMuscleParametersAnnot")) 
					-i "cMuscle_muscle_muscleParams.png" ;
	menuItem -divider true ;
		menuItem -l (uiRes("m_cMuscle.kApplyMuscleSplineDeformer")) 
					-c ("cMuscleSplineDeformerUI(); ") 
					-ann (uiRes("m_cMuscle.kApplyMuscleSplineDeformerAnnot")) 
					-i "cMuscle_muscle_muscleSplineDef.png" ;
		menuItem -l (uiRes("m_cMuscle.kCustomMuscleShapes")) 
					-c ("cMuscleSplineDeformerShapeUI(); ") 
					-ann (uiRes("m_cMuscle.kCustomMuscleShapesAnnot")) 
					-i "cMuscle_muscle_muscleShapes.png" ;
		menuItem -l (uiRes("m_cMuscle.kResetBasePoseForMuscleSplineDeformer")) 
					-c ("cMS_resetSplineDefBasePoseSel(); ") 
					-ann (uiRes("m_cMuscle.kResetBasePoseForMuscleSplineDeformerAnnot")) 
					-i "cMuscle_muscle_splineReset.png" ;
	menuItem -divider true ;
		menuItem -l (uiRes("m_cMuscle.kApplyMuscleStretchDeformer")) 
					-c ("cMuscle_setupStretch(); ") 
					-ann (uiRes("m_cMuscle.kApplyMuscleStretchDeformerAnnot")) 
					-i "cMuscle_muscle_muscleStretchDef.png" ;
	setParent -menu ".." ;

	menuItem -divider true ;

	menuItem -l (uiRes("m_cMuscle.kSkinSetup")) 
				-sm true 
				-to 1  ;
		menuItem -l (uiRes("m_cMuscle.kApplyMuscleSystemSkinDeformer")) 
					-c ("cMuscle_makeMuscleSystem(1); ") 
					-ann (uiRes("m_cMuscle.kApplyMuscleSystemSkinDeformerAnnot")) 
					-i "cMuscle_skin_apply.png" ;
		menuItem -l (uiRes("m_cMuscle.kConvertMayaSkinToMuscleSystem")) 
					-c ("cMuscleConvertSkin(); ") 
					-ann (uiRes("m_cMuscle.kConvertMayaSkinToMuscleSystemAnnot")) 
					-i "cMuscle_skin_convert.png"  ;
	menuItem -divider true ;
		menuItem -l (uiRes("m_cMuscle.kReInitializeSetupDataOnMuscleSystem")) 
					-c ("cMuscle_prepareRelax(); ") 
					-ann (uiRes("m_cMuscle.kReInitializeSetupDataOnMuscleSystemAnnot")) 
					-i "cMuscle_skin_initRelax.png"  ;
		menuItem -l (uiRes("m_cMuscle.kBindFatOnMuscleSystem")) 
					-c ("cMuscle_bindFat(); ") 
					-ann (uiRes("m_cMuscle.kBindFatOnMuscleSystemAnnot")) 
					-i "cMuscle_skin_bindFat.png"  ;
	menuItem -divider true ;
		menuItem -l (uiRes("m_cMuscle.kAutoFixInvalidStickyBindPoints")) 
					-c ("cMuscle_fixStickyBindUI(); ") 
					-ann (uiRes("m_cMuscle.kAutoFixInvalidStickyBindPointsAnnot")) 
					-i "cMuscle_skin_autoFixSticky.png" ;
		menuItem -l (uiRes("m_cMuscle.kAutoFixDeletedMissingMuscles")) 
					-c ("cMuscle_fixDisconnectedUI(); ") 
					-ann (uiRes("m_cMuscle.kAutoFixDeletedMissingMusclesAnnot")) 
					-i "cMuscle_skin_autoFixMissingMus.png" ;
	menuItem -divider true ;
		menuItem -l (uiRes("m_cMuscle.kSafeDeleteHistory")) 
					-c ("cMuscle_bake(); ") 
					-ann (uiRes("m_cMuscle.kSafeDeleteHistoryAnnot"))  
					-i "cMuscle_skin_safeDelHistory.png" ;
		menuItem -l (uiRes("m_cMuscle.kDisconnectAllMuscleObjects")) 
					-c ("cMuscle_disconnectSystem(1); ") 
					-ann (uiRes("m_cMuscle.kDisconnectAllMuscleObjectsAnnot")) 
					-i "cMuscle_skin_disconnAllMus.png"  ;
		menuItem -l (uiRes("m_cMuscle.kDisconnectAllMuscleDirections")) 
					-c ("cMuscle_disconnectDirSystem(1); ") 
					-ann (uiRes("m_cMuscle.kDisconnectAllMuscleDirectionsAnnot")) 
					-i "cMuscle_skin_disconnAllDir.png" ;
		menuItem -l (uiRes("m_cMuscle.kDisconnectAllMuscleDisplaces")) 
					-c ("cMuscle_disconnectDisplaceSystem(1); ") 
					-ann (uiRes("m_cMuscle.kDisconnectAllMuscleDisplacesAnnot")) 
					-i "cMuscle_skin_disconnAllDisp.png" ;
		menuItem -l (uiRes("m_cMuscle.kDisconnectAllMuscleSmartCollides")) 
					-c ("cMuscle_disconnectSmartCollideSystem(1); ") 
					-ann (uiRes("m_cMuscle.kDisconnectAllMuscleSmartCollidesAnnot")) 
					-i "cMuscle_skin_disconnAllSmart.png" ;
	menuItem -divider true ;
		menuItem -l (uiRes("m_cMuscle.kSetupForRelativeStickyDeformation")) 
					-c ("cMuscle_setupSelectedSystemsForRelative(); ") 
					-ann (uiRes("m_cMuscle.kSetupForRelativeStickyDeformationAnnot")) 
					-i "cMuscle_skin_setupRelative.png"  ;
		menuItem -l (uiRes("m_cMuscle.kSetMusclesBonesAsNotRelative")) 
					-c ("cMuscle_markSelectedMuscleObjectsRelative(0); ") 
					-ann (uiRes("m_cMuscle.kSetMusclesBonesAsNotRelativeAnnot")) 
					-i "cMuscle_skin_relativeOff.png"  ;
		menuItem -l (uiRes("m_cMuscle.kSetMusclesBonesAsRelative")) 
					-c ("cMuscle_markSelectedMuscleObjectsRelative(1); ") 
					-ann (uiRes("m_cMuscle.kSetMusclesBonesAsRelativeAnnot")) 
					-i "cMuscle_skin_relativeOn.png"  ;	
	setParent -menu ".." ;

	menuItem -l (uiRes("m_cMuscle.kMuscleObjects")) 
				-sm true 
				-to 1  ;
		menuItem -l (uiRes("m_cMuscle.kConnectMuscleObjects")) 
					-c ("cMuscle_connectToSystem(); ") 
					-ann (uiRes("m_cMuscle.kConnectMuscleObjectsAnnot")) 
					-i "cMuscle_skin_connMus.png" ;
		menuItem -l (uiRes("m_cMuscle.kDisconnectMuscleObjects")) 
					-c ("cMuscle_disconnectSelMusclesFromSystem(1); ") 
					-ann (uiRes("m_cMuscle.kDisconnectMuscleObjectsAnnot")) 
					-i "cMuscle_skin_disconnMus.png" ; 
		menuItem -l (uiRes("m_cMuscle.kDeleteMuscleObjects")) 
					-c ("cMuscle_deleteMusclesFromSystem(); ") 
					-ann (uiRes("m_cMuscle.kDeleteMuscleObjectsAnnot"))
					-i "cMuscle_muscle_delete.png" ;
										
	menuItem -divider true ;
		menuItem -l (uiRes("m_cMuscle.kResetBasePoseForMuscleObjects")) 
					-c ("cMuscle_resetBindPose(0, 1); ") 
					-ann (uiRes("m_cMuscle.kResetBasePoseForMuscleObjectsAnnot")) 
					-i "cMuscle_skin_resetBase.png" ; 
		menuItem -l (uiRes("m_cMuscle.kCreateBaseForMuscleObjects")) 
					-c ("cMuscle_resetBindPose(1, 1); ") 
					-ann (uiRes("m_cMuscle.kCreateBaseForMuscleObjectsAnnot")) 
					-i "cMuscle_skin_createBase.png" ;
		menuItem -l (uiRes("m_cMuscle.kReBindStickyForMuscleObjects")) 
					-c ("cMuscle_bindStickySel(); ") 
					-ann (uiRes("m_cMuscle.kReBindStickyForMuscleObjectsAnnot")) 
					-i "cMuscle_skin_rebindSticky.png" ;
		menuItem -l (uiRes("m_cMuscle.kVisualizeStickyBindDistanceForMuscleObjects")) 
					-c ("cMuscle_visualizeStickyBindDistanceSel(); ") 
					-ann (uiRes("m_cMuscle.kVisualizeStickyBindDistanceForMuscleObjectsAnnot")) 
					-i "cMuscle_skin_visSticky.png" ;
	setParent -menu ".." ;

    menuItem -l (uiRes("m_cMuscle.kPaintMuscleWeights")) 
					-c ("cMusclePaint(); ") 
					-ann (uiRes("m_cMuscle.kPaintMuscleWeightsAnnot")) 
					-i "cMuscle_skin_paint.png" ;

	menuItem -l (uiRes("m_cMuscle.kWeightingPainting")) 
				-sm true 
				-to 1  ;		
	
		menuItem -l (uiRes("m_cMuscle.kApplyDefaultWeights")) 
					-c ("cMuscleWeightDefaultUI(); ") 
					-ann (uiRes("m_cMuscle.kApplyDefaultWeightsAnnot")) 
					-i "cMuscle_skin_applyDefault.png" ;
		menuItem -l (uiRes("m_cMuscle.kLoadSaveWeights")) 
					-c ("cMuscleSaveWeights(); ") 
					-ann (uiRes("m_cMuscle.kLoadSaveWeightsAnnot")) 
					-i "cMuscle_skin_saveWeights.png" ;
		menuItem -l (uiRes("m_cMuscle.kMirrorWeights")) 
					-c ("cMuscleMirrorWeights(); ") 
					-ann (uiRes("m_cMuscle.kMirrorWeightsAnnot")) 
					-i "cMuscle_skin_mirrorWts.png" ;
		menuItem -l (uiRes("m_cMuscle.kTransferWeights")) 
					-c ("cMuscleTransferWeights(); ") 
					-ann (uiRes("m_cMuscle.kTransferWeightsAnnot")) 
					-i "cMuscle_skin_transferWeights.png" ;
		menuItem -l (uiRes("m_cMuscle.kPruneWeights")) 
					-c ("cMuscleWeightPruneUI(); ") 
					-ann (uiRes("m_cMuscle.kPruneWeightsAnnot")) 
					-i "cMuscle_skin_wtprune.png" ;
	setParent -menu ".." ;

	menuItem -divider true ;

	menuItem -l (uiRes("m_cMuscle.kDirection")) 
				-sm true 
				-to 1  ;
		menuItem -l (uiRes("m_cMuscle.kMakeMuscleDirection")) 
					-c ("cMuscle_makeDir(); ") 
					-ann (uiRes("m_cMuscle.kMakeMuscleDirectionAnnot")) 
					-i "cMuscle_skin_makeDir.png" ;
	menuItem -divider true ;
		menuItem -l (uiRes("m_cMuscle.kConnectMuscleDirections")) 
					-c ("cMuscle_connectDirToSystem(1); ") 
					-ann (uiRes("m_cMuscle.kConnectMuscleDirectionsAnnot")) 
					-i "cMuscle_skin_connDir.png" ;
		menuItem -l (uiRes("m_cMuscle.kDisconnectMuscleDirections")) 
					-c ("cMuscle_disconnectSelDirFromSystem(1); ") 
					-ann (uiRes("m_cMuscle.kDisconnectMuscleDirectionsAnnot")) 
					-i "cMuscle_skin_disconnDir.png" ;
	setParent -menu ".." ;

	string $mayaMuscleDisplaceSubMenuFullyQualifiedName = `menuItem -l (uiRes("m_cMuscle.kDisplacement")) 
				-sm true 
				-to 1
				MayaMuscleDisplaceSubMenu`;
		menuItem -l (uiRes("m_cMuscle.kCreateMuscleDisplace")) 
					-c ("cMuscle_createDisplaceUI(); ") 
					-ann (uiRes("m_cMuscle.kCreateMuscleDisplaceAnnot")) 
					-i "cMuscle_disp_create.png" ;
	menuItem -divider true ;
		menuItem -l (uiRes("m_cMuscle.kConnectMuscleDisplaceNodes")) 
					-c ("cMuscle_connectDisplaceToSysUI(); ") 
					-ann (uiRes("m_cMuscle.kConnectMuscleDisplaceNodesAnnot")) 
					-i "cMuscle_disp_connect.png" ;
		menuItem -l (uiRes("m_cMuscle.kDisconnectMuscleDisplaceNodes")) 
					-c ("cMuscle_disconnectDisplaceFromSysUI(); ") 
					-ann (uiRes("m_cMuscle.kDisconnectMuscleDisplaceNodesAnnot")) 
					-i "cMuscle_disp_disconnect.png" ;
	menuItem -divider true ;
		menuItem -l (uiRes("m_cMuscle.kConnectNURBsCurveToMuscleDisplace")) 
					-c ("cMuscle_connectCurveToDisplaceUI(); ") 
					-ann (uiRes("m_cMuscle.kConnectNURBsCurveToMuscleDisplaceAnnot")) 
					-i "cMuscle_disp_connectCurve.png" ;
		menuItem -l (uiRes("m_cMuscle.kDisconnectNURBsCurveFromMuscleDisplace")) 
					-c ("cMuscle_disconnectCurveFromDisplaceUI(); ") 
					-ann (uiRes("m_cMuscle.kDisconnectNURBsCurveFromMuscleDisplaceAnnot")) 
					-i "cMuscle_disp_disconnectCurve.png" ;
	menuItem -divider true ;
		menuItem -l (uiRes("m_cMuscle.kCreateMayaMuscleShaderNetwork")) 
					-c ("cMuscle_createShaderUI(); ") 
					-ann (uiRes("m_cMuscle.kCreateMayaMuscleShaderNetworkAnnot")) 
					-i "cMuscle_disp_mayaShader.png"
					CreateMayaMuscleShaderAnchorPoint;
	menuItem -e
				-postMenuCommand ("RefreshMuscleDisplace " + $mayaMuscleDisplaceSubMenuFullyQualifiedName)
				MayaMuscleDisplaceSubMenu;

	setParent -menu ".." ;

	menuItem -l (uiRes("m_cMuscle.kSmartCollision")) 
				-sm true 
				-to 1  ;
		menuItem -l (uiRes("m_cMuscle.kCreateMuscleSmartCollide")) 
					-c ("cMuscleSmartCollide_setup(); ") 
					-ann (uiRes("m_cMuscle.kCreateMuscleSmartCollideAnnot")) 
					-i "cMuscle_smart_create.png" ;
	menuItem -divider true ;
		menuItem -l (uiRes("m_cMuscle.kConnectMuscleSmartCollideNodes")) 
					-c ("cMuscleSmartCollide_connectSCToSystem(1); ") 
					-ann (uiRes("m_cMuscle.kConnectMuscleSmartCollideNodesAnnot")) 
					-i "cMuscle_smart_connect.png" ;
		menuItem -l (uiRes("m_cMuscle.kDisconnectMuscleSmartCollideNodes")) 
					-c ("cMuscleSmartCollide_disconnectFromSys(1); ") 
					-ann (uiRes("m_cMuscle.kDisconnectMuscleSmartCollideNodesAnnot")) 
					-i "cMuscle_smart_disconnect.png" ;
	setParent -menu ".." ;

	menuItem -l (uiRes("m_cMuscle.kSelfMultiCollision")) 
				-sm true 
				-to 1  ;
		menuItem -l (uiRes("m_cMuscle.kSelfCollisionGroupingUI")) 
					-c ("cMuscleSelfCollisionUI(); ") 
					-ann (uiRes("m_cMuscle.kSelfCollisionGroupingUIAnnot")) 
					-i "cMuscle_multi_apply.png" ;
		menuItem -l (uiRes("m_cMuscle.kApplyMuscleMultiCollideDeformer")) 
					-c ("cMuscleMultiCollide_setup(); ") 
					-ann (uiRes("m_cMuscle.kApplyMuscleMultiCollideDeformerAnnot")) 
					-i "cMuscle_multi_apply.png" ;
	menuItem -divider true ;
		menuItem -l (uiRes("m_cMuscle.kRigSelectionForKeepOut")) 
					-c ("cMuscle_rigKeepOutSel(); ") 
					-ann (uiRes("m_cMuscle.kRigSelectionForKeepOutAnnot")) 
					-i "cMuscle_keepout_rig.png" ;
		menuItem -l (uiRes("m_cMuscle.kConnectMusclesToKeepOut")) 
					-c ("cMuscle_keepOutAddRemMuscle(1); ") 
					-ann (uiRes("m_cMuscle.kConnectMusclesToKeepOutAnnot")) 
					-i "cMuscle_keepout_connect.png" ;
		menuItem -l (uiRes("m_cMuscle.kDisconnectMusclesFromKeepOut")) 
					-c ("cMuscle_keepOutAddRemMuscle(0); ") 
					-ann (uiRes("m_cMuscle.kDisconnectMusclesFromKeepOutAnnot")) 
					-i "cMuscle_keepout_disconnect.png" ;
	setParent -menu ".." ;

	menuItem -l (uiRes("m_cMuscle.kCaching")) 
				-sm true 
				-to 1  ;
		menuItem -l (uiRes("m_cMuscle.kSetLocationOfFileCache")) 
					-c ("cMuscle_chooseCacheFile(); ") 
					-ann (uiRes("m_cMuscle.kSetLocationOfFileCacheAnnot")) 
					-i "cMuscle_skin_cacheFile.png" ;
		menuItem -l (uiRes("m_cMuscle.kCreateCache")) 
					-c ("cMuscle_makeCacheUI(); ") 
					-ann (uiRes("m_cMuscle.kCreateCacheAnnot"))  
					-i "cMuscle_skin_cacheCreate.png" ;
		menuItem -l (uiRes("m_cMuscle.kDeleteNodeCache")) 
					-c ("cMuscle_deleteNodeCacheUI(); ") 
					-ann (uiRes("m_cMuscle.kDeleteNodeCacheAnnot")) 
					-i "cMuscle_skin_cacheDelete.png" ;
	menuItem -divider true ;
		menuItem -l (uiRes("m_cMuscle.kDeletePerPointSkinJiggleCache")) 
					-c ("cMuscle_deleteSkinJiggleCacheUI(); ") 
					-ann (uiRes("m_cMuscle.kDeletePerPointSkinJiggleCacheAnnot")) 
					-i "cMuscle_skin_cacheDeleteJiggle.png" ;
	setParent -menu ".." ;

	menuItem -divider true ;

	menuItem -l (uiRes("m_cMuscle.kSelection")) 
				-sm true 
				-to 1  ;
		menuItem -l (uiRes("m_cMuscle.kSelectConnectedMuscleObjectsFromMuscleSystems")) 
					-c ("cMuscle_selMusclesFromSystem(); ") 
					-ann (uiRes("m_cMuscle.kSelectConnectedMuscleObjectsFromMuscleSystemsAnnot")) 
					-i "cMuscle_sel_musFromSys.png" ;
		menuItem -l (uiRes("m_cMuscle.kSelectConnectedMuscleDirectionsFromMuscleSystems")) 
					-c ("cMuscle_selDirFromSystem(); ") 
					-ann (uiRes("m_cMuscle.kSelectConnectedMuscleDirectionsFromMuscleSystemsAnnot")) 
					-i "cMuscle_sel_dirFromSys.png" ;
		menuItem -l (uiRes("m_cMuscle.kSelectConnectedMuscleSystemsFromMuscleObjects")) 
					-c ("cMuscle_selSystemFromMuscles(); ") 
					-ann (uiRes("m_cMuscle.kSelectConnectedMuscleSystemsFromMuscleObjectsAnnot")) 
					-i "cMuscle_sel_sysFromMus.png" ;
		menuItem -l (uiRes("m_cMuscle.kSelectConnectedMuscleSystemsFromMuscleDirectons")) 
					-c ("cMuscle_selSystemFromDir(); ") 
					-ann (uiRes("m_cMuscle.kSelectConnectedMuscleSystemsFromMuscleDirectonsAnnot")) 
					-i "cMuscle_sel_sysFromDir.png" ;
	setParent -menu ".." ;

	menuItem -l (uiRes("m_cMuscle.kBonusRigging")) 
				-sm true 
				-to 1  ;
		menuItem -l (uiRes("m_cMuscle.kCreateMuscleSpline")) 
					-c ("cMuscleSplineUI(); ") 
					-ann (uiRes("m_cMuscle.kCreateMuscleSplineAnnot")) 
					-i "cMuscle_bonus_spline.png" ;
		menuItem -l (uiRes("m_cMuscle.kSurfaceAttach")) 
					-c ("cMuscleSurfAttachSetup(); ") 
					-ann (uiRes("m_cMuscle.kSurfaceAttachAnnot")) 
					-i "cMuscle_bonus_surfAttach.png" ;
		menuItem -l (uiRes("m_cMuscle.kFixSurfaceAttachToAllowForPolySmooth")) 
					-c ("cMuscle_fixSurfAttachForPolySmooth(); ") 
					-ann (uiRes("m_cMuscle.kFixSurfaceAttachToAllowForPolySmoothAnnot")) 
					-i "cMuscle_bonus_surfAttach.png" ;
	setParent -menu ".." ;
}

/*
 * Build the Muscle menu as a sub menu under the given parent menu.
 */
global proc buidMuscleMenu(string $parent, string $subMenu)
{
    setParent -menu $parent;
    if (`menu -q -exists $subMenu`)
    {
        menu -e -dai $subMenu;
    }
    else
    {
        string $anchorPoint = "wrinkleCtxDialogItem";

        string $anchorPointDivider = "";
        if(`menuItem -q -exists $anchorPoint`)
            $anchorPointDivider = `menuItem -divider true -longDivider true -insertAfter $anchorPoint`;

        if($anchorPointDivider != "") {
            menuItem -l (uiRes("m_cMuscle.kDeformMuscle"))
                -sm true 
                -to true 
                -insertAfter $anchorPointDivider 
                $subMenu ;
        }
    }

    if (`menuItem -q -exists  $subMenu`)
    {
        buildMuscleMenuItems($subMenu);
    }

    setParent -menu ".." ;
}

// --------------------------------------------------------------------------

/*
 * cMuscle_makeMenu() - Makes or remake the cMuscle menu tree off the main
 *    window.
 */
global proc cMuscle_makeMenu()
{
    // Create Muscle menu under Rigging->Deform if Deform menu is already built. 
    global string $gRigDeformationsMenu;
    if(`menu -q -ni $gRigDeformationsMenu` > 0)
        buidMuscleMenu($gRigDeformationsMenu, "cRigMuscleMenu");

    // Create Muscle menu under Modeling->Deform if Deform menu is already built. 
    global string $gMainDeformMenu;
    if(`menu -q -ni $gMainDeformMenu` > 0)
        buidMuscleMenu($gMainDeformMenu, "cModMuscleMenu");
}

// --------------------------------------------------------------------------

/*
 * cMuscle_makeCapsule() - Makes a capsule muscle object
 */
global proc string[] cMuscle_makeCapsule(int $keepBase)
{
	string $obj ;
	string $mOs[] ;
	clear $mOs ;

	select -cl ;
	$obj = `group -em -w -n ("muscleCapsule#")`;
	$mOs[size($mOs)] = cMuscle_setupMuscle($obj, $keepBase, 1) ;


	// Make in nice hierarchy
	string $grpMain ;
	if (objExists("grp"+$obj+"RIG"))
		$grpMain = `group -em -w -n ("grp"+$obj+"RIG#")` ;
	else
		$grpMain = `group -em -w -n ("grp"+$obj+"RIG")` ;
	parent $obj $grpMain ;

	if (objExists("grpMUSCLES") != true)
	{
		group -em -w -n "grpMUSCLES" ;
	}
	parent $grpMain "grpMUSCLES" ;


	select -r $obj ;

	string $msg = (uiRes("m_cMuscle.kCapsuleMuscleSetupObject"));
	print (`format -stringArg $obj $msg`) ;
	return $mOs ;
}

// --------------------------------------------------------------------------

/*
 * cMuscle_makeMuscle() - Makes a node into a muscle object
 */
global proc string[] cMuscle_makeMuscle(int $keepBase)
{
	string $objs[] = `ls -sl -type "transform"` ;
	string $obj ;
	string $mOs[] ;
	clear $mOs ;

	int $capsuleAxis = 1 ;

	for ($obj in $objs)
	{
		// If we have a joint, prompt for info...
		if (nodeType($obj) == "joint")
		{
			// Ask for which axis down joint length if haven't done so yet.
			string $labelXAxis = (uiRes("m_cMuscle.kXAxis"));
			string $labelYAxis = (uiRes("m_cMuscle.kYAxis"));
			string $labelZAxis = (uiRes("m_cMuscle.kZAxis"));
			string $labelNegXAxis = (uiRes("m_cMuscle.kNegXAxis"));
			string $labelNegYAxis = (uiRes("m_cMuscle.kNegYAxis"));
			string $labelNegZAxis = (uiRes("m_cMuscle.kNegZAxis"));
			string $labelCancel = (uiRes("m_cMuscle.kCancel"));

			string $ret = `confirmDialog 
							-t (uiRes("m_cMuscle.kJointToCapsuleConversion"))
							-m (uiRes("m_cMuscle.kChooseWhichAxisAimsDownJointLength"))
							-button $labelXAxis
							-button $labelYAxis
							-button $labelZAxis
							-button $labelNegXAxis
							-button $labelNegYAxis
							-button $labelNegZAxis
							-button $labelCancel
							-defaultButton $labelCancel
							-cancelButton $labelCancel
							-dismissString $labelCancel
				`;

			if ($ret == $labelXAxis)
				$capsuleAxis = 0 ;
			else if ($ret == $labelYAxis)
				$capsuleAxis = 1 ;
			else if ($ret == $labelZAxis)
				$capsuleAxis = 2 ;
			else if ($ret == $labelNegXAxis)
				$capsuleAxis = 3 ;
			else if ($ret == $labelNegYAxis)
				$capsuleAxis = 4 ;
			else if ($ret == $labelNegZAxis)
				$capsuleAxis = 5 ;
			else
				error -sl 0 (uiRes("m_cMuscle.kAbortedAtUsersRequest")) ;
			break ;
		}
	}	


	int $nObj = size($objs) ;
	if ($nObj > 0)
	{
		for ($obj in $objs)
		{
			$mOs[size($mOs)] = cMuscle_setupMuscle($obj, $keepBase, $capsuleAxis) ;
			string $msg = (uiRes("m_cMuscle.kSConvertedToCMuscleObjectN"));
			print (`format -stringArg $obj $msg`) ;
		}
		select -r $objs ;
	}
	else
	{
		error -sl 0 (uiRes("m_cMuscle.kMustSelectObjectToConvertToMuscleBone")) ;
	}


	return $mOs ;
}


// --------------------------------------------------------------------------


/*
 * cMuscle_setupMuscle() - Given a muscle node , this sets it up to work
 */
global proc string cMuscle_setupMuscle(string $xform, int $keepBase, int $capsuleAxis)
{

	// Make upper case version of xform name...
	int $len = size($xform);
	string $Xform = toupper( substring($xform, 1, 1)  );
	if ($len >= 2)
		$Xform += substring($xform, 2, $len) ;

	// First make sure this thing doesn't have a muscle object yet.
	string $curMOs[] = `listRelatives -shapes -ni -type "cMuscleObject" $xform` ;
	if (size($curMOs) > 0)
	{
		string $msg = (uiRes("m_cMuscle.kTransformAlreadyCMuscleObjectWithMuscleObject"));
		warning -sl 0 (`format -stringArg $xform -stringArg $curMOs[0] $msg`) ;
		return $curMOs[0] ;	
	}


	string $mO = "" ;
	string $base ;

	// Does this thing live under a mesh xform?
	string $meshs[] = `listRelatives -ni -children -type "mesh" $xform` ;
	string $nurbs[] = `listRelatives -ni -children -type "nurbsSurface" $xform` ;
	if (size($meshs) > 0)
	{
		$mO = `createNode "cMuscleObject" -name ("cMuscleObject_"+$xform+"Shape#") -p $xform` ;
		connectAttr -f ($meshs[0]+".worldMesh") ($mO+".meshIn") ;
		setAttr ($mO+".type") 0 ;   // change to poly

		setAttr -keyable 0 ($mO+".length") ;	// now hide this attr
		setAttr -keyable 0 ($mO+".radius") ;	// now hide this attr
		setAttr -keyable 0 ($mO+".capsuleAxis") ;	// now hide this attr
		setAttr -keyable 0 ($mO+".nSeg") ;	// now hide this attr
		setAttr -keyable 0 ($mO+".nSides") ;	// now hide this attr
		setAttr -keyable 0 ($mO+".userScaleX") ;	// now hide this attr
		setAttr -keyable 0 ($mO+".userScaleY") ;	// now hide this attr
		setAttr -keyable 0 ($mO+".userScaleZ") ;	// now hide this attr

		setAttr ($mO+".draw") 0 ;
		setAttr ($mO+".wirecolor") -type double3 0.8 0.8 0.8 ;
		setAttr ($mO+".shadecolor") -type double3 0.9 0.9 0.9 ;
	}
	else if (size($nurbs) > 0)
	{
		$mO = `createNode "cMuscleObject" -name ("cMuscleObject_"+$xform+"Shape#") -p $xform` ;
		connectAttr -f ($nurbs[0]+".worldSpace") ($mO+".meshIn") ;

		setAttr ($mO+".type") 1 ;   // change to nurbs

		setAttr ($mO+".draw") 0 ;

		setAttr -keyable 0 ($mO+".length") ;	// now hide this attr
		setAttr -keyable 0 ($mO+".radius") ;	// now hide this attr
		setAttr -keyable 0 ($mO+".capsuleAxis") ;	// now hide this attr
		setAttr -keyable 0 ($mO+".nSeg") ;	// now hide this attr
		setAttr -keyable 0 ($mO+".nSides") ;	// now hide this attr
	}
	else
	{
		$mO = `createNode "cMuscleObject" -name ($xform+"Shape") -p $xform` ;
		setAttr ($mO+".type") 2 ;   // change to capsule

		setAttr -keyable 0 ($mO+".userScaleX") ;	// now hide this attr
		setAttr -keyable 0 ($mO+".userScaleY") ;	// now hide this attr
		setAttr -keyable 0 ($mO+".userScaleZ") ;	// now hide this attr

		// First see if there is a child object..if so use that dist to base length on
		string $childs[] ;
		clear $childs ;
		$childs = `listRelatives -children -ni -type "transform" -type "joint" $xform`;
		if (size($childs) > 0 && $childs[0] != "")
		{
			float $pos1[3] = `xform -q -ws -rp $xform` ;
			float $pos2[3] = `xform -q -ws -rp $childs[0]` ;
			vector $v = << ($pos2[0]-$pos1[0]), ($pos2[1]-$pos1[1]), ($pos2[2]-$pos1[2]) >> ;
			float $dist = mag($v) ;

			setAttr ($mO+".length") $dist ;
			float $rad = ($dist * 0.075) ;	// Base radius on length.
			if ($rad <= 0.0000000001)
				$rad = 0.0000000001 ;
			setAttr ($mO+".radius") $rad ; 
		}
		else
		{
			setAttr ($mO+".length") 0.0 ;
			setAttr ($mO+".radius") 0.5 ;
		}

		if (nodeType($xform) == "joint")
		{
			setAttr ($mO+".capsuleAxis") $capsuleAxis ;

			setAttr ($mO+".nSeg") 1 ;
			setAttr ($mO+".nSides") 6 ;
		}

		setAttr ($mO+".wirecolor") -type double3 0.8 0.8 0.8 ;
		setAttr ($mO+".shadecolor") -type double3 0.9 0.9 0.9 ;

	}

	cMuscle_cleanMayaShape($mO) ;		// Remove extra attrs we don't want to see...

	connectAttr -f ($xform+".worldMatrix") ($mO+".worldMatrixStart") ;

	// Now connect in the base stuff...this makes it, so we either keep it or at 
	// least so the basic bind pose stuff is all stored on the nodes...
	$base = cMuscle_setupMuscleBase($xform, $mO) ;
	setAttr -lock 1 -keyable 0 ($mO+".type") ;	// now hide this attr

	// Now if we don't want base, delete it.
	if (!$keepBase)
		delete $base ;

	select -r $xform $mO ;

	return $mO ;   
}


// --------------------------------------------------------------------------

/*
 * cMuscle_setupMuscleBase() - Given a muscle xform and object, this will generate
 *			and connect in a "base" for it.  Returns the base xform name.
 */
global proc string cMuscle_setupMuscleBase(string $xform, string $mO)
{
	/*
	// Make upper case version of xform name...
	int $len = size($xform);
	string $Xform = toupper( substring($xform, 1, 1)  );
	if ($len >= 2)
	$Xform += substring($xform, 2, $len) ;
	 */

	string $base ;

	// First look to see if anything is already connected into the object as a base...
	string $cons[] = `listConnections -s 1 -d 0 -p 0 -scn 1 ($mO+".worldMatrixStartBase")` ;
	if ($cons[0] != "")		// Yep...so delete any base we may have now, we'll redo it.
	{
		delete $cons ;
	}	


	// Make a duplicate base up
	string $bases[] = `duplicate -rr -rc $xform` ;
	$base = `rename $bases[0] ($xform+"BASE")`;
	string $childs[] = `listRelatives -ni -children -type "transform" -type "joint" -type "cMuscleObject" $base`;
	if (size($childs) > 0)
		delete $childs ;
	setAttr -l 0 -k 1 ($base+".tx"); setAttr -l 0 -k 1 ($base+".ty"); setAttr -l 0 -k 1 ($base+".tz");
	setAttr -l 0 -k 1 ($base+".rx"); setAttr -l 0 -k 1 ($base+".ry"); setAttr -l 0 -k 1 ($base+".rz");
	setAttr -l 0 -k 1 ($base+".sx"); setAttr -l 0 -k 1 ($base+".sy"); setAttr -l 0 -k 1 ($base+".sz");
	setAttr ($base+".inheritsTransform") true ;
	string $parents[] = `listRelatives -parent $base`;
	if (size($parents) > 0)  // parent to world if not already....
		parent -w $base ;
	setAttr -l 0 -k 1 ($base+".v") ;	
	setAttr ($base+".v") 0 ;	

	// Does this thing live under a mesh xform?
	string $meshs[] = `listRelatives -ni -children -type "mesh" $xform` ;
	string $nurbs[] = `listRelatives -ni -children -type "nurbsSurface" $xform` ;
	if (size($meshs) > 0)
	{
	}
	else if (size($nurbs) > 0)
	{
		string $nurbsBase[] = `listRelatives -ni -children -type "nurbsSurface" $base` ;
		connectAttr -f ($nurbsBase[0]+".worldSpace") ($mO+".meshInBase") ;
	}
	else
	{
	}

	// Connect in transform
	connectAttr -f ($base+".worldMatrix") ($mO+".worldMatrixStartBase") ;


	select -r $base ;

	return $base ;   


}


// --------------------------------------------------------------------------

/*
 * cMuscle_resetBindPose() - This will reset a muscle's bind pose by creating
 *		a base and then deleting it.  If $keepBase is true, then the base
 *		is actually kept.  Works on selected objects.
 */
global proc string[] cMuscle_resetBindPose(int $keepBase, int $rebindSticky) 
{
	string $bases[] ;
	clear $bases ;

	string $objs[] = `ls -sl`;
	string $errStrMustSelectMuscleObject = (uiRes("m_cMuscle.kMustSelectMuscleObjectToReset"));
	if (size($objs) <= 0)
		error -sl 0 ($errStrMustSelectMuscleObject) ;


	// Look at muscle objects.
	string $mOs[] = `listRelatives -shapes -ni -type "cMuscleObject" $objs`;
	string $mO ;

	if (size($mOs) <= 0)
		error -sl 0 ($errStrMustSelectMuscleObject) ;

	for ($mO in $mOs)
	{
		int $type = `getAttr ($mO+".type")` ;			// What type is it?
		string $xforms[] = `listRelatives -parent -ni $mO` ;	// Get parent transform node.
		string $xform = $xforms[0] ;

		float $maxDist = 2.0 * cMuscle_autoCalcStickyBindDistance($mO) ;	// Do 2x orig to be safe here...


		$base = cMuscle_setupMuscleBase($xform, $mO) ;  // Generate the base!

		if ($type == 1 && $rebindSticky == 1)	// NURBs type muscle...should do a rebind sticky to truly reset also...
		{
			// Only have to rebind sticky if it's actually connected to any system nodes!
			string $mSs[] = `listConnections -s 0 -d 1 -p 0 -scn 1 -type "cMuscleSystem" ($mO+".muscleData")` ; 
			string $mS ;

			for ($mS in $mSs)
			{

				cMuscle_bindSticky($mO, $mS, $maxDist ) ;
			} // end of rebind sticky for each sys
		} // end of if nurbs type

		// Now if we don't want to keep just delete the base we made, otherwise store it.
		if ($keepBase)
		{
			$bases[size($bases)] = $base ;
			setAttr ($base+".v") 1 ;		// Show this base since the user specifically requested it.
			string $msg = (uiRes("m_cMuscle.kGeneratedBaseForMuscleObject"));
			print (`format -stringArg $base -stringArg $mO $msg`) ; 
		}
		else
		{
			delete $base ;
			string $msg = (uiRes("m_cMuscle.kResetBindPoseForMuscleObject"));
			print (`format -stringArg $mO $msg`) ; 
		}

	} // end of each muscle object reset


	if ($keepBase)
		select -r $bases ;
	else
		select -r $objs ;

	return $bases ;
}

// --------------------------------------------------------------------------


/*
 * cMuscle_makeMuscleSystem() - Added muscleSystem deformer to sel geo.
 */
global proc string cMuscle_makeMuscleSystem(int $bPrompt)
{
	string $objs[] = `ls -sl` ;

	if (size($objs) <= 0) {
		error -sl 0 (uiRes("m_cMuscle.kMustSelectObjectOrComponentsToDeform")) ;
		return "";
	}
	
	string $selectedShape = "";
	if(`objectType -isa "shape" $objs[0]` == 1)	{
	    $selectedShape = $objs[0];
	}
    else if(`objectType -isa "transform" $objs[0]` == 1) {
        string $result[] = `listRelatives -path -shapes $objs[0]`;
        if(size($result) > 0)
            $selectedShape = $result[0];
    }
    
    if($selectedShape != "") {
        string $existingMuscleDeformer[] = `listConnections -s 1 -d 0 -type cMuscleSystem $selectedShape`;
        if(size($existingMuscleDeformer)) {
            error (uiRes("m_cMuscle.kMuscleDeformerAlreadyExists")) ;
            return "";
        }
    }

	// Just add the deformer!
	string $defs[] = `deformer -type "cMuscleSystem" $objs[0]` ;
	string $def = $defs[0] ;

	// Set up needed data for cache
	connectAttr -f ("time1.outTime") ($def+".inTime") ;

	string $path = `workspace -q -dir` ;	 // Get workspace current dir
	$path += "muscleCache/" ;

	if (`filetest -d $path` != 1)	// If doesn't exist yet, make it.
		sysFile -makeDir $path ;

	// And set to a good cache file name....
	setAttr -type "string" ($def+".cachePath") ($path+$objs[0]+".mus") ;

	// Make label attributes locked.
	setAttr -lock true ($def+".STICKY");
	setAttr -lock true ($def+".SLIDING");
	setAttr -lock true ($def+".JIGGLE");
	setAttr -lock true ($def+".DISPLACE");
	setAttr -lock true ($def+".FORCE");
	setAttr -lock true ($def+".RELAX");
	setAttr -lock true ($def+".SMOOTH");
	setAttr -lock true ($def+".COLLISION");

	select -r $def ;
	cMuscle_prepareRelax() ;		// Also set up relax data for it!

	string $skins[] = cMuscle_getDeformers("skinCluster", {$objs[0]}) ;
	if ($bPrompt && size($skins) >= 1)
	{
		string $labelYes = (uiRes("m_cMuscle.kYes"));
		string $labelNo = (uiRes("m_cMuscle.kNo"));
		string $ret = `confirmDialog 
						-t (uiRes("m_cMuscle.kSetupForRelativeDeformation"))
						-m (uiRes("m_cMuscle.kThisMeshAppearsToHaveSkinClusterApplied"))
						-button $labelYes
						-button $labelNo
						-defaultButton $labelYes
						-cancelButton $labelNo
						-dismissString $labelNo
			`;

		if ($ret == $labelYes)
			cMuscle_setupSystemForRelative($def) ;
	}


	select -r $objs[0] ;

	string $msg = (uiRes("m_cMuscle.kAddedDef"));
	print (`format -stringArg $def $msg`) ;
	return $def ;
}

// --------------------------------------------------------------------------

/*
 * cMuscle_prepareRelax() - Sets up muscle system with needed relax data
 *		of mesh in default state.
 */
global proc cMuscle_prepareRelax()
{
	string $objs[] = `ls -sl`;

	if (size($objs) <= 0)
		error -sl 0 (uiRes("m_cMuscle.kMustSelectObjectWithMuscleSystemDeformer")) ;

	// Look for a muscle system in what is chosen...
	string $hist[] = `listHistory -pdo true -il 1 $objs`;
	string $mSs[] = `ls -type "cMuscleSystem" $hist` ;

	$mSs = stringArrayRemoveDuplicates($mSs) ;

	if (size($mSs) <= 0)
		error -sl 0 (uiRes("m_cMuscle.kMustSelectMuscleSystem")) ;

	// Go thru each one
	string $mS ;
	for ($mS in $mSs)
	{
		// What mesh is it deforming?
		string $geos[] = `deformer -q -geometry $mS` ; 

		string $type = nodeType($geos) ;
		if ($type == "nurbsSurface" || $type == "mesh" || $type == "subdiv")
		{	
			setAttr ($mS+".envelope") 0 ;		// Disable it for relax calc.
			refresh ;

			// Clear out any old data first...
			int $a ;
			int $size ;
			$size = `getAttr -size ($mS+".smoothData.smoothEntry")` ;
			for ($a=0; $a < $size; ++$a)
				catch(` removeMultiInstance ($mS+".smoothData.smoothEntry["+$a+"]") `) ;
			$size = `getAttr -size ($mS+".smoothData.ptToPtEntry")` ;
			for ($a=0; $a < $size; ++$a)
				catch(` removeMultiInstance ($mS+".smoothData.ptToPtEntry["+$a+"]") `) ;
			$size = `getAttr -size ($mS+".relaxData.relaxSt")` ;
			for ($a=0; $a < $size; ++$a)
				catch(` removeMultiInstance ($mS+".relaxData.relaxSt["+$a+"]") `) ;
			$size = `getAttr -size ($mS+".relaxData.relaxBd")` ;
			for ($a=0; $a < $size; ++$a)
				catch(` removeMultiInstance ($mS+".relaxData.relaxBd["+$a+"]") `) ;
			$size = `getAttr -size ($mS+".relaxData.relaxTri")` ;
			for ($a=0; $a < $size; ++$a)
				catch(` removeMultiInstance ($mS+".relaxData.relaxTri["+$a+"]") `) ;

			catch(`cMuscleRelaxSetup -gen $mS`) ;		// Do the relax pre-calc stuff!

			setAttr ($mS+".envelope") 1 ;		// Enable it
			select -r $geos[0] $mS ;
		}
	}
}

// --------------------------------------------------------------------------

/*
 * cMuscle_visualizeStickyBindDistanceSel() - For selected muscle objects,
 *		Visualizes sticky bind distance. 
 */
global proc cMuscle_visualizeStickyBindDistanceSel()
{
	string $objs[] = `ls -sl`;

	string $msg = (uiRes("m_cMuscle.kMustSelectMuscleObject"));

	if (size($objs) <= 0)
		error -sl 0 ($msg) ;

	string $mOs[] = `listRelatives -shapes -ni -type "cMuscleObject" $objs`;
	if (size($mOs) <= 0)
		error -sl 0 ($msg) ;

	string $mO ;
	for ($mO in $mOs)
	{
		// Only do this for NURBs...since that's the only one that needs it.
		if (`getAttr ($mO+".type")` == 1)
		{
			float $data[] = `cMuscleBindSticky -cbind -muscle $mO` ;
			string $spheres[] = `sphere -p $data[0] $data[1] $data[2] -ax 0 1 0 -ssw 0 -esw 360 -r $data[3] -d 3 -ut 0 -tol 0.01 -s 8 -nsp 4 -ch 1 -n ("cMuscleStickyBindVisualize#")` ;
			CenterPivot ;

			// If material doesn't exist...make one.
			//
			if (objExists("matMuscleStickyBindVisualize") != true)
			{
				string $mat = `shadingNode -asShader blinn`;
				string $mat = `rename $mat ("matMuscleStickyBindVisualize")`;

				sets -renderable true -noSurfaceShader true -empty -name ($mat+"SG") ;
				connectAttr -f ($mat+".outColor") ($mat+"SG.surfaceShader") ;


				setAttr ($mat+".color") -type double3 1.0 1.0 0.0 ;
				setAttr ($mat+".specularColor") -type double3 0.5 0.5 0.0 ;
				setAttr ($mat+".transparency") -type double3 0.7 0.7 0.7 ;
				setAttr ($mat+".reflectivity") 0.0 ;
				setAttr ($mat+".specularRollOff") 0.25 ;
				setAttr ($mat+".eccentricity") 0.60 ;
			}
			// Apply material        
			select -r $spheres[0] ;
			sets -e -forceElement ("matMuscleStickyBindVisualizeSG");    

		}

	}  // end of each muscle

}	

// --------------------------------------------------------------------------

/*
 * cMuscle_autoCalcStickyBindDistance() - Given a muscleObject, auto calcs
 *		the sticky bind distance.
 */
global proc float cMuscle_autoCalcStickyBindDistance(string $mO)
{
	float $data[] = `cMuscleBindSticky -cbind -muscle $mO` ;

	return $data[3] ;
}	


// --------------------------------------------------------------------------

/*
 * cM_checkForInvalidMuscleObjects() - In case the user duplicated muscle objects,
 *		then this means they are not connected...this tool will find them,
 *		select them, and ask if they should be fixed.
 */
global proc cM_checkForInvalidMuscleObjects()
{
	string $bad[] ;
	clear $bad ;

	string $mOs[] = `ls -type "cMuscleObject" "*"` ;
	string $mO ;
	for ($mO in $mOs)
	{
		string $cons[] ;
		clear $cons ;

		int $type = `getAttr ($mO+".type")` ;
		$cons = `listConnections -s 1 -d 0 -p 1 -scn 1 ($mO+".worldMatrixStart")` ;
		if (size($cons) <= 0)
		{
			$bad[size($bad)] = $mO ;
			string $msg = (uiRes("m_cMuscle.kInvalidNoMatrix"));
			$msg = `format -stringArg $mO -stringArg $type $msg`;
			print ($msg) ;
			continue ;
		}
		$cons = `listConnections -s 1 -d 0 -p 1 -scn 1 ($mO+".meshIn")` ;
		if ($type != 2 && size($cons) <= 0 )
		{
			$bad[size($bad)] = $mO ;
			string $msg = (uiRes("m_cMuscle.kInvalidNoMesh"));
			$msg = `format -stringArg $mO -stringArg $type $msg`;
			print ($msg) ;
		}
	}

	select -r $bad ;

	if (size($bad) > 0)
	{
		string $msg = (uiRes("m_cMuscle.kMuscleObjectAppearsToBeDisconnected"));
		$msg = `format -stringArg (size($bad)) $msg`;
		string $labelFix= (uiRes("m_cMuscle.kFix"));
		string $labelIgnore= (uiRes("m_cMuscle.kIgnore"));
		string $ret = `confirmDialog
						-t (uiRes("m_cMuscle.kAutoFixCMuscleObjects"))
						-m $msg
						-ma "left"
						-button $labelFix
						-button $labelIgnore
						-defaultButton $labelFix
						-dismissString $labelIgnore
						-cancelButton $labelIgnore
			`;
		if ($ret == $labelFix)
		{
			string $xforms[] = `listRelatives -parent $bad`;	// Get the real parent xforms we want to reconvert...
			delete $bad ;	// Delete bad cMuscleObject nodes...
			select -r $xforms ;
			cMuscle_makeMuscle(0) ;
			string $msg = (uiRes("m_cMuscle.kCorrectedMuscleObjectNodes"));
			$msg = `format -stringArg (size($xforms)) $msg`;
			print ($msg) ;
		}			
		else
		{
			string $msg = (uiRes("m_cMuscle.kThereAreInvalidMuscleObjectNodes"));
			$msg = `format -stringArg (size($bad)) $msg`;
			print ($msg) ;	
		}
	}
	else
		print (uiRes("m_cMuscle.kAllMuscleObjectNodesAppearToBeValid")) ;
}



// --------------------------------------------------------------------------

/*
 * cMuscle_connectToSystem() - Connects all selected muscleObjects to
 *	the selected muscleSystem
 */
global proc cMuscle_connectToSystem()
{
	string $objs[] = `ls -sl`;

	if (size($objs) <= 0)
		error -sl 0 (uiRes("m_cMuscle.kMustSelectMuscleObjectsAndMuscleSystemDeformerOrGeometry")) ;


	string $mOs[] = `listRelatives -shapes -ni -type "cMuscleObject" $objs`;
	string $hist[] = `listHistory -pdo true -il 1 $objs`;
	string $mSs[] = `ls -type "cMuscleSystem" $hist` ;

	$mSs = stringArrayRemoveDuplicates($mSs) ;


	if (size($mOs) <= 0)
		error -sl 0 (uiRes("m_cMuscle.kMustSelectMuscleObject2"));

	if (size($mSs) <= 0)
		error -sl 0 (uiRes("m_cMuscle.kMustSelectMuscleSystem2"));



	// Default NURBs dist
	float $maxDist = -1 ;


	string $mO ;
	int $hasNURBs = 0 ;
	float $avgDist = 0.0 ;
	for ($mO in $mOs)	// each muscleObject
	{
		if (`getAttr ($mO+".type")` == 1)
		{
			$avgDist += cMuscle_autoCalcStickyBindDistance($mO) ;
			++$hasNURBs ;
			break ;
		}
	}


	int $distMode = 0 ;		// 0=bind all,  1=calc 2=use specified

	// Only query for Max Dist if adding NURBs in.
	if ($hasNURBs)
	{
		$avgDist = $avgDist / $hasNURBs ;	// average dist

		string $labelAutoCalculate = (uiRes("m_cMuscle.kAutoCalculate"));
		string $labelAvgValue = (uiRes("m_cMuscle.kAvgValue"));
		string $labelAllPoints = (uiRes("m_cMuscle.kAllPoints"));
		string $labelCancel = (uiRes("m_cMuscle.kCancel2"));
		string $result = `promptDialog 
							-title (uiRes("m_cMuscle.kStickyBindMaximumDistance"))
							-message (uiRes("m_cMuscle.kMaxDistanceFromCenterOfMuscle"))
							-text $avgDist
							-button $labelAutoCalculate
							-button $labelAvgValue
							-button $labelAllPoints
							-button $labelCancel
							-defaultButton $labelAutoCalculate 
							-cancelButton $labelCancel
							-dismissString $labelCancel
			`;

		if ($result == $labelCancel) 
			return ;

		$maxDist = `promptDialog -q -text` ;		// get as a float

		if ($result == $labelAllPoints || $maxDist == -1)
		{
			$distMode = 0 ;
			$maxDist = -1 ;
		}
		else if ($result == $labelAutoCalculate || $maxDist == 0)
		{
			$distMode = 1 ;
			$maxDist = 0 ;
		}
		else if ($result == $labelAvgValue)
		{
			$distMode = 2 ;
		}
		else
			return ;
	}


	string $mS ;
	for ($mS in $mSs)	// each muscleSystem
		setAttr ($mS+".envelope") 0.0 ;		// Disable

	for ($mO in $mOs)	// each muscleObject
	{
		// First now for this muscle Object figure out the size...
		string $parents[] = `listRelatives -parent $mO`;
		string $xform = $parents[0] ;

		// Calc best distance for this muscle if that is what we are doing....
		if ($distMode == 1)
			$maxDist = cMuscle_autoCalcStickyBindDistance($mO) ;

		string $mS ;
		for ($mS in $mSs)	// each muscleSystem
		{
			setAttr ($mS+".envelope") 0.0 ;		// Disable

			// Make sure this muscle isn't connected yet!
			string $existMus[] = `cMuscleQuery -system $mS -muscle`;

			string $e;
			int $alreadyConnected = 0 ;
			for ($e in $existMus)
			{
				if ($mO == $e)
				{
					$alreadyConnected = 1;
					break ;
				}
			}
			if ($alreadyConnected)
			{
				string $msg = (uiRes("m_cMuscle.kMuscleObjectAlreadyConnectedToMuscleNode"));
				$msg = `format -stringArg $mO -stringArg $mS $msg`;
				warning -sl 0 ($msg) ;
				break ;		// next one then!
			}


			// Find next unconnected index...
			//
			int $musIdxs[] = `cMuscleQuery -system $mS -muscle -index`;
			$musIdxs = `sort $musIdxs` ;

			int $idx=0 ;
			int $test;
			int $done=0 ;
			for ($test=0; $test < size($musIdxs); ++$test)
			{
				if ($test != $musIdxs[$test])	// we have a gap!
				{
					$idx = $test ; 
					$done = 1 ;
					break ;
				}
				++$idx ;	// otherwise keep going, we may end with +1 from last...
			}

			// See does this muscleObject have a base???
			string $cons[] = `listConnections -s 1 -d 0 -p 0 -scn 1 ($mO+".worldMatrixStartBase")` ;
			int $bHasBase = 0 ;
			if ($cons[0] != "")		// Yep...so delete any base we may have now, we'll redo it.
				$bHasBase = 1 ;

			// Select XForm of Muscle Object
			select -r $xform ;
			cMuscle_resetBindPose($bHasBase, 0) ;    // Since we are binding, do a RESET on the bind/base pose...but don't do extra sticky rebinds...just the main shape/xform stuff.
			//was a bug in 1.0, should not be 0 above for first parameter if the base already exists.

			connectAttr -f ($mO+".muscleData") ($mS+".muscleData["+$idx+"]") ; 
			// Now also bind it as sticky if needed.  That way sticky works
			// right away once it is attached.
			cMuscle_bindSticky($mO, $mS, $maxDist) ;

			// Hmmm must set back to 1 before we attempt to add something else in!
			// otherwise the node may disable and get messed up!
			//			setAttr ($mS+".envelope") 1.0 ;		// Enable
			//			refresh ;
		}
	}

	for ($mS in $mSs)	// each muscleSystem
		setAttr ($mS+".envelope") 1.0 ;		// Enable

	select -r $objs ;	// Resel

	print (uiRes("m_cMuscle.kMuscleConnectionDone")) ;

}


// --------------------------------------------------------------------------

/*
 * cMuscle_bindFat() - Perform a bind on Fat
 */
global proc cMuscle_bindFat()
{
	string $msg = (uiRes("m_cMuscle.kMustSelectNodeThatHasMuscleDeformer"));
	string $objs[] = `ls -sl`;
	string $hist[] = `listHistory -pdo true -il 1 $objs`;
	if (size($hist) <= 0 || size($objs) <= 0)
		error -sl 0 ($msg) ;

	string $mSs[] = `ls -type "cMuscleSystem" $hist` ;
	$mSs = stringArrayRemoveDuplicates($mSs) ;

	if (size($mSs) <= 0)
		error -sl 0 ($msg) ;


	select -r $mSs[0] ;

	int $shrink = `getAttr ($mSs[0]+".shrinkWrap")` ;	// store

	setAttr ($mSs[0]+".useBind") 0 ;		// Turn off bind mode
	setAttr ($mSs[0]+".shrinkWrap") 1 ;		// enable shrinkWrap
	setAttr ($mSs[0]+".enableSliding") 1 ;	// enable sliding
	setAttr ($mSs[0]+".envelope") 1 ;	// activate
	refresh ;		// Make it calc fat.
	setAttr ($mSs[0]+".useBind") 1 ;		// Turn on bind mode, now it will use what it just figured
	setAttr ($mSs[0]+".shrinkWrap") $shrink ;  // restore
	refresh ;

}

// --------------------------------------------------------------------------

/*
 * cMuscle_selMusclesFromSystem() - Selects all muscleObjects tied into the system
 */
global proc cMuscle_selMusclesFromSystem()
{
	string $objs[] = `ls -sl`;
	if (size($objs) <= 0)
		error -sl 0 (uiRes("m_cMuscle.kMustSelectMuscleDeformerOrGeometry")) ;
	string $hist[] = `listHistory -pdo true -il 1 $objs`;
	string $mSs[] = `ls -type "cMuscleSystem" $hist` ;
	if (size($mSs) <= 0)
		error -sl 0 (uiRes("m_cMuscle.kMustSelectMuscle")) ;    
	$mSs = stringArrayRemoveDuplicates($mSs) ;

	select -cl ;

	string $mS ;
	for ($mS in $mSs)
	{
		string $mOsShapes[] = `cMuscleQuery -system $mS -muscle` ;
		string $mOs[] = `listRelatives -parent $mOsShapes` ;
		select -add $mOs ;
	}

	print (uiRes("m_cMuscle.kSelectedMuscleObjectsFromMuscleSystem")) ;
}


// --------------------------------------------------------------------------

/*
 * cMuscle_selSystemFromMuscles() - Selects all systems these muscle(s) are deforming
 */
global proc cMuscle_selSystemFromMuscles()
{
	string $objs[] = `ls -sl`;
	if (size($objs) <= 0)
		error -sl 0 (uiRes("m_cMuscle.kMustSelectMuscleObject3"));
	string $mOs[] = `listRelatives -shapes -ni -type "cMuscleObject" $objs`;
	if (size($mOs) <= 0)
		error -sl 0 (uiRes("m_cMuscle.kMustSelectMuscleSystem3"));

	select -cl ;

	string $mO ;
	for ($mO in $mOs)
	{
		string $mSs[] = `listConnections -s 0 -d 1 -p 0 ($mO+".muscleData")` ;
		select -add $mSs ;
	}

	print (uiRes("m_cMuscle.kSelectedMuscleSystemsFromMuscleObjects")) ;
}


// --------------------------------------------------------------------------


/*
 * cMuscle_disconnectSystem() - Removes muscleData connections from System nodes.
 */
global proc cMuscle_disconnectSystem(int $rem)
{
	string $objs[] = `ls -sl`;

	if (size($objs) <= 0)
		error -sl 0 (uiRes("m_cMuscle.kMustSelectMuscleSystemDeformerOrGeometry")) ;

	string $hist[] = `listHistory -pdo true -il 1 $objs`;
	string $mSs[] = `ls -type "cMuscleSystem" $hist` ;
	$mSs = stringArrayRemoveDuplicates($mSs) ;


	if (size($mSs) <= 0)
		error -sl 0 (uiRes("m_cMuscle.kMustSelectMuscleSystem4")) ;

	select -cl ;

	string $mS ;
	for ($mS in $mSs)	// each muscleSystem
		setAttr ($mS+".envelope") 0.0 ;		// Disable

	for ($mS in $mSs)	// each muscleSystem
	{
		string $mOs[] = `cMuscleQuery -system $mS -muscle` ;		// Get muscles
		int $idxs[] = `cMuscleQuery -system $mS -muscle -index` ;	// And index connected into

		int $i;
		for ($i=0; $i < size($mOs); ++$i)
		{
			// Disconnect it!
			disconnectAttr ($mOs[$i]+".muscleData") ($mS+".muscleData["+$idxs[$i]+"]") ;
			if ($rem == 1)
				removeMultiInstance -b true ($mS+".muscleData["+$idxs[$i]+"]") ;
		} // each muscle connection in...


	}  // each system selected...

	for ($mS in $mSs)	// each muscleSystem
		setAttr ($mS+".envelope") 1.0 ;		// Enable


	select $objs ;

	print (uiRes("m_cMuscle.kDisconnectedAllMuscleObjectsNodeFromMuscleSystemNodes")) ;
}

// --------------------------------------------------------------------------
/*
 * cMuscle_deleteMusclesFromSystem() - delete selected muscleObjects
 *		from System.
 */
global proc cMuscle_deleteMusclesFromSystem()
{
    string $selection[] = `ls -sl`;
    string $muscleSurface;
    string $muscleTransform;
    if(`nodeType $selection[0]` == "nurbsSurface") {
        $muscleSurface = $selection[0];
        string $parent[] = `listRelatives -parent $muscleSurface`;
        $muscleTransform = $parent[0];
        
    }
    else if(`nodeType $selection[0]` == "transform") {
        string $children[] = `listRelatives -children $selection[0]`;
        for($child in $children) {
            if(`nodeType $child` == "nurbsSurface") {
                $muscleSurface = $child;
                $muscleTransform = $selection[0];
                break;
            }
        }
    }
    
    if($muscleSurface == "") {
        print (uiRes("m_cMuscle.kSelectMuscleForDelete")) ;
        return;
    }
    
    string $createPlug = $muscleSurface + ".create";
    string $muscleCreatorNode[] = `listConnections -source true $createPlug`;    
    
    if(size($muscleCreatorNode) < 1 || `nodeType $muscleCreatorNode[0]` != "cMuscleCreator") {
        print (uiRes("m_cMuscle.kSelectV2MuscleForDelete")) ;
        return;
    }
            
    
    string $rigGroup[] = `listRelatives -parent $muscleTransform`;        
    
    string $connectedNodes[] = `listConnections $muscleCreatorNode[0]`;
        
    for($connNode in $connectedNodes) {
        if(`objExists $connNode`)
            delete $connNode;        
    }        
    
    if(size($rigGroup) > 0  && (`objExists $rigGroup[0]`) && (`nodeType $rigGroup[0]` == "transform") && 
      (`match "grpcMuscleSurface" $rigGroup[0]` != ""))
        delete $rigGroup[0];
            
    if(`objExists $muscleCreatorNode[0]`)
        delete $muscleCreatorNode[0];
    
    
    
}



// --------------------------------------------------------------------------


/*
 * cMuscle_disconnectSelMusclesFromSystem() - Removes selected muscleObjects
 *		from System nodes.
 */
global proc cMuscle_disconnectSelMusclesFromSystem(int $rem)
{
	string $objs[] = `ls -sl`;

	if (size($objs) <= 0)
		error -sl 0 (uiRes("m_cMuscle.kMustSelectMuscleObjectsAndMuscleSystemDeformerOrGeometry2"));


	string $mOs[] = `listRelatives -shapes -ni -type "cMuscleObject" $objs`;
	string $hist[] = `listHistory -pdo true -il 1 $objs`;
	string $mSs[] = `ls -type "cMuscleSystem" $hist` ;
	$mSs = stringArrayRemoveDuplicates($mSs) ;


	if (size($mOs) <= 0)
		error -sl 0 (uiRes("m_cMuscle.kMustSelectMuscleObject4")) ;

	if (size($mSs) <= 0)
		error -sl 0 (uiRes("m_cMuscle.kMustSelectMuscleSystem5")) ;


	select -cl ;


	for ($mS in $mSs)	// each muscleSystem
	{
		// For each muscle
		for ($mO in $mOs) 
		{
			$idx = cMuscle_getMusIndex($mO, $mS);

			if ($idx >= 0)
			{
				string $msg = (uiRes("m_cMuscle.kDisconnectingMuscleObjectFromMuscleSystem"));
				$msg = `format -stringArg $mO -stringArg $mS $msg`;
				print ($msg) ;

				// Get all points for mesh....			
				string $surfs[] = `deformer -q -geometry $mS` ;
				string $surf = $surfs[0] ;
				string $pts[] ;
				int $nPts ;
				if (nodeType($surf) == "nurbsSurface")
				{
					select -r ($surf+".cv[*]") ;
					$pts = `ls -sl -fl` ;
					$nPts = size($pts) ;
				}
				else if (nodeType($surf) == "mesh")
				{
					select -r ($surf+".vtx[*]") ;
					$pts = `ls -sl -fl` ;
					$nPts = size($pts) ;
				}
				else if (nodeType($surf) == "subdiv")
				{
					select -r ($surf+".smp[*]") ;
					$pts = `ls -sl -fl` ;
					$nPts = size($pts) ;
				}
				select -cl ;


				string $xforms[] = `listRelatives -parent $mO` ;
				string $xform = $xforms[0] ;

				float $env = `getAttr ($mS+".envelope")` ;
				catch (`setAttr ($mS+".envelope") 0.0`) ;	// Set to zero for speed!

				// Make sure lock weights if off for this
				setAttr ($mO+".lockStickyWt") 0 ;
				setAttr ($mO+".lockSlidingWt") 0 ;

				// Now set all sticky weights to 0 and renormalize.
				print (uiRes("m_cMuscle.kZeroingWeights")) ;
				waitCursor -state on ;

				string $title = (uiRes("m_cMuscle.kZeroingTransformWeightsForDisconnect"));
				$title = `format -stringArg $xform $title`;
				string $msgPointProgress = (uiRes("m_cMuscle.kPointProgressInitial"));
				$msgPointProgress = `format -stringArg ($nPts-1) $msgPointProgress`;
				progressWindow 
					-title ($title)
					-progress 0
					-status ($msgPointProgress) 
					-isInterruptable true 
					;

				int $p ;
				for ($p=0; $p < $nPts; ++$p)
				{
					if (`progressWindow -q -isCancelled`)
					{
						warning -sl 0 (uiRes("m_cMuscle.kZeroWeightsAborted")) ;
						break ;
					}

					int $nPct = (100.0 * $p/($nPts-1.0)) ;

					$msgPointProgress = (uiRes("m_cMuscle.kPointProgress"));
					$msgPointProgress = `format -stringArg $p -stringArg ($nPts-1) -stringArg $nPct $msgPointProgress`;
					progressWindow -e -progress $nPct -status ($msgPointProgress) ;

					cMuscleWeight -mi $idx -v 0.0 -normalize true -wt "sticky" -system $mS $pts[$p] ;
					cMuscleWeight -mi $idx -v 0.0 -normalize false -wt "sliding" -system $mS $pts[$p] ;
				}

				progressWindow -endProgress ;

				waitCursor -state off ;


				// Disconnect it!
				disconnectAttr ($mO+".muscleData") ($mS+".muscleData["+$idx+"]") ;
				if ($rem == 1)
					removeMultiInstance -b true ($mS+".muscleData["+$idx+"]") ;

				catch (`setAttr ($mS+".envelope") $env`) ;	// back to user value


			} // each muscle connection in...

		} // each muscle...


	}  // each system selected...


	select $objs ;

	print (uiRes("m_cMuscle.kDisconnectedMuscleObjectsFromMuscleSystemNodes")) ;
}


// --------------------------------------------------------------------------

/*
 * cMuscle_bake() - Deletes history on a mesh
 */
global proc cMuscle_bake()
{
	// First disconnect all muscleObjects so they don't get deleted
	// when the history goes away...but use 0 so that the instance[] data
	// remains so the deformer still looks the same.
	cMuscle_disconnectSystem(0) ;
	cMuscle_disconnectDirSystem(0) ;
	cMuscle_disconnectDisplaceSystem(0) ;
	cMuscle_disconnectSmartCollideSystem(0) ;
	delete -ch ;	// And now delete history on the object!
}


// --------------------------------------------------------------------------

/*
 * cMuscle_makeDir() - Makes a cMuscleDirection node and sets it up
 */
global proc cMuscle_makeDir()
{
	string $objs[] = `ls -sl` ;
	string $mOs[] ;
	string $mO ;

	if (size($objs) > 0)
		$mOs = `listRelatives -shapes -ni -type "cMuscleObject" $objs`;

	// Convert capsules to also have muscleDirection nodes.....
	if (size($mOs) > 0)
	{
		for ($mO in $mOs)
		{
			string $xforms[] = `listRelatives -ni -parent $mO`;
			string $xform = $xforms[0] ;

			// Make sure there is not a cMuscleDirection already under this xform!
			string $mDs[] = `listRelatives -shapes -ni -type "cMuscleDirection" $xform`;
			if (size($mDs) > 0)
				continue ;

			// Now...since capsules are just transforms with an axis, 
			// set up this cMuscleDirection under the same xform node, 
			// and just connect capsule stuff into it.
			//
			string $mD = `createNode "cMuscleDirection" -name ("cMuscleDirection_"+$xform+"#") -p $xform ` ;

			// Put matrix into compound so it drives itself.
			connectAttr -f ($xform+".worldMatrix") ($mD+".worldMatrixA") ;

			// And set up to be a radial dir node with length based on capsule.
			setAttr ($mD+".type") 1 ;		// radial
			connectAttr -f ($mO+".length") ($mD+".length") ;
			connectAttr -f ($mO+".capsuleAxis") ($mD+".dirAxis") ;

			float $radius = `getAttr ($mO+".radius")` ;
			setAttr ($mD+".falloffInner") ($radius*1.3333) ;
			setAttr ($mD+".falloffOuter") ($radius*2.0) ;

			// And clean up stuff that is now driven.
			setAttr -lock 1 -k 0 ($mD+".type") ;
			setAttr -lock 0 -k 0 ($mD+".length") ;
			setAttr -lock 0 -k 0 ($mD+".dirAxis") ;

			cMuscle_cleanMayaShape($mD) ;		// Remove extra attrs we don't want to see...
		}

		select -r $objs ;			// Re-select at end
	}
	else		// Else make standalone cMuscleDirection object.
	{
		string $mD = `createNode "cMuscleDirection" -name ("cMuscleDirectionShape#") ` ;

		string $xforms[] = `listRelatives -ni -parent $mD`;
		string $xform = $xforms[0] ;

		// Put matrix into compound so it drives itself.
		connectAttr -f ($xform+".worldMatrix") ($mD+".worldMatrixA") ;

		cMuscle_cleanMayaShape($mD) ;		// Remove extra attrs we don't want to see...
	}

	print (uiRes("m_cMuscle.kCreatedMuscleDirectionNode")) ;
}

// --------------------------------------------------------------------------


/*
 * cMuscle_connectDirToSystem() - Connects all selected muscleDirection nodes to
 *	the selected muscleSystem
 */
global proc cMuscle_connectDirToSystem(int $verbose)
{
	string $objs[] = `ls -sl`;

	if (size($objs) <= 0)
	{
		if ($verbose)			
			error -sl 0 (uiRes("m_cMuscle.kMustSelectMuscleDireectionAndMuscleSystemDeformerOrGeometry")) ;
		else
			return ;
	}


	string $mDs[] = `listRelatives -shapes -ni -type "cMuscleDirection" $objs`;
	string $hist[] = `listHistory -pdo true -il 1 $objs`;
	string $mSs[] = `ls -type "cMuscleSystem" $hist` ;
	$mSs = stringArrayRemoveDuplicates($mSs) ;


	if (size($mDs) <= 0)
	{
		if ($verbose)
			error -sl 0 (uiRes("m_cMuscle.kMustSelectMuscleDirection")) ;
		else
			return ;
	}

	if (size($mSs) <= 0)
	{
		if ($verbose)
			error -sl 0 (uiRes("m_cMuscle.kMustSelectMuscleSystem6")) ;
		else
			return ;
	}


	string $mS ;
	for ($mS in $mSs)	// each muscleSystem
		setAttr ($mS+".envelope") 0.0 ;		// Disable


	string $mD ;
	for ($mD in $mDs)	// each muscleDirection
	{
		string $mS ;
		for ($mS in $mSs)	// each muscleSystem
		{
			// Make sure this muscle isn't connected yet!
			string $existDir[] = `cMuscleQuery -system $mS -direction` ;

			string $e;
			int $alreadyConnected = 0 ;
			for ($e in $existDir)
			{
				if ($mD == $e)
				{
					$alreadyConnected = 1;
					break ;
				}
			}
			if ($alreadyConnected)
			{
				string $msg = (uiRes("m_cMuscle.kMuscleDirectionAlreadyConnectedToMuscleSystemNode"));
				$msg = `format -stringArg $mD -stringArg $mS $msg`;
				warning -sl 0 ($msg) ;
				break ;		// next one then!
			}


			// Find next unconnected index...
			//
			int $dirIdxs[] = `cMuscleQuery -system $mS -direction -index`;
			$dirIdxs = `sort $dirIdxs` ;

			int $idx=0 ;
			int $test;
			int $done=0 ;
			for ($test=0; $test < size($dirIdxs); ++$test)
			{
				if ($test != $dirIdxs[$test])	// we have a gap!
				{
					$idx = $test ; 
					$done = 1 ;
					break ;
				}
				++$idx ;	// otherwise keep going, we may end with +1 from last...
			}

			connectAttr -f ($mD+".dirData") ($mS+".dirData["+$idx+"]") ;            
		}
	}

	for ($mS in $mSs)	// each muscleSystem
		setAttr ($mS+".envelope") 1.0 ;		// enable


	print (uiRes("m_cMuscle.kMuscleSystemDirectionConnectionsDone")) ;

}


// --------------------------------------------------------------------------


/*
 * cMuscle_disconnectDirSystem() - Removes dirData connections from System nodes.
 */
global proc cMuscle_disconnectDirSystem(int $rem)
{
	string $objs[] = `ls -sl`;

	if (size($objs) <= 0)
		error -sl 0 (uiRes("m_cMuscle.kMustSelectMuscleSystemDeformerOrGeometry2")) ;

	string $hist[] = `listHistory -pdo true -il 1 $objs`;
	string $mSs[] = `ls -type "cMuscleSystem" $hist` ;
	$mSs = stringArrayRemoveDuplicates($mSs) ;


	if (size($mSs) <= 0)
		error -sl 0 (uiRes("m_cMuscle.kMustSelectMuscleSystem7")) ;

	select -cl ;

	string $mS ;
	for ($mS in $mSs)	// each muscleSystem
		setAttr ($mS+".envelope") 0.0 ;		// Disable

	for ($mS in $mSs)	// each muscleSystem
	{
		string $mDs[] = `cMuscleQuery -system $mS -direction` ;		// Get direction
		int $idxs[] = `cMuscleQuery -system $mS -direction -index` ;	// And index connected into

		int $i;
		for ($i=0; $i < size($mDs); ++$i)
		{

			// Disconnect it!
			disconnectAttr ($mDs[$i]+".dirData") ($mS+".dirData["+$idxs[$i]+"]") ;
			if ($rem == 1)
				removeMultiInstance -b true ($mS+".dirData["+$idxs[$i]+"]") ;
		} // each muscle connection in...


	}  // each system selected...

	for ($mS in $mSs)	// each muscleSystem
		setAttr ($mS+".envelope") 1.0 ;		// Enable

	select $objs ;

	print (uiRes("m_cMuscle.kDisconnectedAllMuscleDirectionNodesFromMuscleSystemNodes")) ;
}

// --------------------------------------------------------------------------


/*
 * cMuscle_disconnectSelDirFromSystem() - Removes selected muscleDirection's
 *		from System nodes.
 */
global proc cMuscle_disconnectSelDirFromSystem(int $rem)
{
	string $objs[] = `ls -sl`;

	if (size($objs) <= 0)
		error -sl 0 (uiRes("m_cMuscle.kMustSelectMuscleObjectsAndMuscleSystemDeformerOrGeometry3")) ;


	string $mDs[] = `listRelatives -shapes -ni -type "cMuscleDirection" $objs`;
	string $hist[] = `listHistory -pdo true -il 1 $objs`;
	string $mSs[] = `ls -type "cMuscleSystem" $hist` ;
	$mSs = stringArrayRemoveDuplicates($mSs) ;


	if (size($mDs) <= 0)
		error -sl 0 (uiRes("m_cMuscle.kMustSelectMuscleDirection2")) ;

	if (size($mSs) <= 0)
		error -sl 0 (uiRes("m_cMuscle.kMustSelectMuscleSystem8")) ;


	select -cl ;

	for ($mS in $mSs)	// each muscleDirection
	{
		// For each direction
		for ($mD in $mDs) 
		{
			$idx = cMuscle_getDirIndex($mD, $mS);

			if ($idx >= 0)
			{
				string $msg = (uiRes("m_cMuscle.kDisconnectingMuscleDirectionFromMuscleSystem"));
				$msg = `format -stringArg $mD -stringArg $mS $msg`;
				print ($msg) ;

				// Get all points for mesh....			
				string $surfs[] = `deformer -q -geometry $mS` ;
				string $surf = $surfs[0] ;
				string $pts[] ;
				int $nPts ;
				if (nodeType($surf) == "nurbsSurface")
				{
					select -r ($surf+".cv[*]") ;
					$pts = `ls -sl -fl` ;
					$nPts = size($pts) ;
				}
				else if (nodeType($surf) == "mesh")
				{
					select -r ($surf+".vtx[*]") ;
					$pts = `ls -sl -fl` ;
					$nPts = size($pts) ;
				}
				else if (nodeType($surf) == "subdiv")
				{
					select -r ($surf+".smp[*]") ;
					$pts = `ls -sl -fl` ;
					$nPts = size($pts) ;
				}
				select -cl ;

				string $xforms[] = `listRelatives -parent $mD` ;
				string $xform = $xforms[0] ;

				float $env = `getAttr ($mS+".envelope")` ;
				catch (`setAttr ($mS+".envelope") 0.0`) ;	// Set to zero for speed!

				// Make sure lock weights if off for this
				setAttr ($mD+".lockDirWt") 0 ;

				// Now set all dir weights to 0 
				print (uiRes("m_cMuscle.kZeroWeights")) ;
				waitCursor -state on ;

				string $title =(uiRes("m_cMuscle.kZeroingTransformWeightsForDisconnect2"));
				$title = `format -stringArg $xform $title`;
				progressWindow 
					-title ($title)
					-progress 0
					-status ("Point 0/"+($nPts-1)) 
					-isInterruptable true 
					;

				int $p ;
				for ($p=0; $p < $nPts; ++$p)
				{
					if (`progressWindow -q -isCancelled`)
					{
						warning -sl 0 (uiRes("m_cMuscle.kZeroWeigthsAbortedSomeWeightsMayRemainOnOldMuscleBone")) ;
						break ;
					}

					int $nPct = (100.0 * $p/($nPts-1.0)) ;

					progressWindow -e -progress $nPct -status ("Point "+$p+"/"+($nPts-1)+" ("+$nPct+"%)") ;

					cMuscleWeight -mi $idx -v 0.0 -normalize false -wt "direction" -system $mS $pts[$p] ;
				}

				progressWindow -endProgress ;

				waitCursor -state off ;



				// Disconnect it!
				disconnectAttr ($mD+".dirData") ($mS+".dirData["+$idx+"]") ;
				if ($rem == 1)
					removeMultiInstance -b true ($mS+".dirData["+$idx+"]") ;

				catch (`setAttr ($mS+".envelope") $env`) ;	// Set back to user val

			} // each muscle connection in...

		} // each dir...


	}  // each system selected...


	select $objs ;

	print (uiRes("m_cMuscle.kDisconnectedMuscleDirectionsFromMuscleSystemNodes")) ;
}

// --------------------------------------------------------------------------


/*
 * cMuscle_selDirFromSystem() - Selects all muscleDirections tied into the system
 */
global proc cMuscle_selDirFromSystem()
{
	string $objs[] = `ls -sl`;
	if (size($objs) <= 0)
		error -sl 0 (uiRes("m_cMuscle.kMustSelectMuscleSystemDeformerOrGeometry3")) ;
	string $hist[] = `listHistory -pdo true -il 1 $objs`;
	string $mSs[] = `ls -type "cMuscleSystem" $hist` ;
	if (size($mSs) <= 0)
		error -sl 0 (uiRes("m_cMuscle.kMustSelectMuscleSystem9")) ;    
	$mSs = stringArrayRemoveDuplicates($mSs) ;

	select -cl ;

	string $mS ;
	for ($mS in $mSs)
	{
		string $mDsShapes[] = `cMuscleQuery -system $mS -direction` ;
		string $mDs[] = `listRelatives -parent $mDsShapes`;
		select -add $mDs ;
	}

	print (uiRes("m_cMuscle.kSelectedMuscleDirectionsFromMuscleSystems")) ;
}


// --------------------------------------------------------------------------

/*
 * cMuscle_selSystemFromDir() - Selects all systems these dir(s) are deforming
 */
global proc cMuscle_selSystemFromDir()
{
	string $objs[] = `ls -sl`;
	if (size($objs) <= 0)
		error -sl 0 (uiRes("m_cMuscle.kMustSelectMuscleDirection3")) ;
	string $mDs[] = `listRelatives -shapes -ni -type "cMuscleDirection" $objs`;
	if (size($mDs) <= 0)
		error -sl 0 (uiRes("m_cMuscle.kMustSelectMuscleDirection4")) ;

	select -cl ;

	string $mD ;
	for ($mD in $mDs)
	{
		string $mSs[] = `listConnections -s 0 -d 1 -p 0 ($mD+".dirData")` ;
		select -add $mSs ;
	}

	print (uiRes("m_cMuscle.kSelectedMuscleSystemsFromDirections")) ;
}


// --------------------------------------------------------------------------



/*
 * cMuscle_setupStretch() - Given a node , this sets it up to have stretch deformer
 */
global proc string[] cMuscle_setupStretch()
{

	string $objs[] = `ls -sl` ;

	if (size($objs) <= 0)
		error -sl 0 (uiRes("m_cMuscle.kMustSelectObjectOrComponentsToDeform2")) ;

	// Find the transform node related to what is selected, since we 
	// might have a shape selected.
	string $xforms[] = `ls -type "transform" $objs`;
	if (size($xforms) <= 0)
		$xforms = `listRelatives -ni -parent $objs`;
	string $xform = $xforms[0] ;

	// Make upper case version of xform name...
	int $len = size($xform);
	string $Xform = toupper( substring($xform, 1, 1)  );
	if ($len >= 2)
		$Xform += substring($xform, 2, $len) ;


	if (objExists("setMUSCLERIGS") != true)
		sets -em -n "setMUSCLERIGS" ;

	string $setRig = ("set"+$Xform+"RIG") ;
	if (objExists($setRig) != true)
	{
		sets -em -n $setRig ;
		sets -include "setMUSCLERIGS" $setRig ;
	}




	/*
	 * Ok this is a total hack...the newer cMuscleSplineDeformer has a nice
	 *	command to figure the proper start/end points of a surface for rigging....
	 *	So we temporarily apply that deformer, figure the locations, and then blow
	 *	it away...but that way the start/end locators are at a better spot.
	 */

	// Apply the deformer	
	string $defsTEMP[] = `deformer -type "cMuscleSplineDeformer" $xform` ;
	string $defTEMP = $defsTEMP[0] ;

	// Now position the controls somewhere reasonable....
	float $posData[6] = `cMuscleSplineBind -endpts $defTEMP` ;		//	Where are good start/end pts?

	// Blow away temp def!
	delete $defTEMP ;



	// Just add the deformer!
	string $defs[] = `deformer -type "cMuscleStretch" -n ("cMuscleStretch"+$Xform+"#") $xform` ;
	string $def = $defs[0] ;
	setAttr -lock 1 ($def+".SCALING") ;		// Lock label attrs
	setAttr -lock 1 ($def+".WEIGHTING") ;
	setAttr -lock 1 ($def+".JIGGLE") ;

	// For some reason maya wigs out with edit membership when this is done...
	//		which causes reset base and stuff to break...so don't add deformers to set.
	//
	//	sets -in $setRig $def ;		

	connectAttr -f ("time1.outTime") ($def+".inTime") ;

	// Make len show up so ppl can set driven key from it if desired.
	addAttr -ln ("lengthOut") -dv 0.0 -k 1 $def ;
	connectAttr -f ($def+".lengthCalc") ($def+".lengthOut") ;


	// Make some locators to do basic location info.
	//

	// Make one
	string $locs[] = `spaceLocator`;

	// Now rename and make all the rest too.
	string $locA = `rename $locs[0] ("loc"+$Xform+"Start")`;
	$locs = `duplicate -rr -rc $locA` ;
	string $locB = `rename $locs[0] ("loc"+$Xform+"Mid")`;
	$locs = `duplicate -rr -rc $locA` ;
	string $locC = `rename $locs[0] ("loc"+$Xform+"End")`;
	$locs = `duplicate -rr -rc $locA` ;


	string $locABase = `rename $locs[0] ("loc"+$Xform+"StartBASE")`;
	$locs = `duplicate -rr -rc $locA` ;
	string $locBBase = `rename $locs[0] ("loc"+$Xform+"MidBASE")`;
	$locs = `duplicate -rr -rc $locA` ;
	string $locCBase = `rename $locs[0] ("loc"+$Xform+"EndBASE")`;

	// Make pretty!  Errr I mean color locs so know start vs. end etc..
	//
	color -ud 5 $locA ;		// Cyan = Start
	color -ud 1 $locC ;		// Orange = End


	sets -in $setRig $locA $locB $locC $locABase $locBBase $locCBase ;


	// Connect the worldMatrices up
	connectAttr -f ($locA+".worldMatrix") ($def+".worldMatrixStart") ;
	connectAttr -f ($locB+".worldMatrix") ($def+".worldMatrixMid") ;
	connectAttr -f ($locC+".worldMatrix") ($def+".worldMatrixEnd") ;
	connectAttr -f ($locABase+".worldMatrix") ($def+".worldMatrixStartBase") ;
	connectAttr -f ($locBBase+".worldMatrix") ($def+".worldMatrixMidBase") ;
	connectAttr -f ($locCBase+".worldMatrix") ($def+".worldMatrixEndBase") ;


	// Properly move the locators...
	xform -a -ws -t $posData[0] $posData[1] $posData[2] $locA $locABase  ; 	
	xform -a -ws -t $posData[3] $posData[4] $posData[5] $locC $locCBase  ; 	

	// Aim each control to the other and then delete the constraint, so they are oriented right.
	string $tempCons[] ;
	$tempCons = `aimConstraint -w 1 -aim 0 1 0 -u 0 0 1 -wu 0 0 1 -wut "objectrotation" -wuo $locC $locC $locA` ;
	delete $tempCons ; 	
	$tempCons = `aimConstraint -w 1 -aim 0 -1 0 -u 0 0 1 -wu 0 0 1 -wut "objectrotation" -wuo $locA $locA $locC` ;
	delete $tempCons ; 	
	$tempCons = `aimConstraint -w 1 -aim 0 1 0 -u 0 0 1 -wu 0 0 1 -wut "objectrotation" -wuo $locCBase $locCBase $locABase` ;
	delete $tempCons ; 	
	$tempCons = `aimConstraint -w 1 -aim 0 -1 0 -u 0 0 1 -wu 0 0 1 -wut "objectrotation" -wuo $locABase $locABase $locCBase` ;
	delete $tempCons ; 	

	// Also pt/orient middle ones nicely.
	$tempCons = `pointConstraint -w 1 $locA $locC $locB` ;
	delete $tempCons ;
	$tempCons = `pointConstraint -w 1 $locABase $locCBase $locBBase` ;
	delete $tempCons ;
	$tempCons = `orientConstraint -w 1 $locA $locC $locB` ;
	delete $tempCons ;
	$tempCons = `orientConstraint -w 1 $locABase $locCBase $locBBase` ;
	delete $tempCons ;



	// Set up a nice offset constraint
	string $grpOff = `group -em -w -n ("grpOffsetMid"+$Xform+"")`;    // grp that gets constrained
	sets -in $setRig $grpOff ;

	string $pcons[] = `pointConstraint $locB $grpOff` ;	// snap to B loc
	string $ocons[] = `orientConstraint $locB $grpOff` ;
	delete $pcons $ocons ;

	string $grps[] ;				// offset grps
	$grps = `duplicate -rr -rc $grpOff` ;
	string $grpOffA = `rename $grps[0] ("grpOffsetTgtStart"+$Xform+"")`;
	$grps = `duplicate -rr -rc $grpOff` ;
	string $grpOffC = `rename $grps[0] ("grpOffsetTgtEnd"+$Xform+"")`;

	// Make some other offset grps that read the right offset location for the tgts based on base.
	$grps = `duplicate -rr -rc $grpOff` ;
	string $grpOffARead = `rename $grps[0] ("grpOffsetReadStart"+$Xform+"")`;
	$grps = `duplicate -rr -rc $grpOff` ;
	string $grpOffCRead = `rename $grps[0] ("grpOffsetStartEnd"+$Xform+"")`;

	sets -in $setRig $grpOffA $grpOffC $grpOffARead $grpOffCRead ;


	// Parent them!
	parent $locB $grpOff ;
	parent $grpOffA $locA ;
	parent $grpOffC $locC ;

	parent $grpOffARead $locABase ;
	parent $grpOffCRead $locCBase ;

	// Setup the offset constraint
	string $pCons[] = `pointConstraint -w 0.5 $grpOffA $grpOffC $grpOff` ;    
	string $offOs[] = `orientConstraint -w 0.5 $grpOffA $grpOffC $grpOff` ;
	setAttr ($offOs[0]+".interpType") 0 ;	// No Flip orient constraint mode...
	sets -in $setRig $pCons[0] $offOs[0] ;


	// And set up the readers so that they drive the offset targets
	pointConstraint $locBBase $grpOffARead ;
	pointConstraint $locBBase $grpOffCRead ;
	orientConstraint $locBBase $grpOffARead ;
	orientConstraint $locBBase $grpOffCRead ;
	connectAttr -f ($grpOffARead+".translate") ($grpOffA+".translate") ;
	connectAttr -f ($grpOffARead+".rotate") ($grpOffA+".rotate") ;
	connectAttr -f ($grpOffCRead+".translate") ($grpOffC+".translate") ;
	connectAttr -f ($grpOffCRead+".rotate") ($grpOffC+".rotate") ;

	// And nice holder grps
	string $grpLocs = `group -em -w -n ("grpStretchLocs"+$Xform+"")` ;
	string $grpLocsBase = `group -em -w -n ("grpStretchLocs"+$Xform+"BASE")` ;
	setAttr ($grpLocsBase+".inheritsTransform") 0 ;
	parent $locA $grpOff $locC $grpLocs ;
	parent $locABase $locBBase $locCBase $grpLocsBase ;
	string $grpRig = `group -em -w -n ("grp"+$Xform+"RIG")` ;
	parent $grpLocs $grpLocsBase $grpRig ;
	string $grpGEO = `group -em -w -n ("grp"+$Xform+"GEO")` ;
	parent $grpGEO $grpRig ;
	setAttr ($grpGEO+".inheritsTransform") 0 ;
	setAttr -l 1 -k 0 ($grpGEO+".tx") ;
	setAttr -l 1 -k 0 ($grpGEO+".ty") ;
	setAttr -l 1 -k 0 ($grpGEO+".tz") ;
	setAttr -l 1 -k 0 ($grpGEO+".rx") ;
	setAttr -l 1 -k 0 ($grpGEO+".ry") ;
	setAttr -l 1 -k 0 ($grpGEO+".rz") ;
	setAttr -l 1 -k 0 ($grpGEO+".sx") ;
	setAttr -l 1 -k 0 ($grpGEO+".sy") ;
	setAttr -l 1 -k 0 ($grpGEO+".sz") ;
	// Lock GEO down too...
	parent $xform $grpGEO ;
	setAttr -l 1 -k 1 ($xform+".tx") ;
	setAttr -l 1 -k 1 ($xform+".ty") ;
	setAttr -l 1 -k 1 ($xform+".tz") ;
	setAttr -l 1 -k 1 ($xform+".rx") ;
	setAttr -l 1 -k 1 ($xform+".ry") ;
	setAttr -l 1 -k 1 ($xform+".rz") ;
	setAttr -l 1 -k 1 ($xform+".sx") ;
	setAttr -l 1 -k 1 ($xform+".sy") ;
	setAttr -l 1 -k 1 ($xform+".sz") ;
	sets -in $setRig $grpLocs $grpLocsBase $grpRig $grpGEO ;



	// Do some final parenting
	if (objExists("grpMUSCLES") != true)
	{
		group -em -w -n ("grpMUSCLES") ;	
	}
	parent $grpRig "grpMUSCLES" ;


	setAttr ($grpLocsBase+".v") 0 ;	// Hide bases!

	select -r $objs ;

	string $results[] ;
	clear $results ;

	$results[0] = $def ;
	$results[1] = $locA ;
	$results[2] = $locB ;
	$results[3] = $locC ;
	$results[4] = $locABase ;
	$results[5] = $locBBase ;
	$results[6] = $locCBase ;



	print (uiRes("m_cMuscle.kSetupMuscleStrech")) ;

	return $results ;
}

// --------------------------------------------------------------------------

/* 
 * cMuscle_getMusIndex() - Given a muscle and a system node, this will return
 *	the muscleData[] index # that the muscle is connected to on the system,
 *	otherwise it returns -1.
 */
global proc int cMuscle_getMusIndex(string $mO, string $mS)
{
	if ($mO == "" || $mS == "")
		return -1 ;

	if (nodeType($mO) != "cMuscleObject")
		return -1 ;
	if (nodeType($mS) != "cMuscleSystem")
		return -1 ;


	string $mOs[] = `cMuscleQuery -system $mS -muscle` ;	// Get muscle
	int $idxs[] = `cMuscleQuery -system $mS -muscle -index` ;	// And index connected into
	int $i ;
	int $idx = -1;
	// Find matching mus....
	for ($i=0; $i < size($mOs); ++$i)
	{
		if ($mO == $mOs[$i])
		{
			$idx = $idxs[$i];
			return $idx ;
		}
	}


	return -1 ;
}


// --------------------------------------------------------------------------


/* 
 * cMuscle_getDirIndex() - Given a dir and a system node, this will return
 *	the dirData[] index # that the dir is connected to on the system,
 *	otherwise it returns -1.
 */
global proc int cMuscle_getDirIndex(string $mDir, string $mS)
{
	if ($mDir == "" || $mS == "")
		return -1 ;

	if (nodeType($mDir) != "cMuscleDirection")
		return -1 ;
	if (nodeType($mS) != "cMuscleSystem")
		return -1 ;


	string $mDs[] = `cMuscleQuery -system $mS -direction` ;	// Get direction
	int $idxs[] = `cMuscleQuery -system $mS -direction -index` ;	// And index connected into
	int $i ;
	int $idx = -1;
	// Find matching dir....
	for ($i=0; $i < size($mDs); ++$i)
	{
		if ($mDir == $mDs[$i])
		{
			$idx = $idxs[$i];
			return $idx ;
		}
	}

	return -1 ;
}

// --------------------------------------------------------------------------


/* 
 * cMuscle_getSmartCollideIndex() - Given a smartcollide and a system node, this will return
 *	the smartCollideData[] index # that the smartcollide is connected to on the system,
 *	otherwise it returns -1.
 */
global proc int cMuscle_getSmartCollideIndex(string $mSmart, string $mS)
{
	if ($mSmart == "" || $mS == "")
		return -1 ;

	if (nodeType($mSmart) != "cMuscleSmartCollide")
		return -1 ;
	if (nodeType($mS) != "cMuscleSystem")
		return -1 ;


	string $mSs[] = `cMuscleQuery -system $mS -smartcollide` ;      // Get smartcollide
	int $idxs[] = `cMuscleQuery -system $mS -smartcollide -index` ;	// And index connected into
	int $i ;
	int $idx = -1;
	// Find matching dir....
	for ($i=0; $i < size($mSs); ++$i)
	{
		if ($mSmart == $mSs[$i])
		{
			$idx = $idxs[$i];
			return $idx ;
		}
	}

	return -1 ;
}


// --------------------------------------------------------------------------

/*
 * cMuscle_bindStickySel() - Does a sticky bind for all selected muscles
 *	to all the selected muscle systems.
 */
global proc cMuscle_bindStickySel()
{

	string $objs[] = `ls -sl`;

	if (size($objs) <= 0)
		error -sl 0 (uiRes("m_cMuscle.kMustSelectMuscleObjectsAndMuscleSystemDeformerOrGeometry4")) ;


	string $mOs[] = `listRelatives -shapes -ni -type "cMuscleObject" $objs`;
	string $hist[] = `listHistory -pdo true -il 1 $objs`;
	string $mSs[] = `ls -type "cMuscleSystem" $hist` ;
	$mSs = stringArrayRemoveDuplicates($mSs) ;


	if (size($mOs) <= 0)
		error -sl 0 (uiRes("m_cMuscle.kMustSelectMuscleObject5")) ;

	if (size($mSs) <= 0)
		error -sl 0 (uiRes("m_cMuscle.kMustSelectMuscleSystem10")) ;


	// Default NURBs dist
	float $maxDist = -1 ;

	string $mO ;
	int $hasNURBs = 0 ;
	float $avgDist = 0.0 ;
	for ($mO in $mOs)	// each muscleObject
	{
		if (`getAttr ($mO+".type")` == 1)
		{
			$avgDist += cMuscle_autoCalcStickyBindDistance($mO) ;
			++$hasNURBs ;
			break ;
		}
	}


	int $distMode = 0 ;		// 0=bind all,  1=calc 2=use specified

	// Only query for Max Dist if adding NURBs in.
	if ($hasNURBs)
	{
		$avgDist = $avgDist / $hasNURBs ;	// average dist

		string $labelAutoCalculate = (uiRes("m_cMuscle.kAutoCalculate2"));
		string $labelAvgValue = (uiRes("m_cMuscle.kAvgValue2"));
		string $labelAllPoints = (uiRes("m_cMuscle.kAllPoints2")); 
		string $labelCancel = (uiRes("m_cMuscle.kCancel3"));
		string $result = `promptDialog 
							-title (uiRes("m_cMuscle.kStickyBindMaximumDistance2"))
							-message (uiRes("m_cMuscle.kMaxDistanceFromCenterOfMuscle2"))
							-text $avgDist
							-button $labelAutoCalculate
							-button $labelAvgValue
							-button $labelAllPoints
							-button $labelCancel
							-defaultButton $labelAutoCalculate 
							-cancelButton $labelCancel
							-dismissString $labelCancel
			`;

		if ($result == $labelCancel) 
			return ;

		$maxDist = `promptDialog -q -text` ;		// get as a float

		if ($result == $labelAllPoints || $maxDist == -1)
		{
			$distMode = 0 ;
			$maxDist = -1 ;
		}
		else if ($result == $labelAutoCalculate || $maxDist == 0)
		{
			$distMode = 1 ;
			$maxDist = 0 ;
		}
		else if ($result == $labelAvgValue)
		{
			$distMode = 2 ;
		}
		else
			return ;
	}



	for ($mO in $mOs)	// each muscleObject
	{
		// Calc best distance for this muscle if that is what we are doing....
		if ($distMode == 1)
			$maxDist = cMuscle_autoCalcStickyBindDistance($mO) ;

		string $mS ;
		for ($mS in $mSs)	// each muscleSystem
		{
			cMuscle_bindSticky($mO, $mS, $maxDist) ;
		} // end of each system
	} // end of each muscle
}

// --------------------------------------------------------------------------

/* 
 * cMuscle_bindSticky() - Given an actual muscleObject and System nodes,
 *	this binds the sticky data for it.
 */
global proc cMuscle_bindSticky(string $mO, string $mS, float $maxDist)
{
	// Make sure it's a type that needs binding...
	//
	int $type = `getAttr ($mO+".type")` ;	//what type of muscle?

	if ($type == 0 || $type == 2)	// skip poly/capsule..they don't get bound.
		return ;

	cMuscleBindSticky -system $mS -muscle $mO -d $maxDist ;

}

// --------------------------------------------------------------------------

/*
 * cMuscle_makeEndLenReader() - For a selected mO, make it have a nice
 *	locator to do end length calc and aiming.
 */
global proc cMuscle_makeEndLenReader()
{
	string $objs[] = `ls -sl -type "transform"` ;

	if (size($objs) <= 0)
		error -sl 0 (uiRes("m_cMuscle.kMustSelectMuscleToSetupEndFor")) ;


	string $mOs[] = `listRelatives -shapes -ni -type "cMuscleObject" $objs`;
	string $mO ;
	int $idx = 0 ;

	if (size($mOs) <= 0)
		error -sl 0 (uiRes("m_cMuscle.kMustSelectMuscleThatIsAlreadyMuscleObject")) ;


	for ($mO in $mOs)
	{
		string $xforms[] = `listRelatives -ni -parent $mO`;
		string $xform = $xforms[0] ;

		string $parents[] = `listRelatives -parent $xform` ;
		string $parent = $parents[0] ;


		// Make upper case version of xform name...
		int $len = size($xform);
		string $Xform = toupper( substring($xform, 1, 1)  );
		if ($len >= 2)
			$Xform += substring($xform, 2, $len) ;

		// Which axis is down length.
		int $nCapAxis = `getAttr ($mO+".capsuleAxis")`;

		string $locs[] = `spaceLocator` ;

		// Snap it!
		string $pcons[] = `pointConstraint $xform $locs[0]` ;
		string $ocons[] = `orientConstraint $xform $locs[0]` ;
		delete $pcons $ocons ;

		// move it out a bit
		float $fLen = `getAttr ($mO+".length")` ;
		if ($nCapAxis == 0)	// X-Axis length
			xform -r -os -t $fLen 0 0 $locs[0] ;
		else if ($nCapAxis == 1)	// Y-Axis length
			xform -r -os -t 0 $fLen 0 $locs[0] ;
		else if ($nCapAxis == 2)	//ZY-Axis length
			xform -r -os -t 0 0 $fLen $locs[0] ;
		else if ($nCapAxis == 3)	// Neg X-Axis length
			xform -r -os -t (-$fLen) 0 0 $locs[0] ;
		else if ($nCapAxis == 4)	// Neg Y-Axis length
			xform -r -os -t 0 (-$fLen) 0 $locs[0] ;
		else 				// Neg Z-Axis length
			xform -r -os -t 0 0 (-$fLen) $locs[0] ;

		connectAttr -f ($locs[0]+".worldMatrix") ($mO+".worldMatrixEnd") ;
		connectAttr -f ($mO+".lengthCalc") ($mO+".length") ;

		if ($nCapAxis == 0)	// X-Axis length
			aimConstraint -aim 1 0 0 -u 0 1 0 -wu 0 1 0 -wut "objectrotation" -wuo $locs[0] $locs[0] $xform ;
		else if ($nCapAxis == 1)	// Y-Axis length
			aimConstraint -aim 0 1 0 -u 0 0 1 -wu 0 0 1 -wut "objectrotation" -wuo $locs[0] $locs[0] $xform ;
		else if ($nCapAxis == 2)	// Z-Axis length
			aimConstraint -aim 0 0 1 -u 0 1 0 -wu 0 1 0 -wut "objectrotation" -wuo $locs[0] $locs[0] $xform ;
		else if ($nCapAxis == 3)	// Neg X-Axis length
			aimConstraint -aim -1 0 0 -u 0 1 0 -wu 0 1 0 -wut "objectrotation" -wuo $locs[0] $locs[0] $xform ;
		else if ($nCapAxis == 4)	// Neg Y-Axis length
			aimConstraint -aim 0 -1 0 -u 0 0 1 -wu 0 0 1 -wut "objectrotation" -wuo $locs[0] $locs[0] $xform ;
		else   					// Neg Z-Axis length
			aimConstraint -aim 0 0 -1 -u 0 1 0 -wu 0 1 0 -wut "objectrotation" -wuo $locs[0] $locs[0] $xform ;

		$locs[0] = `rename $locs[0] ("locAimTgt"+$Xform)`;

		if ($parent != "")
			parent $locs[0] $parent ;

		select -r $xform ;
	}



}

// --------------------------------------------------------------------------

/*
 * cMuscle_showHelp() - Show help
 */
global proc cMuscle_showHelp() 
{
	/*
	   string $paths[] = `cMuscleAbout -install` ;		// Where installed?
	   string $path = $paths[0] ;
	   print ("// Install Path is: "+$path+" //\n");

	   showHelp -a ("file:\\"+$path+"help\\index.html") ;
	 */	

	// Find where the plug-in is installed
	//
	string $pluginPath = `pluginInfo -query -path MayaMuscle`;
	string $delimiter = "/";
	if (`about -win`) {
		$delimiter = "\\";
	}
	string $pluginPaths[];
	tokenize ($pluginPath, $delimiter, $pluginPaths);
	// Result: /Volumes/Emerald/aw/branch/build/optim/Extra/BonusToolsPrivate/cMuscleSystem/plug-ins/MayaMuscle.bundle // 
	int $numPaths = size ($pluginPaths);
	$pluginPath = "";
	if ($numPaths > 2) $numPaths -= 2;
	for ($i = 0; $i < $numPaths; $i++) {
		$pluginPath = $pluginPath + $pluginPaths[$i] + $delimiter;
	}

	string $paths[];
	$paths[0] = $pluginPath;			// Where installed?
	string $path = "" ;

	//	print ("// Install Path is: "+$paths[0]+" //\n");

	// Now do all this so it works with Mozilla and such....
	// Thanks to Sunit Parekh for the fix.
	tokenize($paths[0], "\\", $paths) ;					// separate dir structure

	for ($i=0;$i<size($paths); ++$i)
	{
		if (gmatch($paths[$i], "* *"))					// find out if space exists
			$paths[$i] = `substitute " " $paths[$i] "%20"`;	// substitute the funny %20 thing
		$path=$path+$paths[$i]+"/";				// re-create the path string
	}

	showHelp -a ("file:///"+$path+"help/index.html");	

}

// --------------------------------------------------------------------------


/*
 * cMuscle_about() - Make about dlg
 */
global proc cMuscle_about()
{
}

// --------------------------------------------------------------------------

// --------------------------------------------------------------------------
//	Cache Procs
// --------------------------------------------------------------------------

// --------------------------------------------------------------------------

/*
 * cMuscle_makeCacheUI() - Little window to auto scrub time to generate cache.
 */
global proc cMuscle_makeCacheUI()
{
	if (`window -ex cMuscleCacheWin`)
	{
		showWindow cMuscleCacheWin ;
		return ;
	}

	window -w 260 -h 130 -s true -t (uiRes("m_cMuscle.kGeneralCache")) cMuscleCacheWin ;
	scrollLayout mainMakeCacheUIScrollLayout;
	formLayout -parent mainMakeCacheUIScrollLayout mainForm ;

	int $min = `playbackOptions -q -min` ;
	int $max = `playbackOptions -q -max` ;


	intFieldGrp -numberOfFields 1
		-label (uiRes("m_cMuscle.kStart"))
		-cw2 50 100 
		-value1 $min ifgStart ;

	intFieldGrp -numberOfFields 1
		-label (uiRes("m_cMuscle.kEnd"))
		-cw2 50 100 
		-value1 $max ifgEnd ;

	radioButtonGrp -l (uiRes("m_cMuscle.kCacheTo"))
		-nrb 2
		-la2 (uiRes("m_cMuscle.kExternalFile"))
		(uiRes("m_cMuscle.kNode"))
		-sl 2
		-cw3 80 100 60 rbgCacheTo ;

	checkBox -l (uiRes("m_cMuscle.kDeleteExtraPerPointSkinJiggleData")) -v 1 cbDelSkinJiggle ;

	button -l (uiRes("m_cMuscle.kGenerateCacheForObjects"))
		-c ("cMuscle_makeCache();")
		-ann (uiRes("m_cMuscle.kGenerateCacheForObjectsAnnot")) btnCache ; 

	formLayout -e
		-af ifgStart "top" 5 
		-an ifgStart "bottom" 
		-af ifgStart "left" 5 
		-ap ifgStart "right" 0 50 

		-af ifgEnd "top" 5 
		-an ifgEnd "bottom" 
		-ap ifgEnd "left" 0 50
		-af ifgEnd "right" 5 

		-ac rbgCacheTo "top" 5 ifgStart  
		-an rbgCacheTo "bottom" 
		-af rbgCacheTo "left" 5
		-af rbgCacheTo "right" 5 

		-ac cbDelSkinJiggle "top" 5 rbgCacheTo  
		-an cbDelSkinJiggle "bottom" 
		-af cbDelSkinJiggle "left" 5
		-af cbDelSkinJiggle "right" 5 


		-ac btnCache "top" 5 cbDelSkinJiggle  
		-an btnCache "bottom" 
		-af btnCache "left" 5
		-af btnCache "right" 5 

		mainForm ;



	showWindow cMuscleCacheWin;


}


// --------------------------------------------------------------------------

/*
 * cMuscle_makeCache() - Create a cache.
 */
global proc cMuscle_makeCache()
{
	int $min = `intFieldGrp -q -v1 ifgStart` ;	
	int $max = `intFieldGrp -q -v1 ifgEnd` ;
	int $cacheTo = `radioButtonGrp -q -sl rbgCacheTo` ;
	int $bDelSkinJiggle = `checkBox -q -v cbDelSkinJiggle` ;

	string $strType = "" ;

	int $write =1;
	int $read =2;
	if ($cacheTo == 1)	// External File
	{
		$write = 1 ; 
		$read = 2 ; 
		$strType = "file" ;
	}
	else if ($cacheTo == 2)		// Node
	{
		$write = 3 ; 
		$read = 4 ; 
		$strType = "node" ;
	}

	if ($min > $max)
	{
		error -sl 0 (uiRes("m_cMuscle.kTheStartFrameMustBeLowerThanTheEndFrame")) ;
	}

	string $objs[] = `ls -sl`;

	if (size($objs) <= 0)
		error -sl 0 (uiRes("m_cMuscle.kMustSelectObjectWithMuscleSystemDeformer2")) ;

	// Look for a muscle system in what is chosen...
	string $hist[] = `listHistory -pdo true -il 1 $objs`;
	string $mSs[] = `ls -type "cMuscleSystem" $hist` ;
	string $mS;

	$mSs = stringArrayRemoveDuplicates($mSs) ;

	if (size($mSs) <= 0)
		error -sl 0 (uiRes("m_cMuscle.kMustSelectMuscleSystem11")) ;


	// Blow away the window
	deleteUI -wnd cMuscleCacheWin ;

	// Now use plugin command instead...
	select -r $objs ;
	cMuscleCache -s $min -e $max -mode $strType $mSs ;		// Execute cache for Muscle System nodes	

	select -r $objs ;

	// Blow away jiggle cache if desired!
	if ($bDelSkinJiggle)
		cMuscle_delSkinJiggleCache($min, $max) ;

	select -r $objs ;

	string $msg = (uiRes("m_cMuscle.kMuscleGeneratedCacheForFrameMinToMax"));
	$msg = `format -stringArg $min -stringArg $max $msg`;
	print ($msg) ;
}

// --------------------------------------------------------------------------

/*
 * cMuscle_deleteNodeCacheUI() - Little window to choose what node cache frames to delete
 */
global proc cMuscle_deleteNodeCacheUI()
{
	if (`window -ex cMuscleDeleteCacheWin`)
	{
		showWindow cMuscleDeleteCacheWin ;
		return ;
	}

	window -w 260 -h 90 -s true -t (uiRes("m_cMuscle.kDeleteCache")) cMuscleDeleteCacheWin ;
	scrollLayout mainDeleteNodeCacheUIScrollLayout;
	formLayout -parent mainDeleteNodeCacheUIScrollLayout mainForm ;

	int $min = `playbackOptions -q -min` ;
	int $max = `playbackOptions -q -max` ;


	intFieldGrp -numberOfFields 1
		-label (uiRes("m_cMuscle.kStart2"))
		-cw2 50 100 
		-value1 $min ifgDelStart ;

	intFieldGrp -numberOfFields 1
		-label (uiRes("m_cMuscle.kEnd2"))
		-cw2 50 100 
		-value1 $max ifgDelEnd ;


	button -l (uiRes("m_cMuscle.kDeleteNodeCacheForObjects")) 
		-c ("cMuscle_delNodeCache();") 
		-ann (uiRes("m_cMuscle.kDeleteNodeCacheForObjectsAnnot")) btnDelCache ; 

	formLayout -e
		-af ifgDelStart "top" 5 
		-an ifgDelStart "bottom" 
		-af ifgDelStart "left" 5 
		-ap ifgDelStart "right" 0 50 

		-af ifgDelEnd "top" 5 
		-an ifgDelEnd "bottom" 
		-ap ifgDelEnd "left" 0 50
		-af ifgDelEnd "right" 5 

		-ac btnDelCache "top" 5 ifgDelStart  
		-an btnDelCache "bottom" 
		-af btnDelCache "left" 5
		-af btnDelCache "right" 5 

		mainForm ;



	showWindow cMuscleDeleteCacheWin;


}

// --------------------------------------------------------------------------

/*
 * cMuscle_delNodeCache() - Deletes node cache 
 */
global proc cMuscle_delNodeCache()
{
	int $min = `intFieldGrp -q -v1 ifgDelStart` ;	
	int $max = `intFieldGrp -q -v1 ifgDelEnd` ;

	if ($min > $max)
	{
		error -sl 0 (uiRes("m_cMuscle.kTheStartFrameMustBeLowerThanTheEndFrame2")) ;
	}

	string $objs[] = `ls -sl`;

	if (size($objs) <= 0)
		error -sl 0 (uiRes("m_cMuscle.kMustSelectObjectWithMuscleSystemDeformer3")) ;

	// Look for a muscle system in what is chosen...
	string $hist[] = `listHistory -pdo true -il 1 $objs`;
	string $mSs[] = `ls -type "cMuscleSystem" $hist` ;
	string $mS;

	$mSs = stringArrayRemoveDuplicates($mSs) ;

	if (size($mSs) <= 0)
		error -sl 0 (uiRes("m_cMuscle.kMustSelectMuscleSystem12")) ;

	waitCursor -state on ;

	for ($mS in $mSs)
	{
		// Turn all caches to disabled...
		setAttr ($mS+".cache") 0; 		// Disabled

		int $t ;
		for ($t=$min; $t <= $max; ++$t)
		{
			// Blow away each cache frame data	 ADD MAX_NEG_FRAMES which is 1024
			removeMultiInstance ($mS+".cacheFrame["+($t+1024)+"]") ;
		}

	}

	waitCursor -state off ;


	// Blow away the window
	deleteUI -wnd cMuscleDeleteCacheWin ;
}

// --------------------------------------------------------------------------


/*
 * cMuscle_chooseCacheFile() - Use the nicer Maya file browser....
 */
global proc cMuscle_chooseCacheFile()
{
	// See the top of fileBrowser.mel in Maya for info.
	// Basically you call :
	//		fileBrowser( string $procCB, string $action, string $type, int $mode) ;
	//
	//  $procCB = callback proc to be invoked when the action button is pressed
	//  $action = label of the button in the browser that will do something, like "Load" or "Save"
	//  $type   = File type to be used... like *.mel
	//  $mode   = 0=read 1=write 2=write (no paths)  4=Read dir's only
	//
	//
	//  The Callback proc must take two strings, and return an int
	// ie:
	//	global proc int fileProcCB(string $file, string $type) 
	//
	//   $file  = file or dir that was chosen
	//   $type  = type of file
	//     Returns 1 if dialog should close and success, 0 if keep open and fail.
	//
	//  Finally another useful items is: 
	//		global string $gDefaultFileBrowserDir;
	//
	//	This will put the filebrowser to point to the path.  Useful to make
	//	it go somewhere right before the initial fileBrowser call.
	//
	global string $gDefaultFileBrowserDir;

	string $os = `about -os` ;

	string $objs[] = `ls -sl`;
	if (size($objs) <= 0)
		error -sl 0 (uiRes("m_cMuscle.kMustSelectObjectWithMuscleSystemDeformer4")) ;
	// Look for a muscle system in what is chosen...
	string $hist[] = `listHistory -pdo true -il 1 $objs`;
	string $mSs[] = `ls -type "cMuscleSystem" $hist` ;
	string $mS = $mSs[0] ;
	if ($mS == "")
		error -sl 0 (uiRes("m_cMuscle.kMustSelectObjectWithMuscleSystemDeformer5")) ;


	string $curFile = `getAttr ($mS+".cachePath")` ;
	string $dir = dirname($curFile) ;

	if ($dir != "")
	{
		if ($os == "nt")
			; // For some reason maya gives error in fileBrowser.mel in windows
		else
			pv_goDirectory($dir) ;			// And start in that place...
	}

	fileBrowser( "cMuscle_chooseCacheFileCB", (uiRes("m_cMuscle.kChoose")), "*.*", 1) ;

}

// --------------------------------------------------------------------------

/*
 * cMuscle_chooseCacheFileCB() - Callback proc for fileBrowser call.
 */
global proc int cMuscle_chooseCacheFileCB(string $file, string $type)
{
	string $objs[] = `ls -sl`;
	if (size($objs) <= 0)
		error -sl 0 (uiRes("m_cMuscle.kMustSelectObjectWithMuscleSystemDeformer6")) ;
	// Look for a muscle system in what is chosen...
	string $hist[] = `listHistory -pdo true -il 1 $objs`;
	string $mSs[] = `ls -type "cMuscleSystem" $hist` ;
	string $mS = $mSs[0] ;
	if ($mS == "")
		error -sl 0 (uiRes("m_cMuscle.kMustSelectObjectWithMuscleSystemDeformer7")) ;


	setAttr -type "string" ($mS+".cachePath") $file ;

	return 1 ;
}


// --------------------------------------------------------------------------


/*
 * cMuscle_deleteSkinJiggleCacheUI() - Little window to choose what skin jiggle cache frames to delete
 */
global proc cMuscle_deleteSkinJiggleCacheUI()
{
	if (`window -ex cMuscleDeleteSkinJiggleCacheWin`)
	{
		showWindow cMuscleDeleteSkinJiggleCacheWin ;
		return ;
	}

	window -w 260 -h 90 -s true -t (uiRes("m_cMuscle.kDeleteSkinJiggle")) cMuscleDeleteSkinJiggleCacheWin ;
	scrollLayout mainDeleteSkinJiggleCacheUIScrollLayout;
	formLayout -parent mainDeleteSkinJiggleCacheUIScrollLayout mainForm ;

	int $min = `playbackOptions -q -min` ;
	int $max = `playbackOptions -q -max` ;


	intFieldGrp -numberOfFields 1
		-label (uiRes("m_cMuscle.kStart3"))
		-cw2 50 100 
		-value1 $min ifgDelStart ;

	intFieldGrp -numberOfFields 1
		-label (uiRes("m_cMuscle.kEnd3"))
		-cw2 50 100 
		-value1 $max ifgDelEnd ;


	button -l (uiRes("m_cMuscle.kDeletePerPointSkinJiggleForSelectedObjects")) 
		-c ("cMuscle_delSkinJiggleCacheCB();") 
		-ann (uiRes("m_cMuscle.kDeletePerPointSkinJiggleForSelectedObjectsAnnot")) btnDelCache ; 

	formLayout -e
		-af ifgDelStart "top" 5 
		-an ifgDelStart "bottom" 
		-af ifgDelStart "left" 5 
		-ap ifgDelStart "right" 0 50 

		-af ifgDelEnd "top" 5 
		-an ifgDelEnd "bottom" 
		-ap ifgDelEnd "left" 0 50
		-af ifgDelEnd "right" 5 

		-ac btnDelCache "top" 5 ifgDelStart  
		-an btnDelCache "bottom" 
		-af btnDelCache "left" 5
		-af btnDelCache "right" 5 

		mainForm ;



	showWindow cMuscleDeleteSkinJiggleCacheWin;
}

// --------------------------------------------------------------------------

/*
 * cMuscle_delSkinJiggleCacheCB() - Callback to Delete skin Jiggle cache 
 */
global proc cMuscle_delSkinJiggleCacheCB()
{
	int $min = `intFieldGrp -q -v1 ifgDelStart` ;	
	int $max = `intFieldGrp -q -v1 ifgDelEnd` ;

	if ($min > $max)
	{
		warning -sl 0 (uiRes("m_cMuscle.kTheStartFrameMustBeLowerThanTheEndFrame3")) ;
		return ;
	}

	cMuscle_delSkinJiggleCache($min, $max) ;	// Do it!

	// Blow away the window
	deleteUI -wnd cMuscleDeleteSkinJiggleCacheWin ;

}

// --------------------------------------------------------------------------

/*
 * cMuscle_delSkinJiggleCache() - Deletes skin Jiggle cache 
 */
global proc cMuscle_delSkinJiggleCache(int $min, int $max)
{
	string $objs[] = `ls -sl`;

	if (size($objs) <= 0)
	{
		warning -sl 0 (uiRes("m_cMuscle.kMustSelectObjectWithMuscleSystemDeformer8")) ;
		return ;
	}

	// Look for a muscle system in what is chosen...
	string $hist[] = `listHistory -pdo true -il 1 $objs`;
	string $mSs[] = `ls -type "cMuscleSystem" $hist` ;
	string $mS;

	$mSs = stringArrayRemoveDuplicates($mSs) ;

	if (size($mSs) <= 0)
	{
		warning -sl 0 (uiRes("m_cMuscle.kMustSelectMuscleSystem13")) ;
		return ;
	}

	waitCursor -state on ;

	for ($mS in $mSs)
	{
		int $t ;
		for ($t=$min; $t <= $max; ++$t)
		{
			// Blow away each cache frame data	 ADD MAX_NEG_FRAMES which is 1024
			removeMultiInstance ($mS+".jiggleFrame["+($t+1024)+"]") ;
		}

	}

	waitCursor -state off ;

}


// --------------------------------------------------------------------------

// --------------------------------------------------------------------------
//	Surf Attach Procs
// --------------------------------------------------------------------------

/*
 * cMuscleSurfAttachSetup() - Sets up the attach.
 */
global proc cMuscleSurfAttachSetup()
{
	string $sels[] = `ls -fl -sl` ;
	string $sel ;
	string $parts[] ;

	string $made[] ; 
	clear $made ;

	int $nSels = size($sels) ;
	int $i ;
	for ($i=0; $i < $nSels; ++$i)
	{
		string $sel = $sels[$i] ;

		if (gmatch($sel, "*.uv*"))
		{
			tokenize($sel, "[]", $parts) ;
			float $u = $parts[1] ;
			float $v = $parts[2] ;
			tokenize($sel, ".", $parts) ;
			string $obj = $parts[0] ;

			string $node = `createNode "cMuscleSurfAttach" -n "cMuscleSurfAttachShape#"` ;
			string $xforms[] = `listRelatives -parent $node` ;
			string $xform = $xforms[0] ;
			$made[size($made)] = $xform ; 

			connectAttr -f ($obj+".worldSpace") ($node+".surfIn") ;
			connectAttr -f ($xform+".rotateOrder") ($node+".inRotOrder") ;
			setAttr ($node+".uLoc") $u ;
			setAttr ($node+".vLoc") $v ;

			connectAttr -f ($node+".outTranslate") ($xform+".translate") ;
			connectAttr -f ($node+".outRotate") ($xform+".rotate") ;

			// And group nicely for nice rigging....
			//
			if (objExists("grpSurfAttachRIG") != true)
			{
				group -em -w -n ("grpSurfAttachRIG") ;
				setAttr ("grpSurfAttachRIG.inheritsTransform") 0 ;
			}
			setAttr ($xform+".inheritsTransform") 0 ;
			parent $xform "grpSurfAttachRIG" ;

			string $msg = (uiRes("m_cMuscle.kSetUpNURBSAttachForSelection"));
			$msg = `format -stringArg $sel $msg`;
			print ($msg) ;
		}
		else if (gmatch($sel, "*.f*"))
		{
			tokenize($sel, ".", $parts) ;
			string $obj = $parts[0] ;

			// Get face as edges
			string $results[] = `polyInfo -faceToEdge $sel` ;
			// results[0]= FACE    175:    175    575    195    576
			clear $parts ;
			tokenize($results[0], ":", $parts) ;
			string $idxsStr = $parts[1] ;
			clear $parts ;
			tokenize($idxsStr, $parts) ;
			int $idx1 = (int)$parts[0] ;
			int $idx2 = (int)$parts[2] ;

			// Make da node....

			string $node = `createNode "cMuscleSurfAttach" -n "cMuscleSurfAttachShape#"` ;
			string $xforms[] = `listRelatives -parent $node` ;
			string $xform = $xforms[0] ;
			$made[size($made)] = $xform ; 

			connectAttr -f ($obj+".worldMesh") ($node+".surfIn") ;
			connectAttr -f ($xform+".rotateOrder") ($node+".inRotOrder") ;
			setAttr ($node+".uLoc") 0.5 ;
			setAttr ($node+".vLoc") 0.5 ;
			setAttr ($node+".edgeIdx1") $idx1 ;
			setAttr ($node+".edgeIdx2") $idx2 ;

			connectAttr -f ($node+".outTranslate") ($xform+".translate") ;
			connectAttr -f ($node+".outRotate") ($xform+".rotate") ;

			// And group nicely for nice rigging....
			//
			if (objExists("grpSurfAttachRIG") != true)
			{
				group -em -w -n ("grpSurfAttachRIG") ;
				setAttr ("grpSurfAttachRIG.inheritsTransform") 0 ;
			}
			setAttr ($xform+".inheritsTransform") 0 ;
			parent $xform "grpSurfAttachRIG" ;

			string $msg = (uiRes("m_cMuscle.kSetUpPolygonMeshAttachForSelectionEdgeEdge"));
			$msg = `format -stringArg $sel -stringArg $idx1 -stringArg $idx2 $msg`;
			print ($msg) ;
		}
		else if (gmatch($sel, "*.e*"))
		{
			tokenize($sel, ".", $parts) ;
			string $obj = $parts[0] ;

			clear $parts ;
			tokenize($sel, "[]", $parts) ;
			int $idx1 = (int)$parts[1] ;

			// Get next sel edge too
			++$i ;
			string $sel2 = $sels[$i] ;
			clear $parts ;
			tokenize($sel2, "[]", $parts) ;
			int $idx2 = (int)$parts[1] ;

			// Make da node....

			string $node = `createNode "cMuscleSurfAttach" -n "cMuscleSurfAttachShape#"` ;
			string $xforms[] = `listRelatives -parent $node` ;
			string $xform = $xforms[0] ;
			$made[size($made)] = $xform ; 

			connectAttr -f ($obj+".worldMesh") ($node+".surfIn") ;
			connectAttr -f ($xform+".rotateOrder") ($node+".inRotOrder") ;
			setAttr ($node+".uLoc") 0.5 ;
			setAttr ($node+".vLoc") 0.5 ;
			setAttr ($node+".edgeIdx1") $idx1 ;
			setAttr ($node+".edgeIdx2") $idx2 ;

			connectAttr -f ($node+".outTranslate") ($xform+".translate") ;
			connectAttr -f ($node+".outRotate") ($xform+".rotate") ;

			// And group nicely for nice rigging....
			//
			if (objExists("grpSurfAttachRIG") != true)
			{
				group -em -w -n ("grpSurfAttachRIG") ;
				setAttr ("grpSurfAttachRIG.inheritsTransform") 0 ;
			}
			setAttr ($xform+".inheritsTransform") 0 ;
			parent $xform "grpSurfAttachRIG" ;

			string $msg = (uiRes("m_cMuscle.kSetUpPolygonMeshAttachForSelSelEdgeEdge"));
			$msg = `format -stringArg $sel -stringArg $sel2 -stringArg $idx1 -stringArg $idx2 $msg`;
			print ($msg) ;
		}
	}


	// Select em at the end!
	if (size($made) > 0)
		select -r $made ;
}


// --------------------------------------------------------------------------


/*
 * cMuscle_fixSurfAttachForPolySmooth() - Main Entry
 */
global proc cMuscle_fixSurfAttachForPolySmooth()
{
	// Get all surf attach nodes...or transforms that could have them underneath...
	string $sel[] = `ls -type "cMuscleSurfAttach" -type "transform" -sl` ;

	string $infos[] ;
	string $info ;

	string $s ;
	for ($s in $sel)
	{
		if (nodeType($s) == "cMuscleSurfAttach")
			$infos[size($infos)] = $s ;
		else
		{
			// See if there is a surf attach shape under
			string $shapes[] = `listRelatives -ni -shapes $s` ;
			string $sh;
			for ($sh in $shapes)
			{
				if (nodeType($sh) == "cMuscleSurfAttach")
					$infos[size($infos)] = $sh ;
			}
		}
	}

	if (size($infos) <= 0)
		error -sl 0 (uiRes("m_cMuscle.kMustSelectOneOrMoreMuscleSurfAttachNodesToFix")) ;

	string $toDelete[] ;
	clear $toDelete ;

	// Check each one....
	for ($info in $infos)
	{
		//		print ("// Checking "+$info+"...") ;


		// Get current shape into surfAttach.
		string $curCons[] = `listConnections -s 1 -d 0 -p 1 -scn 1 ($info+".surfIn")`;
		string $parts[] ;
		tokenize($curCons[0], ".", $parts) ;

		if (nodeType($parts[0]) != "mesh")
			continue ;

		// Get XForm of shape
		select -r $parts[0] ;
		pickWalk -d up ;
		string $xforms[] = `ls -sl` ;
		string $xform = $xforms[0] ;

		//		print ("  XForm="+$xform+"  ") ;

		if ($xform != "")		// This should NEVER be the case, ie: we ought to be deforming something!
		{
			string $shapes[] = `listRelatives -shapes -ni $xform` ;
			//			print (" $shapes[0]="+$shapes[0]+" ") ;

			string $shapeSurfAttach = "" ;	// Special shape node just for surfAttach.
			if (objExists($shapes[0]+".msgSurfAttachShape"))
			{
				// Must do with -p 1 so we get shape name not transform!
				string $cmsg[] = `listConnections -s 1 -d 0 -p 1 -scn 1 ($shapes[0]+".msgSurfAttachShape")` ;
				string $parts[] ;
				tokenize($cmsg[0], ".", $parts) ;
				$shapeSurfAttach = $parts[0] ;
			}
			else
				addAttr -ln "msgSurfAttachShape" -at "message" $shapes[0] ;	// If not yet made, make one.



			string $hist[] = `listHistory -pdo 1 -il 2 $shapes[0]` ;
			int $nH = size($hist) ;
			// Result: polySmoothFace2 polySmoothFace1 polyTorus1 //
			int $idx ;
			int $smoothIdx = -1 ;


			// Work backwards...actually fwd from earliest history to later history.
			// We want to find the earliest/first poly smooth node.	
			for ($idx = $nH-1; $idx >= 0; --$idx)
			{
				// If it is a polySmooth..keep goind back in history.
				if (nodeType($hist[$idx]) == "polySmoothFace")
				{
					$smoothIdx = $idx ;		// We got on abort!
					break ;
				}
			}

			// We have a poly smooth node, we have it's index...
			// Make sure there is something at the end higher index 
			// that is connecetd in, we'll change to be connected to that.
			if ($smoothIdx != -1)
			{
				// What is driving this poly mesh?
				string $consFrom[] = `listConnections -s 1 -d 0 -p 1 -scn 1 ($hist[$smoothIdx]+".inputPolymesh")` ;

				// First make a shape surfAttach node if needed!
				if ($shapeSurfAttach == "")
				{
					// Make a new shape under same xform
					$shapeSurfAttach = `createNode "mesh" -p $xform` ;
					string $xformNoColon = `substitute ":" $xform "_"`; 
					$shapeSurfAttach = `rename $shapeSurfAttach ("meshSurfAttach"+$xformNoColon+"Shape")` ;	// Do this separate so it works...
					setAttr ($shapeSurfAttach+".intermediateObject")  1 ;	// Make it invisible and intermediate.
					connectAttr -f ($shapeSurfAttach+".message") ($shapes[0]+".msgSurfAttachShape") ;
				}

				// Now see what is currently into the shape surfAttach mesh....
				string $curConsShape[] = `listConnections -s 1 -d 0 -p 1 -scn 1 ($shapeSurfAttach+".inMesh")` ;					

				// Connect real thing we want into the shape node.
				if ($curConsShape[0] != $consFrom[0])
					connectAttr -f $consFrom[0] ($shapeSurfAttach+".inMesh") ;


				// Connect output of temp surfAttach shape to the surfAttach.
				if ($curCons[0] != ($shapeSurfAttach+".worldMesh"))
					connectAttr -f ($shapeSurfAttach+".worldMesh") ($info+".surfIn") ;

				string $msg = (uiRes("m_cMuscle.kFixedConsFromShapeSurfAttachWorldMeshInfoSurfIn"));
				$msg = `format -stringArg $consFrom[0] -stringArg $shapeSurfAttach -stringArg $info $msg`;
				print ($msg ) ;
			} // end of if have a smooth
			else
			{

				// Don't do this right away since OTHER rivets might still be using it....
				// But later blow away specific surfAttach shape, we don't need it.
				if ($shapeSurfAttach != "")
				{
					$toDelete[size($toDelete)] = $shapeSurfAttach ;
					$shapeSurfAttach = "" ;
				}


				// Connect directly from "real" shape into the surfAttach.
				if ($curCons[0] != ($shapes[0]+".worldMesh"))			
					connectAttr -f ($shapes[0]+".worldMesh") ($info+".surfIn") ;

				string $msg = (uiRes("m_cMuscle.kFinalGeoShapesWorldMeshInfoSurfIn"));
				$msg = `format -stringArg $shapes[0] -stringArg $info $msg`;
				print ($msg) ;
			}


		} // end of each cons not empty
		else
		{
			string $msg = (uiRes("m_cMuscle.kWarningInfoHasNoSurfInToXFormConnection"));
			$msg = `format -stringArg $info $msg`;
			print ($msg) ;
		}	
	} // end of each info node


	$toDelete = stringArrayRemoveDuplicates($toDelete) ;
	if (size($toDelete) > 0)
	{
		print (uiRes("m_cMuscle.kDeletingUnneededShapeSurfAttachNodes")) ;

		string $del ;
		for ($del in $toDelete)
		{
			if (objExists($del) != true)
				continue ;

			// Does this thing have ANY outgoing connections, if so, it probably still has
			// at least some surfAttach nodes tied to it, so leave it alone....
			string $outs[] = `listConnections -s 0 -d 1 -p 1 -scn 1 -type "cMuscleSurfAttach" ($del)` ;	
			if (size($outs) > 0)
				continue ;

			print ($del+" ") ;
			delete $del ;
		}
		print ("\n") ;
	}


	// Restore orig sel		
	select -r $sel ;	
}



// --------------------------------------------------------------------------

/*
 * cMuscle_capsuleToPolyCyl() - Generates a poly cylinder from a capsule for rendering.
 */
global proc cMuscle_capsuleToPolyCyl()
{
	string $objs[] = `ls -sl` ;
	string $obj ;

	string $cylNew[] ;
	clear $cylNew ;

	for ($obj in $objs)
	{
		string $mO = "" ;
		if (nodeType($obj) == "cMuscleObject")
			$mO = $obj ;
		else if (nodeType($obj) == "transform" || nodeType($obj) == "joint")
		{
			string $shapes[] = `listRelatives -ni -shapes $obj` ;
			string $shape ;
			for ($shape in $shapes)
			{
				if (nodeType($shape) == "cMuscleObject")
				{
					$mO = $shape ;
					break ;
				}
			}
		}

		if ($mO == "")
			continue ;
		int $type = `getAttr ($mO+".type")` ;
		if ($type != 2)  // capsule
			continue ;
		string $xforms[] = `listRelatives -parent $mO` ;
		string $xform = $xforms[0] ;
		string $msg = (uiRes("m_cMuscle.kCapsuleMuscleObjectXForm"));
		$msg = `format -stringArg $mO -stringArg $xform $msg`;
		print ($msg) ;

		// Generate direction of cyl
		int $axis = `getAttr ($mO+".capsuleAxis")` ;
		float $dir[3] = {0.0, 0.0, 0.0} ;
		if ($axis <= 2)
			$dir[$axis] = 1.0 ;
		else
			$dir[$axis-3] = -1.0 ;

		float $rad = `getAttr ($mO+".radius")` ;
		float $len = `getAttr ($mO+".length")` ;
		float $nSeg = `getAttr ($mO+".nSeg")` ;
		float $nSides = `getAttr ($mO+".nSides")` ;

		if ($len+($rad*2) <= 0.0)
			continue ;

		string $cyls[] = `polyCylinder -r $rad -h ($len+($rad*2)) -sx $nSides -sy $nSeg -sz 0 -ax $dir[0] $dir[1] $dir[2] -tx 1 -ch 0` ;
		string $name = ($xform+"PolyCyl") ;
		if (objExists($name))
			delete $name ;
		string $cyl = `rename $cyls[0] $name`;
		$cylNew[size($cylNew)] = $cyl ;

		string $pcons[] = `pointConstraint $xform $cyl` ;		// snap
		string $ocons[] = `orientConstraint $xform $cyl` ;
		delete $pcons $ocons ;

		parent $cyl $xform ;		// Parent up...

		// Now since the cyl has the axis in the center...offset right dir by half len
		xform -r -os -t ($dir[0]*$len*0.5) ($dir[1]*$len*0.5) ($dir[2]*$len*0.5) $cyl ;

		// Also make a material for it.
		float $colR = `getAttr ($mO+".shadecolorR")` ;
		float $colG = `getAttr ($mO+".shadecolorG")` ;
		float $colB = `getAttr ($mO+".shadecolorB")` ;

		string $matName = ("mat"+$xform+"PolyCyl") ;
		if (objExists($matName))
			delete $matName ;
		string $matSGName = ($matName+"SG") ;
		if (objExists($matSGName))
			delete $matSGName ;

		string $mat = `shadingNode -asShader blinn`;
		string $mat = `rename $mat $matName` ;

		sets -renderable true -noSurfaceShader true -empty -name ($mat+"SG") ;
		connectAttr -f ($mat+".outColor") ($mat+"SG.surfaceShader") ;

		setAttr ($mat+".color") -type double3 $colR $colG $colB ;
		setAttr ($mat+".specularColor") -type double3 0.2 0.2 0.2 ;
		setAttr ($mat+".reflectivity") 0.0 ;
		setAttr ($mat+".specularRollOff") 0.25 ;
		setAttr ($mat+".eccentricity") 0.60 ;
		// Apply material        
		select -r $cyl ;
		sets -e -forceElement ($mat+"SG");    


	}


	// Select newly created poly cyls at end.
	if (size($cylNew) > 0)
		select -r $cylNew ;

	print (uiRes("m_cMuscle.kGeneratedPolyCylindersFromCapsules")) ;
}


// --------------------------------------------------------------------------

// --------------------------------------------------------------------------
//	String Procs
// --------------------------------------------------------------------------

// --------------------------------------------------------------------------


/*
 * cMuscle_strSearchReplace() - Given a main string $str, looks for ALL occurances
 *	of $search, and replaces them with $replace.
 *
 *	This properly handles the replace string being similar or a part
 *	of the search string, and handling multiple matches.
 */
global proc string cMuscle_strSearchReplace(string $str, string $search, string $replace)
{
	string $retstr = "";

	// Sanity check please!
	if ($search == "")
		return $str;

	if ($str == "")
		return $str;

	int $len = size($str);
	int $lenS = size($search);

	int $i, $j;
	int $match;

	for ($i=1; $i <= $len; ++$i)
	{
		$match = 0;

		// Now get substring from where we are currently
		// to the number of letters past of the length
		// of the search string.  Basically the same
		// length as the search string.  So if it is identical
		// we know we have a match.
		//
		// If not, we don't.  We also make sure we aren't
		// trying to look past the end of the string...
		//
		$j = $i + ($lenS - 1);

		if ($j <= $len)
		{
			string $part = `substring $str $i $j`;
			if ($part == $search)
				$match = 1;
		}

		if ($match == 1)
		{
			$retstr += $replace; // we did it, so insert replace str
			$i = $j;	// skip forward
		}
		else
		{
			string $char = `substring $str $i $i`;
			$retstr += $char;
		}
	}

	return $retstr;

}

// --------------------------------------------------------------------------
//	cMuscleKeepOut procs
// --------------------------------------------------------------------------

// --------------------------------------------------------------------------

/*
 * cMuscle_keepOutAddRemMuscle() - 
 */
global proc cMuscle_keepOutAddRemMuscle(int $add)
{
	string $objs[] = `ls -sl` ;
	string $obj ;

	string $keepOuts[] ;
	string $muscles[] ;

	// Break selection into either keep out nodes or muscles
	for ($obj in $objs)
	{
		if (nodeType($obj) == "cMuscleObject")
		{
			$muscles[size($muscles)] = $obj ;
			continue ;
		}
		if (nodeType($obj) == "cMuscleKeepOut")
		{
			$keepOuts[size($keepOuts)] = $obj ;
			continue ;
		}


		string $mOs[] = `listRelatives -shapes -ni -type "cMuscleObject" $obj`;
		if (size($mOs) > 0 && $mOs[0] != "")
		{
			$muscles[size($muscles)] = $mOs[0] ;
			continue ;
		}

		string $kOs[] = `listRelatives -shapes -ni -type "cMuscleKeepOut" $obj`;
		if (size($kOs) > 0 && $kOs[0] != "")
		{
			$keepOuts[size($keepOuts)] = $kOs[0] ;
			continue ;
		}

		string $ko = cMuscle_getMessage($obj, "msgKeepOut") ;
		if ($ko != "")
		{
			$keepOuts[size($keepOuts)] = $ko ;
			continue ;
		}

	}

	if (size($keepOuts) <= 0)
		error -sl 0 (uiRes("m_cMuscle.kMustSelectMuscleKeepOutNodeOrControlThatWasRiggedWithMuscleKeepOut")) ;
	if (size($muscles) <= 0)
		error -sl 0 (uiRes("m_cMuscle.kMustSelectMuscleObject6")) ;

	string $k ;
	for ($k in $keepOuts)
	{
		string $m ;
		for ($m in $muscles)
		{
			cMuscle_keepOutLowLevelConnect($k, $m, $add) ;
		}
	}

	print (uiRes("m_cMuscle.kMuscleKeepOutConnectionsDone")) ;
}

// --------------------------------------------------------------------------

/* 
 * cMuscle_keepOutLowLevelConnect() - 
 */
global proc cMuscle_keepOutLowLevelConnect(string $keepOut, string $muscle, int $add)
{
	// Look thru all connections in the muscle node, and see if any of them
	//	are the keep out, and store if it is...
	//
	string $cons[] = `listConnections -s 1 -d 1 -p 1 -scn 1 ($muscle+".muscleData")` ;
	string $con ;
	string $conAlready = "" ;
	for ($con in $cons)
	{
		string $parts[] ;
		tokenize($con, ".", $parts) ;
		if ($parts[0] == $keepOut)
		{
			$conAlready = $con ;
			break ;	
		}
	}

	if ($add)
	{
		if ($conAlready != "")
		{
			string $msg = (uiRes("m_cMuscle.kMuscleAlreadyConnectedToKeepOutNode"));
			$msg = `format -stringArg $muscle -stringArg $keepOut $msg`;
			warning ($msg) ;	
			return ;
		}
		// Find next idx...ie: what next one has no connections...
		int $idx = 0;
		int $bDone = false ;
		do
		{
			string $cons[] = `listConnections -s 1 -d 0 -p 0 -scn 1 ($keepOut+".muscleData["+$idx+"]")` ;
			if (size($cons) <= 0)
				$bDone = 1;
			else
				++$idx ;
		} while(!$bDone) ;

		// Connect!
		connectAttr -f ($muscle+".muscleData") ($keepOut+".muscleData["+$idx+"]") ;
		string $msg = (uiRes("m_cMuscle.kConnectedMuscleToKeepOut"));
		$msg = `format -stringArg $muscle -stringArg $keepOut $msg`;
		print ($msg) ;
	}
	else
	{
		if ($conAlready == "")
		{
			string $msg = (uiRes("m_cMuscle.kMuscleNotConnectedToKeepOutNode"));
			$msg = `format -stringArg $muscle -stringArg $keepOut $msg`;
			warning ($msg) ;	
			return ;
		}
		disconnectAttr ($muscle+".muscleData") $conAlready ;
		removeMultiInstance -b true $conAlready ;
		string $msg = (uiRes("m_cMuscle.kDisconnectedMuscleFromKeepOut"));
		$msg = `format -stringArg $muscle -stringArg $keepOut $msg`;
		print ($msg) ;
	}
}

// --------------------------------------------------------------------------

/*
 * cMuscle_rigKeepOutSel() - Rigs selected objects for keepout ability.
 */
global proc string[] cMuscle_rigKeepOutSel()
{
	string $result[] ;
	clear $result ;

	string $objs[] = `ls -sl` ;
	string $obj ;
	for ($obj in $objs)
	{
		// Make sure not already rigged or not already a keep out node...
		if (nodeType($obj) == "cMuscleKeepOut")
			continue ;

		string $kOs[] = `listRelatives -shapes -ni -type "cMuscleKeepOut" $obj`;
		if (size($kOs) > 0 && $kOs[0] != "")
			continue ;

		string $ko = cMuscle_getMessage($obj, "msgKeepOut") ;
		if ($ko != "")
			continue ;

		// Ok so RIG it!
		string $kOs[] = cMuscle_rigKeepOut($obj) ;
		$result[size($result)] = $kOs[0] ;
		$result[size($result)] = $kOs[1] ;
		$result[size($result)] = $kOs[2] ;
	}

	// Reselect orig...
	if (size($objs) > 0)
		select -r $objs ;

	return $result ;
}

// --------------------------------------------------------------------------

/*
 * cMuscle_rigKeepOut() - Rig a node for keep out
 */
global proc string[] cMuscle_rigKeepOut(string $obj)
{
	// Set up a nice offset constraint
	string $keepOut = `createNode "cMuscleKeepOut" -n ("cMuscleKeepOutShape#")`;
	string $xforms[] = `listRelatives -parent $keepOut` ;
	string $xform = $xforms[0] ;

	string $keepOutDriven = `group -em -w -n ($xform+"Driven")` ;


	// Snap to right spot.
	string $pcons[] = `pointConstraint $obj $xform` ;	// snap 
	string $ocons[] = `orientConstraint $obj $xform` ;
	delete $pcons $ocons ;
	string $pcons[] = `pointConstraint $obj $keepOutDriven` ;	// snap 
	string $ocons[] = `orientConstraint $obj $keepOutDriven` ;
	delete $pcons $ocons ;

	// Set it up
	connectAttr -f ($xform+".worldMatrix") ($keepOut+".worldMatrixAim") ;
	connectAttr -f ($keepOut+".outTranslateLocal") ($keepOutDriven+".translate") ;

	// reparent original children to the driven node now... 
	string $childs[] = `listRelatives -children -ni -type "transform" -type "joint" $obj` ;
	string $child ;
	// Set up hierarchy
	parent $xform $obj ;
	parent $keepOutDriven $xform ;
	for ($child in $childs)
		parent $child $keepOutDriven ;


	// Set up nice msg attrs to keep track of stuff.
	cMuscle_addMessage($obj, "msgKeepOutXForm", $xform ) ;
	cMuscle_addMessage($obj, "msgKeepOut", $keepOut ) ;
	cMuscle_addMessage($obj, "msgKeepOutDriven", $keepOutDriven ) ;


	// Now also for specific cMuscle stuff, if the original object looks like
	// it has a connection to a spline deformer, move the connection off 
	// of the control and instead put it onto a new offset node 
	string $cons[] = `listConnections -s 0 -d 1 -p 1 -scn 1 -type "cMuscleSpline" ($obj+".worldMatrix")`;
	// Result: cMuscleSplineMusOuterLfShape.controlData[2].insertMatrix //
	if (size($cons) > 0)
	{
		string $iCtrlOffset = `group -em -w -n ($obj+"SplineOffset")` ;
		// Snap to right spot.
		string $pcons[] = `pointConstraint $obj $iCtrlOffset` ;	// snap 
		string $ocons[] = `orientConstraint $obj $iCtrlOffset` ;
		delete $pcons $ocons ;
		// parent
		parent $iCtrlOffset $keepOutDriven ;
		cMuscle_addMessage($obj, "msgSplineOffset", $iCtrlOffset ) ;
		// reconnect
		string $con ;
		for ($con in $cons)
		{
			disconnectAttr ($obj+".worldMatrix") ($con) ;
			connectAttr -f ($iCtrlOffset+".worldMatrix") ($con) ;
		}
	}


	select -r $xform ;
	return ({$xform, $keepOut, $keepOutDriven}) ;
}

// --------------------------------------------------------------------------

/* 
 * cMuscle_addMessage() - Adds a msg attr to the base and connects in tgt
 */
global proc cMuscle_addMessage(string $base, string $attr, string $msgTgt )
{
	if (objExists($base+"."+$attr) != true)
		addAttr -ln $attr $base ;
	connectAttr -f ($msgTgt+".message") ($base+"."+$attr) ;
}

// --------------------------------------------------------------------------

/*
 * cMuscle_getMessage() - Get object tied into message.
 */
global proc string cMuscle_getMessage(string $base, string $attr)
{
	if (objExists($base+"."+$attr) != true)
		return "" ;

	string $cons[] = `listConnections -s 1 -d 0 -p 0 -scn 1 ($base+"."+$attr)` ;
	return $cons[0] ;
}

// --------------------------------------------------------------------------

// --------------------------------------------------------------------------
//	cMuscleRelative Procs
// --------------------------------------------------------------------------

// --------------------------------------------------------------------------

/*
 * cMuscle_setupSystemForRelative() - Given a muscle node, set it up to be relative
 */
global proc string cMuscle_setupSystemForRelative(string $mS)
{
	string $shapes[] = `deformer -q -geometry $mS` ;
	string $shape = $shapes[0] ;

	// First see if a cMuscleRelative node already exists...if it does, we just keep that one...
	string $rels[] = cMuscle_getDeformers("cMuscleRelative", {$shape}) ;
	string $rel ;
	if (size($rels) >= 1)
		$rel = $rels[0] ;
	else
	{
		$rels = `deformer -type "cMuscleRelative" -frontOfChain $shape` ;
		$rel = $rels[0] ;
	}

	// Now if a skinCluster exists, we want the deformer just in front of that, but after other
	// things like blends..so we just look for a skin, and use the reorderDeformers call to
	// slide the def up... otherwise we'll leave it Front Of Chain for the user to correct if desired.
	//
	string $skins[] = cMuscle_getDeformers("skinCluster", {$shape}) ;
	if (size($skins) >= 1)
	{
		reorderDeformers $skins[0] $rel $shape ;	// Put cMuscleRelative just before the skinCluster	
	}

	// Now do the needed connection
	catch(`connectAttr -f ($rel+".point") ($mS+".relativePoint") `) ;
	catch(`setAttr ($mS+".relativeSticky") 1`) ;

	string $msg = (uiRes("m_cMuscle.kSetupMuscleSystemForRelativeStickyDeformation"));
	$msg = `format -stringArg $mS $msg`;
	print ($msg) ;
	return $rel ;
}

// --------------------------------------------------------------------------

/*
 * cMuscle_setupSelectedSystemsForRelative() - For any selected meshes with cMuscle
 *		Sets them up for relative mode...
 */
global proc cMuscle_setupSelectedSystemsForRelative()
{
	string $mSs[] = cMuscle_getSelectedDeformers("cMuscleSystem") ;
	string $mS ;
	for ($mS in $mSs)
	{
		cMuscle_setupSystemForRelative($mS) ;	
	}
}

// --------------------------------------------------------------------------

/*
 * cMuscle_markSelectedMuscleObjectsRelative() - Just a helper util to easily set
 *		the relative attribute on selected muscle objects on or off.
 */
global proc cMuscle_markSelectedMuscleObjectsRelative(int $bRel)
{
	string $mOs[] = cMuscle_getSelectedShapes("cMuscleObject") ;
	string $mO ;
	for ($mO in $mOs)
	{
		catch(`setAttr ($mO+".relative") $bRel`) ;	
	}
}

// --------------------------------------------------------------------------


// --------------------------------------------------------------------------


