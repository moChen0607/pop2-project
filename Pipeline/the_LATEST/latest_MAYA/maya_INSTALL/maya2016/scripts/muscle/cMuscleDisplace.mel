// Copyright (C) 1997-2014 Autodesk, Inc., and/or its licensors.
// All rights reserved.
//
// The coded instructions, statements, computer programs, and/or related
// material (collectively the "Data") in these files contain unpublished
// information proprietary to Autodesk, Inc. ("Autodesk") and/or its licensors,
// which is protected by U.S. and Canadian federal copyright law and by
// international treaties.
//
// The Data is provided for use exclusively by You. You have the right to use,
// modify, and incorporate this Data into other products for purposes authorized 
// by the Autodesk software license agreement, without fee.
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND. AUTODESK
// DOES NOT MAKE AND HEREBY DISCLAIMS ANY EXPRESS OR IMPLIED WARRANTIES
// INCLUDING, BUT NOT LIMITED TO, THE WARRANTIES OF NON-INFRINGEMENT,
// MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE, OR ARISING FROM A COURSE 
// OF DEALING, USAGE, OR TRADE PRACTICE. IN NO EVENT WILL AUTODESK AND/OR ITS
// LICENSORS BE LIABLE FOR ANY LOST REVENUES, DATA, OR PROFITS, OR SPECIAL,
// DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES, EVEN IF AUTODESK AND/OR ITS
// LICENSORS HAS BEEN ADVISED OF THE POSSIBILITY OR PROBABILITY OF SUCH DAMAGES.

/*
 * Includes
 */

 
/*
 * globals
 */

// --------------------------------------------------------------------------

// --------------------------------------------------------------------------
//	UI Procs
// --------------------------------------------------------------------------

// --------------------------------------------------------------------------

/*
 * cMuscle_createDisplaceUI() - Create a new cMuscleDisplace node ready
 *		for deformation usage.
 */
global proc cMuscle_createDisplaceUI()
{
	string $data[] = cMuscle_createDisplace() ;		// Do it!
}

// --------------------------------------------------------------------------

/*
 * cMuscle_connectDisplaceToSysUI() - Look for a selected system node
 *	and displace nodes and connect them all together
 */
global proc cMuscle_connectDisplaceToSysUI()	
{
	string $mSs[] = cMuscle_getSelectedDeformers("cMuscleSystem") ;
	string $mS ;
	
	string $mDs[] = cMuscle_getSelectedShapes("cMuscleDisplace") ;
	string $mD ;

	if (size($mSs) <= 0 || size($mDs) <= 0)
		error -sl 0 (uiRes("m_cMuscleDisplace.kMustSelectMuscleDisplaceAndMuscleSystemMeshToConnect"));

	for ($mS in $mSs)
		{
		for ($mD in $mDs)
			{
			cMuscle_connectDisplaceToSys($mS, $mD) ;		// Do the connection.
			} // end of each displace
		} // end of each deformer
}

// --------------------------------------------------------------------------

/*
 * cMuscle_disconnectDisplaceFromSysUI() - Disconnects all selected cMuscleDisplace
 *		nodes from the selected cMuscleSystem deformers.
 */
global proc cMuscle_disconnectDisplaceFromSysUI()
{
	string $mSs[] = cMuscle_getSelectedDeformers("cMuscleSystem") ;
	string $mS ;
	
	string $mDs[] = cMuscle_getSelectedShapes("cMuscleDisplace") ;
	string $mD ;

	if (size($mSs) <= 0 || size($mDs) <= 0)
		error -sl 0 (uiRes("m_cMuscleDisplace.kMustSelectMuscleDisplaceAndMuscleSystemMeshToDisconnect")) ;

	for ($mS in $mSs)
		{
		for ($mD in $mDs)
			{
			cMuscle_disconnectDisplaceFromSys($mS, $mD) ;		// Do the breakup
			} // end of each displace
		} // end of each deformer	
}

// --------------------------------------------------------------------------

/*
 * cMuscle_connectCurveToDisplaceUI() -  Look for a selected curveshape nodes
 *	and displace nodes and connect them all together
 */
global proc cMuscle_connectCurveToDisplaceUI()
{
	string $curves[] = cMuscle_getSelectedShapes("nurbsCurve") ;
	string $curve ;
	
	string $mDs[] = cMuscle_getSelectedShapes("cMuscleDisplace") ;
	string $mD ;

	if (size($curves) <= 0 || size($mDs) <= 0)
		error -sl 0 (uiRes("m_cMuscleDisplace.kMustSelectNURBsCurveAndMuscleDisplaceToConnect")) ;

	for ($curve in $curves)
		{
		for ($mD in $mDs)
			{
			cMuscle_connectCurveToDisplace($mD, $curve) ;		// Do the connection.
			} // end of each displace
		} // end of each deformer
}

// --------------------------------------------------------------------------

/*
 * cMuscle_disconnectCurveFromDisplaceUI() -  Disconnects all selected curveshape nodes
 *	from all selected displace nodes.
 */
global proc cMuscle_disconnectCurveFromDisplaceUI()
{
	string $curves[] = cMuscle_getSelectedShapes("nurbsCurve") ;
	string $curve ;
	
	string $mDs[] = cMuscle_getSelectedShapes("cMuscleDisplace") ;
	string $mD ;

	if (size($curves) <= 0 || size($mDs) <= 0)
		error -sl 0 (uiRes("m_cMuscleDisplace.kMustSelectNURBsCurveAndMuscleDisplaceToDisconnect")) ;

	for ($curve in $curves)
		{
		for ($mD in $mDs)
			{
			cMuscle_disconnectCurveFromDisplace($mD, $curve) ;		// Do the connection.
			} // end of each displace
		} // end of each deformer
}

// --------------------------------------------------------------------------

/*
 * cMuscle_createShaderUI() - Create a nice Maya cMuscleShader network
 */
global proc cMuscle_createShaderUI()
{
	string $data[] = cMuscle_createShader() ;	
}

// --------------------------------------------------------------------------

// --------------------------------------------------------------------------
//	Worker Procs
// --------------------------------------------------------------------------

// --------------------------------------------------------------------------

/*
 * cMuscle_createDisplace() - Create a cMuscleDisplace setup that can
 *		be used for deformation
 *
 *	Returns the { xform, cMuscledisplaceShape, file }
 */
global proc string[] cMuscle_createDisplace()
{
	string $disp = `createNode "cMuscleDisplace" -n "cMuscleDisplaceShape#"` ;
	string $xforms[] = `listRelatives -p $disp` ;
	string $xform = $xforms[0] ;
	cMuscle_cleanMayaShape($disp) ;
	
	// Connect in proper transform from transform node
	connectAttr -f ($xform+".worldMatrix") ($disp+".dispData.worldMatrixDisp") ;
	
	// Now make the file node to connect into it.
	string $file = `createNode "file" -n "file#"` ;
	connectAttr -f ($file+".outColor") ($disp+".shader") ;
	
	select -r $xform ;
	
	return  {$xform, $disp, $file} ;
}

// --------------------------------------------------------------------------

/*
 * cMuscle_getConnectedDisplaceIndex() - Given a system node and a cMuscleDisplace
 *	node, returns the index # that the disp is connected into the sys array with.
 *
 *	Return -1 if no connection, otherwise 0....n for index
 */
global proc int cMuscle_getConnectedDisplaceIndex(string $mS, string $mD)
{
	// List connections to see if this thing is connected yet...
	string $cons[] = `listConnections -s 0 -d 1 -p 1 -scn 1 ($mD+".dispData")` ;
	string $con ;
	for ($con in $cons)
		{
		string $parts[] ;
		tokenize($con, ".", $parts) ;
		if ($parts[0] == $mS)		// Was the connection into the same deformer?
			{
			tokenize($con, "[]", $parts) ;		// cMuscleSystem1.dispData[2] for example
			int $idx = (int)$parts[1] ;			// Get just the index #
			return $idx ;
			}
		}

	return -1 ;		// not connected
}

// --------------------------------------------------------------------------

/*
 * cMuscle_connectDisplaceToSys() - Connects cMuscleDisplace node into
 *		next available slot for cMuscleSystem.
 */
global proc cMuscle_connectDisplaceToSys(string $mS, string $mD)
{
	int $curIdx = cMuscle_getConnectedDisplaceIndex($mS, $mD) ;
	if ($curIdx != -1)
		{
		string $msg = (uiRes("m_cMuscleDisplace.kMuscleDisplaceAlreadyConnectedToMuscleSystem"));
		$msg = `format -stringArg $mD -stringArg $mS $msg`;
		warning -sl 0 ($msg) ;
		return ;
		}

	// Ok not yet connected...so lets do it.
	
	// Find next unconnected index...
    //
	int $idx=0 ;
	int $done=0 ;
	while (!$done)
		{
		string $cons[] ;
		clear $cons ;
		$cons = `listConnections -s 1 -d 0 -p 1 -scn 1 ($mS+".dispData["+$idx+"]")` ;
		if (size($cons) > 0)		// something already connected...
			++$idx ;				// so loop again and try next
		else
			{
			$done = 1 ;
			break ;
			}
		}

	connectAttr -f ($mD+".dispData") ($mS+".dispData["+$idx+"]") ;

	// Now due to Maya update issues, if this displace node is already connected
	// with curves...connect the curves into the deformer here too.
	//
	int $nCurves = `getAttr -size ($mD+".curves")` ;
	int $c ;
	for ($c=0; $c < $nCurves; ++$c)
		{
		catch(` connectAttr -f ($mD+".curves["+$c+"]") ($mS+".dispData["+$idx+"].curves["+$c+"]") `) ;
		}
	
	
	string $msg = (uiRes("m_cMuscleDisplace.kConnectedMuscleDisplaceToMuscleSystem"));
	$msg = `format -stringArg $mD -stringArg $mS $msg`;
	print ($msg) ;
}

// --------------------------------------------------------------------------

/*
 * cMuscle_disconnectDisplaceFromSys() - Disconnects a cMuscleDisplace node from
 *		a cMuscleSystem deformer.
 */
global proc cMuscle_disconnectDisplaceFromSys(string $mS, string $mD)
{
	int $idx = cMuscle_getConnectedDisplaceIndex($mS, $mD) ;
	if ($idx == -1)
		{
		string $msg = (uiRes("m_cMuscleDisplace.kMuscleDisplaceNotConnectedToMuscleSystem"));
		$msg = `format -stringArg $mD -stringArg $mS $msg`;
		warning -sl 0 ($msg) ;
		return ;
		}

	// Ok time to disconnect... and also remove the actual plug...
	disconnectAttr ($mD+".dispData") ($mS+".dispData["+$idx+"]") ;
	removeMultiInstance -b true ($mS+".dispData["+$idx+"]") ;

	string $msg = (uiRes("m_cMuscleDisplace.kDisconnectedMuscleDisplaceFromMuscleSystem"));
	$msg = `format -stringArg $mD -stringArg $mS $msg`;
	print ($msg) ;
}

// --------------------------------------------------------------------------

/*
 * cMuscle_disconnectDisplaceSystem() - Removes all cMuscleDisplace connections from System nodes.
 */
global proc cMuscle_disconnectDisplaceSystem(int $rem)
{
    string $objs[] = `ls -sl`;
    
    if (size($objs) <= 0)
        error -sl 0 (uiRes("m_cMuscleDisplace.kMustSelectMuscleSystemDeformerOrGeometry")) ;

    string $mSs[] = cMuscle_getSelectedDeformers("cMuscleSystem") ;

    
    if (size($mSs) <= 0)
        error -sl 0 (uiRes("m_cMuscleDisplace.kMustSelectMuscleSystemObject")) ;

    select -cl ;

	string $mS ;
	for ($mS in $mSs)	// each muscleSystem
		setAttr ($mS+".envelope") 0.0 ;		// Disable
		
    for ($mS in $mSs)	// each muscleSystem
		{
		// List connections to see if this thing is connected yet...
		string $mDs[] = `listConnections -s 1 -d 0 -p 0 -scn 1 ($mS+".dispData")` ;
		string $mD ;
		for ($mD in $mDs)
			{
				// Have to see what index the disp is connected into the sys with too...
			int $dIdx = cMuscle_getConnectedDisplaceIndex($mS, $mD) ;

			// Disconnect it!
			disconnectAttr ($mD+".dispData") ($mS+".dispData["+$dIdx+"]") ;
			if ($rem == 1)
				removeMultiInstance -b true ($mS+".dispData["+$dIdx+"]") ;
			} // each muscle connection in...

		}  // each system selected...
	
	for ($mS in $mSs)	// each muscleSystem
		setAttr ($mS+".envelope") 1.0 ;		// Enable
		
	
    select $objs ;

	string $msg = (uiRes("m_cMuscleDisplace.kDisconnectedAllMuscleDisplaceFromMuscleSystem"));
    print ($msg) ;
}


// --------------------------------------------------------------------------

// --------------------------------------------------------------------------
//	Curve related displace Worker Procs
// --------------------------------------------------------------------------

// --------------------------------------------------------------------------

/*
 * cMuscle_getConnectedCurveDisplaceIndex() - Given a curve shapea and a cMuscleDisplace
 *	node, returns the index # that the curve is connected into the displace node with.
 *
 *	Return -1 if no connection, otherwise 0....n for index
 */
global proc int cMuscle_getConnectedCurveDisplaceIndex(string $mD, string $curveShape)
{
	// List connections to see if this thing is connected yet...
	string $cons[] = `listConnections -s 0 -d 1 -p 1 -scn 1 ($curveShape+".worldSpace")` ;
	string $con ;
	for ($con in $cons)
		{
		string $parts[] ;
		tokenize($con, ".", $parts) ;
		if ($parts[0] == $mD)		// Was the connection into the same displace?
			{
			tokenize($con, "[]", $parts) ;		// cMuscleDisplaceShape1.curves[2] for example
			int $idx = (int)$parts[1] ;			// Get just the index #
			return $idx ;
			}
		}

	return -1 ;		// not connected
}

// --------------------------------------------------------------------------


/*
 * cMuscle_connectCurveToDisplace() - Connects a curve shape into
 *		next available slot for cMuscleDisplace node.
 */
global proc cMuscle_connectCurveToDisplace(string $mD, string $curveShape)
{
	int $curIdx = cMuscle_getConnectedCurveDisplaceIndex($mD, $curveShape) ;
	if ($curIdx != -1)
		{
		string $msg = (uiRes("m_cMuscleDisplace.kCurveAlreadyConnectedToMuscleDisplace"));
		$msg = `format -stringArg $curveShape -stringArg $mD $msg`;
		warning -sl 0 ($msg) ;
		return ;
		}

	// Ok not yet connected...so lets do it.
	
	// Find next unconnected index...
    //
	int $idx=0 ;
	int $done=0 ;
	while (!$done)
		{
		string $cons[] ;
		clear $cons ;
		$cons = `listConnections -s 1 -d 0 -p 1 -scn 1 ($mD+".curves["+$idx+"]")` ;
		if (size($cons) > 0)		// something already connected...
			++$idx ;				// so loop again and try next
		else
			{
			$done = 1 ;
			break ;
			}
		}

	connectAttr -f ($curveShape+".worldSpace[0]") ($mD+".curves["+$idx+"]") ;

	// Now due to Maya update issues, if this displace node is already connected
	// into a cMuscleSystem or cMuscleShader node, connect the curve attrs
	//
	string $cons[] ;
	clear $cons ;
	$cons = `listConnections -s 0 -d 1 -p 1 -scn 1 -type "cMuscleSystem" -type "cMuscleShader" ($mD+".dispData")` ;
	string $con ;
	for ($con in $cons)
		{
		string $parts[] ;
		tokenize($con, ".", $parts) ;
		string $node = $parts[0] ;
		
		if (nodeType($node) == "cMuscleShader")
			catch(` connectAttr -f ($mD+".curves["+$idx+"]") ($node+".curves["+$idx+"]") `) ;
		else if (nodeType($node) == "cMuscleSystem")
			{
				// Have to see what index the disp is connected into the sys with too...
			int $dIdx = cMuscle_getConnectedDisplaceIndex($node, $mD) ;
			catch(` connectAttr -f ($mD+".curves["+$idx+"]") ($node+".dispData["+$dIdx+"].curves["+$idx+"]") `) ;
			}
		}
	
	
	string $msg = (uiRes("m_cMuscleDisplace.kConnectedCurveShapeToMuscleDisplace"));
	$msg = `format -stringArg $curveShape -stringArg $mD $msg`;
	print ($msg) ;
}

// --------------------------------------------------------------------------

/*
 * cMuscle_disconnectCurveFromDisplace() - Disconnects a curve shape from
 *		a cMuscleDisplace node.
 */
global proc cMuscle_disconnectCurveFromDisplace(string $mD, string $curveShape)
{
	int $idx = cMuscle_getConnectedCurveDisplaceIndex($mD, $curveShape) ;
	if ($idx == -1)
		{
		string $msg = (uiRes("m_cMuscleDisplace.kCurveNotConnectedToMuscleDisplace"));
		$msg = `format -stringArg $curveShape -stringArg $mD $msg`;
		warning -sl 0 ($msg) ;
		return ;
		}

	// Ok time to disconnect... and also remove the actual plug...
	disconnectAttr ($curveShape+".worldSpace") ($mD+".curves["+$idx+"]") ;
	removeMultiInstance -b true ($mD+".curves["+$idx+"]") ;

	string $msg = (uiRes("m_cMuscleDisplace.kDisconnectedCurveShapeFromMuscleDisplace"));
	$msg = `format -stringArg $curveShape -stringArg $mD $msg`;
	print ($msg) ;
}

// --------------------------------------------------------------------------

// --------------------------------------------------------------------------
//	Shader Worker Procs
// --------------------------------------------------------------------------

// --------------------------------------------------------------------------

/*
 * cMuscle_createShader() - Creates a nice cMuscleShader hierarchy and new
 *		displace node to be used with it for usage as a Maya shader.
 *
 *	  Returns: {$shader, $xform, $disp, $file} 
 */
global proc string[] cMuscle_createShader()
{
	string $shader = `createNode "cMuscleShader" -n "cMuscleShader#"` ;
		
	string $disp = `createNode "cMuscleDisplace" -n "cMuscleDisplaceShape#"` ;
	string $xforms[] = `listRelatives -p $disp` ;
	string $xform = $xforms[0] ;
	cMuscle_cleanMayaShape($disp) ;
	
	// Connect in proper transform from transform node
	connectAttr -f ($xform+".worldMatrix") ($disp+".dispData.worldMatrixDisp") ;
	
	// Now make the file node to connect into it.
	string $file = `createNode "file" -n "file#"` ;
	connectAttr -f ($file+".outColor") ($disp+".shader") ;	// We don't HAVE to do this, but since user may try to plug this disp into a deformer, we do just in case. 
	
	
	// Connect all the stuff to the shader
	connectAttr -f ($disp+".dispData") ($shader+".dispData") ;
//	connectAttr -f ($disp+".dispData.curves") ($shader+".dispData.curves") ;	// do this since Maya has update issues
	connectAttr -f ($file+".outColor") ($shader+".image") ;

	
	select -r $shader $xform ;
	
	return  {$shader, $xform, $disp, $file} ;
}


// --------------------------------------------------------------------------



