// Copyright (C) 1997-2014 Autodesk, Inc., and/or its licensors.
// All rights reserved.
//
// The coded instructions, statements, computer programs, and/or related
// material (collectively the "Data") in these files contain unpublished
// information proprietary to Autodesk, Inc. ("Autodesk") and/or its licensors,
// which is protected by U.S. and Canadian federal copyright law and by
// international treaties.
//
// The Data is provided for use exclusively by You. You have the right to use,
// modify, and incorporate this Data into other products for purposes authorized 
// by the Autodesk software license agreement, without fee.
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND. AUTODESK
// DOES NOT MAKE AND HEREBY DISCLAIMS ANY EXPRESS OR IMPLIED WARRANTIES
// INCLUDING, BUT NOT LIMITED TO, THE WARRANTIES OF NON-INFRINGEMENT,
// MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE, OR ARISING FROM A COURSE 
// OF DEALING, USAGE, OR TRADE PRACTICE. IN NO EVENT WILL AUTODESK AND/OR ITS
// LICENSORS BE LIABLE FOR ANY LOST REVENUES, DATA, OR PROFITS, OR SPECIAL,
// DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES, EVEN IF AUTODESK AND/OR ITS
// LICENSORS HAS BEEN ADVISED OF THE POSSIBILITY OR PROBABILITY OF SUCH DAMAGES.

//
//
//  Creation Date:  17 April 2007
//
//  Description:
//      This is part of a set of methods for changing
//		a property sheet to point to a new node.
//		(A way of efficiently re-using existing controls)
//		This method re-connects a control of undetermined type.
//
//  Input Arguments:
//      The name of the existing control
//		The name of the new plug
//		
 
global proc AEreplaceCompound ( string $controlName, string $plugName, string $changedCommand )
{
	//	Get node name and attr name
	string $buffer[];
	tokenize($plugName, ".", $buffer);
	string $node = $buffer[0];
	string $compoundParent = $buffer[size($buffer) - 1];

	//	$compoundMultiParent is compound parent attr with [ ] (in case multi) or without [ ] (if not multi)
	//	$compoundParent is compound parent attr ALWAYS WITHOUT [ ]
	$compoundMultiParent = $compoundParent;

	int $isMulti = 0;

	//	Is this multi compound?
	//	if so, $plugname looks like this: attrname[n]
	clear($buffer);
	tokenize($compoundParent, "[",$buffer);
	//	Yes. multi compound
	if( size($buffer) >0 )
	{
		$compoundParent = $buffer[0];
		$isMulti = 1;
	}

	//	attributeQuery does NOT take multi attr.
	//	For ex, `attributeQuery -node "myNode" -listChildren "colors[0]"` is error
	//	Instead, use `attributeQuery -node "myNode" -listChildren "colors"
	//	So, we have to use $compoundParent
	string $childAttrs[] = `attributeQuery -node $node  -listChildren $compoundParent`;

	//	No child!
	//	This attr is not compound. 
	//	Call AEnewOther instead.
	int $numChildren = size($childAttrs);
	if( $numChildren == 0 )
	{
		AEreplaceOther($controlName, $plugName, $changedCommand);
		return;
	}

	string $childType, $childPlug;

	setUITemplate -pst attributeEditorTemplate;
		
	//	First, the formLayout label
	frameLayout -e -l `attributeName -nice $plugName` $controlName;
	
	//	Get the column layout
	string $columnLayout[] = `frameLayout -q -childArray $controlName`;
	setParent $columnLayout[0];

	//	Get the layout's children
	string $childrenUI[] = `columnLayout -q -childArray $columnLayout[0]`;
	
		for($i=0; $i<$numChildren; $i++)
		{
			$childPlug = ($node + "." + $compoundMultiParent + "." + $childAttrs[$i]);
			$childType = `getAttr -type $childPlug`;
			string $childControl = `setParent -query` + "|" + $childrenUI[$i];
			if( $childType == "bool" )
			{
				connectControl -in 2 $childControl $childPlug;
				if ($changedCommand != "") 
				{
					// create a new scriptJob for this attribute
					string $cmd = $changedCommand + " \"" + $node + "\"";
					scriptJob -p $childControl -rp -ac $childPlug $cmd;
				}
			}
			else if( $childType == "long" )
			{
				AEreplaceInt($childControl, $childPlug, $changedCommand);
			}
			else if( $childType == "float" || $childType == "time" || $childType == "double")
			{
				AEreplaceFloat($childControl, $childPlug, $changedCommand);
			}
			else if( $childType == "enum" )
			{
				AEreplaceEnum($childControl, $childPlug, $changedCommand);
			}
			else if( `attributeQuery -node $node -usedAsColor $childAttrs[$i]` )
			{
				AEreplaceColor($childControl, $childPlug, $changedCommand);
			}
			else if( $childType == "matrix" )
			{
				AEreplaceMatrix($childControl, $childPlug, $changedCommand);
			}
			else if( $childType == "string" )
			{
				AEreplaceString($childControl, $childPlug, $changedCommand);
			}
			else if( $childType == "float3" )
			{
				AEreplaceVector($childControl, $childPlug, $changedCommand);
			}
			else if( $childType == "message" )
			{
				AEreplaceMessage($childControl, $childPlug, $changedCommand);
			}
			else
			{
				AEreplaceOther($childControl, $childPlug, $changedCommand);
			}
		}

		//	Multi Compound attr has "Delete" button for each compound.
		if( $isMulti )
		{
			if( size($childrenUI) > $numChildren )
			{
				//	"Delete" button is in a rowLayout
				setParent $childrenUI[$numChildren];
				string $deleteButtonControls[] = `rowLayout -q -childArray $childrenUI[$numChildren]`;
				symbolButton -e -command ("AEremoveMultiElement " + $plugName) $deleteButtonControls[1];
				setParent ..;
			}
		}

		setParent ..;	// columnLayout
		setParent ..;	// frameLayout
	setUITemplate -popTemplate;

}
