// Copyright (C) 1997-2014 Autodesk, Inc., and/or its licensors.
// All rights reserved.
//
// The coded instructions, statements, computer programs, and/or related
// material (collectively the "Data") in these files contain unpublished
// information proprietary to Autodesk, Inc. ("Autodesk") and/or its licensors,
// which is protected by U.S. and Canadian federal copyright law and by
// international treaties.
//
// The Data is provided for use exclusively by You. You have the right to use,
// modify, and incorporate this Data into other products for purposes authorized 
// by the Autodesk software license agreement, without fee.
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND. AUTODESK
// DOES NOT MAKE AND HEREBY DISCLAIMS ANY EXPRESS OR IMPLIED WARRANTIES
// INCLUDING, BUT NOT LIMITED TO, THE WARRANTIES OF NON-INFRINGEMENT,
// MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE, OR ARISING FROM A COURSE 
// OF DEALING, USAGE, OR TRADE PRACTICE. IN NO EVENT WILL AUTODESK AND/OR ITS
// LICENSORS BE LIABLE FOR ANY LOST REVENUES, DATA, OR PROFITS, OR SPECIAL,
// DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES, EVEN IF AUTODESK AND/OR ITS
// LICENSORS HAS BEEN ADVISED OF THE POSSIBILITY OR PROBABILITY OF SUCH DAMAGES.

//
//  Procedure Name:
//	AEhwRenderGlobalsTemplate
//
//  Description Name;
//	Creates the attribute editor controls for the hardware
//	render globals node.
//
//  Input Value:
//	nodeName 
//
//  Output Value:
//	None
// 


global proc  AEhrgResolutionSetValue( string $nodeAttr, string $textField )
{
	string	$value = `textField -q -text $textField`;

	setAttr -type "string" $nodeAttr $value;
}

global proc  AEhrgResolutionReplace( string $nodeAttr )
{
	string $value = `getAttr $nodeAttr`;

	textField -e
		-text $value 
		-cc ("AEhrgResolutionSetValue "+$nodeAttr+" resolutionConnected")
		resolutionConnected;
}


global proc AEhwRenderCustomBackgroundColorNew(string $attrName1)
{
	attrColorSliderGrp
		-label (uiRes("m_AEhwRenderGlobalsTemplate.kBackgroundColor"))
		-showButton false
		-at $attrName1
		customHWRenderBackgroundColorSlider;
}
global proc AEhwRenderCustomBackgroundColorReplace(string $attrName1)
{
	attrColorSliderGrp
		-edit
		-at $attrName1
	customHWRenderBackgroundColorSlider;
}


global proc  AEhrgResolutionNew( string $nodeAttr )
{
	setUITemplate -pst attributeEditorTemplate;

	string $value = `getAttr $nodeAttr`;
	global int $gTextColumnWidthIndex;
	global int $gAEMapButtonIndex;
	global int $gAESingleWidgetWidthIndex;

	// Define column sizes in relation to size of other widgets 
	// We have to make column 3 bigger than it normally would be to
	// fit the select button

	int $col1Size = $gTextColumnWidthIndex;
	int $col2Size = ( (3 * $gAESingleWidgetWidthIndex) - $gAEMapButtonIndex);
	int $col3Size = 53;

	rowLayout -nc 3 -columnWidth3 $col1Size $col2Size $col3Size;
		text -label (uiRes("m_AEhwRenderGlobalsTemplate.kResolution")) resolutionName;
		textField
			-text $value 
			-cc ("AEhrgResolutionSetValue "+$nodeAttr+" resolutionConnected")
			resolutionConnected;
		connectControl resolutionConnected "defaultHardwareRenderGlobals.resolution";
		button -w $col3Size -label (uiRes("m_AEhwRenderGlobalsTemplate.kSelect")) -c "glImageSizeWin";
		setParent ..;

	setUITemplate -ppt;
}



global proc  AEcheckEnableMultiPass( string $nodeName )
{
	string $nodeAttr = $nodeName + ".multiPassRendering";
	int $value = `getAttr $nodeAttr`;

	if ($value == 1)
	{
		editorTemplate -dimControl $nodeName "renderPasses" false;
		editorTemplate -dimControl $nodeName "antiAliasPolygons" false;
		editorTemplate -dimControl $nodeName "edgeSmoothing" false;
		editorTemplate -dimControl $nodeName "motionBlur" false;
	}
	else
	{
		editorTemplate -dimControl $nodeName "renderPasses" true;
		editorTemplate -dimControl $nodeName "antiAliasPolygons" true;
		editorTemplate -dimControl $nodeName "edgeSmoothing" true;
		editorTemplate -dimControl $nodeName "motionBlur" true;
	}
}

global proc AEhrgLightingCB( string $nodeName )
{
	string $nodeAttr = $nodeName + ".lightingMode";
	int $value = `getAttr $nodeAttr`;
	if ($value == 0)
	{
		editorTemplate -dimControl $nodeName "displayShadows" true;
	}
	else
	{
		editorTemplate -dimControl $nodeName "displayShadows" false;
	}
}

global proc  AEhrgGeometryMaskCB( string $nodeName )
{
	string $nodeAttr = $nodeName + ".geometryMask";
	int $value = `getAttr $nodeAttr`;

	if ($value == 1)
	{
		editorTemplate -dimControl $nodeName "drawStyle" true;
	}
	else
	{
		editorTemplate -dimControl $nodeName "drawStyle" false;
	}
}

global proc AEhwRenderGlobalsImageFormatUpdate( string $menu, string $nodeAttr )
{
	global int $AEhwRenderGlobalsImageFormatCBLock; 
	if ( ! $AEhwRenderGlobalsImageFormatCBLock ) { 
		string $buffer[]; 
		tokenize $nodeAttr "." $buffer; 
		int $idx = `getAttr $nodeAttr`; 
		global string $imfKey[]; 
		string $key = "";
		if ( $idx == 50 ) {
			$key = `getAttr ($buffer[0] + ".imfkey")`;
		} else { 
			$key = $imfKey[$idx]; 
		}
		imageFormatsMenuSelectImfKey( $menu, $key );
	}
}

global proc AEhwRenderGlobalsImageFormatMenuUpdate( string $menu, string $nodeAttr )
{
	int $id = imageFormatsMenuImfAttrId( $menu );

	global int $AEhwRenderGlobalsImageFormatCBLock;

	// Prevent the scriptJob callbacks from firing ...
	//
	$AEhwRenderGlobalsImageFormatCBLock = 1;
	
	string $buffer[]; 
	tokenize $nodeAttr "." $buffer; 
	string $attrImfPlugin = $buffer[0] + ".imfkey"; 
	string $attrImfPluginExt = $buffer[0] + ".imfext"; 
	
	if (imageFormatIsIMFPlugin($id)) {
		string $imfKey = imageFormatsMenuImfKey( $menu );
		string $ext = imageFormatsMenuImfExt( $menu );
		setAttr $nodeAttr 50;
		setAttr -type "string" $attrImfPlugin $imfKey;
		setAttr -type "string" $attrImfPluginExt $ext; 
	} else {
		setAttr $nodeAttr $id;
		setAttr -type "string" $attrImfPlugin ""; 
		setAttr -type "string" $attrImfPluginExt ""; 
	}

	// Resume scriptJob callbacks.
	//
	$AEhwRenderGlobalsImageFormatCBLock = 0;
}

proc attachScriptJobToMenu( string $menu, string $nodeAttr )
{
	scriptJob
		-p $menu -rp
		-ac $nodeAttr ("AEhwRenderGlobalsImageFormatUpdate "+$menu+" "+$nodeAttr);
}

global proc AEhwRenderGlobalsImageFormatNew( string $nodeAttr ) 
{
	global int $AEhwRenderGlobalsImageFormatCBLock = 0; 
	columnLayout -adj true imageFormatLayout; 
	string $menu = `optionMenuGrp -label (uiRes("m_AEhwRenderGlobalsTemplate.kImageFormat")) imageFormatMenu`;
	string $cmd = "AEhwRenderGlobalsImageFormatMenuUpdate " + $menu + " " + $nodeAttr;
	optionMenuGrp -e -cc $cmd $menu;

	buildImageFormatsMenu( 0, 0, 0, 0, 1 );
	AEhwRenderGlobalsImageFormatUpdate( $menu, $nodeAttr ); 

	attachScriptJobToMenu( $menu, $nodeAttr ); 
	setParent ..;
}

global proc AEhwRenderGlobalsImageFormatReplace( string $nodeAttr )
{
	int $optMenu = `optionMenuGrp -q -exists imageMenuFormat`; 
	if ( $optMenu ) { 
		string $menuName = `optionMenuGrp -q -fullPathName imageMenuFormat`; 
		string $cmd = "AEhwRenderGlobalsImageFormatMenuUpdate " + $menuName + " " + $nodeAttr; 
		optionMenuGrp -e -cc $cmd $menuName;
		attachScriptJobToMenu( $menuName, $nodeAttr );
	}
}

global proc AEhwRenderGlobalsTemplate ( string $nodeName )
{
	editorTemplate -beginScrollLayout;
		
		editorTemplate -beginLayout (uiRes("m_AEhwRenderGlobalsTemplate.kImageOutputFiles")) -collapse 0;
			editorTemplate -addControl "filename";
			editorTemplate -addControl "extension";
			editorTemplate -addControl "startFrame";
			editorTemplate -addControl "endFrame";
			editorTemplate -addControl "byFrame";
			editorTemplate -callCustom "AEhwRenderGlobalsImageFormatNew" "AEhwRenderGlobalsImageFormatReplace" "imageFormat";
			editorTemplate -callCustom "AEhrgResolutionNew" "AEhrgResolutionReplace" "resolution";
			editorTemplate -addControl "alphaSource";
			editorTemplate -addControl "writeZDepth";
			editorTemplate -suppress "imfPluginKey";
			editorTemplate -suppress "imfPluginKeyExt";
		editorTemplate -endLayout;
	
		editorTemplate -beginLayout (uiRes("m_AEhwRenderGlobalsTemplate.kRenderModes")) -collapse 0;
			editorTemplate -beginNoOptimize;
			editorTemplate -addControl "lightingMode" "AEhrgLightingCB";
			editorTemplate -addControl "drawStyle";
			editorTemplate -addControl "lighting";
			editorTemplate -addControl "texturing";
			editorTemplate -addControl "lineSmoothing";
			editorTemplate -addControl "fullImageResolution";
			editorTemplate -addControl "geometryMask" "AEhrgGeometryMaskCB";
			editorTemplate -addControl "displayShadows";
			editorTemplate -addControl "shadowsObeyLightLinking";
			editorTemplate -addControl "shadowsObeyShadowLinking";
			editorTemplate -endNoOptimize;
		editorTemplate -endLayout;

		editorTemplate -beginLayout (uiRes("m_AEhwRenderGlobalsTemplate.kMultiPassRenderOptions"));
			editorTemplate -addControl "multiPassRendering" "AEcheckEnableMultiPass";
			editorTemplate -addControl "renderPasses";
			editorTemplate -addControl "antiAliasPolygons";
			editorTemplate -addControl "edgeSmoothing";
			editorTemplate -addControl "motionBlur";
		editorTemplate -endLayout;

		editorTemplate -beginLayout (uiRes("m_AEhwRenderGlobalsTemplate.kDisplayOptions"));
			editorTemplate -beginNoOptimize;
			editorTemplate -addControl "grid";
			editorTemplate -addControl "cameraIcons";
			editorTemplate -addControl "lightIcons";
			editorTemplate -addControl "emitterIcons";
			editorTemplate -addControl "fieldIcons";
			editorTemplate -addControl "collisionIcons";
			editorTemplate -addControl "transformIcons";
			editorTemplate -callCustom
				"AEhwRenderCustomBackgroundColorNew"
				"AEhwRenderCustomBackgroundColorReplace"
				"backgroundColor";
			editorTemplate -endNoOptimize;
		editorTemplate -endLayout;

		// include/call base class/node attributes
		AEdependNodeTemplate $nodeName;

	editorTemplate -addExtraControls;
	editorTemplate -endScrollLayout;
}
