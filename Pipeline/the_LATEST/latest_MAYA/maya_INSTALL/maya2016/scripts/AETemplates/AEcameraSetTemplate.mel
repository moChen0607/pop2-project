// Copyright (C) 1997-2014 Autodesk, Inc., and/or its licensors.
// All rights reserved.
//
// The coded instructions, statements, computer programs, and/or related
// material (collectively the "Data") in these files contain unpublished
// information proprietary to Autodesk, Inc. ("Autodesk") and/or its licensors,
// which is protected by U.S. and Canadian federal copyright law and by
// international treaties.
//
// The Data is provided for use exclusively by You. You have the right to use,
// modify, and incorporate this Data into other products for purposes authorized 
// by the Autodesk software license agreement, without fee.
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND. AUTODESK
// DOES NOT MAKE AND HEREBY DISCLAIMS ANY EXPRESS OR IMPLIED WARRANTIES
// INCLUDING, BUT NOT LIMITED TO, THE WARRANTIES OF NON-INFRINGEMENT,
// MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE, OR ARISING FROM A COURSE 
// OF DEALING, USAGE, OR TRADE PRACTICE. IN NO EVENT WILL AUTODESK AND/OR ITS
// LICENSORS BE LIABLE FOR ANY LOST REVENUES, DATA, OR PROFITS, OR SPECIAL,
// DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES, EVEN IF AUTODESK AND/OR ITS
// LICENSORS HAS BEEN ADVISED OF THE POSSIBILITY OR PROBABILITY OF SUCH DAMAGES.

//
//  Creation Date:	April 11, 2008
//
//  Procedure Name:
//	AEcameraSetTemplate
//
//  Description Name;
//	Creates the attribute editor controls for the cameraSet node.
//
//  Input Value:
//	nodeName 
//
//  Output Value:
//	None
//

global string $gKnownAuxAttributes[] = { "active", 
										 "order", 
										 "clearDepth" };

proc string[] getCameraAndSetNodes(string $nodeName, string $multiAttr)
//
// Description:
//     This procedure fills in a string array containing the name of the
// connected camera node, the name of the connected set node if any, and the
// full attribute name of the "active" and "Order" attributes for the
// given node and multi-attribute.
//
{
	string $camAndSet[];

	// Get the upstream camera connection.  If none exists, return immediately.
	string $inputs[] = `listConnections -t transform ($nodeName + "." + $multiAttr + ".camera")`;
	if (size($inputs) == 0)
		return $camAndSet;

	// Set the camera source name.
	string $source[];
	tokenize($inputs[0], ".", $source);
	$camAndSet[0] = $source[0];

	// Get the upstream set connection and add it to the return list.
	$inputs = `listConnections -t objectSet ($nodeName + "." + $multiAttr + ".sceneData")`;
	if (size($inputs) > 0)
	{
		tokenize($inputs[0], ".", $source);
		$camAndSet[1] = $source[0];
	}
	else
		$camAndSet[1] = "";

	// Construct the active and order attribute names and add them to
	// the return list.
	//
	global string $gKnownAuxAttributes[]; 
	int $idx = 1; 
	for ( $x in $gKnownAuxAttributes ) { 
		$camAndSet[++$idx] = ($nodeName + "." + $multiAttr + "." + $x);
	}

	return $camAndSet;
}

global proc AEcameraSetNew(string $attrName)
{
	global string $gAEcameraSetControls[];
	// Register a script job to delete all of the control UI in the case of a file -new.
	scriptJob -e "deleteAll" AEcameraSetDeleteControls;

	string $buffer[];
	tokenize($attrName, ".", $buffer);
	string $nodeName = $buffer[0];

	setUITemplate -pst attributeEditorTemplate;
	columnLayout "cameraSetCameraLayerColumn";

	// Get all of the connectable cameraLayer attributes.
	string $allAttrs[] = `listAttr -multi -connectable ($nodeName + ".cameraLayer")`;

	// Iterate over them, looking for connected camera attributes.  For each one found,
	// fill in the UI for the associated multi attribute.
	int $i;
	int $c = 0;
	for ($i=0; $i < size($allAttrs); $i++)
	{
		tokenize($allAttrs[$i], ".", $buffer);
		if ((size($buffer) != 2) || ($buffer[1] != "camera"))
			continue;

		string $camAndSet[] = getCameraAndSetNodes($nodeName, $buffer[0]);
		if (size($camAndSet) == 0)
			continue;

		string $rcName = ("cameraSetCL_RC" + $c);
		rowColumnLayout -numberOfColumns 2
			-columnWidth 1 150
			-columnWidth 2 150
			-columnAlign 1 "right"
			-columnAlign 2 "left" $rcName;

		text -label $buffer[0] -font "boldLabelFont" ("cameraSetCL_MultiLabel" + $c);
		separator;
		text -al "right" -label (uiRes("m_AEcameraSetTemplate.kAECameraSetCameraLabel"));
		text -label $camAndSet[0] -font "obliqueLabelFont" ("cameraSetCL_CameraLabel" + $c);
		text -al "right" -label (uiRes("m_AEcameraSetTemplate.kAECameraSetSceneDataLabel"));
		text -label $camAndSet[1] -font "obliqueLabelFont" ("cameraSetCL_SetLabel" + $c);
		setParent ..;

		attrControlGrp -label (uiRes("m_AEcameraSetTemplate.kAECameraSetActiveLabel"))
				-attribute $camAndSet[2] -cc "refresh -f" ("cameraSetCL_Active" + $c);
		$gAEcameraSetControls[size($gAEcameraSetControls)] = $rcName;
		$gAEcameraSetControls[size($gAEcameraSetControls)] = ("cameraSetCL_Active" + $c);

		attrControlGrp -label (uiRes("m_AEcameraSetTemplate.kAECameraSetOrderLabel"))
				-attribute $camAndSet[3] -cc "refresh -f" ("cameraSetCL_Order" + $c);
		$gAEcameraSetControls[size($gAEcameraSetControls)] = ("cameraSetCL_Order" + $c);
		attrControlGrp 
			-label (uiRes("m_AEcameraSetTemplate.kAEStereoCameraSetDepthLabel"))
			-attribute $camAndSet[4] -cc "refresh -f" ("cameraSetCL_ClearDepth" + $c);
		$gAEcameraSetControls[size($gAEcameraSetControls)] = ("cameraSetCL_ClearDepth"+$c);
		$c++;
	}
	
	setParent ..;
	setUITemplate -ppt;

	AEcameraSetReplace( $attrName );
}


global proc AEcameraSetReplace(string $attrName)
{
	global string $gAEcameraSetControls[];

	string $buffer[];
	tokenize($attrName, ".", $buffer);
	string $nodeName = $buffer[0];

	setUITemplate -pst attributeEditorTemplate;
  
	setParent "cameraSetCameraLayerColumn";

	// Get all of the connectable cameraLayer attributes.
	string $allAttrs[] = `listAttr -multi -connectable ($nodeName + ".cameraLayer")`;

	// Iterate over them, looking for connected camera attributes.  For each one found,
	// fill in the UI for the associated multi attribute.
	int $i;
	int $c = 0;
	for ($i=0; $i < size($allAttrs); $i++)
	{
		tokenize($allAttrs[$i], ".", $buffer);
		if ((size($buffer) != 2) || ($buffer[1] != "camera"))
			continue;

		string $camAndSet[] = getCameraAndSetNodes($nodeName, $buffer[0]);
		if (size($camAndSet) == 0)
			continue;

		// If the UI doesn't exist for this multi-attribute, create it.  Otherwise, use
		// the existing UI.
		string $rcName = ("cameraSetCL_RC" + $c);
		if (!`control -exists $rcName`)
		{
			rowColumnLayout -numberOfColumns 2
				-columnWidth 1 150
				-columnWidth 2 150
				-columnAlign 1 "right"
				-columnAlign 2 "left" $rcName;

			text -label $buffer[0] -font "boldLabelFont" ("cameraSetCL_MultiLabel" + $c);
			separator;
			text -al "right" -label (uiRes("m_AEcameraSetTemplate.kAECameraSetCamera2Label"));
			text -label $camAndSet[0] -font "obliqueLabelFont" ("cameraSetCL_CameraLabel" + $c);
			text -al "right" -label (uiRes("m_AEcameraSetTemplate.kAECameraSetSceneData2Label"));
			text -label $camAndSet[1] -font "obliqueLabelFont" ("cameraSetCL_SetLabel" + $c);
			setParent ..;

			attrControlGrp -label (uiRes("m_AEcameraSetTemplate.kAECameraSetActive2Label"))
					-attribute $camAndSet[2] -cc "refresh -f" ("cameraSetCL_Active" + $c);
			$gAEcameraSetControls[size($gAEcameraSetControls)] = $rcName;
			$gAEcameraSetControls[size($gAEcameraSetControls)] = ("cameraSetCL_Active" + $c);
			attrControlGrp -label (uiRes("m_AEcameraSetTemplate.kAECameraSetOrder2Label"))
					-attribute $camAndSet[3] -cc "refresh -f" ("cameraSetCL_Order" + $c);
			$gAEcameraSetControls[size($gAEcameraSetControls)] = ("cameraSetCL_Order" + $c);
			attrControlGrp 
				-label (uiRes("m_AEcameraSetTemplate.kAEStereoCameraSetDepth2Label"))
				-attribute $camAndSet[4] -cc "refresh -f" ("cameraSetCL_ClearDepth" + $c);
			$gAEcameraSetControls[size($gAEcameraSetControls)] = ("cameraSetCL_ClearDepth"+$c); 
		}
		else
		{
			control -e -visible true $rcName;
			control -e -visible true ("cameraSetCL_Active"+$c);
			control -e -visible true ("cameraSetCL_Order"+$c);
			control -e -visible true ("cameraSetCL_ClearDepth"+$c); 
			text -e -label $buffer[0] ("cameraSetCL_MultiLabel" + $c);
			text -e -label $camAndSet[0] ("cameraSetCL_CameraLabel" + $c);
			text -e -label $camAndSet[1] ("cameraSetCL_SetLabel" + $c);
			attrControlGrp -e -attribute $camAndSet[2] 
				-cc "refresh -f" ("cameraSetCL_Active" + $c);
			attrControlGrp -e -attribute $camAndSet[3]
				-cc "refresh -f" ("cameraSetCL_Order" + $c);
			attrControlGrp -e -attribute $camAndSet[4]
				-cc "refresh -f" ("cameraSetCL_ClearDepth" + $c); 
		}
		$c++;
	}

	setParent ..;

	// Hide any existing unused UI.  Each defined layer has three
	// children: The rowColumnLayout for the camera and layer labels,
	// the active attribute control, and the drawOrder attribute
	// control.
	global string $gKnownAuxAttributes[]; 
	int $skip = size($gKnownAuxAttributes)+1; 
	$c = $c * $skip;
	int $numChildren = `columnLayout -q -numberOfChildren "cameraSetCameraLayerColumn"`;
	if ($c < $numChildren)
	{
		string $children[] = `columnLayout -q -childArray "cameraSetCameraLayerColumn"`;
		for (; $c < $numChildren; $c++) { 
			control -e -visible false $children[$c];
		}
	}

	setUITemplate -ppt;
}

global proc AEcameraSetDeleteControls ()
//
// Description:
//     This procedure deletes all of the UI controls build for the cameraLayer attribute.
// The procedure is called from a script job when a file -new is performed.
//
{
	global string $gAEcameraSetControls[];
	string $c;
	for ($c in $gAEcameraSetControls)
		deleteUI $c;
	clear($gAEcameraSetControls);
}

global proc AEcameraSetTemplate ( string $nodeName )
{
	editorTemplate -beginScrollLayout;

	editorTemplate -beginLayout (uiRes("m_AEcameraSetTemplate.kAECameraSetCameraLayerLabel"))
		-collapse false;
	editorTemplate -callCustom AEcameraSetNew AEcameraSetReplace cameraLayer;
	editorTemplate -endLayout;

	AEdependNodeTemplate $nodeName;
	editorTemplate -suppress "cameraLayer";
	editorTemplate -suppress "camera";
	editorTemplate -suppress "sceneData";
	global string $gKnownAuxAttributes[];
	for ($x in $gKnownAuxAttributes) { 
		editorTemplate -suppress $x;
	}	
	editorTemplate -endScrollLayout;
}
