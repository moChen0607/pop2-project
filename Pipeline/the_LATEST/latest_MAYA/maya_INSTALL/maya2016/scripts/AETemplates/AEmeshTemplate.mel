// Copyright (C) 1997-2014 Autodesk, Inc., and/or its licensors.
// All rights reserved.
//
// The coded instructions, statements, computer programs, and/or related
// material (collectively the "Data") in these files contain unpublished
// information proprietary to Autodesk, Inc. ("Autodesk") and/or its licensors,
// which is protected by U.S. and Canadian federal copyright law and by
// international treaties.
//
// The Data is provided for use exclusively by You. You have the right to use,
// modify, and incorporate this Data into other products for purposes authorized 
// by the Autodesk software license agreement, without fee.
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND. AUTODESK
// DOES NOT MAKE AND HEREBY DISCLAIMS ANY EXPRESS OR IMPLIED WARRANTIES
// INCLUDING, BUT NOT LIMITED TO, THE WARRANTIES OF NON-INFRINGEMENT,
// MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE, OR ARISING FROM A COURSE 
// OF DEALING, USAGE, OR TRADE PRACTICE. IN NO EVENT WILL AUTODESK AND/OR ITS
// LICENSORS BE LIABLE FOR ANY LOST REVENUES, DATA, OR PROFITS, OR SPECIAL,
// DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES, EVEN IF AUTODESK AND/OR ITS
// LICENSORS HAS BEEN ADVISED OF THE POSSIBILITY OR PROBABILITY OF SUCH DAMAGES.

//
//	Procedure Name:
//	AEmeshTemplate
//
//	Description Name;
//	Creates the attribute editor controls for the mesh node
//
//	Input Value:
//	nodeName
//
//	Output Value:
//	None
//

global proc checkMeshDisplayBorder ( string $nodeName )
{
	string $nodeAttr = $nodeName + ".displayBorders";
	int $value = `getAttr $nodeAttr`;

	if ( $value ) {
		editorTemplate -dimControl $nodeName "borderWidth" false;
	} else {
		editorTemplate -dimControl $nodeName "borderWidth" true;
	}
}

global proc checkMeshUseMaxSubd ( string $nodeName )
{
  string $nodeAttr = $nodeName + ".useMaxSubdivisions";
  int $value = `getAttr $nodeAttr`;

	if ( $value ) {
	  editorTemplate -dimControl $nodeName "maxSubd" false;
	} else {
	  editorTemplate -dimControl $nodeName "maxSubd" true;
	}
}

global proc checkMeshUseMinScreen ( string $nodeName )
{
	string $nodeAttr = $nodeName + ".useMinScreen";
	int $value = `getAttr $nodeAttr`;

	if ( $value ) {
		editorTemplate -dimControl $nodeName "minScreen" false;
	} else {
		editorTemplate -dimControl $nodeName "minScreen" true;
	}
}

global proc checkMeshUseMaxEdgeLength ( string $nodeName )
{
	string $nodeAttr = $nodeName + ".useMaxEdgeLength";
	int $value = `getAttr $nodeAttr`;

	if ( $value ) {
		editorTemplate -dimControl $nodeName "maxEdgeLength" false;
	} else {
		editorTemplate -dimControl $nodeName "maxEdgeLength" true;
	}
}

global proc checkMeshUseMaxUv ( string $nodeName )
{
	string $nodeAttr = $nodeName + ".useMaxUV";
	int $value = `getAttr $nodeAttr`;

	if ( $value ) {
		editorTemplate -dimControl $nodeName "maxUv" false;
	} else {
		editorTemplate -dimControl $nodeName "maxUv" true;
	}
}



global proc checkMeshUseMinEdgeLength ( string $nodeName )
{
	string $nodeAttr = $nodeName + ".useMinEdgeLength";
	int $value = `getAttr $nodeAttr`;

	if ( $value ) {
		editorTemplate -dimControl $nodeName "minEdgeLength" false;
	} else {
		editorTemplate -dimControl $nodeName "minEdgeLength" true;
	}
}

global proc checkMeshDisplayNormals ( string $nodeName )
{
	string $nodeAttr = $nodeName + ".displayNormal";
	int $value = `getAttr $nodeAttr`;

	if ( $value ) {
		editorTemplate -dimControl $nodeName "normalSize" false;
		editorTemplate -dimControl $nodeName "normalType" false;
	} else {
		$nodeAttr = $nodeName + ".displayTangent";
		$value = `getAttr $nodeAttr`;
		if( $value )
		{
			editorTemplate -dimControl $nodeName "normalSize" false;
		}
		else
		{
			editorTemplate -dimControl $nodeName "normalSize" true;
		}
		editorTemplate -dimControl $nodeName "normalType" true;
	}
}

global proc checkMeshDisplayVertices ( string $nodeName )
{
	string $nodeAttr = $nodeName + ".displayVertices";
	int $value = `getAttr $nodeAttr`;

	if ( $value ) {
		editorTemplate -dimControl $nodeName "vertexBackfaceCulling" false;
		editorTemplate -dimControl $nodeName "vertexSize" false;
	} else {
		editorTemplate -dimControl $nodeName "vertexBackfaceCulling" true;
		editorTemplate -dimControl $nodeName "vertexSize" true;
	}
}

global proc checkMeshDisplayUVs ( string $nodeName )
{
	string $nodeAttr = $nodeName + ".displayUVs";
	int $value = `getAttr $nodeAttr`;

	if ( $value ) {
		editorTemplate -dimControl $nodeName "uvSize" false;
	} else {
		editorTemplate -dimControl $nodeName "uvSize" true;
	}
}

global proc checkMeshAllowTopologyMod( string $nodeName )
{
	int $isLocked[] = `lockNode -q $nodeName`;
	editorTemplate -dimControl $nodeName "allowTopologyMod" $isLocked[0];
}

proc setDisplayColorChannelOptionMenu( string $attrName )
{
	string $channel = `getAttr $attrName`;
	int $option = 4; // Diffuse
	if ( $channel == "color" || $channel == "Diffuse" ) $option = 4;
	else if ( $channel == "None" ) $option = 1;
	else if ( $channel == "Ambient" ) $option = 2;
	else if ( $channel == "Ambient+Diffuse" ) $option = 3;
	else if ( $channel == "Specular" ) $option = 5;
	else if ( $channel == "Emission" ) $option = 6;

	if ( `optionMenuGrp -q -exists displayColorChannelOptionMenu` )
	{
		optionMenuGrp -e
			-select $option
			displayColorChannelOptionMenu;
	}
}

global proc setDisplayColorChannelAttribute( string $attrName )
{
	string $channel = "Diffuse";
	int $option = `optionMenuGrp -q -select displayColorChannelOptionMenu`;

	if ( $option == 4 ) $channel = "Diffuse";
	else if ( $option == 1 ) $channel = "None";
	else if ( $option == 2 ) $channel = "Ambient";
	else if ( $option == 3 ) $channel = "Ambient+Diffuse";
	else if ( $option == 5 ) $channel = "Specular";
	else if ( $option == 6 ) $channel = "Emission";
	
	setAttr -type "string" $attrName $channel;
}

global proc AEdisplayColorChannelNew ( string $attrName )
{
	setUITemplate -pushTemplate attributeEditorTemplate;
	string $parent = `setParent -q`;

	optionMenuGrp 
		-label (uiRes("m_AEmeshTemplate.kDisplayColorChannel"))
		displayColorChannelOptionMenu;
	menuItem -label (uiRes("m_AEmeshTemplate.kNone")) ;
	menuItem -label (uiRes("m_AEmeshTemplate.kAmbient"));
	menuItem -label (uiRes("m_AEmeshTemplate.kAmbientPlusDiffuse"));
	menuItem -label (uiRes("m_AEmeshTemplate.kDiffuse"));
	menuItem -label (uiRes("m_AEmeshTemplate.kSpecular"));
	menuItem -label (uiRes("m_AEmeshTemplate.kEmission"));
	setDisplayColorChannelOptionMenu( $attrName );

	optionMenuGrp -e
		-changeCommand ( "setDisplayColorChannelAttribute " + $attrName )
		displayColorChannelOptionMenu;

	setUITemplate -popTemplate;
}

global proc AEdisplayColorChannelReplace( string $attrName )
{
	optionMenuGrp -e
		-changeCommand ""
		displayColorChannelOptionMenu;

	setDisplayColorChannelOptionMenu( $attrName );

	optionMenuGrp -e
		-changeCommand ( "setDisplayColorChannelAttribute " + $attrName )
		displayColorChannelOptionMenu;
}

global proc SMPCustomControlsNew( string $attr1Name, string $attr2Name )
{
	setUITemplate -pushTemplate attributeEditorTemplate;

	string $nodeName = plugNode($attr1Name);

	checkBoxGrp -label (uiRes("m_AEmeshTemplate.kSMPDisplay")) 
			-changeCommand ("SMPAttrsFromCustomControlsUI \"" + $nodeName + "\"")
		SMPreview_CBG;

	radioButtonGrp -label (uiRes("m_AEmeshTemplate.kSMPDisplayLabel"))
			-numberOfRadioButtons 1
			-label1 (uiRes("m_AEmeshTemplate.kSMPDisplayBoth"))
			-changeCommand ("SMPAttrsFromCustomControlsUI \"" + $nodeName + "\"")
		SMPreviewType1_RBG;

	radioButtonGrp -label (uiRes("m_AEmeshTemplate.kSMPEditLabel"))
			-columnWidth 1 175
			-numberOfRadioButtons 3
			-vertical
			-label1 (uiRes("m_AEmeshTemplate.kSMPEditCage"))
			-label2 (uiRes("m_AEmeshTemplate.kSMPEditSmoth"))
			-label3 (uiRes("m_AEmeshTemplate.kSMPEditBoth"))
			-changeCommand ("SMPAttrsFromCustomControlsUI \"" + $nodeName + "\"")
		SMPreviewSelectType_RBG;

	radioButtonGrp -label (uiRes("m_AEmeshTemplate.kSMPEmpty")) 
			-shareCollection SMPreviewType1_RBG
			-numberOfRadioButtons 1
			-label1 (uiRes("m_AEmeshTemplate.kSMPDisplaySmooth"))
			-changeCommand ("SMPAttrsFromCustomControlsUI \"" + $nodeName + "\"")
		SMPreviewType2_RBG;

	SMPCustomControlsUIFromAttrs($nodeName);

	setUITemplate -popTemplate;

	global int $SMPDisplayModeScriptJobId;
	global int $SMPSelectionTypeScriptJobId;

	string $cmd = ("SMPCustomControlsUIFromAttrs \"" + $nodeName + "\"");
	$SMPDisplayModeScriptJobId = `scriptJob -parent SMPreview_CBG 
									-replacePrevious
									-attributeChange $attr1Name 
									$cmd`;

	$SMPSelectionTypeScriptJobId = `scriptJob -parent SMPreviewType1_RBG 
										-replacePrevious
										-attributeChange $attr2Name 
										$cmd`;
}

global proc SMPMapBordersNew( string $attr1Name, string $attr2Name, string $attr3Name )
{
	setUITemplate -pushTemplate attributeEditorTemplate;

	string $nodeName = plugNode($attr1Name);

	radioButtonGrp -label (uiRes("m_AEmeshTemplate.kSMPMapBordersLabel"))
			-vertical
			-numberOfRadioButtons 3
			-label1 (uiRes("m_AEmeshTemplate.kSMPDoNotSmooth"))
			-label2 (uiRes("m_AEmeshTemplate.kSMPSmoothInternal"))
			-label3 (uiRes("m_AEmeshTemplate.kSMPSmoothAll"))
			-changeCommand ("SMPAttrsFromMapBordersUI \"" + $nodeName + "\"")
		SMMapBorders_RBG;
	
	checkBoxGrp -label (uiRes("m_AEmeshTemplate.kSMPPreserve"))
			-vertical
			-numberOfCheckBoxes 2
			-label1 (uiRes("m_AEmeshTemplate.kSMPGeometryBorders"))
			-label2 (uiRes("m_AEmeshTemplate.kSMPHardEdges"))
			-changeCommand ("SMPAttrsFromMapBordersUI \"" + $nodeName + "\"")
		SMPreserver_CBG;

	SMPMapBordersUIFromAttrs($nodeName);

	setUITemplate -popTemplate;

	string $cmd = ("SMPMapBordersUIFromAttrs \"" + $nodeName + "\"");
	scriptJob -parent SMMapBorders_RBG 
			  -replacePrevious
			  -attributeChange $attr1Name 
			  $cmd;
}

proc string[] SMPSmoothDrawTypeWarningMsg(string $errorAttr)
{
	string $result[] = { "", "" };
	int $error = `getAttr $errorAttr`;
	if ($error != 0) {
		$result = {
			(uiRes("m_AEmeshTemplate.kSmoothDrawWarningMsg")),
			(uiRes("m_AEmeshTemplate.kSmoothDrawWarningAnn"))
		};
	}
	return $result;
}

global proc SMPSmoothDrawTypeWarningNew(string $errorAttr)
{
	string $msg[] = SMPSmoothDrawTypeWarningMsg($errorAttr);
	text -label $msg[0] -ann $msg[1] smoothDrawTypeWarning;
}

global proc SMPSmoothDrawTypeWarningReplace(string $errorAttr)
{
	string $msg[] = SMPSmoothDrawTypeWarningMsg($errorAttr);
	text -edit -label $msg[0] -ann $msg[1] smoothDrawTypeWarning;
}

global proc SMPCustomControlsReplace( string $attr1Name, string $attr2Name )
{
	string $nodeName = plugNode($attr1Name);

	checkBoxGrp -edit
			-changeCommand ("SMPAttrsFromCustomControlsUI \"" + $nodeName + "\"")
		SMPreview_CBG;

	radioButtonGrp -edit
			-changeCommand ("SMPAttrsFromCustomControlsUI \"" + $nodeName + "\"")
		SMPreviewType1_RBG;

	radioButtonGrp -edit
			-changeCommand ("SMPAttrsFromCustomControlsUI \"" + $nodeName + "\"")
		SMPreviewSelectType_RBG;

	radioButtonGrp -edit
			-changeCommand ("SMPAttrsFromCustomControlsUI \"" + $nodeName + "\"")
		SMPreviewType2_RBG;

	global int $SMPDisplayModeScriptJobId;
	global int $SMPSelectionTypeScriptJobId;

	scriptJob -kill $SMPDisplayModeScriptJobId;
	scriptJob -kill $SMPSelectionTypeScriptJobId;

	string $cmd = ("SMPCustomControlsUIFromAttrs \"" + $nodeName + "\"");
	$SMPDisplayModeScriptJobId = `scriptJob -parent SMPreview_CBG 
									-replacePrevious
									-attributeChange $attr1Name 
									$cmd`;

	$SMPSelectionTypeScriptJobId = `scriptJob -parent SMPreviewType1_RBG 
										-replacePrevious
										-attributeChange $attr2Name 
										$cmd`;

	SMPCustomControlsUIFromAttrs($nodeName);
}

global proc SMPMapBordersReplace( string $attr1Name, string $attr2Name, string $attr3Name )
{
	string $nodeName = plugNode($attr1Name);

	radioButtonGrp -edit
			-changeCommand ("SMPAttrsFromMapBordersUI \"" + $nodeName + "\"")
		SMMapBorders_RBG;

	checkBoxGrp -edit
			-changeCommand ("SMPAttrsFromMapBordersUI \"" + $nodeName + "\"")
		SMPreserver_CBG;

	SMPMapBordersUIFromAttrs($nodeName);
}

global proc SMPCustomControlsUIFromAttrs(string $nodeName)
{
	int $smpMode = `getAttr ($nodeName + ".displaySmoothMesh")`;
	int $smpSelMode = `getAttr ($nodeName + ".smoothMeshSelectionMode")`;

	checkBoxGrp -edit -value1 (0 != $smpMode) SMPreview_CBG;

	if (1 == $smpMode)
		radioButtonGrp -edit -select 1 SMPreviewType1_RBG;
	else if (2 == $smpMode)
		radioButtonGrp -edit -select 1 SMPreviewType2_RBG;

	radioButtonGrp -edit -select ($smpSelMode + 1) SMPreviewSelectType_RBG;

	SMPSetCustomControlsEnableState($nodeName);
}

global proc SMPMapBordersUIFromAttrs(string $nodeName)
{
	int $smpMapBorders = `getAttr ($nodeName + ".keepMapBorders")`;

	if (0 == $smpMapBorders)
		radioButtonGrp -edit -select 3 SMMapBorders_RBG;
	else if (2 == $smpMapBorders)
		radioButtonGrp -edit -select 1 SMMapBorders_RBG;
	else
		radioButtonGrp -edit -select 2 SMMapBorders_RBG;

	int $keepBorder = `getAttr ($nodeName + ".keepBorder")`;
	checkBoxGrp -edit -value1 $keepBorder SMPreserver_CBG;

	int $keepHardEdge = `getAttr ($nodeName + ".keepHardEdge")`;
	checkBoxGrp -edit -value2 $keepHardEdge SMPreserver_CBG;

	SMPSetMapBordersEnableState();
}

global proc SMPAttrsFromCustomControlsUI(string $nodeName)
{
	int $display = `checkBoxGrp -query -value1 SMPreview_CBG`;
	if (0 == $display)
	{
		setAttr ($nodeName + ".displaySmoothMesh") 0;
	}
	else if (1 == `radioButtonGrp -query -select SMPreviewType1_RBG`)
	{
		setAttr ($nodeName + ".displaySmoothMesh") 1;
	}
	else
	{
		setAttr ($nodeName + ".displaySmoothMesh") 2;
	}

	int $selMode = `radioButtonGrp -query -select SMPreviewSelectType_RBG`;
	$selMode = $selMode - 1;
	if (0 <= $selMode && $selMode <= 2 )
		setAttr ($nodeName + ".smoothMeshSelectionMode") $selMode;

	SMPSetCustomControlsEnableState($nodeName);
}

global proc SMPAttrsFromMapBordersUI(string $nodeName)
{
	int $mapBorders = `radioButtonGrp -query -select SMMapBorders_RBG`;
	if (1 == $mapBorders)
		setAttr ($nodeName + ".keepMapBorders") 2;
	else if (3 == $mapBorders)
		setAttr ($nodeName + ".keepMapBorders") 0;
	else
		setAttr ($nodeName + ".keepMapBorders") 1;

	int $keepBorder = `checkBoxGrp -query -value1 SMPreserver_CBG`;
	setAttr ($nodeName + ".keepBorder") $keepBorder;

	int $keepHardEdge = `checkBoxGrp -query -value2 SMPreserver_CBG`;
	setAttr ($nodeName + ".keepHardEdge") $keepHardEdge;

	SMPSetMapBordersEnableState();
}

global proc SMPSetCustomControlsEnableState(string $nodeName)
{
	int $disableDisplayType = (0 == `checkBoxGrp -q -value1 SMPreview_CBG`);
	
	if ($disableDisplayType)
	{
		radioButtonGrp -edit -enable false SMPreviewType1_RBG;
		radioButtonGrp -edit -enable false SMPreviewSelectType_RBG;
		radioButtonGrp -edit -enable false SMPreviewType2_RBG;
	}
	else
	{
		radioButtonGrp -edit -enable true SMPreviewType1_RBG;
		radioButtonGrp -edit -enable true SMPreviewType2_RBG;

		int $enableSelectType = (1 == `radioButtonGrp -q -select SMPreviewType1_RBG`);
		radioButtonGrp -edit -enable $enableSelectType SMPreviewSelectType_RBG;
	}

	editorTemplate -dimControl $nodeName "smoothLevel" $disableDisplayType;
	editorTemplate -dimControl $nodeName "displaySubdComps" $disableDisplayType;
	editorTemplate -dimControl $nodeName "continuity" $disableDisplayType;
	editorTemplate -dimControl $nodeName "smoothUVs" $disableDisplayType;
	editorTemplate -dimControl $nodeName "keepBorder" $disableDisplayType;
	editorTemplate -dimControl $nodeName "keepHardEdge" $disableDisplayType;
	editorTemplate -dimControl $nodeName "propagateEdgeHardness" $disableDisplayType;
	editorTemplate -dimControl $nodeName "smoothOffset" $disableDisplayType;
	editorTemplate -dimControl $nodeName "useSmoothPreviewForRender" $disableDisplayType;

	SMPcheckUsePreviewForRender($nodeName);
	SMPSetMapBordersEnableState();
}

global proc SMPSetMapBordersEnableState()
{
	int $enableMapBorders = (0 != `checkBoxGrp -q -value1 SMPreview_CBG`);

	if (`radioButtonGrp -query -exists SMMapBorders_RBG`)
	{
		radioButtonGrp -edit -enable $enableMapBorders SMMapBorders_RBG;
	}

	if (`checkBoxGrp -query -exists SMPreserver_CBG`)
	{
		checkBoxGrp -edit -enable $enableMapBorders SMPreserver_CBG;
	}
}

global proc SMPcheckUsePreviewForRender(string $nodeName)
{
	int $disableDisplayType = true;
	if (`checkBoxGrp -exists SMPreview_CBG`) {
		$disableDisplayType = (0 == `checkBoxGrp -q -value1 SMPreview_CBG`);
	}
	string $nodeAttr = $nodeName + ".useSmoothPreviewForRender";
	int $value = `getAttr $nodeAttr`;
	int $dim = ($disableDisplayType || $value);

	editorTemplate -dimControl $nodeName "renderSmoothLevel" $dim;
}

global proc SMPuseGlobalSmoothDrawType(string $nodeName)
{
	string $nodeAttr = $nodeName + ".useGlobalSmoothDrawType";
	int $value = `getAttr $nodeAttr`;
	editorTemplate -dimControl $nodeName "smoothDrawType" $value;
}

global proc AEbuildSmoothControls(string $nodeName)
{
	editorTemplate -beginLayout (uiRes("m_AEmeshTemplate.kSmoothMeshControls"));

		editorTemplate -callCustom 
			"SMPCustomControlsNew"
			"SMPCustomControlsReplace"
			"displaySmoothMesh"
			"smoothMeshSelectionMode";

		editorTemplate -label (uiRes("m_AEmeshTemplate.kUseSubdivisionMethod"))
			-addControl "useGlobalSmoothDrawType" "SMPuseGlobalSmoothDrawType";
		editorTemplate -label (uiRes("m_AEmeshTemplate.kSmoothDrawType"))
			-addControl "smoothDrawType";
		editorTemplate -callCustom 
			"SMPSmoothDrawTypeWarningNew"
			"SMPSmoothDrawTypeWarningReplace"
			"outSmoothMeshSubdError";

		editorTemplate -beginLayout (uiRes("m_AEmeshTemplate.kDisplaySmoothControls")) -collapse false;
			editorTemplate -label (uiRes("m_AEmeshTemplate.kDispSubdCompsAttr"))
				-addControl "displaySubdComps";
			editorTemplate -label (uiRes("m_AEmeshTemplate.kSmoothLevelAttr"))
				-addControl "smoothLevel";
			editorTemplate -label (uiRes("m_AEmeshTemplate.kUsePreviewLevel"))
				-addControl "useSmoothPreviewForRender" "SMPcheckUsePreviewForRender";
			editorTemplate -label (uiRes("m_AEmeshTemplate.kRenderSmoothLevel"))
				-addControl "renderSmoothLevel";

										
		editorTemplate -endLayout;

		editorTemplate -beginLayout (uiRes("m_AEmeshTemplate.kSmoothMeshOpenSubdivControls")) -collapse true;
		editorTemplate -beginNoOptimize;

		// For OSD Boundary Conditions
		//editorTemplate -addControl "useOsdBoundaryMethods"; // Hidden
		editorTemplate -label (uiRes("m_AEmeshTemplate.kSmoothMesh_osdVertBoundary_label")) -addControl "osdVertBoundary" ;
		editorTemplate -label (uiRes("m_AEmeshTemplate.kSmoothMesh_osdFvarBoundary_label"))     -addControl "osdFvarBoundary" ;

		// Additional OSD Parameters
		editorTemplate -label (uiRes("m_AEmeshTemplate.kSmoothMesh_osdFvarPropagateCorners_label")) -addControl "osdFvarPropagateCorners";
		editorTemplate -label (uiRes("m_AEmeshTemplate.kSmoothMesh_osdSmoothTriangles_label"))     -addControl "osdSmoothTriangles";
		editorTemplate -label (uiRes("m_AEmeshTemplate.kSmoothMesh_osdCreaseMethod_label"))        -addControl "osdCreaseMethod";
		editorTemplate -label (uiRes("m_AEmeshTemplate.kSmoothMesh_enableOpenCL_label")) -addControl "enableOpenCL";
		{
			editorTemplate -label (uiRes("m_AEmeshTemplate.kSmoothMesh_smoothTessLevel_label")) -addControl "smoothTessLevel";
			//editorTemplate -label _L10N(kSmoothMesh_smoothOsdColorizePatches_label, "Adaptive Colorized Patches") -addControl "smoothOsdColorizePatches" ;
			// Hide colorize for time being
			editorTemplate -suppress "smoothOsdColorizePatches";
		}

		// Displacement attributes
		editorTemplate -addSeparator;
		editorTemplate -label (uiRes("m_AEmeshTemplate.kSmoothMesh_showDisplacements_label"))   -addControl "showDisplacements";
		editorTemplate -label (uiRes("m_AEmeshTemplate.kSmoothMesh_loadTiledTextures_label")) -addControl "loadTiledTextures";
		editorTemplate -label (uiRes("m_AEmeshTemplate.kSmoothMesh_Displacement_label"))  -addControl "displacementType";

		editorTemplate -endNoOptimize;
		editorTemplate -endLayout;

		editorTemplate -beginLayout (uiRes("m_AEmeshTemplate.kSmoothMeshMayaControls")) -collapse true;
			editorTemplate -beginNoOptimize;

			editorTemplate -label (uiRes("m_AEmeshTemplate.kBoundaryRule"))
				-addControl "boundaryRule"; 
			editorTemplate -addControl "continuity";
			editorTemplate -addControl "smoothUVs";
			editorTemplate -addControl "propagateEdgeHardness";
			editorTemplate -endNoOptimize;
			editorTemplate -callCustom 
				"SMPMapBordersNew"
				"SMPMapBordersReplace"
				"keepMapBorders"
				"keepHardEdge"
				"keepBorder";
		editorTemplate -endLayout;

	editorTemplate -endLayout;

	editorTemplate -suppress "smoothOffset";
}

global proc AEdimBifrostNotImplementedControls( string $nodeName )
{
	string $bifrost = "bifrost";
	string $biAero = "bifrostAero";
	string $biLiquid = "bifrostLiquid"; 
	string $biCollider = "bifrostCollider";

	// When all false, remove this PROC
	editorTemplate -dimControl $nodeName ($biCollider + "Enable")					false;

	//editorTemplate -dimControl $nodeName  ($biAero + "Enable")					false;
	//editorTemplate -dimControl $nodeName  ($biAero + "VoxelScale")				true;
	//editorTemplate -dimControl $nodeName  ($biAero + "TransportPrecision")		true;
	//editorTemplate -dimControl $nodeName  ($biAero + "MinTransportSteps")			true;
	//editorTemplate -dimControl $nodeName  ($biAero + "MaxTransportSteps")			true;
	//editorTemplate -dimControl $nodeName  ($biAero + "TransportTimeScale")		true;

	//editorTemplate -dimControl $nodeName  ($biAero + "Density")					true;
	//editorTemplate -dimControl $nodeName  ($biAero + "Viscosity")					true;
	//editorTemplate -dimControl $nodeName  ($biAero + "ExpansionRate")				true;
	
	//editorTemplate -dimControl $nodeName  ($biAero + "Temperature")				false;
	//editorTemplate -dimControl $nodeName  ($biAero + "Fuel")						true;
	//editorTemplate -dimControl $nodeName  ($biAero + "Smoke")						false;	
	
	//editorTemplate -dimControl $nodeName  ($biAero + "FluidFractionThreshold")	true;

	//editorTemplate -dimControl $nodeName  ($biAero + "CacheSeparately")			true;
	//editorTemplate -dimControl $nodeName  ($biAero + "CacheBasename")				true;

	//editorTemplate -dimControl $nodeName  ($biAero + "Vorticity")					true;
	//editorTemplate -dimControl $nodeName  ($biAero + "Speed")						true;
	//editorTemplate -dimControl $nodeName  ($biAero + "UVTextureInfo")				true;

	editorTemplate -dimControl $nodeName   ($biLiquid + "Enable")					false;
	editorTemplate -dimControl $nodeName   ($biLiquid + "ContinuousEmission")		false;
		
	//editorTemplate -dimControl $nodeName   ($biLiquid + "VoxelScale")				true;
	//editorTemplate -dimControl $nodeName   ($biLiquid + "TransportPrecision")     true;
	//editorTemplate -dimControl $nodeName   ($biLiquid + "MinTransportSteps")      true;
	//editorTemplate -dimControl $nodeName   ($biLiquid + "MaxTransportSteps")      true;
	//editorTemplate -dimControl $nodeName   ($biLiquid + "TransportTimeScale")     true;	
	
	editorTemplate -dimControl $nodeName   ($biLiquid + "Density")					false;
	//editorTemplate -dimControl $nodeName   ($biLiquid + "Viscosity")				true;	
	editorTemplate -dimControl $nodeName   ($biLiquid + "ExpansionRate")			false;
	//editorTemplate -dimControl $nodeName   ($biLiquid + "SurfaceTension")         true;	
	
	editorTemplate -dimControl $nodeName   ($biLiquid + "StictionStrength")         false;
	editorTemplate -dimControl $nodeName   ($biLiquid + "StictionBandwidth")        false;	
	//editorTemplate -dimControl $nodeName   ($biLiquid + "DropletThreshold")       true;
	//editorTemplate -dimControl $nodeName   ($biLiquid + "DropletMergebackDepth")  true;
		
	//editorTemplate -dimControl $nodeName   ($biLiquid + "SurfaceParticleDensity")		true;
	//editorTemplate -dimControl $nodeName   ($biLiquid + "SurfaceBandwidth")			true;			
	//editorTemplate -dimControl $nodeName   ($biLiquid + "InteriorParticleDensity")	true;
	//editorTemplate -dimControl $nodeName   ($biLiquid + "RegulateParticles")			true;		
	//
	// editorTemplate -dimControl $nodeName   ($biLiquid + "VolumeRegulation")			true;		
	// editorTemplate -dimControl $nodeName   ($biLiquid + "FluidMergeFactor")			true;		
	// editorTemplate -dimControl $nodeName   ($biLiquid + "FluidVelocityKernel")		true;	
	// editorTemplate -dimControl $nodeName   ($biLiquid + "FluidFractionThreshold")	true;
	//
	//
	//
	//editorTemplate -dimControl $nodeName   ($biLiquid + "CacheSeparately")			true;
	//editorTemplate -dimControl $nodeName   ($biLiquid + "CacheBasename")				true;
	//
	//
	//
	//editorTemplate -dimControl $nodeName   ($biLiquid + "Vorticity")					true;	
	//editorTemplate -dimControl $nodeName   ($biLiquid + "Speed")						true;		
	//editorTemplate -dimControl $nodeName   ($biLiquid + "Curvature")					true;	
	//editorTemplate -dimControl $nodeName   ($biLiquid + "Splashiness")				true;	
	//editorTemplate -dimControl $nodeName   ($biLiquid + "ParticleAge")				true;	
	//editorTemplate -dimControl $nodeName   ($biLiquid + "ParticleID")					true;	
	//editorTemplate -dimControl $nodeName   ($biLiquid + "UVTextureInfo")				true; 

}

// AE dim and Channel Box remove attributes
global proc AEdimCBremoveControls( string $nodeName, string $attrName, int $dim )
{
	editorTemplate -dimControl $nodeName $attrName					$dim;	
	int $keyable = !$dim; 
	//setAttr -keyable $keyable -channelBox $keyable ($nodeName + "." + $attrName);
	setAttr -keyable $keyable ($nodeName + "." + $attrName);
}

global proc AEdimBifrostEnableCollisionControls( string $nodeName )
{
	if(`attributeExists  "bifrostColliderEnable" $nodeName `) {
		int $dim = !`getAttr ($nodeName + ".bifrostColliderEnable")`;
	
		AEdimCBremoveControls( $nodeName, "bifrostColliderThickness", $dim ); 
		AEdimCBremoveControls( $nodeName, "bifrostColliderMode", $dim ); 
	}
}

global proc AEdimBifrostEnableAccelaratorControls( string $nodeName )
{
	if(`attributeExists  "bifrostAcceleratorEnable" $nodeName `) {
		int $dim = !`getAttr ($nodeName + ".bifrostAcceleratorEnable")`;
	
		AEdimCBremoveControls( $nodeName, "bifrostAcceleratorMode", $dim ); 
		
		AEdimCBremoveControls( $nodeName, "bifrostAcceleratorInfluence", $dim ); 
		AEdimCBremoveControls( $nodeName, "bifrostAcceleratorInheritVelocity", $dim ); 
		AEdimCBremoveControls( $nodeName, "bifrostAcceleratorFalloffBandwidth", $dim ); 
		AEdimCBremoveControls( $nodeName, "bifrostAcceleratorInfluence", $dim ); 
		AEdimCBremoveControls( $nodeName, "bifrostAcceleratorDirectionMagnitude", $dim ); 
		AEdimCBremoveControls( $nodeName, "bifrostAcceleratorDirection", $dim ); 
		AEdimCBremoveControls( $nodeName, "bifrostAcceleratorDirectionX", $dim ); 
		AEdimCBremoveControls( $nodeName, "bifrostAcceleratorDirectionY", $dim ); 
		AEdimCBremoveControls( $nodeName, "bifrostAcceleratorDirectionZ", $dim ); 

		AEdimCBremoveControls( $nodeName, "bifrostAcceleratorBoundaryLayerStrength", $dim ); 
		AEdimCBremoveControls( $nodeName, "bifrostAcceleratorBoundaryLayerBandwidth", $dim ); 

	}
}

global proc AEdimBifrostEnableLiquidEmissionControls( string $nodeName )
{
	if(`attributeExists  "bifrostLiquidEnable" $nodeName `) {
		int $dim = !`getAttr ($nodeName + ".bifrostLiquidEnable")`;
	
		AEdimCBremoveControls( $nodeName, "bifrostLiquidContinuousEmission", $dim ); 

		AEdimCBremoveControls( $nodeName, "bifrostLiquidThickness", $dim ); 
		AEdimCBremoveControls( $nodeName, "bifrostLiquidMode", $dim ); 

		AEdimCBremoveControls( $nodeName, "bifrostLiquidDensity", $dim ); 
		AEdimCBremoveControls( $nodeName, "bifrostLiquidExpansionRate", $dim ); 

		AEdimCBremoveControls( $nodeName, "bifrostLiquidStictionStrength", $dim ); 
		AEdimCBremoveControls( $nodeName, "bifrostLiquidStictionBandwidth", $dim ); 
	}

}

global proc AEdimBifrostEnableAeroEmissionControls( string $nodeName )
{
	if(`attributeExists  "bifrostAeroEnable" $nodeName `) {
		int $dim = !`getAttr ($nodeName + ".bifrostAeroEnable")`;
	
		AEdimCBremoveControls( $nodeName, "bifrostAeroContinuousEmission", $dim ); 

		AEdimCBremoveControls( $nodeName, "bifrostAeroThickness", $dim ); 
		AEdimCBremoveControls( $nodeName, "bifrostAeroMode", $dim ); 

		AEdimCBremoveControls( $nodeName, "bifrostAeroStictionStrength", $dim ); 
		AEdimCBremoveControls( $nodeName, "bifrostAeroStictionBandwidth", $dim ); 

		AEdimCBremoveControls( $nodeName, "bifrostAeroDensity", $dim ); 
		AEdimCBremoveControls( $nodeName, "bifrostAeroTemperature", $dim ); 
	}

}


// Helper bifrost function that returns string const projection type 
proc string AEbifrostUVProjName( int $code ) {
    if ( $code == 0 ) return (uiRes("m_AEmeshTemplate.kBifrostProjNone"));
	else if ( $code == 1 ) return (uiRes("m_AEmeshTemplate.kBifrostProjPlanar"));
	else if ( $code == 2 ) return (uiRes("m_AEmeshTemplate.kBifrostProjCylindrical"));
	else if ( $code == 3 ) return (uiRes("m_AEmeshTemplate.kBifrostProjSpherical"));
	error "Unsupported uv proj code";
}

// Helper bifrost function that finds connected UV projection node
// $bifrostUVProjCon specify emitter bifrost attribute to link connection
proc string AEbifrostGetConnectedProj( string $bifrostUVProjCon )
{
	// Get node and attr 
	string $tokens[];
	$numTokens = `tokenize $bifrostUVProjCon "." $tokens`;
	if ($numTokens != 2) {
		return "";
	}
	if(`attributeExists $tokens[1] $tokens[0] `) {

    		string $plugs[] = `listConnections -d true -s false -sh false $bifrostUVProjCon`;
    		for( $plug in $plugs ) {
	    		string $nType = `nodeType $plug`;
			if ( $nType == "polyPlanarProj" || $nType == "polyCylProj" || $nType == "polySphProj" || $nType == "polyAutoProj" ) {
				return $plug;
			}
		}
	}
	return "";
}

// This proc set requested bifrost UV projection for emitter 
// $bifrostUVProjCon specify emitter bifrost attribute to link connection
// $proj specify requested projection as string constant at optionMenu
global proc AEbifrostSetUVProjection( string $bifrostUVProjCon, string $proj )
{
	string $existingproj = AEbifrostGetConnectedProj( $bifrostUVProjCon );
	if ( $existingproj != "" ) {
		// Check if we have the same projection already
	    string $nType = `nodeType $existingproj`;
		if ( $nType == "polyPlanarProj" ) {
			if ( $proj == `AEbifrostUVProjName( 1 )` )
 				return; // The same projeciton as requested
		}
		else if ( $nType == "polyCylProj" ) {
			if ( $proj == `AEbifrostUVProjName( 2 )` )
 				return; // The same projeciton as requested
		}
		else if ( $nType == "polySphProj" ) {
			if ( $proj == `AEbifrostUVProjName( 3 )` )
 				return; // The same projeciton as requested
		}

		// Delete old projection. We need create new (or leave empty in case none is selected)		
        delete $existingproj;
	}
	
	if ( $proj == `AEbifrostUVProjName( 0 )` )
		return; // None is selected

	string $prtype = "";
	if ( $proj == `AEbifrostUVProjName( 1 )` ) $prtype = "planar";
	else if ( $proj == `AEbifrostUVProjName( 2 )` ) $prtype = "cylindrical";
	else if ( $proj == `AEbifrostUVProjName( 3 )` ) $prtype = "spherical";
	else error "Unsupported uv proj type"; 


	// Get transform from shape 
	string $tokens[];
	$numTokens = `tokenize $bifrostUVProjCon "." $tokens`;
	string $shape = $tokens[0];
	string $parents[] = `listRelatives -fullPath -parent $shape`;
    string $emnode  = $parents[0];
	
	// Preserve selection
	string $select[] = `ls -sl`;
    string $uvsname = `getAttr $bifrostUVProjCon`;
	string $prnode[] = `polyProjection -type $prtype -uvs $uvsname -cm true ( $emnode + ".f[*]")`;
	select -r $select;
	
	// Connect newly created projection to bifrost connection attribute
	connectAttr -f $bifrostUVProjCon ($prnode[0] + ".uvSetName");
}


// This proc selects projection node and activates manipulator
// As result UV manipulator for UV bifrost projection is shown to user 
global proc AEbifrostProjToolActivate( string $bifrostUVProjCon )
{
	string $existingproj = AEbifrostGetConnectedProj( $bifrostUVProjCon );
	if ( $existingproj == "" )
		return;

	select -add $existingproj;
	setToolTo ShowManips;
}

// UI for bifrost UV projection
global proc AEbifrostProjToolNew( string $bifrostUVProjCon )
{
	string $cmd = "AEbifrostSetUVProjection( \"" + $bifrostUVProjCon + "\", \"#1\" );";
	setUITemplate -pst attributeEditorTemplate;
		columnLayout -adj true;
			rowLayout -nc 4 -adj 4 bifrostUVProjConLayout;
				text -label "";
		        optionMenu -label (uiRes("m_AEmeshTemplate.kBifrostProj")) -changeCommand $cmd currentProjSel;
        		    menuItem -label `AEbifrostUVProjName( 0 )`;
		            menuItem -label `AEbifrostUVProjName( 1 )`;
		            menuItem -label `AEbifrostUVProjName( 2 )`;
		            menuItem -label `AEbifrostUVProjName( 3 )`;
				button -label (uiRes("m_AEmeshTemplate.kBifrostProjMan")) activateProjTool;
				setParent ..;
		setParent ..;

	setParent ..;

	setUITemplate -ppt;
	setParent ..;

	AEbifrostProjToolReplace( $bifrostUVProjCon );
}

global proc AEbifrostProjToolReplace( string $bifrostUVProjCon )
{
	int $sel = 1;
	string $existingproj = AEbifrostGetConnectedProj( $bifrostUVProjCon );
	if ( $existingproj != "" ) {
	    string $nType = `nodeType $existingproj`;
		if ( $nType == "polyPlanarProj" ) $sel = 2;
		else if ( $nType == "polyCylProj" ) $sel = 3;
		else if ( $nType == "polySphProj" ) $sel = 4;
	}
	string $cmd = "AEbifrostSetUVProjection( \"" + $bifrostUVProjCon + "\", \"#1\" );";
	optionMenu -e -changeCommand $cmd currentProjSel;
	// optionMenu -e -select $sel currentProjSel;
	if ( $sel != 1 ) button -e -en true activateProjTool;
	else button -e -en false activateProjTool;
    button -e -c ("AEbifrostProjToolActivate( \"" + $bifrostUVProjCon + "\") ") activateProjTool;
}


global proc AEbuildBifrostMeshControls(string $nodeName)
{
	string $biAero = "bifrostAero";
	string $biLiquid = "bifrostLiquid";
	string $biCollider = "bifrostCollider";
	
	editorTemplate -beginLayout (uiRes("m_AEmeshTemplate.kBifrostMeshControls"));		

		//COLLISION + cheat callback to grey out at large!		
		editorTemplate -beginLayout (uiRes("m_AEmeshTemplate.kBifrostCollider")) -collapse true;
			editorTemplate -addDynamicControl -label (uiRes("m_AEmeshTemplate.kBifrostEnableCollision")) ($biCollider + "Enable") "AEdimBifrostEnableCollisionControls";
			editorTemplate -beginLayout (uiRes("m_AEmeshTemplate.kBifrostColliderConversion")) -collapse false;
				editorTemplate -addDynamicControl -label (uiRes("m_AEmeshTemplate.kBifrostColliderMode")) "bifrostColliderMode";
				editorTemplate -addDynamicControl -label (uiRes("m_AEmeshTemplate.kBifrostColliderThickness")) "bifrostColliderThickness";
			editorTemplate -endLayout;
		editorTemplate -endLayout;
		AEshowBlockIfAttrExists {"bifrostColliderEnable"};

		//ACCELERATOR		
		editorTemplate -beginLayout (uiRes("m_AEmeshTemplate.kBifrostAcceleration")) -collapse true;
			editorTemplate -addDynamicControl -label (uiRes("m_AEmeshTemplate.kBifrostAcceleratorEnable")) "bifrostAcceleratorEnable" "AEdimBifrostEnableAccelaratorControls";
			editorTemplate -beginLayout (uiRes("m_AEmeshTemplate.kBifrostAcceleratorConversion")) -collapse false;
				editorTemplate -addDynamicControl -label (uiRes("m_AEmeshTemplate.kBifrostAcceleratorMode")) "bifrostAcceleratorMode";
			editorTemplate -endLayout;
			editorTemplate -beginLayout (uiRes("m_AEmeshTemplate.kBifrostAccelerationGeometryInfluence")) -collapse false;
				editorTemplate -addDynamicControl -label (uiRes("m_AEmeshTemplate.kBifrostAcceleratorInfluencey")) "bifrostAcceleratorInfluence";		
				editorTemplate -addDynamicControl -label (uiRes("m_AEmeshTemplate.kBifrostAcceleratorInheritVelocity")) "bifrostAcceleratorInheritVelocity";
				editorTemplate -addDynamicControl -label (uiRes("m_AEmeshTemplate.kBifrostAcceleratorFalloffBandwidth")) "bifrostAcceleratorFalloffBandwidth";
				editorTemplate -addDynamicControl -label (uiRes("m_AEmeshTemplate.kBifrostAcceleratorMagnitude")) "bifrostAcceleratorDirectionMagnitude";
				editorTemplate -addDynamicControl -label (uiRes("m_AEmeshTemplate.kBifrostAcceleratorDirection")) "bifrostAcceleratorDirection";
			editorTemplate -endLayout;
			editorTemplate -beginLayout (uiRes("m_AEmeshTemplate.kBifrostAccelerationBoundaryLayer")) -collapse false;				
				editorTemplate -addDynamicControl -label (uiRes("m_AEmeshTemplate.kBifrostAcceleratorBoundaryLayerStrength")) "bifrostAcceleratorBoundaryLayerStrength";
				editorTemplate -addDynamicControl -label (uiRes("m_AEmeshTemplate.kBifrostAcceleratorBoundaryLayerBandwidth")) "bifrostAcceleratorBoundaryLayerBandwidth";
			editorTemplate -endLayout;
		editorTemplate -endLayout;
		AEshowBlockIfAttrExists {"bifrostAcceleratorEnable"};

		//LIQUID	
		editorTemplate -beginLayout (uiRes("m_AEmeshTemplate.kBifrostLiquidEmission")) -collapse true;
			editorTemplate -addDynamicControl -label (uiRes("m_AEmeshTemplate.kBifrostLiquidEnableEmission"))					($biLiquid + "Enable") "AEdimBifrostEnableLiquidEmissionControls";
			editorTemplate -addDynamicControl -label (uiRes("m_AEmeshTemplate.kBifrostLiquidContinuousEmission"))				($biLiquid + "ContinuousEmission"); 
			
			//editorTemplate -addDynamicControl -label _L10N( kBifrostLiquidVoxelScale, "Voxel Scale")								($biLiquid + "VoxelScale");
			//editorTemplate -addDynamicControl -label _L10N( kBifrostLiquidTransportPrecision, "Transport Precision")				($biLiquid + "TransportPrecision");
			//editorTemplate -addDynamicControl -label _L10N( kBifrostLiquidMinTransportSteps, "Min Transport Steps" )				($biLiquid + "MinTransportSteps");
			//editorTemplate -addDynamicControl -label _L10N( kBifrostLiquidMaxTransportSteps, "Max Transport Steps" )				($biLiquid + "MaxTransportSteps");
			//editorTemplate -addDynamicControl -label _L10N( kBifrostLiquidTransportTimeScale, "Transport Time Scale")				($biLiquid + "TransportTimeScale");
		
			editorTemplate -beginLayout (uiRes("m_AEmeshTemplate.kBifrostLiquidConversion")) -collapse false;
				editorTemplate -addDynamicControl -label (uiRes("m_AEmeshTemplate.kBifrostLiquidMode"))											($biLiquid + "Mode"); 
				editorTemplate -addDynamicControl -label (uiRes("m_AEmeshTemplate.kBifrostLiquidThickness"))								($biLiquid + "Thickness"); 
			editorTemplate -endLayout;

			editorTemplate -beginLayout (uiRes("m_AEmeshTemplate.kBifrostLiquidPhysicalAttributes")) -collapse false;
				editorTemplate -addDynamicControl -label (uiRes("m_AEmeshTemplate.kBifrostLiquidDensity"))									($biLiquid + "Density");
				//editorTemplate -addDynamicControl -label _L10N( kBifrostLiquidViscosity, "Viscosity")								($biLiquid + "Viscosity");	
				editorTemplate -addDynamicControl -label (uiRes("m_AEmeshTemplate.kBifrostLiquidExpansionRate"))						($biLiquid + "ExpansionRate");
				//editorTemplate -addDynamicControl -label _L10N( kBifrostLiquidSurfaceTension, "Surface Tension")					($biLiquid + "SurfaceTension");
			editorTemplate -endLayout;									
	
			editorTemplate -beginLayout (uiRes("m_AEmeshTemplate.kBifrostStickiness")) -collapse false;
				editorTemplate -addDynamicControl -label (uiRes("m_AEmeshTemplate.kBifrostLiquidStickinessStrength"))						($biLiquid + "StictionStrength");
				editorTemplate -addDynamicControl -label (uiRes("m_AEmeshTemplate.kBifrostLiquidStickinessBandwidth"))						($biLiquid + "StictionBandwidth");	
				//editorTemplate -addDynamicControl -label _L10N( kBifrostLiquidDropletThreshold, "Droplet Threshold")				($biLiquid + "DropletThreshold");
				//editorTemplate -addDynamicControl -label _L10N( kBifrostLiquidDropletMergebackDepth, "Droplet Mergeback Depth")		($biLiquid + "DropletMergebackDepth");
			editorTemplate -endLayout;

			//editorTemplate -beginLayout _L10N( kBifrostLiquidParticleDistribution, "Particle Distribution" ) -collapse false;
			//	editorTemplate -addDynamicControl -label _L10N( kBifrostLiquidSurfaceParticleDensity, "Surface Particle Density")	($biLiquid + "SurfaceParticleDensity");
			//	editorTemplate -addDynamicControl -label _L10N( kBifrostLiquidSurfaceBandwidth, "Surface Bandwidth")				($biLiquid + "SurfaceBandwidth");			
			//	editorTemplate -addDynamicControl -label _L10N( kBifrostLiquidInteriorParticleDensity, "Interior Particle Density")	($biLiquid + "InteriorParticleDensity");
			//	editorTemplate -addDynamicControl -label _L10N( kBifrostLiquidRegulateParticles, "Regulate Particles")				($biLiquid + "RegulateParticles");		
			//editorTemplate -endLayout;
			//
			//editorTemplate -beginLayout _L10N( kBifrostLiquidAdvancedAttributes, "Advanced Attributes" ) -collapse true;				 
			//	editorTemplate -addDynamicControl -label _L10N( kBifrostLiquidVolumeRegulation,	"Volume Regulation")				 ($biLiquid + "VolumeRegulation");		
			//	editorTemplate -addDynamicControl -label _L10N( kBifrostLiquidFluidMergeFactor, "Fluid Merge Factor")				 ($biLiquid + "FluidMergeFactor");		
			//	editorTemplate -addDynamicControl -label _L10N( kBifrostLiquidFluidVelocityKernel, "Fluid Velocity Kernel")			 ($biLiquid + "FluidVelocityKernel");	
			//	editorTemplate -addDynamicControl -label _L10N( kBifrostLiquidFluidFractionThreshold, "Fluid Fraction Threshold")	 ($biLiquid + "FluidFractionThreshold");
			//editorTemplate -endLayout;

			//editorTemplate -beginLayout _L10N( kBifrostLiquidCaching, "Caching" ) -collapse true;
			//	editorTemplate -addDynamicControl -label _L10N( kBifrostLiquidCacheSeparately, "Cache Separately" )					($biLiquid + "CacheSeparately");
			//	editorTemplate -addDynamicControl -label _L10N( kBifrostLiquidCacheBasename, "Basename" )							($biLiquid + "CacheBasename");
			//editorTemplate -endLayout;

			//editorTemplate -beginLayout _L10N( kBifrostLiquidExtraOutputChannels, "Extra Output Channels" ) -collapse true;
			//	editorTemplate -addDynamicControl -label _L10N( kBifrostLiquidVorticity,	"Vorticity")							($biLiquid + "Vorticity");	
			//	editorTemplate -addDynamicControl -label _L10N( kBifrostLiquidSpeed, "Speed")										($biLiquid + "Speed");		
			//	editorTemplate -addDynamicControl -label _L10N( kBifrostLiquidCurvature, "Curvature")								($biLiquid + "Curvature");	
			//	editorTemplate -addDynamicControl -label _L10N( kBifrostLiquidSplashiness, "Splashiness")							($biLiquid + "Splashiness");	
			//	editorTemplate -addDynamicControl -label _L10N( kBifrostLiquidParticleAge,	"Particle Age")							($biLiquid + "ParticleAge");	
			//	editorTemplate -addDynamicControl -label _L10N( kBifrostLiquidParticleID, "Particle ID")							($biLiquid + "ParticleID");	
			//	editorTemplate -addDynamicControl -label _L10N( kBifrostLiquidUVTextureInfo, "UV Texture Info")						($biLiquid + "UVTextureInfo"); 
			//editorTemplate -endLayout;
		editorTemplate -endLayout;
		AEshowBlockIfAttrExists {"bifrostLiquidEnable"};

		// AERO
		editorTemplate -beginLayout (uiRes("m_AEmeshTemplate.kBifrostAeroEmission")) -collapse true;
			editorTemplate -addDynamicControl -label (uiRes("m_AEmeshTemplate.kBifrostAeroEnableEmission"))				($biAero + "Enable") 	"AEdimBifrostEnableAeroEmissionControls";
			editorTemplate -addDynamicControl -label (uiRes("m_AEmeshTemplate.kBifrostAeroContinuousEmission"))  ($biAero + "ContinuousEmission"); 
			editorTemplate -addDynamicControl -label (uiRes("m_AEmeshTemplate.kBifrostAeroEmissionDensity"))     			($biAero + "Density"); 
			editorTemplate -addDynamicControl -label (uiRes("m_AEmeshTemplate.kBifrostAeroEmissionTemp"))			($biAero + "Temperature"); 

			editorTemplate -beginLayout (uiRes("m_AEmeshTemplate.kBifrostAeroConversion")) -collapse false;
				editorTemplate -addDynamicControl -label (uiRes("m_AEmeshTemplate.kBifrostAeroMode"))							($biAero + "Mode"); 
				editorTemplate -addDynamicControl -label (uiRes("m_AEmeshTemplate.kBifrostAeroThickness"))					($biAero + "Thickness"); 
			editorTemplate -endLayout;

			editorTemplate -beginLayout (uiRes("m_AEmeshTemplate.kBifrostAeroStickiness")) -collapse false;
				editorTemplate -addDynamicControl -label (uiRes("m_AEmeshTemplate.kBifrostAeroStickinessStrength"))		($biAero + "StictionStrength");
				editorTemplate -addDynamicControl -label (uiRes("m_AEmeshTemplate.kBifrostAeroStickinessBandwidth"))	($biAero + "StictionBandwidth");	
			editorTemplate -endLayout;

		editorTemplate -endLayout;		
		AEshowBlockIfAttrExists {"bifrostAeroEnable"};

		// UVProjection
		editorTemplate -beginLayout (uiRes("m_AEmeshTemplate.kBifrostUVTitle")) -collapse true;
			editorTemplate -callCustom AEbifrostProjToolNew AEbifrostProjToolReplace "bifrostUVProjCon";			

		editorTemplate -endLayout;
		AEshowBlockIfAttrExists {"bifrostLiquidEnable", "bifrostAeroEnable"};		

	editorTemplate -endLayout;
	AEshowBlockIfAttrExists {"bifrostColliderEnable", "bifrostAcceleratorEnable", "bifrostLiquidEnable", "bifrostAeroEnable"};
}


global proc checkMeshReuseTrianglesAE( string $nodeName )
{
	int $val = `getAttr ($nodeName+".reuseTriangles")`;	
	polyOptions -reuseTriangles $val $nodeName;
}

global proc AEmeshTangentSpaceChange( string $tangentSpaceMenu, string $windingOrderMenu, string $attr)
{
	int $space = `radioButtonGrp -query -select $tangentSpaceMenu` - 1;
	int $windingOrder = `radioButtonGrp -query -select $windingOrderMenu` - 1;
	if( $windingOrder >= 0 && $space >= 0)
		setAttr $attr ($space * 2 + $windingOrder);
}

global proc AEmeshTangentSpaceNew( string $attributeUIName, string $attr)
{
	string $tangentSpaceMenu = "AEmeshTangentSpace" + $attributeUIName;
	string $windingOrderMenu = "AEmeshWindingOrder" + $attributeUIName;

	radioButtonGrp 
		-numberOfRadioButtons 2 
		-label (uiRes("m_AEmeshTemplate.kTangentSpaceCoordinateSystem")) 
		-labelArray2 	(uiRes("m_AEmeshTemplate.kRightHandedTangents")) 
						(uiRes("m_AEmeshTemplate.kLeftHandedTangents")) 
		$tangentSpaceMenu;

	radioButtonGrp 
		-numberOfRadioButtons 2 
		-label (uiRes("m_AEmeshTemplate.kTangentSpaceUVWindingOrder")) 
		-labelArray2 	(uiRes("m_AEmeshTemplate.kDetectUVWindingOrder")) 
						(uiRes("m_AEmeshTemplate.kIgnoreUVWindingOrder")) 
		$windingOrderMenu;

	AEmeshTangentSpaceReplace($attributeUIName, $attr);
}

global proc AEmeshTangentSpaceReplace( string $attributeUIName, string $attr )
{
	string $tangentSpaceMenu = "AEmeshTangentSpace" + $attributeUIName;
	string $windingOrderMenu = "AEmeshWindingOrder" + $attributeUIName;

	int $value = `getAttr $attr`;
	int $space = $value / 2;
	int $windingOrder = $value - $space * 2;
	
	radioButtonGrp -e -select ($space + 1) $tangentSpaceMenu;
	radioButtonGrp -edit -changeCommand
		("AEmeshTangentSpaceChange " + $tangentSpaceMenu + " " + $windingOrderMenu + " " + $attr)
		$tangentSpaceMenu;
	radioButtonGrp -edit -enable true $tangentSpaceMenu;

	radioButtonGrp -edit -select ($windingOrder + 1) $windingOrderMenu;
	radioButtonGrp -edit -changeCommand
		("AEmeshTangentSpaceChange " + $tangentSpaceMenu + " " + $windingOrderMenu + " " + $attr)
		$windingOrderMenu;
	radioButtonGrp -edit -enable true $windingOrderMenu;

}


global proc AEmeshTemplate( string $nodeName )
{
	editorTemplate -beginScrollLayout;


		editorTemplate -beginLayout (uiRes("m_AEmeshTemplate.kTessellationAttributes"));

			editorTemplate -addControl "maxTriangles";

			editorTemplate -addControl "useMaxSubdivisions" 
						"checkMeshUseMaxSubd";
			editorTemplate -addControl "maxSubd";

			editorTemplate -addControl "useMinScreen"
						"checkMeshUseMinScreen";
			editorTemplate -addControl "minScreen";

			editorTemplate -addControl "useMaxUV"
						"checkMeshUseMaxUv";
			editorTemplate -addControl "maxUv";

			editorTemplate -addControl "useMinEdgeLength"
						"checkMeshUseMinEdgeLength";
			editorTemplate -addControl "minEdgeLength";

			editorTemplate -addControl "useMaxEdgeLength"
						"checkMeshUseMaxEdgeLength";
			editorTemplate -addControl "maxEdgeLength";

		editorTemplate -endLayout;

		editorTemplate -beginLayout (uiRes("m_AEmeshTemplate.kMeshComponentDisplay"));
			editorTemplate -beginNoOptimize;
			editorTemplate -addControl "displayImmediate";
			editorTemplate -addControl "displayVertices"
				"checkMeshDisplayVertices";
			editorTemplate -addControl "vertexSize";
			editorTemplate -addControl "vertexBackfaceCulling";
			editorTemplate -addControl "backfaceCulling";

			editorTemplate -endNoOptimize;
	
			editorTemplate -addSeparator;
			editorTemplate -addControl "displayEdges";	
			editorTemplate -addControl "displayBorders" 
				"checkMeshDisplayBorder";
			editorTemplate -addControl "borderWidth";
	
			editorTemplate -addSeparator;
			editorTemplate -beginNoOptimize;
			editorTemplate -suppress "displayItemNumbers";			
			editorTemplate -addControl "displayCenter";
			editorTemplate -addControl "displayTriangles";
			editorTemplate -label (uiRes("m_AEmeshTemplate.kDisplayUVs")) -addControl "displayUVs" 
				"checkMeshDisplayUVs";
			editorTemplate -addControl "uvSize";
			editorTemplate -addControl "displayNonPlanar";
			editorTemplate -label (uiRes("m_AEmeshTemplate.kDisplayInvisibleFaces")) -addControl "displayInvisibleFaces";
			
			editorTemplate -addSeparator;
					
			editorTemplate -addControl "displayColors";
			editorTemplate -callCustom 
				"AEdisplayColorChannelNew"
				"AEdisplayColorChannelReplace"
				"displayColorChannel";
				
			editorTemplate -addControl "materialBlend";				
			
			editorTemplate -addSeparator;
			editorTemplate -addControl "displayNormal" 
						"checkMeshDisplayNormals";
			editorTemplate -addControl "displayTangent" 
						"checkMeshDisplayNormals";
			editorTemplate -addControl "normalSize"
						"checkMeshDisplayNormals";
			editorTemplate -addControl "normalType";

			editorTemplate -endNoOptimize;
	
		editorTemplate -endLayout;

		editorTemplate -beginLayout (uiRes("m_AEmeshTemplate.kMeshControls"));
			editorTemplate -addControl "currentUVSet";
			editorTemplate -addControl "currentColorSet";
			editorTemplate -addControl "motionVectorColorSet";
			editorTemplate -addControl "vertexColorSource";
			editorTemplate -addControl "allowTopologyMod" "checkMeshAllowTopologyMod";
			editorTemplate -addControl "quadSplit";
			editorTemplate -addControl "vertexNormalMethod";
			editorTemplate -addSeparator;
			editorTemplate -addControl "displayAlphaAsGreyScale";
			editorTemplate -addSeparator;
			editorTemplate -addControl "reuseTriangles" "checkMeshReuseTrianglesAE";
		editorTemplate -endLayout;
		
		editorTemplate -beginLayout (uiRes("m_AEmeshTemplate.kTangentSpace"));
			editorTemplate -callCustom  "AEmeshTangentSpaceNew     \"Mesh\"" 
										"AEmeshTangentSpaceReplace \"Mesh\"" 
										"tangentSpace";
			editorTemplate -addControl "tangentSmoothingAngle";
			editorTemplate -addControl "tangentNormalThreshold";
		editorTemplate -endLayout;
		
		AEbuildSmoothControls($nodeName);
		
		// include/call base class/node attributes
		AEsurfaceShapeTemplate $nodeName;
		AEbuildBifrostMeshControls $nodeName;

		// supressed attributes
		editorTemplate -suppress "inMesh";
		editorTemplate -suppress "outMesh";
		editorTemplate -suppress "outSmoothMesh";
		editorTemplate -suppress "cachedInMesh";
		editorTemplate -suppress "useNumTriangles";
		editorTemplate -suppress "numTriangles";
		editorTemplate -suppress "pnts";
		editorTemplate -suppress "colors";
		editorTemplate -suppress "colorPerVertex";
		editorTemplate -suppress "normalPerVertex";
		editorTemplate -suppress "uvSet";
		editorTemplate -suppress "normals";
		editorTemplate -suppress "displayFacesWithGroupId";
		editorTemplate -suppress "userTrg";
		editorTemplate -suppress "collisionOffsetVelocityIncrement";
		editorTemplate -suppress "collisionDepthVelocityIncrement";
		editorTemplate -suppress "perInstanceIndex";
		editorTemplate -suppress "perInstanceTag";
		editorTemplate -suppress "useMeshSculptCache";
		editorTemplate -suppress "computeFromSculptCache";
		editorTemplate -suppress "useMeshTexSculptCache";
		editorTemplate -suppress "freeze";

	editorTemplate -addExtraControls;

	editorTemplate -addDynamicControl "collisionEnable";
	editorTemplate -addDynamicControl "collisionOffset";
	editorTemplate -addDynamicControl "collisionDepth";
	editorTemplate -addDynamicControl "collisionPriority";
	editorTemplate -addDynamicControl "depthMapEnable";
	editorTemplate -addDynamicControl "depthMapWeight";
	editorTemplate -addDynamicControl "displayCollision";
	AEaddDynRampClothCollision "collisionOffsetVelocityMultiplier";
	AEaddDynRampClothCollision "collisionDepthVelocityMultiplier";

	editorTemplate -endScrollLayout;

}
