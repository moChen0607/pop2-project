// Copyright (C) 1997-2014 Autodesk, Inc., and/or its licensors.
// All rights reserved.
//
// The coded instructions, statements, computer programs, and/or related
// material (collectively the "Data") in these files contain unpublished
// information proprietary to Autodesk, Inc. ("Autodesk") and/or its licensors,
// which is protected by U.S. and Canadian federal copyright law and by
// international treaties.
//
// The Data is provided for use exclusively by You. You have the right to use,
// modify, and incorporate this Data into other products for purposes authorized 
// by the Autodesk software license agreement, without fee.
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND. AUTODESK
// DOES NOT MAKE AND HEREBY DISCLAIMS ANY EXPRESS OR IMPLIED WARRANTIES
// INCLUDING, BUT NOT LIMITED TO, THE WARRANTIES OF NON-INFRINGEMENT,
// MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE, OR ARISING FROM A COURSE 
// OF DEALING, USAGE, OR TRADE PRACTICE. IN NO EVENT WILL AUTODESK AND/OR ITS
// LICENSORS BE LIABLE FOR ANY LOST REVENUES, DATA, OR PROFITS, OR SPECIAL,
// DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES, EVEN IF AUTODESK AND/OR ITS
// LICENSORS HAS BEEN ADVISED OF THE POSSIBILITY OR PROBABILITY OF SUCH DAMAGES.

//
//
//  Creation Date:  July 16, 1997
//
//  Procedure Name:
//  AEnewNonNumericMulti
//
//  Description Name;
//  Creates appropriate controls for a non-numeric multi
//
//  Input Value:
//  node (name)
// 
//  Return Value:
//  This method must return the name of the OUTERMOST layout
//  created here.  This will be used later to delete these controls.
//
  
//
// This procedure creates a new plug for the multiAttr.
// It first finds the max index, and increase the index by 1.
global proc AEnewNonNumericMultiAddNewItem(
	string $node, 
	string $multiAttr
	)
{
	string $attr = ($node + "." + $multiAttr);

	// Find the next available index
	int $nextAvailable = 0;

	string $buffer;
	if( `getAttr -s $attr` > 0 )
	{
		//	Get currently used indices
		//	The return value looks like this: {rgb[0], rgb[0].r, rgb[0].g, rgb[0].b, rgb[3], ... }
		string $multi[] = `listAttr -multi $attr`;

		for($m in $multi)
		{
			//	Find index [n]
			$buffer = match("\\[[0-9]+\\]", $m);

			//	Find n. Use implicate data type conversion. string "15" is converted to int 15
			int $index = match("[0-9]+", $buffer);
			
			if ( $index >= $nextAvailable )
				$nextAvailable = $index + 1;
		}
	}

	// Creat a new plug.
	string $plugName = $attr + "[" + $nextAvailable + "]";

	int $isMentalrayNode = isClassified( $node, "rendernode/mentalray");

	// Create a plug by accessing it
	catchQuiet( `getAttr -type $plugName`);

	//	If this is a mental ray shader's color Attr, 
	//	make sure the alpha component is removed.
	if( $isMentalrayNode &&
		`attributeQuery -node $node -usedAsColor $multiAttr` &&
		`attributeQuery -node $node -exists ($multiAttr + "A")` 
		)
	{
		catchQuiet( `getAttr -type ($attr + "A[" + $nextAvailable + "]")`);
	}
}

//	
//	Remove the specified element
global proc AEremoveMultiElement(string $plugName)
{
	//	Get node name and attr name
	string $buffer[];
	tokenize($plugName, ".", $buffer);
	string $nodeName = $buffer[0];

	int $layerClip = isClassified( $nodeName, "animation/animLayerClip");
	string $connFrom[];
	if($layerClip)
	{
		$clipPlugName = $plugName + ".clipInput";
		$connFrom = `listConnections -d false -s true $clipPlugName`;
	}

	removeMultiInstance -break true $plugName;

	//	If this is a mental ray shader's color Attr, 
	//	make sure the alpha component is removed.

	string $multiParent = $buffer[1];
	tokenize($multiParent, "[",$buffer);
	string $attrName = $buffer[0];

	if( isClassified( $nodeName, "rendernode/mentalray") &&
		`attributeQuery -node $nodeName -usedAsColor $attrName` &&
		`attributeQuery -node $nodeName -exists ($attrName + "A")` 
		)
	{
		removeMultiInstance -break true ($nodeName + "." + $attrName + "A" + "[" + $buffer[1]);
	}
	
	if( $layerClip )
	{
		$attrName = $nodeName + "." + $attrName;

		if (size(`getAttr -multiIndices $attrName`) == 0)
		{
			//	When all clips on the clip node are deleted, then delete the empty clip node as well.
			catch(`delete $nodeName`);
		}

		if ( size($connFrom) ) 
		{
			string $connTo[] = `listConnections -d true -s false $connFrom[0]`;
			if (size($connTo) < 1)
			{
				// The curve connected to that clip will be deleted if the curve is not connected to any other nodes. 
				catch(`delete $connFrom[0]`);
			}
		}
	}
}

//
//	Create a new control for the array element
global proc AEnewNonNumericMultiCreateNewControl(
	string $nodeName,
	string $attributeName,
	string $cc,
	string $attributeTypeProc,
	int $elementIndex)
{
	if ($elementIndex == -1) return;

	// build the plug name
	//
	string $plugName = ($nodeName+"."+$attributeName+"["+$elementIndex+"]");

	// build the attribute UI name
	//
	string $attrName = `attributeName -nice $plugName`;

	// build the command
	//
	string $cmd = ($attributeTypeProc + " \""
			+ $plugName + "\" \""
			+ $attrName + "\" "
			+ $cc);

	int $isUserDefinedCompound = ( $attributeTypeProc == "AEnewCompound" );

	//	if the attr is not a user-defined compound,
	//	create a control and a "Delete" button in a rowLayout
	if( $isUserDefinedCompound == 0 )
	{

		// Use attributeEditorMultiTemplate 
		// so that the "Delete" button appears next to array elements
		setUITemplate -pst attributeEditorMultiTemplate;

			// row layout to contain the attr control, "delete" button
			rowLayout -nc 3;

			// Create a control for the attribute
			//
			eval($cmd);

			// Add a "Delete" button
			symbolButton 
				-image "smallTrash.png" 
				-command ("AEremoveMultiElement " + $plugName);
			text -label "";
		setParent ..;
		setUITemplate -ppt;
	}
	else
	{
		//	This is a multi of user-defined compound
		//	The "Delete" button will be created inside the compound frameLayout

		// Create a control for the attribute
		//
		eval($cmd);
	}
}

global proc string AEnewNonNumericMulti(string	$nodeName,
										string	$attributeName,
										string	$uiName,
										string	$changedCommand,
										string	$attributeTypeProc,
										int		$elementIndexString[])
{
	global int $gMaxNonNumericMultis = 20;

	// create a frameLayout
	//
	string $createdFrame = `frameLayout -l $uiName -collapse false`;  // outermost layout name is returned at end

		// create a columnLayout (hide it while we're creating the controls)
		//
		string $createdColumn = `columnLayout -adj true -vis false`;

			// "Add New Item" button
			rowLayout -nc 2 ;
				text -label "";
				button -label (uiRes("m_AEnewNonNumericMulti.kAddNewItem")) 
					-command ("AEnewNonNumericMultiAddNewItem(\"" + $nodeName+"\",\""+$attributeName + "\")");
			setParent ..;

			string	$plugName, $attrname, $cmd;

			// build the changedCommand
			//
			string $cc = "\"\"";
			if ($changedCommand != "") {
				$cc = ("("+$changedCommand+" \""+$nodeName+"\")");
			} 

			// get the number of multis that need controls
			//
			int		$numElements = size($elementIndexString);
			
			// if there are more than $gMaxNonNumericMultis elements, clip them.
			//
			int $tooBig = 0;
			if ( $numElements > $gMaxNonNumericMultis ){
				$tooBig = $numElements - $gMaxNonNumericMultis;
				$numElements = $gMaxNonNumericMultis;
			}

			// build the controls for the multis
			//
			for ( $i = 0; $i < $numElements; $i++ ) {
				AEnewNonNumericMultiCreateNewControl(
					$nodeName, $attributeName, $cc, $attributeTypeProc, $elementIndexString[$i]);
				
			}
			
			// if there are elements that we cannot display, tell the user
			//
			if ( $tooBig > 0 ){
				string $fmt = (uiRes("m_AEnewNonNumericMulti.kInsufficientRoom"));
				text -l `format -s $tooBig $fmt`;
			}

		setParent ..;

		// make the columnLayout visible
		//
		columnLayout -e -vis true $createdColumn;

	setParent ..;

	return $createdFrame;

}
