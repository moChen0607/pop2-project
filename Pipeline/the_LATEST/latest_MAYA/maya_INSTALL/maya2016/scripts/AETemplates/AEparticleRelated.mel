// Copyright (C) 1997-2014 Autodesk, Inc., and/or its licensors.
// All rights reserved.
//
// The coded instructions, statements, computer programs, and/or related
// material (collectively the "Data") in these files contain unpublished
// information proprietary to Autodesk, Inc. ("Autodesk") and/or its licensors,
// which is protected by U.S. and Canadian federal copyright law and by
// international treaties.
//
// The Data is provided for use exclusively by You. You have the right to use,
// modify, and incorporate this Data into other products for purposes authorized 
// by the Autodesk software license agreement, without fee.
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND. AUTODESK
// DOES NOT MAKE AND HEREBY DISCLAIMS ANY EXPRESS OR IMPLIED WARRANTIES
// INCLUDING, BUT NOT LIMITED TO, THE WARRANTIES OF NON-INFRINGEMENT,
// MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE, OR ARISING FROM A COURSE 
// OF DEALING, USAGE, OR TRADE PRACTICE. IN NO EVENT WILL AUTODESK AND/OR ITS
// LICENSORS BE LIABLE FOR ANY LOST REVENUES, DATA, OR PROFITS, OR SPECIAL,
// DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES, EVEN IF AUTODESK AND/OR ITS
// LICENSORS HAS BEEN ADVISED OF THE POSSIBILITY OR PROBABILITY OF SUCH DAMAGES.

//
//
//  Creation Date:	1998
//
proc string[] particleSamplerInfoNodeList( string $node )
//
// Description:
//   returns a list of particle sampler info nodes in
// the history of the given node.
//
{
	int $resultCount = 0;
	string $result[];
	string $history[] = `listHistory $node`;
	int $i;
	int $count = size($history);
	for ($i =  0; $i < $count; $i++)
	{
		if( `nodeType $history[$i]` == "particleSamplerInfo" )
		{
			$result[ $resultCount ] = $history[$i];
			$resultCount++;
		}
	}
	return $result;
}

global proc string[] AEparticleRelated (string $node)
//
//  Description:
//		Return a list of nodes related to the particle that we want to
//		display tabs for when the particle is in the AE.
//      We include every node related to the particle's motion and look:
//      emitters, springs, shaders, the works.  This lets the customer
//      always just select the paricle shape to edit anything.
//
//  Input Value:
//	   nodeName:  name of the particle node that is in the editor, that
//				  we are finding related nodes for.
//
//  Output Value:
//		The list of related nodes, with the node whose tab we want to be
//          opened, with the particle node added at the end of the
//          array.  The related nodes are (in order of appearance):
//          emitters, shaders, instancers, fields, springs, and geoConnectors.
{
	string $relatedNodes[];

	int $i, $connCount;

	// Add connected emitters.
	// Just look for source plugs.  It the particle is connected to an
	// emitter's "output" plug, then the emitter must be emitting into that 
	// particle, and we want that emitter's tab to go in the Attribute Editor
	// with the particle.
	//
	// Get the list of the particle's source connections.
	//
	string $connections[] = 
		`listConnections -type "pointEmitter" -plugs true -d false ($node)`;

	// See if the particle is connected to the emitter's output attribute.
	// If it is, add it to the list of related nodes.
	//
	int $numRelated = 0;
	for ($i = 0; $i < size($connections); $i++) 
	{
		string $matchString = match("output", $connections[$i]);
		if ($matchString == "output") 
		{
			string $buffer[]; 
			tokenize($connections[$i], ".", $buffer);
			$relatedNodes[$numRelated] = $buffer[0];
			$numRelated++;
		}
	}

	// Tabs for assigned shaders.
	//
	// If we are using cloud rendering, both shaders are relevant.
	// If we are using blobby or any other type of rendering,
	// only the surface shader is relevant.
	// So, always add the surface shader; add the volume shader
	// if and only if we are using cloud rendering.
	// If we don't find any of those, we just add the shading engine.
	// This is the same behavior as for geometry.
	//
	string $seList[] = `listConnections -type shadingEngine $node`;
	if (size($seList) > 0)
	{
		int $addedCount = 0;
		string $buffer[];

		// Add the volume shader if we are cloud or tube rendering
		// Add it first so it appears first.
		//
		if ( (8 == `getAttr ($node+".particleRenderType")`) ||  
		     (9 == `getAttr ($node+".particleRenderType")`) )
		{
			$buffer = `listConnections ($seList[0]+".volumeShader")`;
			if (size($buffer) > 0)
			{
				$relatedNodes[$numRelated] = $buffer[0];
				$numRelated++;
				$addedCount++;

				// Also add all particle sampler info nodes for this shader.
				//
				string $samplerInfoNodes[] = particleSamplerInfoNodeList( $buffer[0] );
				int $i;
				int $samplerInfoCount = size($samplerInfoNodes);
				for ($i = 0; $i < $samplerInfoCount; $i++)
				{
					$relatedNodes[$numRelated] = $samplerInfoNodes[$i];
					$numRelated++;
					$addedCount++;
				}
			}
		}

		// Add the surface shader except in tube rendering.
		//
		if (9 != `getAttr ($node+".particleRenderType")`)
		{
			$buffer = `listConnections ($seList[0]+".surfaceShader")`;
			if (size($buffer) > 0)
			{
				$relatedNodes[$numRelated] = $buffer[0];
				$numRelated++;
				$addedCount++;

				// Add all particle sampler info nodes 
				// associated with this shader.
				//
				string $samplerInfoNodes[] = particleSamplerInfoNodeList( $buffer[0] );
				int $i;
				int $samplerInfoCount = size($samplerInfoNodes);
				for ($i = 0; $i < $samplerInfoCount; $i++)
				{
					$relatedNodes[$numRelated] = $samplerInfoNodes[$i];
					$numRelated++;
					$addedCount++;
				}
			}	
		}
        
		string $thirdPartyConnectedShaders[] = `callbacks -executeCallbacks -hook "firstConnectedShader" $seList[0]`;
        string $thirdPartyConnectedShader;
        
        for ($thirdPartyConnectedShader in $thirdPartyConnectedShaders){
            if (size($thirdPartyConnectedShader)){
                $relatedNodes[$numRelated] = $thirdPartyConnectedShader;
                $numRelated++;
                $addedCount++;
            }
        }
        		
		// If no shaders were connected to the shading engine,
		// add a tab for the shading engine instead.
		//
		if ($addedCount == 0)
		{
			$relatedNodes[$numRelated] = $seList[0];
			$numRelated++;
		}
	}

	//
	// Add tabs for each instancer node that this particle object
	// driving.
	//
	$connections = `listConnections -type "instancer" -d true $node`;
	$connCount = size($connections);
	for( $i = 0; $i < $connCount; $i ++ )
	{
		$relatedNodes[$numRelated] = $connections[$i];
		$numRelated ++;
	}

	// Likewise add all fields.
	//
	$connections = 
		`listConnections -type "field" -plugs true -d false ($node)`;

	// See if the particle is connected to the field's output attribute.
	// If it is, add it to the list of related nodes.
	//
	$connCount = size($connections);
	for ($i = 0; $i < $connCount; $i++) 
	{
		string $matchString = match("outputForce", $connections[$i]);
		if ($matchString == "outputForce") 
		{
			string $buffer[]; 
			tokenize($connections[$i], ".", $buffer);
			$relatedNodes[$numRelated] = $buffer[0];
			$numRelated++;
		}
	}

	// Add all springs. There is one incoming connection per spring object.
	//
	$connections = `listConnections -type "spring" -d false -plugs true ($node)`;
	$connCount = size($connections);
	for( $i = 0; $i < $connCount; $i++ ) 
	{
		string $buffer[]; 
		tokenize($connections[$i], ".", $buffer);
		$relatedNodes[$numRelated] = $buffer[0];
		$numRelated++;
	}

	// Just look for geoConnector source plugs.  If particle is connected
	// to a geoConnector's "friction" plug, then the object owned by the
	// geoConnector is a collide object for that particle, and we want that
	// geoConnector's tab to go in the Attribute Editor with the particle,
	// so the user can more easily edit the resilience and friction attributes.
	//
	// Get the list of the particle's source connections.
	//
	$connections = 
		`listConnections -type "geoConnector" -plugs true -d false ($node)`;

	// If the particle is connected to the geoConnector's friction attribute.
	// add it to the list of related nodes.
	//
	$connCount = size($connections);
	for ($i = 0; $i < $connCount; $i++) 
	{
		string $matchString = match("friction", $connections[$i]);
		if ($matchString == "friction") 
		{
			string $buffer[]; 
			tokenize($connections[$i], ".", $buffer);
			$relatedNodes[$numRelated] = $buffer[0];
			$numRelated++;
		}
	}

	// The AE will first open the tab at the end of the list, so add the
	// particle shape node name at the end of the list so it will be opened.
	// Actually, we have to add it twice, because "they" are assuming the last
	// one is a duplicate and are stripping it out. 
	//
	int $index = size($relatedNodes);

	$relatedNodes[$index] = $node;
	$relatedNodes[$index+1] = $node;

	string $deformerRelatedNodes[] = `defaultNavigation -ren -d $node`;
	for ($tmpNode in $deformerRelatedNodes) {
		$relatedNodes[size($relatedNodes)] = $tmpNode;
	}

	return $relatedNodes;
}

