// Copyright (C) 1997-2014 Autodesk, Inc., and/or its licensors.
// All rights reserved.
//
// The coded instructions, statements, computer programs, and/or related
// material (collectively the "Data") in these files contain unpublished
// information proprietary to Autodesk, Inc. ("Autodesk") and/or its licensors,
// which is protected by U.S. and Canadian federal copyright law and by
// international treaties.
//
// The Data is provided for use exclusively by You. You have the right to use,
// modify, and incorporate this Data into other products for purposes authorized 
// by the Autodesk software license agreement, without fee.
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND. AUTODESK
// DOES NOT MAKE AND HEREBY DISCLAIMS ANY EXPRESS OR IMPLIED WARRANTIES
// INCLUDING, BUT NOT LIMITED TO, THE WARRANTIES OF NON-INFRINGEMENT,
// MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE, OR ARISING FROM A COURSE 
// OF DEALING, USAGE, OR TRADE PRACTICE. IN NO EVENT WILL AUTODESK AND/OR ITS
// LICENSORS BE LIABLE FOR ANY LOST REVENUES, DATA, OR PROFITS, OR SPECIAL,
// DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES, EVEN IF AUTODESK AND/OR ITS
// LICENSORS HAS BEEN ADVISED OF THE POSSIBILITY OR PROBABILITY OF SUCH DAMAGES.


//
//  Creation Date:	May 1999
//
//  Procedure Name:
//	AEparticleFireworksNew
//
//  Description Name;
//	Creates controls for the fireworks clip effects relating to
//  fireworks attributes in the rockets particle).
//
//  Input Value:
//	nodeName.attrName 
//
//  Output Value:
//	None
// 
//
//  CONTENTS
//		
//  UTILITY PROCEDURES
//
//		itemInList
//		getCurrentRocketId
//		getSourceNode
//		getSourcePlug
//		setLaunchLocatorPosition
//		setBurstLocatorPosition
//		remakeColorPalette
//		editColor
//
//	PROCEDURES TO CREATE THE LAYOUTS
//
//		AEfwCreateOrEditOptionMenu
//		makeColorCanvasRows
//		createFireworksColorPalette
//		editFireworksColorPalette
//		createRocketTrailsColorPalette
//		editRocketTrailsColorPalette
//		createFrameTimesLayout
//		setFrameTimesControls
//		createOrEditPositionsLayout
//
//	CALLBACKS FOR THE CONTROLS
//
//		AEfwRocketsMenuGrpCB
//		AEfwColorCanvasCB
//		AEfwTrailColorCanvasCB
//		AEfwSelectionCanvasCB
//		AEfwSetLaunchPositionCB
//		AEfwSetBurstPositionCB
//		AEfwShowBurstPositionCB
//		AEfwShowLaunchPositionCB
//		AEfwShowLaunchPosManipCB 
//		AEfwShowBurstPosManipCB 
//		AEfwLaunchFrameCB
//		AEfwBurstFrameCB
//		AEfwLaunchFrameSJ
//		AEfwBurstFrameSJ
//		AEfwSparksColorSpreadCB
//		AEfwFireworksDisplayCB
//		AEfwResetColorPaletteCB 
//		AEfwCreateNewColorPaletteCB 
//		
//	MAIN PROCEDURES
//
//		AEparticleFireworksNew
//		AEparticleFireworksReplace

//
//	PROCEDURES RELATED TO THE FIREWORKS GROUP
//

includeEffectsGlobals;

global string $AEfwOptionMenuParent;

//
//  ================ itemInList ================
//
//  SYNOPSIS
//      Return whether $itemName is in the list $itemList
//
//
//	ARGUMENTS
//		string $itemName   -- name to search for
//		string $itemList[] -- list in which to search for the name
//
//	RETURN
//		1 if found the name; 0 if not.
//
proc int itemInList(string $itemName, string $itemList[])
{
	int $found = 0;

	for ($i = 0; $i < size( $itemList ); $i++)
	{
		if ($itemName == $itemList[$i])
		{
			$found = 1;
			break;
		}
	}
	return $found;
}


//
//  ================ getCurrentRocketId ================
//
//  SYNOPSIS
//      Return the particle id of the particle/rocket currently selected
//		in the option menu.
//
//
//	ARGUMENTS
//		None
//
//	RETURN
//		The particle id.
//
proc int getCurrentRocketId()
{
	global string $AEfwOptionMenuParent;

	string $currRocket = `optionMenuGrp -q -value $AEfwOptionMenuParent`;

	string $buffer[];
	tokenize ($currRocket, " ", $buffer);

	// If there are no rockets currently, return -1, otherwise return the
	// current particle/rocket id.
	//
	int $id = -1;

	if ($buffer[0] != "None")
	{
		$id = $buffer[1];
	}
	return $id;
}


//
//  ================ getSourceNode ================
//
//  SYNOPSIS
//      Return the name of the node whose message attribute is connected
//		to $nodeAttr.
//
//
//	ARGUMENTS
//		string $nodeAttr -- the node + attribute connected to the node.
//
//	RETURN
//		The node name
//
proc string getSourceNode(string $nodeAttr)
{
	string $source =
		`connectionInfo -sourceFromDestination ($nodeAttr)`;

	string $buffer[];
	tokenize($source, ".", $buffer);

	return $buffer[0];
}

//
//  ================ getSourcePlug ================
//
//  SYNOPSIS
//      Return the name of the node.attr whose message attribute is connected
//		to $nodeAttr.
//
//
//	ARGUMENTS
//		string $nodeAttr -- the node + attribute connected to the node.
//
//	RETURN
//		The nodeName.attr
//
proc string getSourcePlug(string $nodeAttr)
{
	string $source =
		`connectionInfo -sourceFromDestination ($nodeAttr)`;

	return $source;
}


//
//  ================ setColorSelectionCanvasHighlight ================
//
//  SYNOPSIS
//      Highlight appropriate selection canvases.
//
//
//	ARGUMENTS
//		string $nodeName -- the node currently in the editor
//		int    $selectionCanvasIndex -- the canvas to highlight
//
//	RETURN
//		None
//
proc setColorSelectionCanvasHighlight(string $nodeName, 
									int $selectionCanvasIndex)
{
	int $numColors = `getAttr -size ($nodeName + ".fireworksColors")`;
    for ($i = 0; $i < $numColors; $i++)
    {
        canvas -edit -rgbValue .4 .4 .4 ("colorSelectionCanvas" + $i);
	}

	// Get the color range to highlight.
	//
	float $colorSpread = `getAttr ($nodeName + ".sparksColorSpread")`;

    canvas -e 
			-rgbValue .9 .9 .9 
			("colorSelectionCanvas" + $selectionCanvasIndex);

	for ($i = 1; $i <= $colorSpread; $i++)
	{
		int $minus = $selectionCanvasIndex - $i;
		int $plus = $selectionCanvasIndex + $i;

		if ($plus > ($numColors - 1))
			$plus =  $plus % $numColors;

		if ($minus < 0)
		{
			$minus = $numColors + $minus;
		}

    	canvas -edit -rgbValue .6 .6 .6 ("colorSelectionCanvas" + $minus);
    	canvas -edit -rgbValue .6 .6 .6 ("colorSelectionCanvas" + $plus);
	}
}


//
//  ================ setLaunchLocatorPosition ================
//
//  SYNOPSIS
//      Set the position of the launch locator to be at
//		the launch position of the particle/rocket which
//		is currently selected in the option menu.
//
//
//	ARGUMENTS
//		string $nodeName   -- name of the rocket particles shape
//		int    $rocketId   -- id of the currently selected particle/rocket
//
//	RETURN
//		None
//
proc setLaunchLocatorPosition(string $nodeName, int $rocketId)
{

	float $rocketLoc[];

	// Get the launch location of the currently selected particle/rocket.
	//
	$rocketLoc = 
		`particle -attribute launchPositionPP -id $rocketId -q $nodeName`;

	// Get the name of the launch locator.
	//
	string $launchLocator = 
			getSourceNode(($nodeName + ".launchPositionManipMessage"));

	// Set the location of the launch locator to be that of the launch
	// position of the current particle/rocket.
	//
	setAttr ($launchLocator + ".translate") 
			-type double3 $rocketLoc[0] $rocketLoc[1] $rocketLoc[2];
}


//
//  ================ setBurstLocatorPosition ================
//
//  SYNOPSIS
//      Set the position of the burst locator to be at
//		the burst position of the particle/rocket which
//		is currently selected in the option menu.
//
//
//	ARGUMENTS
//		string $nodeName   -- name of the rocket particles shape
//		int    $rocketId   -- id of the currently selected particle/rocket
//
//	RETURN
//		None
//
proc setBurstLocatorPosition(string $nodeName, int $rocketId)
{

	float $rocketLoc[];

	// Get the burst location of the currently selected particle/rocket.
	//
	$rocketLoc = 
		`particle -attribute burstPositionPP -id $rocketId -q $nodeName`;

	// Get the name of the burst locator.
	//
	string $burstLocator = getSourceNode($nodeName + ".burstPositionManipMessage");

	// Set the location of the burst locator to be that of the burst
	// position of the current particle/rocket.
	//
	setAttr ($burstLocator + ".translate") 
			-type double3 $rocketLoc[0] $rocketLoc[1] $rocketLoc[2];
}


//
//  ================ editColor ================
//
//  SYNOPSIS
//		Set a new color in a rocket particle's  color attribute,
//		in the shader for this color, and in the color canvas.
//
//
//
//	ARGUMENTS
//		string $buffer
//		string $nodeName
//
//	RETURN
//		None
//
proc editColor( string $nodeName,
				string $attrName,
				string $shaderName,
				string $colorCanvasName,
				vector $color,
				int $colorCanvasIndex)
{

	// Set the new values in the particle "fireworksColors" attribute,
	// in the shader for this color, and in the color canvas.
	//

	// Get the new color values as floats.
	//
	float $newR = $color.x;
	float $newG = $color.y;
	float $newB = $color.z;

	setAttr 
		($nodeName + "." + $attrName + "[" + $colorCanvasIndex + "]")
		-type double3 $newR $newG $newB;

	string $destNodeAttr = 
				$nodeName + "." + $shaderName + "[" + $colorCanvasIndex + "]";
	string $shader = getSourceNode ($destNodeAttr);

	// Unlock the shader color so it can only be edited, then re-lock it.
	//
	setAttr -lock false ($shader + ".color");
	setAttr ($shader + ".color") -type double3 $newR $newG $newB;
	setAttr -lock true ($shader + ".color");
	
    canvas -edit -rgbValue $newR $newG $newB $colorCanvasName;
}



//
//  ================ remakeColorPalette ================
//
//  SYNOPSIS
//		Re-create the color palette, using $proc.
//
//	ARGUMENTS
//		string $nodeName -- name of the rocket particle in the editor
//		string $proc     -- name of the procedure to use to make the palette
//
//	RETURN
//		None
//
proc remakeColorPalette(string $nodeName, string $proc)
{
	// Get the original list of colors.
	//
	int $numColors = `getAttr -size ($nodeName + ".fireworksColors")`;
	string $cmd =  $proc + " " + $numColors;
 	vector $colors[] = eval($cmd);

	// Reset the colors in the fireworksColors, their shaders and the color
	// canvases because case some of them have probably been changed.
	//

	// Have to figure out how many rows, and how many children in each row.
	// that tells us how many canvases there are.  Here's the layout -- assume
	// 2 rows of color canvases:
	//
	//   column  AEparticleFireworksPaletteColumn
	//     1. text
	//	   2. rowLayout
	//           text
	//           attrFieldGrp
	//     3. text
	//     4. row (1st canvas color row)
	//           text colorCanvasColumns
	//     5. row (1st selection color row)
	//           text selectionCanvasColumns
	//     6. dummyRow
	//           text
	//     Repeat rows 4, 5, 6
	//
	// Num extra rows = 3  (text attrFieldRow text )
	// Num remaining children/3 = num rows of color canvases
	//    Get num children in each row (num children - 1 (for text filler)).
	//    Edit them.
	//

	// Get the number of color canvases  currently in the editor.
	//
	string $paletteRowNames[] =
				`columnLayout -q -ca AEparticleFireworksPaletteColumn`;

	int $numPaletteRows =  size($paletteRowNames);
	int $numCanvasRows = ($numPaletteRows - 3) / 3;

	string $colorRowNames[];

	// Get the names of the color rows.
	//
	// "offset" to takes into account the initial three rows.
	//
	int $offset = 3;
	for ($i = 1; $i <= $numCanvasRows; $i++)
	{
		$colorRowNames[$i - 1] = $paletteRowNames[$i * $offset];
	}

	// Get the number of canvases per row (numChildren - 1) of each row,
	// because each row starts with a blank text to get a good layout offset.
	//
	string $canvasRowChildNames[];
	string $colorCanvasNames[];

	int $offset = 0;
	for ($i = 0; $i < $numCanvasRows; $i++)
	{
		// Get the number of children 
		//
		$canvasRowChildNames = `rowLayout -q -ca $colorRowNames[$i]`;

		for ($j = 0; $j < size($canvasRowChildNames); $j++)
		{
			// Remove non-canvases from the canvasRowChildNames;
			//
			if (`canvas -exists $canvasRowChildNames[$j]`)
			{
				$colorCanvasNames[$offset] = $canvasRowChildNames[$j];
				$offset++;
			}
		}
	}

	// Now edit each canvas, shader, attribute entry.
	//
	vector $thisColor;
	for ($i = 0; $i < $numColors; $i++)
	{
		$thisColor = $colors[$i];

		editColor($nodeName, 
					"fireworksColors", "fireworksShaders",
					$colorCanvasNames[$i],
					$thisColor,
					$i);
	}

	// Set the name of the procedure used in the colorPaletteProc attribute.
	//
	setAttr -type "string" ($nodeName + ".colorPaletteProc") $proc;
}


//
//  ================ AEfwCreateOrEditOptionMenu ================
//
//  SYNOPSIS
//      If the option menu for the rocket particles does not exist,
//		create it; otherwise modify the current one with the new set
//		of particles.
//
//	ARGUMENTS
//		string $nodeName -- name of the rocket particle in the editor.
//
//	RETURN
//		None
//
global proc AEfwCreateOrEditOptionMenu(string $nodeName)
{
	global string $AEfwOptionMenuParent;

	int $numOldItems = 0;
	int $currItem = 1;
	string $currValue = "";

	// Find out how many particles (rockets) are in the particle node.
	//
	int $numParticles = `particle -q -count $nodeName`;

	// Get a list of the id's of all the particles in the node.
	//
	float $particleIds[];
	for ($i = 0; $i < $numParticles; $i++)
	{
		float $id[];
		$id = `particle -attribute id -order $i -q $nodeName`;
		$particleIds[$i] = $id[0];
	}

	// If the option menu does not exist, build it; otherwise:
	//
	// If the old and new lists are identical, leave the list and its
	// selection alone, and just call the option menu callback to make sure
	// the correct info is in for the current node name.  If they are not
	// identical, delete the list's old items and make new ones for the
	// current node.  
	//
	string $oldRocketItemsList[];
	string $newRocketsList[];
	string $newRocketItemsList[];
	clear($oldRocketItemsList);
	clear($newRocketsList);
	clear($newRocketItemsList);

	if (!`optionMenuGrp -ex AEfwRocketsOM`)
	{
		optionMenuGrp -label (uiRes("m_AEparticleFireworksNew.kFireworkRockets")) 
			-cc ("AEfwRocketsMenuGrpCB " + $nodeName + "\n")
			AEfwRocketsOM;

		setParent AEfwRocketsOM;
		$AEfwOptionMenuParent = `setParent -q`;
	}
	else
	{
		setParent $AEfwOptionMenuParent;

		// Reset the optionMenuGrp callback for the current node.
		//
		optionMenuGrp -e
			-cc ("AEfwRocketsMenuGrpCB " + $nodeName + "\n")
			AEfwRocketsOM;

        // Option menu exists.  So, get the list of old items. 
        //
        $oldRocketItemsList = `optionMenuGrp -q -ils AEfwRocketsOM`;
        
		// Find out how many menu items are in the option menu, so we know
		// how many to delete.
		//
		$numOldItems = `optionMenuGrp -q -ni AEfwRocketsOM`;

		// Get the current selected item, so we can re-select it if
		// it still exists when we are done building the list.
		//
		$currItem = `optionMenuGrp -q -sl AEfwRocketsOM`;
		$currValue = `optionMenuGrp -q -value AEfwRocketsOM`;
	}

	setParent AEfwRocketsOM;

	if ($numParticles == 0)
	{
		// There are no particles, so delete any items in the old list
		// and create one "None" menuItem.
		//
		if (!(`menuItem -q -exists noneItem_noneItem`))
		{
			$parent = `setParent -m ($AEfwOptionMenuParent + "|OptionMenu")`;
			menuItem -label (uiRes("m_AEparticleFireworksNew.kNone"))  noneItem_noneItem;
		}
		for ($i = 0; $i < size($oldRocketItemsList); $i++)
		{
			deleteUI $oldRocketItemsList[$i];
		}
	}
	else
	{
        // There is at least one particle, so add a new menuItem for each
		// particle/rocket -- unless the old and new lists are identical,
		// in which case, let's leave well enough alone and just reset
		// the callback and call the callback to make sure the editor
		// is updated for the current node.
        //
		$parent = `setParent -m ($AEfwOptionMenuParent + "|OptionMenu")`;

        for ( $i = 0; $i < $numParticles; $i++ )
        {
			$newRocketsList[$i] = "Rocket " + $particleIds[$i];
			$newRocketItemsList[$i] = "Rocket_" + $particleIds[$i];
		}

		// If the new and old lists are identical, don't remake the list.
		//
		int $listsIdentical = 0;

		if (size($newRocketItemsList) == size($oldRocketItemsList))
		{
			$listsIdentical = 1;
			// If the lists are the same size, see if they have the same
			// items in them.
			//
			for ($i = 0; $i < size($newRocketItemsList); $i++)
			{
				if ($newRocketItemsList[$i]  != $oldRocketItemsList[$i])
				{
					$listsIdentical = 0;
				}
			}
		}

		// If the lists are not identical, remake the menu list.
		//
		if (!$listsIdentical)
		{
			// Delete the old list -- but first stick a "dummy" item in there to
			// not be deleted, as the list can't be empty.  Then delete it at
			// the end.
			//
			menuItem -label (uiRes("m_AEparticleFireworksNew.kDummy"))  dummyItem;

			for ($i = 0; $i < size($oldRocketItemsList); $i++)
			{
				deleteUI $oldRocketItemsList[$i];
			}
			// Make the new list.
			//
			for ($i = 0; $i < size($newRocketItemsList); $i++)
			{
        		menuItem -l $newRocketsList[$i] $newRocketItemsList[$i];
			}
			// Delete the dummy item.
			//
			deleteUI dummyItem;

			// Select the first item in the menu.
			//
			optionMenuGrp -e -sl 1 $AEfwOptionMenuParent;
		}

	}
}


//
//  ================ makeColorCanvasRows ================
//
//  SYNOPSIS
//      Make the rows and color canvases needed.
//
//	ARGUMENTS
//		string $nodeName              -- name of the rocket particle in the editor.
//		int    $makeSelectionCanvases -- whether to make selection canvases
//		string $baseName
//		vector $colors                -- list of fireworks colors
//		int    $numColors             -- how many color canvases to make
//		int    $rowNameStartNum       -- first number to use in naming rows
//		int    $canvasNameStartNum    -- first number to us in naming canvases
//		string $attrName
//		string $shaderName
//
//	RETURN
//		None
//
proc makeColorCanvasRows(string $nodeName, 
							int $makeSelectionCanvases,
							string $baseName,
							vector $colors[],
							int $numColors, 
							int $rowNameStartNum,
							int $canvasNameStartNum,
							string $attrName,
							string $shaderName)
{
	// Let's make 16 colors per row;
	//
	int $numColumns = 16;
	int $numRows = $numColors/$numColumns;

	// The number of colors may not be a multiple of 16, so set up for
	// doing the last row in that case.
	//
	int $numColLastRow = $numColors % $numColumns;

	if ($numColLastRow != 0)
		$numRows += 1;

	int $indexOffset = $numColumns;
	
	int $columnWidth = 21;

	for ($i = 0; $i < $numRows; $i++)
	{
		// Make a row of colors
		//
   		rowLayout
       		-width 320
       		-height 20
       		-numberOfColumns ($numColumns + 1)
       		-columnWidth 1 32
       		-columnWidth 2 $columnWidth
       		-columnWidth 3 $columnWidth
       		-columnWidth 4 $columnWidth
       		-columnWidth 5 $columnWidth
       		-columnWidth 6 $columnWidth
       		-columnWidth 7 $columnWidth
       		-columnWidth 8 $columnWidth
       		-columnWidth 9 $columnWidth
       		-columnWidth 10 $columnWidth
       		-columnWidth 11 $columnWidth
       		-columnWidth 12 $columnWidth
       		-columnWidth 13 $columnWidth
       		-columnWidth 14 $columnWidth
       		-columnWidth 15 $columnWidth
       		-columnWidth 16 $columnWidth
       		-columnWidth 17 $columnWidth
       		(($baseName + "Row") + ($i + $rowNameStartNum));
		
		// First column is the filler.
		//
       	text -l "";

		// If on the last row, there may be fewer than numColumns canvases.
		//
		int $numCol;
		if ($numColLastRow != 0 && $i == ($numRows - 1))
			$numCol = $numColLastRow;
		else
			$numCol = $numColumns;

		for ($j = 0; $j < $numCol; $j++)
		{
           	int $ind = $j + ($indexOffset * $i) + $canvasNameStartNum;
           	vector $currColors = $colors[$ind];

           	canvas -width 20 -height 20
               	-rgbValue ($currColors.x) ($currColors.y) ($currColors.z)
				-pc ("AEfwColorCanvasCB " + $nodeName + " " + $attrName + " " + $shaderName + " " + $ind + " " +  $baseName + "Canvas" + $ind )
               	($baseName + "Canvas" + $ind);
		}
		setParent ..;

		// Make a row of highlight/selection canvases, if requested.
		//
		if ($makeSelectionCanvases)
		{
   			rowLayout
       			-width 320
       			-height 30
       			-numberOfColumns ($numColumns + 1)
       			-columnWidth 1 32
       			-columnWidth 2 $columnWidth
        		-columnWidth 3 $columnWidth
        		-columnWidth 4 $columnWidth
        		-columnWidth 5 $columnWidth
        		-columnWidth 6 $columnWidth
        		-columnWidth 7 $columnWidth
        		-columnWidth 8 $columnWidth
        		-columnWidth 9 $columnWidth
        		-columnWidth 10 $columnWidth
       			-columnWidth 11 $columnWidth
       			-columnWidth 12 $columnWidth
       			-columnWidth 13 $columnWidth
       			-columnWidth 14 $columnWidth
       			-columnWidth 15 $columnWidth
       			-columnWidth 16 $columnWidth
       			-columnWidth 17 $columnWidth
       			(($baseName + "SelectionRow") + ($i + $rowNameStartNum));

			// First column is the filler.
			//
       		text -l "";

			// If on the last row, there may be fewer than numColumns canvases.
			//
			if ($numColLastRow != 0 && $i == ($numRows - 1))
				$numCol = $numColLastRow;
			else
				$numCol = $numColumns;

       		for ($j = 0; $j < $numCol; $j++)
       		{
           		int $ind = $j + ($indexOffset * $i) + $canvasNameStartNum;

           		float $r = .4;
           		float $g = .4;
           		float $b = .4;

           		canvas -width 20 -height 10
               		-rgbValue $r $g $b
               		-pc ("AEfwSelectionCanvasCB " + $nodeName + " " + $ind)
               		(($baseName + "SelectionCanvas") + $ind);
       		}

			setParent ..;
		}

		// Make a dummy row to get a margin between each row, as the
		// AE refuses to honor rowAttach requests.
		//
       	rowLayout
			-width 320
			-height 10
			-numberOfColumns 1
			-columnWidth 1 10

			(($baseName + "DummyRow") + ($i + $rowNameStartNum));
		text -l "" -height 10;	

       	setParent ..;
	}
}


//
//  ================ createFireworksColorPalette ================
//
//  SYNOPSIS
//      Create the color palette of canvas controls for all the colors
//		for the particle bursts (fireworks sparks) of the rockets of
//		$nodeName.
//		The palette is stored in the rocket particle.  So get it, and create
//		a canvas control for each color, and format them.
//
//	ARGUMENTS
//		string $nodeName -- name of the current particle node.
//
//	RETURN
//		None
//
proc createFireworksColorPalette(string $nodeName)
{
	global string $AEfwOptionMenuParent;

	// If the palette already exists, delete it and start again.
	//
	if (!`frameLayout -exists AEparticleFireworksPaletteFrame`)
	{
		frameLayout
			-borderVisible 0
			-collapse 0
			-collapsable 0
			-label (uiRes("m_AEparticleFireworksNew.kEditRocketBurstColors")) 
			AEparticleFireworksPaletteFrame;
	}

	setParent AEparticleFireworksPaletteFrame;

	if (`columnLayout -exists AEparticleFireworksPaletteColumn`)
	{
		columnLayout -e -manage 0 AEparticleFireworksPaletteColumn;
		deleteUI -layout AEparticleFireworksPaletteColumn;
	}

	columnLayout AEparticleFireworksPaletteColumn;

	// We have to add a long empty text, because on NT, the frame is
	// truncated to the length of the longest control in it, NOT including
	// the frame label.  And if users choose 5 or fewer colors, the label
	// will be truncated. Well, we could use a little space below the
	// frame label also.
	//
	text -label " " -width 340 -height 3;

	// Add an attrFieldGrp for the sparksColorSpread.
	//
	// We will connect it to the sparksColorSpread attribute in the
	// fireworks group this rocket belongs to, as the rocket's
	// sparksColorSpread is connected to that attribute for ease of
	// editing in the Channel Box.
	//
	$fireworksGroup = 
			getSourceNode(($nodeName + ".rocketsMessage"));

    rowLayout
        -width 320
        -height 20
        -numberOfColumns 2
        -columnWidth 1 24
		-columnWidth 2 320
	AEfwColorSpreadRow;

	text -l "";

	attrFieldSliderGrp
		-label (uiRes("m_AEparticleFireworksNew.kSparksColorSpread")) 
		-s 2
		-at ($fireworksGroup + ".sparksColorSpread")
		-cc ("AEfwSparksColorSpreadCB " + $nodeName)
		AEfwSparksColorSpread;

	setParent ..;

	text -l "" -height 3;

	// Get the number of colors in the rocket's "palette".
	//
	int $numColors = `getAttr -size ($nodeName + ".fireworksColors")`;
	
	// Get all the colors.
	//
	float $color[];
	vector $colors[];
	for ($i = 0; $i < $numColors; $i++)
	{
		$color = `getAttr ($nodeName + ".fireworksColors[" + $i + "]")`;

		vector $theColor = <<$color[0], $color[1], $color[2]>>;

		$colors[$i] = $theColor;
	}

	// Lay out the color palette in rows layout.
	// For each color there are two rows -- one for the color canvas and
	// one for a highlight/selection canvas by which the user can select
	// a given color and assign it to the current rocket selected in the
	// option menu group.
	//

	//   0 = start index for naming rows; 0 = start index for naming canvases;
	//   1 = make selection canvases
	//
	makeColorCanvasRows($nodeName, 1, 
						"color", $colors, $numColors, 
						0, 0,
						"fireworksColors", "fireworksShaders");

	// Find out what is the currently selected particle/rocket.
	// Get its index into the color palette and make that the selected/
	// highlit one.
	//
	int $rocketId = getCurrentRocketId();

	if ($rocketId > -1)
	{
		float $sparkColorIndex[] = 
			`particle -attribute burstColorIndex -id $rocketId -q
						$nodeName`;

		setColorSelectionCanvasHighlight($nodeName, $sparkColorIndex[0]);
	}

	// Create a button for resetting the color palette to the palette
	// it was last created from.  And create a textfield to specify
	// a new color palette to replace the current one.
	//
	// 
	setParent AEparticleFireworksColumn;

	// If the remake pallete frame already exists, delete it and start again.
	//
	if (!`frameLayout -exists AEparticleFireworksRemakePaletteFrame`)
	{
		frameLayout
			-borderVisible 0
			-collapse 0
			-collapsable 0
			-label (uiRes("m_AEparticleFireworksNew.kRemakeColorPalette")) 
			AEparticleFireworksRemakePaletteFrame;
	}

	setParent AEparticleFireworksRemakePaletteFrame;

	if (`columnLayout -exists AEparticleFireworksRemakePaletteColumn`)
	{
		columnLayout -e -manage 0 AEparticleFireworksRemakePaletteColumn;
		deleteUI -layout AEparticleFireworksRemakePaletteColumn;
	}

	columnLayout AEparticleFireworksRemakePaletteColumn;

	// We have to add a long empty text, because on NT, the frame is
	// truncated to the length of the longest control in it, NOT including
	// the frame label.  And if users choose 5 or fewer colors, the label
	// will be truncated. Well, we could use a little space below the
	// frame label also.
	//
	text -label " " -width 340 -height 3;

	string $proc = `getAttr ($nodeName + ".colorPaletteProc")`;

   	rowLayout
		-numberOfColumns 2
		-columnWidth 1 20
		-columnWidth 2 320
		AEfwResetColorPaletteRow;

	text -l "";

	button -l ("Reset from " + $proc)
		-c ("AEfwResetColorPaletteCB " + $nodeName )
		AEfwResetColorPaletteB;

	setParent ..;

	textFieldGrp -label (uiRes("m_AEparticleFireworksNew.kCreatenewfrom")) 
		-cc ("AEfwCreateNewColorPaletteCB " + $nodeName )
		AEfwCreateColorPaletteTF;

//	setParent ..;
}


//
//  ================ editFireworksColorPalette ================
//
//  SYNOPSIS
//      Edit the color palette of canvas controls for all the colors
//		for the particle bursts (fireworks sparks) of the rockets of
//		$nodeName.
//		The palette is stored in the rocket particle.  So get it, and edit
//		a canvas control for each color.
//		If there are more or fewer colors than the current layout contains,
//		delete or add canvases.
//
//	ARGUMENTS
//		string $nodeName -- name of the current particle node.
//
//	RETURN
//		None
//
proc editFireworksColorPalette(string $nodeName)
{
	global string $AEfwOptionMenuParent;

	// Make sure the palette exists.  If it doesn't, create it.
	//
	//
	if ((!`frameLayout -exists AEparticleFireworksPaletteFrame`) ||
		(!`columnLayout -exists AEparticleFireworksPaletteColumn`))
	{
		createFireworksColorPalette($nodeName);
		return;
	}

	setParent AEparticleFireworksPaletteColumn;

	// Re-attach the sparksColorSpread attrFieldSliderGrp to the current node.
	//
	$fireworksGroup = 
			getSourceNode(($nodeName + ".rocketsMessage"));

	attrFieldSliderGrp
		-e 
		-at ($fireworksGroup + ".sparksColorSpread")
		-cc ("AEfwSparksColorSpreadCB " + $nodeName)
		AEfwSparksColorSpread;

	// Get the number of colors in the rocket's "palette".
	//
	int $numColors = `getAttr -size ($nodeName + ".fireworksColors")`;
	
	// Get all the colors from the fireworksColors attribute.
	//
	float $color[];
	vector $colors[];
	for ($i = 0; $i < $numColors; $i++)
	{
		$color = `getAttr ($nodeName + ".fireworksColors[" + $i + "]")`;

		vector $theColor = <<$color[0], $color[1], $color[2]>>;

		$colors[$i] = $theColor;
	}

	// We will re-use canvases that exist.  So ...
	// We have to figure out how many rows, and how many children in each row.
	// That tells us how many canvases there are.  Here's the layout -- assume
	// 2 rows of color canvases:
	//
	//   column  AEparticleFireworksPaletteColumn
	//     1. text
	//	   2. rowLayout
	//           text
	//           attrFieldGrp
	//     3. text
	//     4. row (1st canvas color row)
	//           text colorCanvasColumns
	//     5. row (1st selection color row)
	//           text selectionCanvasColumns
	//     6. dummyRow
	//           text
	//     7. row (2nd canvas color row)
	//           text colorCanvasColumns
	//     8. row (2nd selection cavas row)
	//           text selectionCanvasColumns
	//     9. dummyRow 
	//           text
	//
	// Num extra rows = 3  (text attrFieldRow text )
	// Num remaining children/3 = num rows of color canvases
	//    One row = color canvases; one row = selection canvases; one row =
	//    dummy filler row.
	//
	//    Get the num children in each row (num children - 1 (for text filler)).
	//    Edit existing ones.
	//    If more old ones, delete remaining ones.
	//    If more new ones, add and fill extras.
	//    Highlight the current one
	//
	// Get the number of color canvases  currently in the editor.
	//
	int $numPaletteRows = 
				`columnLayout -q -nch AEparticleFireworksPaletteColumn`;

	string $paletteRowNames[] =
				`columnLayout -q -ca AEparticleFireworksPaletteColumn`;

	int $numCanvasRows = ($numPaletteRows - 3) / 3;

	string $colorRowNames[];
	string $selectionRowNames[];
	string $dummyRowNames[];

	// Get the names of the color, selection and dummy rows.  They will be
	// needed for adding and deleting canvases.
	//
	// "offset" takes into account the initial three rows.
	//
	int $offset = 3;
	for ($i = 1; $i <= $numCanvasRows; $i++)
	{
		$colorRowNames[$i - 1] = $paletteRowNames[$i * $offset];
		$selectionRowNames[$i - 1] = $paletteRowNames[$i * $offset + 1];
		$dummyRowNames[$i - 1] = $paletteRowNames[$i * $offset + 2];
	}

	int $numExistingColorRows = size($colorRowNames);

	// Names of all the children in the rows.
	//
	string $canvasRowChildNames[];
	string $selectionRowChildNames[];

	// Names of all the canvases in the rows.
	//
	string $colorCanvasNames[];
	string $selectionCanvasNames[];

	// Get the number of canvases per row is (numChildren - 1) of each row,
	// because each row starts with a blank text to get a good layout offset.
	//
	int $offset = 0;
	for ($i = 0; $i < $numCanvasRows; $i++)
	{
		// Get the number of children 
		//
		$canvasRowChildNames = `rowLayout -q -ca $colorRowNames[$i]`;
		$selectionRowChildNames = `rowLayout -q -ca $selectionRowNames[$i]`;

		for ($j = 0; $j < size($canvasRowChildNames); $j++)
		{
			// Get just the canvases from the canvasRowChildNames;
			//
			if (`canvas -exists $canvasRowChildNames[$j]`)
			{
				$colorCanvasNames[$offset] = $canvasRowChildNames[$j];
				$selectionCanvasNames[$offset] = $selectionRowChildNames[$j];
				$offset++;
			}
		}
	}

	int $numColorCanvases = size($colorCanvasNames);

	// Edit the color palettes.
	//
	if ($numColorCanvases < $numColors)
	{
		// If there are fewer current color canvases than number of colors
		// in this rocket, then we have to add more canvases, and possibly
		// rows, to the layout.
		//

		// First, for all existing rows, get the current color for each canvas
		// and put it in. Also reset the callback for the current node.
		//
		int $colorIndex = 0;
		$ind = 0;
		for ($i = 0; $i < $numColorCanvases; $i++)
		{
       		vector $currColors = $colors[$i];
       		canvas -e
              		-rgbValue ($currColors.x) ($currColors.y) ($currColors.z)
					-pc ("AEfwColorCanvasCB " + $nodeName + " " + "fireworksColors" + " " + "fireworksShaders" + " " + $i + " " +  "colorCanvas" + $i )
               		("colorCanvas" + $i);

				// Also reset the callback for the selection canvas.
				//
           		canvas -e
					-pc ("AEfwSelectionCanvasCB " + $nodeName + " " + $i )
               		("colorSelectionCanvas" + $i);
		}

		// Get the number and name of the last row.
		//
		int $lastRowIndex = $numExistingColorRows - 1;
		string $lastRow =  $colorRowNames[$lastRowIndex];

		// Get number of new canvases that need to be created.
		//
		int $numCanvasesToAdd = $numColors - $numColorCanvases;

		// Find out how many canvases are currently in the last row.
		//
		int $numChildren = `rowLayout -q -nch $lastRow`;
		int $numFreeCanvasesInRow =  17 - $numChildren;

		// Finish off the last row, and then, if there are more new colors
		// left over, add more rows, and add the canvases to them.
		//
		setParent $lastRow;

		// First, make the color canvases for the last row.
		//
		int $ind = $numColorCanvases;

		int $numCanvasesToMake;
		if ($numCanvasesToAdd < $numFreeCanvasesInRow)
			$numCanvasesToMake = $numCanvasesToAdd;
		else
			$numCanvasesToMake = $numFreeCanvasesInRow;

		int $ind = $numColorCanvases;
		for ($i = 0; $i < $numCanvasesToMake; $i++)
		{
       		vector $currColors = $colors[$ind];
			canvas -width 20 -height 20
               	-rgbValue ($currColors.x) ($currColors.y) ($currColors.z)
               	-pc ("AEfwColorCanvasCB " + $nodeName + " fireworksColors fireworksShaders " + $ind + " colorCanvas" + $ind )
               	("colorCanvas" + $ind);

			// Add the new canvas names to colorCanvasNames
			//
			$colorCanvasNames[$ind] = "colorCanvas" + $ind;
			$ind++;
		}

		setParent AEparticleFireworksPaletteColumn;

		// Make the selectionCanvases in the last row.
		//
		$lastRow =  $selectionRowNames[$lastRowIndex];
		setParent $lastRow;

		// Reset the index for naming the selection canvases.
		//
		$ind = $numColorCanvases;

		for ($i = 0; $i < $numCanvasesToMake; $i++)
		{
			canvas -width 20 -height 10
              	-rgbValue .4 .4 .4
               	-pc ("AEfwSelectionCanvasCB " + $nodeName + " " + $ind)
               	("colorSelectionCanvas" + $ind);

			// Add the new canvas names to selectionCanvasNames
			//
			$selectionCanvasNames[$ind] = "colorSelectionCanvas" + $ind;
			$ind++;
		}
		setParent AEparticleFireworksPaletteColumn;
		
		// Now create additional rows and canvases needed, and set the
		// colors in the canvases.
		//
		int $numColorsInNewRows = $numCanvasesToAdd - $numFreeCanvasesInRow;

		if ($numColorsInNewRows > 0)
		{
			makeColorCanvasRows($nodeName, 
								1,
								"color",
								$colors,
								$numColorsInNewRows, 
								$lastRowIndex + 1, $ind,
								"fireworksColors", "fireworksShaders");
		}
	}
	else
	{
		// Number of color canvases is equal to or greater than number of
		// colors needed, so just reset the colors and then delete any unused
		// canvases.  Also, reset the callbacks for both the color canvases
		// and the selection canvases.
		//
		vector $thisColor;
		for ($i = 0; $i < $numColors; $i++)
		{
			$thisColor = $colors[$i];

        	canvas -e 
					-rgbValue ($thisColor.x) ($thisColor.y) ($thisColor.z) 
					-pc ("AEfwColorCanvasCB " + $nodeName + " " + "fireworksColors" + " " + "fireworksShaders" + " " + $i + " " +  "colorCanvas" + $i )
					$colorCanvasNames[$i];

        	canvas -e 
               		-pc ("AEfwSelectionCanvasCB " + $nodeName + " " + $i)
					$selectionCanvasNames[$i];
		}

		// Delete unused canvases and rows.
		//
		for ($i = $numColors; $i < $numColorCanvases; $i++) 
		{
			deleteUI $colorCanvasNames[$i];
			deleteUI $selectionCanvasNames[$i];
		}

		// Delete any rows with only one item in them; which means there is
		// only the initial text, and not color canvases.
		//
		for ($i = size($colorRowNames) - 1; $i >=0; $i--)
		{
			int $numChildren = `rowLayout -q -nch $colorRowNames[$i]`;
			if ($numChildren <= 1)
			{
				deleteUI $colorRowNames[$i];
				deleteUI $selectionRowNames[$i];
				deleteUI $dummyRowNames[$i];
			}
		}
	}

	// Get the currently selected particle/rocket.  Get its index into the
	// color palette and make that the selected/highlit one.
	//
	int $rocketId = getCurrentRocketId();

	if ($rocketId > -1)
	{
	 	float $sparkColorIndex[] = 
	 		`particle -attribute burstColorIndex -id $rocketId -q
	 					$nodeName`;

		setColorSelectionCanvasHighlight($nodeName, $sparkColorIndex[0]);
	}

	string $proc = `getAttr ($nodeName + ".colorPaletteProc")`;
	button -e
		-l ("Reset from " + $proc)
		-c ("AEfwResetColorPaletteCB " + $nodeName )
		AEfwResetColorPaletteB;

	textFieldGrp -e
		-cc ("AEfwCreateNewColorPaletteCB " + $nodeName )
		AEfwCreateColorPaletteTF;
}


//
//  ================ createRocketTrailsColorPalette ================
//
//  SYNOPSIS
//      Create the color palette of canvas controls for all the colors
//		for the rocket trails of $nodeName.
//		The palette is stored in the rocket particle.  So get it, and create
//		a canvas control for each color, and format them.
//
//	ARGUMENTS
//		string $nodeName -- name of the current particle node.
//
//	RETURN
//		None
//
proc createRocketTrailsColorPalette(string $nodeName)
{
	global string $AEfwOptionMenuParent;

	// If the palette already exists, delete it and start again.
	//
	if (!`frameLayout -exists AErocketTrailsPaletteFrame`)
	{
		frameLayout
			-borderVisible 0
			-collapse 0
			-collapsable 0
			-label (uiRes("m_AEparticleFireworksNew.kEditRocketTrailColors")) 
			AErocketTrailsPaletteFrame;
	}

	setParent AErocketTrailsPaletteFrame;

	if (`columnLayout -exists AErocketTrailsPaletteColumn`)
	{
		columnLayout -e -manage 0 AErocketTrailsPaletteColumn;
		deleteUI -layout AErocketTrailsPaletteColumn;
	}

	columnLayout AErocketTrailsPaletteColumn;

	// We have to add a long empty text, because on NT, the frame is
	// truncated to the length of the longest control in it, NOT including
	// the frame label.  And if users choose 5 or fewer colors, the label
	// will be truncated. Well, we could use a little space below the
	// frame label also.
	//
	text -label " " -width 340 -height 3;

	// Get the number of colors in the rocket trails' "palette".
	//
	int $numColors = `getAttr -size ($nodeName + ".rocketTrailColors")`;
	
	// Get all the colors.
	//
	float $color[];
	vector $colors[];
	for ($i = 0; $i < $numColors; $i++)
	{
		$color = `getAttr ($nodeName + ".rocketTrailColors[" + $i + "]")`;

		vector $theColor = <<$color[0], $color[1], $color[2]>>;

		$colors[$i] = $theColor;
	}

	// Lay out the color palette in rows layout.
	// For each color there are two rows -- one for the color canvas and
	// one for a highlight/selection canvas by which the user can select
	// a given color and assign it to the current rocket selected in the
	// option menu group.
	//
	makeColorCanvasRows($nodeName, 0, "trails", $colors, $numColors, 0, 0,
						"rocketTrailColors", "rocketTrailShaders");
}


//
//  ================ editRocketTrailsColorPalette ================
//
//  SYNOPSIS
//      Edit the color palette of canvas controls for all the colors
//		for the particle rocket trails for $nodeName.
//		The palette is stored in the rocket particle.  So get it, and edit
//		a canvas control for each color.
//		If there are more or fewer colors than the current layout contains,
//		delete or add canvases.
//
//	ARGUMENTS
//		string $nodeName -- name of the current particle node.
//
//	RETURN
//		None
//
proc editRocketTrailsColorPalette(string $nodeName)
{
	global string $AEfwOptionMenuParent;

	// Make sure the palette exists.  If it doesn't, create it.
	//
	//
	if ((!`frameLayout -exists AErocketTrailsPaletteFrame`) ||
		(!`columnLayout -exists AErocketTrailsPaletteColumn`))
	{
		createRocketTrailsColorPalette($nodeName);
		return;
	}

	setParent AErocketTrailsPaletteColumn;

	// Get the number of colors in the rocket trail's "palette".
	//
	int $numColors = `getAttr -size ($nodeName + ".rocketTrailColors")`;
	
	// Get all the colors.
	//
	float $color[];
	vector $colors[];
	for ($i = 0; $i < $numColors; $i++)
	{
		$color = `getAttr ($nodeName + ".rocketTrailColors[" + $i + "]")`;
		vector $theColor = <<$color[0], $color[1], $color[2]>>;
		$colors[$i] = $theColor;
	}

	// Have to figure out how many rows, and how many children in each row.
	// that tells us how many canvases there are.  Here's the layout -- assume
	// 2 rows of color canvases:
	//
	//   column  AEparticleFireworksPaletteColumn
	//     1. text
	//     4. row (1st canvas color row)
	//           text colorCanvasColumns
	//     6. dummyRow
	//           text
	//     7. row (2nd canvas color row)
	//           text colorCanvasColumns
	//     9. dummyRow 
	//           text
	//
	//    Get the num children in each row (num children - 1 (for text filler)).
	//    Figure out if we have more or less currently.
	//    Edit existing ones.
	//    If more old ones, delete remaining ones.
	//    If more new ones, add and fill extras.
	//
	// Get the number of trail color canvases  currently in the layout.
	//
	int $numPaletteRows = 
				`columnLayout -q -nch AErocketTrailsPaletteColumn`;

	string $paletteRowNames[] =
				`columnLayout -q -ca AErocketTrailsPaletteColumn`;

	int $numCanvasRows = ($numPaletteRows - 1) / 2;

	string $colorRowNames[];
	string $dummyRowNames[];

	// Get the names of the color and dummy rows.  They will be
	// needed for adding and deleting canvases.
	//
	// "offset" to take into account the initial row in the palette column.
	//
	int $offset = 1;
	for ($i = 0; $i < $numCanvasRows; $i++)
	{
		$colorRowNames[$i] = $paletteRowNames[($i * 2) + $offset];
		$dummyRowNames[$i] = $paletteRowNames[($i * 2) + $offset + 1];
	}

	int $numExistingColorRows = size($colorRowNames);


	// Get the names of the color canvases:

	// Names of all the children in the rows.
	//
	string $canvasRowChildNames[];

	// Names of all the canvases in the rows.
	//
	string $colorCanvasNames[];

	int $offset = 0;
	for ($i = 0; $i < $numCanvasRows; $i++)
	{
		// Get the number of children in current row.
		//
		$canvasRowChildNames = `rowLayout -q -ca $colorRowNames[$i]`;

		for ($j = 0; $j < size($canvasRowChildNames); $j++)
		{
			// Make a list of just canvases from the canvasRowChildNames;
			//
			if (`canvas -exists $canvasRowChildNames[$j]`)
			{
				$colorCanvasNames[$offset] = $canvasRowChildNames[$j];
				$offset++;
			}
		}
	}

	int $numColorCanvases = size($colorCanvasNames);

	// Edit the color palette layout.
	//
	if ($numColorCanvases < $numColors)
	{
		// If there are fewer current color canvases than number of colors
		// in this rocket, then we have to add more canvases, and possibly
		// rows, to the layout.
		//

		// First, for all existing canvases, get the current color for each
		// canvas and put it in, and reset the callback for the current node.
		//
		for ($i = 0; $i < $numColorCanvases; $i++)
		{
        	vector $currColors = $colors[$i];
           	canvas -e
           		-rgbValue ($currColors.x) ($currColors.y) ($currColors.z)
           		-pc ("AEfwColorCanvasCB " + $nodeName + " rocketTrailColors rocketTrailShaders " + $i  + " trailsCanvas" + $i )
           		("trailsCanvas" + $i);
		}

		// Get the number and name of the last row.
		//
		int $lastRowIndex = $numExistingColorRows - 1;
		string $lastRow =  $colorRowNames[$lastRowIndex];

		// Get number of new canvases that need to be created.
		//
		int $numCanvasesToAdd = $numColors - $numColorCanvases;

		// Find out how many canvases are currently in the last row.
		//
		int $numChildren = `rowLayout -q -nch $lastRow`;
		int $numFreeCanvasesInRow =  17 - $numChildren;

		// Finish off the last row, and then, if there are more new colors
		// left over, add more rows, and add the canvases to them.
		//
		setParent $lastRow;

		// First, make the color canvases for the last row.
		//
		int $numCanvasesToMake;
		if ($numCanvasesToAdd < $numFreeCanvasesInRow)
			$numCanvasesToMake = $numCanvasesToAdd;
		else
			$numCanvasesToMake = $numFreeCanvasesInRow;
		int $ind = $numColorCanvases;
		for ($i = 0; $i < $numCanvasesToMake; $i++)
		{
			vector $currColors = $colors[$ind];
			canvas -width 20 -height 20
               	-rgbValue ($currColors.x) ($currColors.y) ($currColors.z)
               	-pc ("AEfwColorCanvasCB " + $nodeName + " rocketTrailColors rocketTrailShaders " + $ind  + " trailsCanvas" + $ind )
               	("trailsCanvas" + $ind);

			// Add the new canvas names to colorCanvasNames
			//
			$colorCanvasNames[$ind] = "trailsCanvas" + $ind;
			$ind++;
		}

		setParent AErocketTrailsPaletteColumn;

		// Now create additional rows and canvases needed, and set the
		// colors in the canvases.
		//
		int $numColorsInNewRows = $numCanvasesToAdd - $numFreeCanvasesInRow;

		if ($numColorsInNewRows > 0)
		{
			makeColorCanvasRows($nodeName, 
								0,
								"trails",
								$colors, 
								$numColorsInNewRows, 
								$lastRowIndex + 1, $ind,
								"rocketTrailColors", "rocketTrailShaders");
		}
	}
	else
	{
		// Number of color canvases is equal to or greater than number of
		// colors needed, so just reset the colors and callbacks, then delete
		// any unused canvases.
		//
		vector $thisColor;
		for ($i = 0; $i < $numColors; $i++)
		{
			$thisColor = $colors[$i];

        	canvas -e 
					-rgbValue ($thisColor.x) ($thisColor.y) ($thisColor.z) 
               		-pc ("AEfwColorCanvasCB " + $nodeName + " rocketTrailColors rocketTrailShaders " + $i  + " trailsCanvas" + $i )
					$colorCanvasNames[$i];
		}

		// Delete unused canvases and rows.
		//
		for ($i = $numColors; $i < $numColorCanvases; $i++) 
		{
			deleteUI $colorCanvasNames[$i];
		}

		// Delete any rows with only one item in them; which means there is
		// only the initial text, and not color canvases.
		//
		for ($i = size($colorRowNames) - 1; $i >=0; $i--)
		{
			int $numChildren = `rowLayout -q -nch $colorRowNames[$i]`;
			if ($numChildren <= 1)
			{
				deleteUI $colorRowNames[$i];
				deleteUI $dummyRowNames[$i];
			}
		}
	}
}



//  ================ createFrameTimesLayout ================
//
//  SYNOPSIS
//      Create the controls to edit launch time and frame time for
//		the particle/rocket currently selected in the option menu.
//
//	ARGUMENTS
//		string $nodeName -- name of the current particle node.
//
//	RETURN
//		None
//
proc createFrameTimesLayout(string $nodeName)
{
	global float $dynMinFloatField;
	global float $dynMaxFloatField;

	// Add controls to edit the launch frame and burst frame for each
	// particle/rocket.
	//

	floatSliderGrp -label (uiRes("m_AEparticleFireworksNew.kBurstFrame")) 
		-field true
		-min 0 -max 500
		-fmn $dynMinFloatField
		-fmx $dynMaxFloatField
		-pre 2 -step 1
		-cc ("AEfwBurstFrameCB " + $nodeName)
		AEfwBurstFrame;

	floatSliderGrp -label (uiRes("m_AEparticleFireworksNew.kLaunchFrame")) 
		-field true
		-min 0 -max 500
		-fmn $dynMinFloatField
		-fmx $dynMaxFloatField
		-pre 2 -step 1
		-cc ("AEfwLaunchFrameCB " + $nodeName)
		AEfwLaunchFrame;

	scriptJob -replacePrevious -parent AEfwLaunchFrame
				-attributeChange ($nodeName + ".launchFramePP")
				("AEfwLaunchFrameSJ " + $nodeName);
	scriptJob -replacePrevious -parent AEfwBurstFrame
				-attributeChange ($nodeName + ".burstFramePP")
				("AEfwBurstFrameSJ " + $nodeName);
}


//  ================ createFrameTimesControls ================
//
//  SYNOPSIS
//		Set the Launch Frame and Burst Frame controls with the
//		values of launchFramePP and burstFramePP for $nodeName for
//		$rocketId.
//
//	ARGUMENTS
//		string $nodeName -- name of the current particle node.
//		int    $rocketId -- id of rocket currently selected
//
//	RETURN
//		None
//
proc setFrameTimesControls(string $nodeName, int $rocketId)
{
	float $launchFrame[] = 
		`particle -attribute launchFramePP -id $rocketId -q $nodeName`;

	float $burstFrame[] = 
		`particle -attribute burstFramePP -id $rocketId  -q $nodeName`;

	floatSliderGrp -e -v $launchFrame[0] AEfwLaunchFrame;
	floatSliderGrp -e -v $burstFrame[0] AEfwBurstFrame;
}



//  ================ createOrEditPositionsLayout ================
//
//  SYNOPSIS
//      Create the layout to edit the launch and burst positions of
//		the particles/rockets.
//
//	ARGUMENTS
//		string $nodeName -- name of the current particle node.
//
//	RETURN
//		None
//
proc createOrEditPositionsLayout(string $nodeName)
{
	global string $AEfwOptionMenuParent;

	setParent AEparticleFireworksColumn;

	// Make the layout only if it doesn't already exist.
	//
	if (!`frameLayout -exists AEparticleFireworksBurstEdit`)
	{
		frameLayout
			-borderVisible 0
			-collapse 0
			-collapsable 0
			-label (uiRes("m_AEparticleFireworksNew.kEditRocketPositions")) 
			AEparticleFireworksBurstEdit;

		columnLayout AEparticleFireworksPositionColumn;

		// Add an empty text because we could use a little space below the
		// frame label.
		//
		text -label " " -height 3;

   		rowLayout
			-numberOfColumns 3
			-columnWidth 1 20
			-columnWidth 2 186
			-columnWidth 3 186
			AEfwPositionCheckboxRow;

		text -label " " -height 3;

		checkBox
			-label (uiRes("m_AEparticleFireworksNew.kShowBurstPositions")) 
			-onc ("AEfwShowBurstPositionCB " + $nodeName + " 1")
			-ofc ("AEfwShowBurstPositionCB " + $nodeName + " 0")
			AEfwShowBurstPosC;

		checkBox
			-label (uiRes("m_AEparticleFireworksNew.kShowLaunchPositions")) 
			-onc ("AEfwShowLaunchPositionCB " + $nodeName + " 1")
			-ofc ("AEfwShowLaunchPositionCB " + $nodeName + " 0")
			AEfwShowLaunchPosC;

		setParent ..;

		rowLayout
			-numberOfColumns 3
			-columnWidth 1 20
			-columnWidth 2 186
			-columnWidth 3 186
			AEShowManipsCheckboxRow;

		text -label " " -height 3;

		checkBox
			-label (uiRes("m_AEparticleFireworksNew.kShowBurstPosManip")) 
			-onc ("AEfwShowBurstPosManipCB " + $nodeName + " 1")
			-ofc ("AEfwShowBurstPosManipCB " + $nodeName + " 0")
			AEfwShowBurstManipC;

		checkBox
			-label (uiRes("m_AEparticleFireworksNew.kShowLaunchPosManip")) 
			-onc ("AEfwShowLaunchPosManipCB " + $nodeName + " 1")
			-ofc ("AEfwShowLaunchPosManipCB " + $nodeName + " 0")
			AEfwShowLaunchManipC;

		setParent ..;

	   	rowLayout
			-numberOfColumns 3
			-columnWidth 1 20
			-columnWidth 2 180
			-columnWidth 3 165
			AEfwBurstPosButtonsRow;

		text -l "";

		button -label (uiRes("m_AEparticleFireworksNew.kSetRocketBurstPosition")) 
			-c ("AEfwSetBurstPositionCB " + $nodeName )
			AEfwSetBurstPosB;

		button -label (uiRes("m_AEparticleFireworksNew.kSetRocketLaunchPosition")) 
			-c ("AEfwSetLaunchPositionCB " + $nodeName )
			AEfwSetLaunchPosB;
	
		setParent ..;
		text -label " " -height 3;

		setParent AEparticleFireworksPositionColumn;

		// Add controls to edit the launch frame and burst frame for each
		// particle/rocket.
		//
		createFrameTimesLayout($nodeName);

		// Get the current rocket id and set the frame times controls
		//
		int $rocketId = getCurrentRocketId();
		if ($rocketId > -1)
			setFrameTimesControls($nodeName, $rocketId);

	}

	// Put the launchFramePP and burstFramePP values for the rocket
	// currently selected in the option menu.
	//
	int $rocketId = getCurrentRocketId();

	if ($rocketId > -1)
	{
		float $launchFrame[] =
				`particle -attribute launchFramePP -id $rocketId -q $nodeName`;
		float $burstFrame[] =
				`particle -attribute burstFramePP -id $rocketId -q $nodeName`;

		floatSliderGrp -e -v $launchFrame[0] AEfwLaunchFrame;
		floatSliderGrp -e -v $burstFrame[0] AEfwBurstFrame;
	}

	// Set the checkboxes and buttons.
	//

	// Reset the control callbacks for the current node.
	//
	checkBox -e
		-onc ("AEfwShowBurstPositionCB " + $nodeName + " 1")
		-ofc ("AEfwShowBurstPositionCB " + $nodeName + " 0")
		AEfwShowBurstPosC;

	checkBox -e
		-onc ("AEfwShowLaunchPositionCB " + $nodeName + " 1")
		-ofc ("AEfwShowLaunchPositionCB " + $nodeName + " 0")
		AEfwShowLaunchPosC;
	checkBox -e
		-onc ("AEfwShowBurstPosManipCB " + $nodeName + " 1")
		-ofc ("AEfwShowBurstPosManipCB " + $nodeName + " 0")
		AEfwShowBurstManipC;

	checkBox -e
		-onc ("AEfwShowLaunchPosManipCB " + $nodeName + " 1")
		-ofc ("AEfwShowLaunchPosManipCB " + $nodeName + " 0")
		AEfwShowLaunchManipC;

	button -e
		-c ("AEfwSetBurstPositionCB " + $nodeName )
		AEfwSetBurstPosB;

	button  -e
		-c ("AEfwSetLaunchPositionCB " + $nodeName )
		AEfwSetLaunchPosB;
	

	// Set the checkbox appropriately for showAllLaunchPositions.
	//
	int $launchPosVisible = 
			`getAttr ($nodeName + ".showAllLaunchPositions")`;

	checkBox -e -v $launchPosVisible AEfwShowLaunchPosC;

	// Set the checkbox appropriately for showAllBurstPositions.
	//
	int $burstPosVisible = 
			`getAttr ($nodeName + ".showAllBurstPositions")`;

	checkBox -e -v $burstPosVisible AEfwShowBurstPosC;

	int $isOn = `checkBox -q -v AEfwShowLaunchManipC`;
	AEfwShowLaunchPosManipCB( $nodeName, $isOn);
	$isOn = `checkBox -q -v AEfwShowBurstManipC`;
	AEfwShowBurstPosManipCB( $nodeName, $isOn);

}


//
//  ================ AEfwRocketsMenuGrpCB ================
//
//  SYNOPSIS
//		Callback for the Rockets Menu Group by which the user selects
//		a given particle/rocket to edit.
//
//	ARGUMENTS
//		string $nodeName -- name of the current particle node.
//
//	RETURN
//		None
//
global proc AEfwRocketsMenuGrpCB(string $nodeName)
{
	global string $AEfwOptionMenuParent;

	// Get the menu label name of the current selection.
	//
	int $rocketId = getCurrentRocketId();

	if ($rocketId == -1) return;

	// Find out which colorIndex this rocket currently has, and highlight that
	// canvas in the palette array.  We know it by the sparkColorIndex. 
	// 
	float $sparkColorIndex[] = 
			`particle -attribute burstColorIndex -id $rocketId -q $nodeName`;

    // De-highlight the current selection (we don't know which it is, so have
	// to de-highlight all, then highlight the selection canvas for the
	// current rocket.
	//
	setColorSelectionCanvasHighlight($nodeName, $sparkColorIndex[0]);

	// Set the positions of the launch and burst locators
	// to the launch and burst locations of the selected particle.
	//
	setLaunchLocatorPosition($nodeName, $rocketId);
	setBurstLocatorPosition($nodeName, $rocketId);

	// Set the launchFrame and burstFrame controls to those of the
	// selected particle.
	//
	setFrameTimesControls($nodeName, $rocketId);
}


//
//  ================ AEfwColorCanvasCB ================
//
//  SYNOPSIS
//		Callback for the color canvases (for spark burst colors and
//		trail colors).  This will bring up the Color
//		Editor to edit the color, and put the new color value in the
//		fireworksColors attribute at the selected index.
//
//	ARGUMENTS
//		string $nodeName         -- Name of the current particle node.
//		string $attrName         -- Name of attribute to get color index from
//		string $shaderName       -- Name of shader to be edited
//		int    $colorCanvasIndex -- Index of color canvas to be edited.
//		string $colorCanvasName  -- Name of color canvas to be edited.
//
//	RETURN
//		None
//
global proc AEfwColorCanvasCB(string $nodeName,
								string $attrName,
								string $shaderName,
								int $colorCanvasIndex,
                       			string $colorCanvasName)
{
	global string $AEfwOptionMenuParent;

	// Get the current color of the selected canvas from the particle.
	//
	float $color[];	
	$color = 
		`getAttr ($nodeName + "." + $attrName + "[" + $colorCanvasIndex + "]")`;

	vector $currColors = <<$color[0], $color[1], $color[2]>>;

	// Call the color editor so the user can edit the color.
	// Return is the three floats in string format, followed by a 1 if the
	// user selected "OK" and 0 if the user selected "Cancel" in the editor.
	//
    string $result =
        `colorEditor -rgb ($currColors.x) ($currColors.y) ($currColors.z)`;

    string $buffer[];
    tokenize($result, " ", $buffer);

	float $newR = $buffer[0];
	float $newG = $buffer[1];
	float $newB = $buffer[2];
	vector $newColor = <<$newR, $newG, $newB>>;

    string $userOk = $buffer[3];

	// If the user selected OK, then do the edit.
	//
    if ($userOk)
    {
		// Set the new values in the particle "fireworksColors" attribute,
		// in the shader for this color, and in the color canvas.
		//
		editColor( $nodeName,
					$attrName,
					$shaderName,
					$colorCanvasName,
					$newColor,
					$colorCanvasIndex);
	}
}


//
//  ================ AEfwSelectionCanvasCB ================
//
//  SYNOPSIS
//		Callback for the selection canvases.  The canvas selected becomes
//		the new color of the particle/rocket currently selected in the
//		option menu.
//
//	ARGUMENTS
//		string $nodeName             -- Name of the current particle node.
//		int    $selectionCanvasIndex -- Index of selection canvas just selected.
//
//	RETURN
//		None
//
global proc AEfwSelectionCanvasCB(string $nodeName,
									int $selectionCanvasIndex)
{
	global string $AEfwOptionMenuParent;

    // If the canvas selection is changed, then make the current rocket
    // in the option menu group have that color.
    //

    // Get the id of the current Rocket from the menu group
    //
	int $rocketId = getCurrentRocketId();

	if ($rocketId == -1) return;

    // The canvas index is the new index into $nodeName.fireworksColors
    // for the current particle/rocket. So, we have to put that in
	// $nodeName.burstColorIndex for the currently selected particle/
	// rocket.
    //
	particle -e
			-id $rocketId 
			-attribute burstColorIndex0 
			-fv $selectionCanvasIndex $nodeName;
	particle -e
			-id $rocketId 
			-attribute burstColorIndex 
			-fv $selectionCanvasIndex $nodeName;

    // De-highlight the selection canvases, then highlight the current
	// color of the current particle/rocket.
    //
	setColorSelectionCanvasHighlight($nodeName, $selectionCanvasIndex);

}


//
//  ================ AEfwSetLaunchPositionCB ================
//
//  SYNOPSIS
//		Callback for the Set Rocket Launch Position button.
//		This does the edit of the launch position of the selected particle.
//
//	ARGUMENTS
//		string $nodeName             -- Name of the current particle node.
//
//	RETURN
//		None
//
global proc AEfwSetLaunchPositionCB(string $nodeName )
{
	global string $AEfwOptionMenuParent;

	// Get the id of the currently selected particle/rocket.
	//
	int $rocketId = getCurrentRocketId();

	if ($rocketId == -1) return;

	// Get the name of the launch locator
	//
	string $launchLocator = 
			getSourceNode(($nodeName + ".launchPositionManipMessage"));

	// Get the position of the locator
	//
	float $locatorPos[] = `getAttr ($launchLocator + ".translate")`;

	// Set the launch position of the currently selected particle/rocket
	// to the location of the launch locator.
	//
	particle -e
		-attribute launchPositionPP0 -id $rocketId 
		-vv $locatorPos[0] $locatorPos[1] $locatorPos[2]
		$nodeName;

	particle -e
		-attribute launchPositionPP -id $rocketId 
		-vv $locatorPos[0] $locatorPos[1] $locatorPos[2]
		$nodeName;

	refresh;
}


//
//  ================ AEfwShowLaunchPositionCB ================
//
//  SYNOPSIS
//		Callback for the Show Launch Positions checkbox.
//		This either shows or hides the launch positions by setting the
//		appropriate attribute.
//
//	ARGUMENTS
//		string $nodeName  -- Name of the current particle node.
//		int    $isOn      -- whether the checkbox is on or off.
//
//	RETURN
//		None
//
global proc AEfwShowLaunchPositionCB(string $nodeName, int $isOn)
{
	// Have to get the source attribute for the "showAllLaunchPositions"
	// attribute and edit it.
	//
	string $nodeAttr = $nodeName + ".showAllLaunchPositions";
	string $sourcePlug = getSourcePlug($nodeAttr);

	if ($isOn)
	{
		setAttr $sourcePlug true;
	}
	else
	{
		setAttr $sourcePlug false;
	}
}


//
//  ================ AEfwSetBurstPositionCB ================
//
//  SYNOPSIS
//		Callback for the Set Rocket Burst Position button.
//		This does the edit of the burst position of the selected particle.
//
//	ARGUMENTS
//		string $nodeName  -- Name of the current particle node.
//
//	RETURN
//		None
//
global proc AEfwSetBurstPositionCB(string $nodeName )
{
	global string $AEfwOptionMenuParent;
	
	// Get the id of the currently selected particle/rocket.
	//
	int $rocketId = getCurrentRocketId();

	if ($rocketId == -1) return;

	// Get the name of the burst locator
	//
	string $burstLocator = getSourceNode($nodeName + ".burstPositionManipMessage");

	// Get the position of the locator
	//
	float $locatorPos[] = 
			`getAttr ($burstLocator + ".translate")`;

	// Set burst position of the particle that is currently selected to
	// be at the position of the locator.
	//
	particle -e
		-attribute burstPositionPP0 -id $rocketId 
		-vv $locatorPos[0] $locatorPos[1] $locatorPos[2]
		$nodeName;

	particle -e
		-attribute burstPositionPP -id $rocketId 
		-vv $locatorPos[0] $locatorPos[1] $locatorPos[2]
		$nodeName;

	refresh;
}


//
//  ================ AEfwShowBurstPositionCB ================
//
//  SYNOPSIS
//		Callback for the Show Burst Positions checkbox.
//		This either shows or hides the burst positions by setting the
//		appropriate attribute.
//
//	ARGUMENTS
//		string $nodeName  -- Name of the current particle node.
//		int    $isOn      -- whether the checkbox is on or off.
//
//	RETURN
//		None
//
global proc AEfwShowBurstPositionCB(string $nodeName, int $isOn)
{
	// Have to get the source attribute for the "showAllBurstPositions"
	// attribute and edit it.
	//
	string $nodeAttr = $nodeName + ".showAllBurstPositions";
	string $sourcePlug = getSourcePlug($nodeAttr);

	if ($isOn)
	{
		setAttr $sourcePlug true;
	}
	else
	{
		setAttr $sourcePlug false;
	}
}


//
//  ================ AEfwShowLaunchPosManipCB ================
//
//  SYNOPSIS
//		Callback for the Show Launch Position Manip checkbox.
//		Sets controls appropriately for whether the user selects to
//		show or hide the locator manip for launch position
//		of the rockets.
//
//	ARGUMENTS
//		string $nodeName  -- name of the current particle node.
//		int    $isOn      -- whether the checkbox is on or off.
//
//	RETURN
//		None
//
global proc AEfwShowLaunchPosManipCB (string $nodeName, int $isOn)
{
	// Get the name of the launch locator
	//
	string $launchLocator = 
			getSourceNode(($nodeName + ".launchPositionManipMessage"));

	if ($isOn)
	{
		// If the checkbox is on, show the locator and enable the
		// launch position edit buttons.
		//
		button -e -enable true  AEfwSetLaunchPosB;

		// Set the location of the position manip to be at the
		// currently selected rocket launch position.
		//
		int $rocketId = getCurrentRocketId();
		if ($rocketId > -1)
			setLaunchLocatorPosition($nodeName, $rocketId);

		// Select the locator.
		//
		select -r $launchLocator;
	
		// Set to the move tool context.
		// 
		setToolTo moveSuperContext;

		// Make sure the "Show Burst Pos Manip" is off.
		//
		button -e -enable false  AEfwSetBurstPosB;
		checkBox -e -value 0  AEfwShowBurstManipC;
	}
	else
	{
		// If the checkbox is off, disable the
		// position edit buttons. Reset to select context.
		//
		button -e -enable false  AEfwSetLaunchPosB;

		setToolTo selectSuperContext;
	}
}

//
//  ================ AEfwShowBurstPosManipCB ================
//
//  SYNOPSIS
//		Callback for the Show Burst Position Manip checkbox.
//		Sets controls appropriately for whether the user selects to
//		show or hide the locator manip for the burst position
//		of the rockets.
//
//	ARGUMENTS
//		string $nodeName  -- name of the current particle node.
//		int    $isOn      -- whether the checkbox is on or off.
//
//	RETURN
//		None
//
global proc AEfwShowBurstPosManipCB (string $nodeName, int $isOn)
{
	// Get the name of the burst locator
	//
	string $burstLocator = 
			getSourceNode($nodeName + ".burstPositionManipMessage");

	if ($isOn)
	{
		// If the checkbox is on, show the locator and enable the
		// burst position edit buttons.
		//
		button -e -enable true  AEfwSetBurstPosB;

		// Set the locations of the position manips to be at the
		// currently selected rocket launch and burst positions.
		//
		int $rocketId = getCurrentRocketId();
		if ($rocketId > -1)
			setBurstLocatorPosition($nodeName, $rocketId);

		// Select the locator.
		//
		select -r $burstLocator;

		// Set to the move tool context.
		// 
		setToolTo moveSuperContext;

		// Turn off the checkbox and buttons for the burst position manip.
		//
		button -e -enable false  AEfwSetLaunchPosB;
		checkBox -e -value 0  AEfwShowLaunchManipC;

	}
	else
	{
		// If the checkbox is off, disable the launch position edit button.
		//
		button -e -enable false  AEfwSetBurstPosB;

		// Set to the select tool context.
		// 
		setToolTo selectSuperContext;
	}
}


//
//  ================ AEfwLaunchFrameCB ================
//
//  SYNOPSIS
//		Callback for the Launch Frame float slider
//		Sets the value in the float slider into the launchFramePP
//		attribute for the particle id of the particle/rocket currently
//		selected in the option menu.
//
//	ARGUMENTS
//		string $nodeName  -- name of the current particle node.
//
//	RETURN
//		None
//
global proc AEfwLaunchFrameCB( string $nodeName)
{
	global string $AEfwOptionMenuParent;

	// Get the current particle/rocket id.
	//
	int $rocketId = getCurrentRocketId();

	if ($rocketId == -1) return;

	// Get the value from the Launch Frame float field and set it into
	// launchFramePP for particle with id $rocketId.
	//
	float $launchFrame = `floatSliderGrp -q -v AEfwLaunchFrame`;

	particle -e 
		-attribute launchFramePP0 -id $rocketId -fv $launchFrame
		$nodeName;
	particle -e 
		-attribute launchFramePP -id $rocketId -fv $launchFrame
		$nodeName;
}


//
//  ================ AEfwBurstFrameCB ================
//
//  SYNOPSIS
//		Callback for the Burst Frame float slider
//		Sets the value in the float slider into the burstFramePP
//		attribute for the particle id of the particle/rocket currently
//		selected in the option menu.
//
//	ARGUMENTS
//		string $nodeName  -- name of the current particle node.
//
//	RETURN
//		None
//
global proc AEfwBurstFrameCB(string $nodeName)
{
	global string $AEfwOptionMenuParent;

	// Get the current particle/rocket id.
	//
	int $rocketId = getCurrentRocketId();

	if ($rocketId == -1) return;

	// Get the value from the Burst Frame float field and set it into
	// burstFramePP for particle with id $rocketId.
	//
	float $burstFrame = `floatSliderGrp -q -v AEfwBurstFrame`;

	particle -e 
		-attribute burstFramePP0 -id $rocketId -fv $burstFrame
		$nodeName;
	particle -e 
		-attribute burstFramePP -id $rocketId -fv $burstFrame
		$nodeName;
}


//
//  ================ AEfwLaunchFrameSJ ================
//
//  SYNOPSIS
//		Callback for the Launch Frame script job.  Called if the attribute
//		is changed from somewhere other than the editor.
//		Sets the value in the launchFramePP attribute for the particle id
//		of the particle/rocket currently selected in the option menu into
//		the Launch Frame floatSliderGrp.
//
//	ARGUMENTS
//		string $nodeName  -- name of the current particle node.
//
//	RETURN
//		None
//
global proc AEfwLaunchFrameSJ( string $nodeName)
{
	// Get the current particle/rocket id.
	//
	int $rocketId = getCurrentRocketId();

	if ($rocketId == -1) return;

	// Now see if the id in the option menu still exists and if it doesn't
	// just return.  The particle could have died during playback but the
	// layout has not yet been reset before the scriptJob (called when the
	// burstFrame has changed, which I suppose it did because the particle
	// died)  is executed, so we will be querying a particle that doesn't
	// exist, which results in an error message.
	//

	// Find out how many particles (rockets) are in the particle node.
	//
	int $numParticles = `particle -q -count $nodeName`;

	// Get a list of the id's of all the particles in the node.
	//
	float $particleIds[];
	int $found = 0;
	for ($i = 0; $i < $numParticles; $i++)
	{
		float $id[];
		$id = `particle -attribute id -order $i -q $nodeName`;

		if ($id[0] == $rocketId)
		{
			$found = 1;
			break;
		}
	}

	if (!$found)
		return;

	// Get the value from thelaunchFramePP for the particle with id $rocketId,
	// and set it into the Launch Frame float field.
	//
	float $launchFrame[] = `particle 
								-attribute launchFramePP -id $rocketId 
								-q
								$nodeName`;

	floatSliderGrp -e -v $launchFrame[0] AEfwLaunchFrame;
}


//
//  ================ AEfwBurstFrameSJ ================
//
//  SYNOPSIS
//		Callback for the Burst Frame script job.  Called if the attribute
//		is changed from somewhere other than the editor.
//		Sets the value in the burstFramePP attribute for the particle id
//		of the particle/rocket currently selected in the option menu into
//		the Burst Frame floatSliderGrp.
//
//	ARGUMENTS
//		string $nodeName  -- name of the current particle node.
//
//	RETURN
//		None
//
global proc AEfwBurstFrameSJ( string $nodeName)
{
	// Get the current particle/rocket id.
	//
	int $rocketId = getCurrentRocketId();

	if ($rocketId == -1) return;

	// Now see if the id in the option menu still exists and if it doesn't
	// just return.  The particle could have died during playback but the
	// layout has not yet been reset before the scriptJob (called when the
	// burstFrame has changed, which I suppose it did because the particle
	// died)  is executed, so we will be querying a particle that doesn't
	// exist, which results in an error message.
	//

	// Find out how many particles (rockets) are in the particle node.
	//
	int $numParticles = `particle -q -count $nodeName`;

	// Get a list of the id's of all the particles in the node.
	//
	float $particleIds[];
	int $found = 0;
	for ($i = 0; $i < $numParticles; $i++)
	{
		float $id[];
		$id = `particle -attribute id -order $i -q $nodeName`;

		if ($id[0] == $rocketId)
		{
			$found = 1;
			break;
		}
	}

	if (!$found)
		return;

	// Get the value from the burstFramePP for the particle with id $rocketId,
	// and set it into the Burst Frame float field.
	//

	float $burstFrame[] = `particle 
	 							-attribute burstFramePP -id $rocketId 
	 							-q
	 							$nodeName`;

	floatSliderGrp -e -v $burstFrame[0] AEfwBurstFrame;

}


//  ================ AEfwSparksColorSpreadCB ================
//
//  SYNOPSIS
//		Callback for the Sparks Color Spread attrFieldSliderGrp.
//		Reset the highlighting of the selection canvas to reflect
//		the new range.
//
//	ARGUMENTS
//		string $nodeName  -- name of the current particle node.
//
//	RETURN
//		None
//
global proc AEfwSparksColorSpreadCB(string $nodeName)
{
	// Find out what is the currently selected particle/rocket.
	// Get its index into the color palette and make that the selected/
	// highlit one.  This will reset to highlight the number of colors
	// in the range.
	//
	int $rocketId = getCurrentRocketId();

	if ($rocketId > -1)
	{
		float $sparkColorIndex[] = 
			`particle -attribute burstColorIndex -id $rocketId -q
						$nodeName`;

		setColorSelectionCanvasHighlight($nodeName, $sparkColorIndex[0]);
	}
}


//  ================ AEfwFireworksDisplayCB ================
//
//  SYNOPSIS
//		Callback for the Fireworks display type radioButtonGrp.
//		Set whether to display the fireworks bursts as geometry (cones)
//		or particles.
//
//	ARGUMENTS
//		string $nodeName  -- name of the current particle node.
//		string $displayType -- "geometry" or "particle"
//
//	RETURN
//		None
//
global proc AEfwFireworksDisplayCB(string $nodeName, int $displayGeom)
{
	// Find the fireworks group and set its displayGeometry attribute.
	// The visibility of particle vs instancer will be set via an
	// expression.
	//
	$fireworksGroup = 
			getSourceNode(($nodeName + ".rocketsMessage"));

	setAttr ($fireworksGroup + ".displayGeometry")  $displayGeom;
}


//  ================ AEfwResetColorPaletteCB ================
//
//  SYNOPSIS
//		Callback for the Fireworks Reset to Original Color Palette button.
//		Re-make the color paletter to its original set of colors.
//
//	ARGUMENTS
//		string $nodeName  -- name of the current particle node.
//
//	RETURN
//		None
//
global proc AEfwResetColorPaletteCB(string $nodeName )
{
	// Get the name of the procedure used to create the color palette.
	//
	$proc = `getAttr ($nodeName + ".colorPaletteProc")`;

	remakeColorPalette($nodeName, $proc);

}


//  ================ AEfwCreateNewColorPaletteCB ================
//
//  SYNOPSIS
//		Callback for the Fireworks Reset to Original Color Palette button.
//		Re-make the color paletter to its original set of colors.
//
//	ARGUMENTS
//		string $nodeName  -- name of the current particle node.
//
//	RETURN
//		None
//
global proc AEfwCreateNewColorPaletteCB(string $nodeName )
{
	// Get the name of the procedure used to create the color palette.
	//
	string $proc = `textFieldGrp -q -tx AEfwCreateColorPaletteTF`;

	if ($proc == "")
	{
		warning((uiRes("m_AEparticleFireworksNew.kNoRestColorPalette")));
		return;
	}

	remakeColorPalette($nodeName, $proc);

	// Reset the button to the new proc name; and clear the textfield.
	//
	button -e
		-l ("Reset from " + $proc)
		AEfwResetColorPaletteB;

	textFieldGrp -e -tx "" AEfwCreateColorPaletteTF;
}


//
//  ================ AEparticleFireworksNew ================
//
//  SYNOPSIS
//		Main procedure to create the fireworks layout in the Attribute Editor.
//
//	ARGUMENTS
//		string $nodeAttr  -- name of the current particle node and attribute.
//
//	RETURN
//		None
//
global proc AEparticleFireworksNew ( string $nodeAttr )
{
	string $buffer[];
	tokenize($nodeAttr, ".", $buffer);
	string $nodeName = $buffer[0];
	string $attrName = $buffer[1];

	setUITemplate -pst attributeEditorTemplate;

	// If this particle is not a fireworks rocket particle, if there is
	// a fireworks layout, delete it and return.
	//
	if (!`attributeQuery -node $nodeName -exists _fireworksRocket`)
	{
		if (`frameLayout -ex AEparticleFireworksFrame`)
    	{
			frameLayout -e -manage 0 AEparticleFireworksFrame;
			deleteUI -layout AEparticleFireworksFrame;
		}
		return;
	}

	setUITemplate -ppt;

	// Create the fireworks layout, or modify it.
	//
	AEparticleFireworksReplace $nodeAttr;

}


//
//  ================ AEparticleFireworksReplace ================
//
//  SYNOPSIS
//		Procedure to create/modify the fireworks layout in the Attribute Editor.
//
//	ARGUMENTS
//		string $nodeAttr  -- name of the current particle node and attribute.
//
//	RETURN
//		None
//
global proc AEparticleFireworksReplace ( string $nodeAttr )
{
	global string $AEfwOptionMenuParent;

	// Get the node and attributes names.
	//
	string $buffer[];
	tokenize($nodeAttr, ".", $buffer);
	string $nodeName = $buffer[0];
	string $attrName = $buffer[1];

	if (!`attributeQuery -node $nodeName -exists _fireworksRocket`)
	{
		// If this is not a fireworks rocket, if there are controls in this
		// layout, we need to delete them.
		//
		// We can just delete the frame.
		//
		if (`frameLayout -ex AEparticleFireworksFrame`)
    	{
			frameLayout -e -manage 0 AEparticleFireworksFrame;
			deleteUI -layout AEparticleFireworksFrame;
		}
		setUITemplate -ppt;
		return;
	}

	// If the frame does not exist,  build it.
	//
	if (!`frameLayout -ex AEparticleFireworksFrame`)
   	{
       	setUITemplate -pst attributeEditorTemplate;

   		frameLayout
			-borderVisible 1
			-collapse 1
			-collapsable 1
			-label (uiRes("m_AEparticleFireworksNew.kFireworks")) 
			AEparticleFireworksFrame;

	}
	// If the column does not exist,  build it.
	//
	if (!`columnLayout -ex AEparticleFireworksColumn`)
   	{
		columnLayout AEparticleFireworksColumn;
	}

	if(!`frameLayout -ex AEparticleFireworksDisplayFrame`)
	{
		frameLayout
			-borderVisible 0
			-collapse 0
			-collapsable 0
			-label (uiRes("m_AEparticleFireworksNew.kFireworksDisplayType")) 
			AEparticleFireworksDisplayFrame;

		columnLayout AEparticleFireworksColumn;

		radioButtonGrp 
			-nrb 1
			-label1 (uiRes("m_AEparticleFireworksNew.kDisplayAsGeometry")) 
			-cc1 ("AEfwFireworksDisplayCB " + $nodeName + " 1")
			AEfwFireworksDisplayType1;

		radioButtonGrp 
			-nrb 1
			-scl AEfwFireworksDisplayType1
			-label1 (uiRes("m_AEparticleFireworksNew.kDisplayAsParticles")) 
			-cc1 ("AEfwFireworksDisplayCB " + $nodeName + " 0")
			AEfwFireworksDisplayType2;
	}

	// Set the radio button.
	//
	$fireworksGroup = 
			getSourceNode(($nodeName + ".rocketsMessage"));

	int $displayGeom = `getAttr ($fireworksGroup + ".displayGeometry")`;
	if ($displayGeom)
		radioButtonGrp -e -sl 1 AEfwFireworksDisplayType1;
	else
		radioButtonGrp -e -sl 1 AEfwFireworksDisplayType2;

	setParent AEparticleFireworksColumn;

	// Get the list of all the rocket particles (their id's) and put them
	//
	AEfwCreateOrEditOptionMenu($nodeName);

	setParent AEparticleFireworksColumn;

	if (!`text -exists AEfwPositionsSeparatorText`)	
		text -l "" -height 3 AEfwPositionsSeparatorText;
	if (!`separator -exists AEfwPositionsSeparator`)	
		separator AEfwPositionsSeparator;

	// Create the layout for editing the rocket launch and burst
	// positions
	//
	createOrEditPositionsLayout($nodeName);

	// Set the launch and burst positions to be at the particle/rocket
	// which is currently selected in the option menu.
	//
	int $rocketId = getCurrentRocketId();

	if ($rocketId > -1) 
	{
		setLaunchLocatorPosition($nodeName, $rocketId);
		setBurstLocatorPosition($nodeName, $rocketId);
	}

	// Set a filler so there will be a little space before the color
	// palette.
	//

	// Create the color palettes.
	//
	setParent AEparticleFireworksColumn;

	if (!`text -exists AEfwColorSeparatorText`)	
		text -l "" -height 3 AEfwColorSeparatorText;
	if (!`separator -exists AEfwColorSeparator`)	
		separator AEfwColorSeparator;

	if (!`columnLayout -exists AEparticleFireworksPaletteColumn`)
	{
		createFireworksColorPalette($nodeName);
	}
	else
	{
		editFireworksColorPalette($nodeName);
	}

	setParent AEparticleFireworksColumn;

	if (!`separator -exists AEfwTrailsColorSeparator`)	
		separator AEfwTrailsColorSeparator;

	if (!`columnLayout -exists AErocketTrailsPaletteColumn`)
	{
		createRocketTrailsColorPalette($nodeName);
	}
	else
	{
		editRocketTrailsColorPalette($nodeName);
	}

	setParent ..;
	setUITemplate -ppt;
}



