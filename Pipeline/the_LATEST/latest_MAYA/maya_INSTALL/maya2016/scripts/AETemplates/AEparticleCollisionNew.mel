// Copyright (C) 1997-2014 Autodesk, Inc., and/or its licensors.
// All rights reserved.
//
// The coded instructions, statements, computer programs, and/or related
// material (collectively the "Data") in these files contain unpublished
// information proprietary to Autodesk, Inc. ("Autodesk") and/or its licensors,
// which is protected by U.S. and Canadian federal copyright law and by
// international treaties.
//
// The Data is provided for use exclusively by You. You have the right to use,
// modify, and incorporate this Data into other products for purposes authorized 
// by the Autodesk software license agreement, without fee.
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND. AUTODESK
// DOES NOT MAKE AND HEREBY DISCLAIMS ANY EXPRESS OR IMPLIED WARRANTIES
// INCLUDING, BUT NOT LIMITED TO, THE WARRANTIES OF NON-INFRINGEMENT,
// MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE, OR ARISING FROM A COURSE 
// OF DEALING, USAGE, OR TRADE PRACTICE. IN NO EVENT WILL AUTODESK AND/OR ITS
// LICENSORS BE LIABLE FOR ANY LOST REVENUES, DATA, OR PROFITS, OR SPECIAL,
// DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES, EVEN IF AUTODESK AND/OR ITS
// LICENSORS HAS BEEN ADVISED OF THE POSSIBILITY OR PROBABILITY OF SUCH DAMAGES.

//
//
//  Creation Date:	july 15, 1997
//
//  Procedure Name:
//	AEdynObjectCollisionNew
//
//  Description Name;
//	Creates the controls for the multiAttr collisionGeometry on the dynObject Node
//
//  Input Value:
//	nodeName.attrName 
//
//  Output Value:
//	None
// 

global proc dynSetResilience( float $resilience, string $nodeName, int $index )
{
	setAttr ($nodeName + ".collisionResilience[" + $index + "]") $resilience;
}

global proc dynSetFriction( float $friction, string $nodeName, int $index )
{
	setAttr ($nodeName + ".collisionFriction[" + $index + "]") $friction;
}

global proc dynSetOffset( float $offset, string $nodeName, int $index )
{
	setAttr ($nodeName + ".collisionOffset[" + $index + "]") $offset;
}

global proc dynOffsetChange( string $attr, string $ctrl )
{
	float $offset = `getAttr $attr`;
	if( $offset <= 0.0 ) {
		error( (uiRes("m_AEparticleCollisionNew.kOffsetZero")) );
	}
}

global proc AEparticleCollisionNew ( string $nodeAttr )
{
	string $buffer[];
	tokenize($nodeAttr, ".", $buffer);
	string $nodeName = $buffer[0];
	string $attrName = $buffer[1];

	setUITemplate -pst attributeEditorTemplate;

	columnLayout ($attrName+"Column");

	setParent ..;
	setUITemplate -ppt;

	AEparticleCollisionReplace $nodeAttr;
}


global proc AEparticleCollisionReplace ( string $nodeAttr )
{
	//  Particle systems provide (u,v) coordinates of collision impact points
	//  via the collisionU/collisionV per-particle attributes.  We have now
	//	added controls to allow users to specify which of the collision object's
	//	uv sets are used to express these coordinates.  The uvControlUtils()
	//	procedure brings into scope the functions necessary to implement the 
	//	user interface for dynamics-relate uv set choosing functionality.
	//
	uvControlUtils();
	
	string $buffer[];
	tokenize($nodeAttr, ".", $buffer);
	string $nodeName = $buffer[0];
	string $attrName = $buffer[1];

	string $collisionGeoms[] = `collision -q $nodeName`;
	string $collisionNames[];
	int    $collisionIndices[];
	int $collGeomCount = size($collisionGeoms);
	int $i;
	for( $i = 0; $i < $collGeomCount; $i ++ )
	{
		string $geomIndex[];
		tokenize( $collisionGeoms[$i], ":", $geomIndex);
		$collisionNames[size($collisionNames)] = $geomIndex[0];
		$collisionIndices[size($collisionIndices)] = $geomIndex[1];
	}

	string $columnName = $attrName + "Column";
	setUITemplate -pst attributeEditorTemplate;
	if (!`columnLayout -ex $columnName`)
	{
		setUITemplate -pst attributeEditorTemplate;
		columnLayout $columnName;
		setUITemplate -ppt;
	}
	setParent $columnName;
	$layoutName=`setParent -q`;

	// $numSetsExisting is used to delete any controls that are not being
	// re-used, which will happen if the number of goals of the new particle
	// in the editor is less than that of the previous particle.  So first,
	// we find out how many children (controls) are now in the layout.
	//
	int $numSetsExisting = `columnLayout -q -nch $layoutName`;

	// We have to remove from consideration in deleting unused controls the
	// first control, "goalSmoothness", which is always there.  But also, we
	// delete two at a time, so we want half the number of unused controls for
	// the loop counter.
	//
	if ($numSetsExisting > 0)
		$numSetsExisting = ($numSetsExisting - 1) / 3;

	// The controls will be:  an attrFieldSliderGrp for each
	// goal + weight -- the name of the goal object is the  label
	// of the slider field, and the weight applied to that goal
	// object is the value in the slider field.
	//
	string $traceDepth = (uiRes("m_AEparticleCollisionNew.kTraceDepth"));
	if (`attrFieldSliderGrp -ex pTraceDepth`)
	{
        attrFieldSliderGrp -e
            -label $traceDepth
            -s 1
            -at ($nodeName + ".traceDepth")
            pTraceDepth;
    }
    else
    {
        setUITemplate -pst attributeEditorTemplate;
        attrFieldSliderGrp
            -label $traceDepth
            -s 1
            -at ($nodeName + ".traceDepth")
        pTraceDepth;
        setUITemplate -ppt;
    }

	for ($i = 0; $i < size($collisionNames); $i++)
	{		
		string $groupLabel = $collisionNames[$i];

		string $format = (uiRes("m_AEparticleCollisionNew.kMultiObjectLabel"));
		string $textFieldLabel = `format -s $collisionIndices[$i] $format`;

		string $textFieldName = ( "collisionObject" + $i );
		string $resSliderLabel = (uiRes("m_AEparticleCollisionNew.kResilience"));
		string $fricSliderLabel = (uiRes("m_AEparticleCollisionNew.kFriction"));
		string $offsetSliderLabel = (uiRes("m_AEparticleCollisionNew.kCollisionOffset"));
		string $uvSetName = "collisionUVSet" + $i;
		string $sepName = "collisionSeparator" + $i;

		// Index i here is not correct because goals may not be
		// consecutive in the multi.  Need to get the index from
		// the shape.  
		//
		$resFullAttrName = $nodeName + ".collisionResilience[" + $collisionIndices[$i] + "]";
		$resSliderName = "resilience" + $i;
		$fricFullAttrName = $nodeName + ".collisionFriction[" + $collisionIndices[$i] + "]";
		$fricSliderName = "friction" + $i;
		$offsetFullAttrName = $nodeName + ".collisionOffset[" + $collisionIndices[$i] + "]";
		$offsetSliderName = "offset" + $i;

		if (`textFieldGrp -ex $textFieldName`)
		{
			textFieldGrp -e
				-label $textFieldLabel
				-editable false
				-text $groupLabel
				$textFieldName;
		}
		else
		{
			setUITemplate -pst attributeEditorTemplate;

			textFieldGrp
				-label $textFieldLabel
				-editable false
				-text $groupLabel
				$textFieldName;

			setUITemplate -ppt;
		}

		if (`attrFieldSliderGrp -ex $resSliderName`)
		{
			attrFieldSliderGrp -e 
				-l $resSliderLabel
				-s 0.1 
				-at $resFullAttrName
				$resSliderName;
		}
		else
		{
			setUITemplate -pst attributeEditorTemplate;

			attrFieldSliderGrp 
				-l $resSliderLabel
				-s 0.1 
				-at $resFullAttrName
			$resSliderName;

			setUITemplate -ppt;
		}

		if (`attrFieldSliderGrp -ex $fricSliderName`)
		{
			attrFieldSliderGrp -e 
				-l $fricSliderLabel
				-s 0.1 
				-at $fricFullAttrName
				$fricSliderName;
		}
		else
		{
			setUITemplate -pst attributeEditorTemplate;

			attrFieldSliderGrp 
				-l $fricSliderLabel
				-s 0.1 
				-at $fricFullAttrName
			$fricSliderName;

			setUITemplate -ppt;
		}
		
		if( `attrFieldSliderGrp -ex $offsetSliderName`) 
		{
			attrFieldSliderGrp -e
				-label $offsetSliderLabel
				-pre 3 
				-s 0.01
				-at $offsetFullAttrName
				$offsetSliderName;
		}
		else 
		{
			setUITemplate -pst attributeEditorTemplate;

			attrFieldSliderGrp
				-l $offsetSliderLabel
				-cc ("dynOffsetChange "+$offsetFullAttrName+" "+$offsetSliderName)
				-pre 3
				-s 0.01
				-at $offsetFullAttrName
			$offsetSliderName;

			setUITemplate -ppt;
		}
		
		int $collisionIndex = $collisionIndices[$i];
		
		if (`optionMenuGrp -ex $uvSetName`)
		{
			// update the uv set dropdown to reflect the current collision object.
			// The list of available uv sets is updated, as well as the currently
			// selected uv set.  If the collision object is not a polymesh, the menu
			// will be hidden.
			//
			string $uvMenu = uvsControl( "replace", $nodeName, "collision", $collisionIndex, $uvSetName );
			int $polyCollider = uvsIsDynPoly( $nodeName, "collision", $collisionIndex );
			optionMenuGrp -e -m $polyCollider $uvMenu;
		}
		else
		{
			// create the uv set menu to allow users to select which uv set
			// to use on the collision object for providing collisionU/collisionV
			// values.
			//
			string $uvMenu = uvsControl( "create", $nodeName, "collision", $collisionIndex, $uvSetName );
			int $polyCollider = uvsIsDynPoly( $nodeName, "collision", $collisionIndex );
			optionMenuGrp -e -m $polyCollider $uvMenu;

			separator $sepName;
		}
	}

	for ($i = size($collisionNames); $i < $numSetsExisting; $i++)
	{
		$textFieldName = "collisonObject" + $i;
		$resSliderName = "resilience" + $i;
		$fricSliderName = "friction" + $i;
		$offsetSliderName = "offset" + $i;
		$uvSetName = "collisionUVSet" + $i;
		string $sepName = "collisionSeparator" + $i;

		if (`textFieldGrp -ex $textFieldName` )
		{
			deleteUI $textFieldName;
		}

		if (`attrFieldSliderGrp -ex $resSliderName` )
		{
			deleteUI $resSliderName;
		}

		if (`attrFieldSliderGrp -ex $fricSliderName` )
		{
			deleteUI $fricSliderName;
		}

		if( `attrFieldSliderGrp -ex $offsetSliderName` )
		{
			deleteUI $offsetSliderName;
		}
		
		if (`optionMenuGrp -ex $uvSetName`)
		{
			deleteUI $uvSetName;
		}
		
		if( `separator -ex $sepName` ) 
		{
			deleteUI $sepName;
		}
	}

	setParent ..;
	setUITemplate -ppt;
}

