// Copyright (C) 1997-2014 Autodesk, Inc., and/or its licensors.
// All rights reserved.
//
// The coded instructions, statements, computer programs, and/or related
// material (collectively the "Data") in these files contain unpublished
// information proprietary to Autodesk, Inc. ("Autodesk") and/or its licensors,
// which is protected by U.S. and Canadian federal copyright law and by
// international treaties.
//
// The Data is provided for use exclusively by You. You have the right to use,
// modify, and incorporate this Data into other products for purposes authorized 
// by the Autodesk software license agreement, without fee.
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND. AUTODESK
// DOES NOT MAKE AND HEREBY DISCLAIMS ANY EXPRESS OR IMPLIED WARRANTIES
// INCLUDING, BUT NOT LIMITED TO, THE WARRANTIES OF NON-INFRINGEMENT,
// MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE, OR ARISING FROM A COURSE 
// OF DEALING, USAGE, OR TRADE PRACTICE. IN NO EVENT WILL AUTODESK AND/OR ITS
// LICENSORS BE LIABLE FOR ANY LOST REVENUES, DATA, OR PROFITS, OR SPECIAL,
// DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES, EVEN IF AUTODESK AND/OR ITS
// LICENSORS HAS BEEN ADVISED OF THE POSSIBILITY OR PROBABILITY OF SUCH DAMAGES.

//
// Script:    AEcolorRemap.mel
//
// SYNOPSIS
//          Creates a color re-map node on a texture.
//

global proc AEcolorRemap( string $targetname)
{
    string $tmp;
	string $connection;

    // Should test that this also includes children of this compound attr. APP 18jun97
    string $compoundConnection[] = `listConnections -source false -destination true -plugs true $targetname`;
    int $numConnects = size($compoundConnection);

	// If the first node connected to is an RgbToHsv, we warn the user
	// that this node is probably already color remapped.
    if ($numConnects > 0) {
	    $connection = $compoundConnection[0];
		//print ("Checking if " + $connection + " is an rgbToHsv node.\n");
        $tmp = `nodeType $connection`;
		//print ("Nodetype is " + $tmp + "\n");
        if ($tmp == "rgbToHsv") {
			string $cancel = (uiRes("m_AEcolorRemap.kCancel"));
			$tmp = `confirmDialog -title (uiRes("m_AEcolorRemap.kOutColorRemapped"))
						  -message (uiRes("m_AEcolorRemap.kOutColorMessage"))
						  -button (uiRes("m_AEcolorRemap.kContinue")) -button $cancel -defaultButton $cancel
						  -cancelButton $cancel -dismissString $cancel`;
			//print ("confirmDialog returned " + $tmp + "\n");
			if ($tmp == $cancel) {
				return;
        	}
        }
    }

        
    // Create the rgb to hsv node so that we can transform the color to use ramp properly.
    $tmp = `shadingNode -asUtility rgbToHsv`;
    string $nameB = "RemapRgbToHsv#";
    $nameB = `rename $tmp $nameB`;

    // Create the ramp node which will remap the color based on the value of the textures' color.
    $tmp = `shadingNode -asTexture ramp`;
    string $nameC = "RemapRamp#";
    $nameC = `rename $tmp $nameC`;

    // Connect the newly created nodes to each other.
    connectAttr -force ($targetname) ($nameB + ".inRgb");
    connectAttr -force ($nameB + ".outHsvH")  ($nameC + ".uCoord");
    connectAttr -force ($nameB + ".outHsvV")  ($nameC + ".vCoord");

    // Now change the connections to be to the remap ramp rather than the texture.
	// print ("There are " + $numConnects + " connections to " + $targetname + "\n");
    for ( $connection in $compoundConnection ) {
		// print ("TRYING TO CONNECT " + $nameC + ".outColor" + " TO " + $connection + "\n");
		catch ( `connectAttr -force ($nameC + ".outColor") $connection` ) ;
    }
}
