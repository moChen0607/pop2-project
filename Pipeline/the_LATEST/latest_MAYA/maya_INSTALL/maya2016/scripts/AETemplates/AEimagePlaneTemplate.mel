// Copyright (C) 1997-2014 Autodesk, Inc., and/or its licensors.
// All rights reserved.
//
// The coded instructions, statements, computer programs, and/or related
// material (collectively the "Data") in these files contain unpublished
// information proprietary to Autodesk, Inc. ("Autodesk") and/or its licensors,
// which is protected by U.S. and Canadian federal copyright law and by
// international treaties.
//
// The Data is provided for use exclusively by You. You have the right to use,
// modify, and incorporate this Data into other products for purposes authorized 
// by the Autodesk software license agreement, without fee.
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND. AUTODESK
// DOES NOT MAKE AND HEREBY DISCLAIMS ANY EXPRESS OR IMPLIED WARRANTIES
// INCLUDING, BUT NOT LIMITED TO, THE WARRANTIES OF NON-INFRINGEMENT,
// MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE, OR ARISING FROM A COURSE 
// OF DEALING, USAGE, OR TRADE PRACTICE. IN NO EVENT WILL AUTODESK AND/OR ITS
// LICENSORS BE LIABLE FOR ANY LOST REVENUES, DATA, OR PROFITS, OR SPECIAL,
// DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES, EVEN IF AUTODESK AND/OR ITS
// LICENSORS HAS BEEN ADVISED OF THE POSSIBILITY OR PROBABILITY OF SUCH DAMAGES.

//
//  Procedure Name:
//	AEimagePlaneTemplate
//
//  Description Name;
//	Creates the attribute editor controls for the imagePlane Node
//
//  Input Value:
//	nodeName 
//
//  Output Value:
//	None
// 

// ADSK_CLR_MGT_BEGIN
    source "colorSpaceProcedures";
// ADSK_CLR_MGT_END

proc string getPlugNode( string $plug )
{
    string $buffer[];
    tokenize($plug, ".", $buffer);
    return size($buffer) > 0 ? $buffer[0] : "";
}

proc int isAttachedToCamera(string $attribute)
{
	string $imagePlane = getPlugNode($attribute);
	string $message = $imagePlane + ".message";
	string $list[] = `listConnections -shapes 1 $message`;
	int $result = 0;
	int $i;
	for($i = 0; $i < size($list); $i++)
	{
		if (`objectType -isa "camera" $list[$i]`)
		{
			$result = 1;
			break;
		}
	}
	return $result;
}

//
//  Procedure Name:
//	AEassignImageCB
//
global proc int AEassignDepthCB( string $fileAttribute, 
								 string $filename, 
								 string $fileType )
{
	setAttr $fileAttribute -type "string" $filename;

    string $currentDir = `workspace -q -dir`;
    retainWorkingDirectory ($currentDir);
	return true; 
}

global proc int AEassignImageCB( string $type,
                                 string $fileAttribute,
                                 string $filename,
                                 string $fileType )
{
	if ( `getAttr ($type)` == 1 ) {
		setAttr $type 0;
	}
	
	setAttr $fileAttribute -type "string" $filename;
	string $imgplane[];
	tokenize ($fileAttribute, ".", $imgplane);

	// Movie case is special
	
	string $fe;
	$fe = $imgplane[0] + ".frameExtension";
	if ( `getAttr ($type)` == 2 )
	{
	
		// Based on the code in createImportedMovieImagePlane()
		setAttr ( $imgplane[0] + ".useFrameExtension" ) 1;
		if ( `connectionInfo -isDestination $fe` == false ) {
			expression -s ($fe + "=frame" );
		}
	}
	else 
	{
		string $frameExtensionSource = `connectionInfo -sourceFromDestination $fe`;
		if ($frameExtensionSource != "") 
		{
			setAttr ( $imgplane[0] + ".useFrameExtension" ) 0;
			string $frameExtensionExpression[]; 
			tokenize $frameExtensionSource "." $frameExtensionExpression;
			delete $frameExtensionExpression[0] ;
			setAttr $fe 1;
		}
	}
	
	// The image need to be initialized
	// Initialize the image size according to image's aspect ratio
	int $mrRetain = `getAttr ($imgplane[0] + ".mr")`;
	int $pixmapSize[] = `imagePlane -q -imageSize $imgplane[0]`;
	
	// Consider if we do not load image successfully
	if ($pixmapSize[0]>0 && $pixmapSize[1]>0 )	
	{
		// set the mr on to change w/h by command
		setAttr ($imgplane[0] + ".mr") true;
		
		// [TODO] for now we only make the width/height respect image aspect ratio
		// Simply devide 100
		float $width = (float)$pixmapSize[0] /100;
		imagePlane -e -w $width $imgplane[0];
		
		// recover mr from the retained value
		setAttr ($imgplane[0] + ".mr") $mrRetain;
	}
	
	string $currentDir = `workspace -q -dir`;
	retainWorkingDirectory ($currentDir);

	return true;
}

//
//  Procedure Name:
//  AEimagePlaneBrowser
//

global proc AEimagePlaneBrowser( string $cmd, string $imgPlane )
{
    string  $workspace = `workspace -q -fn`;
    setWorkingDirectory $workspace "image" "sourceImages";
	string $open = (uiRes("m_AEimagePlaneTemplate.kOpen"));
	
    if ( `getAttr ($imgPlane + ".type")` == 0 ) {
		// image
		fileBrowser ($cmd, $open, "image", 0);
	} else if ( `getAttr ($imgPlane + ".type")` == 2 ) {
		// Movie
	    fileBrowser ($cmd, $open, "movie", 0);
	}
}

//
//  Procedure Name:
//	AEimagePlaneNameNew
//

global proc AEimagePlaneNameNew (string $type, string $fileAttribute)
{
	setUITemplate -pst attributeEditorTemplate;
	rowLayout -nc 3 textureNameLayout;
		text -label (uiRes("m_AEimagePlaneTemplate.kImageName")) ;
		textField textureNameField;
			symbolButton -image "navButtonBrowse.png" browser;
		setParent ..;
	setUITemplate -ppt;

    AEimagePlaneNameReplace $type $fileAttribute;
}

//
//  Procedure Name:
//	AEimagePlaneNameReplace
//

global proc AEimagePlaneNameReplace (string $type, string $fileAttribute)
{

    string $imgplane[];
    tokenize ($fileAttribute, ".", $imgplane);
	if(size($imgplane) < 1) return;

	connectControl -fileName textureNameField $fileAttribute;

    string $command = "AEassignImageCB "+$type+" "+$fileAttribute;

    button -e -c
		("AEimagePlaneBrowser \"" + $command + "\" " + $imgplane[0] ) browser;

}

//
//  Procedure Name:
//	AEimagePlaneDepthNameNew
//

global proc AEimagePlaneDepthNameNew (string $fileAttribute)
{
	setUITemplate -pst attributeEditorTemplate;
	rowLayout -nc 3 textureNameDepthLayout;
		text -label (uiRes("m_AEimagePlaneTemplate.kImageDepthName")) ;
		textField textureNameDepthField;
			symbolButton -image "navButtonBrowse.png" browser;
		setParent ..;
	setUITemplate -ppt;

    AEimagePlaneDepthNameReplace $fileAttribute;
}

//
//  Procedure Name:
//	AEimagePlaneDepthNameReplace
//

global proc AEimagePlaneDepthNameReplace (string $fileAttribute)
{
	string $buffer[];
	tokenize( $fileAttribute, ".", $buffer );
	if(size($buffer) < 1) return;

	connectControl -fileName textureNameDepthField $fileAttribute;
    string $command = "AEassignDepthCB "+$fileAttribute;
    button -e -c
		("AEimagePlaneBrowser \"" + $command + "\" " + $buffer[0] ) browser;

	int $dm = `getAttr ($buffer[0] + ".useDepthMap")` && 
		`getAttr ($buffer[0] + ".separateDepth")`; 
	rowLayout -e -enable $dm textureNameDepthLayout;
}

global proc	AEimagePlaneDepthDimControl(int $status) 
{ 
	//greys out the Depth File field if status is false
	//or enables it when status is true
	if ( `rowLayout -exists textureNameDepthLayout` ) { 
		rowLayout -e -enable $status textureNameDepthLayout; 
	}
}

//
//  Procedure Name:
//	AEsourceTextureNew
//

global proc AEsourceTextureNew( string $type, string $texture )
{
	setUITemplate -pst attributeEditorTemplate;
	global int $gTextColumnWidthIndex;
	global int $gAEMapButtonIndex;
	global int $gAESingleWidgetWidthIndex;

	// Define column sizes in relation to size of other widgets 
	// It would look nicer to have the second column be 
	// 3 * $gAESingleWidgetWidthIndex but this would make the 
	// whole Attribute Editor need to be wider so we sacrifice 
	// the look of this particular control for the greater good 

	int $col1Size = $gTextColumnWidthIndex;
	int $col2Size = ( (3 * $gAESingleWidgetWidthIndex) - $gAEMapButtonIndex);
	int $col3Size = $gAEMapButtonIndex;
	int $col4Size = $gAEMapButtonIndex;

	rowLayout -nc 4 -columnWidth4 $col1Size $col2Size $col3Size $col4Size;
        	text -label (uiRes("m_AEimagePlaneTemplate.kTexture"))  ;
        	textField textureField;
        	symbolButton -image "navButtonUnconnected.png" textureMapButton;
        	symbolButton -image "navButtonConnected.png"  texture2Button;
		setParent ..;
	setUITemplate -ppt;

    AEsourceTextureReplace $type $texture;
}

//
//  Procedure Name:
//	AEsourceTextureReplace
//

global proc AEsourceTextureReplace( string $type, string $texture )
{
    string $value = "";
	string $connections[] = `listConnections $texture`;
    if (size($connections) > 0) $value = $connections[0];

	setUITemplate -pst attributeEditorTemplate;
    textField -e -cc
        ("{ string $c[] = `listConnections -plugs true -source true "+$texture+"`;"+
         "if (size($c) > 0) disconnectAttr $c[0] "+$texture+";"+
         "if (\"#1\" != \"\") defaultNavigation -connectToExisting -source #1.outColor -destination "+$texture+"; }")
        -text $value
        textureField;

    string $command = "defaultNavigation -connectToExisting -force true -source %node -destination "+$texture;

	button -e -c
        ("setAttr "+$type+" 1;"+
         "createRenderNode -allWithTexturesUp \""+$command+"\" \"\"")
        textureMapButton;

	button -e -c
        ("{ string $c[] = `listConnections "+$texture+"`; "+
         "if (size($c) > 0) showEditor $c[0]; }")
        texture2Button;

	setUITemplate -ppt;
}

//
//  Procedure Name:
//	AEchangeLookThroughCamera
//
global proc AEchangeLookThroughCamera( string $imgPlane )
{	
	string $lookThruCam = `optionMenu -query -value AELookThroughCameraMenu`;
	imagePlane -edit -lookThrough $lookThruCam $imgPlane;
}

//
//  Procedure Name:
//	AEdisplayCurrentNew
//

global proc AEdisplayCurrentNew( string $displayOnlyIfCurrent )
{
	string $imgPlane[];
	tokenize( $displayOnlyIfCurrent, ".", $imgPlane );
									
	// Initialize all the items
	string $allCameras[] = `listCameras`;
	string $currentCamera[] = `imagePlane -q -lookThrough $imgPlane[0]`;
	
	setUITemplate -pst attributeEditorTemplate;
	
	columnLayout;
	string $collection = `radioButtonGrp -numberOfRadioButtons 1 
								-label (uiRes("m_AEimagePlaneTemplate.kDisplay"))  
								-label1 (uiRes("m_AEimagePlaneTemplate.kLookingthroughcamera"))  displayOnlyIfCurrent`;
								
	optionMenu  -label "" -parent displayOnlyIfCurrent AELookThroughCameraMenu;
		
	radioButtonGrp -numberOfRadioButtons 1 
								-label1 (uiRes("m_AEimagePlaneTemplate.kInallviews"))  
								-shareCollection $collection displayOnlyIfCurrent1;

	for ($i = 0; $i < size($allCameras); $i++)
	{
		menuItem -label $allCameras[$i] ("AELookThroughCameraItem" + $i);	
	}
	
	setUITemplate -ppt;

    AEdisplayCurrentReplace $displayOnlyIfCurrent;
}

//
//  Procedure Name:
//	AEdisplayCurrentReplace
//

global proc AEdisplayCurrentReplace( string $displayOnlyIfCurrent )
{
	string $imgPlane[];
	tokenize( $displayOnlyIfCurrent, ".", $imgPlane );

    int $allViews = !`getAttr $displayOnlyIfCurrent`;
		
	// Set up all the cameras 
	int $i, $j;
	string $allCameras[] = listCameras();
	string $currentCamera[0] = `imagePlane -q -lookThrough $imgPlane[0]`;

	setUITemplate -pst attributeEditorTemplate;

    radioButtonGrp -e
        -onCommand1 ("setAttr "+$displayOnlyIfCurrent+" on;" +
								"optionMenu -edit -enable true AELookThroughCameraMenu;" +
								"AEchangeLookThroughCamera " + $imgPlane[0])
        displayOnlyIfCurrent;
    radioButtonGrp -e
        -onCommand1 ("setAttr "+$displayOnlyIfCurrent+" off;" +
								"optionMenu -edit -enable false AELookThroughCameraMenu;")
        displayOnlyIfCurrent1;

	if ($allViews == 0) {
	    radioButtonGrp -e -select 1 displayOnlyIfCurrent;
		optionMenu -edit -enable true AELookThroughCameraMenu;
	} else {
	    radioButtonGrp -e -select 1 displayOnlyIfCurrent1;
		optionMenu -edit -enable false AELookThroughCameraMenu;
	}
	
	setParent -menu AELookThroughCameraMenu;
	
	int $isCameraExists = 0;

	for ($i = 0; $i < size($allCameras); $i++)
	{
		if (`menuItem -exists ("AELookThroughCameraItem" + $j)`)
			menuItem -edit -label $allCameras[$i] ("AELookThroughCameraItem" + $j);
		else 
			menuItem -label $allCameras[$i] ("AELookThroughCameraItem" + $j);
		$j++;
		
		if ($currentCamera[0] == $allCameras[$i]) 
		{
			optionMenu -edit -select ($j) AELookThroughCameraMenu;
			$isCameraExists = 1;
		}
		
	}
		
	while (`menuItem -exists ("AELookThroughCameraItem" + $j)`)
	{			
		deleteUI ("AELookThroughCameraItem" + $j);
		$j++;
	}
	
	// if the look through camera is deleted trigger the display in all view button
	if ( $isCameraExists == 0 )
	{
		radioButtonGrp -e -select 1 displayOnlyIfCurrent1;
		optionMenu -edit -enable false AELookThroughCameraMenu;
	}
	
	setParent -menu ..;
	
	int $isAttached = `isAttachedToCamera($displayOnlyIfCurrent)`;
	if ($isAttached == 0)
		optionMenu -edit -visible true AELookThroughCameraMenu;
	else
		optionMenu -edit -visible false AELookThroughCameraMenu;
		
	setUITemplate -ppt;
	
	optionMenu -e -changeCommand ("AEchangeLookThroughCamera " + $imgPlane[0]) AELookThroughCameraMenu;
}

global proc updateLockedPositionControls(string $lockedToCamera)
{
	string $imagePlaneName[];
	$numTokens = tokenize($lockedToCamera, ".", $imagePlaneName );

	if(!`objExists $imagePlaneName[0]`){
		return ;
	}

	int $isLockedToCamera = `getAttr $lockedToCamera`;

	if ($isLockedToCamera) {
		// update the UI
		radioButtonGrp -e -select 1 lockedToCamera;
	} else {
		// update the UI
		radioButtonGrp -e -select 2 lockedToCamera;
	}
	
	AEimagePlaneWantDepthCallback $imagePlaneName[0];
	
	editorTemplate -dimControl $imagePlaneName[0] "fit" (!$isLockedToCamera);
	editorTemplate -dimControl $imagePlaneName[0] "size" (!$isLockedToCamera);
	editorTemplate -dimControl $imagePlaneName[0] "offset" (!$isLockedToCamera);
	editorTemplate -dimControl $imagePlaneName[0] "imageCenter" $isLockedToCamera;
	editorTemplate -dimControl $imagePlaneName[0] "width" $isLockedToCamera;
	editorTemplate -dimControl $imagePlaneName[0] "height" $isLockedToCamera;
	
	checkBoxGrp -e -enable (!$isLockedToCamera) maintainImageAspectRatio;
}

//
//  Procedure Name:
//  checkImageShadingSamplesOverride
//
//

global proc checkImageShadingSamplesOverride ( string $nodeName ) 
{
    // Note: volume needs this attribute also!!
    string $nodeAttr = $nodeName + ".shadingSamplesOverride";
    int $value = `getAttr $nodeAttr`;
    if ( $value == 1 ) {
        editorTemplate -dimControl $nodeName "shadingSamples" false;
        editorTemplate -dimControl $nodeName "maxShadingSamples" false;
    } else {
        editorTemplate -dimControl $nodeName "shadingSamples" true;
        editorTemplate -dimControl $nodeName "maxShadingSamples" true;
    } 
}

//
//  Procedure Name:
//  AEfitGate
//

global proc AEfitGate ( string $sizeX, string $sizeY )
{
    setUITemplate -pst attributeEditorTemplate;

    rowLayout -nc 2;
    text -l "";
    button -label (uiRes("m_AEimagePlaneTemplate.kFittoResolutionGate")) 
           -c ("AEinvokeFitRezGate "+ $sizeX + " " + $sizeY) fitRezButton;
    setParent ..;

    rowLayout -nc 2;
    text -l "";
    button -label (uiRes("m_AEimagePlaneTemplate.kFittoFilmGate")) 
           -c ("AEinvokeFitFilmGate "+ $sizeX + " " + $sizeY) fitFilmButton;
    setParent ..;

    setUITemplate -ppt;
}

//
//  Procedure Name:
//  AErepFitGate
//

global proc AErepFitGate ( string $sizeX, string $sizeY )
{
	button -e -c ("AEinvokeFitRezGate "+ $sizeX + " " + $sizeY) fitRezButton;
	button -e -c ("AEinvokeFitFilmGate "+ $sizeX + " " + $sizeY) fitFilmButton;

	button -e -enable `isAttachedToCamera($sizeX)` fitRezButton; 
	button -e -enable `isAttachedToCamera($sizeX)` fitFilmButton; 
}

//
//	Procedure Name:
//	AEinvokeFitFilmGate
//

global proc AEinvokeFitFilmGate ( string $sizeX, string $sizeY )
{
    // Get imageplane name
    string $imgplane[];
    tokenize ($sizeX, ".", $imgplane);

    // Get camera info
    string $camera[] = `listConnections ($imgplane[0] + ".message")`;
	int $i, $j;
	for ($i = 0; $i < size($camera); $i++) {
		if (`objectType -isa "camera" $camera[$i]`) break;
		string $shapes[] = `listRelatives -shapes ($camera[$i])`;
		for ($j = 0; $j < size($shapes); $j++) 
			if (`objectType -isa "camera" $shapes[$j]`) break;
		if ($j != size($shapes)) break;
	}
    if ($i == size ($camera)) return;
    float $camX = `getAttr ($camera[$i] + ".horizontalFilmAperture")`;
    float $camY = `getAttr ($camera[$i] + ".verticalFilmAperture")`;

	// Set the image plane + camera sizes to be the same.
	setAttr $sizeX $camX;
	setAttr $sizeY $camY;
}

//
//  Procedure Name:
//  AEinvokeFitRezGate
//

global proc AEinvokeFitRezGate ( string $sizeX, string $sizeY )
{
	// Get resolution info
	string $globals[] = `ls -renderGlobals`;
	string $rez[] = `listConnections ($globals[0] + ".resolution")`;
	float $rezAspect = `getAttr ($rez[0] + ".deviceAspectRatio")`;

	// Get imageplane name
	string $imgplane[];
	tokenize ($sizeX, ".", $imgplane);

	// Get camera info
	string $camera[] = `listConnections ($imgplane[0] + ".message")`;
    int $i, $j;
    for ($i = 0; $i < size($camera); $i++) {
        if (`objectType -isa "camera" $camera[$i]`) break;
        string $shapes[] = `listRelatives -shapes ($camera[$i])`;
        for ($j = 0; $j < size($shapes); $j++) 
            if (`objectType -isa "camera" $shapes[$j]`) break;
        if ($j != size($shapes)) break;
    }
    if ($i == size ($camera)) return;
	float $camX = `getAttr ($camera[$i] + ".horizontalFilmAperture")`;
	float $camY = `getAttr ($camera[$i] + ".verticalFilmAperture")`;
	int $fitType = `getAttr ($camera[$i] + ".filmFit")`;

	// Based on camera + resolution info, provide best fit.
	if ($fitType == 0) {		// FILL
		float $camAspect = $camX / $camY;
		if ($rezAspect < $camAspect) {
			setAttr $sizeY $camY;
			setAttr $sizeX ($camY * $rezAspect);
		} else {
			setAttr $sizeX $camX;
			setAttr $sizeY ($camX / $rezAspect);
		}
	} else if ($fitType == 1) { // HORIZONTAL
		setAttr $sizeX $camX;
		setAttr $sizeY ($camX / $rezAspect);
	} else if ($fitType == 2) { // VERTICAL
		setAttr $sizeY $camY;
		setAttr $sizeX ($camY * $rezAspect);
    } else if ($fitType == 3) { // OVERSCAN
		float $camAspect = $camX / $camY;
		if ($rezAspect < $camAspect) {
			setAttr $sizeX $camX;
			setAttr $sizeY ($camX / $rezAspect);
		} else {
			setAttr $sizeX ($camY * $rezAspect);
			setAttr $sizeY $camY;
		}
    }
}

//  Procedure Name:
//  changeImageSize
global proc changeImageSize( string $maintainRatio, string $value1,
                                                     string $value2, int $invert )
{  
	if (`getAttr $maintainRatio` == 0)
		return;
	string $imgPlane[];
	tokenize( $value1, ".", $imgPlane );
	float $imageValue1 = `getAttr $value1`;
	float $imageValue2 = `getAttr $value2`;

	int $imageSize[2] = `imagePlane -q -imageSize $imgPlane[0]`;

	if ( $imageSize[0]==0 || $imageSize[1]==0 ||  $imageValue1==0 || $imageValue2==0 )
		return;
		
	// aspect1 is from the geometry size from the original image
	// aspect2 is from the image plane's size  
	// in this situation we want to make them with the same aspect, respecting the original image size
	float $aspect1, $aspect2;
	if ( $invert == 0 )
	{
		$aspect1 = (float) $imageSize[0] / $imageSize[1];
		$aspect2 = $imageValue1 / $imageValue2;
	}
	else
	{
		$aspect1 = (float) $imageSize[1] / $imageSize[0];
		$aspect2 = $imageValue2 / $imageValue1;
	}
	
	if ( abs($aspect1-$aspect2)<1e-6 )
		return;
	else 
	{
		$imageValue2 = $imageValue1 * $aspect1;
		setAttr $value2 $imageValue2;
	}
}

//
//  Procedure Name:
//	AEmaintainImageAspectRatioNew
//
global proc AEmaintainImageAspectRatioNew( string $maintainRatio, string $width, 
														string $height ) 
{
	setUITemplate -pst attributeEditorTemplate;

	checkBoxGrp
        -label (uiRes("m_AEimagePlaneTemplate.kMaintainPicAspectRatio"))
		-numberOfCheckBoxes 1
        maintainImageAspectRatio;
		
	setUITemplate -ppt;
	
	AEmaintainImageAspectRatioEdit($maintainRatio, $width, $height );
}

//
//  Procedure Name:
//	AEmaintainImageAspectRatioEdit
//
global proc AEmaintainImageAspectRatioEdit( string $maintainRatio, string $width, 
														string $height ) {

	int $maintainRatioValue = `getAttr $maintainRatio`;

    checkBoxGrp -e
        -value1 $maintainRatioValue
        -changeCommand ("setAttr "+$maintainRatio+" #1")
		maintainImageAspectRatio;
	
	 scriptJob -parent maintainImageAspectRatio -force -replacePrevious
        -compressUndo true 
		-attributeChange $width ("changeImageSize " + $maintainRatio + " " + $width + " " + $height + " " + "1" );
	 
	 scriptJob -parent maintainImageAspectRatio
        -compressUndo true 
		-attributeChange $height ("changeImageSize " + $maintainRatio + " " + $height + " " + $width + " " + "0" );
		
}

//
//  Procedure Name:
//	AEimagePlaneFitUpdateCallback
//
global proc AEimagePlaneFitUpdateCallback( string $imgPlane )
{
    string	$nodeAttr = ($imgPlane + ".fit");
	int		$fitValue = `getAttr $nodeAttr`;
	int		$isToSize = ($fitValue != 4);	//kFitToSize


	// The "Squeeze Correction" only makes sense whent the image plane is
	// using the "To Size" fit algorithm. BUG 107886

	editorTemplate -dimControl $imgPlane "squeezeCorrection" ($isToSize);
}

global proc AEimagePlaneSeparateDepthCallback( string $imgPlane )
{
	AEimagePlaneDepthDimControl (`getAttr ($imgPlane + ".useDepthMap")` && `getAttr ($imgPlane + ".separateDepth")` && `getAttr( $imgPlane +".lockedToCamera")`);
}

global proc AEimagePlaneWantDepthCallback( string $imgPlane )
{
	string $nodeAttr = ($imgPlane + ".useDepthMap"); 
	int    $dm  = `getAttr $nodeAttr`;
	int    $sd  = `getAttr ($imgPlane + ".separateDepth")` && $dm; 
	int    $dmI = !($dm); 

	int $isFixed = !`getAttr ($imgPlane + ".lockedToCamera")`;
	if($isFixed)
	{	
		$dm = true;
		$sd = false;
		$dmI = true;
	}

	editorTemplate -dimControl $imgPlane "depth" $dm;
	editorTemplate -dimControl $imgPlane "rotate" $dm;

	editorTemplate -dimControl $imgPlane "useDepthMap" $isFixed;

	editorTemplate -dimControl $imgPlane "compositeDepth" $dmI; 
	editorTemplate -dimControl $imgPlane "separateDepth" $dmI;
	AEimagePlaneDepthDimControl $sd;
	editorTemplate -dimControl $imgPlane "depthOversample" $dmI;
	editorTemplate -dimControl $imgPlane "depthBias" $dmI;
	editorTemplate -dimControl $imgPlane "depthScale" $dmI;
}

//
//  Procedure Name:
//	AEimagePlaneViewUpdateCallback
//
global proc AEimagePlaneViewUpdateCallback( string $imgPlane )
{

    // if the image plane is an image file dim out the sourceTexture
    // controls and undim the image file controls
    
    if ( `getAttr ($imgPlane + ".type")` == 0 ) {
        // Image plane is using a image type

        editorTemplate -dimControl $imgPlane "sourceTexture" true;
        editorTemplate -dimControl $imgPlane "imageName" false;
        editorTemplate -dimControl $imgPlane "useFrameExtension" false;
		editorTemplate -dimControl $imgPlane "frameOffset" false;
		editorTemplate -dimControl $imgPlane "frameIn" true;
		editorTemplate -dimControl $imgPlane "frameOut" true;
		editorTemplate -dimControl $imgPlane "textureFilter" false;
		
        // Depending on whether use frame extension is on or off, we
        // dim the frame extension control.

        checkUseFrameExtension($imgPlane);
    }
    else if ( `getAttr ($imgPlane + ".type")` == 2 ) {
        // Image plane is using a movie

        editorTemplate -dimControl $imgPlane "sourceTexture" true;
        editorTemplate -dimControl $imgPlane "imageName" false;
        editorTemplate -dimControl $imgPlane "useFrameExtension" true;		// this isn't an option
		editorTemplate -dimControl $imgPlane "frameCache" true; 
		editorTemplate -dimControl $imgPlane "frameOffset" false;
		editorTemplate -dimControl $imgPlane "frameIn" false;
		editorTemplate -dimControl $imgPlane "frameOut" false;
		editorTemplate -dimControl $imgPlane "frameExtension" false;
		editorTemplate -dimControl $imgPlane "textureFilter" false;
		
		checkMaintainRatio($imgPlane);
		
    }
    else {
        // Image plane is a texture

        editorTemplate -dimControl $imgPlane "sourceTexture" false;

        editorTemplate -dimControl $imgPlane "imageName" true;
        editorTemplate -dimControl $imgPlane "useFrameExtension" true;
        editorTemplate -dimControl $imgPlane "frameExtension" true;
		editorTemplate -dimControl $imgPlane "frameCache" true;
		editorTemplate -dimControl $imgPlane "frameOffset" true; 
		editorTemplate -dimControl $imgPlane "frameIn" true;
		editorTemplate -dimControl $imgPlane "frameOut" true;
		editorTemplate -dimControl $imgPlane "textureFilter" true;
	}   
}

//
//  Procedure Name:
//	checkMaintainRatio
//
global proc checkMaintainRatio( string $imgplane )
{
	// The image need to be initialized
	// Initialize the image size according to image's aspect ratio
	int $mrRetain = `getAttr ($imgplane + ".mr")`;
	int $pixmapSize[] = `imagePlane -q -imageSize $imgplane`;
	
	// Consider if we do not load image successfully
	if ($pixmapSize[0]>0 && $pixmapSize[1]>0 && $mrRetain)	
	{
		float $aspect1 = (float)$pixmapSize[0]/$pixmapSize[1];
		float $width = `getAttr ($imgplane + ".width")`;
		float $height = `getAttr ($imgplane + ".height")`;
		if ($width<1e-6 || $height<1e-6)
			return;
		float $aspect2 = (float)$width/$height;
		
		if (abs($aspect1-$aspect2) < 1e-6)
			return;
		
		// Initialize
		// [TODO] for now we only make the width/height respect image aspect ratio
		// Simply devide 100
		$width = (float)$pixmapSize[0] /100;
		setAttr ($imgplane + ".width") $width;

		
	}
}

//
//  Procedure Name:
//	AEimagePlaneTemplate
//
global proc AEimagePlaneTemplate ( string $nodeName )
{
	AEswatchDisplay $nodeName;
	editorTemplate -beginScrollLayout;
		editorTemplate -beginLayout (uiRes("m_AEimagePlaneTemplate.kImagePlaneAttributes"))  -collapse 0;
			editorTemplate -callCustom "AEdisplayCurrentNew" 
					"AEdisplayCurrentReplace" 
					"displayOnlyIfCurrent";

			editorTemplate -addControl "displayMode" "AEimagePlaneViewUpdateCallback";

			editorTemplate -addControl "colorGain";
			editorTemplate -addControl "colorOffset";
			editorTemplate -addControl "alphaGain";			
			editorTemplate -addSeparator;
            
			editorTemplate -addControl "type" "AEimagePlaneViewUpdateCallback";

			editorTemplate -addControl "textureFilter" ;

			editorTemplate -callCustom "AEimagePlaneNameNew" "AEimagePlaneNameReplace"
        			"type" 	"imageName";
			editorTemplate -label (uiRes("m_AEimagePlaneTemplate.kUseImageSequence"))  -addControl "useFrameExtension" "checkUseFrameExtension";
			editorTemplate -label (uiRes("m_AEimagePlaneTemplate.kImageNumber"))  -addControl "frameExtension";
			editorTemplate -addControl "frameOffset";
			editorTemplate -addControl "frameIn";
			editorTemplate -addControl "frameOut";
									
			editorTemplate -addControl "frameCache"; 
			editorTemplate -callCustom "AEsourceTextureNew" "AEsourceTextureReplace" 
					"type" 
					"sourceTexture";

			// ADSK_CLR_MGT_BEGIN
			editorTemplate -ccu "AEcolorSpaceNew" "AEcolorSpaceReplace" "colorSpace";
			editorTemplate -addControl "ignoreColorSpaceFileRules";
			// ADSK_CLR_MGT_END



		editorTemplate -endLayout;

		editorTemplate -beginLayout (uiRes("m_AEimagePlaneTemplate.kPlacement"))  -collapse 0;
			editorTemplate -addControl "fit" "AEimagePlaneFitUpdateCallback";
			editorTemplate -callCustom "AEfitGate" "AErepFitGate" "sizeX" "sizeY";
			editorTemplate -addControl "size";
			editorTemplate -addControl "squeezeCorrection";
			editorTemplate -addControl "offset";
			editorTemplate -addControl "depth";
			editorTemplate -addControl "rotate"; 
		editorTemplate -endLayout;

		editorTemplate -beginLayout (uiRes("m_AEimagePlaneTemplate.kPlacementExtras"))  -collapse 0;
			editorTemplate -addControl "coverageX";
			editorTemplate -addControl "coverageY";
			editorTemplate -addControl "coverageOriginX";
			editorTemplate -addControl "coverageOriginY";
			editorTemplate -addSeparator;
			editorTemplate -addControl "imageCenter";
			editorTemplate -addControl "width";
			editorTemplate -addControl "height";
			editorTemplate -callCustom "AEmaintainImageAspectRatioNew" "AEmaintainImageAspectRatioEdit" "maintainRatio" "width" "height" ;
		editorTemplate -endLayout;

        editorTemplate -beginLayout (uiRes("m_AEimagePlaneTemplate.kRenderStats")) ;
			editorTemplate -beginNoOptimize;
			editorTemplate -addControl "alreadyPremult";
            editorTemplate -addControl "shadingSamplesOverride" "checkImageShadingSamplesOverride";
            editorTemplate -endNoOptimize;
            editorTemplate -addControl "shadingSamples";
            editorTemplate -addControl "maxShadingSamples";
			editorTemplate -addSeparator;
			editorTemplate -beginNoOptimize;
            editorTemplate -addControl "visibleInReflections";
            editorTemplate -addControl "visibleInRefractions";
			editorTemplate -endNoOptimize;
        editorTemplate -endLayout;

		editorTemplate -beginLayout (uiRes("m_AEimagePlaneTemplate.kDepthLabel")) ; 
			editorTemplate -addControl "useDepthMap" "AEimagePlaneWantDepthCallback";
			editorTemplate -addControl "compositeDepth"; 
			editorTemplate -addControl "separateDepth" "AEimagePlaneSeparateDepthCallback";
			editorTemplate -callCustom "AEimagePlaneDepthNameNew" "AEimagePlaneDepthNameReplace"
				"depthFile";
			editorTemplate -addControl "depthOversample";
			editorTemplate -addControl "depthBias"; 
			editorTemplate -addControl "depthScale";
		editorTemplate -endLayout; 


		// include/call base class/node attributes
		AEshapeTemplate $nodeName;

		// suppressed attribute
		editorTemplate -suppress "coverage";
		editorTemplate -suppress "coverageOrigin";

	// set up the dim switches
	AEimagePlaneViewUpdateCallback($nodeName );

	editorTemplate -addExtraControls;
	editorTemplate -endScrollLayout;
}
