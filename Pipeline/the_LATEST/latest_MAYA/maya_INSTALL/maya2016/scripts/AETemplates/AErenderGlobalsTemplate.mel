// Copyright (C) 1997-2014 Autodesk, Inc., and/or its licensors.
// All rights reserved.
//
// The coded instructions, statements, computer programs, and/or related
// material (collectively the "Data") in these files contain unpublished
// information proprietary to Autodesk, Inc. ("Autodesk") and/or its licensors,
// which is protected by U.S. and Canadian federal copyright law and by
// international treaties.
//
// The Data is provided for use exclusively by You. You have the right to use,
// modify, and incorporate this Data into other products for purposes authorized 
// by the Autodesk software license agreement, without fee.
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND. AUTODESK
// DOES NOT MAKE AND HEREBY DISCLAIMS ANY EXPRESS OR IMPLIED WARRANTIES
// INCLUDING, BUT NOT LIMITED TO, THE WARRANTIES OF NON-INFRINGEMENT,
// MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE, OR ARISING FROM A COURSE 
// OF DEALING, USAGE, OR TRADE PRACTICE. IN NO EVENT WILL AUTODESK AND/OR ITS
// LICENSORS BE LIABLE FOR ANY LOST REVENUES, DATA, OR PROFITS, OR SPECIAL,
// DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES, EVEN IF AUTODESK AND/OR ITS
// LICENSORS HAS BEEN ADVISED OF THE POSSIBILITY OR PROBABILITY OF SUCH DAMAGES.

//
//  Procedure Name:
//	AErenderGlobalsTemplate
//
//  Description:
//	Creates the attribute editor controls for the renderGlobalsNode
//
//  Input Value:
//	nodeName
//
//  Output Value:
//	None
//


///////////////////////////////////
// custom Layout for Renderable Cameras list
///////////////////////////////////

//
//  Procedure Name:
//	AEcameraListNew
//
//

global proc AEcameraListNew ()
{
	setUITemplate -pst attributeEditorPresetsTemplate;
	rowLayout -nc 5;
		text -label "";
		text -label (uiRes("m_AErenderGlobalsTemplate.kRenderable"));
		text -label (uiRes("m_AErenderGlobalsTemplate.kImage"));
		text -label (uiRes("m_AErenderGlobalsTemplate.kMask"));
		text -label (uiRes("m_AErenderGlobalsTemplate.kDepth"));
	setParent ..;

	string $allCameras[] = `ls -ca`;
	string $parents[];
	string $outputName;
	int    $i;

	for ($i = 0; $i < size($allCameras); $i++) {
		$parents = `listRelatives -p $allCameras[$i]`;
		$outputName = `getAttr ($allCameras[$i] + ".imageName")`;
		setUITemplate -pst attributeEditorTemplate;
		checkBoxGrp -ncb 4 
			-label ($parents[0] + " [" + $outputName + "]")
			-l1 "" -l2 "" -l3 "" -l4 ""
			("AEcameraAE" + $i);
		connectControl -in 2 ("AEcameraAE" + $i) ($allCameras[$i] + ".renderable");
		connectControl -in 3 ("AEcameraAE" + $i) ($allCameras[$i] + ".image");
		connectControl -in 4 ("AEcameraAE" + $i) ($allCameras[$i] + ".mask");
		connectControl -in 5 ("AEcameraAE" + $i) ($allCameras[$i] + ".depth");
		setUITemplate -ppt;
	}
	setUITemplate -ppt;
}

//
//  Procedure Name:
//	AEcameraListReplace
//
//

global proc AEcameraListReplace()
{
	setUITemplate -pst attributeEditorTemplate;
	string $allCameras[] = `ls -ca`;
	string $parents[];
	string $outputName;
	int    $i;

	for ($i = 0; $i < size($allCameras); $i++) {
		$parents = `listRelatives -p $allCameras[$i]`;
		$outputName = `getAttr ($allCameras[$i] + ".imageName")`;
		if (`checkBoxGrp -exists ("AEcameraAE"+$i)`) {
			setUITemplate -pst attributeEditorTemplate;
			checkBoxGrp -e
				-label ($parents[0] + " [" + $outputName + "]")
				-l1 "" -l2 "" -l3 "" -l4 ""
				("AEcameraAE" + $i);
			connectControl -in 2 ("AEcameraAE" + $i) ($allCameras[$i] + ".renderable");
			connectControl -in 3 ("AEcameraAE" + $i) ($allCameras[$i] + ".image");
			connectControl -in 4 ("AEcameraAE" + $i) ($allCameras[$i] + ".mask");
			connectControl -in 5 ("AEcameraAE" + $i) ($allCameras[$i] + ".depth");
			setUITemplate -ppt;
		} else {
			setUITemplate -pst attributeEditorTemplate;
			checkBoxGrp -ncb 4 
				-label ($parents[0] + " [" + $outputName + "]")
				-l1 "" -l2 "" -l3 "" -l4 ""
				("AEcameraAE" + $i);
			connectControl -in 2 ("AEcameraAE" + $i) ($allCameras[$i] + ".renderable");
			connectControl -in 3 ("AEcameraAE" + $i) ($allCameras[$i] + ".image");
			connectControl -in 4 ("AEcameraAE" + $i) ($allCameras[$i] + ".mask");
			connectControl -in 5 ("AEcameraAE" + $i) ($allCameras[$i] + ".depth");
			setUITemplate -ppt;
		}
	}

	// delete any unused checkBoxGrps
	//
	while (`checkBoxGrp -exists ("AEcameraAE"+$i)`) {
		deleteUI ("AEcameraAE"+$i);
		$i++;
	}

}

////////////////////////////////////////////////////
// custom Layout for the render quality attribute
////////////////////////////////////////////////////

global string $gAErenderGlobalsQualityLUT[];

proc string getCurrentRenderQualityMenu()
{
	global string $gAErenderGlobalsQualityLUT[];

	// look for the correct parent
	//
	string $curParent = `setParent -q`;
	int	$index = -1;
	int $i;
	for ($i = 0; $i < size($gAErenderGlobalsQualityLUT); $i += 2 ) {
		if ( $curParent == $gAErenderGlobalsQualityLUT[$i] ) {
			$index = $i+1;
			break;
		}
	}
	string $menu = "renderQualityMenu";
	if ($index != -1) {
		$menu = $gAErenderGlobalsQualityLUT[$index];
	}
	return $menu;
}

//
//  Procedure Name:
//	AEnewRenderQuality
//
//

global proc AEnewRenderQuality ( string $quality )
{
	string $node = `renderQualityNode`;
	connectAttr -f ($node + ".message") $quality;
	showEditor $node;
}

//
//  Procedure Name:
//	AErenderQualityNew
//
//

global proc AErenderQualityNew (string $quality)
{
	global string $gAErenderGlobalsQualityLUT[];

	string $buffer[];
	tokenize($quality,".",$buffer);
	string $nodeName = $buffer[0];

	setUITemplate -pst attributeEditorTemplate;
	string $connect[] = `listConnections $quality`;
	string $allQual[] = `ls -rq`;
	int $i;

	$numUI = size($gAErenderGlobalsQualityLUT);
	$gAErenderGlobalsQualityLUT[$numUI] = `setParent -q`;

	rowLayout -nc 3 renderQualityLayout;
		text -label (uiRes("m_AErenderGlobalsTemplate.kRenderQuality")) renderGlobalsText;
		string $menu = `optionMenu -label "" renderQualityMenu`;
		optionMenu -e
			-cc ("AEeditRenderQuality "+$menu+" "+$quality)
			renderQualityMenu;
			for ($i = 0; $i < size($allQual); $i++)
			{
				menuItem -label $allQual[$i] ("renderQualityAE" + $i);
				if ($connect[0] == $allQual[$i])
					optionMenu -e -sl ($i+1) $menu;
			};
		setParent -m ..;
		button -label (uiRes("m_AErenderGlobalsTemplate.kNew"))
			-c ("AEnewRenderQuality " + $quality)
			newRenderQualityButton;
	setParent ..;
	scriptJob
		-p $menu -rp
		-ac $quality ("AErenderQualityMenuUpdate "+$menu+" "+$nodeName);
	setUITemplate -ppt;
	$gAErenderGlobalsQualityLUT[$numUI+1] = $menu;
}

//
//  Procedure Name:
//	AErenderQualityReplace
//
//

global proc AErenderQualityReplace (string $quality)
{

	// get the nodeName
	//
	string $buffer[];
	tokenize($quality,".",$buffer);
	string $nodeName = $buffer[0];

	// get parent
	//
	string $menu = getCurrentRenderQualityMenu();

	// update the option menu
	//
	AErenderQualityMenuUpdate($menu,$nodeName);

	// update the scriptJob
	//
	scriptJob
		-p $menu -rp
		-ac $quality ("AErenderQualityMenuUpdate "+$menu+" "+$nodeName);
}

//
//  Procedure Name:
//	AErenderQualityUpdate
//
//

global proc AErenderQualityMenuUpdate (string $menu, string $nodeName)
{
    string $connect[] = `listConnections ($nodeName+".quality")`;
    string $allQual[] = `ls -rq`;
	int $numQualities = size ($allQual);

	setParent -m $menu;

	// relabel menuItems that already exist
	//
	int $numOptions = `optionMenu -q -ni $menu`;
	string $optionMenuItems[] = `optionMenu -q -ill $menu`;
	int $i = 0;
	while ( $i < $numOptions && $i < $numQualities ) {
        menuItem -e -label $allQual[$i] $optionMenuItems[$i];
        if ($connect[0] == $allQual[$i])
        	optionMenu -e -sl ($i+1) $menu;
		$i++;
	}

	// if we've run out of menu items and need more, create
	// them now, else, delete any excess menuItems
	//
	if ( $numOptions < $numQualities ) {
		for ( $i = $numOptions; $i < $numQualities; $i++ ) {
        	menuItem -l $allQual[$i] ("renderQualityAE" + $i);
        	if ($connect[0] == $allQual[$i])
        		optionMenu -e -sl ($i+1) $menu;
		}
	} else if ( $numOptions > $numQualities ) {
		for ( $i = $numQualities; $i < $numOptions; $i++ ) {
        	if (`menuItem -exists $optionMenuItems[$i]`)
				deleteUI $optionMenuItems[$i];
		}
	}

	setParent -m ..;
}

//
//  Procedure Name:
//	AEeditRenderQuality
//
//

global proc AEeditRenderQuality ( string $menu, string $quality )
{
	string $globals[] = `ls -renderGlobals`;
	string $currMenu = `optionMenu -q -v $menu`;
	string $currentConnection[] = `listConnections -p true $quality`;
	string $curr = ($currMenu + ".message");
	if ($currentConnection[0] != $currMenu)
	{
		connectAttr -f $curr $quality;
	}

	// Note:
	//	See the comment in AEeditRenderResolution() for an
	//	explanation of odd behaviour in the attribute editor
	//	which can be caused by this proc.
}


////////////////////////////////////////////////////
// custom layout for the render resolution layout 
////////////////////////////////////////////////////

global string $gAErenderGlobalsResolutionLUT[];

proc string getCurrentRenderResolutionMenu()
{
	global string $gAErenderGlobalsResolutionLUT[];

	// look for the correct parent
	//
	string $curParent = `setParent -q`;
	int	$index = -1;
	int $i;
	for ($i = 0; $i < size($gAErenderGlobalsResolutionLUT); $i += 2 ) {
		if ( $curParent == $gAErenderGlobalsResolutionLUT[$i] ) {
			$index = $i+1;
			break;
		}
	}
	string $menu = "renderResolutionMenu";
	if ($index != -1) {
		$menu = $gAErenderGlobalsResolutionLUT[$index];
	}
	return $menu;
}

//
//  Procedure Name:
//	 AEnewRenderResolution
//
//

global proc AEnewRenderResolution ( string $resolution )
{
	string $node = `resolutionNode`;
	connectAttr -f ($node + ".message") $resolution;
	showEditor $node;
}

//
//  Procedure Name:
//	AErenderResolutionNew
//
//

global proc AErenderResolutionNew ( string $resolution )
{
	global string $gAErenderGlobalsResolutionLUT[];

	string $buffer[];
	tokenize($resolution,".",$buffer);
	string $nodeName = $buffer[0];

	setUITemplate -pst attributeEditorTemplate;
	string $connect[] = `listConnections $resolution`;
	string $allRez[] = `ls -rr`;
	int $i;

	int $numUI = size($gAErenderGlobalsResolutionLUT);
	$gAErenderGlobalsResolutionLUT[$numUI] = `setParent -q`;

    rowLayout -nc 3 renderResolutionLayout;
    	text -label (uiRes("m_AErenderGlobalsTemplate.kRenderResolution")) renderResolutionText;
    	string $menu = `optionMenu -label "" renderResolutionMenu`;
		optionMenu -e
			-cc ("AEeditRenderResolution "+$menu+" "+$resolution)
			renderResolutionMenu;
        	for ($i = 0; $i < size($allRez); $i++)
        	{
            	menuItem -label $allRez[$i] ("renderResolutionAE" + $i);
            	if ($connect[0] == $allRez[$i])
                	optionMenu -e -sl ($i+1) $menu;
        	};
		setParent -m ..;
		button
			-label (uiRes("m_AErenderGlobalsTemplate.kNewButton"))
			-c ("AEnewRenderResolution "+ $resolution)
			newRenderResolutionButton;
   	setParent ..;
	scriptJob
		-p $menu -rp
		-ac $resolution ("AErenderResolutionMenuUpdate "+$menu+" "+$nodeName);
	setUITemplate -ppt;
	$gAErenderGlobalsResolutionLUT[$numUI+1] = $menu;
}

//
//  Procedure Name:
//	AErenderResolutionReplace
//
//

global proc AErenderResolutionReplace ( string $resolution )
{

	// get the nodeName
	//
	string $buffer[];
	tokenize($resolution,".",$buffer);
	string $nodeName = $buffer[0];

	// get parent
	//
	string $menu = getCurrentRenderResolutionMenu();

	// update the option menu
	//
	AErenderResolutionMenuUpdate($menu,$nodeName);

	// update the scriptJob
	//
	scriptJob
		-p $menu -rp
		-ac $resolution ("AErenderResolutionMenuUpdate "+$menu+" "+$nodeName);
}

//
//  Procedure Name:
//	AErenderResolutionUpdate
//
//

global proc AErenderResolutionMenuUpdate (string $menu, string $nodeName)
{
    string $connect[] = `listConnections ($nodeName+".resolution")`;
    string $allRes[] = `ls -rr`;
	int $numResolutions = size ($allRes);

	setParent -m $menu;

	// relabel menuItems that already exist
	//
	int $numOptions = `optionMenu -q -ni $menu`;
	string $optionMenuItems[] = `optionMenu -q -ill $menu`;
	int $i = 0;
	while ( $i < $numOptions && $i < $numResolutions ) {
        menuItem -e -label $allRes[$i] $optionMenuItems[$i];
        if ($connect[0] == $allRes[$i])
        	optionMenu -e -sl ($i+1) $menu;
		$i++;
	}

	// if we've run out of menu items and need more, create
	// them now, else, delete any excess menuItems
	//
	if ( $numOptions < $numResolutions ) {
		for ( $i = $numOptions; $i < $numResolutions; $i++ ) {
        	menuItem -label $allRes[$i] ("renderResolutionAE" + $i);
        	if ($connect[0] == $allRes[$i])
        		optionMenu -e -sl ($i+1) $menu;
		}
	} else if ( $numOptions > $numResolutions ) {
		for ( $i = $numResolutions; $i < $numOptions; $i++ ) {
        	if (`menuItem -exists $optionMenuItems[$i]`)
				deleteUI $optionMenuItems[$i];
		}
	}

	setParent -m ..;
}

//
//  Procedure Name:
//	AEeditRenderResolution
//
//

global proc AEeditRenderResolution ( string $menu, string $resolution )
{
	string $globals[] = `ls -renderGlobals`;
	string $currMenu = `optionMenu -q -v $menu`;
	string $currentConnection[] = `listConnections -p true $resolution`;
	string $curr = ($currMenu+".message");
	if ($currentConnection[0] != $currMenu) {
		connectAttr -f $curr $resolution;
	}

	// Note:
	//	If you create a new resolution, the attribute
	//	editor will update to display the newly created node.
	//	If you then click back on the renderGlobals tab to get it
	//	to appear in the attribute editor and then select another
	//	resolution from the optionMenu, the attribute editor will
	//	update to show the last created resolution.  This behaviour,
	//	although somewhat confusing, is correct.  This is because
	//	the resolution node was in focus at the time, not the
	//	renderGlobals node.  We could simply add a `showEditor
	// 	$renderGlobalsNode` to force the attribute editor to stay
	//	on the renderGlobals node, but this would lead to even
	//	more problematic behaviour when tear-offs are used.
	//	In this case, everytime the user selected a new resolution
	//	from the optionMenu in the tearoff, the main attribute
	//	would always update to display the renderGlobals node,
	//	which defeats the purpose of a tearoff in the first place.
	//	This is why `showEditor $renderGlobalsNode` should not
	//	appear in this proc.  The same applies for the proc
	//	AEeditRenderQuality() - ajp.
}


//
//  Procedure Name:
//	checkAnimationRange
//
//

global proc checkAnimationRange ( string $nodeName ) 
{
	string $nodeAttr = $nodeName + ".animationRange";
	int $value = `getAttr $nodeAttr`;
	
	if ( $value == 1 ) {
		editorTemplate -dimControl $nodeName "startFrame" true;
		editorTemplate -dimControl $nodeName "endFrame"   true;
		editorTemplate -dimControl $nodeName "byFrameStep" true;
	} else {
		editorTemplate -dimControl $nodeName "startFrame" false;
		editorTemplate -dimControl $nodeName "endFrame"   false;
		editorTemplate -dimControl $nodeName "byFrameStep" false;
	}
}

//
//  Procedure Name:
//	checkModifyExtension
//
//

global proc checkModifyExtension ( string $nodeName ) 
{
	string $nodeAttr = $nodeName + ".animation";
	int $animation = `getAttr $nodeAttr`;
	$nodeAttr = $nodeName + ".modifyExtension";
	int $modifyExtension = `getAttr $nodeAttr`;
	
	if ( $animation == 1 && $modifyExtension == 1 ) {
		editorTemplate -dimControl $nodeName "startExtension" false;
		editorTemplate -dimControl $nodeName "byExtension"    false;
	} else {
		editorTemplate -dimControl $nodeName "startExtension" true;
		editorTemplate -dimControl $nodeName "byExtension"    true;
	}
}

//
//  Procedure Name:
//	checkRenderGlobalsMotionBlurType
//
//

global proc checkRenderGlobalsMotionBlurType ( string $nodeName ) 
{
	string $nodeAttr = $nodeName + ".motionBlur";
	int $motionBlur = `getAttr $nodeAttr`;

	$nodeAttr = $nodeName + ".motionBlurType";
	int $value = `getAttr $nodeAttr`;
	
	if( $motionBlur == 1 ) {
		if ( $value == 1 ) {
			editorTemplate -dimControl $nodeName "blurLength" true;
			editorTemplate -dimControl $nodeName "blurSharpness" true;
			editorTemplate -dimControl $nodeName "smoothValue" true;
			editorTemplate -dimControl $nodeName "smoothColor" true;
			editorTemplate -dimControl $nodeName "keepMotionVector" true;
			editorTemplate -dimControl $nodeName "motionBlurByFrame" false;
		} else {
			editorTemplate -dimControl $nodeName "blurLength" false;
			editorTemplate -dimControl $nodeName "blurSharpness" false;
			editorTemplate -dimControl $nodeName "smoothValue" false;
			editorTemplate -dimControl $nodeName "smoothColor" false;
			editorTemplate -dimControl $nodeName "keepMotionVector" false;
			editorTemplate -dimControl $nodeName "motionBlurByFrame" false;
		}
	}
	else {
		editorTemplate -dimControl $nodeName "blurLength" true;
		editorTemplate -dimControl $nodeName "blurSharpness" true;
		editorTemplate -dimControl $nodeName "smoothValue" true;
		editorTemplate -dimControl $nodeName "smoothColor" true;
		editorTemplate -dimControl $nodeName "keepMotionVector" true;
		editorTemplate -dimControl $nodeName "motionBlurByFrame" true;
	}
}

//
//  Procedure Name:
//	checkRenderGlobalsMotionBlur
//
//

global proc checkRenderGlobalsMotionBlur ( string $nodeName ) 
{
	string $nodeAttr = $nodeName + ".motionBlur";
	int $motionBlur = `getAttr $nodeAttr`;
	
	if ( $motionBlur == 1 ) {
		editorTemplate -dimControl $nodeName "motionBlurType" false;
		editorTemplate -dimControl $nodeName "motionBlurByFrame" false;
		editorTemplate -dimControl $nodeName "blurLength" false;
		editorTemplate -dimControl $nodeName "blurSharpness" false;
		editorTemplate -dimControl $nodeName "smoothValue" false;
		editorTemplate -dimControl $nodeName "smoothColor" false;
		editorTemplate -dimControl $nodeName "keepMotionVector" false;
		checkRenderGlobalsMotionBlurType $nodeName;

	} else {
		editorTemplate -dimControl $nodeName "motionBlurType" true;
		editorTemplate -dimControl $nodeName "motionBlurByFrame" true;
		editorTemplate -dimControl $nodeName "blurLength" true;
		editorTemplate -dimControl $nodeName "blurSharpness" true;	
		editorTemplate -dimControl $nodeName "smoothValue" true;
		editorTemplate -dimControl $nodeName "smoothColor" true;
		editorTemplate -dimControl $nodeName "keepMotionVector" true;	
	}
}


//
//  Procedure Name:
//	checkComposite
//
//

global proc checkComposite ( string $nodeName ) 
{
	string $nodeAttr = $nodeName + ".composite";
	int $value = `getAttr $nodeAttr`;
	
	if ( $value == 1 ) {
		editorTemplate -dimControl $nodeName "compositeThreshold" false;
	} else {
		editorTemplate -dimControl $nodeName "compositeThreshold" true;
	}
}

//
//  Procedure Name:
//	checkOutFormatControl
//
//

global proc checkOutFormatControl ( string $nodeName ) 
{
	string $nodeAttr = $nodeName + ".outFormatControl";
	int $value = `getAttr $nodeAttr`;
	
	if ( $value == 2 ) {
		editorTemplate -dimControl $nodeName "outFormatExt" false;
	} else {
		editorTemplate -dimControl $nodeName "outFormatExt" true;
	}
}

//
//
//  Procedure Name:
//	checkFieldExtControl
//
//

global proc checkFieldExtControl ( string $nodeName ) 
{
	string $nodeAttr = $nodeName + ".fieldExtControl";
	int $value = `getAttr $nodeAttr`;
	
	if ( $value == 2 ) {
		editorTemplate -dimControl $nodeName "evenFieldExt" false;
		editorTemplate -dimControl $nodeName "oddFieldExt" false;
	} else {
		editorTemplate -dimControl $nodeName "evenFieldExt" true;
		editorTemplate -dimControl $nodeName "oddFieldExt" true;
	}
}

//
//  Procedure Name:
//	checkRenderGlobalsAnimation
//
//

global proc checkRenderGlobalsAnimation ( string $nodeName ) 
{
	string $nodeAttr = $nodeName + ".animation";
	int $value = `getAttr $nodeAttr`;
	
	if ( $value ) {
		editorTemplate -dimControl $nodeName "animationRange" false;
		editorTemplate -dimControl $nodeName "startFrame" false;
		editorTemplate -dimControl $nodeName "endFrame" false;
		editorTemplate -dimControl $nodeName "byFrameStep" false;
		editorTemplate -dimControl $nodeName "modifyExtension" false;
		editorTemplate -dimControl $nodeName "startExtension" false;
		editorTemplate -dimControl $nodeName "byExtension" false;	
		editorTemplate -dimControl $nodeName "extensionPadding" false;

		checkAnimationRange $nodeName;
		checkModifyExtension $nodeName;
	} else {
		editorTemplate -dimControl $nodeName "animationRange" true;
		editorTemplate -dimControl $nodeName "startFrame" true;
		editorTemplate -dimControl $nodeName "endFrame" true;
		editorTemplate -dimControl $nodeName "byFrameStep" true;
		editorTemplate -dimControl $nodeName "modifyExtension" true;
		editorTemplate -dimControl $nodeName "startExtension" true;
		editorTemplate -dimControl $nodeName "byExtension" true;	
		editorTemplate -dimControl $nodeName "extensionPadding" true;
	}
}


//
//	Procedure Names: AErenderObjNew, AErenderObjReplace, AErenderObjSet
//	Purpose: render all or render active settings
//

global proc AErenderObjNew (string $renderAll)
{
	global string $AErenderObjMenu;
    setUITemplate -pst attributeEditorTemplate;
    rowLayout -nc 2 renderWhatRow;
        text -label (uiRes("m_AErenderGlobalsTemplate.kRenderObjects"));
        string $AErenderObjMenu = `optionMenu -label "" `;
            menuItem -label (uiRes("m_AErenderGlobalsTemplate.kRenderAll")) renderObj1;
            menuItem -label (uiRes("m_AErenderGlobalsTemplate.kRender")) renderObj2;
        setParent ..;
	optionMenu -e -cc ("AErenderObjSet " + $renderAll + " " +$AErenderObjMenu) $AErenderObjMenu;
	scriptJob -p $AErenderObjMenu -rp -ac $renderAll
		 ("checkRenderAllMenu " + $renderAll + " " + $AErenderObjMenu);
	
    setUITemplate -ppt;

	// If already render-active, set the menu as such...
	if (`getAttr $renderAll` == 0)
		optionMenu -e -sl 2 $AErenderObjMenu;
}

global proc AErenderObjReplace (string $renderAll)
{
	global string $AErenderObjMenu;
	if (`optionMenu -exists $AErenderObjMenu`) {
	    optionMenu -e -cc ("AErenderObjSet " + $renderAll + " " + $AErenderObjMenu) $AErenderObjMenu;
		scriptJob -p $AErenderObjMenu -rp -ac $renderAll
			 ("checkRenderAllMenu "+$renderAll +" "+ $AErenderObjMenu);
	}
}

global proc checkRenderAllMenu (string $renderAll, string $AErenderObjMenu)
{
	if (`getAttr $renderAll` == 0)
	{
		optionMenu -e -sl 2 $AErenderObjMenu;
	} else {
		optionMenu -e -sl 1 $AErenderObjMenu;
	}
}

global proc AErenderObjSet (string $renderAll, string $AErenderObjMenu)
{
    string $curr = `optionMenu -q -v $AErenderObjMenu`;
    if ($curr == uiRes("m_AErenderGlobalsTemplate.kRenderAll"))
        setAttr $renderAll 1;
    else if ($curr == (uiRes("m_AErenderGlobalsTemplate.kRender")) )
        setAttr $renderAll 0;
}

global proc AEenvFogNew (string $fog)
//
// Description:
//		Setup up button that makes fog.
//
{
	setUITemplate -pst attributeEditorTemplate;

		attrNavigationControlGrp -label (uiRes("m_AErenderGlobalsTemplate.kEnvironmentFog"))
				-at $fog envFogControl;

	setUITemplate -ppt;
}

global proc AEenvFogReplace (string $fog)
//
// Description:
//		Replace the button with the command to create fog
//		for the new camera.
//
{
	attrNavigationControlGrp -edit
		-at $fog envFogControl;
}


//
//  Procedure Name:
//	AErenderGlobalsTemplate
//
//

global proc AErenderGlobalsTemplate ( string $nodeName ) 
{
editorTemplate -beginScrollLayout;
	
	editorTemplate -beginLayout (uiRes("m_AErenderGlobalsTemplate.kRenderableObjectsCamera")) -collapse 0;
		editorTemplate -callCustom "AErenderObjNew" "AErenderObjReplace" "renderAll";

		editorTemplate -addControl "imageFormat";
		editorTemplate -addSeparator;
		editorTemplate -callCustom "AEcameraListNew" "AEcameraListReplace";
		editorTemplate -suppress "cameras";
	editorTemplate -endLayout;

	editorTemplate -beginLayout (uiRes("m_AErenderGlobalsTemplate.kRenderQualityResolution")) -collapse 0;
		editorTemplate -callCustom "AErenderQualityNew" 
				"AErenderQualityReplace"
				"quality";
		editorTemplate -callCustom "AErenderResolutionNew" 
				"AErenderResolutionReplace"
				"resolution";

	editorTemplate -endLayout;

	editorTemplate -beginLayout (uiRes("m_AErenderGlobalsTemplate.kAnimation"));
		editorTemplate -addControl "animation" "checkRenderGlobalsAnimation";
		editorTemplate -addControl "animationRange" "checkAnimationRange";

		editorTemplate -addControl "startFrame";
		editorTemplate -addControl "endFrame";
		editorTemplate -addControl "byFrameStep";
		editorTemplate -suppress   "byFrame";

		editorTemplate -addControl "modifyExtension" "checkModifyExtension";
		editorTemplate -addControl "startExtension";
		editorTemplate -addControl "byExtension";	
		editorTemplate -addControl "extensionPadding";
	editorTemplate -endLayout;

	editorTemplate -beginLayout (uiRes("m_AErenderGlobalsTemplate.kMotionBlur"));	
		editorTemplate -addControl "motionBlur" "checkRenderGlobalsMotionBlur";
		editorTemplate -addControl "motionBlurType" "checkRenderGlobalsMotionBlurType";
		editorTemplate -addControl "motionBlurByFrame";
		editorTemplate -addControl "blurLength";
		editorTemplate -addControl "blurSharpness";
		editorTemplate -addControl "smoothValue";
		editorTemplate -interruptOptimize;	
		editorTemplate -addControl "smoothColor";
		editorTemplate -interruptOptimize;	
		editorTemplate -addControl "keepMotionVector";
	editorTemplate -endLayout;

	editorTemplate -beginLayout (uiRes("m_AErenderGlobalsTemplate.kSpecialEffects"));
		editorTemplate -addControl "ignoreFilmGate";
		editorTemplate -addControl "gammaCorrection";
		editorTemplate -addControl "composite" "checkComposite";
		editorTemplate -addControl "compositeThreshold";
		editorTemplate -addControl "clipFinalShadedColor";
		editorTemplate -callCustom "AEenvFogNew" "AEenvFogReplace" "fogGeometry";
		editorTemplate -addControl "enableDepthMaps";
		editorTemplate -addControl "shadowPass";
		editorTemplate -addControl "shadowsObeyLightLinking";
		editorTemplate -addControl "shadowsObeyShadowLinking";
	editorTemplate -endLayout;

	editorTemplate -beginLayout (uiRes("m_AErenderGlobalsTemplate.kOutputExtensions"));
		editorTemplate -addControl "useMayaFileName";
		editorTemplate -addControl "useFrameExt";
		editorTemplate -addControl "outFormatControl" "checkOutFormatControl";
		editorTemplate -addControl "outFormatExt";
		editorTemplate -addSeparator;

		editorTemplate -addControl "fieldExtControl" "checkFieldExtControl";
		editorTemplate -addControl "oddFieldExt";
		editorTemplate -addControl "evenFieldExt";

	editorTemplate -endLayout;
	
	editorTemplate -beginLayout (uiRes("m_AErenderGlobalsTemplate.kMemoryandPerformanceOptions"));
		editorTemplate -addControl "maximumMemory";
		editorTemplate -addControl "useFileCache";
		editorTemplate -addControl "optimizeInstances";
		editorTemplate -addControl "reuseTessellations";
		editorTemplate -interruptOptimize;	
		editorTemplate -addControl "useDisplacementBoundingBox";
		editorTemplate -addControl "recursionDepth";
        editorTemplate -addControl "leafPrimitives";
        editorTemplate -addControl "subdivisionPower";
        editorTemplate -addControl "subdivisionHashSize";
        editorTemplate -addControl "logRenderPerformance";
	editorTemplate -endLayout;
	
	editorTemplate -beginLayout (uiRes("m_AErenderGlobalsTemplate.kMelCallbacks"));
		editorTemplate -addControl "preMel";
		editorTemplate -addControl "postMel";
		editorTemplate -addControl "preRenderLayerMel";
		editorTemplate -addControl "postRenderLayerMel";
		editorTemplate -addControl "preRenderMel";
		editorTemplate -addControl "postRenderMel";
		editorTemplate -addControl "preFurRenderMel";
		editorTemplate -addControl "postFurRenderMel";
	editorTemplate -endLayout;
	
	// include/call base class/node attributes
	AEdependNodeTemplate $nodeName;

	// suppressed attributes
	editorTemplate -suppress "topRegion";
	editorTemplate -suppress "leftRegion";
	editorTemplate -suppress "bottomRegion";
	editorTemplate -suppress "rightRegion";
	editorTemplate -suppress "useRenderRegion";

editorTemplate -addExtraControls;
editorTemplate -endScrollLayout;
}
