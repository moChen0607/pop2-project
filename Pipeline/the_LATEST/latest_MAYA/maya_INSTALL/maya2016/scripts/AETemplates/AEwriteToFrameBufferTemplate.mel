// Copyright (C) 1997-2014 Autodesk, Inc., and/or its licensors.
// All rights reserved.
//
// The coded instructions, statements, computer programs, and/or related
// material (collectively the "Data") in these files contain unpublished
// information proprietary to Autodesk, Inc. ("Autodesk") and/or its licensors,
// which is protected by U.S. and Canadian federal copyright law and by
// international treaties.
//
// The Data is provided for use exclusively by You. You have the right to use,
// modify, and incorporate this Data into other products for purposes authorized 
// by the Autodesk software license agreement, without fee.
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND. AUTODESK
// DOES NOT MAKE AND HEREBY DISCLAIMS ANY EXPRESS OR IMPLIED WARRANTIES
// INCLUDING, BUT NOT LIMITED TO, THE WARRANTIES OF NON-INFRINGEMENT,
// MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE, OR ARISING FROM A COURSE 
// OF DEALING, USAGE, OR TRADE PRACTICE. IN NO EVENT WILL AUTODESK AND/OR ITS
// LICENSORS BE LIABLE FOR ANY LOST REVENUES, DATA, OR PROFITS, OR SPECIAL,
// DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES, EVEN IF AUTODESK AND/OR ITS
// LICENSORS HAS BEEN ADVISED OF THE POSSIBILITY OR PROBABILITY OF SUCH DAMAGES.

//
//  Procedure Name:
//	AEwriteToFrameBufferTemplate
//
//  Description Name;
//	Creates the attribute editor controls for the writeToFrameBuffer Node
//
//  Input Value:
//	nodeName 
//
//  Output Value:
//	None
// 


// store the names of the optionMenu control us to specify the associated renderPassNode
global string $AEColorRenderPassControl = "";
global string $AEVectorRenderPassControl = "";
global string $AEDepthRenderPassControl = "";
global string $AELabelRenderPassControl = "";

proc string getRenderPassControlName( string $fullAttrName )
{
    global string $AEColorRenderPassControl; 
    global string $AEVectorRenderPassControl; 
    global string $AEDepthRenderPassControl; 
    global string $AELabelRenderPassControl; 
    string $result;
    string $nameTokens[];
    tokenize $fullAttrName "." $nameTokens;
    string $type = `nodeType $nameTokens[0]`;
    if ( $type == "writeToColorBuffer" )
    {
        $result = $AEColorRenderPassControl;
    }
    if ( $type == "writeToVectorBuffer" )
    {
        $result = $AEVectorRenderPassControl;
    }
    if ( $type == "writeToDepthBuffer" )
    {
        $result = $AEDepthRenderPassControl;
    }
    if ( $type == "writeToLabelBuffer" )
    {
        $result = $AELabelRenderPassControl;
    }
    return $result;
}

proc string getRenderPassType( string $fullAttrName )
{
    string $result;
    string $nameTokens[];
    tokenize $fullAttrName "." $nameTokens;
    string $type = `nodeType $nameTokens[0]`;
    if ( $type == "writeToColorBuffer" )
    {
        $result = "CSTCOL";
    }
    if ( $type == "writeToVectorBuffer" )
    {
        $result = "CSTVCT";
    }
    if ( $type == "writeToDepthBuffer" )
    {
        $result = "CSTZ";
    }
    if ( $type == "writeToLabelBuffer" )
    {
        $result = "CSTLBL";
    }
    return $result;
}

proc string getRenderPassControlLabel( string $fullAttrName )
{
    string $result;
    string $nameTokens[];
    tokenize $fullAttrName "." $nameTokens;
    string $type = `nodeType $nameTokens[0]`;
    if ( $type == "writeToColorBuffer" )
    {
        $result = (uiRes("m_AEwriteToFrameBufferTemplate.kCustomColor"));
    }
    if ( $type == "writeToVectorBuffer" )
    {
        $result = (uiRes("m_AEwriteToFrameBufferTemplate.kCustomVector"));
    }
    if ( $type == "writeToDepthBuffer" )
    {
        $result = (uiRes("m_AEwriteToFrameBufferTemplate.kCustomDepth"));
    }
    if ( $type == "writeToLabelBuffer" )
    {
        $result = (uiRes("m_AEwriteToFrameBufferTemplate.kCustomLabel"));
    }
    return $result;
}


//  Stores the name of a newly create control
proc setRenderPassControlName( string $fullAttrName, string $controlName )
{
    global string $AEColorRenderPassControl; 
    global string $AEVectorRenderPassControl; 
    global string $AEDepthRenderPassControl; 
    global string $AELabelRenderPassControl; 

    string $nameTokens[];
    tokenize $fullAttrName "." $nameTokens;
    string $type = `nodeType $nameTokens[0]`;
    if ( $type == "writeToColorBuffer" )
    {
        $AEColorRenderPassControl = $controlName;
    }
    if ( $type == "writeToVectorBuffer" )
    {
        $AEVectorRenderPassControl = $controlName;
    }
    if ( $type == "writeToDepthBuffer" )
    {
        $AEDepthRenderPassControl = $controlName;
    }
    if ( $type == "writeToLabelBuffer" )
    {
        $AELabelRenderPassControl = $controlName;
    }
}

global proc AErenderPassNew( string $fullAttrName )
{
    AEcreateRenderPassControl($fullAttrName);
}

proc AEcreateRenderPassControlItems(string $fullAttrName)
{
    menuItem -label (uiRes("m_AEwriteToFrameBufferTemplate.kNone"));
    string  $renderPassNodes[] = `lsType("renderPass")`;
    int $numNodes = `size($renderPassNodes)`-1;
    int $i;
    string $rpType = getRenderPassType($fullAttrName);
    for ($i = 0; $i < $numNodes ; $i++)
    {
        string $passIDplug = $renderPassNodes[$i] + ".passID";
        if (`getAttr $passIDplug` ==  $rpType)
        {
            menuItem -label $renderPassNodes[$i];
        }
    }
}

proc AEselectConnectedRenderPass(string $fullAttrName, string $renderPassControl)
{
    //select the right item
    if (`connectionInfo -isDestination $fullAttrName`)
    {
        string $connectedPlug = `connectionInfo -sourceFromDestination $fullAttrName`;
        string $plugTokens[];
        tokenize $connectedPlug "." $plugTokens;
        optionMenuGrp -edit -value $plugTokens[0] $renderPassControl;
    }
    else
    {
        if(`optionMenuGrp -q -ni $renderPassControl` >= 1)
        {
            optionMenuGrp -edit -select 1 $renderPassControl;
        }
    }
}

// Rebuild the render pass selection control from scratch
global proc AEcreateRenderPassControl(string $fullAttrName)
{
    setUITemplate -pst attributeEditorTemplate;     

    string $controlLabel = `getRenderPassControlLabel($fullAttrName)`;
    string $renderPassControl = `optionMenuGrp -label $controlLabel`;
    setRenderPassControlName($fullAttrName, $renderPassControl);

    AEcreateRenderPassControlItems( $fullAttrName );
    
    setUITemplate -ppt;

    string $jobCmd = "AEupdateRenderPassControl \"" + $fullAttrName + "\" \"" + $renderPassControl + "\"";
    scriptJob -parent $renderPassControl -event renderPassChange $jobCmd;

    string $chgCmd = "AErenderPassConnect \"" + $fullAttrName + "\" \"" + $renderPassControl + "\";";
    optionMenuGrp -edit -changeCommand $chgCmd $renderPassControl;

    AEselectConnectedRenderPass($fullAttrName, $renderPassControl);
}

global proc AEupdateRenderPassControl(string $fullAttrName, string $renderPassControl)
{
    string $attrTok[];
    tokenize $fullAttrName "." $attrTok;
    if (`attributeExists $attrTok[1] $attrTok[0]`)
    {
        if (`optionMenuGrp -query -ni $renderPassControl` >= 1)
        {
            deleteUI -mi `optionMenuGrp -query -itemListShort $renderPassControl`;
        }

        setParent -menu ($renderPassControl + "|OptionMenu");
        AEcreateRenderPassControlItems( $fullAttrName );
        AEselectConnectedRenderPass($fullAttrName, $renderPassControl);
    }
}

// Adjusts the connection of the render pass message attribute whe the
// render pass control is edited
global proc AErenderPassConnect( string $fullAttrName, string $renderPassControl )
{
    string $cmd;

    //discard old connection if it exists
    if (`connectionInfo -isDestination $fullAttrName`)
    {
        string $oldSrcAttr = `connectionInfo -sourceFromDestination $fullAttrName`;
        $cmd = "disconnectAttr \"" + $oldSrcAttr + "\" \"" + $fullAttrName + "\";";
    }

    // create a new connection if selection is not <none>
    if (`optionMenuGrp -query -select $renderPassControl` != 1)
    {
        string $srcAttr = `optionMenuGrp -query -value $renderPassControl` + ".message";
        $cmd = $cmd + "connectAttr \"" + $srcAttr + "\" \"" + $fullAttrName + "\";";
    }
    evalEcho($cmd);
}

global proc AErenderPassReplace( string $fullAttrName )
{
    string $renderPassControl = `getRenderPassControlName($fullAttrName)`;

    AEupdateRenderPassControl($fullAttrName, $renderPassControl);

    // replace the script job so that it uses the new node
    // (-rp flag)
    string $jobCmd = "AEupdateRenderPassControl \"" + $fullAttrName + "\" \"" + $renderPassControl + "\"";
    scriptJob -rp -parent $renderPassControl -event renderPassChange $jobCmd;

    // update the callback so that it uses the new node
    string $chgCmd = "AErenderPassConnect \"" + $fullAttrName + "\" \"" + $renderPassControl + "\";";
    optionMenuGrp -edit -changeCommand $chgCmd $renderPassControl;
}

global proc AEwriteToFrameBufferTemplate ( string $nodeName )
{
    editorTemplate -beginLayout (uiRes("m_AEwriteToFrameBufferTemplate.kFrameBufferOptions")) -collapse 0;
        editorTemplate -callCustom "AErenderPassNew" "AErenderPassReplace" "renderPass";
		editorTemplate -addControl "writeOperation";
		editorTemplate -addControl "scaleFactor";
	editorTemplate -endLayout;
    editorTemplate -beginLayout (uiRes("m_AEwriteToFrameBufferTemplate.kEvalTrigger")) -collapse 1;
		editorTemplate -addControl "evaluationMode";
		editorTemplate -addControl "evaluationPassThrough";
	editorTemplate -endLayout;
}
