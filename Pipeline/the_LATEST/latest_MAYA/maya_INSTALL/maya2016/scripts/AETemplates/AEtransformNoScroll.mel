// Copyright (C) 1997-2014 Autodesk, Inc., and/or its licensors.
// All rights reserved.
//
// The coded instructions, statements, computer programs, and/or related
// material (collectively the "Data") in these files contain unpublished
// information proprietary to Autodesk, Inc. ("Autodesk") and/or its licensors,
// which is protected by U.S. and Canadian federal copyright law and by
// international treaties.
//
// The Data is provided for use exclusively by You. You have the right to use,
// modify, and incorporate this Data into other products for purposes authorized 
// by the Autodesk software license agreement, without fee.
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND. AUTODESK
// DOES NOT MAKE AND HEREBY DISCLAIMS ANY EXPRESS OR IMPLIED WARRANTIES
// INCLUDING, BUT NOT LIMITED TO, THE WARRANTIES OF NON-INFRINGEMENT,
// MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE, OR ARISING FROM A COURSE 
// OF DEALING, USAGE, OR TRADE PRACTICE. IN NO EVENT WILL AUTODESK AND/OR ITS
// LICENSORS BE LIABLE FOR ANY LOST REVENUES, DATA, OR PROFITS, OR SPECIAL,
// DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES, EVEN IF AUTODESK AND/OR ITS
// LICENSORS HAS BEEN ADVISED OF THE POSSIBILITY OR PROBABILITY OF SUCH DAMAGES.

//
//  Procedure Name:
//	AEtransformNoScroll 
//
//  Description:
//	Creates attribute editor controls in separate files 
//	for the transform Node
//
//  Input Value:
//	nodeName
//
//  Output Value:
//	None
//

global string $gTransformLimitsUILUT[];

proc string getCurrentTransformLimitsUI()
{
	global string $gTransformLimitsUILUT[];

	// get the current parent
	//
	string $currentParent = `setParent -q`;

	// look for this parent in the LUT
	//
	int $i;
	for ( $i = 0; $i < size($gTransformLimitsUILUT); $i += 2 ) {
		if ( $currentParent == $gTransformLimitsUILUT[$i] ) {
			return $gTransformLimitsUILUT[$i+1];
		}
	}
	return $currentParent;
}

global proc AElimitsLabelNew ( string $nodeAttr )
{
	setUITemplate -pst attributeEditorLimitsTemplate;
	rowLayout -nc 6;
		text -l "";
		text -l "";
		text -label (uiRes("m_AEtransformNoScroll.kMin")) ;
		rowLayout -nc 3;
			text -l "";
			text -label (uiRes("m_AEtransformNoScroll.kCurrent")) ;
			text -l "";
		setParent ..;
		text -label (uiRes("m_AEtransformNoScroll.kMax")) ;
		text -l "";
	setParent ..;
	setUITemplate -ppt;
}


global proc AElimitsLabelReplace ( string $nodeAttr )
{
	// empty proc
}



global proc dimLimitField( string $fieldName, string $attr )
{
	int $value = `getAttr $attr`;
	if ($value)
		floatField -e -en 1 $fieldName;
	else
		floatField -e -en 0 $fieldName;
}


//  Procedure Name: 	checkLimitValue
//
//	see what the current settings of min and max are, and swap them 
//	if they are the wrong way around.
//	Also make sure, that the current value is never invalid
//
global proc checkLimitValue (	string $transformType, 
								string $axis,
								string $nodeName,
								int $fromUI,
								string $parent )
{
	string $attrMin = $nodeName+".min"+$transformType+$axis+"Limit";
	string $attrMax = $nodeName+".max"+$transformType+$axis+"Limit";
	string $enableMin = $nodeName+".min"+$transformType+$axis+"LimitEnable";
	string $enableMax = $nodeName+".max"+$transformType+$axis+"LimitEnable";
	string $currentAttr;
	switch ($transformType){
		case "Rot":
			$currentAttr = ($nodeName + ".rotate" + $axis);
			$flag = "-r"+tolower($axis);
			$eflag = "-er"+tolower($axis);
			break;
		case "Trans":
			$currentAttr = ($nodeName + ".translate" + $axis);
			$flag = "-t"+tolower($axis);
			$eflag = "-et"+tolower($axis);
			break;
		case "Scale":
			$currentAttr = ($nodeName + ".scale" + $axis);
			$flag = "-s"+tolower($axis);
			$eflag = "-es"+tolower($axis);
			break;
	}
	string $name = ($transformType + "Limit" + $axis);

	float $minValue, $maxValue;
	int $enableMinVal, $enableMaxVal;
	if ( $fromUI == 1 ) {
		// get the current UI values
		//
		$minValue = `floatField -q -v ($parent + "|min" + $name + "Field")`;
		$maxValue = `floatField -q -v ($parent + "|max" + $name + "Field")`;
		$enableMinVal = `checkBox -q -v ($parent + "|min" + $name + "CheckBox")`;
		$enableMaxVal = `checkBox -q -v ($parent + "|max" + $name + "CheckBox")`;
	} else {
		// get the current attribute values
		//
		$minValue = `getAttr $attrMin`;
		$maxValue = `getAttr $attrMax`;
		$enableMinVal = `getAttr $enableMin`;
		$enableMaxVal = `getAttr $enableMax`;
	}
	int $fieldStateMin = `floatField -q -en ($parent + "|min" + $name + "Field")`;
	int $fieldStateMax = `floatField -q -en ($parent + "|max" + $name + "Field")`;

	// only swap the values if both enable flags are on
	//
	if ($minValue > $maxValue) {
		if ( $enableMinVal == 1 && $enableMaxVal == 1 ) {
			float $tmp = $minValue;
			$minValue = $maxValue;
			$maxValue = $tmp;
		} else if  ( !$fromUI ) {
			// the user tried to set a limit outside the UI
			// (e.g. via setAttr) erroneously;
			// need to get the current UI values which should
			// be correct and use setAttr to get the attributes
			// in the right state;
			// note that $minValue and $maxValue will still
			// be wrong - this is OK - an error will be
			// produced in when the transformLimit command
			// is executed
			//
			setAttr $attrMin `floatField -q -v ($parent + "|min" + $name + "Field")`;
			setAttr $attrMax `floatField -q -v ($parent + "|max" + $name + "Field")`;
		}
		$fromUI = 1;
	}

	if ( $fromUI == 1 ) {
		string $command = "transformLimits "
						+ $flag + " " + $minValue + " " + $maxValue + " "
						+ $eflag + " " + $enableMinVal + " " + $enableMaxVal
						+ " " + $nodeName;
		catch(evalEcho($command));

		// get the current attribute values
		//
		$minValue = `getAttr $attrMin`;
		$maxValue = `getAttr $attrMax`;
		$enableMinVal = `getAttr $enableMin`;
		$enableMaxVal = `getAttr $enableMax`;
	}

	// update the UI
	//
	floatField -e -v $minValue ($parent + "|min" + $name + "Field");
	floatField -e -v $maxValue ($parent + "|max" + $name + "Field");
	checkBox -e -v $enableMinVal ($parent + "|min" + $name + "CheckBox");
	checkBox -e -v $enableMaxVal ($parent + "|max" + $name + "CheckBox");
}


//  Procedure Name: 	AElimitReplace
//	
//	Hooks up all the widgets
//
global proc AElimitsReplace (	string $transformType, 
								string $axis,
								string $attrMin )
{
	// construct all the necessary attribute names 
	//
	string $tmp[];
	tokenize($attrMin, ".", $tmp);
	string $nodeName = $tmp[0];

	string $attrMax = $nodeName+".max"+$transformType+$axis+"Limit";
	string $enableMin = $nodeName+".min"+$transformType+$axis+"LimitEnable";
	string $enableMax = $nodeName+".max"+$transformType+$axis+"LimitEnable";
	string $currentAttr;
	switch ($transformType){
		case "Rot":
			$currentAttr = ($nodeName + ".rotate" + $axis);
			break;
		case "Trans":
			$currentAttr = ($nodeName + ".translate" + $axis);
			break;
		case "Scale":
			$currentAttr = ($nodeName + ".scale" + $axis);
			break;
	}
	string $name = ($transformType + "Limit" + $axis);
	string $currentName = ("current" + $transformType + $axis + "Field");

	// build the full path name for the controls
	//
	string $parent = getCurrentTransformLimitsUI();
	if ( `match ("LimitRow"+$transformType+"$") $parent` == "" )
	{
		// If a joint is selected $parent is set to one level above 
		// "LimitRow[$transformType]".  So, set parent to the LimitRow 
		// level if it's not there already.
		$parent += ("|LimitRow"+$transformType);
	}
	string $minButton = ($parent+"|TransformLimitButtonRow|min"+$name+"Button");
	string $maxButton = ($parent+"|TransformLimitButtonRow|max"+$name+"Button");
	string $minCheckBox = ($parent + "|min" + $name + "CheckBox");
	string $maxCheckBox = ($parent + "|max" + $name + "CheckBox");
	string $minField = ($parent + "|min" + $name + "Field");
	string $maxField = ($parent + "|max" + $name + "Field");

	// hook up all the controls 
	//
	button -e
		-c ("limitEnter "
			+ $transformType + " "
			+ $axis + " "
			+ $nodeName + " min "
			+ $parent)
		$minButton;
	connectControl $currentName $currentAttr;
	button -e
		-c ("limitEnter "
			+ $transformType + " "
			+ $axis + " "
			+ $nodeName + " max "
			+ $parent)
		$maxButton;

	// define what happens when the ui is used
	//
	checkBox -e
		-cc ("checkLimitValue "
			+ $transformType + " "
			+ $axis + " "
			+ $nodeName + " 1 "
			+ $parent)
		$minCheckBox;
	checkBox -e
		-cc ("checkLimitValue "
			+ $transformType + " "
			+ $axis + " "
			+ $nodeName + " 1 "
			+ $parent)
		$maxCheckBox;
	floatField -e
		-cc ("checkLimitValue "
			+ $transformType + " "
			+ $axis + " "
			+ $nodeName + " 1 "
			+ $parent)
		$minField;
	floatField -e
		-cc ("checkLimitValue "
			+ $transformType + " "
			+ $axis + " "
			+ $nodeName + " 1 "
			+ $parent)
		$maxField;
	scriptJob
		-p $minCheckBox -rp
		-ac $enableMin ("dimLimitField "+$minField+" "+$enableMin);
	scriptJob
		-p $maxCheckBox -rp
		-ac $enableMax ("dimLimitField "+$maxField+" "+$enableMax);
	scriptJob
		-p $minField -rp
		-ac $attrMin ("checkLimitValue "
						+ $transformType + " "
						+ $axis + " "
						+ $nodeName + " 0 "
						+ $parent);
	scriptJob
		-p $maxField -rp
		-ac $attrMax ("checkLimitValue "
						+ $transformType + " "
						+ $axis + " "
						+ $nodeName + " 0 "
						+ $parent);

	// check the floatFields' initial dim state
	//
	dimLimitField $minField $enableMin;
	dimLimitField $maxField $enableMax;

	// see if it is necessary to swap values 
	//
	checkLimitValue $transformType $axis $nodeName 0 $parent;
}


//  Procedure Name: 	AElimitsNew
//
//  	This procedure creates the widgets for the limit workflow
//
global proc AElimitsNew (	string $transformType, 
							string $axis,
							string $attrMin )
{
	global string $gTransformLimitsUILUT[];

	// construct all the necessary attribute names 
	//
	string $tmp[];
	tokenize($attrMin, ".", $tmp);
	string $nodeName = $tmp[0];

	string $attrMax = $nodeName+".max"+$transformType+$axis+"Limit";
	string $enableMin = $nodeName+".min"+$transformType+$axis+"LimitEnable";
	string $enableMax = $nodeName+".max"+$transformType+$axis+"LimitEnable";
	string $transformTypeUI = $transformType;

	string $currentAttr;
	switch ($transformType){
		case "Rot":
			$currentAttr = ($nodeName + ".rotate" + $axis);
			$transformTypeUI = (uiRes("m_AEtransformNoScroll.kTypeRotate"));
			break;
		case "Trans":
			$currentAttr = ($nodeName + ".translate" + $axis);
			$transformTypeUI = (uiRes("m_AEtransformNoScroll.kTypeTrans"));
			break;
		case "Scale":
			$currentAttr = ($nodeName + ".scale" + $axis);
			$transformTypeUI = (uiRes("m_AEtransformNoScroll.kTypeScale"));
			break;
	}

	string $axisUI;
	switch( $axis ) {
		case "X":
			$axisUI = (uiRes("m_AEtransformNoScroll.kX"));
			break;
		case "Y":
			$axisUI = (uiRes("m_AEtransformNoScroll.kY"));
			break;
		case "Z":
			$axisUI = (uiRes("m_AEtransformNoScroll.kZ"));
			break;
		default:
			$axisUI = $axis;
			break;
	}

	string $limit = (uiRes("m_AEtransformNoScroll.kLimit"));
	string $UIname = `format -s $transformTypeUI -s $axisUI $limit`;
	string $name = ($transformType + "Limit" + $axis);
	string $currentName = ("current" + $transformType + $axis + "Field");

	// build the widgets 
	setUITemplate -pst attributeEditorLimitsTemplate;

	int $newUI = size($gTransformLimitsUILUT);
	$gTransformLimitsUILUT[$newUI] = `setParent -q`;
	
	$gTransformLimitsUILUT[$newUI+1] =
		`rowLayout -nc 6 ("LimitRow" + $transformType)`;
		text -label $UIname;
		checkBox -v `getAttr $enableMin` -l "" ( "min" + $name + "CheckBox");
		floatField -pre 2 -v `getAttr $attrMin` ( "min" + $name + "Field");
		rowLayout -nc 3 "TransformLimitButtonRow";
			button -label "<" ( "min" + $name + "Button");
			floatField -precision 2 ( $currentName);
			button -label ">" ( "max" + $name + "Button");
		setParent ..;
		floatField -pre 2 -v `getAttr $attrMax` ( "max" + $name + "Field");
		checkBox -v `getAttr $enableMax` -l "" ( "max" + $name + "CheckBox");
	setParent ..;

	setUITemplate -ppt;

	// hook up the widgets
	AElimitsReplace $transformType $axis $attrMin;
}


//  Procedure Name: 	limitEnter
//
//	Puts the current transformation value to be the 
//	corresponding limit. Turns limit usage on.
//
global proc limitEnter (string $transformType, 
						string $axis,
						string $nodeName,
						string $minMax,
						string $parent )
{
	string $attrMin = $nodeName+".min"+$transformType+$axis+"Limit";
	string $attrMax = $nodeName+".max"+$transformType+$axis+"Limit";
	string $enableMin = $nodeName+".min"+$transformType+$axis+"LimitEnable";
	string $enableMax = $nodeName+".max"+$transformType+$axis+"LimitEnable";
	string $currentAttr;
	switch ($transformType){
		case "Rot":
			$currentAttr = ($nodeName + ".rotate" + $axis);
			break;
		case "Trans":
			$currentAttr = ($nodeName + ".translate" + $axis);
			break;
		case "Scale":
			$currentAttr = ($nodeName + ".scale" + $axis);
			break;
	}
	float $curVal = `getAttr $currentAttr`;
	string $name = ($transformType + "Limit" + $axis);

	// check whether the right or the left button was hit.
	// Transfer the value to the corresponding side/limit value
	// check whether the value is a real min/max or whether the
	// values have to be swapped.
	//
	// We are careful to set the actual limit attribute value based
	// on the corresponding transform attribute value, rather than
	// using the value returned by floatField -query, since the latter
	// has less precision.
	//
	if ($minMax == "min")
	{
		string $attrMin = $nodeName+".min"+$transformType+$axis+"Limit";
		setAttr $attrMin $curVal;
		floatField -e -v $curVal ($parent + "|min" + $name + "Field");
        checkBox -e -v 1 ($parent + "|min" + $name + "CheckBox");
		checkLimitValue $transformType $axis $nodeName 0 $parent;
	} else {
		string $attrMax = $nodeName+".max"+$transformType+$axis+"Limit";
		setAttr $attrMax $curVal;
		floatField -e -v $curVal ($parent + "|max" + $name + "Field");
        checkBox -e -v 1 ($parent + "|max" + $name + "CheckBox");
		checkLimitValue $transformType $axis $nodeName 0 $parent;
	}
}


//  Procedure Name: 	AEupdateWorldSpacePivots
//
//	updates the widgets, as soon as any transformation value of 
//	the object changes.
//
global proc AEupdateWorldPivots ( string $nodeName )
{
	float $worldRotatePivot[] = `xform -ws -q -rp $nodeName`;
	float $worldScalePivot[] = `xform -ws -q -sp $nodeName`;

	floatField -e -v $worldRotatePivot[0] wrpX;
	floatField -e -v $worldRotatePivot[1] wrpY;
	floatField -e -v $worldRotatePivot[2] wrpZ;

	floatField -e -v $worldScalePivot[0] wspX;
	floatField -e -v $worldScalePivot[1] wspY;
	floatField -e -v $worldScalePivot[2] wspZ;
}


//  Procedure Name: 	AEworldSpacePivotsReplace
//
//	Hooks up the world space pivot widgets
//
global proc AEworldSpacePivotsReplace ( string $rotatePivot )
{
	string $nodeAttrName[];
	tokenize($rotatePivot, ".", $nodeAttrName);
	string $nodeName = $nodeAttrName[0];

	floatField -e -cc ("AEsetWorldPivots "+$nodeName )
		wrpX;
	floatField -e -cc ("AEsetWorldPivots "+$nodeName )
		wrpY;
	floatField -e -cc ("AEsetWorldPivots "+$nodeName )
		wrpZ;
	
	floatField -e -cc ("AEsetWorldPivots "+$nodeName )
		wspX;
	floatField -e -cc ("AEsetWorldPivots "+$nodeName )
		wspY;
	floatField -e -cc ("AEsetWorldPivots "+$nodeName )
		wspZ;
	
	scriptJob -p "wrpX" -rp 
			-attributeChange ($nodeName+".worldMatrix") 
				( "AEupdateWorldPivots "+$nodeName );
	scriptJob -p "wrpX" 
			-attributeChange ($nodeName+".translate") 
				( "AEupdateWorldPivots "+$nodeName );
	scriptJob -p "wrpX" 
			-attributeChange ($nodeName+".rotatePivotTranslate") 
				( "AEupdateWorldPivots "+$nodeName );
	scriptJob -p "wrpX"
			-attributeChange ($nodeName+".rotatePivot") 
				( "AEupdateWorldPivots "+$nodeName );
	scriptJob -p "wrpX"
			-attributeChange ($nodeName+".scalePivot") 
				( "AEupdateWorldPivots "+$nodeName );

	AEupdateWorldPivots $nodeName;
}


//  Procedure Name: 	AEworldSpacePivotsNew
//
// 	Creates the widgets to show world space positions of pivots
//
global proc AEworldSpacePivotsNew ( string $rotatePivot )
{
	string $nodeName[];
	tokenize($rotatePivot, ".", $nodeName);

	setUITemplate -pst attributeEditorPresetsTemplate;
	
	rowLayout -nc 4 -cat 1 right 0 -cat 2 both 0
		-cat 3 both 0 -cat 4 both 0
		WorldRotatePivotGrp;
		text -label (uiRes("m_AEtransformNoScroll.kWorldRotatePivot"))  WorldRotatePivotText;
		floatField wrpX;
		floatField wrpY;
		floatField wrpZ;
		setParent ..;
	
	rowLayout -nc 4 -cat 1 right 0 -cat 2 both 0
		-cat 3 both 0 -cat 4 both 0
		WorldScalePivotGrp;
		text -label (uiRes("m_AEtransformNoScroll.kWorldScalePivot"))  WorldScalePivotText;
		floatField wspX;
		floatField wspY;
		floatField wspZ;
		setParent ..;
	
	setUITemplate -ppt;
	
	AEworldSpacePivotsReplace $rotatePivot;
}


//  Procedure Name: 	AEsetWorldPivots
//
//	sets the transformation values of the object according to the 
//	entered values in the fields.
//
global proc AEsetWorldPivots ( string $nodeName )
{

	float $rpX = `floatField -q -v wrpX`;
	float $rpY = `floatField -q -v wrpY`;
	float $rpZ = `floatField -q -v wrpZ`;

	float $spX = `floatField -q -v wspX`;
	float $spY = `floatField -q -v wspY`;
	float $spZ = `floatField -q -v wspZ`;

	xform -ws -rp $rpX $rpY $rpZ $nodeName;
	xform -ws -sp $spX $spY $spZ $nodeName;
}


//  Procedure Name: 	AEupdateLocalSpacePivots
//
//	updates the widgets, as soon as any transformation value of 
//	the object changes.
//
global proc AEupdateLocalPivots ( string $nodeName )
{
	float $localRotatePivot[] = `xform -q -rp $nodeName`;
	float $localScalePivot[] = `xform -q -sp $nodeName`;

	floatField -e -v $localRotatePivot[0] lrpX;
	floatField -e -v $localRotatePivot[1] lrpY;
	floatField -e -v $localRotatePivot[2] lrpZ;

	floatField -e -v $localScalePivot[0] lspX;
	floatField -e -v $localScalePivot[1] lspY;
	floatField -e -v $localScalePivot[2] lspZ;
}


//  Procedure Name: 	AElocalSpacePivotsReplace
//
//	Hooks up the local space pivot widgets
//
global proc AElocalSpacePivotsReplace ( string $rotatePivot )
{
	string $nodeAttrName[];
	tokenize($rotatePivot, ".", $nodeAttrName);
	string $nodeName = $nodeAttrName[0];

	floatField -e -cc ("AEsetLocalPivots "+$nodeName )
		lrpX;
	floatField -e -cc ("AEsetLocalPivots "+$nodeName )
		lrpY;
	floatField -e -cc ("AEsetLocalPivots "+$nodeName )
		lrpZ;
	
	floatField -e -cc ("AEsetLocalPivots "+$nodeName )
		lspX;
	floatField -e -cc ("AEsetLocalPivots "+$nodeName )
		lspY;
	floatField -e -cc ("AEsetLocalPivots "+$nodeName )
		lspZ;
	
	scriptJob -p "lrpX" -rp 
			-attributeChange ($nodeName+".matrix") 
				( "AEupdateLocalPivots "+$nodeName );
	scriptJob -p "lrpX" 
			-attributeChange ($nodeName+".translate") 
				( "AEupdateLocalPivots "+$nodeName );
	scriptJob -p "lrpX" 
			-attributeChange ($nodeName+".rotatePivotTranslate") 
				( "AEupdateLocalPivots "+$nodeName );
	scriptJob -p "lrpX"
			-attributeChange ($nodeName+".rotatePivot") 
				( "AEupdateLocalPivots "+$nodeName );
	scriptJob -p "lrpX"
			-attributeChange ($nodeName+".scalePivot") 
				( "AEupdateLocalPivots "+$nodeName );

	AEupdateLocalPivots $nodeName;
}


//  Procedure Name: 	AElocalSpacePivotsNew
//
// 	Creates the widgets to show local space positions of pivots
//
global proc AElocalSpacePivotsNew ( string $rotatePivot )
{
	string $nodeName[];
	tokenize($rotatePivot, ".", $nodeName);

	setUITemplate -pst attributeEditorPresetsTemplate;
	
	rowLayout -nc 4 -cat 1 right 0 -cat 2 both 0
		-cat 3 both 0 -cat 4 both 0
		LocalRotatePivotGrp;
		text -label (uiRes("m_AEtransformNoScroll.kLocalRotatePivot"))  LocalRotatePivotText;
		floatField lrpX;
		floatField lrpY;
		floatField lrpZ;
		setParent ..;
	
	rowLayout -nc 4 -cat 1 right 0 -cat 2 both 0
		-cat 3 both 0 -cat 4 both 0
		LocalScalePivotGrp;
		text -label (uiRes("m_AEtransformNoScroll.kLocalScalePivot"))  LocalScalePivotText;
		floatField lspX;
		floatField lspY;
		floatField lspZ;
		setParent ..;
	
	setUITemplate -ppt;
	
	AElocalSpacePivotsReplace $rotatePivot;
}


//  Procedure Name: 	AEsetLocalPivots
//
//	sets the transformation values of the object according to the 
//	entered values in the fields.
//
global proc AEsetLocalPivots ( string $nodeName )
{
	float $rpX = `floatField -q -v lrpX`;
	float $rpY = `floatField -q -v lrpY`;
	float $rpZ = `floatField -q -v lrpZ`;

	float $spX = `floatField -q -v lspX`;
	float $spY = `floatField -q -v lspY`;
	float $spZ = `floatField -q -v lspZ`;

	xform -rp $rpX $rpY $rpZ $nodeName;
	xform -sp $spX $spY $spZ $nodeName;
}

global proc
AEnewSpecifiedManip (string $specifiedManipLocation)
{
	setUITemplate -pst attributeEditorTemplate;

	attrNavigationControlGrp
		-label (uiRes("m_AEtransformNoScroll.kManipHistoryNode")) 
		-attribute $specifiedManipLocation
		specifiedManipLocationControl;

	setUITemplate -ppt;
}

global proc
AEreplaceSpecifiedManip (string $specifiedManipLocation)
{
	attrNavigationControlGrp -edit
		-attribute $specifiedManipLocation
		specifiedManipLocationControl;
}

//  Procedure Name: 	AEtransformNoScroll
//
global proc AEtransformNoScroll ( string $nodeName )
{
	if (`objectType $nodeName` == "joint")
	{
		editorTemplate -suppress "displayRotatePivot";
		editorTemplate -suppress "displayScalePivot";
		editorTemplate -suppress "rotatePivot";
		editorTemplate -suppress "scalePivot";
	} else {
		editorTemplate -beginLayout (uiRes("m_AEtransformNoScroll.kPivots")) ;
			editorTemplate -beginNoOptimize;
			editorTemplate -addControl "displayRotatePivot";
			editorTemplate -addControl "displayScalePivot";
			editorTemplate -endNoOptimize;
			
			editorTemplate -beginLayout (uiRes("m_AEtransformNoScroll.kLocalSpace")) ;
				editorTemplate -callCustom "AElocalSpacePivotsNew"
						"AElocalSpacePivotsReplace"
						"rotatePivot";
			editorTemplate -endLayout;
	
			editorTemplate -beginLayout (uiRes("m_AEtransformNoScroll.kWorldSpace"))  -collapse 0;
				editorTemplate -callCustom "AEworldSpacePivotsNew"
						"AEworldSpacePivotsReplace"
						"rotatePivot";
			editorTemplate -endLayout;
		editorTemplate -endLayout;
	}

	editorTemplate -beginLayout (uiRes("m_AEtransformNoScroll.kLimitInformation")) ;
	editorTemplate -beginLayout (uiRes("m_AEtransformNoScroll.kTranslate")) ;
		editorTemplate -callCustom "AElimitsLabelNew"
					"AElimitsLabelReplace"
					"minTransXLimitEnable";
		editorTemplate -callCustom 
				("AElimitsNew \"Trans\" \"X\"")
				("AElimitsReplace \"Trans\" \"X\"")
				"minTransXLimit";
		editorTemplate -callCustom 
				("AElimitsNew \"Trans\" \"Y\"")
				("AElimitsReplace \"Trans\" \"Y\"")
				"minTransYLimit";
		editorTemplate -callCustom 
				("AElimitsNew \"Trans\" \"Z\"")
				("AElimitsReplace \"Trans\" \"Z\"")
				"minTransZLimit";
	editorTemplate -endLayout;

	editorTemplate -beginLayout (uiRes("m_AEtransformNoScroll.kRotate"))  -collapse 0;
		editorTemplate -callCustom "AElimitsLabelNew"
					"AElimitsLabelReplace"
					"minRotXLimitEnable";
		editorTemplate -callCustom 
				("AElimitsNew \"Rot\" \"X\"")
				("AElimitsReplace \"Rot\" \"X\"")
				"minRotXLimit";
		editorTemplate -callCustom 
				("AElimitsNew \"Rot\" \"Y\"")
				("AElimitsReplace \"Rot\" \"Y\"")
				"minRotYLimit";
		editorTemplate -callCustom 
				("AElimitsNew \"Rot\" \"Z\"")
				("AElimitsReplace \"Rot\" \"Z\"")
				"minRotZLimit";
	editorTemplate -endLayout;

	editorTemplate -beginLayout (uiRes("m_AEtransformNoScroll.kScale")) ;
		editorTemplate -callCustom "AElimitsLabelNew"
					"AElimitsLabelReplace"
					"minScaleXLimitEnable";
		editorTemplate -callCustom 
				("AElimitsNew \"Scale\" \"X\"")
				("AElimitsReplace \"Scale\" \"X\"")
				"minScaleXLimit";
		editorTemplate -callCustom 
				("AElimitsNew \"Scale\" \"Y\"")
				("AElimitsReplace \"Scale\" \"Y\"")
				"minScaleYLimit";
		editorTemplate -callCustom 
				("AElimitsNew \"Scale\" \"Z\"")
				("AElimitsReplace \"Scale\" \"Z\"")
				"minScaleZLimit";
	editorTemplate -endLayout;
	editorTemplate -endLayout;

	editorTemplate -beginLayout (uiRes("m_AEtransformNoScroll.kDisplay")) ;
		editorTemplate -beginNoOptimize;
		editorTemplate -addControl "displayHandle";
		editorTemplate -addControl "displayLocalAxis";
		editorTemplate -endNoOptimize;

		editorTemplate -label (uiRes("m_AEtransformNoScroll.kSelectionHandle"))  -addControl "selectHandle";
		editorTemplate -addControl "showManipDefault";
		editorTemplate -callCustom AEnewSpecifiedManip AEreplaceSpecifiedManip "specifiedManipLocation";

		// include/call base class/node attributes
		AEdagNodeCommon $nodeName;

	editorTemplate -endLayout;

	// include/call base class/node attributes
	AEdagNodeInclude $nodeName;

	//suppressed Attributes
	editorTemplate -suppress "minTransLimit";
	editorTemplate -suppress "maxTransLimit";
	editorTemplate -suppress "minRotLimit";
	editorTemplate -suppress "maxRotLimit";
	editorTemplate -suppress "minScaleLimit";
	editorTemplate -suppress "maxScaleLimit";
	editorTemplate -suppress "minTransLimitEnable";
	editorTemplate -suppress "minTransYLimitEnable";
	editorTemplate -suppress "minTransZLimitEnable";
	editorTemplate -suppress "maxTransLimitEnable";
	editorTemplate -suppress "maxTransXLimitEnable";
	editorTemplate -suppress "maxTransYLimitEnable";
	editorTemplate -suppress "maxTransZLimitEnable";
	editorTemplate -suppress "minRotLimitEnable";
	editorTemplate -suppress "minRotYLimitEnable";
	editorTemplate -suppress "minRotZLimitEnable";
	editorTemplate -suppress "maxRotLimitEnable";
	editorTemplate -suppress "maxRotXLimitEnable";
	editorTemplate -suppress "maxRotYLimitEnable";
	editorTemplate -suppress "maxRotZLimitEnable";
	editorTemplate -suppress "minScaleLimitEnable";
	editorTemplate -suppress "minScaleYLimitEnable";
	editorTemplate -suppress "minScaleZLimitEnable";
	editorTemplate -suppress "maxScaleLimitEnable";
	editorTemplate -suppress "maxScaleXLimitEnable";
	editorTemplate -suppress "maxScaleYLimitEnable";
	editorTemplate -suppress "maxScaleZLimitEnable";
	editorTemplate -suppress "scalePivot";
	editorTemplate -suppress "scalePivotTranslate";
	editorTemplate -suppress "rotatePivotTranslate";
	editorTemplate -suppress "newTransMinusRotatePivot";
	editorTemplate -suppress "orient";
	editorTemplate -suppress "geometry";
	editorTemplate -suppress "dynamics";
	editorTemplate -suppress "xformMatrix";
}

