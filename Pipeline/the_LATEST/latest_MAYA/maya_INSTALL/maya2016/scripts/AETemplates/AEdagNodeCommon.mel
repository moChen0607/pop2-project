// Copyright (C) 1997-2014 Autodesk, Inc., and/or its licensors.
// All rights reserved.
//
// The coded instructions, statements, computer programs, and/or related
// material (collectively the "Data") in these files contain unpublished
// information proprietary to Autodesk, Inc. ("Autodesk") and/or its licensors,
// which is protected by U.S. and Canadian federal copyright law and by
// international treaties.
//
// The Data is provided for use exclusively by You. You have the right to use,
// modify, and incorporate this Data into other products for purposes authorized 
// by the Autodesk software license agreement, without fee.
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND. AUTODESK
// DOES NOT MAKE AND HEREBY DISCLAIMS ANY EXPRESS OR IMPLIED WARRANTIES
// INCLUDING, BUT NOT LIMITED TO, THE WARRANTIES OF NON-INFRINGEMENT,
// MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE, OR ARISING FROM A COURSE 
// OF DEALING, USAGE, OR TRADE PRACTICE. IN NO EVENT WILL AUTODESK AND/OR ITS
// LICENSORS BE LIABLE FOR ANY LOST REVENUES, DATA, OR PROFITS, OR SPECIAL,
// DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES, EVEN IF AUTODESK AND/OR ITS
// LICENSORS HAS BEEN ADVISED OF THE POSSIBILITY OR PROBABILITY OF SUCH DAMAGES.

//
//  Procedure Name:
//	AEdagNodeCommon
//
//  Description:
//	Creates the attribute editor controls for the dagObjectNode
//
//  Input Value:
//	nodeName
//
//  Output Value:
//	None
//
global proc AEreplaceBbox( string $minBox, string $maxBox )
{
	attrFieldGrp -edit
		-label (uiRes("m_AEdagNodeCommon.kBoundingBoxMin")) 
		-attribute $minBox
		bboxMin;

	attrFieldGrp -edit
		-label (uiRes("m_AEdagNodeCommon.kBoundingBoxMax")) 
		-attribute $maxBox
		bboxMax;
	
	string $parent = `setParent -q`;
	string $tokens[];
	tokenize( $minBox,".", $tokens);
	string $node = $tokens[0];
		
	scriptJob -runOnce true
		-ac ($node+".matrix")
		("setParent "+$parent+";AEreplaceBbox(\""+$minBox+"\",\""+$maxBox+"\")");
}	
	
	
global proc AEnewBbox( string $minBox, string $maxBox )
{
	// Create custom UI for the bounding box attributes.
	// This needs to be done because they don't send
	// attribute changed messages, and must instead rely
	// on another attribute to update them.
	//
	attrFieldGrp bboxMin;
	attrFieldGrp bboxMax;
	
	AEreplaceBbox( $minBox, $maxBox );
}

global proc AEupdateGhostFrames(string $plug)
{
	string $buff[];
	string $frameString = `textFieldGrp -q -tx customFramesText`;
	tokenize($frameString,",",$buff);

	int $frameCount = size($buff);
	string $cmdString = ("setAttr "+$plug+" -typ \"Int32Array\" "+$frameCount);
	for ($ii = 0; $ii < $frameCount; $ii++) {
		int $frame = $buff[$ii];
		$cmdString += (" "+$frame);
	}
	evalEcho $cmdString;
}

global proc AEghostFramesNew(string $plug)
{
	setUITemplate -pst attributeEditorTemplate;
	textFieldGrp -label (uiRes("m_AEdagNodeCommon.kCustomFrames"))  
		-annotation (uiRes("m_AEdagNodeCommon.kEntertheframenumbersseparatedAnnot"))  customFramesText;
	AEghostFramesReplace($plug);
	setUITemplate -ppt;
}

global proc AEghostFramesReplace(string $plug)
{
	int $frames[] = `getAttr $plug`;
	int $frameCount = size($frames);
	string $frameString;
	if ($frameCount > 0) {
		for ($ii = 0; $ii < $frameCount; $ii++) {
			$frameString += $frames[$ii];
			if ($ii != ($frameCount-1)) {
				$frameString += ",";
			}
		}
	}
	textFieldGrp -e -tx $frameString customFramesText;
				 
	textFieldGrp -e -cc ("AEupdateGhostFrames "+$plug) customFramesText;
}

global proc AEcheckGhostControl(string $nodeName)
{
	string $long[] = `ls -long $nodeName`;
	int $ghostControl = `getAttr ($long[0]+".ghostingControl")`;
	int $dimRange = 0;
	int $dimPrePost = 0;
	int $dimFrames = 0;
	int $dimGhostDriver = 0;
	switch ($ghostControl) {
	case 0:
		// global preferences, dim everything
		$dimRange = 1;
		$dimPrePost = 1;
		$dimFrames = 1;
		$dimGhostDriver = 1;
		break;
	case 1:
		// custom frames
		$dimPrePost = 1;
		$dimRange = 1;
		$dimGhostDriver = 1;
		break;
	case 2:
		$dimGhostDriver = 1;
	case 3:
		// custom pre, post
		$dimRange = 1;
		$dimFrames = 1;
		break;
	case 4:
		// keyframes
		$dimPrePost = 1;
		$dimFrames = 1;
		break;
	}
	if (`textFieldGrp -exists customFramesText`) {
		textFieldGrp -e -enable (! $dimFrames) customFramesText;
	}
	editorTemplate -dimControl $nodeName "ghostPreSteps" $dimPrePost;
	editorTemplate -dimControl $nodeName "ghostPostSteps" $dimPrePost;
	editorTemplate -dimControl $nodeName "ghostStepSize" $dimPrePost;
	editorTemplate -dimControl $nodeName "ghostRangeStart" $dimRange;
	editorTemplate -dimControl $nodeName "ghostRangeEnd" $dimRange;	
	editorTemplate -dimControl $nodeName "ghostDriver"   $dimGhostDriver;
	editorTemplate -dimControl $nodeName "ghostColorPre"   0;
	editorTemplate -dimControl $nodeName "ghostColorPreA"  0;
	editorTemplate -dimControl $nodeName "ghostColorPost"  0;
	editorTemplate -dimControl $nodeName "ghostColorPostA" 0;
}

global proc AEdagNodeCommonRefreshOutliners()
{
	string $eds[] = `lsUI -editors`;
	for ( $ed in $eds )
	{
		if ( `outlinerEditor -exists $ed` )
			outlinerEditor -e -refresh $ed;
	}
}

global proc AEhiddenInOutlinerNew(string $plug)
{
	setUITemplate -pst attributeEditorTemplate;
	checkBoxGrp -label1 (uiRes("m_AEdagNodeCommon.kHiddenInOutliner")) hiddenInOutlinerCheck;
	AEhiddenInOutlinerReplace($plug);
	setUITemplate -ppt;
}

global proc AEhiddenInOutlinerReplace(string $plug)
{
	int $v = `getAttr $plug`;
	checkBoxGrp -e -value1 $v hiddenInOutlinerCheck;
	checkBoxGrp -e -cc ("setAttr " + $plug + " #1;AEdagNodeCommonRefreshOutliners();") hiddenInOutlinerCheck;
}

global proc AEuseOutlinerColorNew(string $plug)
{
	setUITemplate -pst attributeEditorTemplate;
	checkBoxGrp -label1 (uiRes("m_AEdagNodeCommon.kUseOutlinerColor")) useOutlinerColorCheck;
	AEuseOutlinerColorReplace($plug);
	setUITemplate -ppt;
}

global proc AEuseOutlinerColorReplace(string $plug)
{
	int $v = `getAttr $plug`;
	checkBoxGrp -e -value1 $v useOutlinerColorCheck;
	checkBoxGrp -e -cc ("setAttr " + $plug + " #1;AEdagNodeCommonRefreshOutliners();") useOutlinerColorCheck;
}

global proc AEoutlinerColorNew(string $plug)
{
	setUITemplate -pst attributeEditorTemplate;
	colorSliderGrp -label (uiRes("m_AEdagNodeCommon.kOutlinerColor")) outlinerColorGrp;
	AEoutlinerColorReplace($plug);
	setUITemplate -ppt;
}

global proc AEoutlinerColorSet( string $plug )
{
	float $rgb[] = `colorSliderGrp -q -rgbValue outlinerColorGrp`;
	setAttr $plug -type float3 $rgb[0] $rgb[1] $rgb[2];
	AEdagNodeCommonRefreshOutliners();
}

global proc AEoutlinerColorReplace(string $plug)
{
	float $v[] = `getAttr $plug`;
	colorSliderGrp -e -rgbValue $v[0] $v[1] $v[2] outlinerColorGrp;
	colorSliderGrp -e -cc ( "AEoutlinerColorSet " + $plug ) -dc ( "AEoutlinerColorSet " + $plug ) outlinerColorGrp;
}

global proc AEdagNodeCommon ( string $nodeName ) 
{
	editorTemplate -addControl "visibility";
	editorTemplate -addControl "template";
	editorTemplate -label (uiRes("m_AEdagNodeCommon.kLODVisibility"))  -addControl "lodVisibility";

	string $nodeType = `objectType $nodeName`;

	editorTemplate -beginNoOptimize;
	if (`attributeExists "displayHWEnvironment" $nodeName`)
		editorTemplate -label (uiRes("m_AEdagNodeCommon.kEnvironmentMapTexture"))  
			-addControl "displayHWEnvironment";			

	if ($nodeType == "nurbsSurface" ||
		// $nodeType == "subdiv" || -- not currently supported in hw renderer
		$nodeType == "mesh")
	{
		editorTemplate -label (uiRes("m_AEdagNodeCommon.kIgnoreHardwareShader"))  
				-addControl "ignoreHwShader";
	}
	else
		editorTemplate -suppress "ignoreHwShader";			
	editorTemplate -endNoOptimize;

	string $isField[] = `ls -type field $nodeName`;

	// Make sure we test for all derived camera types
	if ($nodeType == "spotLight" ||
		$nodeType == "directionalLight" ||
		$nodeType == "areaLight" ||
		$nodeType == "volumeLight" ||
		`objectType -isa "camera" $nodeName`) { 
		// Note: ambient and point light shapes are drawn as icons, i.e. they
		// have a fixed size.  Therefore scaling these shapes does not apply.
		//
		editorTemplate -addControl "locatorScale"; 
	}

	if ($nodeType == "imagePlane" ) { 
		editorTemplate -addControl "frameVisibility"; 
	}

	editorTemplate -label (uiRes("m_AEdagNodeCommon.kHideOnPlayback"))  -addControl "hideOnPlayback";
	
	if ($nodeType == "lattice" ||
		$nodeType == "baseLattice" ||
		$nodeType == "nurbsSurface" ||
		$nodeType == "subdiv" ||
		$nodeType == "nurbsCurve" ||
		$nodeType == "fluidShape" ||
		$nodeType == "particle" ||
		$nodeType == "nParticle" ||
		$nodeType == "nCloth" ||
		$nodeType == "nRigid" ||
		$nodeType == "mesh"){
		editorTemplate -addControl "intermediateObject";
	} else {
		editorTemplate -suppress "intermediateObject";
	}

	editorTemplate -interruptOptimize;
	editorTemplate -callCustom "AEhiddenInOutlinerNew" "AEhiddenInOutlinerReplace" "hiddenInOutliner";
	editorTemplate -callCustom "AEuseOutlinerColorNew" "AEuseOutlinerColorReplace" "useOutlinerColor";
	editorTemplate -callCustom "AEoutlinerColorNew" "AEoutlinerColorReplace" "outlinerColor";
	
	if ($nodeType == "nurbsSurface" ||
		$nodeType == "mesh" ||
		$nodeType == "particle" ||
		$nodeType == "nParticle")
	{				
		editorTemplate -label (uiRes("m_AEdagNodeCommon.kHardwareFogMultiplier")) 
				-addControl "hardwareFogMultiplier";
	}
	else {
		editorTemplate -suppress "hardwareFogMultiplier";		
	}	

	if ($nodeType != "ikHandle" &&
		size($isField) != 1 &&
		$nodeType != "pointEmitter" &&
		$nodeType != "particle" &&
		$nodeType != "nParticle")
	{
		editorTemplate -beginLayout (uiRes("m_AEdagNodeCommon.kGhostingInformation")) ;
		editorTemplate -addControl "ghosting";
		editorTemplate -addControl "ghostingControl" "AEcheckGhostControl";
		editorTemplate -label (uiRes("m_AEdagNodeCommon.kPreSteps"))  -addControl "ghostPreSteps";
		editorTemplate -label (uiRes("m_AEdagNodeCommon.kPostSteps"))  -addControl "ghostPostSteps";
		editorTemplate -label (uiRes("m_AEdagNodeCommon.kStepSize"))  -addControl "ghostStepSize";
		editorTemplate -callCustom "AEghostFramesNew" "AEghostFramesReplace" "ghostFrames";
		editorTemplate -label (uiRes("m_AEdagNodeCommon.kStartFrame"))  -addControl "ghostRangeStart";
		editorTemplate -label (uiRes("m_AEdagNodeCommon.kEndFrame"))  -addControl "ghostRangeEnd";
		editorTemplate -label (uiRes("m_AEdagNodeCommon.kPreFrameColor"))  -addControl "ghostColorPre";
		editorTemplate -label (uiRes("m_AEdagNodeCommon.kPreFrameAlpha"))  -addControl "ghostColorPreA";
		editorTemplate -label (uiRes("m_AEdagNodeCommon.kPostFrameColor")) -addControl "ghostColorPost";
		editorTemplate -label (uiRes("m_AEdagNodeCommon.kPostFrameAlpha")) -addControl "ghostColorPostA";
		editorTemplate -label (uiRes("m_AEdagNodeCommon.kGhostDriver"))  -addControl "ghostDriver";
		editorTemplate -suppress "ghostCustomSteps";
		editorTemplate -endLayout;
	} else {
		editorTemplate -suppress "ghosting";
		editorTemplate -suppress "ghostingControl";
		editorTemplate -suppress "ghostPreSteps";
		editorTemplate -suppress "ghostPostSteps";
		editorTemplate -suppress "ghostStepSize";
		editorTemplate -suppress "ghostFrames";
		editorTemplate -suppress "ghostRangeStart";
		editorTemplate -suppress "ghostRangeEnd";
		editorTemplate -suppress "ghostColorPre";
		editorTemplate -suppress "ghostColorPreA";
		editorTemplate -suppress "ghostColorPost";
		editorTemplate -suppress "ghostColorPostA";
		editorTemplate -suppress "ghostDriver";
		editorTemplate -suppress "ghostFrames";
		editorTemplate -suppress "ghostCustomSteps";
	}
	
	editorTemplate -beginLayout (uiRes("m_AEdagNodeCommon.kBoundingBoxInformation")) ;
		editorTemplate -suppress "boundingBox";
		editorTemplate -callCustom AEnewBbox AEreplaceBbox "boundingBoxMin" "boundingBoxMax";
	editorTemplate -endLayout;

	editorTemplate -beginLayout (uiRes("m_AEdagNodeCommon.kDrawingOverrides"))  -collapse 1;
		AEdrawInfo	"overrideDisplayType"
					"overrideLevelOfDetail"
					"overrideShading"
					"overrideTexturing"
					"overridePlayback"
					"overrideEnabled"
					"overrideVisibility"
					"overrideRGBColors"
					"overrideColor"
					"overrideColorRGB";
	editorTemplate -endLayout;
	
	editorTemplate -beginLayout (uiRes("m_AEdagNodeCommon.kSelection")) -collapse 1;
		editorTemplate -addControl "selectionChildHighlighting";
	editorTemplate -endLayout;

	// suppressed Attributes
	editorTemplate -suppress "drawOverride";
	editorTemplate -suppress "useObjectColor";
	editorTemplate -suppress "objectColor";
	editorTemplate -suppress "objectColorRGB";
	editorTemplate -suppress "center";
	editorTemplate -suppress "matrix";
	editorTemplate -suppress "inverseMatrix";
	editorTemplate -suppress "worldMatrix";
	editorTemplate -suppress "worldInverseMatrix";
	editorTemplate -suppress "parentMatrix";
	editorTemplate -suppress "parentInverseMatrix";
	editorTemplate -suppress "instObjGroups";
    editorTemplate -suppress "containerEdits";
	editorTemplate -suppress "wireColorRGB";
	AEcontainerNodeSuppress $nodeName;
}

