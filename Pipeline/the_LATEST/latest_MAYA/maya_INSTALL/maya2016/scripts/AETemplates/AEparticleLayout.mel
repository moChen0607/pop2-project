// Copyright (C) 1997-2014 Autodesk, Inc., and/or its licensors.
// All rights reserved.
//
// The coded instructions, statements, computer programs, and/or related
// material (collectively the "Data") in these files contain unpublished
// information proprietary to Autodesk, Inc. ("Autodesk") and/or its licensors,
// which is protected by U.S. and Canadian federal copyright law and by
// international treaties.
//
// The Data is provided for use exclusively by You. You have the right to use,
// modify, and incorporate this Data into other products for purposes authorized 
// by the Autodesk software license agreement, without fee.
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND. AUTODESK
// DOES NOT MAKE AND HEREBY DISCLAIMS ANY EXPRESS OR IMPLIED WARRANTIES
// INCLUDING, BUT NOT LIMITED TO, THE WARRANTIES OF NON-INFRINGEMENT,
// MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE, OR ARISING FROM A COURSE 
// OF DEALING, USAGE, OR TRADE PRACTICE. IN NO EVENT WILL AUTODESK AND/OR ITS
// LICENSORS BE LIABLE FOR ANY LOST REVENUES, DATA, OR PROFITS, OR SPECIAL,
// DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES, EVEN IF AUTODESK AND/OR ITS
// LICENSORS HAS BEEN ADVISED OF THE POSSIBILITY OR PROBABILITY OF SUCH DAMAGES.

//
//  Procedure Name:
//	AEparticleTemplate
//
//  Description Name;
//	Creates the attribute editor controls for the particle Node
//
//  Input Value:
//	nodeName 
//
//  Output Value:
//	None
// 


global string	$gAEgenericColumnLayout = "";
global string	$gAEgenericFrameLayout = "";


//  ========== particleColorAddAttrCB ==========
//
//  Description:
//      User has selected "Add Attribute" in the Color Dialog,
//		so add the selected attribute(s).
//
global proc particleColorAddAttrCB( string $nodeName )
{
	global string $dynParticleSaveParent;

	setParent particleColorWin;

	int $selectedRGB = `checkBox -q -v particleColorPerObjCB`;
	int $selectedRGBPP = `checkBox -q -v particleColorPerPartCB`;

    string  $objName = $nodeName;

	// If the attribute already exists, don't add another.
	//
	int $rgbExists = 0;
	int $rgbPPExists = 0;

	string 	$currAttrs[] = `listAttr $objName`;
	int		$currAttrsCnt = size( $currAttrs );

	for ($i = 0; $i < $currAttrsCnt; $i++)
	{
		if ($selectedRGB && $currAttrs[$i] == "rgb")
		{
			$rgbExists = 1;
		}
		if ($selectedRGBPP && $currAttrs[$i] == "rgbPP")
		{
			$rgbExists = 1;
		}
	}

	if ($selectedRGB && !$rgbExists)
	{
		evalEcho(("addAttr -is true -ln \"colorRed\" -dv 0.0 -at double " + $objName));
		evalEcho(("setAttr -keyable true " + $objName + ".colorRed"));
		evalEcho(("addAttr -is true -ln \"colorGreen\" -dv 0.0 -at double " + $objName));
		evalEcho(("setAttr -keyable true " + $objName + ".colorGreen"));
		evalEcho(("addAttr -is true -ln \"colorBlue\" -dv 0.0 -at double " + $objName));
		evalEcho(("setAttr -keyable true " + $objName + ".colorBlue"));
	}

	if ($selectedRGBPP && !$rgbPPExists)
	{
		evalEcho(("addAttr -ln \"rgbPP\" -dt vectorArray " + $objName));
    	evalEcho(("addAttr -ln \"rgbPP0\" -dt vectorArray " + $objName));
	}

	deleteUI -window particleColorWin;

}  // particleColorAddAttrCB //



//  ========== particleSelColorAttrCB ==========
//
//  Description:
//      User has chosen to add a color attribute, so enable the
//		"Add" button in the dialog.
//
global proc particleSelColorAttrCB()
{
	setParent particleColorWin;

	button -e -enable true particleColorAddButton;
}


// ****************************************************************
//
//          ADD COLOR, OPACITY, PROCEDURES
//
// ****************************************************************

global proc resetParticleAddButton( string $perObject,  
				string $perParticle,
				string $buttonName,
				string $nodeName)
{
	global string $dynParticleSaveParent;

	// If both attributes are now in existence, dim the
	// "Add <whatever>" button.
	//
	int $isPerObject = 0;
	int $isPerParticle = 0;

    string  $objName = $nodeName;
	string	$currAttrs[] = `listAttr $objName`;
	int		$currAttrsCnt = size( $currAttrs );

	for ($i = 0; $i < $currAttrsCnt; $i++)
	{
		if ($currAttrs[$i] == $perObject)
		{
			$isPerObject = 1;
		}
		if ($currAttrs[$i] == $perParticle)
		{
			$isPerParticle = 1;
		}
	}

	if ($isPerObject && $isPerParticle)
	{
		button -e -enable false $buttonName;
	}
	else
	{
		button -e -enable true $buttonName;
	}

}	// resetParticleAddButton



//  ========== particleOpacityAddAttrCB ==========
//
//  Description:
//      User has selected "Add Attribute" in the Opacity Dialog,
//		so add the selected attribute(s).
//
global proc particleOpacityAddAttrCB( string $nodeName )
{
	global string $dynParticleSaveParent;

	setParent particleOpacityWin;

	int $selectedOpacity = `checkBox -q -v particleOpacityPerObjCB`;
	int $selectedOpacityPP = `checkBox -q -v particleOpacityPerPartCB`;

    string  $objName = $nodeName ;

	// If the attribute already exists, don't add another.
	//
	int $opacityExists = 0;
	int $opacityPPExists = 0;

	string	$currAttrs[] = `listAttr $objName`;
	int		$currAttrsCnt = size( $currAttrs );

	for ($i = 0; $i < $currAttrsCnt; $i++)
	{
		if ($selectedOpacity && $currAttrs[$i] == "opacity")
		{
			$opacityExists = 1;
		}
		if ($selectedOpacityPP && $currAttrs[$i] == "opacityPP")
		{
			$opacityPPExists = 1;
		}
	}

	if ($selectedOpacity && !$opacityExists)
	{
		evalEcho(("addAttr -is true -ln \"opacity\" -at double " + $objName));
		evalEcho(("setAttr -keyable true " + $objName + ".opacity"));
		evalEcho(("setAttr " + $objName + ".opacity 1.0"));
	}

	if ($selectedOpacityPP && !$opacityPPExists)
	{
		evalEcho(("addAttr -ln \"opacityPP\" -dt doubleArray " + $objName));
    	evalEcho(("addAttr -ln \"opacityPP0\" -dt doubleArray " + $objName));
	}

	resetParticleAddButton("opacity", "opacityPP", "addOpacityAttrButton", $nodeName);

	deleteUI -window particleOpacityWin;

}  // particleOpacityAddAttrCB //


global proc	particleSetAddCheckboxes(string $windowName, string $objName,
					string $perObject, string $perParticle,
					string $boxName,
					string $boxNamePP)
{
	setParent $windowName;

	// If one attribute is already in existence, don't allow
	// user to try to add it again.
	//
	string 	$currAttrs[] = `listAttr $objName`;
	int		$currAttrsCnt = size( $currAttrs );

	for ($i = 0; $i < $currAttrsCnt; $i++)
	{
		if ($currAttrs[$i] == $perObject)
		{
			checkBox -e -enable false $boxName;
			break;
		}
	}

	for ($i = 0; $i < $currAttrsCnt; $i++)
	{
		if ($currAttrs[$i] == $perParticle)
		{
			checkBox -e  -enable false $boxNamePP;
			break;
		}
	}
}



//  ========== addParticleOpacityCB ==========
//
//  Description:
//      Add the dynamic attribute "opacity" to the particle object.
//
global proc  addParticleOpacityCB( string $nodeName )
{
	global string $dynParticleSaveParent;

    string  $objName = $nodeName ;

	if (!`window -exists "particleOpacityWin"`)
	{
		window 
			-title (uiRes("m_AEparticleLayout.kParticleOpacity")) 
			-iconName (uiRes("m_AEparticleLayout.kOpacity")) 
			particleOpacityWin;

    	frameLayout -bv false -cll false -lv false -mh 2
        	particleOpacityFL;
		columnLayout -adj true particleOpacityCL;

		checkBox -label (uiRes("m_AEparticleLayout.kAddPerObjectAttribute")) 
			particleOpacityPerObjCB;

		checkBox -label (uiRes("m_AEparticleLayout.kAddPerParticleAttribute")) 
			particleOpacityPerPartCB;

		particleSetAddCheckboxes("particleOpacityWin",
					$objName,
					"opacity", "opacityPP", 
					"particleOpacityPerObjCB",
					"particleOpacityPerPartCB");

		setParent particleOpacityFL;
		setParent particleOpacityCL;

		separator -hr true -h 10;

		formLayout -nd 100 
			particleOpacityAddAttrF;

		button -label (uiRes("m_AEparticleLayout.kAddAttribute"))  
			-c ("particleOpacityAddAttrCB " + $nodeName )
			particleOpacityAddButton;

		button -label (uiRes("m_AEparticleLayout.kCancel"))  
			-c "window -e -visible false particleOpacityWin"
			particleOpacityCloseButton;

		formLayout -e
			-af particleOpacityAddButton "top"   0
			-af particleOpacityAddButton "left"  3
			-ap particleOpacityAddButton "right" 1 50
			-af particleOpacityAddButton "bottom"  3

			-af particleOpacityCloseButton "top" 0
			-ap particleOpacityCloseButton "left" 1 50
			-af particleOpacityCloseButton "right" 3
			-af particleOpacityCloseButton "bottom"  3
			particleOpacityAddAttrF;

		setParent ..;

	}
	showWindow particleOpacityWin;

} //  addParticleOpacityCB


//  ========== addParticleColorCB ==========
//
//  Description:
//      Add the dynamic attribute "rgb" to the particle object.
//
global proc  addParticleColorCB(string $nodeName )
{
	global string $dynParticleSaveParent;

    string  $objName = $nodeName;

	if (!`window -exists "particleColorWin"`)
	{
		window 
			-title (uiRes("m_AEparticleLayout.kParticleColor")) 
			-iconName (uiRes("m_AEparticleLayout.kColor")) 
			particleColorWin;

    	frameLayout -bv false -cll false -lv false -mh 2
        	particleColorFL;
		columnLayout -adj true particleColorCL;

		checkBox -label (uiRes("m_AEparticleLayout.kAddPerObjectAttribute2")) 
			-onc ("particleSelColorAttrCB")
			particleColorPerObjCB;

		checkBox -label (uiRes("m_AEparticleLayout.kAddPerParticleAttribute2")) 
			-onc ("particleSelColorAttrCB")
			particleColorPerPartCB;

		checkBox -label (uiRes("m_AEparticleLayout.kShader")) 
			-onc ("particleSelColorShaderCB")
			particleColorShaderCB;

		particleSetAddCheckboxes("particleColorWin",
					$objName,
					"colorRed", "rgbPP", 
					"particleColorPerObjCB",
					"particleColorPerPartCB");

		setParent particleColorFL;
		setParent particleColorCL;

		separator -hr true -h 10;

		formLayout -nd 100 
			particleColorAddAttrF;

		button -label (uiRes("m_AEparticleLayout.kAddAttribute2"))  
			-c ("particleColorAddAttrCB " + $nodeName)
			particleColorAddButton;

		button -label (uiRes("m_AEparticleLayout.kCancel2"))  
			-c "window -e -visible false particleColorWin"
			particleColorCloseButton;

		formLayout -e
			-af particleColorAddButton "top"   0
			-af particleColorAddButton "left"  3
			-ap particleColorAddButton "right" 1 50
			-af particleColorAddButton "bottom"  3

			-af particleColorCloseButton "top" 0
			-ap particleColorCloseButton "left" 1 50
			-af particleColorCloseButton "right" 3
			-af particleColorCloseButton "bottom"  3
			particleColorAddAttrF;

		setParent ..;
	}
	showWindow particleColorWin;

} //  addParticleColorCB




// ========== AEparticleAddDynamicRenderAttr ==========
//
//  Description:
//      Render wizard button callback.
//
//      This adds all the needed render attributes to the
//      particle object for the currently selected render
//      plug-in. It first checks to see which attributes
//      are already present and does not add them again.
//
global proc  AEparticleAddDynamicRenderAttr ( string $nodeName )
{

    // Build list of attributes used by current render type.
    //
    int     $attrEnumRenderType = `getAttr ($nodeName + ".particleRenderType")`;
	string  $renderType = `particleRenderInfo -name $attrEnumRenderType -q`;
    string  $renderAttrAry[] = `particleRenderInfo -attrList $attrEnumRenderType -q`;
	int		$renderAttrCnt = size( $renderAttrAry );


    // Build list of attributes the particle object currently owns.
    //
    string  $objAttrAry[] = `listAttr $nodeName`;
	int		$objAttrCnt = size( $objAttrAry );


    // Special case for "Geometry" render type. Need to add
    // shapeName as an existing attribute even though it is
    // not a dynamic attribute.
    //
    if ($renderType == "Geometry")
    {
        $objAttrAry[size($objAttrAry)] = "shapeName";
    }

    // Compare the two lists of attributes, and make a new list
    // of just the missing render attributes needed for the
    // current render type.
    //
    string  $addAttrAry[];
    int     $addCount = 0;

    for ($i = 0; $i < $renderAttrCnt; $i++)
    {
        string  $words[];
        int     $needed = 1;

        tokenize( $renderAttrAry[$i], ":", $words );

        for ($j = $objAttrCnt - 1; $j >= 0; $j--)
        {
            if ($words[0] == $objAttrAry[$j])
            {
                $needed = 0;
                break;
            }
        }

        if ($needed)
        {
            $addAttrAry[$addCount++] = $renderAttrAry[$i];
        }
    }

    // Add the missing attributes to the particle object.
    //
	int	$addAttrCnt = size( $addAttrAry );

    for ($i = 0; $i < $addAttrCnt; $i++)
    {
		dynAddParticleAttr( $nodeName, $addAttrAry[$i] );
    }

	clear($renderAttrAry);
	clear($objAttrAry);
	clear($addAttrAry);

}  // AEparticleAddDynamicRenderAttr //


global proc dimLifespanControls ( string $nodeName )
//
// Description:
//  set dimming for lifespan controls.
{
	string $nodeAttr = $nodeName + ".lifespanMode";
	int $value = `getAttr $nodeAttr`;
	
	if ( $value == 0 ) {
		editorTemplate -dimControl $nodeName "lifespanPP" true;
		editorTemplate -dimControl $nodeName "lifespan" true;
		editorTemplate -dimControl $nodeName "lifespanRandom" true;
		editorTemplate -dimControl $nodeName "generalSeed" true;
	} 
    else 
	if ( $value == 1 ) {
		editorTemplate -dimControl $nodeName "lifespanPP" true;
		editorTemplate -dimControl $nodeName "lifespan" false;
		editorTemplate -dimControl $nodeName "lifespanRandom" true;
		editorTemplate -dimControl $nodeName "generalSeed" true;
	}
    else 
	if ( $value == 2 ) {
		editorTemplate -dimControl $nodeName "lifespanPP" true;
		editorTemplate -dimControl $nodeName "lifespan" false;
		editorTemplate -dimControl $nodeName "lifespanRandom" false;
		editorTemplate -dimControl $nodeName "generalSeed" false;
	}
	else
	if ( $value == 3 ) {
		editorTemplate -dimControl $nodeName "lifespanPP" false;
		editorTemplate -dimControl $nodeName "lifespan" true;
		editorTemplate -dimControl $nodeName "lifespanRandom" true;
		editorTemplate -dimControl $nodeName "generalSeed" true;
	}
}


//  ========== AEparticleAddDynamicAttrWnd ==========
//
//  Description:
// 		Post the Add Attribute window. 
//
global proc AEparticleAddDynamicAttrWnd ( string $nodeName )
{
	dynAddAttrWin ( { $nodeName } );

}  // AEparticleAddDynamicAttrWnd //


//  ========== addParticleColorShaderCB ==========
//
//  Description:
//      User has chosen the hyperShade in the Color Dialog, so
//		disable the Add Attribute button, and bring up the hyperShade.
//
global proc particleSelColorShaderCB()
{
	setParent particleColorWin;

	// Disable the Add Attributebutton.
	//
	button -e -enable false particleColorAddButton;

	// Bring up a hyperShade
	//
    string $listers[] = `getPanel -scriptType "hyperShadePanel"`;
    string $listerName;

    if (size ($listers) > 0) 
	{
        //  Found an existing one.
        //
        $listerName = $listers[0];

    } else 
	{
        //  Need to make a new one.
        //
        $listerName = `scriptedPanel -unParent
                    -type "hyperShadePanel"
                    -label (uiRes("m_AEparticleLayout.kMultiLister")) `;
    }

    //  Tear it off -- or pop it up if it is already torn off.
    //
	if (`scriptedPanel -q -to $listerName`) 
        showWindow ($listerName+"Window");
    else 
        scriptedPanel -e -to $listerName;
}


global proc AEparticleAddAttrNew ( string $renderType )
{
	global int $gTextColumnWidthIndex;

	string $nodeName[];
	tokenize($renderType, ".", $nodeName);

	setUITemplate -pst attributeEditorPresetsTemplate;
	rowLayout -nc 3 -columnWidth 1 $gTextColumnWidthIndex
			-columnWidth 2 180
			-columnAttach 2 both 0
			-columnAttach 1 right 5;
		text -label (uiRes("m_AEparticleLayout.kAddAttributesFor")) ;
		button -label (uiRes("m_AEparticleLayout.kCurrentRenderType")) 
			-c ("AEparticleAddDynamicRenderAttr " + $nodeName[0] )
			addRenderTypeAttrButton;
		setParent ..;
	setUITemplate -ppt;
}


global proc AEparticleAddAttrReplace ( string $renderType )
{
	string $nodeName[];
	tokenize($renderType, ".", $nodeName);

	button -e -c ("AEparticleAddDynamicRenderAttr " + $nodeName[0] )
		addRenderTypeAttrButton;
}


global proc  checkDynamicAttributes( string $nodeName )
{

	// List of render attributes. These are all the
	// render attributes which need to be dimmed and 
	// unkeyable when changing render types.
	//
	int		$useAttrAry[];
	string	$renderAttrAry[];
	int		$i;

	$i = 0;
	$renderAttrAry[$i++] = "attributeName";
	$renderAttrAry[$i++] = "betterIllumination";
	$renderAttrAry[$i++] = "colorAccum";
	$renderAttrAry[$i++] = "colorBlue";
	$renderAttrAry[$i++] = "colorGreen";
	$renderAttrAry[$i++] = "colorRed";
	$renderAttrAry[$i++] = "lineWidth";
	$renderAttrAry[$i++] = "multiCount";
	$renderAttrAry[$i++] = "multiRadius";
	$renderAttrAry[$i++] = "normalDir";
	$renderAttrAry[$i++] = "opacity";
	$renderAttrAry[$i++] = "pointSize";
	$renderAttrAry[$i++] = "radius";
	$renderAttrAry[$i++] = "radius0";
	$renderAttrAry[$i++] = "radius1";
	$renderAttrAry[$i++] = "selectedOnly";
	$renderAttrAry[$i++] = "shapeName";
	$renderAttrAry[$i++] = "spriteNum";
	$renderAttrAry[$i++] = "spriteScaleX";
	$renderAttrAry[$i++] = "spriteScaleY";
	$renderAttrAry[$i++] = "spriteTwist";
	$renderAttrAry[$i++] = "surfaceShading";
	$renderAttrAry[$i++] = "tailFade";
	$renderAttrAry[$i++] = "tailSize";
	$renderAttrAry[$i++] = "threshold";
	$renderAttrAry[$i++] = "useLighting";
	$renderAttrAry[$i++] = "flatShaded";

	$renderAttrCnt = $i;

	// For nParticles radius and threshold should never be greyed out
	int $R = (nodeType( $nodeName ) == "nParticle");  
	
	// Get the current render type of the particle object,
	// and set the dim/keyable state for each of the render
	// attributes.
	//
	string	$nodeAttr = $nodeName + ".particleRenderType";
	int 	$value = `getAttr $nodeAttr`;
	
	switch ( $value )
	{
		case 0: // MultiPoint

			$i = 0;
			$useAttrAry[$i++] = 0;  // attributeName;
			$useAttrAry[$i++] = 0;  // betterIllumination;
			$useAttrAry[$i++] = 1;  // colorAccum;
			$useAttrAry[$i++] = 1;  // colorBlue;
			$useAttrAry[$i++] = 1;  // colorGreen;
			$useAttrAry[$i++] = 1;  // colorRed;
			$useAttrAry[$i++] = 0;  // lineWidth;
			$useAttrAry[$i++] = 1;  // multiCount;
			$useAttrAry[$i++] = 1;  // multiRadius;
			$useAttrAry[$i++] = 1;  // normalDir;
			$useAttrAry[$i++] = 1;  // opacity;
			$useAttrAry[$i++] = 1;  // pointSize;
			$useAttrAry[$i++] = $R;  // radius;
			$useAttrAry[$i++] = 0;  // radius0;
			$useAttrAry[$i++] = 0;  // radius1;
			$useAttrAry[$i++] = 0;  // selectedOnly;
			$useAttrAry[$i++] = 0;  // shapeName;
			$useAttrAry[$i++] = 0;  // spriteNum;
			$useAttrAry[$i++] = 0;  // spriteScaleX;
			$useAttrAry[$i++] = 0;  // spriteScaleY;
			$useAttrAry[$i++] = 0;  // spriteTwist;
			$useAttrAry[$i++] = 0;  // surfaceShading;
			$useAttrAry[$i++] = 0;  // tailFade;
			$useAttrAry[$i++] = 0;  // tailSize;
			$useAttrAry[$i++] = $R;  // threshold;
			$useAttrAry[$i++] = 1;  // useLighting;
			$useAttrAry[$i++] = 0;  // flatShaded;
			break;


		case 1: // MultiStreak

			$i = 0;
			$useAttrAry[$i++] = 0;  // attributeName;
			$useAttrAry[$i++] = 0;  // betterIllumination;
			$useAttrAry[$i++] = 1;  // colorAccum;
			$useAttrAry[$i++] = 1;  // colorBlue;
			$useAttrAry[$i++] = 1;  // colorGreen;
			$useAttrAry[$i++] = 1;  // colorRed;
			$useAttrAry[$i++] = 1;  // lineWidth;
			$useAttrAry[$i++] = 1;  // multiCount;
			$useAttrAry[$i++] = 1;  // multiRadius;
			$useAttrAry[$i++] = 1;  // normalDir;
			$useAttrAry[$i++] = 1;  // opacity;
			$useAttrAry[$i++] = 0;  // pointSize;
			$useAttrAry[$i++] = $R;  // radius;
			$useAttrAry[$i++] = 0;  // radius0;
			$useAttrAry[$i++] = 0;  // radius1;
			$useAttrAry[$i++] = 0;  // selectedOnly;
			$useAttrAry[$i++] = 0;  // shapeName;
			$useAttrAry[$i++] = 0;  // spriteNum;
			$useAttrAry[$i++] = 0;  // spriteScaleX;
			$useAttrAry[$i++] = 0;  // spriteScaleY;
			$useAttrAry[$i++] = 0;  // spriteTwist;
			$useAttrAry[$i++] = 0;  // surfaceShading;
			$useAttrAry[$i++] = 1;  // tailFade;
			$useAttrAry[$i++] = 1;  // tailSize;
			$useAttrAry[$i++] = $R;  // threshold;
			$useAttrAry[$i++] = 1;  // useLighting;
			$useAttrAry[$i++] = 0;  // flatShaded;
			break;


		case 2: // Numeric

			$i = 0;
			$useAttrAry[$i++] = 1;  // attributeName;
			$useAttrAry[$i++] = 0;  // betterIllumination;
			$useAttrAry[$i++] = 0;  // colorAccum;
			$useAttrAry[$i++] = 0;  // colorBlue;
			$useAttrAry[$i++] = 0;  // colorGreen;
			$useAttrAry[$i++] = 0;  // colorRed;
			$useAttrAry[$i++] = 0;  // lineWidth;
			$useAttrAry[$i++] = 0;  // multiCount;
			$useAttrAry[$i++] = 0;  // multiRadius;
			$useAttrAry[$i++] = 0;  // normalDir;
			$useAttrAry[$i++] = 0;  // opacity;
			$useAttrAry[$i++] = 1;  // pointSize;
			$useAttrAry[$i++] = $R;  // radius;
			$useAttrAry[$i++] = 0;  // radius0;
			$useAttrAry[$i++] = 0;  // radius1;
			$useAttrAry[$i++] = 1;  // selectedOnly;
			$useAttrAry[$i++] = 0;  // shapeName;
			$useAttrAry[$i++] = 0;  // spriteNum;
			$useAttrAry[$i++] = 0;  // spriteScaleX;
			$useAttrAry[$i++] = 0;  // spriteScaleY;
			$useAttrAry[$i++] = 0;  // spriteTwist;
			$useAttrAry[$i++] = 0;  // surfaceShading;
			$useAttrAry[$i++] = 0;  // tailFade;
			$useAttrAry[$i++] = 0;  // tailSize;
			$useAttrAry[$i++] = $R;  // threshold;
			$useAttrAry[$i++] = 0;  // useLighting;
			$useAttrAry[$i++] = 0;  // flatShaded;
			break;


		case 3: // Points

			$i = 0;
			$useAttrAry[$i++] = 0;  // attributeName;
			$useAttrAry[$i++] = 0;  // betterIllumination;
			$useAttrAry[$i++] = 1;  // colorAccum;
			$useAttrAry[$i++] = 1;  // colorBlue;
			$useAttrAry[$i++] = 1;  // colorGreen;
			$useAttrAry[$i++] = 1;  // colorRed;
			$useAttrAry[$i++] = 0;  // lineWidth;
			$useAttrAry[$i++] = 0;  // multiCount;
			$useAttrAry[$i++] = 0;  // multiRadius;
			$useAttrAry[$i++] = 1;  // normalDir;
			$useAttrAry[$i++] = 1;  // opacity;
			$useAttrAry[$i++] = 1;  // pointSize;
			$useAttrAry[$i++] = $R;  // radius;
			$useAttrAry[$i++] = 0;  // radius0;
			$useAttrAry[$i++] = 0;  // radius1;
			$useAttrAry[$i++] = 0;  // selectedOnly;
			$useAttrAry[$i++] = 0;  // shapeName;
			$useAttrAry[$i++] = 0;  // spriteNum;
			$useAttrAry[$i++] = 0;  // spriteScaleX;
			$useAttrAry[$i++] = 0;  // spriteScaleY;
			$useAttrAry[$i++] = 0;  // spriteTwist;
			$useAttrAry[$i++] = 0;  // surfaceShading;
			$useAttrAry[$i++] = 0;  // tailFade;
			$useAttrAry[$i++] = 0;  // tailSize;
			$useAttrAry[$i++] = $R;  // threshold;
			$useAttrAry[$i++] = 1;  // useLighting;
			$useAttrAry[$i++] = 0;  // flatShaded;
			break;


		case 4: // Spheres

			$i = 0;
			$useAttrAry[$i++] = 0;  // attributeName;
			$useAttrAry[$i++] = 0;  // betterIllumination;
			$useAttrAry[$i++] = 0;  // colorAccum;
			$useAttrAry[$i++] = 1;  // colorBlue;
			$useAttrAry[$i++] = 1;  // colorGreen;
			$useAttrAry[$i++] = 1;  // colorRed;
			$useAttrAry[$i++] = 0;  // lineWidth;
			$useAttrAry[$i++] = 0;  // multiCount;
			$useAttrAry[$i++] = 0;  // multiRadius;
			$useAttrAry[$i++] = 0;  // normalDir;
			$useAttrAry[$i++] = 1;  // opacity;
			$useAttrAry[$i++] = 0;  // pointSize;
			$useAttrAry[$i++] = 1;  // radius;
			$useAttrAry[$i++] = 0;  // radius0;
			$useAttrAry[$i++] = 0;  // radius1;
			$useAttrAry[$i++] = 0;  // selectedOnly;
			$useAttrAry[$i++] = 0;  // shapeName;
			$useAttrAry[$i++] = 0;  // spriteNum;
			$useAttrAry[$i++] = 0;  // spriteScaleX;
			$useAttrAry[$i++] = 0;  // spriteScaleY;
			$useAttrAry[$i++] = 0;  // spriteTwist;
			$useAttrAry[$i++] = 0;  // surfaceShading;
			$useAttrAry[$i++] = 0;  // tailFade;
			$useAttrAry[$i++] = 0;  // tailSize;
			$useAttrAry[$i++] = $R;  // threshold;
			$useAttrAry[$i++] = 0;  // useLighting;
			$useAttrAry[$i++] = 0;  // flatShaded;
			break;


		case 5: // Sprites

			$i = 0;
			$useAttrAry[$i++] = 0;  // attributeName;
			$useAttrAry[$i++] = 0;  // betterIllumination;
			$useAttrAry[$i++] = 0;  // colorAccum;
			$useAttrAry[$i++] = 1;  // colorBlue;
			$useAttrAry[$i++] = 1;  // colorGreen;
			$useAttrAry[$i++] = 1;  // colorRed;
			$useAttrAry[$i++] = 0;  // lineWidth;
			$useAttrAry[$i++] = 0;  // multiCount;
			$useAttrAry[$i++] = 0;  // multiRadius;
			$useAttrAry[$i++] = 0;  // normalDir;
			$useAttrAry[$i++] = 1;  // opacity;
			$useAttrAry[$i++] = 0;  // pointSize;
			$useAttrAry[$i++] = $R;  // radius;
			$useAttrAry[$i++] = 0;  // radius0;
			$useAttrAry[$i++] = 0;  // radius1;
			$useAttrAry[$i++] = 0;  // selectedOnly;
			$useAttrAry[$i++] = 0;  // shapeName;
			$useAttrAry[$i++] = 1;  // spriteNum;
			$useAttrAry[$i++] = 1;  // spriteScaleX;
			$useAttrAry[$i++] = 1;  // spriteScaleY;
			$useAttrAry[$i++] = 1;  // spriteTwist;
			$useAttrAry[$i++] = 0;  // surfaceShading;
			$useAttrAry[$i++] = 0;  // tailFade;
			$useAttrAry[$i++] = 0;  // tailSize;
			$useAttrAry[$i++] = $R;  // threshold;
			$useAttrAry[$i++] = 1;  // useLighting;
			$useAttrAry[$i++] = 0;  // flatShaded;
			break;


		case 6: // Streak

			$i = 0;
			$useAttrAry[$i++] = 0;  // attributeName;
			$useAttrAry[$i++] = 0;  // betterIllumination;
			$useAttrAry[$i++] = 1;  // colorAccum;
			$useAttrAry[$i++] = 1;  // colorBlue;
			$useAttrAry[$i++] = 1;  // colorGreen;
			$useAttrAry[$i++] = 1;  // colorRed;
			$useAttrAry[$i++] = 1;  // lineWidth;
			$useAttrAry[$i++] = 0;  // multiCount;
			$useAttrAry[$i++] = 0;  // multiRadius;
			$useAttrAry[$i++] = 1;  // normalDir;
			$useAttrAry[$i++] = 1;  // opacity;
			$useAttrAry[$i++] = 0;  // pointSize;
			$useAttrAry[$i++] = $R;  // radius;
			$useAttrAry[$i++] = 0;  // radius0;
			$useAttrAry[$i++] = 0;  // radius1;
			$useAttrAry[$i++] = 0;  // selectedOnly;
			$useAttrAry[$i++] = 0;  // shapeName;
			$useAttrAry[$i++] = 0;  // spriteNum;
			$useAttrAry[$i++] = 0;  // spriteScaleX;
			$useAttrAry[$i++] = 0;  // spriteScaleY;
			$useAttrAry[$i++] = 0;  // spriteTwist;
			$useAttrAry[$i++] = 0;  // surfaceShading;
			$useAttrAry[$i++] = 1;  // tailFade;
			$useAttrAry[$i++] = 1;  // tailSize;
			$useAttrAry[$i++] = $R;  // threshold;
			$useAttrAry[$i++] = 1;  // useLighting;
			$useAttrAry[$i++] = 0;  // flatShaded;
			break;


		case 7: // Blobby Surface (s/w)

			$i = 0;
			$useAttrAry[$i++] = 0;  // attributeName;
			$useAttrAry[$i++] = 0;  // betterIllumination;
			$useAttrAry[$i++] = 0;  // colorAccum;
			$useAttrAry[$i++] = 1;  // colorBlue;
			$useAttrAry[$i++] = 1;  // colorGreen;
			$useAttrAry[$i++] = 1;  // colorRed;
			$useAttrAry[$i++] = 0;  // lineWidth;
			$useAttrAry[$i++] = 0;  // multiCount;
			$useAttrAry[$i++] = 0;  // multiRadius;
			$useAttrAry[$i++] = 0;  // normalDir;
			$useAttrAry[$i++] = 1;  // opacity;
			$useAttrAry[$i++] = 0;  // pointSize;
			$useAttrAry[$i++] = 1;  // radius;
			$useAttrAry[$i++] = 0;  // radius0;
			$useAttrAry[$i++] = 0;  // radius1;
			$useAttrAry[$i++] = 0;  // selectedOnly;
			$useAttrAry[$i++] = 0;  // shapeName;
			$useAttrAry[$i++] = 0;  // spriteNum;
			$useAttrAry[$i++] = 0;  // spriteScaleX;
			$useAttrAry[$i++] = 0;  // spriteScaleY;
			$useAttrAry[$i++] = 0;  // spriteTwist;
			$useAttrAry[$i++] = 0;  // surfaceShading;
			$useAttrAry[$i++] = 0;  // tailFade;
			$useAttrAry[$i++] = 0;  // tailSize;
			$useAttrAry[$i++] = 1;  // threshold;
			$useAttrAry[$i++] = 0;  // useLighting;
			$useAttrAry[$i++] = 0;  // flatShaded;
			break;


		case 8: //"Cloud (s/w)":

			$i = 0;
			$useAttrAry[$i++] = 0;  // attributeName;
			$useAttrAry[$i++] = 1;  // betterIllumination;
			$useAttrAry[$i++] = 0;  // colorAccum;
			$useAttrAry[$i++] = 1;  // colorBlue;
			$useAttrAry[$i++] = 1;  // colorGreen;
			$useAttrAry[$i++] = 1;  // colorRed;
			$useAttrAry[$i++] = 0;  // lineWidth;
			$useAttrAry[$i++] = 0;  // multiCount;
			$useAttrAry[$i++] = 0;  // multiRadius;
			$useAttrAry[$i++] = 0;  // normalDir;
			$useAttrAry[$i++] = 1;  // opacity;
			$useAttrAry[$i++] = 0;  // pointSize;
			$useAttrAry[$i++] = 1;  // radius;
			$useAttrAry[$i++] = 0;  // radius0;
			$useAttrAry[$i++] = 0;  // radius1;
			$useAttrAry[$i++] = 0;  // selectedOnly;
			$useAttrAry[$i++] = 0;  // shapeName;
			$useAttrAry[$i++] = 0;  // spriteNum;
			$useAttrAry[$i++] = 0;  // spriteScaleX;
			$useAttrAry[$i++] = 0;  // spriteScaleY;
			$useAttrAry[$i++] = 0;  // spriteTwist;
			$useAttrAry[$i++] = 1;  // surfaceShading;
			$useAttrAry[$i++] = 0;  // tailFade;
			$useAttrAry[$i++] = 0;  // tailSize;
			$useAttrAry[$i++] = 1;  // threshold;
			$useAttrAry[$i++] = 0;  // useLighting;
			$useAttrAry[$i++] = 1;  // flatShaded;
			break;


		case 9: // Tube (s/w)

			$i = 0;
			$useAttrAry[$i++] = 0;  // attributeName;
			$useAttrAry[$i++] = 0;  // betterIllumination;
			$useAttrAry[$i++] = 0;  // colorAccum;
			$useAttrAry[$i++] = 1;  // colorBlue;
			$useAttrAry[$i++] = 1;  // colorGreen;
			$useAttrAry[$i++] = 1;  // colorRed;
			$useAttrAry[$i++] = 0;  // lineWidth;
			$useAttrAry[$i++] = 0;  // multiCount;
			$useAttrAry[$i++] = 0;  // multiRadius;
			$useAttrAry[$i++] = 0;  // normalDir;
			$useAttrAry[$i++] = 1;  // opacity;
			$useAttrAry[$i++] = 0;  // pointSize;
			$useAttrAry[$i++] = $R;  // radius;
			$useAttrAry[$i++] = 1;  // radius0;
			$useAttrAry[$i++] = 1;  // radius1;
			$useAttrAry[$i++] = 0;  // selectedOnly;
			$useAttrAry[$i++] = 0;  // shapeName;
			$useAttrAry[$i++] = 0;  // spriteNum;
			$useAttrAry[$i++] = 0;  // spriteScaleX;
			$useAttrAry[$i++] = 0;  // spriteScaleY;
			$useAttrAry[$i++] = 0;  // spriteTwist;
			$useAttrAry[$i++] = 0;  // surfaceShading;
			$useAttrAry[$i++] = 0;  // tailFade;
			$useAttrAry[$i++] = 1;  // tailSize;
			$useAttrAry[$i++] = $R;  // threshold;
			$useAttrAry[$i++] = 0;  // useLighting;
			$useAttrAry[$i++] = 0;  // flatShaded;
			break;


		default:

			$i = 0;
			$useAttrAry[$i++] = 1;  // attributeName;
			$useAttrAry[$i++] = 1;  // betterIllumination;
			$useAttrAry[$i++] = 1;  // colorAccum;
			$useAttrAry[$i++] = 1;  // colorBlue;
			$useAttrAry[$i++] = 1;  // colorGreen;
			$useAttrAry[$i++] = 1;  // colorRed;
			$useAttrAry[$i++] = 1;  // lineWidth;
			$useAttrAry[$i++] = 1;  // multiCount;
			$useAttrAry[$i++] = 1;  // multiRadius;
			$useAttrAry[$i++] = 1;  // normalDir;
			$useAttrAry[$i++] = 1;  // opacity;
			$useAttrAry[$i++] = 1;  // pointSize;
			$useAttrAry[$i++] = 1;  // radius;
			$useAttrAry[$i++] = 1;  // radius0;
			$useAttrAry[$i++] = 1;  // radius0;
			$useAttrAry[$i++] = 1;  // selectedOnly;
			$useAttrAry[$i++] = 1;  // shapeName;
			$useAttrAry[$i++] = 1;  // spriteNum;
			$useAttrAry[$i++] = 1;  // spriteScaleX;
			$useAttrAry[$i++] = 1;  // spriteScaleY;
			$useAttrAry[$i++] = 1;  // spriteTwist;
			$useAttrAry[$i++] = 1;  // surfaceShading;
			$useAttrAry[$i++] = 1;  // tailFade;
			$useAttrAry[$i++] = 1;  // tailSize;
			$useAttrAry[$i++] = 1;  // threshold;
			$useAttrAry[$i++] = 1;  // useLighting;
			$useAttrAry[$i++] = 1;  // flatShaded;
			break;
		}


		if( $value == 7 || $value == 8 || $value == 9 ) {
			// software particle type
			editorTemplate -dimControl $nodeName "visibleInReflections" false;
			editorTemplate -dimControl $nodeName "visibleInRefractions" false;
			editorTemplate -dimControl $nodeName "castsShadows"    		false;
			editorTemplate -dimControl $nodeName "receiveShadows" 		false;
			editorTemplate -dimControl $nodeName "primaryVisibility" 	false;
		} else {
			// hardware particle type
			editorTemplate -dimControl $nodeName "visibleInReflections" true;
			editorTemplate -dimControl $nodeName "visibleInRefractions" true;
			editorTemplate -dimControl $nodeName "castsShadows"			true;
			editorTemplate -dimControl $nodeName "receiveShadows" 		true;
			editorTemplate -dimControl $nodeName "primaryVisibility" 	true;
		}

		// Make list of attributes to turn on and off.
		//
		string	$onAttrList = "";
		string	$offAttrList = "";
		string	$onAttrAry[];
		string	$offAttrAry[];

		for ($i = 0; $i < $renderAttrCnt; $i++)
		{
			if ($useAttrAry[$i])
			{
				$onAttrList += (" -st "+$renderAttrAry[$i]);
			}
			else
			{
				$offAttrList += (" -st "+$renderAttrAry[$i]);
			}
		}


		// Use the listAttr command to return a list of attributes
		// which exist on the particle object (since they are
		// dynamic attributes, they may not actually exist). Then
		// dim the unused attributes (so they are dim in the Attribute
		// Editor, and make then unkeyable (so they don't show up
		// in the channel box).
		//
		string	$cmd;

		$cmd = "listAttr "+$onAttrList+" "+$nodeName;
		$onAttrAry = `eval( $cmd )`;
		$cmd = "listAttr "+$offAttrList+" "+$nodeName;
		$offAttrAry = `eval( $cmd )`;

		for ($i = size( $onAttrAry ) - 1; $i >= 0; $i--)
		{
			editorTemplate -dimControl $nodeName $onAttrAry[$i] false;
			setAttr -keyable true ($nodeName+"."+$onAttrAry[$i]);
		}

		for ($i = size( $offAttrAry ) - 1; $i >= 0; $i--)
		{
			editorTemplate -dimControl $nodeName $offAttrAry[$i] true;
			setAttr -keyable false ($nodeName+"."+$offAttrAry[$i]);
		}


}  // checkDynamicAttributes //


global proc particleExpressionEditor ( string $inAttrName )
{	
	string $nodeName[];
	tokenize($inAttrName, ".", $nodeName);

	expressionEditor ("editExpression" + $inAttrName )
			 $nodeName[0] $nodeName[1];
}


global proc AEaddDynamicAttrNew ( string $count )
{
	string $nodeName[];
	tokenize($count, ".", $nodeName);

	setUITemplate -pst attributeEditorPresetsTemplate;
	
	rowLayout -nc 3
		-columnWidth3 123 123 122
		-columnAttach 1 both 0 
		-columnAttach 2 both 0 
		-columnAttach 3 both 0
		-columnAlign 1 center
		-columnAlign 2 center
		-columnAlign 3 center
	;
		
		button -label (uiRes("m_AEparticleLayout.kGeneral"))
			-c ("AEparticleAddDynamicAttrWnd " + $nodeName[0] )
			addGeneralAttrButton;
		button -label (uiRes("m_AEparticleLayout.kOpacity2"))
			-c ("addParticleOpacityCB " + $nodeName[0] )
			 addOpacityAttrButton;
		button -label (uiRes("m_AEparticleLayout.kColor2"))
			-c ("addParticleColorCB " + $nodeName[0] )
			 addColorAttrButton;
		setParent ..;

	setUITemplate -ppt;

	checkAddDynamicAttrButtonStatus $nodeName[0];
}


global proc AEaddDynamicAttrReplace ( string $count )
{

	string $nodeName[];
	tokenize($count, ".", $nodeName);

	button -e -c ("AEparticleAddDynamicAttrWnd " + $nodeName[0] )
		addGeneralAttrButton;
	button -e -c ("addParticleOpacityCB " + $nodeName[0] )
		addOpacityAttrButton;
	button -e -c ("addParticleColorCB " + $nodeName[0] )
		addColorAttrButton;

	checkAddDynamicAttrButtonStatus $nodeName[0];
}


global proc checkParticleUseLifespanPP ( string $nodeName )
{
	if ( `attributeExists "useLifespanPP" $nodeName` )
	{
		string $nodeAttr = $nodeName + ".useLifespanPP";
		int $value = `getAttr $nodeAttr`;
	
		if ($value == 0) {
			if (`rowLayout -exists lifespanPPRowLayout`)	
				rowLayout -e -en false 
					lifespanPPRowLayout;
			editorTemplate -dimControl $nodeName "lifespan" false;
		} else {
			if (`rowLayout -exists lifespanPPRowLayout`)	
				rowLayout -e -en true 
					lifespanPPRowLayout;
			editorTemplate -dimControl $nodeName "lifespan" true;
		}
	}
}

global proc checkForSoftBody ( string $nodeName )
{
	string $inputConnections[] = 
		`listConnections -plugs on -d off -s on ($nodeName + ".inputGeometry")`;

	string $outputConnections[] = 
		`listConnections -plugs on -d on -s off ($nodeName + ".targetGeometry")`;

	if ((size($inputConnections) == 0) && (size($outputConnections) == 0))
	{
		editorTemplate -dimControl $nodeName "enforceCountFromHistory" true;
 		attrEnumOptionMenuGrp -e -enable false targetGeometrySpaceEnum;
 		attrEnumOptionMenuGrp -e -enable false inputGeometrySpaceEnum;
	}
	else
	{
	 	editorTemplate -dimControl $nodeName "enforceCountFromHistory" false;
 		attrEnumOptionMenuGrp -e -enable true targetGeometrySpaceEnum;
 		attrEnumOptionMenuGrp -e -enable true inputGeometrySpaceEnum;
	}
}

global proc AEinputGeometrySpaceNew( string $attrName )
{
	setUITemplate -pst attributeEditorTemplate;	
 	attrEnumOptionMenuGrp -attribute $attrName -label (uiRes("m_AEparticleLayout.kInputGeomSpace")) 
    	inputGeometrySpaceEnum;
    setUITemplate -ppt;

	AEinputGeometrySpaceReplace $attrName;
}

global proc AEinputGeometrySpaceReplace( string $attrName )
{
	string $tmp[];
	tokenize($attrName, ".", $tmp);
	string $nodeName = $tmp[0];

 	attrEnumOptionMenuGrp -e -attribute $attrName -label (uiRes("m_AEparticleLayout.kInputGeomSpace2")) 
    	inputGeometrySpaceEnum;

	evalDeferred ("checkForSoftBody " + $nodeName );
}

global proc AEtargetGeometrySpaceNew( string $attrName )
{
	setUITemplate -pst attributeEditorTemplate;	
 	attrEnumOptionMenuGrp -attribute $attrName -label (uiRes("m_AEparticleLayout.kTargetGeomSpace")) 
    	targetGeometrySpaceEnum;
    setUITemplate -ppt;
}

global proc AEtargetGeometrySpaceReplace( string $attrName )
{
 	attrEnumOptionMenuGrp -e -attribute $attrName -label (uiRes("m_AEparticleLayout.kTargetGeomSpace2")) 
    	targetGeometrySpaceEnum;
}


//=========================================================
//  Procedure Name: AEparticleLayout
//
global proc AEparticleLayout ( string $nodeName )
{
	editorTemplate -beginLayout (uiRes("m_AEparticleLayout.kGeneralControlAttributes"))  -collapse 0;
		editorTemplate -beginNoOptimize;
		editorTemplate -addControl "isDynamic";
		editorTemplate -addControl "dynamicsWeight";
		editorTemplate -addControl "conserve";
		editorTemplate -addControl "forcesInWorld";
		editorTemplate -addControl "cacheData";
		editorTemplate -addControl "count";
		editorTemplate -suppress "traceDepth";
		editorTemplate -suppress "goalSmoothness";
		editorTemplate -addControl "totalEventCount";
		editorTemplate -endNoOptimize;
	editorTemplate -endLayout;

	editorTemplate -beginLayout (uiRes("m_AEparticleLayout.kEmissionAttributes"))  -collapse 0;
		editorTemplate -beginNoOptimize;
		editorTemplate -addControl "maxCount";
		editorTemplate -addControl "levelOfDetail";
		editorTemplate -addControl "inheritFactor";
		editorTemplate -addControl "emissionInWorld";
		editorTemplate -addControl "dieOnEmissionVolumeExit";
		editorTemplate -endNoOptimize;
	editorTemplate -endLayout;

	editorTemplate -beginLayout (uiRes("m_AEparticleLayout.kLifespanAttributes"))  -collapse 0;
		editorTemplate -addControl "lifespanMode" "dimLifespanControls";
		editorTemplate -addDynamicControl "lifespan";
		editorTemplate -addControl "lifespanRandom";
		editorTemplate -addControl "generalSeed";
	editorTemplate -endLayout;

	// Attributes to control time in the solver.
	editorTemplate -beginLayout (uiRes("m_AEparticleLayout.kTimeAttributes"))  -collapse true;
		editorTemplate -addControl "startFrame";
		editorTemplate -addControl "currentTime";
	editorTemplate -endLayout;

	// Attribute to control collision response.
	editorTemplate -beginLayout (uiRes("m_AEparticleLayout.kCollisionAttributes"))  -collapse true;
			editorTemplate -callCustom
					"AEparticleCollisionNew"
					"AEparticleCollisionReplace"
					"resilience";
	editorTemplate -endLayout;

	// Attributes relevant to soft bodies
	editorTemplate -beginLayout (uiRes("m_AEparticleLayout.kSoftBodyAttributes"))  -collapse true;
		editorTemplate -callCustom "AEinputGeometrySpaceNew"
			"AEinputGeometrySpaceReplace" "inputGeometrySpace";
		editorTemplate -callCustom "AEtargetGeometrySpaceNew"
			"AEtargetGeometrySpaceReplace" "targetGeometrySpace";

		editorTemplate -addControl "enforceCountFromHistory";
	editorTemplate -endLayout;

	// Tab for goal force attributes
	//
	editorTemplate -beginLayout (uiRes("m_AEparticleLayout.kGoalWeightsandObjects"))  -collapse 1;
			editorTemplate -callCustom
					"AEdynObjectGoalWeightNew"
					"AEdynObjectGoalWeightReplace"
					"goalWeight";
	editorTemplate -endLayout;

	// Tab for particle instancer attributes
	//
	editorTemplate -beginLayout (uiRes("m_AEparticleLayout.kInstancer"))  -collapse 1;
			editorTemplate -callCustom
					"AEdynParticleInstancerNew"
					"AEdynParticleInstancerReplace"
					"instanceAttributeMapping";
	editorTemplate -endLayout;

	// Tab for seed attributes
	//
	editorTemplate -beginLayout (uiRes("m_AEparticleLayout.kEmissionRandomStreamSeeds"))  -collapse 1;
			editorTemplate -callCustom
					"AEparticleSeedNew"
					"AEparticleSeedReplace"
					"seed";
	editorTemplate -endLayout;

	// Tab for render attributes
	//
	editorTemplate -beginLayout (uiRes("m_AEparticleLayout.kRenderAttributes"))  -collapse 0;

		editorTemplate -addControl "depthSort";

		editorTemplate -addControl "particleRenderType"
					 "checkDynamicAttributes";
		editorTemplate -callCustom "AEparticleAddAttrNew"
					"AEparticleAddAttrReplace"
					"particleRenderType";

		// the following attributes are dependent on the 
		// renderType settings 

			// used by 
			//	Numeric
		editorTemplate -addDynamicControl "attributeName";
			// used by 
			//	Cloud
		editorTemplate -addDynamicControl "betterIllumination";
		editorTemplate -addDynamicControl "flatShaded";
			// used by 
			//	MultiPoint, MultiStreak, Points, Streak
		editorTemplate -addDynamicControl "colorAccum";
		editorTemplate -addDynamicControl "colorRed";
		editorTemplate -addDynamicControl "colorGreen";
		editorTemplate -addDynamicControl "colorBlue";
		editorTemplate -addDynamicControl "goal";

			// used by 
			//	MultiStreak, Streak,
		editorTemplate -addDynamicControl "lineWidth";	
			// used by 
			//	MultiPoint, MultiStreak
		editorTemplate -addDynamicControl "multiCount";
		editorTemplate -addDynamicControl "multiRadius";
			// used by
			// 	MultiPoint, MultiStreak, Points, Streak
		editorTemplate -addDynamicControl "normalDir";
		editorTemplate -addDynamicControl "opacity";
			// used by 
			//	MultiPoint, Numeric, Points
		editorTemplate -addDynamicControl "pointSize";	
			// used by 
			// 	Spheres, Blobby Surface, Cloud
		editorTemplate -addDynamicControl "radius";
			// used by
			//	Tube
		editorTemplate -addDynamicControl "radius0";
		editorTemplate -addDynamicControl "radius1";	
			// used by
			//	Numeric
		editorTemplate -addDynamicControl "selectedOnly";
			// used by
			// 	Sprites
		editorTemplate -addDynamicControl "spriteNum";
		editorTemplate -addDynamicControl "spriteScaleX";
		editorTemplate -addDynamicControl "spriteScaleY";
		editorTemplate -addDynamicControl "spriteTwist";
			// used by 
			// 	Cloud
		editorTemplate -addDynamicControl "surfaceShading";
			// used by 
			//	MultiStreak, Streak
		editorTemplate -addDynamicControl "tailFade";
			// used by 
			//	MultiStreak, Streak, Tube
		editorTemplate -addDynamicControl "tailSize";
			// used by 
			//	Blobby Surface, Cloud
		editorTemplate -addDynamicControl "threshold";
			// used by 
			//	MultiPoint, MultiStreak, Points, 
			//	Sprites, Streak
		editorTemplate -addDynamicControl "useLighting";

	editorTemplate -endLayout;

	editorTemplate -beginLayout (uiRes("m_AEparticleLayout.kRenderStats")) ;
		editorTemplate -beginNoOptimize;
		editorTemplate -addControl "visibleInReflections";
		editorTemplate -addControl "visibleInRefractions";
		editorTemplate -addControl "castsShadows";
		editorTemplate -addControl "receiveShadows";
		editorTemplate -addControl "motionBlur";
		editorTemplate -addControl "primaryVisibility";
		editorTemplate -endNoOptimize;
	editorTemplate -endLayout;
	
	// This layout should be opened on creation to force
	// the creation of its nested UI.  This is because
	// AEgenericPerParticle.mel will explicitly attempt
	// to open this layout later on anyway.
	//
	editorTemplate -beginLayout (uiRes("m_AEparticleLayout.kPerParticle"))  -collapse false;
		editorTemplate -callCustom 
			"AEgenericPerParticle \"unused\""
			"AEgenericPerParticle \"unused\""
			"genericPP";

		editorTemplate -suppress "rampPosition";
		editorTemplate -suppress "rampVelocity";
		editorTemplate -suppress "rampAcceleration";
		editorTemplate -suppress "position";
		editorTemplate -suppress "velocity";
		editorTemplate -suppress "acceleration";
		editorTemplate -suppress "uvSetTweakLocation";
		editorTemplate -suppress "renderInfo";

	editorTemplate -endLayout;

	editorTemplate -beginLayout (uiRes("m_AEparticleLayout.kAddDynamicAttributes"))  -collapse 0;
		editorTemplate -callCustom "AEaddDynamicAttrNew"
				"AEaddDynamicAttrReplace"
				"count";
	editorTemplate -endLayout;		

	editorTemplate -beginLayout (uiRes("m_AEparticleLayout.kClipEffectsAttributes"))  -collapse true;
		editorTemplate -callCustom "AEparticleClipEffectsNew"
				"AEparticleClipEffectsReplace"
				"genericPP"
				;
	editorTemplate -endLayout;		

	editorTemplate -beginLayout (uiRes("m_AEparticleLayout.kSpriteAttributes"))  -collapse true;
	editorTemplate -addControl "SpriteAnimation";
	editorTemplate -addControl "SpriteStartOption";
	editorTemplate -addControl "SpriteCyclePattern";
	editorTemplate -addControl "SpriteCycleLength";
	editorTemplate -addControl "SpriteInvertCycle";
	
	editorTemplate -endLayout;		

	// Suppress this attribute until we implement it 
	// later in the Volume Controls stage
	editorTemplate -suppress "normalizeVelocity";

	// Suppress attributes so they don't appear under "Extras."
	//
	editorTemplate -suppress "cacheWidth";
	editorTemplate -suppress "inheritColor";
	editorTemplate -suppress "age";
	editorTemplate -suppress "particleId";
	editorTemplate -suppress "idQuery";
	editorTemplate -suppress "attributeQuery";
	editorTemplate -suppress "levelOfDetail";
	editorTemplate -suppress "shapeNameMsg";
	editorTemplate -suppress "event";
	editorTemplate -suppress "eventCount";
	editorTemplate -suppress "eventTest";
	editorTemplate -suppress "centroid";
	editorTemplate -suppress "opacityPP";
	editorTemplate -suppress "lifespanPP";
	editorTemplate -suppress "rgbPP";
	editorTemplate -suppress "goalPP";
	editorTemplate -suppress "ageNormalized";
	editorTemplate -suppress "expressionsAfterDynamics";
	editorTemplate -suppress "useLifespanPP";

	editorTemplate -suppress "collisionData";
	editorTemplate -suppress "collisionResilience";
	editorTemplate -suppress "collisionFriction";
	editorTemplate -suppress "traceDepth";
	editorTemplate -suppress "goalGeometry";
	editorTemplate -suppress "goalActive";
	editorTemplate -suppress "goalSmoothness";

	editorTemplate -suppress "inputGeometry";
	editorTemplate -suppress "enforceCountFromHistory";
	editorTemplate -suppress "targetGeometryWorldMatrix";

	editorTemplate -suppress "goalPP0";
	editorTemplate -suppress "goalPPCache";
	editorTemplate -suppress "opacityPP0";
	editorTemplate -suppress "opacityPPCache";
	editorTemplate -suppress "rgbPP0";
	editorTemplate -suppress "rgbPPCache";
	editorTemplate -suppress "lifespanPP0";
	editorTemplate -suppress "lifespanPPCache";
	editorTemplate -suppress "input";
	editorTemplate -suppress "output";
	editorTemplate -suppress "nextId";
	editorTemplate -suppress "nextId0";
	editorTemplate -suppress "currentSceneTime";
	editorTemplate -suppress "lastSceneTime";
	editorTemplate -suppress "inputForce";
	editorTemplate -suppress "goalStatus";
	editorTemplate -suppress "age0";
	editorTemplate -suppress "particleId0";
	editorTemplate -suppress "mass";
	editorTemplate -suppress "eventSeed";
	editorTemplate -suppress "eventRandState";
	editorTemplate -suppress "eventRandStateX";
	editorTemplate -suppress "eventRandStateY";
	editorTemplate -suppress "eventRandStateZ";
	editorTemplate -suppress "eventCountCache";
	editorTemplate -suppress "eventName";
	editorTemplate -suppress "eventValid";
	editorTemplate -suppress "eventCount";
	editorTemplate -suppress "eventEmit";
	editorTemplate -suppress "eventSplit";
	editorTemplate -suppress "eventDie";
	editorTemplate -suppress "eventRandom";
	editorTemplate -suppress "eventSpread";
	editorTemplate -suppress "eventProc";
	editorTemplate -suppress "traceDepthPP";
	editorTemplate -suppress "currentTimeSave";
	editorTemplate -suppress "useStartupCache";
	editorTemplate -suppress "startupCachePath";
	editorTemplate -suppress "startupCacheFrame";
	
	// suppress any rendering attributes
	//
	editorTemplate -suppress "spriteNumPP";
	editorTemplate -suppress "spriteScaleXPP";
	editorTemplate -suppress "spriteScaleYPP";
	editorTemplate -suppress "spriteTwistPP";
	editorTemplate -suppress "radiusPP";
	editorTemplate -suppress "incandescencePP";

	// suppress the instancing attributes
	//
	editorTemplate -suppress "instanceData";
	editorTemplate -suppress "instancePointData";

	// suppress the sprite attributes
	//
	editorTemplate -suppress "__ApplySprite__";
	editorTemplate -suppress "startIndexPP";
	editorTemplate -suppress "spriteNumRamp";
	editorTemplate -suppress "spriteNumRampU";
	editorTemplate -suppress "worldVelocityInObjectSpace";

	// include/call base class/node attributes
	// actually these are now in the particle shape
	// AEdynObjectInclude $nodeName;

	// Suppress the dynamic attributes for the fireworks clip effect,
	// as the appropriate ones will be put in a special layout.
	//
	editorTemplate -suppress "_fireworksRocket";
	editorTemplate -suppress "fireworksColors";
	editorTemplate -suppress "rocketTrailColors";
	editorTemplate -suppress "launchPositionManipMessage";
	editorTemplate -suppress "burstPositionManipMessage";
	editorTemplate -suppress "minSparksCount";
	editorTemplate -suppress "maxSparksCount";
	editorTemplate -suppress "sparksColorSpread";
	editorTemplate -suppress "maxBurstSpeed";
	editorTemplate -suppress "rocketGravity";
	editorTemplate -suppress "launchPositionPP";
	editorTemplate -suppress "burstPositionPP";
	editorTemplate -suppress "launchFramePP";
	editorTemplate -suppress "burstFramePP";
	editorTemplate -suppress "initialVelocity";
	editorTemplate -suppress "launched";
	editorTemplate -suppress "hasBurst";
	editorTemplate -suppress "colorPaletteProc";
	editorTemplate -suppress "spin";
	editorTemplate -suppress "showAllBurstPositions";
	editorTemplate -suppress "showAllLaunchPositions";
	editorTemplate -suppress "localGravX";
	editorTemplate -suppress "localGravY";
	editorTemplate -suppress "localGravZ";
	editorTemplate -suppress "burstColorIndex";
	editorTemplate -suppress "explodeChance";
	editorTemplate -suppress "displayGeometry";
	editorTemplate -suppress "spinSpeed";
	editorTemplate -suppress "spinSpread";
	editorTemplate -suppress "rocketsMessage";
	editorTemplate -suppress "deformedPosition";
	editorTemplate -callCustom "AEdeformPosReplace" "AEdeformPosReplace" "deformedPosition";

	AEgeometryShapeTemplate $nodeName;
	
	editorTemplate -addExtraControls;

}

global proc AEdeformPosReplace( string $attrName )
{
	string $tmp[];
	tokenize($attrName, ".", $tmp);
	string $nodeName = $tmp[0];

	string $inputConnections[] = `listConnections -plugs on -d off -s on ($nodeName + ".deformedPosition")`;
	if( size($inputConnections) > 0 ) {
 		editorTemplate -dimControl $nodeName "isDynamic" 		true;
 		editorTemplate -dimControl $nodeName "dynamicsWeight" 		true;
 		editorTemplate -dimControl $nodeName "conserve" 		true;
 		editorTemplate -dimControl $nodeName "forcesInWorld" 		true;
 		editorTemplate -dimControl $nodeName "cacheData" 		true;
 		editorTemplate -dimControl $nodeName "maxCount" 		true;
 		editorTemplate -dimControl $nodeName "levelOfDetail" 		true;
 		editorTemplate -dimControl $nodeName "inheritFactor" 		true;
 		editorTemplate -dimControl $nodeName "emissionInWorld" 		true;
 		editorTemplate -dimControl $nodeName "dieOnEmissionVolumeExit" 	true;
 		editorTemplate -dimControl $nodeName "lifespanMode" 		true;
 		editorTemplate -dimControl $nodeName "lifespan" 		true;
 		editorTemplate -dimControl $nodeName "lifespanRandom" 		true;
 		editorTemplate -dimControl $nodeName "generalSeed" 		true;
 		editorTemplate -dimControl $nodeName "count" 			true;
 		editorTemplate -dimControl $nodeName "totalEventCount" 		true;
	} else {
 		editorTemplate -dimControl $nodeName "isDynamic" 		false;
 		editorTemplate -dimControl $nodeName "dynamicsWeight" 		false;
 		editorTemplate -dimControl $nodeName "conserve" 		false;
 		editorTemplate -dimControl $nodeName "forcesInWorld" 		false;
 		editorTemplate -dimControl $nodeName "cacheData" 		false;
 		editorTemplate -dimControl $nodeName "maxCount" 		false;
 		editorTemplate -dimControl $nodeName "levelOfDetail" 		false;
 		editorTemplate -dimControl $nodeName "inheritFactor" 		false;
 		editorTemplate -dimControl $nodeName "emissionInWorld" 		false;
 		editorTemplate -dimControl $nodeName "dieOnEmissionVolumeExit" 	false;
 		editorTemplate -dimControl $nodeName "lifespanMode" 		false;
 		editorTemplate -dimControl $nodeName "lifespan" 		false;
 		editorTemplate -dimControl $nodeName "lifespanRandom" 		false;
 		editorTemplate -dimControl $nodeName "generalSeed" 		false;
 		editorTemplate -dimControl $nodeName "count" 			false;
 		editorTemplate -dimControl $nodeName "totalEventCount" 		false;
	}
}


global proc checkAddDynamicAttrButtonStatus ( string $nodeName )
{
	if (`attributeQuery -exists -node $nodeName "opacityPP"` &&
		`attributeQuery -exists -node $nodeName "opacity"`)
	{
		button -e -en 0 addOpacityAttrButton;
	} else {
		button -e -en 1 addOpacityAttrButton;
	}
}
