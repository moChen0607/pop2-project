// Copyright (C) 1997-2014 Autodesk, Inc., and/or its licensors.
// All rights reserved.
//
// The coded instructions, statements, computer programs, and/or related
// material (collectively the "Data") in these files contain unpublished
// information proprietary to Autodesk, Inc. ("Autodesk") and/or its licensors,
// which is protected by U.S. and Canadian federal copyright law and by
// international treaties.
//
// The Data is provided for use exclusively by You. You have the right to use,
// modify, and incorporate this Data into other products for purposes authorized 
// by the Autodesk software license agreement, without fee.
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND. AUTODESK
// DOES NOT MAKE AND HEREBY DISCLAIMS ANY EXPRESS OR IMPLIED WARRANTIES
// INCLUDING, BUT NOT LIMITED TO, THE WARRANTIES OF NON-INFRINGEMENT,
// MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE, OR ARISING FROM A COURSE 
// OF DEALING, USAGE, OR TRADE PRACTICE. IN NO EVENT WILL AUTODESK AND/OR ITS
// LICENSORS BE LIABLE FOR ANY LOST REVENUES, DATA, OR PROFITS, OR SPECIAL,
// DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES, EVEN IF AUTODESK AND/OR ITS
// LICENSORS HAS BEEN ADVISED OF THE POSSIBILITY OR PROBABILITY OF SUCH DAMAGES.

//
//	Procedure Name:
//	AEnurbsSurfaceTemplate
//
//	Description Name;
//	Creates the attribute editor controls for the nurbsSurface node
//
//	Input Value:
//	nodeName
//
//	Output Value:
//	None
//


global proc AEnurbsSurfaceUpdateRefreshButton( string $nodeName )
{
    int $display = `getAttr ($nodeName + ".displayRenderTessellation")`;
    int $explicit = `getAttr ($nodeName + ".explicitTessellationAttributes")`;
    int $minScreen = `getAttr ($nodeName + ".useMinScreen")`;

    if ($display && $explicit && $minScreen)
    {
        button -e -enable true refreshButton;
    }
    else {
        button -e -enable false refreshButton;
    }
}

global proc AEnurbsCheckSmoothEdge ( string $nodeName )
{
	string $nodeAttr = $nodeName + ".smoothEdge";
	int $value = `getAttr $nodeAttr`;
	editorTemplate -dimControl $nodeName "smoothEdgeRatio" (!$value);
}

global proc AEnurbsCheckUseChordHeight ( string $nodeName ) 
{
	int $enableIt = `getAttr ($nodeName+".useChordHeight")`;

    if (!`getAttr ($nodeName+".explicitTessellationAttributes")`) {
        $enableIt = false;
    }

	editorTemplate -dimControl $nodeName "chordHeight" (!$enableIt);
}

global proc AEnurbsCheckUseChordHeightRatio ( string $nodeName ) 
{
	int $enableIt = `getAttr ($nodeName+".useChordHeightRatio")`;

    if (!`getAttr ($nodeName+".explicitTessellationAttributes")`)
        $enableIt = false;

	editorTemplate -dimControl $nodeName "chordHeightRatio" (!$enableIt);
}

global proc AEnurbsCheckUseMinScreen ( string $nodeName ) 
{
	int $enableIt = `getAttr ($nodeName+".useMinScreen")`;

    if (!`getAttr ($nodeName+".explicitTessellationAttributes")`)
        $enableIt = false;

	editorTemplate -dimControl $nodeName "minScreen" (!$enableIt);

    // The custom controls may not yet be created
    if (`button -exists refreshButton`) {
        AEnurbsSurfaceUpdateRefreshButton($nodeName);
    }
}

proc nurbsDisplayTessControls(string $nodeName)
{

	editorTemplate -beginLayout (uiRes("m_AEnurbsSurfaceTemplate.kSimpleTesselationOptions"));
	    editorTemplate -addControl "curvatureTolerance";
		editorTemplate -addControl "uDivisionsFactor";
		editorTemplate -addControl "vDivisionsFactor";
	editorTemplate -endLayout;

	editorTemplate -beginLayout (uiRes("m_AEnurbsSurfaceTemplate.kAdvancedTessellation"));

		editorTemplate -beginLayout (uiRes("m_AEnurbsSurfaceTemplate.kPrimaryTessellationAttr"))
			-collapse 0;
		    editorTemplate -addControl "modeU";
			editorTemplate -addControl "numberU";
			editorTemplate -addControl "modeV";
			editorTemplate -addControl "numberV";
		editorTemplate -endLayout;

		editorTemplate -beginLayout (uiRes("m_AEnurbsSurfaceTemplate.kSecondaryTessellationAttr"))
			-collapse 0;
		    editorTemplate -addControl "useChordHeight"
				"AEnurbsCheckUseChordHeight";
			editorTemplate -addControl "chordHeight";
			editorTemplate -addControl "useChordHeightRatio"
				"AEnurbsCheckUseChordHeightRatio";
			editorTemplate -addControl "chordHeightRatio";
			editorTemplate -addControl "useMinScreen"
				"AEnurbsCheckUseMinScreen";
			editorTemplate -addControl "minScreen";
		editorTemplate -endLayout;

	editorTemplate -endLayout;

	editorTemplate -beginLayout (uiRes("m_AEnurbsSurfaceTemplate.kCommonTesselationOptions"));
	    editorTemplate -addControl "smoothEdge" "AEnurbsCheckSmoothEdge";
		editorTemplate -addControl "smoothEdgeRatio";
		editorTemplate -addControl "edgeSwap";
	editorTemplate -endLayout;

}

global proc AEnurbsCheckDisplayTesselation( string $nodeName )
{

	int $value = `getAttr ($nodeName+".displayRenderTessellation")`;

    if ( $value ) {
        attrFieldSliderGrp -e -enable true triangleCountField;

        string $modelPanel = "";

        // Get the active model panel
        //

        string $activePanel = `getPanel -withFocus`;

        if (`modelPanel -exists $activePanel`) {
            $modelPanel = $activePanel;
        }
        else {
            // Look for a model panel with a renderable camera
            //

            string $panels[] = `getPanel -visiblePanels`;

            for ($panel in $panels) {
                if (`modelPanel -exists $panel`) {
                    string $camera = `modelPanel -q -camera $panel`;

                    if (`getAttr ($camera+".renderable")`) {
                        $modelPanel = $panel;
                        break;
                    }
                }
            }
        }
                            
        if ($modelPanel != "") {
            // Select the node so wire frame is on top of shaded

            if (size(`ls -selection $nodeName`) == 0)
                select $nodeName;

            string $editor = `modelPanel -q -modelEditor $modelPanel`;

            string $appear = `modelEditor -q -displayAppearance $editor`;

            if ($appear != "smoothShaded" && $appear != "flatShaded") {
                // Hardware shading isn't on

                modelEditor -e -displayAppearance "smoothShaded"
                    -activeOnly true $editor;
            }
        }
        else {
            warning (uiRes("m_AEnurbsSurfaceTemplate.kHardwareWarning"));
        }

    } else {
        attrFieldSliderGrp -e -en false triangleCountField;
    }

	AEnurbsSurfaceUpdateRefreshButton($nodeName);
}

global proc AEdisplayTesselationReplace( string $displayTesselationPlug,
                                         string $triangleCountPlug )
{
	string $buffer[];
	tokenize($displayTesselationPlug, ".", $buffer);
	string $nodeName = $buffer[0];

    checkBoxGrp -e
        -changeCommand ("AEnurbsCheckDisplayTesselation "+$nodeName)
        displayTesselationBox;

    connectControl -index 2 displayTesselationBox $displayTesselationPlug;

    button -e -command ("setAttr " + $displayTesselationPlug + " true") 
        refreshButton;

    AEnurbsSurfaceUpdateRefreshButton( $nodeName );

    int $enableIt = `getAttr $displayTesselationPlug`;

    attrFieldSliderGrp -e
        -attribute $triangleCountPlug
        -enable $enableIt
        triangleCountField;
}

global proc AEdisplayTesselationNew( string $displayTesselationPlug,
							  string $triangleCountPlug )
{
	setUITemplate -pst attributeEditorTemplate;

    checkBoxGrp -numberOfCheckBoxes 1
        -label ""
        -label1 (uiRes("m_AEnurbsSurfaceTemplate.kDisplayRender"))
        -annotation (uiRes("m_AEnurbsSurfaceTemplate.kDisplaytessellationAnnot"))
        displayTesselationBox;

    rowLayout -numberOfColumns 2;
        text -label "";

	    button -label (uiRes("m_AEnurbsSurfaceTemplate.kRefreshTessellation"))
		    refreshButton;
	setParent ..;

    attrFieldSliderGrp
        -label (uiRes("m_AEnurbsSurfaceTemplate.kTriangleCount"))
        triangleCountField;

	setUITemplate -ppt;

    AEdisplayTesselationReplace($displayTesselationPlug, $triangleCountPlug);
}

global proc AEnurbsCheckExplicitTessellation ( string $nodeName )
{
	string $nodeAttr = $nodeName + ".explicitTessellationAttributes";
	int $value = `getAttr $nodeAttr`;
    // The custom controls may not yet be created
    if (`button -exists refreshButton`) {
        AEnurbsSurfaceUpdateRefreshButton($nodeName);
    }
    editorTemplate -dimControl $nodeName "uDivisionsFactor" ($value);
    editorTemplate -dimControl $nodeName "vDivisionsFactor" ($value);
    editorTemplate -dimControl $nodeName "curvatureTolerance" ($value);
    editorTemplate -dimControl $nodeName "modeU" (!$value);
    editorTemplate -dimControl $nodeName "numberU" (!$value);
    editorTemplate -dimControl $nodeName "modeV" (!$value);
    editorTemplate -dimControl $nodeName "numberV" (!$value);

    int $enableIt;

    editorTemplate -dimControl $nodeName "useChordHeight" (!$value);
    $enableIt = (`getAttr ($nodeName+".useChordHeight")`) && $value;
    editorTemplate -dimControl $nodeName "chordHeight" (!$enableIt);

    editorTemplate -dimControl $nodeName "useChordHeightRatio" (!$value);
    $enableIt = (`getAttr ($nodeName+".useChordHeightRatio")`) && $value;
    editorTemplate -dimControl $nodeName "chordHeightRatio" (!$enableIt);

    editorTemplate -dimControl $nodeName "useMinScreen" (!$value);
    $enableIt = (`getAttr ($nodeName+".useMinScreen")`) && $value;
    editorTemplate -dimControl $nodeName "minScreen" (!$enableIt);
}



//
// Procedure Name:
//   AEcurvePrecisionShaded
//	 This procedure exists just to over-ride the attribute name
//	 because it's too long to fit with the 
//   Attribute Editor LHS col = 130 pixels
//
global proc AEcurvePrecisionShadedNew( string $attrName )
{
	setUITemplate -pst attributeEditorTemplate;	
 	attrFieldSliderGrp -attribute $attrName -label (uiRes("m_AEnurbsSurfaceTemplate.kCrvPrecisionShaded"))
    	crvPrecShadedSlider;
    setUITemplate -ppt;
}

global proc AEcurvePrecisionShadedReplace( string $attrName )
{
 	attrFieldSliderGrp -e -attribute $attrName -label (uiRes("m_AEnurbsSurfaceTemplate.kCrvPrecisionShadedReplave"))
    	crvPrecShadedSlider;
}

global proc AEgridDivisionPerSpanUNew( string $attrName )
{
	setUITemplate -pst attributeEditorTemplate;	
 	attrFieldSliderGrp -attribute $attrName -label (uiRes("m_AEnurbsSurfaceTemplate.kGridDivPerSpanU"))
            gridDivPerSpanUSlider;
    setUITemplate -ppt;
}

global proc AEgridDivisionPerSpanUReplace( string $attrName )
{
 	attrFieldSliderGrp -e -attribute $attrName -label (uiRes("m_AEnurbsSurfaceTemplate.kGridDivPerSpanUReplace"))
            gridDivPerSpanUSlider;
}

global proc AEgridDivisionPerSpanVNew( string $attrName )
{
	setUITemplate -pst attributeEditorTemplate;	
 	attrFieldSliderGrp -attribute $attrName -label (uiRes("m_AEnurbsSurfaceTemplate.kGridDivPerSpanV"))
            gridDivPerSpanVSlider;
    setUITemplate -ppt;
}

global proc AEgridDivisionPerSpanVReplace( string $attrName )
{
 	attrFieldSliderGrp -e -attribute $attrName -label (uiRes("m_AEnurbsSurfaceTemplate.kGridDivPerSpanVReplace"))
            gridDivPerSpanVSlider;
}

global proc AEnurbsCheckTextureMapStatus ( string $nodeName ) 
{
	string $nodeAttr = $nodeName + ".fixTextureWarp";
	int $value = `getAttr $nodeAttr`;
	editorTemplate -dimControl $nodeName "gridDivisionPerSpanU" (!$value);
	editorTemplate -dimControl $nodeName "gridDivisionPerSpanV" (!$value);
}


global proc AEnurbsSurfaceTemplate( string $nodeName )
{
	editorTemplate -beginScrollLayout;
		
	editorTemplate -beginLayout (uiRes("m_AEnurbsSurfaceTemplate.kNURBSSurfaceHistory")) -collapse 0;
		editorTemplate -addControl "minMaxRangeU";
		editorTemplate -addControl "minMaxRangeV";
		editorTemplate -addControl "spansUV";
		editorTemplate -addControl "degreeUV";
		editorTemplate -addControl "formU";
		editorTemplate -addControl "formV";

		editorTemplate -addComponents;
	editorTemplate -endLayout;

	editorTemplate -beginLayout (uiRes("m_AEnurbsSurfaceTemplate.kNURBSSurfaceDisplay")) ;
		editorTemplate -addControl "curvePrecision";
		editorTemplate -callCustom "AEcurvePrecisionShadedNew" 
			"AEcurvePrecisionShadedReplace" "curvePrecisionShaded";
		editorTemplate -addControl "simplifyMode";
		editorTemplate -addControl "simplifyU";
		editorTemplate -addControl "simplifyV";
		editorTemplate -addControl "divisionsU";
		editorTemplate -addControl "divisionsV";
		editorTemplate -addControl "normalsDisplayScale";
	editorTemplate -endLayout;
	
	editorTemplate -beginLayout (uiRes("m_AEnurbsSurfaceTemplate.kTessellation"));
		editorTemplate
            -callCustom "AEdisplayTesselationNew" "AEdisplayTesselationReplace"
            "displayRenderTessellation" "renderTriangleCount";

		editorTemplate
			-label (uiRes("m_AEnurbsSurfaceTemplate.kEnableAdvancedTessellation"))
			-addControl "explicitTessellationAttributes"
			"AEnurbsCheckExplicitTessellation";

		nurbsDisplayTessControls($nodeName);

	editorTemplate -endLayout;

	editorTemplate -beginLayout (uiRes("m_AEnurbsSurfaceTemplate.kTextureMap")) ;
		editorTemplate -addControl "fixTextureWarp" AEnurbsCheckTextureMapStatus;
		editorTemplate -callCustom "AEgridDivisionPerSpanUNew"
			"AEgridDivisionPerSpanUReplace" "gridDivisionPerSpanU";
		editorTemplate -callCustom "AEgridDivisionPerSpanVNew"
			"AEgridDivisionPerSpanVReplace" "gridDivisionPerSpanV";
	editorTemplate -endLayout;

	// include/call base class/node attributes
	AEsurfaceShapeTemplate $nodeName;

	//suppressed attributes
	editorTemplate -suppress "inPlace";
	editorTemplate -suppress "tweakSizeU";
	editorTemplate -suppress "tweakSizeV";
	editorTemplate -suppress "cached";
	editorTemplate -suppress "dispCV";
	editorTemplate -suppress "dispSF";
	editorTemplate -suppress "dispEP";
	editorTemplate -suppress "dispHull";
	editorTemplate -suppress "dispGeometry";
	editorTemplate -suppress "dispOrigin";
	editorTemplate -suppress "header";
	editorTemplate -suppress "create";
	editorTemplate -suppress "local";
	editorTemplate -suppress "worldSpace";
	editorTemplate -suppress "trimFace";
	editorTemplate -suppress "selCVDisp";
    editorTemplate -suppress "displayRenderTessellation";
    editorTemplate -suppress "basicTessellationType";
	editorTemplate -suppress "collisionOffsetVelocityIncrement";
	editorTemplate -suppress "collisionDepthVelocityIncrement";

	editorTemplate -addExtraControls;

	editorTemplate -addDynamicControl "collisionEnable";
	editorTemplate -addDynamicControl "collisionOffset";
	editorTemplate -addDynamicControl "collisionDepth";
	editorTemplate -addDynamicControl "collisionPriority";
	editorTemplate -addDynamicControl "depthMapEnable";
	editorTemplate -addDynamicControl "depthMapWeight";
	editorTemplate -addDynamicControl "displayCollision";
	AEaddDynRampClothCollision "collisionOffsetVelocityMultiplier";
	AEaddDynRampClothCollision "collisionDepthVelocityMultiplier";

	editorTemplate -endScrollLayout;
}
