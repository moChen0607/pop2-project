// Copyright (C) 1997-2014 Autodesk, Inc., and/or its licensors.
// All rights reserved.
//
// The coded instructions, statements, computer programs, and/or related
// material (collectively the "Data") in these files contain unpublished
// information proprietary to Autodesk, Inc. ("Autodesk") and/or its licensors,
// which is protected by U.S. and Canadian federal copyright law and by
// international treaties.
//
// The Data is provided for use exclusively by You. You have the right to use,
// modify, and incorporate this Data into other products for purposes authorized 
// by the Autodesk software license agreement, without fee.
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND. AUTODESK
// DOES NOT MAKE AND HEREBY DISCLAIMS ANY EXPRESS OR IMPLIED WARRANTIES
// INCLUDING, BUT NOT LIMITED TO, THE WARRANTIES OF NON-INFRINGEMENT,
// MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE, OR ARISING FROM A COURSE 
// OF DEALING, USAGE, OR TRADE PRACTICE. IN NO EVENT WILL AUTODESK AND/OR ITS
// LICENSORS BE LIABLE FOR ANY LOST REVENUES, DATA, OR PROFITS, OR SPECIAL,
// DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES, EVEN IF AUTODESK AND/OR ITS
// LICENSORS HAS BEEN ADVISED OF THE POSSIBILITY OR PROBABILITY OF SUCH DAMAGES.

//
//	Procedure Name:
//	AEloftTemplate
//
//	Description Name;
//	Creates the attribute editor controls for the loft node
//
//	Input Value:
//	nodeName
//
//	Output Value:
//	None
//

global proc AEloftTemplate( string $nodeName )
{
	string $inputCurve = (uiRes("m_AEloftTemplate.kInputCurve"));
	string $reserveCurve = (uiRes("m_AEloftTemplate.kReserveCurve"));
	editorTemplate -beginScrollLayout;

		editorTemplate -beginLayout (uiRes("m_AEloftTemplate.kLoftHistory")) -collapse false;
			editorTemplate -callCustom ("AEmultiInputNew \""+$inputCurve+"\"")
						("AEmultiInputReplace \""+$inputCurve+"\"")
						"inputCurve";
			editorTemplate -addControl "degree";
			editorTemplate -addControl "uniform";
			editorTemplate -addControl "close";
			editorTemplate -addControl "autoReverse" "autoReverseControls";
			editorTemplate -callCustom "AEloftReverseInputNew"
						"AEloftReverseInputReplace"
						($reserveCurve)
						"inputCurve"
						"reverse";
			editorTemplate -addControl "sectionSpans";
		editorTemplate -endLayout;

		// include/call base class/node attributes
		//
		AEabstractBaseCreateTemplate $nodeName;

		// Add controls for attrs not covered above in the "Loft
		// History" layout.
		//
		// Note specifically that "Reverse Surface Normals" appears in
		// this section, since we do not want to present it as an
		// "obvious" control in "Loft History".  Users modifying this
		// attribute should have to look for it.
		//
		editorTemplate -addExtraControls;

	editorTemplate -endScrollLayout;

	editorTemplate -suppress "createCusp";

}

global proc autoReverseControls( string $nodeName )
{
	string $autoRevAttrName = $nodeName + ".autoReverse";
	int $value = `getAttr $autoRevAttrName`;
	string $connections[] = eval("listConnections -d false -sh true " + $nodeName+ ".inputCurve");
	int $numInputs = size( $connections );
	int $i, $boxIndex;
	string $attReverse = "reverse";

	for ( $i = 0, $boxIndex = 0; $i < $numInputs; $i+=2, $boxIndex++ )
	{
		if ( $value == 0 )
		{
			// auto reverse is off so enable reverse check boxes
			checkBoxGrp -e -enable 1 ($attReverse+$boxIndex);
		}
		else
		{
			// auto reverse is on so disable reverse check boxes
			checkBoxGrp -e -enable 0 ($attReverse+$boxIndex);
		}
	}
}

global proc AEloftReverseInputNew ( string $attributeUIName, string $inputCrvs, string $inputReverse )
{
	setUITemplate -pst attributeEditorTemplate;

	string $buffer[];
	tokenize($inputCrvs, ".", $buffer);
	string $nodeName = $buffer[0];
	string $attInputCurve = $buffer[1];
	tokenize($inputReverse, ".", $buffer);
	string $attReverse = $buffer[1];
	tokenize($attributeUIName, ".", $buffer);
	string $attUIName = $buffer[1];

	string $connections[] = `listConnections -d false -sh true $inputCrvs`;
	int $numInputs = size( $connections );
	int $i, $j;
	string $textName1, $textName2;
	int $index, $boxIndex;
	int $reverseValue;
	string $reverseString1, $reverseString2;

	columnLayout ($attInputCurve + "Column");

	for ( $i = 0, $boxIndex = 0; $i < $numInputs; $i+=2, $boxIndex++ )
	{
		$index = $i + 1; 
		$textName1 = $attUIName + " " + $index;
		$reverseString1 = $inputReverse + "[" + $i +"]";
		if ( $i+2 > $numInputs )
		{
			checkBoxGrp -label "" -ncb 1
				-label1 $textName1
				($attReverse+$boxIndex);
				
			connectControl -index 2 ($attReverse+$boxIndex) $reverseString1;
		}
		else
		{
			$index++;
			$textName2 = $attUIName + " " + $index;
			$j = $i + 1;
			$reverseString2 = $inputReverse + "[" + $j +"]";
			checkBoxGrp -label "" -ncb 2
				-label1 $textName1
				-label2 $textName2
				($attReverse+$boxIndex);

			connectControl -index 2 ($attReverse+$boxIndex) $reverseString1;
			connectControl -index 3 ($attReverse+$boxIndex) $reverseString2;
		}
	}

	setParent ..;

	setUITemplate -ppt;
}


global proc AEloftReverseInputReplace ( string $attributeUIName, string $inputCrvs, string $inputReverse )
{
	setUITemplate -pst attributeEditorTemplate;

	string $connections[] = `listConnections -d false -sh true $inputCrvs`;
	int $numInputs = size( $connections );
	int $i, $j;
	string $textName;
	int $index, $boxIndex;

	string $buffer[];
	tokenize($inputCrvs, ".", $buffer);
	string $nodeName = $buffer[0];
	string $attInputCurve = $buffer[1];
	tokenize($inputReverse, ".", $buffer);
	string $attReverse = $buffer[1];
	tokenize($attributeUIName, ".", $buffer);
	string $attUIName = $buffer[1];

	setParent ($attInputCurve + "Column");

	// delete any old layouts
	for ( $i = 0; ; $i++ )
	{
		if ( `checkBoxGrp -ex ($attReverse+$i)` )
		{
			deleteUI ($attReverse+$i);
		}
		else
		{
			// exit the loop once no more checkboxes exist
			break;
		}
	}

	int $reverseValue;
	string $reverseString;
	for ( $i = 0, $boxIndex = 0; $i < $numInputs; $i+=2, $boxIndex++ )
	{
		$index = $i + 1; 
		$textName1 = $attUIName + " " + $index;
		$reverseString1 = $inputReverse + "[" + $i +"]";
		if ( $i+2 > $numInputs )
		{
			checkBoxGrp -label "" -ncb 1
				-label1 $textName1
				($attReverse+$boxIndex);

			connectControl -index 2 ($attReverse+$boxIndex) $reverseString1;
		}
		else
		{
			$index++;
			$textName2 = $attUIName + " " + $index;
			$j = $i + 1;
			$reverseString2 = $inputReverse + "[" + $j +"]";
			checkBoxGrp -label "" -ncb 2
				-label1 $textName1
				-label2 $textName2
				($attReverse+$boxIndex);

			connectControl -index 2 ($attReverse+$boxIndex) $reverseString1;
			connectControl -index 3 ($attReverse+$boxIndex) $reverseString2;
		}
	}

	setParent ..;
	setUITemplate -ppt;

}
