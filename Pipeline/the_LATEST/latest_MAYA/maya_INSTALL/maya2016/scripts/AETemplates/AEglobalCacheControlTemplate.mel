// Copyright (C) 1997-2014 Autodesk, Inc., and/or its licensors.
// All rights reserved.
//
// The coded instructions, statements, computer programs, and/or related
// material (collectively the "Data") in these files contain unpublished
// information proprietary to Autodesk, Inc. ("Autodesk") and/or its licensors,
// which is protected by U.S. and Canadian federal copyright law and by
// international treaties.
//
// The Data is provided for use exclusively by You. You have the right to use,
// modify, and incorporate this Data into other products for purposes authorized 
// by the Autodesk software license agreement, without fee.
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND. AUTODESK
// DOES NOT MAKE AND HEREBY DISCLAIMS ANY EXPRESS OR IMPLIED WARRANTIES
// INCLUDING, BUT NOT LIMITED TO, THE WARRANTIES OF NON-INFRINGEMENT,
// MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE, OR ARISING FROM A COURSE 
// OF DEALING, USAGE, OR TRADE PRACTICE. IN NO EVENT WILL AUTODESK AND/OR ITS
// LICENSORS BE LIABLE FOR ANY LOST REVENUES, DATA, OR PROFITS, OR SPECIAL,
// DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES, EVEN IF AUTODESK AND/OR ITS
// LICENSORS HAS BEEN ADVISED OF THE POSSIBILITY OR PROBABILITY OF SUCH DAMAGES.

//
//  Procedure Name:
//	AEglobalCacheControlTemplate
//
//  Description Name;
//	Creates the attribute editor controls for the globalCacheControl Node
//
//  Input Value:
//	nodeName 
//
//  Output Value:
//	None
// 

global proc AEcacheControlReplace()
{
	string $currentMenu = `optionMenuGrp -q -v cacheMenu`;

	int $totalMenuItems = `optionMenuGrp -q -numberOfItems cacheMenu`;

	string $allItemNames[] = `optionMenuGrp -q -ils cacheMenu`;

	string $nodes[] = `ls -type "diskCache"`;
	optionMenuGrp -e cacheMenu;

	int $nth;
	int $n = 0;
	string $mcj = "mcj";
	string $mcjNodes[];
	for( $nth = 1; $nth <= size($nodes); $nth++) {
		string $cacheType = `getAttr ($nodes[$nth-1] + ".cacheType")`;
		if( $cacheType == $mcj ) {
			$mcjNodes[$n] = $nodes[$nth-1];
			$n++;
		} 
	}

	// If no disk cache exists
	if( size($mcjNodes) == 0 ) {
		// leave one menuItem and delte the rest
		// Set the first menu item to "No Disk Cache"
		menuItem -e -label (uiRes("m_AEglobalCacheControlTemplate.kNoDiskCache")) $allItemNames[0];
		$n = 1;
	} else {
		$n = size($mcjNodes);
	}

	// Delete the rest
	for( $nth = $n+1; $nth <= $totalMenuItems; $nth++ ) {
		string $itemName = $allItemNames[$nth-1];
		deleteUI $itemName;		
	}
	if( size($mcjNodes) == 0 ) return;

	if( $totalMenuItems > $n ) $totalMenuItems = $n;

	// Build menu items for each disk cache
	int $currentNth = 1;
	for( $nth = 1; $nth <= $totalMenuItems; $nth++ ) {
		string $tmpName = `getAttr ($mcjNodes[$nth-1] + ".cacheName")`;
		if( size($tmpName) == 0 ) 
			$tmpName = `getAttr ($mcjNodes[$nth-1] + ".hiddenCacheName")`;
		if( $tmpName == $currentMenu ) $currentNth = $nth;
		optionMenuGrp -e -sl $nth cacheMenu;
		menuItem -e -l $tmpName $allItemNames[$nth - 1];
	}
    // This is a fix to get around the optionMenuGrp bug (#81337)
    string $fullName = `setParent "cacheMenu"`;
    string $menuName = ($fullName+"|OptionMenu");
    setParent -m $menuName;
	for( $nth = $totalMenuItems + 1; $nth <= size($mcjNodes); $nth++ ) {
		string $tmpName = `getAttr ($mcjNodes[$nth-1] + ".cacheName")`;
		if( size($tmpName) == 0 ) 
			$tmpName = `getAttr ($mcjNodes[$nth-1] + ".hiddenCacheName")`;
		if( $tmpName == $currentMenu ) $currentNth = $nth;
		menuItem -l $tmpName;
	}

	// Set the current menuItem
	optionMenuGrp -e -sl $currentNth cacheMenu;
	if( size($mcjNodes) >= 0 ) {
		string $selectedCache = $mcjNodes[$currentNth-1];
		connectControl -index 2 startTime ($selectedCache+".startTime");
		connectControl -index 2 endTime ($selectedCache+".endTime");
		connectControl -index 2 samplingRate ($selectedCache+".samplingRate");
		connectControl -index 2 samplingType ($selectedCache+".samplingType");
	} else {
		menuItem -label (uiRes("m_AEglobalCacheControlTemplate.kNoDiskCache"));
		floatFieldGrp -e -value1 0 startTime;
		floatFieldGrp -e -value1 0 endTime;
		optionMenuGrp -e -sl $currentNth samplingType;
		menuItem -label (uiRes("m_AEglobalCacheControlTemplate.kOverSample"));
		intFieldGrp   -e -value1 0 samplingRate;
	}

	setParent ..;
}

global proc AEcacheControlNew()
{
	setUITemplate -pushTemplate attributeEditorTemplate;
		optionMenuGrp -label (uiRes("m_AEglobalCacheControlTemplate.kCacheName")) cacheMenu;
                menuItem -label (uiRes("m_AEglobalCacheControlTemplate.kNoDiskCache"));
	setUITemplate -popTemplate;

	setUITemplate -pushTemplate attributeEditorTemplate;
		floatFieldGrp -nf 1 -en1 false -label (uiRes("m_AEglobalCacheControlTemplate.kStartTime")) startTime;
		floatFieldGrp -nf 1 -en1 false -label (uiRes("m_AEglobalCacheControlTemplate.kEndTime")) endTime;
		optionMenuGrp -en false -label (uiRes("m_AEglobalCacheControlTemplate.kSamplingType")) samplingType;
			menuItem -label (uiRes("m_AEglobalCacheControlTemplate.kOverSample"));
			menuItem -label (uiRes("m_AEglobalCacheControlTemplate.kUnderSample"));
		intFieldGrp -nf 1 -en1 false -label (uiRes("m_AEglobalCacheControlTemplate.kSamplingRate")) samplingRate;
	setUITemplate -popTemplate;

	AEcacheControlReplace;
}

global proc AEdeleteAllCache()
{
	string $caches[] = `ls -type "diskCache"`;
	for( $c in $caches ) {
		// Only delete all *jiggle* caches...
		//
		if( `getAttr ($c + ".cacheType")` == "mcj" ) {
			diskCache -delete $c;
		}
	}

	AEcacheControlReplace;
}

global proc AEdeleteAllCacheNew()
{
	setUITemplate -pst attributeEditorTemplate;
	rowLayout -nc 2;
		text -label " ";
		button -label (uiRes("m_AEglobalCacheControlTemplate.kDeleteAllCaches"))
			   -c ("evalEcho AEdeleteAllCache") 
			   -width 80 deleteAllCache;
		setParent ..;
	setUITemplate -ppt;
}

global proc AEdeleteAllCacheReplace()
{

}

global proc AEglobalCacheEnableNew()
//
// Description:
//	Create the option menu for enabling/disabling all 
//	jiggle caches.
//
{
	setUITemplate -pst attributeEditorTemplate;

	optionMenuGrp -label (uiRes("m_AEglobalCacheControlTemplate.kEnableStatus"))
		-cc AEglobalCacheEnableChanged
		globalCacheEnable;

		menuItem -label (uiRes("m_AEglobalCacheControlTemplate.kEnableAll"));
		menuItem -label (uiRes("m_AEglobalCacheControlTemplate.kDisableAll"));
		setParent ..;

	setUITemplate -ppt attributeEditorTemplate;

	AEglobalCacheEnableReplace();
}

global proc AEglobalCacheEnableReplace()
//
// Description:
//	We have to "connect" the option menu so that it displays
//	the right value : are all jiggle caches enabled or disabled?
//	
{
	int $onCount  = 0;
	int $offCount = 0;
	int $jiggleCount = 0;

	string $caches[] = `ls -type diskCache`;
	for( $c in $caches ) {
		if( `getAttr ($c + ".cacheType" )` != "mcj" ) {
			continue;
		}

		$jiggleCount++;

		if( `getAttr ( $c + ".enable" )` ) {
			$onCount++;
		} else {
			$offCount++;
		}
	}

	// Select the All Enabled item
	//
	if( $onCount == $jiggleCount ) {
		optionMenuGrp -e -v (uiRes("m_AEglobalCacheControlTemplate.kEnableAll")) globalCacheEnable;
	} 
	// Select the All Disbled item
	//
	else if( $offCount == $jiggleCount ) {
		optionMenuGrp -e -v (uiRes("m_AEglobalCacheControlTemplate.kDisableAll")) globalCacheEnable;
	} 
	// Cache status is mixed.  If we're showing
	// UI that indicates they're all on or all off,
	// we'd better set them that way...
	// 
	// Note that there's no UI to turn an individual
	// diskCache node on or off, so this actually
	// shouldn't really even happen...
	//
	else {
		AEglobalCacheEnableChanged();
	}
}

proc AEglobalCacheSetAllJiggle( int $enable )
//
// Description:
//	Helper proc to set the enabled state of all jiggle caches.
//	
{
	string $caches[] = `ls -type diskCache`;
	for( $c in $caches ) {
		if( `getAttr ($c + ".cacheType" )` != "mcj" ) {
			continue;
		}

		setAttr ( $c + ".enable" ) $enable;
	}
}

global proc AEglobalCacheEnableChanged()
//
// Description:
//	Take the current value of the option menu and apply it
//	to all jiggle caches in the scene.
//
{
	string $status = `optionMenuGrp -q -value globalCacheEnable`;
	if( $status == (uiRes("m_AEglobalCacheControlTemplate.kEnableAll")) ) {
		AEglobalCacheSetAllJiggle( true );
	} else if( $status == (uiRes("m_AEglobalCacheControlTemplate.kDisableAll")) ) {
		AEglobalCacheSetAllJiggle( false );
	}
}

global proc AEglobalCacheControlTemplate ( string $nodeName )
{
	editorTemplate -beginScrollLayout;  
	editorTemplate -beginLayout (uiRes("m_AEglobalCacheControlTemplate.kControlForAllCaches")) -collapse false;
		editorTemplate -suppress enableStatus;
		editorTemplate -callCustom "AEglobalCacheEnableNew" "AEglobalCacheEnableReplace";

       	editorTemplate -callCustom "AEdeleteAllCacheNew" "AEdeleteAllCacheReplace";
	editorTemplate -endLayout;

	editorTemplate -beginLayout (uiRes("m_AEglobalCacheControlTemplate.kIndividualCacheStatus")) -collapse false;
		editorTemplate -callCustom "AEcacheControlNew"
			"AEcacheControlReplace" ;
	editorTemplate -endLayout;

	editorTemplate -suppress writeEnable;

	AEdependNodeTemplate $nodeName;

	editorTemplate -addExtraControls;
	editorTemplate -endScrollLayout;  

}
