// Copyright (C) 1997-2014 Autodesk, Inc., and/or its licensors.
// All rights reserved.
//
// The coded instructions, statements, computer programs, and/or related
// material (collectively the "Data") in these files contain unpublished
// information proprietary to Autodesk, Inc. ("Autodesk") and/or its licensors,
// which is protected by U.S. and Canadian federal copyright law and by
// international treaties.
//
// The Data is provided for use exclusively by You. You have the right to use,
// modify, and incorporate this Data into other products for purposes authorized 
// by the Autodesk software license agreement, without fee.
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND. AUTODESK
// DOES NOT MAKE AND HEREBY DISCLAIMS ANY EXPRESS OR IMPLIED WARRANTIES
// INCLUDING, BUT NOT LIMITED TO, THE WARRANTIES OF NON-INFRINGEMENT,
// MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE, OR ARISING FROM A COURSE 
// OF DEALING, USAGE, OR TRADE PRACTICE. IN NO EVENT WILL AUTODESK AND/OR ITS
// LICENSORS BE LIABLE FOR ANY LOST REVENUES, DATA, OR PROFITS, OR SPECIAL,
// DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES, EVEN IF AUTODESK AND/OR ITS
// LICENSORS HAS BEEN ADVISED OF THE POSSIBILITY OR PROBABILITY OF SUCH DAMAGES.

// FILE: AEmeshRelated.mel
// INPUT: string (node name)
// RETURN:	string[] (list of related nodes, with the node whose
//			tab you want to be opened duplicated at the
//			end of the array)
//

global proc string[] AEmeshRelated( string $node )
{
	int $isNucleus = false;	// Is this mesh really a nucleus object?
	string $retval[];
	string $shadingNode;
	// Make sure that the shape is first in the list so that

	$retval[0] = $node;

	// Get the default tabs for this node

	string $relNodes[] = `defaultNavigation -ren -d $node`;
	string $preferredNode = `defaultNavigation -dwn -d $node`;

	for ($relNode in $relNodes) {
		$retval[size($retval)] = $relNode;
	}

	// Get the connections to the mesh node

	string $plugs[] = `listConnections -s false -sh true -d true $node`;

	// Look for a connected shading engine - this is
	// the jumping off point to get to the rendering nodes
	// from a selected surface

	for( $plug in $plugs ) {
		string $nType = `nodeType $plug`;
		if ( $nType == "shadingEngine" ) {

			// Get the shader that's connected to this
			// shading engine
			
			string $mayaShaders[] =
					`listConnections ( $plug + ".surfaceShader" )`;
			
			string $customShaders[];
			clear($customShaders);
			string $customShadersArray[] = `callbacks -executeCallbacks -hook "allConnectedShaders" $plug`;
			string $customShadersAsString;
			for( $customShadersAsString in $customShadersArray )
			{
				string $tokens[];
				tokenize($customShadersAsString, ":", $tokens);
				appendStringArray($customShaders, $tokens, size($tokens));
			}
			
			// If the connection is null, then there is no
			// shading group attached to this node - simply
			// return the node itself.

			int $mayaSize = size($mayaShaders);
			int $customShadersSize = size($customShaders);
			if ($mayaSize == 0 && $customShadersSize == 0) {
				$retval[size($retval)] = $plug;
			} else {
				appendStringArray($retval, $mayaShaders, $mayaSize);
				appendStringArray($retval, $customShaders, $customShadersSize);
			}
		}
	}


	// the above loop breaks out after the 1st shading connection, go back again
	// and look through the output connections some more for other interesting
	// node.
	//
	
	for( $plug in $plugs ) {
		string $nType = `nodeType $plug`;
		if( $nType == "pfxToon" ){
			$retval[size($retval)] = $plug;
		} else if( $nType == "nCloth" || $nType == "nRigid" || $nType == "nParticle"){
			$isNucleus = true;
			// Add the parent transform, if any
			//
			string $parents[] = `listRelatives -parent $plug`;
			if( size($parents) > 0 ){
				$retval[size($retval)] = $parents[0];
			}
			$retval[size($retval)] = $plug;
			$preferredNode = $plug;
			string $relatedScript = "AE" + $nType + "Related";

			string $nThingRelated[] = eval($relatedScript+" \""+$plug+"\"");
			if( size($nThingRelated) > 0 ){
				string $tmpNodes[] = $retval;
				$retval = stringArrayCatenate( $tmpNodes, $nThingRelated );
			}
		} else  if( $nType == "bifrostContainer") {
			$retval[size($retval)] = $plug;
		}
	}

	// Now check the source connections to the mesh node for PFX strokes and Nucleus nodes

	string $nodes[] = `listHistory -future false $node`;
	string $hNode;
	string $gNode;

	// Check the src connections for Nucleus nodes too
	// i.e. look for nCloth or nRigid nodes, and if we find one, get the nucleus solver node that
	// its associated with. We stop after finding one, which should cover most cases
	// at worst we might miss some if we had a polyUnite of cloth objects or something

	for( $hNode in $nodes ) {
		string $nType = `nodeType $hNode`;
		if( $nType == "nCloth" || $nType == "nRigid" || $nType == "nParticle" ){
			$retval[size($retval)] = $hNode;
			$preferredNode = $hNode;
			$isNucleus = true;
			string $relatedScript = "AE" + $nType + "Related";

			string $nThingRelated[] = eval($relatedScript+" \""+$hNode+"\"");
			if( size($nThingRelated) > 0 ){
				string $tmpNodes[] = $retval;
				$retval = stringArrayCatenate( $tmpNodes, $nThingRelated );
			}
			break;
		}

	}

	// PFX nodes are dagObjects, so searching for related nodes skips them
	// (the only reason we usually find the intemediate mesh shapes in
	// history is that they happen to be siblings)
	// so we search for strokes explicitly, and add in their related nodes

	// can't do this if pfx slice not loaded
	// string $pfxGeomNodes[] = `ls -type "pfxGeometry" $nodes`;
	// so we need to check the types explicitly

	string $pfxGeomNodes[];


	for( $gNode in $nodes ) {
		if (( `nodeType $gNode` == "stroke" )
		 || ( `nodeType $gNode` == "pfxHair" )
		 || ( `nodeType $gNode` == "pfxToon" )) {
			$pfxGeomNodes[size($pfxGeomNodes)] = $gNode;
		}
	}

	for( $hNode in $pfxGeomNodes ) {
		$retval[size($retval)] = $hNode;
		string $tmp1[] = `defaultNavigation -ren -d $hNode`;
		for ($relNode in $tmp1) {
			$retval[size($retval)] = $relNode;
		}
	}
	
	// check for connections from fluid to poly
	for ($gNode in $nodes ){
		if(	nodeType( $gNode ) == "fluidShape" ){
			$retval[size($retval)] = $gNode;
		}
	}
	
	if( $preferredNode == "" ) {
		$preferredNode = $node;
	}
	$retval[size($retval)] = $preferredNode;

	return $retval;
}

