// Copyright (C) 1997-2014 Autodesk, Inc., and/or its licensors.
// All rights reserved.
//
// The coded instructions, statements, computer programs, and/or related
// material (collectively the "Data") in these files contain unpublished
// information proprietary to Autodesk, Inc. ("Autodesk") and/or its licensors,
// which is protected by U.S. and Canadian federal copyright law and by
// international treaties.
//
// The Data is provided for use exclusively by You. You have the right to use,
// modify, and incorporate this Data into other products for purposes authorized 
// by the Autodesk software license agreement, without fee.
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND. AUTODESK
// DOES NOT MAKE AND HEREBY DISCLAIMS ANY EXPRESS OR IMPLIED WARRANTIES
// INCLUDING, BUT NOT LIMITED TO, THE WARRANTIES OF NON-INFRINGEMENT,
// MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE, OR ARISING FROM A COURSE 
// OF DEALING, USAGE, OR TRADE PRACTICE. IN NO EVENT WILL AUTODESK AND/OR ITS
// LICENSORS BE LIABLE FOR ANY LOST REVENUES, DATA, OR PROFITS, OR SPECIAL,
// DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES, EVEN IF AUTODESK AND/OR ITS
// LICENSORS HAS BEEN ADVISED OF THE POSSIBILITY OR PROBABILITY OF SUCH DAMAGES.

//
//	Procedure Name:
//	AEglobalStitchTemplate
//
//	Description Name;
//	Creates the attribute editor controls for the globalStitch node
//
//	Input Value:
//	nodeName
//
//	Output Value:
//	None
//

global proc AEglobalStitchTemplate( string $nodeName )
{
	string $inputSurface = (uiRes("m_AEglobalStitchTemplate.kInputSurface"));
	editorTemplate -beginScrollLayout;

		editorTemplate -beginLayout (uiRes("m_AEglobalStitchTemplate.kGlobalStitchHistory")) -collapse false;
			editorTemplate -callCustom ("AEmultiInputNew \""+$inputSurface+"\"")
						("AEmultiInputReplace \""+$inputSurface+"\"")
						"inputSurface";
			editorTemplate -beginNoOptimize;
			editorTemplate -addControl "stitchCorners";
			editorTemplate -addControl "stitchEdges";
			editorTemplate -endNoOptimize;
			editorTemplate -addControl "stitchSmoothness";
			editorTemplate -addControl "stitchPartialEdges";
			editorTemplate -addControl "maxSeparation";
			editorTemplate -label (uiRes("m_AEglobalStitchTemplate.kResistance"))
				-addControl "modificationResistance";
			editorTemplate -addControl "sampling";
			
			editorTemplate -beginLayout (uiRes("m_AEglobalStitchTemplate.kLockSurfaces")) -collapse true;
			editorTemplate -callCustom 
				"AEglobalStitchLockSurfaceNew"
				"AEglobalStitchLockSurfaceReplace"
				"inputSurface"
				"lockSurface";
			editorTemplate -endLayout;

		editorTemplate -endLayout;

		// include/call base class/node attributes
		AEabstractBaseCreateTemplate $nodeName;

		editorTemplate -addExtraControls;

	editorTemplate -endScrollLayout;

	editorTemplate -suppress "topology";
	editorTemplate -suppress "updateSampling";

}

global proc AEglobalStitchLockSurfaceNew ( string $inputSrfs, 
										   string $inputLock )
{
	setUITemplate -pst attributeEditorTemplate;

	string $buffer[];
	tokenize($inputSrfs, ".", $buffer);
	string $nodeName = $buffer[0];
	string $attInputSurface = $buffer[1];
	tokenize($inputLock, ".", $buffer);
	string $attLock = $buffer[1];

	string $attUIName = `attributeName -nice ($nodeName + ".lockSurface")`;

	string $connections[] = `listConnections -d false -sh true $inputSrfs`;
	int $numInputs = size( $connections );
	int $i, $j;
	string $textName1, $textName2;
	int $index, $boxIndex;
	int $lockValue;
	string $lockString1, $lockString2;

	columnLayout ($attInputSurface + "Column");

	for ( $i = 0, $boxIndex = 0; $i < $numInputs; $i+=2, $boxIndex++ )
	{
		$index = $i + 1; 
		$textName1 = $attUIName + " " + $index;
		$lockString1 = $inputLock + "[" + $i +"]";
		if ( $i+2 > $numInputs )
		{
			checkBoxGrp -label "" -ncb 1
				-label1 $textName1
				($attLock+$boxIndex);
				
			connectControl -index 2 ($attLock+$boxIndex) $lockString1;			
		}
		else
		{
			$index++;
			$textName2 = $attUIName + " " + $index;
			$j = $i + 1;
			$lockString2 = $inputLock + "[" + $j +"]";
			checkBoxGrp -label "" -ncb 2
				-label1 $textName1
				-label2 $textName2
				($attLock+$boxIndex);
				
			connectControl -index 2 ($attLock+$boxIndex) $lockString1;			
			connectControl -index 3 ($attLock+$boxIndex) $lockString2;			
		}
	}

	setParent ..;

	setUITemplate -ppt;
}


global proc AEglobalStitchLockSurfaceReplace ( string $inputSrfs, 
											   string $inputLock )
{
	setUITemplate -pst attributeEditorTemplate;

	string $connections[] = `listConnections -d false -sh true $inputSrfs`;
	int $numInputs = size( $connections );
	int $i, $j;
	string $textName;
	int $index, $boxIndex;

	string $buffer[];
	tokenize($inputSrfs, ".", $buffer);
	string $nodeName = $buffer[0];
	string $attInputSurface = $buffer[1];
	tokenize($inputLock, ".", $buffer);
	string $attLock = $buffer[1];

	string $attUIName = `attributeName -nice ($nodeName + ".lockSurface")`;

	setParent ($attInputSurface + "Column");

	// delete any old layouts
	for ( $i = 0; ; $i++ )
	{
		if ( `checkBoxGrp -ex ($attLock+$i)` )
		{
			deleteUI ($attLock+$i);
		}
		else
		{
			// exit the loop once no more checkboxes exist
			break;
		}
	}

	int $lockValue;
	string $lockString;
	for ( $i = 0, $boxIndex = 0; $i < $numInputs; $i+=2, $boxIndex++ )
	{
		$index = $i + 1; 
		$textName1 = $attUIName + " " + $index;
		$lockString1 = $inputLock + "[" + $i +"]";
		if ( $i+2 > $numInputs )
		{
			checkBoxGrp -label "" -ncb 1
				-label1 $textName1
				($attLock+$boxIndex);

			connectControl -index 2 ($attLock+$boxIndex) $lockString1;			
		}
		else
		{
			$index++;
			$textName2 = $attUIName + " " + $index;
			$j = $i + 1;
			$lockString2 = $inputLock + "[" + $j +"]";
			checkBoxGrp -label "" -ncb 2
				-label1 $textName1
				-label2 $textName2
				($attLock+$boxIndex);

			connectControl -index 2 ($attLock+$boxIndex) $lockString1;			
			connectControl -index 3 ($attLock+$boxIndex) $lockString2;			
		}
	}

	setParent ..;
	setUITemplate -ppt;

}
