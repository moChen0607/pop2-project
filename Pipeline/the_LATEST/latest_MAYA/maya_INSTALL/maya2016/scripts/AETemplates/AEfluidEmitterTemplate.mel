// Copyright (C) 1997-2014 Autodesk, Inc., and/or its licensors.
// All rights reserved.
//
// The coded instructions, statements, computer programs, and/or related
// material (collectively the "Data") in these files contain unpublished
// information proprietary to Autodesk, Inc. ("Autodesk") and/or its licensors,
// which is protected by U.S. and Canadian federal copyright law and by
// international treaties.
//
// The Data is provided for use exclusively by You. You have the right to use,
// modify, and incorporate this Data into other products for purposes authorized 
// by the Autodesk software license agreement, without fee.
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND. AUTODESK
// DOES NOT MAKE AND HEREBY DISCLAIMS ANY EXPRESS OR IMPLIED WARRANTIES
// INCLUDING, BUT NOT LIMITED TO, THE WARRANTIES OF NON-INFRINGEMENT,
// MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE, OR ARISING FROM A COURSE 
// OF DEALING, USAGE, OR TRADE PRACTICE. IN NO EVENT WILL AUTODESK AND/OR ITS
// LICENSORS BE LIABLE FOR ANY LOST REVENUES, DATA, OR PROFITS, OR SPECIAL,
// DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES, EVEN IF AUTODESK AND/OR ITS
// LICENSORS HAS BEEN ADVISED OF THE POSSIBILITY OR PROBABILITY OF SUCH DAMAGES.

//
//  Procedure Name:
//	AEfluidEmitterTemplate
//
//  Description Name;
//	Creates the attribute editor controls for the fluidEmitter Node
//
//  Input Value:
//	nodeName 
//
//  Output Value:
//	None
// 

global proc flEmitDensityMapNew (string $attrName )
{
	setUITemplate -pst attributeEditorTemplate;
	attrNavigationControlGrp
			-label (uiRes("m_AEfluidEmitterTemplate.kDensityEmitMap"))
			-at $attrName
			densityEmitMapControl;
	setUITemplate -ppt;
}

global proc flEmitDensityMapReplace (string $attrName )
{
	attrNavigationControlGrp -edit
			-at $attrName
			densityEmitMapControl;
}

global proc flEmitHeatMapNew (string $attrName )
{
	setUITemplate -pst attributeEditorTemplate;
	attrNavigationControlGrp
			-label (uiRes("m_AEfluidEmitterTemplate.kHeatEmitMap"))
			-at $attrName
			heatEmitMapControl;
	setUITemplate -ppt;
}

global proc flEmitHeatMapReplace (string $attrName )
{
	attrNavigationControlGrp -edit
			-at $attrName
			heatEmitMapControl;
}

global proc flEmitFuelMapNew (string $attrName )
{
	setUITemplate -pst attributeEditorTemplate;
	attrNavigationControlGrp
			-label (uiRes("m_AEfluidEmitterTemplate.kFuelEmitMap"))
			-at $attrName
			fuelEmitMapControl;
	setUITemplate -ppt;
}

global proc flEmitFuelMapReplace (string $attrName )
{
	attrNavigationControlGrp -edit
			-at $attrName
			fuelEmitMapControl;
}



global proc flDimCycleInterval ( string $nodeName )
//
// Description:
//  Dim the cycle interval if cycleEmission is set to none, undim it otherwise.
// Emitter type doesn't matter, since cycleEmission applies to all.
{
	int $cycEmit = `getAttr( $nodeName + ".cycleEmission" )`;
	if ($cycEmit == 0)
	{
		// cycleEmission == NONE, dim cycleInterval.
		//
		editorTemplate -dimControl $nodeName "cycleInterval" true;
	}
	else
	{
		editorTemplate -dimControl $nodeName "cycleInterval" false;
	}
}

global proc flEmitFluidColorVerifyGrid( string $nodeName ) 
//
// Description:
//	When turning on color emission, color should be set to
//	Dynamic Grid on the fluid, otherwise the color won't update
//  during playback.  If it's not set to Grid, pop up a confirm box
//	offering to do it for them.
//	
{
	int $state = `getAttr( $nodeName + ".emitFluidColor" )`;

	// The docs for editorTemplate -addControl indicate that
	// the proc only gets called on attrChanged messages, but
	// that's not entirely true.  This proc is also called when
	// the AE refreshes.  The global variables are to get 
	// around popping up a confirm box just because of a selection
	// (or active AE tab) change.
	//
	global int $gAEfluidEmitterTemplate_emitFluidColorState = false;
	global string $gAEfluidEmitterTemplate_emitFluidColorNode = "";
	
	// When changing the node displayed (or just the first
	// time), set the current state so we only popup when
	// the user changes turns it on...
	//
	if( $gAEfluidEmitterTemplate_emitFluidColorNode != $nodeName ) {
		$gAEfluidEmitterTemplate_emitFluidColorNode = $nodeName;
		$gAEfluidEmitterTemplate_emitFluidColorState = $state;
		return;
	}

	// Nothing's changed since the last time.
	//
	if( $gAEfluidEmitterTemplate_emitFluidColorState == $state ) {
		return;
	}

	// This is a new state.  Remember it.
	//
	$gAEfluidEmitterTemplate_emitFluidColorState = $state;

	// Never pop up a confirm box when the state is OFF.
	//
	if( !$state ) {
		return;
	}

	// A single emitter could be connected to multiple fluids.
	//
	string $fluidConnectedAttr = ( $nodeName + ".emissionFunction" );
	string $fluids[] = `listConnections -shapes true $fluidConnectedAttr`;
	int    $askedOnce = false;

	for( $f in $fluids ) {
		string $create[];
		if( `fluidsVerifyGrid $f "color" $create` ) {
			continue;
		}
		
		string $createDynamic = $create[0];
		string $createStatic_unused = $create[1];
		string $response;
		
		// Only pop up one confirm box, in the case of multiple
		// fluids attached to the same emitter.
		//
		string $setToDynamicLabel = (uiRes("m_AEfluidEmitterTemplate.kSetToDynamic"));
		string $cancelLabel = (uiRes("m_AEfluidEmitterTemplate.kCancel"));
		if( !$askedOnce ) {
			string $gridTypes;
			string $buttons;
			
			$buttons = ( "-button \"" + $setToDynamicLabel + "\" " +
						 "-button \"" + $cancelLabel + "\" " +
						 "-cancelButton \"" + $cancelLabel + "\" " +
						 "-defaultButton \"" + $setToDynamicLabel+ "\" " +
						 "-dismissString \"" + $cancelLabel + "\" " );
		
			$response = eval( "confirmDialog " + "-message \"" + (uiRes("m_AEfluidEmitterTemplate.kSetColorMethodToDynamic")) + "\" " +
							  $buttons );

			$askedOnce = true;
		}
		
		if( $response == $setToDynamicLabel ) {
			evalEcho( $createDynamic );
		}
	}
}

proc flDimTextureInheritanceAttributes( string $nodeName, int $val )
{
	// Do NOT ever dim particle color of texture rate.
	// If we do that, the "map" button does not function thereafter (bug 125465).
	// It suffices to dim/undim the boolean "inherit" and "enable" buttons.
	// js 1-5-2000.

	//editorTemplate -dimControl $nodeName "particleColor" $val;
	editorTemplate -dimControl $nodeName "inheritColor" $val;
	editorTemplate -dimControl $nodeName "inheritOpacity" $val;
	editorTemplate -dimControl $nodeName "useLuminance" $val;
	editorTemplate -dimControl $nodeName "invertOpacity" $val;
	//editorTemplate -dimControl $nodeName "textureRate" $val;
	editorTemplate -dimControl $nodeName "enableTextureRate" $val;
	editorTemplate -dimControl $nodeName "emitFromDark" $val;
}


global proc flDimVolumeAttributesByShape ( string $nodeName )
//
// Description:
//  If current emitter type is volume, set volume emitter attribute
//  dimming according to volume shape.  If current emitter type is
//  different from volume, do nothing. This routine handles only attributes
//  which are dimmed for some volumes but not for others.  Attributes
//  which are the same for all are handled by dimVolumeAttributes.
{
	int $currEmitType = `getAttr( $nodeName + ".emitterType" )`;
	// if not a volume emitter, do nothing
	if ( $currEmitType != 4 ) return;

	int $currEmitter = `getAttr ( $nodeName + ".volumeShape" )`;

	// Set up the defaults
	//
	editorTemplate -dimControl $nodeName "sectionRadius" true;
	editorTemplate -dimControl $nodeName "awayFromCenter" true;
	editorTemplate -dimControl $nodeName "awayFromAxis"   false;
	editorTemplate -dimControl $nodeName "volumeSweep"   false;

	// Each shape type changes the settings as needed.
	//
	switch ( $currEmitter ){

		case 0: // Cube
			editorTemplate -dimControl $nodeName "volumeSweep"   true;
			//
			// NOTE: no "break;" -- this is intended.
			//
		case 1: // Sphere
			editorTemplate -dimControl $nodeName "awayFromCenter" false;
			editorTemplate -dimControl $nodeName "awayFromAxis"   true;
			break;

		case 2: // Cylinder
			break;

		case 3: // Cone
			break;

		case 4: // Torus
			editorTemplate -dimControl $nodeName "sectionRadius" false;
			break;
		}
}

proc flDimVolumeAttributes( string $nodeName, int $val )
//
// Description:
//   if $val is true, disable all volume attributes.
// If false, enable all those which apply to current volume shape.
{
	editorTemplate -dimControl $nodeName "volumeShape" $val;
	editorTemplate -dimControl $nodeName "volumeOffset" $val;
	editorTemplate -dimControl $nodeName "volumeSweep" $val;
	editorTemplate -dimControl $nodeName "volumeSectionRadius" $val;
	editorTemplate -dimControl $nodeName "awayFromCenter" $val;
	editorTemplate -dimControl $nodeName "awayFromAxis" $val;
	editorTemplate -dimControl $nodeName "aroundAxis" $val;
	editorTemplate -dimControl $nodeName "alongAxis" $val;
	editorTemplate -dimControl $nodeName "randomDirection" $val;
//	editorTemplate -dimControl $nodeName "directionalSpeed" $val;
	editorTemplate -dimControl $nodeName "scaleSpeedBySize" $val;
	editorTemplate -dimControl $nodeName "sectionRadius" $val;
	editorTemplate -dimControl $nodeName "displaySpeed" $val;
	// editorTemplate -dimControl $nodeName "volumeEfficiency" $val;

	// if $val is true, we have now turned everything off, which
	// is correct.  If $val is false, we have turned everything on,
	// which is not quite correct.  Call special routine to handle
	// specific attributes according to shape type.
	//
	if (!$val)
	{
		flDimVolumeAttributesByShape( $nodeName );
	}	
}

global proc AEfluidEmitterTypeNew( string $attrName )
{
	setUITemplate -pst attributeEditorTemplate;	
 	attrEnumOptionMenuGrp -attribute $attrName 
		-enumeratedItem 1 (uiRes("m_AEfluidEmitterTemplate.kOmni"))
		-enumeratedItem 2 (uiRes("m_AEfluidEmitterTemplate.kSurface"))
		-enumeratedItem 3 (uiRes("m_AEfluidEmitterTemplate.kCurve"))
		-enumeratedItem 4 (uiRes("m_AEfluidEmitterTemplate.kVolume"))
		-label (uiRes("m_AEfluidEmitterTemplate.kEmitterType"))  AEfluidEmitterTypeEnum;
    setUITemplate -ppt;

	AEfluidEmitterTypeReplace $attrName;
}

global proc AEfluidEmitterTypeReplace( string $attrName )
{
 	attrEnumOptionMenuGrp -e -attribute $attrName AEfluidEmitterTypeEnum;

	scriptJob -p AEfluidEmitterTypeEnum -rp
		-ac $attrName ("flSetAttributeDimming " + $attrName );

	evalDeferred ("flSetAttributeDimming " + $attrName);
}

global proc flSetAttributeDimming ( string $attrName )
//
// Description:
//  Dim attributes in the attribute editor according to the type of emitter.
// Does not handle the dimming of attributes for a specific volume shape.
{
	string $tmp[];
	tokenize($attrName, ".", $tmp);
	string $nodeName = $tmp[0];

	int $currEmitter = `getAttr ( $nodeName + ".emitterType" )`;
	int		$noSpeed = !getAttr($nodeName + ".speedMethod");
	int		$motionStreak = getAttr( $nodeName + ".motionStreak");
	// Set default settings for all attributes.  Then each emitter 
	// must set only those which vary from the defaults.
	// We do not include un-dimming calls for parameters (eg rate)
	// which apply to every emitter, since nobody ever dims them.
	//

	editorTemplate -dimControl $nodeName "useRatePP" false;

//	editorTemplate -dimControl $nodeName "spread" false;

//	editorTemplate -dimControl $nodeName "directionX" $noSpeed;
//	editorTemplate -dimControl $nodeName "directionY" $noSpeed;
//	editorTemplate -dimControl $nodeName "directionZ" $noSpeed;

//	editorTemplate -dimControl $nodeName "speed" false;
	editorTemplate -dimControl $nodeName "tangentSpeed" $noSpeed;
	editorTemplate -dimControl $nodeName "normalSpeed" $noSpeed;
	editorTemplate -dimControl $nodeName "useDistance" $motionStreak;
	editorTemplate -dimControl $nodeName "minDistance" $motionStreak;
	flDimTextureInheritanceAttributes( $nodeName, true );
	flDimVolumeAttributes( $nodeName, true );
	editorTemplate -dimControl $nodeName "fillObject" ($currEmitter != 2);

	switch ( $currEmitter ){

		case 0: // Direction
			editorTemplate -dimControl $nodeName "tangentSpeed" $noSpeed;
			editorTemplate -dimControl $nodeName "normalSpeed" $noSpeed;
			break;

		case 1: // Omni
			editorTemplate -dimControl $nodeName "useDistance" true;
//			editorTemplate -dimControl $nodeName "spread" true;
//			editorTemplate -dimControl $nodeName "directionX" true;
//			editorTemplate -dimControl $nodeName "directionY" true;
//			editorTemplate -dimControl $nodeName "directionZ" true;
			editorTemplate -dimControl $nodeName "tangentSpeed" true;
			editorTemplate -dimControl $nodeName "normalSpeed" true;
			break;

		case 2: // Surface 
			editorTemplate -dimControl $nodeName "useRatePP"  true;
//			editorTemplate -dimControl $nodeName "directionX" true;
//			editorTemplate -dimControl $nodeName "directionY" true;
//			editorTemplate -dimControl $nodeName "directionZ" true;
//			editorTemplate -dimControl $nodeName "spread" true;
			editorTemplate -dimControl $nodeName "tangentSpeed" true;
			flDimTextureInheritanceAttributes( $nodeName, false );
			break;

		case 3: // Curve 
			editorTemplate -dimControl $nodeName "useRatePP"  true;
//			editorTemplate -dimControl $nodeName "normalSpeed" true;
			break;

		case 4: // Volume
			editorTemplate -dimControl $nodeName "useDistance" true;
			editorTemplate -dimControl $nodeName "useRatePP"  true;
//			editorTemplate -dimControl $nodeName "spread"     true;
			editorTemplate -dimControl $nodeName "tangentSpeed" true;
			editorTemplate -dimControl $nodeName "normalSpeed"  true;
//			editorTemplate -dimControl $nodeName "speed"  true;
			flDimVolumeAttributes( $nodeName, false );

			break;
	}
	AEfluidEmitterUseDistance( $nodeName );
}

global proc AEfluidEmitterUseDistance( string $nodeName ) 
{
		int		$ud = getAttr($nodeName + ".useDistance");
		int		$et = getAttr($nodeName + ".emitterType");
		int		$sm = getAttr( $nodeName + ".motionStreak");
		int $dim = ($et != 1) && ($et == 4 || ($ud == false && $sm == false)  );
		editorTemplate -dimControl $nodeName "minDistance" ($dim || $sm);
		editorTemplate -dimControl $nodeName "maxDistance" $dim;
}
global proc AEfluidEmitterMotionStreak( string $nodeName ) 
{
	int		$sm = getAttr( $nodeName + ".motionStreak");
	int		$et = getAttr($nodeName + ".emitterType");
	AEfluidEmitterUseDistance($nodeName);
	editorTemplate -dimControl $nodeName "useDistance" ($sm || $et == 4 || $et == 1);
}

global proc flDensityMethod( string $nodeName ) 
{
		int		$m = getAttr($nodeName + ".densityMethod");

		editorTemplate -dimControl $nodeName "fluidDensityEmission" (!$m);
		editorTemplate -dimControl $nodeName "densityEmissionMap" (!$m);
}

global proc flHeatMethod( string $nodeName ) 
{
		int		$m = getAttr($nodeName + ".heatMethod");

		editorTemplate -dimControl $nodeName "fluidHeatEmission" (!$m);
		editorTemplate -dimControl $nodeName "heatEmissionMap" (!$m);
}

global proc flFuelMethod( string $nodeName ) 
{
		int		$m = getAttr($nodeName + ".fuelMethod");

		editorTemplate -dimControl $nodeName "fluidFuelEmission" (!$m);
		editorTemplate -dimControl $nodeName "fuelEmissionMap" (!$m);
}

global proc flSpeedMethod( string $nodeName ) 
{
		int		$m = getAttr($nodeName + ".speedMethod");
		int		$et = getAttr($nodeName + ".emitterType");
		editorTemplate -dimControl $nodeName "inheritVelocity" (!$m);
		editorTemplate -dimControl $nodeName "directionalSpeed" (!$m);
		editorTemplate -dimControl $nodeName "directionX" (!$m);
		editorTemplate -dimControl $nodeName "directionY" (!$m);
		editorTemplate -dimControl $nodeName "directionZ" (!$m);
		editorTemplate -dimControl $nodeName "normalSpeed" (!$m || (($et != 2) && ($et != 3)));
		editorTemplate -dimControl $nodeName "alongAxis" (!$m || ($et != 4));
		editorTemplate -dimControl $nodeName "aroundAxis" (!$m || ($et != 4));	
}

global proc AEfluidEmitterRadiusPP( string $nodeName )
{
	if( !getAttr($nodeName + ".useParticleRadius") ){
		return;
	}
	string $con[] = `listConnections -sh 1 ($nodeName +".radiusPP")`;
	if( size( $con ) > 0 ){
		return; // already connected
	}
	$con = `listConnections -sh 1 ($nodeName +".ownerPosData")`;
	if( size($con) > 0 ){
		string $radPP = ($con[0] + ".radiusPP");
		if( objExists( $radPP ) ){
			connectAttr -f $radPP ($nodeName + ".radiusPP" );
		} else {
			setAttr ($nodeName + ".useParticleRadius") false;
			string $warn = (uiRes("m_AEfluidEmitterTemplate.kNoRadiusPP"));
			warning( $con[0] + $warn );
			
		}
	} else {
		setAttr ($nodeName + ".useParticleRadius") false;
		string $warn = (uiRes("m_AEfluidEmitterTemplate.kCantUseRadiusPP"));
		warning( $nodeName + $warn );	
	}
}

global proc AEfluidEmitterTemplate ( string $nodeName )
{
	editorTemplate -beginScrollLayout;
		AEtransformMain $nodeName;

		editorTemplate -beginLayout (uiRes("m_AEfluidEmitterTemplate.kBasicEmitterAttributes"))  -collapse 1;
			editorTemplate -callCustom
				"AEfluidEmitterTypeNew"
				AEfluidEmitterTypeReplace
				emitterType;
			editorTemplate -addControl "startFrameEmission";
			editorTemplate -addControl -label (uiRes("m_AEfluidEmitterTemplate.kRatePercent"))  "rate";
			editorTemplate -addControl -label (uiRes("m_AEfluidEmitterTemplate.kUseRatePP"))  "useRatePP";
			editorTemplate -interruptOptimize;
			editorTemplate -addControl -label (uiRes("m_AEfluidEmitterTemplate.kUseRadiusPP"))  "useParticleRadius" "AEfluidEmitterRadiusPP";
			editorTemplate -addControl "cycleEmission" "flDimCycleInterval";
			editorTemplate -addControl "cycleInterval";
			editorTemplate -addControl "useDistance" "AEfluidEmitterUseDistance";
			editorTemplate -addControl "minDistance";
			editorTemplate -addControl "maxDistance";
			editorTemplate -addControl "fillObject";
		editorTemplate -endLayout;

		editorTemplate -beginLayout (uiRes("m_AEfluidEmitterTemplate.kFluidAttributes"))  -collapse 0;
		    editorTemplate -addControl "densityMethod" "flDensityMethod";
			editorTemplate -addControl -label (uiRes("m_AEfluidEmitterTemplate.kDensityVoxelSec"))  "fluidDensityEmission";
			editorTemplate -callCustom "flEmitDensityMapNew" "flEmitDensityMapReplace" "densityEmissionMap";
			editorTemplate -addControl "heatMethod" "flHeatMethod";
			editorTemplate -addControl -label (uiRes("m_AEfluidEmitterTemplate.kHeatVoxelSec"))  "fluidHeatEmission";
			editorTemplate -callCustom "flEmitHeatMapNew" "flEmitHeatMapReplace" "heatEmissionMap";
			editorTemplate -addControl "fuelMethod" "flFuelMethod";
			editorTemplate -addControl -label (uiRes("m_AEfluidEmitterTemplate.kFuelVoxelSec"))  "fluidFuelEmission";
			editorTemplate -callCustom "flEmitFuelMapNew" "flEmitFuelMapReplace" "fuelEmissionMap";
			editorTemplate -addControl "fluidDropoff";	
			editorTemplate -addControl "emitFluidColor" flEmitFluidColorVerifyGrid;
			editorTemplate -label (uiRes("m_AEfluidEmitterTemplate.kFluidColor"))  -addControl "particleColor";	
			editorTemplate -addControl -label (uiRes("m_AEfluidEmitterTemplate.kMotionStreak"))  "motionStreak" "AEfluidEmitterMotionStreak";
			editorTemplate -addControl -label (uiRes("m_AEfluidEmitterTemplate.kJitter"))  "fluidJitter";
			editorTemplate -beginLayout (uiRes("m_AEfluidEmitterTemplate.kFluidEmissionTurbulence"))  -collapse 1;
				editorTemplate -addControl "turbulenceType";
				editorTemplate -addControl "turbulence";
				editorTemplate -addControl "turbulenceSpeed";
				editorTemplate -addControl -label (uiRes("m_AEfluidEmitterTemplate.kTurbulenceFreq"))  "turbulenceFrequency";
				editorTemplate -addControl "turbulenceOffset";
				editorTemplate -addControl "detailTurbulence";			
			editorTemplate -endLayout;
		editorTemplate -endLayout;
		editorTemplate -beginLayout (uiRes("m_AEfluidEmitterTemplate.kEmissionSpeedAttributes"))  -collapse 0;		
			editorTemplate -addControl "speedMethod" "flSpeedMethod";
			editorTemplate -addControl "inheritVelocity";
			editorTemplate -addControl "normalSpeed";
			editorTemplate -addControl "tangentSpeed";
			editorTemplate -addControl "alongAxis";	
			editorTemplate -addControl "aroundAxis";		
			editorTemplate -addControl "directionalSpeed";
			editorTemplate -addControl "directionX";
			editorTemplate -addControl "directionY";
			editorTemplate -addControl "directionZ";


		editorTemplate -endLayout;
		editorTemplate -beginLayout (uiRes("m_AEfluidEmitterTemplate.kVolumeEmitterAttributes"))  -collapse 1;
			editorTemplate -addControl "volumeShape" "flDimVolumeAttributesByShape";
			editorTemplate -addControl "volumeOffset";
			editorTemplate -addControl "volumeSweep" ;
			editorTemplate -addControl "sectionRadius" ;
			editorTemplate -addControl "normalizedDropoff" ;

			// This is so the dimming on these controls will
			// happen correctly the first time the collapsed
			// layout is opened.  (The dimming proc is attached
			// to the emitter type, but it's possible to open
			// this layout *before* the emitter type widget gets
			// created, so we need to call dimming here as well.
			//
			// (It doesn't matter what attribute we pass in to
			// the flSetAttributeDimming proc, since the proc
			// really just needs the node name.)
			//
			editorTemplate -callCustom 
				flSetAttributeDimming
				flSetAttributeDimming
				volumeShape;

		editorTemplate -endLayout;

		// Suppress attributes we don't want in the editor.
		// 
		editorTemplate -suppress useSceneTime;
		editorTemplate -suppress randState;
		editorTemplate -suppress currentTime;
		editorTemplate -suppress isFull;
		editorTemplate -suppress output;
		editorTemplate -suppress direction;
		editorTemplate -suppress ratePP;
		editorTemplate -suppress inheritFactor;
		editorTemplate -suppress outPositions;
		editorTemplate -suppress outVelocities;
		editorTemplate -suppress parentId;
		editorTemplate -suppress deltaTimeCycle;

		// suppress attrs we don't use for fluids at this time
	//	editorTemplate -suppress "rate";
	//	editorTemplate -suppress "useRatePP";
		editorTemplate -suppress "needParentUV";
		editorTemplate -suppress "scaleRateByObjectSize";
		editorTemplate -suppress "scaleRateBySpeed";
		editorTemplate -suppress "radiusPP";


		editorTemplate -suppress "speed";
		editorTemplate -suppress "speedRandom";
		//editorTemplate -suppress "tangentSpeed";
		//editorTemplate -suppress "normalSpeed";

		editorTemplate -suppress "awayFromCenter";
		editorTemplate -suppress "awayFromAxis";
//		editorTemplate -suppress "alongAxis";
//		editorTemplate -suppress "aroundAxis";
		editorTemplate -suppress "randomDirection";
		//editorTemplate -suppress "directionalSpeed";
		editorTemplate -suppress "scaleSpeedBySize";
		editorTemplate -suppress "displaySpeed";

		//editorTemplate -suppress "directionX";
		//editorTemplate -suppress "directionY";
		//editorTemplate -suppress "directionZ";
		editorTemplate -suppress "spread";

		editorTemplate -suppress "inheritColor";
		editorTemplate -suppress "inheritOpacity";
		editorTemplate -suppress "useLuminance";
		editorTemplate -suppress "invertOpacity";
		editorTemplate -suppress "textureRate";
		editorTemplate -suppress "enableTextureRate";
		editorTemplate -suppress "emitFromDark";
		editorTemplate -suppress "renderLayerInfo";

		// include/call base class/node attributes
		AEdynBaseTemplate $nodeName;

		editorTemplate -beginLayout (uiRes("m_AEfluidEmitterTemplate.kObjectDisplay")) ;
			editorTemplate -label (uiRes("m_AEfluidEmitterTemplate.kLODVisibility"))  -addControl "lodVisibility";
			editorTemplate -addControl "ghosting";
		editorTemplate -endLayout;

	editorTemplate -addExtraControls;
	editorTemplate -endScrollLayout;
}
