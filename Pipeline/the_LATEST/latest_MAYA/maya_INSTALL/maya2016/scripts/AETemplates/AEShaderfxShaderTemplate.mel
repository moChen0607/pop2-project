// Copyright (C) 1997-2014 Autodesk, Inc., and/or its licensors.
// All rights reserved.
//
// The coded instructions, statements, computer programs, and/or related
// material (collectively the "Data") in these files contain unpublished
// information proprietary to Autodesk, Inc. ("Autodesk") and/or its licensors,
// which is protected by U.S. and Canadian federal copyright law and by
// international treaties.
//
// The Data is provided for use exclusively by You. You have the right to use,
// modify, and incorporate this Data into other products for purposes authorized 
// by the Autodesk software license agreement, without fee.
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND. AUTODESK
// DOES NOT MAKE AND HEREBY DISCLAIMS ANY EXPRESS OR IMPLIED WARRANTIES
// INCLUDING, BUT NOT LIMITED TO, THE WARRANTIES OF NON-INFRINGEMENT,
// MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE, OR ARISING FROM A COURSE 
// OF DEALING, USAGE, OR TRADE PRACTICE. IN NO EVENT WILL AUTODESK AND/OR ITS
// LICENSORS BE LIABLE FOR ANY LOST REVENUES, DATA, OR PROFITS, OR SPECIAL,
// DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES, EVEN IF AUTODESK AND/OR ITS
// LICENSORS HAS BEEN ADVISED OF THE POSSIBILITY OR PROBABILITY OF SUCH DAMAGES.

global proc AEShaderFXOpen()
{
	eval("shaderfx -start -sfxnode $ShaderFXActiveShaderName[0]");
}

global proc AEShaderFXReplaceUI()
{
	eval("shaderfx -replaceUI -sfxnode $ShaderFXActiveShaderName[0]");
}

global proc AEShaderFXPropUI()
{
	eval("shaderfx -nodeUI -sfxnode $ShaderFXActiveShaderName[0]");
}

///	\brief	This file defines the attribute editor for our Shaderfx Shader.
///	\param	$nodeName	-	the name of the node instance to display.
/// 
global proc AEShaderfxShaderTemplate( string $nodeName )
{
	// the following controls will be in a scrollable layout
	editorTemplate -beginScrollLayout;

		// add shaderfx selected node properties and shader attributes layout:
		editorTemplate -beginLayout "ShaderFX" -collapse 0;
			editorTemplate -callCustom "ShaderFXOpenNew" "ShaderFXOpenReplace" "";
		editorTemplate -endLayout;

		// include/call base class/node attributes
		AEdependNodeTemplate $nodeName;

		// add any extra attributes that have been added
		editorTemplate -addExtraControls;

		// Find the "Extra Attributes" frameLayout and hide it.
		editorTemplate -callCustom AEShaderFX_suppressExtraNew AEShaderFX_suppressExtraReplace;

	editorTemplate -endScrollLayout;
}

global proc ShaderFXOpenNew( string $attrName )
{
	// register global for active node name.
	// we need this because Maya only creates the template ones and does not run
	// this function again for other shaderfx nodes created.
	// during ShaderFXOpenReplace we get the opportunity to update what is the active (selected) shaderfx node
	global string $ShaderFXActiveShaderName[];

	// Since maya passes us an attribute ( nodename.attributeName) we strip the attributes since we only want the node name
	tokenize($attrName, ".", $ShaderFXActiveShaderName);

	// Normally here we would create a UI control and connect to an attribute
	// But all we need is a button to launch shaderfx
	button -label "Open ShaderFX" -width 100 -command ("AEShaderFXOpen()");

	frameLayout -label "Settings" -collapse 1 ShaderFXSettings;
	setParent ..;

	frameLayout -label "Attributes" -collapse 0 ShaderFXProperties;
	setParent ..;

	// update node property UI or attribute UI:
	AEShaderFXPropUI();
}

global proc ShaderFXOpenReplace( string $attrName )
{
	// normally here we would make a connection between the new attribute and UI control
	// But for us, we only have a button the user needs to press to open ShaderFX
	// So we just store the new object

	// see ShaderFXOpenNew() for details on below:
	global string $ShaderFXActiveShaderName[];
	tokenize($attrName, ".", $ShaderFXActiveShaderName);

	// open the node UI if one is already open for this new node, 
	// otherwise it gets confusing who we are editing:
	AEShaderFXReplaceUI();

	// update node property UI or attribute UI:
	AEShaderFXPropUI();
}

global proc AEShaderFX_suppressExtraNew()
{
    string $sExtraParent = `setParent ..`;
    string $sa[] = `layout -q -ca $sExtraParent`;
    string $sExtra;
    // label string may be localized, look up the localized value 
    // Beware, the resource format or id could change some day. 
    string $extraLabel = `uiRes("s_TPStemplateStrings.rExtraAttributes")`;

    for ( $sExtra in $sa )
    {
        if ( `objectTypeUI -isType frameLayout $sExtra` &&
             `frameLayout -q -l $sExtra` == $extraLabel )
        {
            frameLayout -e -manage 0 -visible 0 $sExtra;
            break;
        }
    }
} 

global proc AEShaderFX_suppressExtraReplace() {}


