// Copyright (C) 1997-2014 Autodesk, Inc., and/or its licensors.
// All rights reserved.
//
// The coded instructions, statements, computer programs, and/or related
// material (collectively the "Data") in these files contain unpublished
// information proprietary to Autodesk, Inc. ("Autodesk") and/or its licensors,
// which is protected by U.S. and Canadian federal copyright law and by
// international treaties.
//
// The Data is provided for use exclusively by You. You have the right to use,
// modify, and incorporate this Data into other products for purposes authorized 
// by the Autodesk software license agreement, without fee.
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND. AUTODESK
// DOES NOT MAKE AND HEREBY DISCLAIMS ANY EXPRESS OR IMPLIED WARRANTIES
// INCLUDING, BUT NOT LIMITED TO, THE WARRANTIES OF NON-INFRINGEMENT,
// MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE, OR ARISING FROM A COURSE 
// OF DEALING, USAGE, OR TRADE PRACTICE. IN NO EVENT WILL AUTODESK AND/OR ITS
// LICENSORS BE LIABLE FOR ANY LOST REVENUES, DATA, OR PROFITS, OR SPECIAL,
// DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES, EVEN IF AUTODESK AND/OR ITS
// LICENSORS HAS BEEN ADVISED OF THE POSSIBILITY OR PROBABILITY OF SUCH DAMAGES.

//
//
//  Creation Date:  17 April 2007
//
//  Description:
//      This procedure adds property sheet controls for
//		a new (multi) compound attribute.  This is for internal
//		use only.  
//
//  Input Arguments:
//		The name of the plug for the attribute
//		The name of the attribute
//		
//  Return Value:
//      The name of the newly-created control.
//
 
//	This procedure returns item list of enum attr node.enumAttr
//	The returned list contais integer value and string value of each enum item.
//	For ex, {0, None, 1, Linear, 5, Smooth, ...}
proc string[] getEnumItems(string $node, string $enumAttr)
{
	string $result[], $item[], $buffer[];
	int $enumValue = 0, $i;

	//	Get raw item list.
	//	$enum will look like: {string=value:string=value:...}
	// If the enum item uses default value, "=value" is omitted.
	string $enum[] = `attributeQuery -node $node -listEnum $enumAttr`;

	//	Tokenize by ":" to separate each item
	tokenize($enum[0], ":", $buffer);
	for($i = 0 ; $i < size($buffer); $i++)
	{
		//	Tokenize by "=" to separate integer value from string value
		clear($item);
		tokenize($buffer[$i], "=", $item);

		//	If an integer value is specified:
		if( size($item) > 1 )
		{
			$enumValue = $item[1];
		}

		//	Store to result
		$result[$i*2] = $enumValue;
		$result[$i*2+1] = $item[0];

		//	Advance $enumValue
		$enumValue ++;
	}
	return $result;
}

global proc string AEnewCompound ( string $plugName, string $attrName, string $changedCommand )
{
	string $createdControl = "";
	
	//	Get node name and attr name
	string $buffer[];
	tokenize($plugName, ".", $buffer);
	string $node = $buffer[0];
	string $compoundParent = $buffer[1];

	//	$compoundMultiParent is compound parent attr with [ ] (in case multi) or without [ ] (if not multi)
	//	$compoundParent is compound parent attr ALWAYS WITHOUT [ ]
	$compoundMultiParent = $compoundParent;

	string $compoundMultiParentNice = `attributeName -nice $plugName`;

	int $isMulti = 0;

	//	Is this multi compound?
	//	if so, $plugname looks like this: attrname[n]
	clear($buffer);
	tokenize($compoundParent, "[",$buffer);
	//	Yes. multi compound
	if( size($buffer) >1 )
	{
		$compoundParent = $buffer[0];
		$isMulti = 1;
	}

	//	attributeQuery does NOT take multi attr.
	//	For ex, `attributeQuery -node "myNode" -listChildren "colors[0]"` is error
	//	Instead, use `attributeQuery -node "myNode" -listChildren "colors"
	//	So, we have to use $compoundParent
	string $childAttrs[] = `attributeQuery -node $node  -listChildren $compoundParent`;

	//	No child!
	//	This attr is not compound. 
	//	Return.
	int $numChildren = size($childAttrs);
	if( $numChildren == 0 )
		return AEnewOther($plugName, $attrName, $changedCommand);

	string $childType, $childPlug, $childAttrName;
	//	Build UI
	setUITemplate -pst attributeEditorTemplate;
		$createdControl = `frameLayout -collapsable true -label $compoundMultiParentNice -borderVisible true -collapse false`;
		columnLayout -adjustableColumn true;

			for($i=0; $i<$numChildren; $i++)
			{
				$childAttrName = $childAttrs[$i];
				$childPlug = ($node + "." + $compoundMultiParent + "." + $childAttrName);
				$childAttrNice = `attributeName -nice $childPlug`;
				$childType = `getAttr -type $childPlug`;
				if( $childType == "bool" )
				{
					// Note: Do not use AEnewBooleanGroup
					// because AEnewBooleanGroup creates a form layout
					string $childCtrl = `checkBoxGrp -ncb 1 -l1 $childAttrNice`;
					connectControl -in 2 $childCtrl $childPlug;
					if ($changedCommand != "") 
					{
						string $cmd = $changedCommand + " \"" + $node + "\"";
						scriptJob -p $childCtrl -rp -ac $childPlug $cmd;
					}
				}
				else if( $childType == "long" )
				{
					AEnewInt($childPlug, $childAttrNice, $changedCommand);
				}
				else if( $childType == "float" || $childType == "time" || $childType == "double" )
				{
					string $childCtrl = AEnewFloat($childPlug, $childAttrNice, $changedCommand);
				}
				else if( $childType == "enum" )
				{
					string $enumItems[];
					getEnumItems($node, $childAttrs[$i]);
					AEnewEnum($childPlug, $childAttrNice, $changedCommand, $enumItems);
				}
				else if( `attributeQuery -node $node -usedAsColor $childAttrs[$i]` )
				{
					AEnewColor($childPlug, $childAttrNice, $changedCommand);
				}
				else if( $childType == "matrix" )
				{
					AEnewMatrix($childPlug, $childAttrNice, $changedCommand);
				}
				else if( $childType == "string" )
				{
					AEnewString($childPlug, $childAttrNice, $changedCommand);
				}
				else if( $childType == "float3" )
				{
					AEnewVector($childPlug, $childAttrNice, $changedCommand);
				}
				else if( $childType == "message" )
				{
					AEnewMessage($childPlug, $childAttrNice, $changedCommand);
				}
				else
				{
					AEnewOther($childPlug, $childAttrNice, $changedCommand);
				}
			}

			if( $isMulti )
			{
				//	Delete button
				setUITemplate -pst attributeEditorMultiTemplate;
					rowLayout -nc 3;
						text -label "";
						symbolButton 
							-image "smallTrash.png" 
							-command ("AEremoveMultiElement " + $plugName);
						text -label "";
					setParent ..;
				setUITemplate -ppt;
			}

		setParent ..;	// columnLayout
		setParent ..;	// frameLayout
	setUITemplate -popTemplate;
	
	return $createdControl;
}
