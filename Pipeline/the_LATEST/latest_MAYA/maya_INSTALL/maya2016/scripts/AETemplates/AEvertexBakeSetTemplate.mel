// Copyright (C) 1997-2014 Autodesk, Inc., and/or its licensors.
// All rights reserved.
//
// The coded instructions, statements, computer programs, and/or related
// material (collectively the "Data") in these files contain unpublished
// information proprietary to Autodesk, Inc. ("Autodesk") and/or its licensors,
// which is protected by U.S. and Canadian federal copyright law and by
// international treaties.
//
// The Data is provided for use exclusively by You. You have the right to use,
// modify, and incorporate this Data into other products for purposes authorized 
// by the Autodesk software license agreement, without fee.
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND. AUTODESK
// DOES NOT MAKE AND HEREBY DISCLAIMS ANY EXPRESS OR IMPLIED WARRANTIES
// INCLUDING, BUT NOT LIMITED TO, THE WARRANTIES OF NON-INFRINGEMENT,
// MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE, OR ARISING FROM A COURSE 
// OF DEALING, USAGE, OR TRADE PRACTICE. IN NO EVENT WILL AUTODESK AND/OR ITS
// LICENSORS BE LIABLE FOR ANY LOST REVENUES, DATA, OR PROFITS, OR SPECIAL,
// DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES, EVEN IF AUTODESK AND/OR ITS
// LICENSORS HAS BEEN ADVISED OF THE POSSIBILITY OR PROBABILITY OF SUCH DAMAGES.

//
//  Description:
//		This script lays out the attribute editor
//		for vertexBakeSet nodes.
//


global proc vertexBakeAlphaChanged (string $nodeName)
{
	string $nodeAttr = $nodeName + ".bakeAlpha";
	int $value = `getAttr $nodeAttr`;
	
	if( $value == 1 )	
	{
		int $clampMin = `getAttr ($nodeName + ".clampMin")`;
		int $clampMax = `getAttr ($nodeName + ".clampMax")`;
		editorTemplate -dimControl $nodeName "alphaBlending" false;
		editorTemplate -dimControl $nodeName "minAlpha" (!$clampMin);
		editorTemplate -dimControl $nodeName "maxAlpha" (!$clampMax);
	}
	else
	{
		editorTemplate -dimControl $nodeName "alphaBlending" true;
		editorTemplate -dimControl $nodeName "minAlpha" true;
		editorTemplate -dimControl $nodeName "maxAlpha" true;
	}
}

global proc vertexBakeColorChanged (string $nodeName)
{
	string $nodeAttr = $nodeName + ".bakeColor";
	int $value = `getAttr $nodeAttr`;
	
	if( $value == 1 )	
	{
		int $clampMin = `getAttr ($nodeName + ".clampMin")`;
		int $clampMax = `getAttr ($nodeName + ".clampMax")`;
		editorTemplate -dimControl $nodeName "colorBlending" false;
		editorTemplate -dimControl $nodeName "minColor" (!$clampMin);
		editorTemplate -dimControl $nodeName "maxColor" (!$clampMax);
	}
	else
	{
		editorTemplate -dimControl $nodeName "colorBlending" true;
		editorTemplate -dimControl $nodeName "minColor" true;
		editorTemplate -dimControl $nodeName "maxColor" true;
	}
}

global proc clampMinChanged (string $nodeName)
{
	string $nodeAttr = $nodeName + ".clampMin";
	int $value = `getAttr $nodeAttr`;
	if( $value == 1 )
	{
		int $bakeAlpha = `getAttr ($nodeName + ".bakeAlpha")`;	
		int $bakeColor = `getAttr ($nodeName + ".bakeColor")`;	
		editorTemplate -dimControl $nodeName "minColor" (!$bakeColor);
		editorTemplate -dimControl $nodeName "minAlpha" (!$bakeAlpha);
	}
	else
	{ 
		editorTemplate -dimControl $nodeName "minColor" true;
		editorTemplate -dimControl $nodeName "minAlpha" true;
	}
}

global proc clampMaxChanged (string $nodeName)
{
	string $nodeAttr = $nodeName + ".clampMax";
	int $value = `getAttr $nodeAttr`;
	if( $value == 1 )
	{
		int $bakeAlpha = `getAttr ($nodeName + ".bakeAlpha")`;
		int $bakeColor = `getAttr ($nodeName + ".bakeColor")`;	
		editorTemplate -dimControl $nodeName "maxColor" (!$bakeColor);
		editorTemplate -dimControl $nodeName "maxAlpha" (!$bakeAlpha);
	}
	else
	{
		editorTemplate -dimControl $nodeName "maxColor" true;
		editorTemplate -dimControl $nodeName "maxAlpha" true;
	}
}


// Description:  This procedure is called when filterSize changes.
//      When the filterSize is less than 0, disable
//      filtering.
//
global proc AEvertexBakeSetFilterSizeChanged(string $nodeName)
{
    float $filterSize = `getAttr ($nodeName+".filterSize")`;

    // When the filterSize is less than 0, disable filtering.
    // Therefore, dim the filter normal tolerance control.
    //
    int $dimFilterNormalTolerance = ($filterSize < 0);
                
    editorTemplate -dimControl $nodeName "filterNormalTolerance" 
        $dimFilterNormalTolerance;
}

//
//	Description:
//		Called when the user changes color set name from the menu
//		Set vertexSet.colorSetName from the optionMenuGrp
//
global proc vertexBakeSetColorSetNameCtrlChanged( string $plug )
{

	if( `optionMenuGrp -q -exists AEvertexBakeSetColorSetNameCtrl`==0 )
		return;	
		
	// get number of menues
	int $numMenus = `optionMenuGrp -q -numberOfItems AEvertexBakeSetColorSetNameCtrl`;
	
	// the last menu is selected.
	// the last menu is "Create New Color Set Name"
	if( `optionMenuGrp -q -select AEvertexBakeSetColorSetNameCtrl` == $numMenus )
	{
		// Enable text field
		textFieldGrp -e -enable 1 AEvertexBakeSetNewColorSetNameCtrl;
	}
	else
	{
		//
		setAttr $plug -type "string" `optionMenuGrp -q -value AEvertexBakeSetColorSetNameCtrl`;
		
		// Disable text field
		textFieldGrp -e -enable 0 AEvertexBakeSetNewColorSetNameCtrl;
	}	
}

//
//	Description:
//		Called when user chooses to create a new color set name for baking
//
global proc vertexBakeSetNewColorSetNameCtrlChanged( string $plug )
{
	setAttr $plug -type "string" `textFieldGrp -q -text AEvertexBakeSetNewColorSetNameCtrl`;
}

//	Description:	
//		List color set names of meshes.
//		If user wants to create a new one,
//		enable the text editor
//
global proc AEvertexBakeSetReplace( string $plug )
{
	// save current parent
	string $parent = `setParent -q`;
	
	// Get bake set node name
	string $node;
	string $buffer[];
	tokenize($plug, ".", $buffer);
	$node = (size($buffer) > 0) ? $buffer[0] : "";
	
	// get color set name
	string $colorSetName = `getAttr $plug`;
	
	// Find related mesh shapes
	string $meshShapes[] = 
		stringArrayRemoveDuplicates(`listConnections -destination 0 -type mesh -shapes 1 $node`);
	
	string $colorSets[];
	string $tmpColorSets[];
	
	// Add color set of each shape to the list
	for( $shape in $meshShapes )
	{
		$tmpColorSets = `polyColorSet -q -allColorSets $shape`;
		$colorSets = stringArrayCatenate($colorSets, $tmpColorSets);
	}
	
	// remove duplicates
	$colorSets = stringArrayRemoveDuplicates($colorSets);
	$colorSets = `sort $colorSets`;
	
	
	// recreate the pull down menu
	deleteUI AEvertexBakeSetColorSetNameCtrl;
	optionMenuGrp 
		-label (uiRes("m_AEvertexBakeSetTemplate.kColorSetName")) 
		-cc ("vertexBakeSetColorSetNameCtrlChanged(\"" + $plug + "\")")
		AEvertexBakeSetColorSetNameCtrl;
	
	
	int $count = 0;
	int $select = 0;
	
	// add menu items
	setParent  "AEvertexBakeSetColorSetNameCtrl";
	for( $colorSet in $colorSets )
	{
	
		menuItem -label $colorSet;
		$count++;
		if( $colorSet == $colorSetName )
			$select = $count;
	}
	
	// add menu to create a new color set name
	menuItem -label (uiRes("m_AEvertexBakeSetTemplate.kCreateNewColorSetName"));
	$count++;
	
	//	Found a menu item that matches vertexBakeSet.colorSetName
	if( $select > 0 )
	{
		// disable the text field
		textFieldGrp -e -enable 0 AEvertexBakeSetNewColorSetNameCtrl;
	}
	else
	{
		// select "Create New Color Set Name" and 
		// enable the text field
		$select = $count;
		textFieldGrp -e -enable 1 AEvertexBakeSetNewColorSetNameCtrl;
	}
		
	optionMenuGrp -e -select $select AEvertexBakeSetColorSetNameCtrl;
	
	// update text field change command
	textFieldGrp -e
		-cc ("vertexBakeSetNewColorSetNameCtrlChanged(\"" + $plug + "\")")
		AEvertexBakeSetNewColorSetNameCtrl;
	
	setParent $parent;
	
}			


global proc AEvertexBakeSetNew( string $plug )
{
	optionMenuGrp -label (uiRes("m_AEvertexBakeSetTemplate.kColorSetName")) 
		AEvertexBakeSetColorSetNameCtrl;
		
	textFieldGrp -label (uiRes("m_AEvertexBakeSetTemplate.kCreateNewColorSet"))
		AEvertexBakeSetNewColorSetNameCtrl;		
			
	AEvertexBakeSetReplace($plug);
}


global proc AEvertexBakeSetTemplate( string $nodeName )
{
	editorTemplate -beginScrollLayout;

	editorTemplate -beginLayout (uiRes("m_AEvertexBakeSetTemplate.kVertexBakeSetAttributes")) -collapse false;
	
		AEbakeSetTemplate $nodeName;

		editorTemplate -addSeparator;
		
		editorTemplate -callCustom 
						"AEvertexBakeSetNew"
						"AEvertexBakeSetReplace"
						"colorSetName";
		
		editorTemplate -addSeparator;
		
		editorTemplate -addControl "bakeColor" "vertexBakeColorChanged"; 
		editorTemplate -addControl "bakeAlpha" "vertexBakeAlphaChanged"; 
		
		editorTemplate -addSeparator;
		
		editorTemplate -addControl "scaleRgba";
		editorTemplate -addControl "clampMin" "clampMinChanged";
		editorTemplate -addControl "minColor";
		editorTemplate -addControl "minAlpha";
		editorTemplate -addControl "clampMax" "clampMaxChanged";
		editorTemplate -addControl "maxColor";
		editorTemplate -addControl "maxAlpha";
		
		editorTemplate -addSeparator;
        
        editorTemplate -addControl "colorBlending";
		editorTemplate -addControl "alphaBlending";
		
		editorTemplate -addSeparator;
		
	    editorTemplate -beginLayout (uiRes("m_AEvertexBakeSetTemplate.kVertexColorFiltering")) 
            -collapse false;

	        editorTemplate -label (uiRes("m_AEvertexBakeSetTemplate.kFilterSize")) 
	            -adc "filterSize"
                "AEvertexBakeSetFilterSizeChanged"; 
	        editorTemplate -label (uiRes("m_AEvertexBakeSetTemplate.kFilterNormalTolerance"))
	            -adc "filterNormalTolerance"; 
	        editorTemplate -addControl "useFaceNormals";    

	    editorTemplate -endLayout;

	editorTemplate -endLayout;

	// include/call base class/node attributes
	AEobjectSetNoScroll $nodeName;

	editorTemplate -addExtraControls;
	editorTemplate -endScrollLayout;
	
	editorTemplate -suppress "alphaMode";
}

