// Copyright (C) 1997-2014 Autodesk, Inc., and/or its licensors.
// All rights reserved.
//
// The coded instructions, statements, computer programs, and/or related
// material (collectively the "Data") in these files contain unpublished
// information proprietary to Autodesk, Inc. ("Autodesk") and/or its licensors,
// which is protected by U.S. and Canadian federal copyright law and by
// international treaties.
//
// The Data is provided for use exclusively by You. You have the right to use,
// modify, and incorporate this Data into other products for purposes authorized 
// by the Autodesk software license agreement, without fee.
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND. AUTODESK
// DOES NOT MAKE AND HEREBY DISCLAIMS ANY EXPRESS OR IMPLIED WARRANTIES
// INCLUDING, BUT NOT LIMITED TO, THE WARRANTIES OF NON-INFRINGEMENT,
// MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE, OR ARISING FROM A COURSE 
// OF DEALING, USAGE, OR TRADE PRACTICE. IN NO EVENT WILL AUTODESK AND/OR ITS
// LICENSORS BE LIABLE FOR ANY LOST REVENUES, DATA, OR PROFITS, OR SPECIAL,
// DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES, EVEN IF AUTODESK AND/OR ITS
// LICENSORS HAS BEEN ADVISED OF THE POSSIBILITY OR PROBABILITY OF SUCH DAMAGES.

//
//  Procedure Name:
//	AEdisplayLayerNoScroll
//
//  Description Name;
//	Creates the attribute editor controls for the displayLayer Node
//
//  Input Value:
//	nodeName 
//
//  Output Value:
//	None
// 

global proc int getCurrentColor( string $layerColorAttr )
{
	int $color = `getAttr $layerColorAttr`;
	if ( $color < 1 ) {
		$color = 0;	// If out of range select the invisible color
	} else if ( $color > 31 ) {
		$color = 31;
	}
	return $color + 1;
}

global proc changeObjColor ( string $layerColorAttr, string $colorCtrl )
{

	int $color = `colorIndexSliderGrp -q -v $colorCtrl` - 1;

	if( catch(`setAttr $layerColorAttr $color`) )
	{
		int $oldColor = getCurrentColor( $layerColorAttr );
		colorIndexSliderGrp -e -v $oldColor $colorCtrl;
	}
}

global proc updateLayerColor (string $layerColorAttr, string $colorCtrl)
{
	// check to set the correct initial settings
	int $color = getCurrentColor( $layerColorAttr );
	colorIndexSliderGrp -e -v $color $colorCtrl;
}

//
//	drawInfoObjColorReplace
//
global proc drawInfoObjColorReplace (string $layerColorAttr)
{
	// There are more then one instance of this slider so to
	// be safe get its full name.
	string $colorCtrl = (`setParent -query` + "|objIndexColorSlider");
	
	colorIndexSliderGrp -e  
			-cc ("changeObjColor " + $layerColorAttr + " "+ $colorCtrl )
			objIndexColorSlider;

	updateLayerColor $layerColorAttr $colorCtrl;
	
	scriptJob -p objIndexColorSlider -rp 
		-attributeChange $layerColorAttr 
		("updateLayerColor " + $layerColorAttr + " " + $colorCtrl);

}

//
//	drawInfoObjColorNew
//
global proc drawInfoObjColorNew ( string $layerColorAttr )
{
	setUITemplate -pst attributeEditorTemplate;
	colorIndexSliderGrp  -label ""  
			-invisible 1
			-v 1			// Color index 1 is taken as the invisible one
			-min 1 -max 32	// Enable the entire (dormant) colour palette
			objIndexColorSlider;
	setUITemplate -ppt;
	colorIndexSliderGrp -e -el "" objIndexColorSlider;
	
	drawInfoObjColorReplace  $layerColorAttr;
}

//
//  RGB color functions
//

global proc float[] getCurrentRGBColor( string $layerColorAttr )
{
	return `getAttr $layerColorAttr`;
}

global proc changeObjRGBColor ( string $layerColorAttr, string $colorCtrl )
{

	float $color[] = `colorSliderGrp -q -rgb $colorCtrl`;

	if( catch(`setAttr $layerColorAttr $color[0] $color[1] $color[2]`) )
	{
		float $oldColor[] = getCurrentRGBColor( $layerColorAttr );
		colorSliderGrp -e -rgb $oldColor $colorCtrl;
	}
}

global proc updateLayerRGBColor (string $layerColorAttr, string $colorCtrl)
{
	// check to set the correct initial settings
	float $color[] = getCurrentRGBColor( $layerColorAttr );
	colorSliderGrp -e -rgb $color[0] $color[1] $color[2] $colorCtrl;
}

global proc updateObjColorsVisibility(string $layerColorAttr)
{
	int $colorType = `getAttr $layerColorAttr`;
	colorIndexSliderGrp -e -visible ($colorType == 0) objIndexColorSlider;
	colorSliderGrp -e -visible ($colorType == 1) objRGBColorSlider;
}

global proc changeObjLayerColorType ( string $layerColorAttr, string $colorCtrl )
{
	int $useRgb = `optionMenuGrp -q -select $colorCtrl` == 2;

	if( catch(`setAttr $layerColorAttr $useRgb`) )
	{
		int $oldColorType = `getAttr $layerColorAttr`;
		optionMenuGrp -e -select ($oldColorType == 0 ? 1 : 2) $colorCtrl;
	}
	
	updateObjColorsVisibility($layerColorAttr);
}

global proc updateObjLayerColorType (string $layerColorAttr, string $colorCtrl)
{
	// check to set the correct initial settings
	int $colorType = `getAttr $layerColorAttr`;
	optionMenuGrp -e -select ($colorType == 0 ? 1 : 2) $colorCtrl;
}

//
//	drawInfoObjRGBColorReplace
//
global proc drawInfoObjRGBColorReplace (string $layerColorAttr)
{
	// There are more then one instance of this slider so to
	// be safe get its full name.
	string $colorCtrl = (`setParent -query` + "|objRGBColorSlider");
	
	colorSliderGrp -e  
			-cc ("changeObjRGBColor " + $layerColorAttr + " "+ $colorCtrl )
			objRGBColorSlider;

	updateLayerRGBColor $layerColorAttr $colorCtrl;
	
	scriptJob -p objRGBColorSlider -rp 
		-attributeChange $layerColorAttr 
		("updateLayerRGBColor " + $layerColorAttr + " " + $colorCtrl);

}

//
//	drawInfoObjRGBColorNew
//
global proc drawInfoObjRGBColorNew ( string $layerColorAttr )
{
	setUITemplate -pst attributeEditorTemplate;
	colorSliderGrp  -label "" objRGBColorSlider;
	setUITemplate -ppt;

	drawInfoObjRGBColorReplace  $layerColorAttr;
}

//
//	drawInfoObjColorTypeReplace
//
global proc drawInfoObjColorTypeReplace (string $layerColorAttr)
{
	// There are more then one instance of this widget so to
	// be safe get its full name.
	string $colorCtrl = (`setParent -query` + "|objOverrideColorType");
	
	optionMenuGrp -e  
			-cc ("changeObjLayerColorType " + $layerColorAttr + " "+ $colorCtrl )
			objOverrideColorType;

	updateObjLayerColorType $layerColorAttr $colorCtrl;
	
	scriptJob -p objOverrideColorType -rp 
		-attributeChange $layerColorAttr 
		("updateObjLayerColorType " + $layerColorAttr + " " + $colorCtrl);

}

//
//	drawInfoObjColorTypeNew
//
global proc drawInfoObjColorTypeNew ( string $layerColorAttr )
{
	setUITemplate -pst attributeEditorTemplate;
	optionMenuGrp -label (uiRes("m_AEdrawInfo.kColorType")) objOverrideColorType;
	menuItem -label (uiRes("m_AEdrawInfo.kIndexed"));
	menuItem -label (uiRes("m_AEdrawInfo.kRGB"));
	
	setUITemplate -ppt;

	drawInfoObjColorTypeReplace  $layerColorAttr;
}
// On incoming connections from the layers to the objects turning off
// the "enabled" flag should gray out the other controls as they will be
// ignored from then on.  The outgoing connections can still modify the
// values although they will not have immediate effect.
//
global proc checkDrawEnabled(
	string	$enabledName,
	string	$displayTypeName,
	string	$levelOfDetailName,
	string	$shadingName,
	string	$texturingName,
	string	$playbackName,
	string	$visibleName,
	string  $useRGBName,
	string  $colourName,
	string	$rgbColourName,
	string	$nodeName )
{
	string $long[] = `ls -long $nodeName`;
	string $nodeAttr = $long[0] + "." + $enabledName;
	int $value = 1 - `getAttr $nodeAttr`;

	// Disable everything for the default layer.  It has no effect
	// on its members anyway so no sense in misleading the user.
	//
	string $mgr[] = `ls -type displayLayerManager`;
	if( size($mgr) > 0 )
	{
		string $def[] = `listConnections ($mgr[0] + ".displayLayerId[0]")`;
		if( (size($def) > 0)
		&&  ($def[0] == $nodeName) )
		{
			$value = 1;
		}
	}

	editorTemplate -dimControl $nodeName $displayTypeName ($value);
	editorTemplate -dimControl $nodeName $levelOfDetailName ($value);
	editorTemplate -dimControl $nodeName $shadingName ($value);
	editorTemplate -dimControl $nodeName $texturingName ($value);
	editorTemplate -dimControl $nodeName $playbackName ($value);
	editorTemplate -dimControl $nodeName $visibleName ($value);
	editorTemplate -dimControl $nodeName $useRGBName ($value);
	editorTemplate -dimControl $nodeName $rgbColourName ($value);
	
	if (`colorIndexSliderGrp -exists objIndexColorSlider`) {
		// replaced slider control with dimControls
		editorTemplate -dimControl $nodeName $colourName ($value);	
	}
}

//	AEdrawInfo
//
global proc AEdrawInfo (
	string $displayTypeName
,	string $levelOfDetailName
,	string $shadingName
,	string $texturingName
,	string $playbackName
,	string $enabledName
,	string $visibleName
,	string $useRGBName
,	string $colourName
,	string $rgbColourName
)
{
	editorTemplate -beginNoOptimize;

	// Make a callback for the incoming end of the enabled flag so that
	// disabling it shuts off the ability to change the other (ignored)
	// values.
	//
	editorTemplate -label (uiRes("m_AEdrawInfo.kEnableOverrides"))  -addControl $enabledName
					("checkDrawEnabled "   + $enabledName + " " +
					$displayTypeName + " " + $levelOfDetailName + " " +
					$shadingName	 + " " + $texturingName + " " +
					$playbackName	 + " " + $visibleName + " " +
					$useRGBName		 + " " + $colourName + " " +
					$rgbColourName);

	editorTemplate -label (uiRes("m_AEdrawInfo.kDisplayType"))  -addControl $displayTypeName;
	editorTemplate -label (uiRes("m_AEdrawInfo.kLevelofDetail"))  -addControl $levelOfDetailName;
	editorTemplate -label (uiRes("m_AEdrawInfo.kShading"))  -addControl $shadingName;
	editorTemplate -label (uiRes("m_AEdrawInfo.kTexturing"))  -addControl $texturingName;
	editorTemplate -label (uiRes("m_AEdrawInfo.kPlayback"))  -addControl $playbackName;
	editorTemplate -label (uiRes("m_AEdrawInfo.kVisible"))  -addControl $visibleName;
	editorTemplate -endNoOptimize;
	editorTemplate -callCustom "drawInfoObjColorTypeNew" "drawInfoObjColorTypeReplace"
				$useRGBName;
	editorTemplate -callCustom "drawInfoObjColorNew" "drawInfoObjColorReplace"
				$colourName;
	editorTemplate -callCustom "drawInfoObjRGBColorNew" "drawInfoObjRGBColorReplace"
				$rgbColourName;

	editorTemplate -callCustom "updateObjColorsVisibility" "updateObjColorsVisibility"
				$useRGBName;
}
