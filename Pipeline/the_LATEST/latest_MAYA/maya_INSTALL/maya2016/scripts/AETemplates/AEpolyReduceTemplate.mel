// Copyright (C) 1997-2014 Autodesk, Inc., and/or its licensors.
// All rights reserved.
//
// The coded instructions, statements, computer programs, and/or related
// material (collectively the "Data") in these files contain unpublished
// information proprietary to Autodesk, Inc. ("Autodesk") and/or its licensors,
// which is protected by U.S. and Canadian federal copyright law and by
// international treaties.
//
// The Data is provided for use exclusively by You. You have the right to use,
// modify, and incorporate this Data into other products for purposes authorized 
// by the Autodesk software license agreement, without fee.
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND. AUTODESK
// DOES NOT MAKE AND HEREBY DISCLAIMS ANY EXPRESS OR IMPLIED WARRANTIES
// INCLUDING, BUT NOT LIMITED TO, THE WARRANTIES OF NON-INFRINGEMENT,
// MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE, OR ARISING FROM A COURSE 
// OF DEALING, USAGE, OR TRADE PRACTICE. IN NO EVENT WILL AUTODESK AND/OR ITS
// LICENSORS BE LIABLE FOR ANY LOST REVENUES, DATA, OR PROFITS, OR SPECIAL,
// DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES, EVEN IF AUTODESK AND/OR ITS
// LICENSORS HAS BEEN ADVISED OF THE POSSIBILITY OR PROBABILITY OF SUCH DAMAGES.

//
//
//  Creation Date:	January 2012
//
//  An earlier version was written June 5, 1997.
//
//  Procedure Name:
//	AEpolyReduceTemplate
//
//  Description Name;
//	Creates the attribute editor controls for the polyReduce Node
//
//  Input Value:
//	nodeName
//
//  Output Value:
//	None
//

proc attrFloatField4Grp(
        string $label,
        string $floatPlug1,
        string $floatPlug2,
        string $floatPlug3,
        string $floatPlug4,
        string $shortName )
//
// This is a 4D vector
//
{
    // Edits to the setup here must be reflected in
    // attrFloatField4GrpEnable/Edit below.
    rowLayout -nc 6 -cw 5 15 $shortName;
        text -l $label label;
        floatField field1;
        floatField field2;
        floatField field3;
        text -al right -l (uiRes("m_AEpolyReduceTemplate.kVectorW")) label4;
        floatField field4;
        connectControl field1 $floatPlug1;
        connectControl field2 $floatPlug2;
        connectControl field3 $floatPlug3;
        connectControl field4 $floatPlug4;
    setParent ..;
}


proc attrFloatField4GrpEnable(
        int $enable,
        string $shortName )
//
// Enable/disable an existing float4 group.
//
{
    string $oldParent = `setParent -q`;
    setParent $shortName;
		text -e -en $enable label;
        floatField -e -en $enable field1;
        floatField -e -en $enable field2;
        floatField -e -en $enable field3;
        floatField -e -en $enable field4;
        text -e -en $enable label4;
    setParent $oldParent;
}

proc attrFloatField4GrpEdit(
        string $floatPlug1,
        string $floatPlug2,
        string $floatPlug3,
        string $floatPlug4,
        string $shortName )
//
// Update an existing float4 group.
//
{
    setParent $shortName;
        connectControl field1 $floatPlug1;
        connectControl field2 $floatPlug2;
        connectControl field3 $floatPlug3;
        connectControl field4 $floatPlug4;
    setParent ..;
}

global proc AEpolyReduceVersionChanged( string $parentLayout )
//
// This callback is intended to be invoked when the version attribute
// is changed. It will update the visibility of the version specific
// UI layout.
//
{
	string $versionControl = $parentLayout + "|AEpolyReduceVersionLayout|AEpolyReduceVersionField";
	columnLayout -e -vis 0 ($parentLayout + "|AEpolyReduceVersionLayout");	
	string $nodeAttr = `attrControlGrp -q -a $versionControl`;
	string $node = `plugNode $nodeAttr`;
	int $value = `getAttr $nodeAttr`;

	switch( $value )
	{
	case 0:	// Maya
		columnLayout -e -vis 0 ($parentLayout + "|AEpolyReduceSoftimageLayout");
		columnLayout -e -vis 1 ($parentLayout + "|AEpolyReduceMayaLayout");
		break;
	case 1: // Softimage
		columnLayout -e -vis 0 ($parentLayout + "|AEpolyReduceMayaLayout");
		columnLayout -e -vis 1 ($parentLayout + "|AEpolyReduceSoftimageLayout");

		// Percentage may have changed under Maya version. Ensure
		// we update our cached results for the Softimage UI.
		string $termControl = $parentLayout + "|AEpolyReduceSoftimageLayout|AEpolyReduceTerminationConditions|AEpolyReduceTerminationField";
		string $termPlug = ($node + ".termination");
		AEpolyReduceRecordTermResults( $parentLayout, $termPlug );
		break;
	}
}

global proc AEpolyReduceTriangulateChanged( string $parentLayout )
//
// This callback is intended to be invoked when the triangulate
// attribute from the Maya controls is updated.
//
{
	string $triControl = $parentLayout + "|AEpolyReduceMayaLayout|AEpolyReduceTriangulateField";
	string $nodeAttr = `attrControlGrp -q -a $triControl`;
	int $value = `getAttr $nodeAttr`;

	if( $value ) {
		attrFieldSliderGrp -e -en 0 ($parentLayout + "|AEpolyReduceMayaLayout|AEpolyReduceKeepQuadsField");
	} else {
		attrFieldSliderGrp -e -en 1 ($parentLayout + "|AEpolyReduceMayaLayout|AEpolyReduceKeepQuadsField");
	}
}

global proc AEpolyReduceUpdateSymmetry( string $parentLayout )
//
// This callback is intended to be invoked when anything that affects
// symmetry controls has changed.
//
{
	string $shapeOptions = $parentLayout +
		"|AEpolyReduceSoftimageLayout|AEpolyReduceShapeOptions";
	string $quadControl = $shapeOptions + "|AEpolyReduceKeepQuadsField";
	string $symControl  = $shapeOptions + "|AEpolyReduceSymmetryType";
	string $quadAttr = `attrControlGrp -q -a $quadControl`;
	string $symAttr  = `attrControlGrp -q -a $symControl`;
	int $quad = (`getAttr $quadAttr` == 1.0);
	int $sym  = `getAttr $symAttr`;

    attrEnumOptionMenuGrp -e -en (!$quad) ($shapeOptions + "|AEpolyReduceSymmetryType");
    attrFieldSliderGrp -e -en (!$quad && $sym > 0) ($shapeOptions + "|AEpolyReduceSymmetryTolerance");

	string $symmetryPlane = $shapeOptions + "|AEpolyReduceSymmetryPlane";
	attrFloatField4GrpEnable (!$quad && $sym > 1) $symmetryPlane;
}

proc int AEpolyReduceTermType(string $node)
//
// Local proc to retrieve an integer termination type from a polyReduce node.
//
{
    string $termAttr = $node + ".termination";
    int $termType = `getAttr $termAttr`;

    // If the termType is out of range somehow, default to percentage.
    if ($termType < 0 || $termType > 2) { $termType = 0; }
    return $termType;
}

global string $AEpolyReduceTerminationTypeNames[] = {
    "percentage",
    "vertexCount",
    "triangleCount"
};

proc int AEpolyReduceTermTypeFromAttr(string $attrName)
//
// Local proc to retrieve an integer termination type from an attribute name.
// Valid names are defined in $AEpolyReduceTerminationTypeNames.
//
{
    global string $AEpolyReduceTerminationTypeNames[];
    int $i;
    for($i = 0; $i < size($AEpolyReduceTerminationTypeNames); ++$i) {
        if ($attrName == $AEpolyReduceTerminationTypeNames[$i]) {
            return $i;
        }
    }
    return 0;
}

proc setSliders(
        string $field,
        string $slider,
        string $floatPlug)
{
    // Set the slider and field ranges.  Unfortunately this isn't
    // automatic nor even particularly easy.
    string $floatNode = `plugNode $floatPlug`;
    string $floatAttr = `plugAttr $floatPlug`;

    int $hasMin = false;
    float $min;
    if (`attributeQuery -n $floatNode -minExists $floatAttr` ) {
        float $mins[] =`attributeQuery -n $floatNode -min $floatAttr`;
        $hasMin = true;
        $min = $mins[0];
        floatField -e -minValue $min $field;
    }
    if (`attributeQuery -n $floatNode -softMinExists $floatAttr` ) {
        float $mins[] =`attributeQuery -n $floatNode -softMin $floatAttr`;
        floatSlider -e -minValue $mins[0] $slider;
    } else if ($hasMin) {
        floatSlider -e -minValue $min $slider;
    }

    int $hasMax = false;
    float $max;
    if (`attributeQuery -n $floatNode -maxExists $floatAttr` ) {
        float $maxs[] =`attributeQuery -n $floatNode -max $floatAttr`;
        $hasMax = true;
        $max = $maxs[0];
        floatField -e -maxValue $max $field;
    }
    if (`attributeQuery -n $floatNode -softMaxExists $floatAttr` ) {
        float $maxs[] =`attributeQuery -n $floatNode -softMax $floatAttr`;
        floatSlider -e -maxValue $maxs[0] $slider;
    } else if ($hasMax) {
        floatSlider -e -maxValue $max $slider;
    }
}

global proc AEpolyReduceCheckBoxSliderEnable(string $parentPath)
//
// Enable or disable parentPath|field and parentPath|slider.
//
{
    string $oldParent = `setParent -q`;
    setParent $parentPath;
        int $enable = `checkBox -q -v box`;
        floatField  -e -en $enable field;
        floatSlider -e -en $enable slider;
    setParent $oldParent;
}


proc attrCheckBoxSliderGrp(
        string $label,
        string $boolPlug,
        string $floatPlug,
        string $shortName )
//
// This is a checkBox attached to an attribute.
//
{
    // Edits to the setup here must be reflected in
    // attrCheckBoxSliderGrpEdit below.
    // The rowLayout column widths are carefully eyeballed to make the
    // control line up with an attrFieldSliderGrp
    $parent = `rowLayout -nc 4 -cw 2 15 -cw 3 53 -cat 4 right 4 -adj 4 $shortName`;
        string $callback = ("AEpolyReduceCheckBoxSliderEnable " + $parent);
        int $enable = `getAttr $boolPlug`;
        text -l $label;
        checkBox -l "" -cc $callback    box;
        floatField  -en $enable         field;
        floatSlider -en $enable slider;
        connectControl box    $boolPlug;
        connectControl field  $floatPlug;
        connectControl slider $floatPlug;
        setSliders     field slider $floatPlug;
    setParent ..;
}


proc attrCheckBoxSliderGrpEdit(
        string $boolPlug,
        string $floatPlug,
        string $shortName )
//
// Update an existing checkbox/slider group.
// We don't update the slider range (we assume it's the same range,
// given it's the same type of attribute).
//
{
    setParent $shortName;
        connectControl box    $boolPlug;
        connectControl field  $floatPlug;
        connectControl slider $floatPlug;
        AEpolyReduceCheckBoxSliderEnable `setParent -q`;
    setParent ..;
}


////////////////////////////////
// MAYA-9848: attrControlGrp -e silently fails on some attribute types.
// That includes strings.  So we implement our own version: use
//   attrStringControlGrp $label $plug $control
// to create, and
//   attrStringControlGrp ""     $plug $control
// to edit.
//
global proc polyReduceStringControlGrpUIChanged(
        string $plug,
        string $parent,
        string $controlName)
{
    string $oldParent = `setParent -q`;

    setParent $parent;
        string $oldvalue = `getAttr $plug`;
        string $newvalue = `textFieldGrp -q -tx $controlName`;
        if ($oldvalue != $newvalue) {
            setAttr -type "string" $plug $newvalue;
        }
    setParent $oldParent;
}

global proc polyReduceStringControlGrpAttrChanged(
        string $plug,
        string $parent,
        string $controlName)
{
    string $oldParent = `setParent -q`;

    setParent $parent;
        string $oldvalue = `textFieldGrp -q -tx $controlName`;
        string $newvalue = `getAttr $plug`;
        if ($oldvalue != $newvalue) {
            textFieldGrp -e -tx $newvalue $controlName;
        }
    setParent $oldParent;
}

proc string attrStringControlGrp(
        string $label,
        string $plug,
        string $controlName)
{
    string $parent = `setParent -q`;
    string $value = `getAttr $plug`;
    string $uicallback = ("polyReduceStringControlGrpUIChanged " + $plug +
                " " + $parent + " " + $controlName);
    string $attrcallback = ("polyReduceStringControlGrpAttrChanged " + $plug +
                " " + $parent + " " + $controlName);
    string $controlPath;
    if ($label != "") {
        // Create.
        $controlPath = `textFieldGrp -l $label
                -tx $value -cc $uicallback $controlName`;
    } else {
        // Edit.
        $controlPath = `textFieldGrp -e
                -tx $value -cc $uicallback $controlName`;
    }

    // Now create a scriptjob tied to the control, replacing whatever
    // used to be there.
    scriptJob -parent $controlPath -rp -ac $plug $attrcallback;

    return $controlPath;
}


global proc AEpolyReduceTerminationChanged( string $parentLayout, string $terminationPlug, int $updateTermInput )
//
// This callback is intended to be invoked when the termination attribute
// changes.
//
// Here we update the target condition with the last computed termination
// result so as to make this transition seamless. In addition, we update the
// UI states of the termination condition fields.
//
{
	string $termControl = $parentLayout + "|AEpolyReduceSoftimageLayout|AEpolyReduceTerminationConditions|AEpolyReduceTerminationField";
	string $percentageControl = $parentLayout + "|AEpolyReduceSoftimageLayout|AEpolyReducePercentageAchievedField";
	string $vertexControl = $parentLayout + "|AEpolyReduceSoftimageLayout|AEpolyReduceVertexCountAchievedField";
	string $triangleControl = $parentLayout + "|AEpolyReduceSoftimageLayout|AEpolyReduceTriangleCountAchievedField";

	string $node = `plugNode $terminationPlug`;
    int $termType = AEpolyReduceTermType( $node );

    // For the attribute that is newly the target, copy the "reduced" value
    // back to the target value.  Leave the others alone.
    // The "Changed" callback gets called even when we haven't changed
    // sometimes, so don't do the setAttr unless it's necessary.
    global string $AEpolyReduceTerminationTypeNames[];
	string $targetAttr = $AEpolyReduceTerminationTypeNames[$termType];
    string $targetPlug = $node + "." + $targetAttr;

	// Since the *Achieved attr is now dirty from the termination attr change,
	// querying the value at this point would trigger an evaluation with the old
	// target value. The attr connected controls are not a valid source either
	// as they will also pull from the attribute.
	//
	// As a result we pull from our cached termination results. See
	// AEpolyReduceRecordTermResults for more details.
	//
	// Additionally, only update term input when requested. There are times where
	// we only want to update the UI and not the inputs.
	if( $updateTermInput )
	{
		float $percentage = `floatField -q -v $percentageControl`;
		int $vertexCount = `intField -q -v $vertexControl`;
		int $triangleCount = `intField -q -v $triangleControl`;
		switch( $termType )
		{
		case 0:	// Percentage
			if( `getAttr $targetPlug` != $percentage ) {
				setAttr $targetPlug $percentage;
			}
			break;
		case 1:	// VertexCount
			if( `getAttr $targetPlug` != $vertexCount ) {
				setAttr $targetPlug $vertexCount;
			}
			break;
		case 2:	// TriangleCount
			if( `getAttr $targetPlug` != $triangleCount ) {
				setAttr $targetPlug $triangleCount;
			}
			break;
		}
	}

    // Refresh all the termination UI fields since they may be
    // enabled/disabled and may switch what attribute they're actually
    // listening to.
    for($i = 0; $i < size($AEpolyReduceTerminationTypeNames); ++$i) {
        AEpolyReduceTermField
			$parentLayout
            ($node + "." + $AEpolyReduceTerminationTypeNames[$i])
            "";
    }

	// Record current termination results.
	AEpolyReduceRecordTermResults( $parentLayout, $terminationPlug );
}

global proc AEpolyReduceTermUIChanged( string $parentLayout, string $terminationPlug, int $updateTermInput )
//
// This callback is intended to be invoked when the termination UI changes.
//
{
	string $versionControl = $parentLayout + "|AEpolyReduceVersionLayout|AEpolyReduceVersionField";
	string $nodeAttr = `attrControlGrp -q -a $versionControl`;
	int $version = `getAttr $nodeAttr`;
	if ($version == 1) { // Softimage
		string $termControl = $parentLayout + "|AEpolyReduceSoftimageLayout|AEpolyReduceTerminationConditions|AEpolyReduceTerminationField";

	    int $termType = `optionMenuGrp -q -sl $termControl` - 1;
	
		// Update termination attr value
		if( `getAttr $terminationPlug` != $termType )
		{
			setAttr $terminationPlug $termType;
		}
	
		// Update termination condition UI
		AEpolyReduceTerminationChanged( $parentLayout, $terminationPlug, $updateTermInput );
	}
}

global proc AEpolyReduceTermAttrChanged( string $parentLayout, string $terminationPlug, int $updateTermInput )
//
// This callback is intended to be invoked when the termination attribute changes.
//
{
	string $versionControl = $parentLayout + "|AEpolyReduceVersionLayout|AEpolyReduceVersionField";
	string $nodeAttr = `attrControlGrp -q -a $versionControl`;
	int $version = `getAttr $nodeAttr`;
	if ($version == 1) { // Softimage
		string $termControl = $parentLayout + "|AEpolyReduceSoftimageLayout|AEpolyReduceTerminationConditions|AEpolyReduceTerminationField";
	
		string $node = `plugNode $terminationPlug`;
	    int $termType = AEpolyReduceTermType( $node );
	
		// Update termination attr UI
		if( `optionMenuGrp -q -sl $termControl` != ($termType + 1) )
		{
			optionMenuGrp -e -sl ($termType + 1) $termControl;
		}
	
		// Update termination condition UI
		AEpolyReduceTerminationChanged( $parentLayout, $terminationPlug, $updateTermInput );
	}
}

global proc AEpolyReduceRecordTermResults( string $parentLayout, string $terminationPlug )
//
// This method records the current Termination Results. This is to facilitate
// seamless transitions between termination conditions. That is, the result of
// the last reduce will remain the same when switching to a new termination
// condition.
//
// This method is intended to only be invoked when the *Achieved attributes
// change.
//
// We must record these here due to the timing of the termination condition
// callback occurring after the termination condition had already changed.
// After the termination condition has changed all outputs would be dirtied
// and any requests from the attribute or UI (connected to attr) would trigger
// an evaluation with the "stale" input values.
//
// We store the values in hidden floatField/intField UI controls.
//
{
	string $percentageControl = $parentLayout + "|AEpolyReduceSoftimageLayout|AEpolyReducePercentageAchievedField";
	string $vertexControl = $parentLayout + "|AEpolyReduceSoftimageLayout|AEpolyReduceVertexCountAchievedField";
	string $triangleControl = $parentLayout + "|AEpolyReduceSoftimageLayout|AEpolyReduceTriangleCountAchievedField";

	string $node = `plugNode $terminationPlug`;

	float $percentage = `getAttr ($node + ".percentageAchieved")`;
	int $vertexCount = `getAttr ($node + ".vertexCountAchieved")`;
	int $triangleCount = `getAttr ($node + ".triangleCountAchieved")`;

	floatField -e -v $percentage $percentageControl;
	intField -e -v $vertexCount $vertexControl;
	intField -e -v $triangleCount $triangleControl;
}

global proc AEpolyReduceTermField( string $parentLayout,
								  string $plug,
								  string $label )
//
// This method creates a new control or replaces an existing control
// for a termination field (percentage, vertex count, or triangle count).
// Pass in an empty-string label to get replace behaviour.
//
{
    string $node = `plugNode $plug`;
	string $attr = `plugAttr $plug`;
    int $currentTermType = `AEpolyReduceTermType $node`;
    int $thisTermType    = `AEpolyReduceTermTypeFromAttr $attr`;

    // If this is the active termination field, print the target.
    // Otherwise print the achieved amount, disabled.
    if ($thisTermType != $currentTermType) {
        $plug = $plug + "Achieved";
    }

	// Record the old parent and set the parent. This must be done
	// as this method can be called from a callback as well. The code
	// below is dependent on an appropriately set UI parent.
	string $oldParent = `setParent -q`;
	setParent ($parentLayout + "|AEpolyReduceSoftimageLayout|AEpolyReduceTerminationConditions");

	string $control = "";
    if( $label != "" ) {
        // Create a new slider
        $control = `attrFieldSliderGrp
            -l $label
            -vis ($thisTermType == $currentTermType)
            -at $plug
            ("AEpolyReduce" + $attr + "Field")`;
    } else {
        // Update an existing slider
        $control = `attrFieldSliderGrp
            -e
            -vis ($thisTermType == $currentTermType)
            -at $plug
            ("AEpolyReduce" + $attr + "Field")`;
    }

	// Restore the old parent
	setParent $oldParent;

	// Use scriptJobs with -p and -rp rather than the attr*Grp -cc flag. The
	// attr*Grp -cc flag does not support " marks in the script string in
	// Maya 2012.
	//
	// [lilo, Jan 2012]
	//
	string $cmd = "AEpolyReduceRecordTermResults(\"" + $parentLayout + "\",\"" + $plug + "\" )";
	scriptJob -p $control -rp -ac $plug $cmd;
}

global proc AEpolyReduceHistoryNew( string $versionPlug,
								   string $terminationPlug,
								   string $percentagePlug,
								   string $vertexCountPlug,
								   string $triangleCountPlug,
								   string $keepQuadsPlug,
								   string $compactnessPlug,
								   string $triangulatePlug,
								   string $cachingReducePlug,
								   string $uvWeightsPlug,
								   string $colorWeightsPlug,
                                   string $vertexWeightCoefficientPlug,
                                   string $invertVertexWeightPlug,
                                   string $sharpnessPlug,
                                   string $useVirtualSymmetryPlug,
                                   string $symmetryTolerancePlug,
                                   string $symmetryPlanePlug,
                                   string $keepBorderPlug,
                                   string $keepBorderWeightPlug,
                                   string $keepMapBorderPlug,
                                   string $keepMapBorderWeightPlug,
                                   string $keepColorBorderPlug,
                                   string $keepColorBorderWeightPlug,
                                   string $keepFaceGroupBorderPlug,
                                   string $keepFaceGroupBorderWeightPlug,
                                   string $keepHardEdgePlug,
                                   string $keepHardEdgeWeightPlug,
                                   string $keepCreaseEdgePlug,
                                   string $keepCreaseEdgeWeightPlug,
                                   string $keepOriginalVerticesPlug,
								   string $vertexMapNamePlug,
								   string $legacyBorderPlug,
								   string $legacyLinePlug,
                                   string $legacyDetailPlug
								   )
//
// This callback is invoked on first instantiation of the AEpolyReduceTemplate.
// This method will create all the UI for the first time and bind it to the
// requested node.
//
{
	string $node = `plugNode $versionPlug`;

	setUITemplate -pst attributeEditorTemplate;

	string $parentLayout = `setParent -q`;

	// Create shared version UI.
	columnLayout AEpolyReduceVersionLayout;
        string $versionCmd = "AEpolyReduceVersionChanged( \"" + $parentLayout + "\" )";
        string $versionControl = `attrEnumOptionMenuGrp -l (uiRes("m_AEpolyReduceTemplate.kVersion")) -at $versionPlug AEpolyReduceVersionField`;

        // Use scriptJobs with -p and -rp rather than the attr*Grp -cc flag. The
        // attr*Grp -cc flag does not support " marks in the script string in
        // Maya 2012.
        //
        // [lilo, Jan 2012]
        //
        scriptJob -p $versionControl -rp -ac $versionPlug $versionCmd;
	setParent ..;

	// Create all UI elements for the Softimage algorithm.
	columnLayout -adj 1 AEpolyReduceSoftimageLayout;
        //
        // Termination options
        //
        frameLayout
            -l (uiRes("m_AEpolyReduceTemplate.kTerminationConditions"))
            -collapsable 1
            -collapse 0
            AEpolyReduceTerminationConditions;

 	        string $termUICmd = "AEpolyReduceTermUIChanged( \"" + $parentLayout + "\",\"" + $terminationPlug + "\", 1 )";
	        string $termAttrCmd = "AEpolyReduceTermAttrChanged( \"" + $parentLayout + "\",\"" + $terminationPlug + "\", 1 )";
	        string $termControl = `optionMenuGrp -l (uiRes("m_AEpolyReduceTemplate.kTermination")) -cc $termUICmd AEpolyReduceTerminationField`;
	        menuItem -l (uiRes("m_AEpolyReduceTemplate.kPercentage")) -da 0;
	        menuItem -l (uiRes("m_AEpolyReduceTemplate.kVertexCount")) -da 1;
	        menuItem -l (uiRes("m_AEpolyReduceTemplate.kTriangleCount")) -da 2;
	        scriptJob -p $termControl -rp -ac $terminationPlug $termAttrCmd;

	        AEpolyReduceTermField( $parentLayout, $percentagePlug, (uiRes("m_AEpolyReduceTemplate.kReduceByPercent")) );
	        AEpolyReduceTermField( $parentLayout, $vertexCountPlug, (uiRes("m_AEpolyReduceTemplate.kReduceVertexCount")) );
	        AEpolyReduceTermField( $parentLayout, $triangleCountPlug, (uiRes("m_AEpolyReduceTemplate.kReduceTriangleCount")) );
        setParent ..;


        //
        // Shape
        //
        frameLayout
            -l (uiRes("m_AEpolyReduceTemplate.kShape"))
            -collapsable 1
            -collapse 0
            AEpolyReduceShapeOptions;

            attrFieldSliderGrp
                -l (uiRes("m_AEpolyReduceTemplate.kPreserveQuadLines"))
                -at $keepQuadsPlug AEpolyReduceKeepQuadsField;
	        string $updateSymmetryCmd = "AEpolyReduceUpdateSymmetry( \"" + $parentLayout + "\" )";
			scriptJob -p ($parentLayout + "|AEpolyReduceKeepQuadsField") -rp -ac $keepQuadsPlug $updateSymmetryCmd;

            attrFieldSliderGrp -l (uiRes("m_AEpolyReduceTemplate.kSharpness"))
                -at $sharpnessPlug -sliderMinValue 0 -sliderMaxValue 1
                AEpolyReduceSharpness;

            attrFieldSliderGrp
                -l (uiRes("m_AEpolyReduceTemplate.kVertexWeightCoefficient"))
                -at $vertexWeightCoefficientPlug -min 0 -max 1
                AEpolyReduceVertexWeightCoefficientField;
            attrControlGrp -l (uiRes("m_AEpolyReduceTemplate.kInvertVertexWeights"))
                -a $invertVertexWeightPlug AEpolyReduceInvertVertexWeightMap;

            // Symmetry goes last so the framelayout for the plane doesn't break the
            // visual flow.
            attrEnumOptionMenuGrp -l (uiRes("m_AEpolyReduceTemplate.kUseVirtualSymmetry"))
                -at $useVirtualSymmetryPlug AEpolyReduceSymmetryType;
			scriptJob -p ($parentLayout + "|AEpolyReduceSymmetryType") -rp -ac $useVirtualSymmetryPlug $updateSymmetryCmd;

            attrFieldSliderGrp -l (uiRes("m_AEpolyReduceTemplate.kSymmetryTolerance"))
                -at $symmetryTolerancePlug AEpolyReduceSymmetryTolerance;

            attrFloatField4Grp
                (uiRes("m_AEpolyReduceTemplate.kSymmetryPlane"))
				($node + ".sx") ($node + ".sy") ($node + ".sz") ($node + ".sw")
                AEpolyReduceSymmetryPlane;

			rowLayout -nc 2 -adj 2 AEpolyReduceSymmetryHint;
				text -l "";
				text -al left -l (uiRes("m_AEpolyReduceTemplate.kSymmetryHint"));
			setParent ..;
        setParent ..;

        //
        // Preservation options
        //
        frameLayout
            -l (uiRes("m_AEpolyReduceTemplate.kFeaturePreservation"))
            -collapsable 1
            -collapse 0
            AEPolyReduceFeaturePreservationOptions;

            // kSoft because this is the Softimage-based algorithm and the
            // labels are different from the Maya algorithm.
            attrCheckBoxSliderGrp
                (uiRes("m_AEpolyReduceTemplate.kSoftPreserveMeshBorders"))
                $keepBorderPlug
                $keepBorderWeightPlug
                AEpolyReduceKeepBorder;
            attrCheckBoxSliderGrp
                (uiRes("m_AEpolyReduceTemplate.kSoftPreserveUVBorders"))
                $keepMapBorderPlug
                $keepMapBorderWeightPlug
                AEpolyReduceKeepMapBorder;
            attrCheckBoxSliderGrp
                (uiRes("m_AEpolyReduceTemplate.kSoftPreserveColorBorders"))
                $keepColorBorderPlug
                $keepColorBorderWeightPlug
                AEpolyReduceKeepColorBorder;
            attrCheckBoxSliderGrp
                (uiRes("m_AEpolyReduceTemplate.kSoftPreserveGroupBorders"))
                $keepFaceGroupBorderPlug
                $keepFaceGroupBorderWeightPlug
                AEpolyReduceKeepGroupBorder;
            attrCheckBoxSliderGrp
                (uiRes("m_AEpolyReduceTemplate.kSoftPreserveHardEdges"))
                $keepHardEdgePlug
                $keepHardEdgeWeightPlug
                AEpolyReduceKeepHardEdge;
            attrCheckBoxSliderGrp
                (uiRes("m_AEpolyReduceTemplate.kSoftPreserveCreaseEdges"))
                $keepCreaseEdgePlug
                $keepCreaseEdgeWeightPlug
                AEpolyReduceKeepCreaseEdge;
        setParent ..;

        frameLayout
            -l (uiRes("m_AEpolyReduceTemplate.kAdvancedOptions"))
            -collapsable 1
            -collapse 0
            AEpolyReduceAdvancedOptions;

            attrStringControlGrp (uiRes("m_AEpolyReduceTemplate.kVertexMapName"))
                $vertexMapNamePlug AEpolyReduceVertexMapName;
        setParent ..;

        // We don't give a control for the reduction cache for the
        // Softimage algorithm; Softimage doesn't, and the cache is
        // relatively small anyway so there's not much point in turning it
        // off.

        // Hidden data storage for AEpolyReduceRecordTermResults.
        floatField -min 0.0 -max 100.0 -pre 6 -vis 0 -en 0 AEpolyReducePercentageAchievedField;
        intField -min 0 -vis 0 -en 0 AEpolyReduceVertexCountAchievedField;
        intField -min 0 -vis 0 -en 0 AEpolyReduceTriangleCountAchievedField;
	setParent ..;

	// Create all UI elements for Maya version.
	columnLayout -adj 1 AEpolyReduceMayaLayout;
        // Percentage attribute is shared between Maya/Softimage versions.
        attrFieldSliderGrp -l (uiRes("m_AEpolyReduceTemplate.kReduceByPercent")) -at $percentagePlug -min 0.0 -max 100.0 AEpolyReduceMayaPercentageField;
        attrFieldSliderGrp -l (uiRes("m_AEpolyReduceTemplate.kTrianglePenaltyWeight"))
            -at $keepQuadsPlug AEpolyReduceKeepQuadsField;
        attrFieldSliderGrp -l (uiRes("m_AEpolyReduceTemplate.kTriangleCompactness")) -at $compactnessPlug AEpolyReduceCompactnessField;

        string $triCmd = "AEpolyReduceTriangulateChanged( \"" + $parentLayout + "\" )";
        string $triControl = `attrControlGrp -l (uiRes("m_AEpolyReduceTemplate.kTriangulate")) -a $triangulatePlug AEpolyReduceTriangulateField`;

        // Use scriptJobs with -p and -rp rather than the attr*Grp -cc flag. The
        // attr*Grp -cc flag does not support " marks in the script string in
        // Maya 2012.
        //
        // [lilo, Jan 2012]
        //
        scriptJob -p $triControl -rp -ac $triangulatePlug $triCmd;

		attrControlGrp -l (uiRes("m_AEpolyReduceTemplate.kCacheReduction")) -a $cachingReducePlug AEpolyReduceCachingReduceField;
        attrControlGrp -l (uiRes("m_AEpolyReduceTemplate.kUVsWeight")) -a $uvWeightsPlug AEpolyReduceUVWeightsField;
        attrControlGrp -l (uiRes("m_AEpolyReduceTemplate.kVertexColorsWeight")) -a $colorWeightsPlug AEpolyReduceColorWeightsField;


        attrControlGrp -l (uiRes("m_AEpolyReduceTemplate.kPreserveMeshBorders"))
            -a $keepBorderPlug AEpolyReduceKeepBorder;
        attrControlGrp -l (uiRes("m_AEpolyReduceTemplate.kPreserveUVBorders"))
            -a $keepMapBorderPlug AEpolyReduceKeepMapBorder;
        attrControlGrp -l (uiRes("m_AEpolyReduceTemplate.kPreserveHardEdges"))
            -a $keepHardEdgePlug AEpolyReduceKeepHardEdge;
        attrControlGrp -l (uiRes("m_AEpolyReduceTemplate.kPreserveOriginalVertices"))
            -a $keepOriginalVerticesPlug AEpolyReduceKeepOriginalVertices;

        frameLayout
            -l (uiRes("m_AEpolyReduceTemplate.kLegacyAttributes"))
            -collapsable 1
            -collapse 1
            legacyOptions;

            attrFieldSliderGrp -l (uiRes("m_AEpolyReduceTemplate.kLegacyBorder"))
                -at $legacyBorderPlug -sliderMinValue 0 -sliderMaxValue 1
                AEpolyReduceLegacyBorder;

            attrFieldSliderGrp -l (uiRes("m_AEpolyReduceTemplate.kLegacyLine"))
                -at $legacyLinePlug -sliderMinValue 0 -sliderMaxValue 1
                AEpolyReduceLegacyLine;

            attrFieldSliderGrp -l (uiRes("m_AEpolyReduceTemplate.kLegacyDetail"))
                -at $legacyDetailPlug -sliderMinValue 0 -sliderMaxValue 1
                AEpolyReduceLegacyDetail;
        setParent ..;
	setParent ..;

	// Update the UI states.
	AEpolyReduceVersionChanged( $parentLayout );
	AEpolyReduceUpdateSymmetry( $parentLayout );
	AEpolyReduceRecordTermResults( $parentLayout, $terminationPlug );
	AEpolyReduceTermAttrChanged( $parentLayout, $terminationPlug, 0 );
	AEpolyReduceTriangulateChanged( $parentLayout );

	setUITemplate -ppt;
}

global proc AEpolyReduceHistoryReplace( string $versionPlug,
										string $terminationPlug,
										string $percentagePlug,
										string $vertexCountPlug,
										string $triangleCountPlug,
										string $keepQuadsPlug,
										string $compactnessPlug,
										string $triangulatePlug,
										string $cachingReducePlug,
										string $uvWeightsPlug,
										string $colorWeightsPlug,
                                        string $vertexWeightCoefficientPlug,
                                        string $invertVertexWeightPlug,
                                        string $sharpnessPlug,
                                        string $useVirtualSymmetryPlug,
                                        string $symmetryTolerancePlug,
                                        string $symmetryPlanePlug,
                                        string $keepBorderPlug,
                                        string $keepBorderWeightPlug,
                                        string $keepMapBorderPlug,
                                        string $keepMapBorderWeightPlug,
                                        string $keepColorBorderPlug,
                                        string $keepColorBorderWeightPlug,
                                        string $keepFaceGroupBorderPlug,
                                        string $keepFaceGroupBorderWeightPlug,
                                        string $keepHardEdgePlug,
                                        string $keepHardEdgeWeightPlug,
                                        string $keepCreaseEdgePlug,
                                        string $keepCreaseEdgeWeightPlug,
                                        string $keepOriginalVerticesPlug,
                                        string $vertexMapNamePlug,
										string $legacyBorderPlug,
										string $legacyLinePlug,
										string $legacyDetailPlug
										)
//
// This callback is invoked on subsequent invocations of the AEpolyReduceTemplate.
// It is called to attach the template to a new node. This method will reattach
// the existing UI created in the "New" callback to the new node.
//
{
	string $node = `plugNode $versionPlug`;
	string $percentageAttr = `plugAttr $percentagePlug`;
	string $vertexCountAttr = `plugAttr $vertexCountPlug`;
	string $triangleCountAttr = `plugAttr $triangleCountPlug`;

	string $parentLayout = `setParent -q`;

	// Update version UI to new nodeAttr.
	setParent AEpolyReduceVersionLayout;
	string $versionControl = $parentLayout + "|AEpolyReduceVersionLayout|AEpolyReduceVersionField";
	string $versionCmd = "AEpolyReduceVersionChanged(\"" + $parentLayout + "\")";
	attrEnumOptionMenuGrp -e -at $versionPlug $versionControl;
	scriptJob -p $versionControl -rp -ac $versionPlug $versionCmd;
	setParent ..;

	// Update Softimage version UI.
	setParent AEpolyReduceSoftimageLayout;
        setParent AEpolyReduceTerminationConditions;
            string $termUICmd =
                "AEpolyReduceTermUIChanged( \""
                    + $parentLayout + "\",\""
                    + $terminationPlug + "\", 1 )";
            string $termAttrCmd =
                "AEpolyReduceTermAttrChanged( \""
                    + $parentLayout + "\",\""
                    + $terminationPlug + "\", 1 )";
            string $termControl = $parentLayout + "|AEpolyReduceSoftimageLayout|AEpolyReduceTerminationConditions|AEpolyReduceTerminationField";
            optionMenuGrp -e -cc $termUICmd $termControl;
            connectControl -index 2 $termControl $terminationPlug;
            scriptJob -p $termControl -rp -ac $terminationPlug $termAttrCmd;

            AEpolyReduceTermField( $parentLayout, $percentagePlug, "" );
            AEpolyReduceTermField( $parentLayout, $vertexCountPlug, "" );
            AEpolyReduceTermField( $parentLayout, $triangleCountPlug, "" );
        setParent ..;

        setParent AEpolyReduceShapeOptions;
            attrFieldSliderGrp -e -at $keepQuadsPlug
                AEpolyReduceKeepQuadsField;
            attrFieldSliderGrp -e -at $sharpnessPlug
                AEpolyReduceSharpness;

            attrEnumOptionMenuGrp -e -at $useVirtualSymmetryPlug AEpolyReduceSymmetryType;
            attrFieldSliderGrp -e -at $symmetryTolerancePlug AEpolyReduceSymmetryTolerance;

            attrFloatField4GrpEdit
				($node + ".sx") ($node + ".sy") ($node + ".sz") ($node + ".sw")
                AEpolyReduceSymmetryPlane;

            attrFieldSliderGrp -e -at $vertexWeightCoefficientPlug
                AEpolyReduceVertexWeightCoefficientField;
            attrControlGrp -e -a $invertVertexWeightPlug
                AEpolyReduceInvertVertexWeightMap;
        setParent ..;

        setParent AEPolyReduceFeaturePreservationOptions;
            attrCheckBoxSliderGrpEdit
                $keepBorderPlug
                $keepBorderWeightPlug
                AEpolyReduceKeepBorder;
            attrCheckBoxSliderGrpEdit
                $keepMapBorderPlug
                $keepMapBorderWeightPlug
                AEpolyReduceKeepMapBorder;
            attrCheckBoxSliderGrpEdit
                $keepColorBorderPlug
                $keepColorBorderWeightPlug
                AEpolyReduceKeepColorBorder;
            attrCheckBoxSliderGrpEdit
                $keepFaceGroupBorderPlug
                $keepFaceGroupBorderWeightPlug
                AEpolyReduceKeepGroupBorder;
            attrCheckBoxSliderGrpEdit
                $keepHardEdgePlug
                $keepHardEdgeWeightPlug
                AEpolyReduceKeepHardEdge;
            attrCheckBoxSliderGrpEdit
                $keepCreaseEdgePlug
                $keepCreaseEdgeWeightPlug
                AEpolyReduceKeepCreaseEdge;
        setParent ..;

        setParent AEpolyReduceAdvancedOptions;
            attrStringControlGrp ""
                $vertexMapNamePlug AEpolyReduceVertexMapName;
        setParent ..;
	setParent ..;

	// Update Maya version UI.
	setParent AEpolyReduceMayaLayout;
        attrFieldSliderGrp -e -at $percentagePlug AEpolyReduceMayaPercentageField;
        attrFieldSliderGrp -e -at $keepQuadsPlug AEpolyReduceKeepQuadsField;
        attrFieldSliderGrp -e -at $compactnessPlug AEpolyReduceCompactnessField;

        string $triControl = $parentLayout + "|AEpolyReduceMayaLayout|AEpolyReduceTriangulateField";
        string $triCmd = "AEpolyReduceTriangulateChanged(\"" + $parentLayout + "\")";
        attrControlGrp -e -a $triangulatePlug $triControl;
        scriptJob -p $triControl -rp -ac $triangulatePlug $triCmd;

        attrControlGrp -e -a $cachingReducePlug AEpolyReduceCachingReduceField;
        attrControlGrp -e -a $uvWeightsPlug AEpolyReduceUVWeightsField;
        attrControlGrp -e -a $colorWeightsPlug AEpolyReduceColorWeightsField;

        attrControlGrp -e -a $keepBorderPlug AEpolyReduceKeepBorder;
        attrControlGrp -e -a $keepMapBorderPlug AEpolyReduceKeepMapBorder;
        attrControlGrp -e -a $keepHardEdgePlug AEpolyReduceKeepHardEdge;
        attrControlGrp -e -a $keepOriginalVerticesPlug AEpolyReduceKeepOriginalVertices;

        setParent legacyOptions;
        	attrControlGrp -e -a $legacyBorderPlug AEpolyReduceLegacyBorder;
        	attrControlGrp -e -a $legacyLinePlug AEpolyReduceLegacyLine;
        	attrControlGrp -e -a $legacyDetailPlug AEpolyReduceLegacyDetail;
		setParent ..;
	setParent ..;

	// Update the UI states.
	AEpolyReduceVersionChanged( $parentLayout );
	AEpolyReduceUpdateSymmetry( $parentLayout );
	AEpolyReduceRecordTermResults( $parentLayout, $terminationPlug );
	AEpolyReduceTermAttrChanged( $parentLayout, $terminationPlug, 0 );
	AEpolyReduceTriangulateChanged( $parentLayout );
}

global proc AEpolyReduceTemplate ( string $node )
{
	editorTemplate -beginScrollLayout;
		editorTemplate -beginLayout (uiRes("m_AEpolyReduceTemplate.kPolyReduceHistory")) -collapse 0;

            // Custom template for the different algorithms of this node:
            // (Maya, Softimage).
			//
            // Each version will display its own set of relevant attributes. As
            // a result, we add the full set of attributes that are version
            // dependent to this callCustom procedure.
			//
			editorTemplate -callCustom "AEpolyReduceHistoryNew" "AEpolyReduceHistoryReplace"
				"version"
				"termination"
				"percentage"
				"vertexCount"
				"triangleCount"
				"keepQuadsWeight"
				"compactness"
				"triangulate"
				"cachingReduce"
				"uvWeights"
				"colorWeights"
                "vertexWeightCoefficient"
                "invertVertexWeights"
                "sharpness"
                "useVirtualSymmetry"    "symmetryTolerance" "symmetryPlane"
				"keepBorder"            "keepBorderWeight"
				"keepMapBorder"         "keepMapBorderWeight"
				"keepColorBorder"       "keepColorBorderWeight"
				"keepFaceGroupBorder"   "keepFaceGroupBorderWeight"
				"keepHardEdge"          "keepHardEdgeWeight"
				"keepCreaseEdge"        "keepCreaseEdgeWeight"
                "keepOriginalVertices"
                "vertexMapName"
				"border" "line" "detail"
            ;

			editorTemplate -suppress "vertexCountIn";
			editorTemplate -suppress "triangleCountIn";
			editorTemplate -suppress "vertexCountAchieved";
			editorTemplate -suppress "triangleCountAchieved";

		editorTemplate -endLayout;

		editorTemplate -suppress "geomWeights";
		editorTemplate -suppress "vertexWeights";
		editorTemplate -suppress "weights";
		editorTemplate -suppress "weightCoefficient";
		editorTemplate -suppress "preserveTopology";

		// include/call base class/node attributes
		AEpolyModifierInclude $node;

	editorTemplate -addExtraControls;
	editorTemplate -endScrollLayout;
}
