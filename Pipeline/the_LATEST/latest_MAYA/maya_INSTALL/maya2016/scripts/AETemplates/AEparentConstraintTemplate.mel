// Copyright (C) 1997-2014 Autodesk, Inc., and/or its licensors.
// All rights reserved.
//
// The coded instructions, statements, computer programs, and/or related
// material (collectively the "Data") in these files contain unpublished
// information proprietary to Autodesk, Inc. ("Autodesk") and/or its licensors,
// which is protected by U.S. and Canadian federal copyright law and by
// international treaties.
//
// The Data is provided for use exclusively by You. You have the right to use,
// modify, and incorporate this Data into other products for purposes authorized 
// by the Autodesk software license agreement, without fee.
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND. AUTODESK
// DOES NOT MAKE AND HEREBY DISCLAIMS ANY EXPRESS OR IMPLIED WARRANTIES
// INCLUDING, BUT NOT LIMITED TO, THE WARRANTIES OF NON-INFRINGEMENT,
// MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE, OR ARISING FROM A COURSE 
// OF DEALING, USAGE, OR TRADE PRACTICE. IN NO EVENT WILL AUTODESK AND/OR ITS
// LICENSORS BE LIABLE FOR ANY LOST REVENUES, DATA, OR PROFITS, OR SPECIAL,
// DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES, EVEN IF AUTODESK AND/OR ITS
// LICENSORS HAS BEEN ADVISED OF THE POSSIBILITY OR PROBABILITY OF SUCH DAMAGES.

//
//  Procedure Name:
//	AEparentConstraintTemplate
//
//  Description Name;
//	Creates the attribute editor controls for the parentConstraint Node
//
//  Input Value:
//	nodeName 
//
//  Output Value:
//	None
//
global proc int parentConstraintTargetIndex( string $parentConstraint, string $target)
{
	string $conns[] = `listConnections -p 1 -s 0 -d 1 -type parentConstraint $target`;
	string $buffer[];
	tokenize($conns[0],"[",$buffer);
	if (size($buffer) > 0) {
		string $buffer2[];
		tokenize($buffer[1],"]",$buffer2);
		int $pIndex = $buffer2[0];
		return $pIndex;
	}
	return 0;
}

global proc AEparentConstraintNew( string $target )
{
	string $buffer[];
	tokenize($target, ".", $buffer);
	string $nodeName = $buffer[0];

	setUITemplate -pst attributeEditorTemplate;
	columnLayout ("targetOffsetColumn");

	string $tgts[]=`parentConstraint -q -targetList $nodeName`;
	for ($i=0; $i < size($tgts); $i++)
	{
		// the target name
		//
		rowLayout -nc 2 ("rcOffset"+$i);
		text -fn "boldLabelFont" -label ($tgts[$i]) ("pcOffset"+$i);
 		text -label "" ("emptyText"+$i);
		setParent ..;

		// the translate offset for the target
		//
		$fieldLabel = $tgts[$i]+" Translate";
		$fieldName = "OffsetT"+$i;
		attrFieldGrp -label $fieldLabel $fieldName;

		// the rotate offset for the target
		//
		$fieldLabel = $tgts[$i]+" Rotate";
		$fieldName = "OffsetR"+$i;
		attrFieldGrp -label $fieldLabel $fieldName;
	}

	setParent ..;

	columnLayout ("updateAndKeyOffsetColumn");
	text -label "";		
	rowLayout -nc 5;
		text -label "";	
		button -annotation (uiRes("m_AEparentConstraintTemplate.kUpdateOffsetAnnot"))
			-label (uiRes("m_AEparentConstraintTemplate.kUpdateOffset"))  updateOffsetButton;
		text -label "";
		button -annotation (uiRes("m_AEparentConstraintTemplate.kKeyOffsetAnnot"))
			-label (uiRes("m_AEparentConstraintTemplate.kKeyOffset"))  keyOffsetButton;
		text -label "";
	setParent ..;

	setUITemplate -ppt;
	AEparentConstraintReplace $target;
}

global proc AEparentConstraintReplace ( string $target )
{
	string $buffer[];
	tokenize($target, ".", $buffer);
	string $nodeName = $buffer[0];

	setUITemplate -pst attributeEditorTemplate;

	setParent "targetOffsetColumn";
	$layoutName=`setParent -q`;

	int $i;
	int $oldCount=`columnLayout -q -nch $layoutName`;
	string $tgts[]=`parentConstraint -q -targetList $nodeName`;
	string $keyRotateCmd = "setKeyframe -ott flat ";
	string $keyTranslateCmd = "setKeyframe -ott flat ";
	string $maintainOffsetCmd = "parentConstraint -e -maintainOffset ";
	for ($i=0; $i < size($tgts); $i++)
	{
		int $pcIndex = parentConstraintTargetIndex($nodeName,$tgts[$i]);

		if (`text -exists ("pcOffset"+$i)`) {
			// if the UI for this index exists already, just modify it
			// to point at the current target
			//
			text -edit -label $tgts[$i] ("pcOffset"+$i);
		} else {
			rowLayout -nc 2 ("rcOffset"+$i);
			text -fn "boldLabelFont" -label ($tgts[$i]) ("pcOffset"+$i);
			text -label "" ("emptyText"+$i);
			setParent ..;
		}

		string $attrT=($nodeName+".tg["+$pcIndex+"].targetOffsetTranslate");
		string $attrR=($nodeName+".tg["+$pcIndex+"].targetOffsetRotate");

		// attach command callbacks to the buttons
		//
		$maintainOffsetCmd += ($tgts[$i]+" ");
		$keyTranslateCmd += ($attrT+" ");
		$keyRotateCmd += ($attrR+" ");		

		// attach the translate offset control to the attribute
		//
		$fieldLabel = (uiRes("m_AEparentConstraintTemplate.kTranslate"));
		$fieldName = "OffsetT"+$i;
		if ( `attrFieldGrp -ex $fieldName` )
		{
			attrFieldGrp -e -label $fieldLabel -at $attrT $fieldName;
		} else {
			setUITemplate -pst attributeEditorTemplate;
			attrFieldGrp -label $fieldLabel -at $attrT $fieldName;
			setUITemplate -ppt;
		}

		// attach the rotate offset control to the attribute
		//
		$fieldLabel = (uiRes("m_AEparentConstraintTemplate.kRotate"));
		$fieldName = "OffsetR"+$i;
		if ( `attrFieldGrp -ex $fieldName` )
		{
			attrFieldGrp -e -label $fieldLabel -at $attrR $fieldName;
		} else {
			setUITemplate -pst attributeEditorTemplate;
			attrFieldGrp -label $fieldLabel -at $attrR $fieldName;
			setUITemplate -ppt;
		}
	}

	$maintainOffsetCmd += (" "+$nodeName);
	button -e -c ("evalEcho(\""+$keyRotateCmd+"; "+$keyTranslateCmd+"\")") keyOffsetButton;
	button -e -c ("evalEcho(\""+$maintainOffsetCmd+"\")") updateOffsetButton;
	
	for ($i=size($tgts); $i < $oldCount; $i++)
	{
		// delete excess UI (the previously loaded constraint had more targets)
		//
		if (`text -exists ("pcOffset"+$i)`) {
			deleteUI ("pcOffset"+$i);
		}
		if (`text -exists ("emptyText"+$i)`) {
			deleteUI ("emptyText"+$i);
		}
		if (`rowLayout -exists ("rcOffset"+$i)`) {
			deleteUI ("rcOffset"+$i);
		}
		$fieldName = "OffsetT"+$i;
		if ( `attrFieldGrp -ex $fieldName` )
			deleteUI $fieldName;
		$fieldName = "OffsetR"+$i;
		if ( `attrFieldGrp -ex $fieldName` )
			deleteUI $fieldName;
	}
	
	setParent ..;
	setUITemplate -ppt;
}	


global proc AEparentCheckInterpType(string $nodeName)
{
	string $cacheExists[] = `listConnections ($nodeName+".interpCache")`;
	if (`button -exists deleteCacheButton`) {
		int $enableDeleteCache = (size($cacheExists) > 0);
		button -e -en $enableDeleteCache deleteCacheButton;
	}

	if (`button -exists createCacheButton`) {	
		// interpType is an enum, and interpType == 4 is "cache"
		//
		int $interpType = `getAttr ($nodeName+".interpType")`;
		int $enableCreateCache = (($interpType == 4) && (size($cacheExists) == 0) ||
								  ($interpType == 0));
		button -e -en $enableCreateCache createCacheButton;
	}
}

global proc AEparentCacheReplace(string $plug)
{
	string $buff[];
	tokenize($plug,".",$buff);
	string $nodeName = $buff[0];

	if (`button -exists deleteCacheButton`) {
		button -e -c ("evalEcho \"parentConstraint -e -dc "+$nodeName+"\"; "+
					  "button -e -en false deleteCacheButton; " +
					  "button -e -en true createCacheButton") deleteCacheButton;
	}

	if (`button -exists createCacheButton`) {
		float $rangeStart = `playbackOptions -q -min`;
		float $rangeEnd   = `playbackOptions -q -max`;
		button -e -c ("evalEcho \"parentConstraint -e -cc "+
					  $rangeStart+" "+$rangeEnd+" "+$nodeName+"\"; "+
					  "button -e -en true deleteCacheButton") createCacheButton;
	}
}

global proc AEparentCacheNew(string $plug)
{
	setUITemplate -pst attributeEditorTemplate;
		
 		columnLayout cachectlColumn;
 		rowLayout -nc 5 deleteCacheLayout;
 		text -label (uiRes("m_AEparentConstraintTemplate.kCache")) ;
		button -label (uiRes("m_AEparentConstraintTemplate.kCreate"))  createCacheButton;
 		text -label "";
		button -label (uiRes("m_AEparentConstraintTemplate.kDelete"))  deleteCacheButton;		
 		text -label "";		
 		setParent ..;

	AEparentCacheReplace($plug);
	setUITemplate -ppt;
}

global proc AEenableRestParentCallback( string $nodeName )
{
	int $enable = `getAttr ($nodeName+".enableRestPosition")`;
	editorTemplate -dimControl $nodeName "restTranslate" (! $enable);
	editorTemplate -dimControl $nodeName "restRotate" (! $enable);	
}


global proc AEparentConstraintTemplate ( string $nodeName )
{
	editorTemplate -beginScrollLayout;		
    	editorTemplate -beginLayout (uiRes("m_AEparentConstraintTemplate.kTargetOffsets"))  -collapse false;
		    editorTemplate -callCustom 
				"AEparentConstraintNew"
				"AEparentConstraintReplace"
				"target";
		editorTemplate -endLayout;

		editorTemplate -beginLayout (uiRes("m_AEparentConstraintTemplate.kParentConstraintAttributes"))  -collapse true;

		    editorTemplate -addControl "lockOutput";			
			editorTemplate -addControl "interpType" "AEparentCheckInterpType";
			editorTemplate -callCustom "AEparentCacheNew" "AEparentCacheReplace" "interpType";

			editorTemplate -addControl "constraintTranslate";
			editorTemplate -addControl "constraintRotate";
			editorTemplate -addControl "enableRestPosition" "AEenableRestParentCallback";			
			editorTemplate -addControl "restTranslate";
			editorTemplate -addControl "restRotate";
			

			// suppressed attributes
			editorTemplate -suppress "constraintRotatePivot";
			editorTemplate -suppress "constraintParentInverseMatrix";
			editorTemplate -suppress "constraintRotateTranslate";
			editorTemplate -suppress "constraintJointOrient";
			editorTemplate -suppress "constraintRotateOrder";
			editorTemplate -suppress "constraintOffsetPolarity";
			editorTemplate -suppress "interpCache";
			editorTemplate -suppress "lastTargetRotate";

		editorTemplate -endLayout;

		// include/call base class/node attributes
		AEtransformMain $nodeName;
		AEtransformNoScroll $nodeName;

	editorTemplate -addExtraControls;
	editorTemplate -endScrollLayout;
}
