// Copyright (C) 1997-2014 Autodesk, Inc., and/or its licensors.
// All rights reserved.
//
// The coded instructions, statements, computer programs, and/or related
// material (collectively the "Data") in these files contain unpublished
// information proprietary to Autodesk, Inc. ("Autodesk") and/or its licensors,
// which is protected by U.S. and Canadian federal copyright law and by
// international treaties.
//
// The Data is provided for use exclusively by You. You have the right to use,
// modify, and incorporate this Data into other products for purposes authorized 
// by the Autodesk software license agreement, without fee.
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND. AUTODESK
// DOES NOT MAKE AND HEREBY DISCLAIMS ANY EXPRESS OR IMPLIED WARRANTIES
// INCLUDING, BUT NOT LIMITED TO, THE WARRANTIES OF NON-INFRINGEMENT,
// MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE, OR ARISING FROM A COURSE 
// OF DEALING, USAGE, OR TRADE PRACTICE. IN NO EVENT WILL AUTODESK AND/OR ITS
// LICENSORS BE LIABLE FOR ANY LOST REVENUES, DATA, OR PROFITS, OR SPECIAL,
// DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES, EVEN IF AUTODESK AND/OR ITS
// LICENSORS HAS BEEN ADVISED OF THE POSSIBILITY OR PROBABILITY OF SUCH DAMAGES.

//
//
//  Creation Date:  18 April 1997
//
//  Description:
//      This implements the various global proc and variables needed 
//		for polygons
//

// these proc are called mainly from the Polygons menu set
// however, we need to have them defined here, because menus are
// read only once the user has pulled down the menu:
// this could make the shelf and other user defined UI fail
// if the Polygons menus have not been created and these functions are called.

global proc string polygonsMenuItemToShelf (string $item)
{
	return $item;
}

global proc PolyRequestUVSetName (string $title, string $cmd, string $version, string $args[])
//
//	Procedure Name:
//		PolyRequestUVSetName
//
//	Description:
//		Helper method to ask the user for a new UV set name and then call
//	a command with the name as the final argument.  The command will be
//	called like: $cmd $version $args "uvSetName"
//
//  Input Arguments:
//		string $title			The title for the dialog box
//		string $cmd				The command to issue
//		string $version			Version to pass onto the command
//		string $args			Arguments to pass onto the command
//
//  Return Value:
//      None.
//
{
	string $ok     = (uiRes("m_initPolygonsUI.kOK"));
	string $cancel = (uiRes("m_initPolygonsUI.kCancel"));
	
	string $response = `promptDialog
		-title $title
		-message (uiRes("m_initPolygonsUI.kDialogUVSetName"))
		-text "uvSet"
		-button $ok
		-button $cancel
		-defaultButton $ok
		-cancelButton $cancel
		-dismissString $cancel`;
	if ($response == $ok) {
		string $name = `promptDialog -query -text`;
		string $execute = ($cmd + " \"" + $version + "\" {");
		string $comma = "";
		for ($arg in $args) {
			$execute += ($comma + "\"" + $arg + "\"");
			$comma = ", ";
		}
		$execute += ("} \"" + $name + "\"");
		eval ($execute);
	}
}

global proc SoftPolyEdgeElements(int $option)
{
	string $cmd = "polySoftEdge -a ";

	if($option == 0)
		$cmd += "0";
	else
		$cmd += "180";

	polyPerformAction $cmd e 0;
}

global proc polyOpenBakeSetAE()
{
	string $lss[] = `ls -type mesh`;
	
	if(size($lss) > 1)
	{
		warning( (uiRes("m_initPolygonsUI.kPolyOpenBakeSetAEWarning")));
		return;
	}

	int $i;
	
	for($i = 0; $i < size($lss); $i++)
	{
		string $atr = $lss[0] + ".iog[0]";
		string $conn[] = `listConnections $atr`;
		
		int $j;
		
		for($j = 0; $j < size($conn); $j++)
		{
			if(`nodeType $conn[$j]` == "vertexBakeSet")
			{
				showBakeSetAE $conn[$j];
				return;
			}
		}

	}

}

global proc polyChangeColorMatChannel(int $opt)
{
	string $cmd = "polyOptions -colorMaterialChannel ";

	if($opt == 0)
		$cmd = $cmd + "none";
	else if($opt == 1)
		$cmd = $cmd + "ambient";
	else if($opt == 2)
		$cmd = $cmd + "ambientDiffuse";
	else if($opt == 3)
		$cmd = $cmd + "diffuse";
	else if($opt == 4)
		$cmd = $cmd + "specular";
	else // if($opt == 5)
		$cmd = $cmd + "emission";
	evalEcho($cmd);
}

global proc polyChangeMaterialBlend(int $opt)
{
	string $cmd = "polyOptions -materialBlend ";

	if($opt == 0)
		$cmd = $cmd + "overwrite";
	else if($opt == 1)
		$cmd = $cmd + "add";
	else if($opt == 2)
		$cmd = $cmd + "subtract";
	else if($opt == 3)
		$cmd = $cmd + "multiply";
	else if($opt == 4)
		$cmd = $cmd + "divide";
	else if($opt == 5)
		$cmd = $cmd + "average";
	else if($opt == 6)
		$cmd = $cmd + "modulate2x";
	evalEcho($cmd);
}

global proc toggleShadeMode()
{
	global int $gSelectMeshesBit;
	
	string $meshSurfaces[] = `filterExpand -ex true -sm $gSelectMeshesBit`;
	int    $isShaded[]  = `polyOptions -query -colorShadedDisplay $meshSurfaces`;
	int    $index = 0;
	
	//  Toggle colorShadedDisplay for all mesh surfaces
	//
	for ( $surface in $meshSurfaces ) {
		if ( $isShaded[$index] ) {
			polyOptions -colorShadedDisplay false $surface;
		} else {
			polyOptions -colorShadedDisplay true $surface;
		}
		$index++;
	}
}

//////////////////////////////////////////////////////////////////////

global proc toggleAutoShowColorPerVertex ()
{
	int $val=`optionVar -q polyAutoShowColorPerVertex`;
	if ($val) $val=0; else $val=1;
	optionVar -intValue polyAutoShowColorPerVertex $val;

	// Menu item may not exist if this has been called from the shelf
	if ( `menuItem -ex toggleAutoShowColorPerVertexItem` )
		menuItem -e -cb `optionVar -q polyAutoShowColorPerVertex`
			toggleAutoShowColorPerVertexItem;
}

global proc togglePolyMoveComponents ()
{
	int $val=`optionVar -q polyKeepFacetsGrouped`;
	if ($val) $val=0; else $val=1;
	optionVar -intValue polyKeepFacetsGrouped $val;

	// Menu item may not exist if this has been called from the shelf
	if ( `menuItem -ex toggleGroupItem` )
		menuItem -e -cb `optionVar -q polyKeepFacetsGrouped` toggleGroupItem;
}

global proc toggleCreatePolyPrimitiveAsTool()
{
	int $val = (!`optionVar -q createPolyPrimitiveAsTool`);
	optionVar -intValue createPolyPrimitiveAsTool $val;

	if ( `menuItem -ex toggleCreatePolyPrimitivesAsToolItem` )
		menuItem -e -cb $val toggleCreatePolyPrimitivesAsToolItem;

	if ( `menuItem -ex togglePolyPrimitivesAsToolItemExitOnComplete` )
		menuItem -e -enable $val togglePolyPrimitivesAsToolItemExitOnComplete;
}

global proc setCreatePolyPrimitiveAsTool(int $state)
{
	optionVar -intValue createPolyPrimitiveAsTool $state;

	if ( `menuItem -ex toggleCreatePolyPrimitivesAsToolItem` )
		menuItem -e -cb $state toggleCreatePolyPrimitivesAsToolItem;

	if ( `menuItem -ex togglePolyPrimitivesAsToolItemExitOnComplete` )
		menuItem -e -enable $state togglePolyPrimitivesAsToolItemExitOnComplete;
}

global proc togglePolyPrimitiveAsToolExitOnComplete()
{
	int $val = (!`optionVar -q polyPrimitiveAsToolExitOnComplete`);
	optionVar -intValue polyPrimitiveAsToolExitOnComplete $val;

	if ( `menuItem -ex togglePolyPrimitivesAsToolItemExitOnComplete` )
		menuItem -e -cb $val togglePolyPrimitivesAsToolItemExitOnComplete;
}

global proc setPolyPrimitiveAsToolExitOnComplete(int $state)
{
	optionVar -intValue polyPrimitiveAsToolExitOnComplete $state;

	if ( `menuItem -ex togglePolyPrimitivesAsToolItemExitOnComplete` )
		menuItem -e -cb $state togglePolyPrimitivesAsToolItemExitOnComplete;
}

global proc togglePolySingleSided ()
{
	int $val=`optionVar -q polyCreateMeshesSingleSided`;
	if ($val) $val=0; else $val=1;
	optionVar -intValue polyCreateMeshesSingleSided $val;

	// Menu item may not exist if this has been called from the shelf
	if ( `menuItem -ex toggleSingleSided` )
		menuItem -e -cb `optionVar -q polyCreateMeshesSingleSided` toggleSingleSided;
}

global proc togglePolyAutoInstallAction ()
{
	int $val=`optionVar -q polyAutoInstallAction`;
	if ($val) $val=0; else $val=1;
	optionVar -intValue polyAutoInstallAction $val;

	// Menu item may not exist if this has been called from the shelf
	if ( `menuItem -ex toggleAutoInstallItem` )
		menuItem -e -cb `optionVar -q polyAutoInstallAction` toggleAutoInstallItem;
}

global proc toggleDisplayPolyCount()
{
	int $val = 1;
	if (`optionVar -exists polyCount`) {
		$val=`optionVar -q polyCount`;
		if ($val) $val=0; else $val=1;
	}
	optionVar -intValue polyCount $val;
	eval("polyEvaluate -ds");
	// Menu item may not exist if this has been called from the shelf
	if ( `menuItem -ex toggleDisplayPolyCountItem` ) {
		menuItem -e -cb `optionVar -q polyCount` toggleDisplayPolyCountItem;
	}
}

global proc togglePolyAutoConvertAction ()
{
	int $val=`optionVar -q polyAutoConvertAction`;
	if ($val) $val=0; else $val=1;
	optionVar -intValue polyAutoConvertAction $val;
	
	// Menu item may not exist if this has been called from the shelf
	if ( `menuItem -ex toggleAutoConvertItem` )
		menuItem -e -cb `optionVar -q polyAutoConvertAction` toggleAutoConvertItem;
}

global proc togglePolyPlanarConstraints ()
{
	int $val =`optionVar -q polyKeepFacetsPlanar`;
	if ($val == 0) $val=1; else $val=0;

// catch a potential error , then set the correct value for polyKeepFacetsPlanar
	string $cmd=("polyCreateFacetCtx -e -pc " + $val 
			+ " polyCreateFacetContext; polyAppendFacetCtx -e -pc " + $val
			+ " polyAppendFacetContext;");			
	if (catch (eval($cmd)))
		warning (uiRes("m_initPolygonsUI.kFacetPlanarError"));

	$val=`polyAppendFacetCtx -q -pc polyAppendFacetContext` 
		+ `polyCreateFacetCtx -q -pc polyCreateFacetContext`;
	if ($val == 2) $val=1; 
	else if ($val == 1) {
		$val=0;
		$cmd=("polyCreateFacetCtx -e -pc " + $val
            + " polyCreateFacetContext; polyAppendFacetCtx -e -pc " + $val
            + " polyAppendFacetContext;");

		catch (eval($cmd));	
	}

	optionVar -intValue polyKeepFacetsPlanar $val;
	// Menu item may not exist if this has been called from the shelf
	if ( `menuItem -exists togglePlanarItem` )
		menuItem -e -cb `optionVar -q polyKeepFacetsPlanar` togglePlanarItem;
}

global proc togglePolyCreateShaderWithMapping ()
{
	int $val =`optionVar -q polyCreateShaderWithMapping`;
	if ($val == 0) $val=1; else $val=0;
	optionVar -intValue polyCreateShaderWithMapping $val;

	if ( `menuItem -exists toggleCreateShaderItem` )
		menuItem -e -cb `optionVar -q polyCreateShaderWithMapping` toggleCreateShaderItem;
}


// global proc initPolygonsUI ()
// {
// the following lines are not _necessary_. they are here
// to allow keeping track of all the global variables used in 
// polygon interaction
	global string $polyTextureColorShader="";	
// we need to synchronize user's chosen defaults with the display defaults:	
	if (`exists "polysDisplaySetup"`) {
		int $tmpObjsAffected = `optionVar -q displayPolyObjsAffected`;
		optionVar -intValue displayPolyObjsAffected 0;
		catch (`polysDisplaySetup 0`);
		optionVar -intValue displayPolyObjsAffected 1;
		catch (`polysDisplaySetup 0`);
		optionVar -intValue displayPolyObjsAffected $tmpObjsAffected;
	}
	polySelectConstraint
        -ws `optionVar -q polyFaceSensitive`;

	// Always disable the polyCount display on startUp
	optionVar -intValue polyCount 0;

	// Stuff for Options->GeneralPreferences->Display
	//
	polyOptions -np -sv `optionVar -q newPolyVertexSize`;
	polyOptions -np -sn `optionVar -q newPolyNormalSize`;
	polyOptions -np -suv `optionVar -q newPolyUVSize`;

	float $longueurNorm[] = `polyOptions -q -np -sn`;

	polyOptions -np -sb `optionVar -q newPolyBorderEdgeSize`;
	polyOptions -np -dv `optionVar -q newPolyVtxDisp`;
	polyOptions -np -bcv `optionVar -q newPolyVtxBackCull`;
	
	int $point = `optionVar -q newPolyVertexNormals`;
	int $facet = `optionVar -q newPolyFacetNormalDisp`;

	polyOptions -np -dn ($point || $facet);

	if( $point && $facet )
		polyOptions -np -pf;
	else if( $point )
			polyOptions -np -pt;
	else if( $facet )
			polyOptions -np -f;

	int $edgeDisp = `optionVar -q newPolyEdgeDisp`;
	if( $edgeDisp == 0 )
		polyOptions -np -ae;
	else if( $edgeDisp == 1 )
		polyOptions -np -se;
	else if( $edgeDisp == 2 )
		polyOptions -np -he;

	polyOptions -np -db `optionVar -q newPolyBorderEdgeHilite`;
	polyOptions -np -dmb `optionVar -q newPolyBorderMapHilite`;
	polyOptions -np -dce `optionVar -q newPolyCreaseEdgeHilite`;
	polyOptions -np -dcv `optionVar -q newPolyCreaseVertexHilite`;
	polyOptions -np -dc `optionVar -q newPolyFacetCentreDisp`; 
	polyOptions -np -dt `optionVar -q newPolyFacetTrngleDisp`; 
	polyOptions -np -dw `optionVar -q newPolyFacetWarpDisp`; 
	polyOptions -np -dif `optionVar -q newPolyHoleFacesHilite`;

	polyOptions -np -din
		`optionVar -q newPolyNumVertexDisp`
		`optionVar -q newPolyNumEdgeDisp`
		`optionVar -q newPolyNumFacetDisp`
		`optionVar -q newPolyNumUvDisp`; 

	polyOptions -np -smoothDrawType `optionVar -q newPolyDefaultSmoothDrawType`; 

	int $backCull = `optionVar -q newPolyBackFaceCull`;
	if( $backCull == 0 )
		polyOptions -np -bc;
	else if( $backCull == 1 )
			polyOptions -np -fb;
	else if( $backCull == 2 )
			polyOptions -np -wbc;
	else if( $backCull == 3 )
			polyOptions -np -hb;

	int $colShaded = `optionVar -q newPolyColorShaded`;
		polyOptions -np -cs $colShaded;

	int $colChannel = `optionVar -query newPolyColorChannel`;	
	if ($colChannel == 1)
		polyOptions -np -cm "none";
	else if ($colChannel == 2)
		polyOptions -np -cm "ambient";
	else if ($colChannel == 3)
		polyOptions -np -cm "ambientDiffuse";
	else if ($colChannel == 4)
		polyOptions -np -cm "diffuse";
	else if ($colChannel == 5)
		polyOptions -np -cm "specular";
	else if ($colChannel == 6)
		polyOptions -np -cm "emission";

	int $matBlend = `optionVar -query newPolyMaterialBlend`;	
	if ($matBlend == 1)
		polyOptions -np -mb "overwrite";
	else if ($matBlend == 2)
		polyOptions -np -mb "add";
	else if ($matBlend == 3)
		polyOptions -np -mb "subtract";
	else if ($matBlend == 4)
		polyOptions -np -mb "multiply";
	else if ($matBlend == 5)
		polyOptions -np -mb "divide";
	else if ($matBlend == 6)
		polyOptions -np -mb "average";
	else if ($matBlend == 6)
		polyOptions -np -mb "modulate2x";
		

	// End for stuff Options->GeneralPreferences->Display 
// }

source MTprocs;
source polyPerformAction;

