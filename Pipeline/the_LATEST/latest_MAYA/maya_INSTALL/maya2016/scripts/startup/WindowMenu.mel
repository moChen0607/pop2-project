// Copyright (C) 1997-2014 Autodesk, Inc., and/or its licensors.
// All rights reserved.
//
// The coded instructions, statements, computer programs, and/or related
// material (collectively the "Data") in these files contain unpublished
// information proprietary to Autodesk, Inc. ("Autodesk") and/or its licensors,
// which is protected by U.S. and Canadian federal copyright law and by
// international treaties.
//
// The Data is provided for use exclusively by You. You have the right to use,
// modify, and incorporate this Data into other products for purposes authorized 
// by the Autodesk software license agreement, without fee.
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND. AUTODESK
// DOES NOT MAKE AND HEREBY DISCLAIMS ANY EXPRESS OR IMPLIED WARRANTIES
// INCLUDING, BUT NOT LIMITED TO, THE WARRANTIES OF NON-INFRINGEMENT,
// MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE, OR ARISING FROM A COURSE 
// OF DEALING, USAGE, OR TRADE PRACTICE. IN NO EVENT WILL AUTODESK AND/OR ITS
// LICENSORS BE LIABLE FOR ANY LOST REVENUES, DATA, OR PROFITS, OR SPECIAL,
// DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES, EVEN IF AUTODESK AND/OR ITS
// LICENSORS HAS BEEN ADVISED OF THE POSSIBILITY OR PROBABILITY OF SUCH DAMAGES.

//
//  Description:
//      This file creates the window menu
//

// This string points to the relationship editor pulldown menu in the
// main window.  If plugins add new tasks, they can add their popup menu
// items to this menu.
global string $relationshipEditorPulldownMenu = "";

// These strings point to procedures for adding and removing tasks to the
// relationship editor.  They are managed by the relationshipEditorRegisterTask
// global procedure that plugin writers can call.
global string $relationshipEditorRegisterCB[] = {};
global string $relationshipEditorUnregisterCB[] = {};

global proc string[] getRelationshipEdPopups()
//
// Description:
//	This procedure finds and returns the popup task menu for all relationship
//  editors.  This list is used to allow plugins to register their own tasks.
//
{
	string $popups[];
    string $controls[] = `lsUI -long -controls`;
	
	// Look for controls whose leaf name is "taskPopup".
	for ($c in $controls) {
		string $tokens[];
		int $numTokens = `tokenize $c "|" $tokens`;
		if ($tokens[$numTokens-1] == "taskPopup")
		    $popups[size($popups)] = $c;
	}
	
	return $popups;
}

global proc int relationshipEditorRegisterTask(
		string $registerCB,
		string $unregisterCB)
//
// Description:
//	This procedure saves the two callbacks for registering and unregistering
//  a task for the relationship editor.  The callbacks are used to add and
//  remove the popup UI which makes the tasks visible to the user.  An id
//  number is returned to the caller to use when unregistering the task.
//
{
	global string $relationshipEditorPulldownMenu;
	global string $relationshipEditorRegisterCB[];
	global string $relationshipEditorUnregisterCB[];
	
	// Use the next available index as the id.
    int $id = size($relationshipEditorRegisterCB);
	
	// Store the callback procedures.
	$relationshipEditorRegisterCB[$id] = $registerCB;
	$relationshipEditorUnregisterCB[$id] = $unregisterCB;
	
	// If the main menu pulldown or the relationship editor popup 
	// have already been created, call the registerCB.
	if ($relationshipEditorPulldownMenu != "") {
	
	    // Call the register CB at least once for the main menu pulldown.
	    eval($registerCB + " foo");
		
		// Get the relationship editor task popups and register the plugin
		// UI for each one.
	    string $taskPopups[] = getRelationshipEdPopups();
		for ($popup in $taskPopups)
	        eval($registerCB + " " + $popup);
	}
	
	return $id;
}

global proc relationshipEditorUnregisterTask(int $taskId)
//
// Description:
//	This procedure unregisters that task specified by the given id.
//
{
	global string $relationshipEditorPulldownMenu;
	global string $relationshipEditorRegisterCB[];
	global string $relationshipEditorUnregisterCB[];
	
    // If the task id is not valid, just return.
	if (($taskId < 0) || ($taskId >= size($relationshipEditorRegisterCB)))
	    return;
		
	// If the relationship editor or the main window pulldown have been created,
	// call the unregisterCB for each relationship editor.
	if ($relationshipEditorPulldownMenu != "") {
	
	    // Call the unregister CB at least once for the main menu pulldown.
	    eval($relationshipEditorUnregisterCB[$taskId] + " foo");
		
		// Get the relationship editor task popups and unregister the plugin
		// UI for each one.
	    string $taskPopups[] = getRelationshipEdPopups();
		for ($popup in $taskPopups)
	        eval($relationshipEditorUnregisterCB[$taskId] + " " + $popup);
    }
		
	// Clear the callback procedures.
	$relationshipEditorRegisterCB[$taskId] = "";
	$relationshipEditorUnregisterCB[$taskId] = "";
}

global proc addRelationshipEdPluginItems(string $popup)
//
// Description:
//	This procedure is called when the relationship editor is built.  It
//  creates the UI for any tasks registered by plugins.
//
{
	global string $relationshipEditorRegisterCB[];
	
    // Call the register callback for each registered plugin.
    for ($cb in $relationshipEditorRegisterCB) {
	    if ($cb != "")
	    	eval($cb + " " + $popup);
	}
}

global proc buildObjectEdMenu( string $parent ) {

	global string $gCommandWindow;

	setParent -menu $parent;

	if (!(`menuItem -query -exists wmAssetEditor`))
	{
		menuItem -ecr false -label (uiRes("m_WindowMenu.kAssetEditorLabel"))  
			-annotation (getRunTimeCommandAnnotation("AssetEditor"))
			-c "AssetEditor" wmAssetEditor;
	}

	if (!(`menuItem -query -exists wmSpreadsheetEditor`))
	{
		menuItem -ecr false -label (uiRes("m_WindowMenu.kAttributeSpreadShtLabel"))  
			-annotation (uiRes("m_WindowMenu.kAttributeSpreadShtAnnot")) 
			-imageOverlayLabel (uiRes("m_WindowMenu.kAttrSpreadOverlayLabel")) 
			-c "SpreadSheetEditor" wmSpreadsheetEditor;
	}

	if (!(`menuItem -query -exists wmComponentEditor`))
	{
		menuItem -ecr false -label (uiRes("m_WindowMenu.kComponentEditorLabel")) 
			 -annotation (uiRes("m_WindowMenu.kComponentEditorAnnot")) 
			-imageOverlayLabel (uiRes("m_WindowMenu.kClipEdOverlayLabel")) 
			 -c "ComponentEditor" wmComponentEditor;
	}

	if (!(`menuItem -query -exists wmConnectionEditor`))
	{
		menuItem -ecr false -label (uiRes("m_WindowMenu.kConnectionEditorLabel"))  
			-annotation (uiRes("m_WindowMenu.kConnectionEditorAnnot")) 
			-c "ConnectionEditor" wmConnectionEditor;
	}

	if (!(`menuItem -query -exists wmDisplayLayerEditorWindow`))
	{
		menuItem -ecr false -label (uiRes("m_WindowMenu.kDisplayLayerEdLabel"))  
			-annotation (uiRes("m_WindowMenu.kDisplayLayerEdAnnot")) 
			-c "DisplayLayerEditorWindow" wmDisplayLayerEditorWindow;
	}

	if (!(`menuItem -query -exists wmFilePathEditor`))
	{
		menuItem -ecr false -label (uiRes("m_WindowMenu.kFilePathEditorLabel"))  
			-annotation (getRunTimeCommandAnnotation("FilePathEditor"))
			-c "FilePathEditor" wmFilePathEditor;
	}

	if (!(`menuItem -query -exists wmNamespaceEditor`))
	{
		menuItem -ecr false -label (uiRes("m_WindowMenu.kNamespaceEditorLabel"))  
			-annotation (getRunTimeCommandAnnotation("NamespaceEditor"))
			-c "NamespaceEditor" wmNamespaceEditor;
	}

	if (!(`menuItem -query -exists wmVisorWindow`))
	{
		string $cmd = "VisorWindow";
		string $annot = getRunTimeCommandAnnotation($cmd);
		string $label = (uiRes("m_WindowMenu.kVisorLabel"));
		menuItem -ecr false -label $label
			-annotation $annot
			-c $cmd wmVisorWindow;
	}

	if (!(`menuItem -query -exists wmChannelControlEditor`))
	{
		menuItem -divider true;

		menuItem -ecr false -label (uiRes("m_WindowMenu.kChannelCtrlLabel"))  
			-annotation (uiRes("m_WindowMenu.kChannelCtrlAnnot")) 
			-c "ChannelControlEditor" wmChannelControlEditor;
	}

	// menuItem -label "Panel Camera Attributes..." -c "showPanelCameraEditor \"\"";

	if (!(`menuItem -query -exists wmScriptEditor`))
	{
		menuItem -divider true;

		menuItem -ltVersion "2015" -ecr false -label (uiRes("m_WindowMenu.kScriptEditorLabel")) 
			-image "cmdWndIcon.png"
			-annotation (uiRes("m_WindowMenu.kScriptEditorAnnot")) 
			-c "ScriptEditor" wmScriptEditor;
	}
	if (!(`menuItem -query -exists wmCommandShell`))
	{
		menuItem -ecr false -label (uiRes("m_WindowMenu.kCommandShellLabel"))  
			-annotation (uiRes("m_WindowMenu.kCommandShellAnnot")) 
			-c "CommandShell" wmCommandShell;
	}

	int $profilerPluginLoaded = `pluginInfo -q -loaded "dgProfiler"`;
	if ($profilerPluginLoaded)
	{
		if (!(`menuItem -query -exists wmDGProfiler`))
		{
			menuItem -ecr false -label (uiRes("m_WindowMenu.kDGProfilerLabel"))  
				-annotation (uiRes("m_WindowMenu.kDGProfilerAnnot")) 
				-c "dgProfiler" wmDGProfiler;
		}
	}
	else
	{
		catchQuiet(`deleteUI -menuItem wmDGProfiler`);
	}
	if (!(`menuItem -query -exists wmProfiler`))
	{
		menuItem -ecr false -label (uiRes("m_WindowMenu.kProfilerLabel"))  
			-annotation (uiRes("m_WindowMenu.kProfilerAnnot")) 
			-ver "2016"
			-c "ProfilerTool" wmProfiler;
	}

}

global proc buildRenderingEdMenu( string $parent ) {

	popupMenu -e -deleteAllItems $parent;
	setParent -menu $parent;

	if( `menu -q -ni $parent` != 0 ) {
		//
		//	Menu is already built - just return
		//
		return;
	}

	string $command = "RenderViewWindow";
	string $annotation = getRunTimeCommandAnnotation($command);
	menuItem -ecr false 
		-image "rvOpenWindow.png"
		-label (localizedPanelLabel("Render View"))
		-annotation $annotation 
		-c $command;
	
	// Create a render globals menu item for each available renderer
	//
	string $renderers[] = `renderer -query -namesOfAvailableRenderers`;
	string $rendererUIName = "";
	
	$command = "RenderGlobalsWindow";
	if ($command != "")
	{
		$annotation = getRunTimeCommandAnnotation($command);
		menuItem 
			-enableCommandRepeat false 
			-label (localizedUIMisc("Render Settings"))
			-annotation $annotation
			-command $command;
	}

	$command = "HypershadeWindow";
	$annotation = getRunTimeCommandAnnotation($command);
	menuItem -ecr false -label (uiRes("m_WindowMenu.kHypershadeLabel"))  
		-annotation $annotation 
		-image "hypershadeIcon.png"
		-imageOverlayLabel (uiRes("m_WindowMenu.kHyperShadeOverlayLabel")) 
		-c $command
		-version 2016;

	// Create renderer specific submenus for any additional renderers installed
	for ($i = 0; $i < size($renderers); $i += 1)
	{
		$command = `renderer -q -renderingEditorsSubMenuProcedure $renderers[$i]`;

		if($command != "")
		{
            $rendererUIName = `renderer -query -rendererUIName $renderers[$i]`;

		   	menuItem
		   		-tearOff				true
				-subMenu				true
				-label $rendererUIName 
 				-annotation 
                (uiRes("m_WindowMenu.kRendererSpecificOptionsAnnot"))
				("rendererOptionsItem" + $renderers[$i]);

			menuItem
				-edit
				-postMenuCommand
					("eval " + $command +
					 " rendererOptionsItem" + $renderers[$i])
				("rendererOptionsItem" + $renderers[$i]);

			setParent -menu ..;
		}
	}
	menuItem -ecr false -label (uiRes("m_WindowMenu.kRenderLayerEdLabel"))  
		-annotation (uiRes("m_WindowMenu.kRenderLayerEdAnnot")) 
		-c "RenderLayerEditorWindow";
	menuItem
		-label (uiRes("m_WindowMenu.kStereoRigEditor"))
		-annotation (uiRes("m_WindowMenu.kStereoRigManagerAnno"))
        -image      "viewStereoEditor.png"
		-command ("stereoCameraCBwrapper(\"stereoRigToolEditor\",\"customRigEditor()\")");
	menuItem -divider true;

	menuItem -ecr false -label (uiRes("m_WindowMenu.kRenderingFlagsLabel"))  
		-annotation (uiRes("m_WindowMenu.kRenderingFlagsAnnot")) 
		-c "RenderFlagsWindow";

	menuItem -ecr false -label (uiRes("m_WindowMenu.kShadingGrpAttribLabel")) 
		-annotation (uiRes("m_WindowMenu.kShadingGrpAttribAnnot")) 
		-c "ShadingGroupAttributeEditor";


	menuItem -divider true;


	if (`licenseCheck -m "edit" -typ "complete"`) {
		menuItem -ecr false -label (uiRes("m_WindowMenu.kHWRenderBufferLabel"))  
			-annotation (uiRes("m_WindowMenu.kHWRenderBufferAnnot")) 
			-c "HardwareRenderBuffer";
	}
}

global proc buildAnimationEdMenu( string $parent ) {
	setParent -menu $parent;
	int $completeLicense = `licenseCheck -m "edit" -typ "complete"`;

	if( `menu -q -ni $parent` != 0 ) {
		//
		//	Menu is already built - just return
		//
		return;
	}
	menuItem -ecr false -label (uiRes("m_WindowMenu.kGraphEditorLabel"))  
		-annotation (uiRes("m_WindowMenu.kGraphEditorAnnot")) 
		-c "GraphEditor";

	
	// ADSK_TIME_EDITOR_BEGIN

	if (mayaHasTimeEditorFeature()) {
		menuItem -ecr false -label (uiRes("m_WindowMenu.kCTEEditorLabel"))  
			-annotation (uiRes("m_WindowMenu.kCTEEditorAnnot")) 
			-version "2016"
			-c "CTEEditor";
	}
	
	// ADSK_TIME_EDITOR_END



	menuItem  -ecr false -label (uiRes("m_WindowMenu.kTraxEditorLabel"))  
		-annotation (uiRes("m_WindowMenu.kTraxEditorAnnot")) 
		-c "CharacterAnimationEditor";
	
	menuItem  -ecr false -label (uiRes("m_WindowMenu.kSequenceEditorLabel"))  
		-annotation (uiRes("m_WindowMenu.kSequenceEditorAnnot")) 
		-c "SequenceEditor";

	menuItem  -ecr false -label (uiRes("m_WindowMenu.kDopeSheetLabel"))  
		-annotation (uiRes("m_WindowMenu.kDopeSheetAnnot")) 
		-c "DopeSheetEditor";

	menuItem -label (uiRes("m_WindowMenu.kHIKRetargeting"))
		-to true
		-image "humanIK_CharCtrl.png"
		-annotation (uiRes("m_WindowMenu.kCharacterControlsAnnot"))
		-c "HIKCharacterControlsTool"		
		hikWindowItem;

	if ($completeLicense) {
		menuItem  -ecr false -label (uiRes("m_WindowMenu.kBlendShapeLabel"))  
			-annotation (uiRes("m_WindowMenu.kBlendShapeAnnot")) 
			-imageOverlayLabel (uiRes("m_WindowMenu.kBlendShapeOverlayLabel")) 
			-image "blendShapeEditor.png" 
			-c "BlendShapeEditor";
	}

	menuItem -divider true;
	menuItem -ecr false -label (uiRes("m_WindowMenu.kExpressionEdLabel"))  
		-annotation (uiRes("m_WindowMenu.kExpressionEdAnnot")) 
		-c "ExpressionEditor" expressionItem;
	
}

global proc buildLightLinkingEdMenu( string $parent ) {
	setParent -menu $parent;

	if( `menu -q -ni $parent` != 0 ) {
		//
		//	Menu is already built - just return
		//
		return;
	}
	menuItem -ecr false -label (uiRes("m_WindowMenu.kLightCentricLabel")) 
	 -annotation (uiRes("m_WindowMenu.kLightCentricAnnot")) 
	  -c "LightCentricLightLinkingEditor";
	menuItem -ecr false -label (uiRes("m_WindowMenu.kObjectCentricLabel"))  
		-annotation (uiRes("m_WindowMenu.kObjectCentricAnnot")) 
		-c "ObjectCentricLightLinkingEditor";
}

global proc buildUvLinkingEdMenu( string $parent ) {
	global string $uvMainLinkMenu;
	global string $furUVLinkMenuItem;
	$uvMainLinkMenu = $parent;

	setParent -menu $parent;

	if( `menu -q -ni $parent` != 0 ) {
		//
		//	Menu is already built - just return
		//
		return;
	}
	menuItem -ecr false -label (uiRes("m_WindowMenu.kTextureCentricLabel")) 
	 -annotation (uiRes("m_WindowMenu.kTextureCentricAnnot")) 
	  -c "TextureCentricUVLinkingEditor";
	menuItem -ecr false -label (uiRes("m_WindowMenu.kUVCentricLabel"))  
		-annotation (uiRes("m_WindowMenu.kUVCentricAnnot")) 
		-c "UVCentricUVLinkingEditor";
	
	//Paint Effects/UV Linking Menu
	{
		menuItem -ecr false -label (uiRes("m_WindowMenu.kPFXUVLabel"))  
		-annotation (uiRes("m_WindowMenu.kPFXUVAnnot")) 
		-c "PFXUVSetLinkingEditor";
	}

	//Hair/UV Linking Menu
	{
		menuItem -ecr false -label 
                            (uiRes("m_WindowMenu.kHairUVLabel"))  
		-annotation (uiRes("m_WindowMenu.kHairUVAnnot"))
		-c "HairUVSetLinkingEditor";
	}

	//Maya Fur Plugin Fur/UV Linking Menu
	if (`pluginInfo -q -l Fur`) {
			$furUVLinkMenuItem = `menuItem -ecr false -label 
                               (uiRes("m_WindowMenu.kFurUVLabel"))  
			-annotation (getRunTimeCommandAnnotation("FurUVSetLinkingEditor"))
			-c "FurUVSetLinkingEditor"`;
	}
}

global proc buildRelationshipEdMenu( string $parent )
{	
	// Make the parent menu available to plugins who want to add their own
	// relationships.  This variable is defined in relationshipEditor.mel.
    global string $relationshipEditorPulldownMenu;
	$relationshipEditorPulldownMenu = $parent;
	
	setParent -menu $parent;

	if( `menu -q -ni $parent` != 0 ) {
		//
		//	Menu is already built - just return
		//
		return;
	}

    menuItem -ltVersion 2016 -ecr false -label (uiRes("m_WindowMenu.kAnimLayerRelEdLabel")) 
	 -annotation (uiRes("m_WindowMenu.kAnimLayerRelEdAnnot")) 
	  -c "AnimLayerRelationshipEditor";	  

	menuItem -ecr false -label (uiRes("m_WindowMenu.kCameraSetEdLabel")) 
		-annotation (uiRes("m_WindowMenu.kDameraSetEdAnnot")) 
		-c "CameraSetEditor";

	menuItem -ecr false -label (uiRes("m_WindowMenu.kCharacterSetEdLabel")) 
	 -annotation (uiRes("m_WindowMenu.kCharacterSetEdAnnot")) 
	  -c "CharacterSetEditor";

	menuItem
		-label (uiRes("m_WindowMenu.kCreaseSetsRelEdLabel"))
		-annotation (getRunTimeCommandAnnotation("PolyCreaseEditor"))
		-command "python \"from maya.app.general import creaseSetEditor; creaseSetEditor.showCreaseSetEditor()\"" 
		-enableCommandRepeat 1
		-image "polyCrease.png" 
		-version "2014"
		;

	menuItem -ecr false -label (uiRes("m_WindowMenu.kDeformerSetsEdLabel"))  
		-annotation (uiRes("m_WindowMenu.kDeformerSetsEdAnnot")) 
		-c "DeformerSetEditor";
	
	menuItem -ecr false -label (uiRes("m_WindowMenu.kDisplayLayersEdLabel")) 
		-annotation (uiRes("m_WindowMenu.kDisplayLayersEdAnnot")) 
		-c "LayerRelationshipEditor";

	if( `licenseCheck -m edit -type complete` == 1 )
	{
		menuItem  -ecr false -label (uiRes("m_WindowMenu.kDynRelEdLabel"))  
			-annotation (uiRes("m_WindowMenu.kDynRelEdAnnot")) 
			-c "DynamicRelationshipEditor";
	}

	if (`pluginInfo -q -l Fur`)
	{
		global string $hairFurLinkMenuItem;
		$hairFurLinkMenuItem = `menuItem -ecr false -label (uiRes("m_WindowMenu.kHairFurLinkEdLabel")) 
		-annotation (uiRes("m_WindowMenu.kHairFurLinkEdAnnot")) 
		-c "HairFurRelationshipEditor"`;
		setParent -menu $parent;
	}

	$menu = `menuItem 
          -label (uiRes("m_WindowMenu.kLightLinkingEdLabel"))  
          -sm true -to true`;
		menu -e -pmc ( "buildLightLinkingEdMenu " + $menu ) $menu;
	setParent -menu $parent;

	menuItem -ecr false -label (uiRes("m_WindowMenu.kParitionsEdLabel")) 
	 -annotation (uiRes("m_WindowMenu.kParitionsEdAnnot")) 
	  -c "PartitionEditor";

	menuItem -ecr false -label (uiRes("m_WindowMenu.kRenderLayerRelEdLabel")) 
	 -annotation (uiRes("m_WindowMenu.kRenderLayerRelEdAnnot")) 
	  -c "RenderLayerRelationshipEditor";

	menuItem -ecr false -label (uiRes("m_WindowMenu.kRenderPassSetEdLabel"))
		-annotation (uiRes("m_WindowMenu.kRenderPassSetEdAnnot"))
		-c "RenderPassSetEditor";

	menuItem -ecr false -label (uiRes("m_WindowMenu.kSetEditorLabel")) 
	 -annotation (uiRes("m_WindowMenu.kSetEditorAnnot")) 
	  -c "SetEditor";
	$menu = `menuItem 
          -label (uiRes("m_WindowMenu.kUVLinkingEdLabel")) 
          -sm true -to true`;
		menu -e -pmc ( "buildUvLinkingEdMenu " + $menu ) $menu;
	setParent -menu $parent;
	
	// Add any items from plugins.
	addRelationshipEdPluginItems("foo");
}

global proc buildSettingsMenu( string $parent ) 
{
	setParent -menu $parent;

	if( `menu -q -ni $parent` != 0 ) {
		//
		//	Menu is already built - just return
		//
		return;
	}

	menuItem -ecr false -label (uiRes("m_WindowMenu.kPreferencesLabel"))  
		-annotation (uiRes("m_WindowMenu.kPreferencesAnnot"))  
		-c "PreferencesWindow";

    menuItem  -ecr false -label (uiRes("m_WindowMenu.kToolSettingsLabel"))  
		-image "toolSettings.png"
		-annotation (uiRes("m_WindowMenu.kToolSettingsAnnot")) 
		-c "ToolSettingsWindow";

	menuItem -ecr false -label (uiRes("m_WindowMenu.kPerfSettingsLabel"))  
		-annotation (uiRes("m_WindowMenu.kPerfSettingsAnnot")) 
		-c "PerformanceSettingsWindow";

    menuItem -divider true;

	menuItem -ecr false -label (uiRes("m_WindowMenu.kHotkeyPrefLabel"))  
		-annotation (uiRes("m_WindowMenu.kHotKeyPrefAnnot"))  
		-c "HotkeyPreferencesWindow"
		-version "2016";

	menuItem -ecr false -label (uiRes("m_WindowMenu.kColorPrefLabel"))  
		-annotation (uiRes("m_WindowMenu.kColorPrefAnnot"))  
		-c "ColorPreferencesWindow";

	menuItem  -ecr false -label (uiRes("m_WindowMenu.kMMenuPrefLabel"))  
		-annotation (uiRes("m_WindowMenu.kMMenuPrefAnnot")) 
		-c "MarkingMenuPreferencesWindow";

	menuItem  -ecr false -label (uiRes("m_WindowMenu.kShelvesPrefLabel"))  
		-annotation (uiRes("m_WindowMenu.kShelvesPrefAnnot")) 
		-c "ShelfPreferencesWindow" shelfOptionsItem;

	menuItem  -ecr false -label (uiRes("m_WindowMenu.kPanelPrefLabel"))  
		-annotation (uiRes("m_WindowMenu.kPanelPrefAnnot")) 
		-c "PanelPreferencesWindow";

	menuItem -divider true;

    menuItem -ecr false -label (uiRes("m_WindowMenu.kPluginMgrLabel"))  
		-annotation (uiRes("m_WindowMenu.kPluginMgrAnnot")) 
		-c "PluginManager";
}

global proc openAEWindow( )
//
//	Description:
//		Opens an AE window, IF the attribute editor isn't
//		in the main Maya window pane already.
//
{
	editSelected;
}

global proc WindowMenu( string $parent ) {

	setParent -menu $parent;
	global string $gMiInteractionEditorMenuParent; 
	global string $gMiInteractionEditorMenuAfter;

	$gMiInteractionEditorMenuParent = $parent;
	
	menuItem -divider true -dividerLabel (uiRes("m_WindowMenu.kEditors"));

	string $menu = `menuItem 
          -label (uiRes("m_WindowMenu.kAnimEditorsLabel"))
          -sm true -to true`;
		menu -e -pmc ( "buildAnimationEdMenu " + $menu ) $menu;
	setParent -menu $parent;
		
	$menu = `menuItem 
           -label (uiRes("m_WindowMenu.kGeneralEditorsLabel"))  
           -sm true -to true`;
		menu -e -pmc ( "buildObjectEdMenu " + $menu ) $menu;
	setParent -menu $parent;

	$menu = `menuItem 
            -label (uiRes("m_WindowMenu.kRelationEditorsLabel"))
            -sm true -to true`;
		menu -e -pmc ( "buildRelationshipEdMenu " + $menu ) $menu;
	setParent -menu $parent;

	$menu = `menuItem -label 
          (uiRes("m_WindowMenu.kRenderingEditorsLabel")) 
          -sm true -to true`;
		menu -e -pmc ( "buildRenderingEdMenu " + $menu ) $menu;
	setParent -menu $parent;

	$menu = `menuItem -label 
          (uiRes("m_WindowMenu.kSettingsPrefsLabel"))
          -sm true -to true`;
		menu -e -pmc ( "buildSettingsMenu " + $menu ) $menu;
	setParent -menu $parent;

	menuItem -divider true -ld false;

	menuItem -ecr false 
	 	-label (localizedUIComponentLabel("Attribute Editor"))
		-image "attributes.png"
	 	-annotation (uiRes("m_WindowMenu.kAttribEditorAnnot")) 
		-c "AttributeEditor";

	menuItem -ecr false -label (uiRes("m_WindowMenu.kOutlinerLabel"))  
		-annotation 
        (uiRes("m_WindowMenu.kOutlinerAnnot")) 
		-c "OutlinerWindow";

	menuItem -ecr false -label (uiRes("m_WindowMenu.kNodeEditorLabel"))  
		-annotation 
        (uiRes("m_WindowMenu.kNodeEditorAnnot")) 
		-c "NodeEditorWindow";

	string $hyperOverlay = (uiRes("m_WindowMenu.kHypergraphOverlayLabel"));
	menuItem -ecr false -label (uiRes("m_WindowMenu.kHypergraphHierarchyLabel"))  
		-annotation 
        (uiRes("m_WindowMenu.kHypergraphHierarchyAnnot")) 
		-imageOverlayLabel $hyperOverlay
		-image "hypergraph.png"
		-c "HypergraphHierarchyWindow";

    menuItem -optionBox true 
        -annotation (uiRes("m_WindowMenu.kHyperGraphOptionsAnnot"))
        -command "hyperGraphOptions DAG";

	menuItem -ecr false -label (uiRes("m_WindowMenu.kHypergraphDGLabel"))  
		-annotation 
        (uiRes("m_WindowMenu.kHypergraphDGAnnot")) 
		-imageOverlayLabel $hyperOverlay
		-image "hypergraph.png"
		-c "HypergraphDGWindow";

    menuItem -optionBox true 
        -annotation (uiRes( "m_WindowMenu.kHyperGraphOptionsAnnot"))
        -command "hyperGraphOptions DG";

	menuItem -divider true -ld false;

	if (`licenseCheck -m "edit" -typ "particlePaint"`) {
		menuItem -ecr false -label (uiRes("m_WindowMenu.kPFX3DLabel"))  
			-annotation 
            (uiRes("m_WindowMenu.kPFX3DAnnot")) 
			-c "PaintEffectsWindow";
	} else {
		menuItem -ecr false -label (uiRes("m_WindowMenu.kPFX2DLabel"))  
			-annotation 
            (uiRes("m_WindowMenu.kPFX2DAnnot")) 
			-c "PaintEffectsWindow";
	}		

	$gMiInteractionEditorMenuAfter = `menuItem -ecr false 
        -label (uiRes("m_WindowMenu.kUVTexEdLabel"))  
		-annotation 
        (uiRes("m_WindowMenu.kUVTexEdAnnot")) 
		-image "textureEditor.png"
		-c "TextureViewWindow"`;

	if( `isTrue AnimationExists` ) {
		menuItem -divider true -ld false;
		menuItem -label (uiRes("m_WindowMenu.kPlayblastLabel"))  
			-annotation (uiRes("m_WindowMenu.kPlayblastAnnot")) 
			-image "playblast.png"
			-c "PlayblastWindow" playblastItem;
		menuItem -optionBox true 
			-annotation (uiRes("m_WindowMenu.kPlayblastDialogAnnot"))
            -c "PlayblastOptions" playblastDialogItem;
	} 

}
