// Copyright (C) 1997-2014 Autodesk, Inc., and/or its licensors.
// All rights reserved.
//
// The coded instructions, statements, computer programs, and/or related
// material (collectively the "Data") in these files contain unpublished
// information proprietary to Autodesk, Inc. ("Autodesk") and/or its licensors,
// which is protected by U.S. and Canadian federal copyright law and by
// international treaties.
//
// The Data is provided for use exclusively by You. You have the right to use,
// modify, and incorporate this Data into other products for purposes authorized 
// by the Autodesk software license agreement, without fee.
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND. AUTODESK
// DOES NOT MAKE AND HEREBY DISCLAIMS ANY EXPRESS OR IMPLIED WARRANTIES
// INCLUDING, BUT NOT LIMITED TO, THE WARRANTIES OF NON-INFRINGEMENT,
// MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE, OR ARISING FROM A COURSE 
// OF DEALING, USAGE, OR TRADE PRACTICE. IN NO EVENT WILL AUTODESK AND/OR ITS
// LICENSORS BE LIABLE FOR ANY LOST REVENUES, DATA, OR PROFITS, OR SPECIAL,
// DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES, EVEN IF AUTODESK AND/OR ITS
// LICENSORS HAS BEEN ADVISED OF THE POSSIBILITY OR PROBABILITY OF SUCH DAMAGES.

//-----------------------------------------------------------------------
//
//  Creation Date:  January 16, 2003
//
//  Procedure Name:
//      cleanUp_CheckInterrupt
//
//  Description:
//
//		Utility function used by the various components of the
//		"Optimize Scene Size" function (otherwise known as scene cleanup).
//
//		This function is called between cleanup operations to decide
//		whether or not Maya should continue running remaining cleanup
//		operations or not.
//
//		For example, if the user interrupts the first step (removal of
//		invalid NURBS, say), then they might want to either skip all the
//		remaining steps, or continue running them normally.  
//
//		When this proc is called, if the last scene cleanup operation
//		was interrupted, then the user will be presented with a dialog
//		box asking if they wish to continue or terminate the rest of the
//		cleanup process.  If they requested that the remaining steps be
//		skipped, this procedure returns 0, otherwise it returns 1.  If 
//		the last cleanup operation was not interrupted, this routine will
//		always return 1 to indicate that the next step should begin.
//
//  Input Arguments: None
//
//	Return Value: 
//
//		1 if the next cleanup operation should proceed
//		0 if all remaining cleanup operations should be skipped, as per
//		  the user's instruction.
//
//	Related Functions:
//
//		cleanUp_StartProgress() - called before an operation begins
//		cleanUp_SetProgress() - called as the operation is running, to 
//								update the progress bar.
//		cleanUp_EndProgress() - called to signal that the operation is 
//								finished.
//		cleanUp_CheckInterrupt() - called between cleanup operations to
//								   detect when a previous operation has
//								   been interrupted.
//		cleanUp_Summary() - called to report the results of cleanup 
//							operations.
//
//
//	Notes:
//
//		- This routine uses the $gCleanUpInterrupted global variable to
//		  keep track of whether or not operations should continue.  If
//		  The user interrupts an operation, the variable is set to 1.  If
//		  they then request that the remaining steps be skipped, the variable
//		  is set to 2.  When the cleanup process first starts running, the
//		  variable is initialized to 0 to indicate that nothing has been
//		  interrupted yet.
//
//		- Unfortunately, the confirmation dialog that this routine presents
//		  to determine if the user wants to continue or abort the remaining
//		  steps has *3* buttons instead of the standard 2.  The reason for
//		  the third button is the fact that the confirmDialog box is
//		  programmed to respond to the ESC key as if the user had pressed
//		  one of the buttons in the dialog (typically, ENTER=Accept, ESC=Cancel).
//		  Unfortunately, with interruptable scene cleanup operations,
//		  the user is pressing ESC a lot, so the likelihood of an extra ESC
//		  keypress being in the queue when the dialog comes up is quite high.
//		  As a result, the dialog assumes that the user hit the Cancel button,
//		  and the remaining cleanup steps are skipped.  The purpose of the 
//		  third button (labelled "_") is simply to catch the ESC keystrokes.
//		  If that button is "pressed", the dialog simply comes up again.
//
//-----------------------------------------------------------------------
global proc int cleanUp_CheckInterrupt()
{
   	global int $gCleanUpInterrupted;

	if( $gCleanUpInterrupted == 1 )
	{
		//	the last operation was interrupted, so ask the user if they
		//	want to continue with the remaining steps or not.
		//
		string $shouldContinue = "_";
		string $continue = (uiRes("m_cleanUp_CheckInterrupt.kContinue"));
		while( $shouldContinue == "_" )
		{
			//	loop until the user presses something other than the bogus
			//	"_" button
			//
			$shouldContinue = `confirmDialog 
				-title (uiRes("m_cleanUp_CheckInterrupt.kVerifyingAction"))
				-message (uiRes("m_cleanUp_CheckInterrupt.kInterruptionMessage"))
				-button $continue -button "_" -button (uiRes("m_cleanUp_CheckInterrupt.kAbort")) -cancelButton "_"`; 
		}

		if( $shouldContinue == $continue )
		{
			//	if the user wants to continue, reset the $gCleanUpInterrupted variable
			//	to 0
			//
			$gCleanUpInterrupted = 0;
			return 1;
		}
		else
		{
			//	if the user wants to abort, set $gCleanUpInterrupted to the next level (2)
			$gCleanUpInterrupted = 2;
			return 0;
		}
	}
	else if( $gCleanUpInterrupted == 2 )
	{
		//	User has requested that the whole process stop
		//
		return 0;
	}
	else
	{
		//	Nothing has been interrupted.
		//
		return 1;
	}
}

