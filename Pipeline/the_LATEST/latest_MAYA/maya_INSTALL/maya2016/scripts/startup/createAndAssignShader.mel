// Copyright (C) 1997-2014 Autodesk, Inc., and/or its licensors.
// All rights reserved.
//
// The coded instructions, statements, computer programs, and/or related
// material (collectively the "Data") in these files contain unpublished
// information proprietary to Autodesk, Inc. ("Autodesk") and/or its licensors,
// which is protected by U.S. and Canadian federal copyright law and by
// international treaties.
//
// The Data is provided for use exclusively by You. You have the right to use,
// modify, and incorporate this Data into other products for purposes authorized 
// by the Autodesk software license agreement, without fee.
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND. AUTODESK
// DOES NOT MAKE AND HEREBY DISCLAIMS ANY EXPRESS OR IMPLIED WARRANTIES
// INCLUDING, BUT NOT LIMITED TO, THE WARRANTIES OF NON-INFRINGEMENT,
// MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE, OR ARISING FROM A COURSE 
// OF DEALING, USAGE, OR TRADE PRACTICE. IN NO EVENT WILL AUTODESK AND/OR ITS
// LICENSORS BE LIABLE FOR ANY LOST REVENUES, DATA, OR PROFITS, OR SPECIAL,
// DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES, EVEN IF AUTODESK AND/OR ITS
// LICENSORS HAS BEEN ADVISED OF THE POSSIBILITY OR PROBABILITY OF SUCH DAMAGES.

//
//  Creation Date:  Oct 6, 2000
//
//  Description:
//      This script creates menu items to add shaders to an object.
//

global proc showShadingGroupAE(string $shader)
//
//	If the option to show the attribute editor is on, then
//	display the attribute editor for the object $shader.
//
{
	if (`optionVar -q AEpopupWhenCreatingShaders`) {
		string $cmd = ("showEditor " + $shader);
		evalDeferred -lowestPriority $cmd;
	}
}

global proc createAndAssignShader (string $type, string $item)
//
//	Create a shader of the given type and assign it to the
//	given object.
//
//	$type = type of shader
//	$item = object to act on, if empty then use the selection list
//
{
	string $objs[];
	string $assignString = $item;
	if ($item == "") {
		// No object was specified in the call to this procedure, so we will
		// assign the shader to whatever is on the current selection list 
		// instead.
		//
		$objs = `ls -selection`;
		$assignString = (uiRes("m_createAndAssignShader.kSelectedObj"));
	}
	else
	{
		//
		// The $item is always an object, never a component (ie face).
		// If the current selection contains faces of the specified item, then
		// we would rather assign the new shader to the specifically selected
		// faces rather than the object as a whole. In particular, this allows
		// users to select faces of a poly object and use the RMB menu to
		// assign shaders to them.
		// 

		string $selection[] = `ls -selection`;
		int $i;

		string $selFacesMsg = (uiRes("m_createAndAssignShader.kSelectedFaces"));
		for ($i = 0; $i < size($selection); $i++)
		{
			if (`match ($item + "\\.f\\[.*\\]") $selection[$i]` != "")
			{
				// One part of the currently selection is faces of the
				// specified item. We will add the selected faces to the list
				// of objects to which the shader will be assigned.
				//
				$objs[size($objs)] = $selection[$i];
				$assignString = `format -stringArg $item $selFacesMsg`;
			}
		}

		if (size($objs) == 0)
		{
			// Try again with the shape. Face selection will be names
			// after the shape when other shapes are parented below the
			// transform.
			string $shapes[] = `listRelatives -s $item`;
			if (size($shapes) > 0 )
			{
				string $shape = $shapes[0];
				for ($i = 0; $i < size($selection); $i++)
				{
					if (`match ($shape + "\\.f\\[.*\\]") $selection[$i]` != "")
					{
						$objs[size($objs)] = $selection[$i];
						$assignString = `format -stringArg $shape $selFacesMsg`;
					}
				}
			}
		}

		if (size($objs) == 0)
		{
			// There were no faces of the specified item in the current
			// selection. Therefore, we will assign the shader to the entire
			// object specified.
			//
			$objs[0] = $item;
		}
	}

    // TO DO: decide how to handle protein types...
    string $material;
    string $typeBuffer[];
    int $numTokens = `tokenize $type "/" $typeBuffer`;
    
    if($numTokens > 1 && $typeBuffer[0] == "adskMaterial")
    {
        $material = `shadingNode -asShader $typeBuffer[0]`;
        adskAsset -assetID $typeBuffer[1] $material;
    }
    else
    	$material = `shadingNode -asShader $type`;

	$sg = `sets -renderable true -noSurfaceShader true 
				-empty -name ($material + "SG")`;

	// Connect the material to the shading group
	//
	defaultNavigation 
		-connectToExisting 
		-source $material
		-destination $sg;

	// Select the items to which the shading group is to be assigned.
	//
	select -r $objs;

	// Assign the shading group to the selected objects.
	//
	if ($type == "dx11Shader" && `optionVar -exists "dx11ShaderDefaultEffect"`)
	{
		string $defaultShader = `optionVar -q "dx11ShaderDefaultEffect"`;
		string $cmd = ("setAttr -type \"string\" " + $material + ".shader \"" + $defaultShader + "\"");
		evalEcho $cmd;
	}
	else if ( $type == "ShaderfxShader" || $type == "StingrayPBS" )
	{
		global string $gShaderFXGraphToAssign;
		eval( "shaderfx -sfxnode \"" + $material + "\" -loadGraph \"" + $gShaderFXGraphToAssign + "\";" );
		eval( "shaderfx -sfxnode \"" + $material + "\" -initShaderAttributes;" );
	}
	if( $type == "oceanShader" ){
		connectAttr -f ($material + ".displacement") ($sg + ".displacementShader");
		connectAttr -f "time1.outTime" ($material + ".time");
		assignOceanShader $sg;
	} else {
		hyperShade -assign $sg;
	}
	if( $type == "fluidShape" ){
		connectAttr -f "time1.outTime" ($material + ".currentTime");
	}

	string $message = (uiRes("m_createAndAssignShader.kCreatedShader"));
	$message = `format -stringArg $type -stringArg $assignString $message`;
	print ("// " + $message + " //\n");

	showShadingGroupAE($sg);
} 

global proc assignCreatedShader(string $type, string $item, string $node, string $selObjs)
//
//	Assign the given shader of the given type to the given object(s).
//
//	$type = type of shader
//	$item = object to act on, if empty then use the selection list
//	$node = the shader
//	$selObjs = string containing the selection list
//
{
	string $objs[];
	$objs = stringToStringArray($selObjs, " ");

	string $assignString = $item;
	if ($item == "") {
		// No object was specified in the call to this procedure, so we will
		// assign the shader to whatever is on the current selection list 
		// instead.
		//
		$assignString = (uiRes("m_createAndAssignShader.kSelectedObj"));
	}
	else
	{
		//
		// The $item is always an object, never a component (ie face).
		// If the current selection contains faces of the specified item, then
		// we would rather assign the new shader to the specifically selected
		// faces rather than the object as a whole. In particular, this allows
		// users to select faces of a poly object and use the RMB menu to
		// assign shaders to them.
		// 

		int $i;
		string $selFacesMsg = (uiRes("m_createAndAssignShader.kSelectedFaces"));
		string $shapes[] = `listRelatives -s $item`;

		for ($i = 0; $i < size($objs); $i++)
		{
			if (`match ($item + "\\.f\\[.*\\]") $objs[$i]` != "")
			{
				// One part of the currently selection is faces of the
				// specified item. We will add the selected faces to the list
				// of objects to which the shader will be assigned.
				//
				$assignString = `format -stringArg $item $selFacesMsg`;
			} else {
				// Try again with the shape. Face selection will be names
				// after the shape when other shapes are parented below the
				// transform.
				if (size($shapes) > 0 )
				{
					string $shape = $shapes[0];
					if (`match ($shape + "\\.f\\[.*\\]") $objs[$i]` != "")
					{
						$assignString = `format -stringArg $shape $selFacesMsg`;
					}
				}
			}
		}
	}

	// Get the name of the shading group.
	//
	$sg = $node + "SG";

	// Create the shading group if it doesn't exist
	//
	if(!`objExists $sg`) {
		$sg = `sets -renderable true -noSurfaceShader true 
				-empty -name ($node + "SG")`;

		// Connect the material to the shading group
		//
		defaultNavigation 
			-connectToExisting 
			-source $node
			-destination $sg;

		if( $type == "oceanShader" ){
			// Additionally hook up to displacement
			//
			connectAttr -f ($node + ".displacement") ($sg + ".displacementShader");
			connectAttr -f "time1.outTime" ($node + ".time");
		}
	}

	if(size($objs) > 0) {
		// Case 1: There are selected objects to assign to.

		// Select the items to which the shading group is to be assigned.
		//
		select -r $objs;

		// Assign the shading group to the selected objects.
		//
		if( $type == "oceanShader" ){
			assignOceanShader $sg;
		} else {
			hyperShade -assign $sg;
		}

		string $message = (uiRes("m_createAndAssignShader.kCreatedShader"));
		$message = `format -stringArg $type -stringArg $assignString $message`;
		print ("// " + $message + " //\n");
	} else {
		// Case 2: There are no selected objects to assign to.

		// Clear the selection since it will be on the created shader,
		// and we don't want the Assign New Material window to pick
		// that up as the selection.
		//
		select -clear;

		string $message = (uiRes("m_createAndAssignShader.kCreateNoAssignWarning"));
		$message = `format -stringArg $type $message`;
		warning $message;
	}

	showShadingGroupAE($sg);

	// Close the Assign New Material window unless the lock button
	// has been selected, indicating that the window is to be kept
	// open after assigning a new material.
	//
	global string $gAssignNewMaterialWindowLockButton;
	if (`window -exists assignNewMaterialWindow` 
		&& `iconTextCheckBox -exists $gAssignNewMaterialWindowLockButton`
		&& !`iconTextCheckBox -q -value $gAssignNewMaterialWindowLockButton`)
	{
		window -e -vis false assignNewMaterialWindow;
	}
}
