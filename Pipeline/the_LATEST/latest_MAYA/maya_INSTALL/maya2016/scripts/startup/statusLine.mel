// Copyright (C) 1997-2014 Autodesk, Inc., and/or its licensors.
// All rights reserved.
//
// The coded instructions, statements, computer programs, and/or related
// material (collectively the "Data") in these files contain unpublished
// information proprietary to Autodesk, Inc. ("Autodesk") and/or its licensors,
// which is protected by U.S. and Canadian federal copyright law and by
// international treaties.
//
// The Data is provided for use exclusively by You. You have the right to use,
// modify, and incorporate this Data into other products for purposes authorized 
// by the Autodesk software license agreement, without fee.
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND. AUTODESK
// DOES NOT MAKE AND HEREBY DISCLAIMS ANY EXPRESS OR IMPLIED WARRANTIES
// INCLUDING, BUT NOT LIMITED TO, THE WARRANTIES OF NON-INFRINGEMENT,
// MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE, OR ARISING FROM A COURSE 
// OF DEALING, USAGE, OR TRADE PRACTICE. IN NO EVENT WILL AUTODESK AND/OR ITS
// LICENSORS BE LIABLE FOR ANY LOST REVENUES, DATA, OR PROFITS, OR SPECIAL,
// DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES, EVEN IF AUTODESK AND/OR ITS
// LICENSORS HAS BEEN ADVISED OF THE POSSIBILITY OR PROBABILITY OF SUCH DAMAGES.

//
//
//  Creation Date:  26 Feb 1996
//
//  Description:
//      This procedure creates the status line.
//
//  Input Arguments:
//      The parent control that the status line will be created in.
//
//  Return Value:
//      The name of the top layout created.
//		Used for embedding the status line within another layout.
//

////////////////////////////////////////////////////////////////
//  Expand/collapse procedures section
///////////////////////////////////////////////////////////////

proc string getOpenOrCloseBarIcon(int $openBar)
//
// Returns string of Icon to display based on value of $openBar
//
{
	if ($openBar) {
		return "openBar.png";
	}
	else {
		return "closeBar.png";
	}
}

global proc toggleFileIcons (int $arg)
//
// Show and Hide the file icons
// $arg=1 means show, 0 means hide, -1 means use optionVar
//
{
	global string $gStatusLine;
	setParent $gStatusLine;

	int $state = $arg;
	if ($state < 0) $state = (!`optionVar -q showStatusFiles`);

	iconTextButton -edit -manage $state newSceneButton;
	iconTextButton -edit -manage $state openSceneButton;
	iconTextButton -edit -manage $state saveSceneButton;
	iconTextButton -edit -manage $state undoButton;
	iconTextButton -edit -manage $state redoButton;
	string $icon = getOpenOrCloseBarIcon($state);
	iconTextButton -edit -i1 $icon fileCollapse;
	optionVar -intValue "showStatusFiles" $state;
}

global proc toggleSnapIcons (int $arg)
//
// Show and Hide the snapping icons
// $arg=1 means show, 0 means hide, -1 means use optionVar
//
{
	global string $gStatusLine;
	setParent $gStatusLine;

	int $state = $arg;
	if ($state < 0) $state = (!`optionVar -q showStatusSnap`);

	formLayout -edit -manage $state snapIcons;
	string $icon = getOpenOrCloseBarIcon($state);
	iconTextButton -edit -i1 $icon snapCollapse;
	optionVar -intValue "showStatusSnap" $state;
}

global proc toggleRenderIcons (int $arg)
//
// Show and Hide the rendering icons
// $arg=1 means show, 0 means hide, -1 means use optionVar
//
{
	global string $gStatusLine;
	setParent $gStatusLine;

	int $state = $arg;
	if ($state < 0) $state = (!`optionVar -q showStatusRender`);
	iconTextButton -edit -manage $state renderViewButton;
	iconTextButton -edit -manage $state renderButton;
	iconTextButton -edit -manage $state iprRenderButton;
	iconTextButton -edit -manage $state renderGlobalsButton;
	iconTextButton -edit -manage $state hypershadeButton;
	string $icon = getOpenOrCloseBarIcon($state);
	iconTextButton -edit -i1 $icon renderCollapse;

	optionVar -intValue "showStatusRender" $state;
}


global proc toggleInputField (int $arg)
//
// Show and Hide the input fields
// $arg=1 means show, 0 means hide, -1 means use optionVar
//
{
	global string $gTextualInputField;
	global string $gNumericalInputXField;
	global string $gNumericalInputYField;
	global string $gNumericalInputZField;
	global string $gStatusLine;
	setParent $gStatusLine;

	// Use image to figure out which fields to show/hide
	//
	string $image = `iconTextButton -query -image1 statusFieldButton`;

	int $state = $arg;
	if ($state < 0) $state = (!`optionVar -q showStatusInputField`);

	iconTextButton -edit -manage $state statusFieldButton;
	
	if ("quickRename.png" == $image || "quickSelect.png" == $image) {
		textField -edit -manage $state $gTextualInputField;
	} else {
		text -edit -manage $state numericalInputXLabel;
		textField -edit -manage $state $gNumericalInputXField;
		text -edit -manage $state numericalInputYLabel;
		textField -edit -manage $state $gNumericalInputYField;
		text -edit -manage $state numericalInputZLabel;
		textField -edit -manage $state $gNumericalInputZField;
	}
	
	string $icon = getOpenOrCloseBarIcon($state);
	iconTextButton -edit -i1 $icon inputFieldCollapse;

	optionVar -intValue "showStatusInputField" $state;
}

global proc toggleHistoryIcons (int $arg)
//
// Show and Hide the history icons
// $arg=1 means show, 0 means hide, -1 means use optionVar
//
{
	global string $gStatusLine;
	setParent $gStatusLine;

	int $state = $arg;
	if ($state < 0) $state = (!`optionVar -q showStatusHistory`);
	formLayout -edit -manage $state historyLayout;
	string $icon = getOpenOrCloseBarIcon($state);
	iconTextButton -edit -i1 $icon historyCollapse;

	optionVar -intValue "showStatusHistory" $state;
}

global proc toggleSelectionSetIcons (int $arg)
//
// Show and Hide the selection set icons
// $arg=1 means show, 0 means hide, -1 means use optionVar
//
{
	global string $gStatusLine;
	setParent $gStatusLine;

	int $state = $arg;
	if ($state < 0) $state = (!`optionVar -q showStatusSelectionSet`);
	formLayout -edit -manage $state presetForm;
	string $icon = getOpenOrCloseBarIcon($state);
	iconTextButton -edit -i1 $icon selectionSetCollapse;

	optionVar -intValue "showStatusSelectionSet" $state;
}

global proc toggleSelectModeIcons (int $arg)
//
// Show and Hide the select mode icons
// $arg=1 means show, 0 means hide, -1 means use optionVar
//
{
	global string $gStatusLine;
	setParent $gStatusLine;

	int $state = $arg;
	if ($state < 0) $state = (!`optionVar -q showStatusSelectMode`);

	formLayout -edit -manage $state masksForm;
	string $icon = getOpenOrCloseBarIcon($state);
	iconTextButton -edit -i1 $icon selectModeCollapse;

	optionVar -intValue "showStatusSelectMode" $state;
}

global proc toggleSelectMaskIcons (int $arg)
//
// Show and Hide the select options icons
// $arg=1 means show, 0 means hide, -1 means use optionVar
//
{
	global string $gStatusLine;
	setParent $gStatusLine;

	int $state = $arg;
	if ($state < 0) $state = (!`optionVar -q showStatusSelectMasks`);

	formLayout -edit -manage $state selectMaskForm;
	iconTextCheckBox -edit -manage $state lockSelectionIcon;
	iconTextCheckBox -edit -manage $state highlightSelectIcon;
	
	string $icon = getOpenOrCloseBarIcon($state);
	iconTextButton -edit -i1 $icon selectMasksCollapse;

	optionVar -intValue "showStatusSelectMasks" $state;
}

////////////////////////////////////////////////////////////////
//  Update procedures section
///////////////////////////////////////////////////////////////

global proc updateLockSelectionIcon( )
//
// Toggles the state of the locked selection icon,
// and the state of -xformNoSelect
{
	if( `selectPref -q -xformNoSelect` == 0)
	{
		selectPref -xformNoSelect 1;
		iconTextCheckBox -e
			-v 1
			-annotation (uiRes("m_statusLine.kUnlockCurrentAnnot"))
			lockSelectionIcon;
	} else {
		selectPref -xformNoSelect 0;
		iconTextCheckBox -e
			-v 0
			-annotation (uiRes("m_statusLine.kLockCurrentAnnot"))
			lockSelectionIcon;
	}
}


global proc toggleHighlightSelectIcon()
{
	int $newState = !`selectPref -q -allowHiliteSelection`;
	selectPref -allowHiliteSelection $newState;
	updateHighlightSelectIcon;
}

global proc updateHighlightSelectIcon()
{
	int $currentState = `selectPref -q -allowHiliteSelection`;

	if ($currentState == 0) {
		// Highlight select is off, so push the button in
		iconTextCheckBox -e -v 1
			-annotation (uiRes("m_statusLine.kHighlightOffAnnot"))
			highlightSelectIcon;
	} else {
		// Highlight select is on, so push the button out
		iconTextCheckBox -e -v 0
			-annotation (uiRes("m_statusLine.kHighlightOnAnnot"))
			highlightSelectIcon;
	}
}

// Adds a close button to a window.
//
global proc addCloseButton( string $windowName, string $formLayout, string $tabLayout )
{
	setParent $formLayout;

	// Create the close button
	//
	string $attach = `separator`;
	button -width 80 -label (uiRes("m_statusLine.kClose")) closeButton;
	button -edit -command ("deleteUI -window " + $windowName) closeButton;

	// Align it to the form properly
	//
	formLayout -edit
		-attachForm $tabLayout "top" 0
		-attachForm $tabLayout "left" 5
		-attachForm $tabLayout "right" 5
		-attachControl $tabLayout "bottom" 5 $attach

		-attachControl $attach "bottom" 5 closeButton
		-attachForm $attach "left" 5
		-attachForm $attach "right" 5
		-attachNone $attach "top"

		-attachForm closeButton "bottom" 5
		-attachNone closeButton "top"
		-attachNone closeButton "left"
		-attachPosition closeButton "right" 3 62
		$formLayout;

}


global proc setEditMode( )
//
// Sets the edit mode when the tabs on the selection mask window
// are clicked on.
{
	string $currentTab = `tabLayout -q -st maskTabContainer`;
	if( $currentTab == "objMaskFrame" )
	{
		setSelectMode("objects", "Objects");
	}
	else {
		setSelectMode("components", "Components");
	}
}

global proc changeSelectMode( string $mode )
{
	if(`exists modelingTookitActive` && modelingTookitActive())
	{
		if($mode == "-object")
		{
			if(`exists dR_selTypeChanged`) 
			{
				dR_selTypeChanged("object");

				if (size(`ls -hilite -hd 1`)==0)
				{
					dR_exitNex;
				}
			}
		}
	}

	switch( $mode ) {
		case "-hierarchical":
			iconTextCheckBox -e -v 1 selectBtnHierComb;
			iconTextCheckBox -e -v 0 selectBtnObject;
			iconTextCheckBox -e -v 0 selectBtnComponent;
			setSelectMode("hierarchy", "Hierarchy");
			break;
		case "-object":
			iconTextCheckBox -e -v 0 selectBtnHierComb;
			iconTextCheckBox -e -v 1 selectBtnObject;
			iconTextCheckBox -e -v 0 selectBtnComponent;
			setSelectMode("objects", "Objects");
			break;
		case "-component":
			iconTextCheckBox -e -v 0 selectBtnHierComb;
			iconTextCheckBox -e -v 0 selectBtnObject;
			iconTextCheckBox -e -v 1 selectBtnComponent;
			setSelectMode("components", "Components");
			break;
	}

}

global proc setHierSelectMode( string $mode )
{
	if ( ! `selectMode -q $mode` ) {
		selectMode $mode;
	}
	else {
		switch( $mode ) {
			case "-root":
				iconTextCheckBox -e -v 1 hierRootButton;
				break;
			case "-leaf":
				iconTextCheckBox -e -v 1 hierLeafButton;
				break;
			case "-template":
				iconTextCheckBox -e -v 1 hierTemplateButton;
				break;
	//		case "-preset":
	//			iconTextCheckBox -e -v 1 comboModelingButton;
		}
	}
}


global proc updateSelectionIcons( string $selectMode )
//
// Handles updating the selection mode icons in the
// status line.
{
	switch( $selectMode ) {
	case "-byHierarchy":

		int $isRoot = `selectMode -q -root`;
		int $isLeaf = `selectMode -q -leaf`;
		int $isTemplate = `selectMode -q -template`;
//		int $isBranch = `selectMode -q -branch`;
//		iconTextCheckBox -e -v $isBranch hierBranchButton;
		iconTextCheckBox -e -v $isRoot hierRootButton;
		iconTextCheckBox -e -v $isLeaf hierLeafButton;
		iconTextCheckBox -e -v $isTemplate hierTemplateButton;

		// Make sure that only the select by
		// hierarchy button is on.
		//
		iconTextCheckBox -e -v 1 selectBtnHierComb;
		iconTextCheckBox -e -v 0 selectBtnObject;
		iconTextCheckBox -e -v 0 selectBtnComponent;

		formLayout -e -manage 1 hierarchyIcons;
		formLayout -e -manage 0 objectMaskIcons;
		formLayout -e -manage 0 componentMaskIcons;
		text 	   -e -manage 0 comboSelectText;
		// textField -e -tx "Hierarchy" maskField;

		break;

	case "-byObjectType":

		// Make sure that the select by object type
		// button only is on.
		//
		iconTextCheckBox -e -v 0 selectBtnHierComb;
		iconTextCheckBox -e -v 1 selectBtnObject;
		iconTextCheckBox -e -v 0 selectBtnComponent;

		//
		// Flip the visibility of the object
		// and component mask icons
		//
		formLayout -e -manage 1 objectMaskIcons;
		formLayout -e -manage 0 hierarchyIcons;
		formLayout -e -manage 0 componentMaskIcons;
		text 	   -e -manage 0 comboSelectText;
		// textField -e -tx "Objects" maskField;

		break;

	case "-byCompType":

		// Make sure that the select by component
		// type button is the only one on.
		iconTextCheckBox -e -v 0 selectBtnHierComb;
		iconTextCheckBox -e -v 0 selectBtnObject;
		iconTextCheckBox -e -v 1 selectBtnComponent;

		//
		// Flip the visibility of the object
		// and component mask icons
		//
		formLayout -e -manage 1 componentMaskIcons;
		formLayout -e -manage 0 hierarchyIcons;
		formLayout -e -manage 0 objectMaskIcons;
		text 	   -e -manage 0 comboSelectText;
		// textField -e -tx "Components" maskField;

		break;

	case "-byPreset":

		// Make sure that the select by hierarchy
		// type button is the only one on.
		iconTextCheckBox -e -v 0 selectBtnHierComb;
		iconTextCheckBox -e -v 1 selectBtnObject;
		iconTextCheckBox -e -v 1 selectBtnComponent;

		//
		// Flip the visibility of the object
		// and component mask icons
		//
		text 	   -e -manage 1 comboSelectText;
		formLayout -e -manage 0 hierarchyIcons;
		formLayout -e -manage 0 objectMaskIcons;
		formLayout -e -manage 0 componentMaskIcons;
		// textField -e -tx "Mixed" maskField;

		break;
	}
}

global proc updateSelectionModeIcons()
// This routine is called by a script job when the selection mode changes
{
	if ( `selectMode -q -object` ) {
		updateSelectionIcons -byObjectType;
	}
	else if ( `selectMode -q -component` ) {
		updateSelectionIcons -byCompType;
	}
	else if ( `selectMode -q -hierarchical` ) {
		updateSelectionIcons -byHierarchy;
	}
	else if ( `selectMode -q -preset` ) {
		updateSelectionIcons -byPreset;
	}

	string $selectionMode = `getSelectMode`;
	textField -e -tx $selectionMode maskField;
}

global proc updateSelectTypeItemState(string $maskGroup, string $selTypeName)
//
// Handles updating new SelectType item state.
{
	global string $gSelMarkerFilterTypeList[];
	global string $gSelJointFilterTypeList[];
	global string $gSelCurveFilterTypeList[];
	global string $gSelSurfaceFilterTypeList[];
	global string $gSelDeformerFilterTypeList[];
	global string $gSelDynamicFilterTypeList[];
	global string $gSelRenderingFilterTypeList[];
	global string $gSelOtherFilterTypeList[];

	int $maskResult = 0;
	string $selName;
	switch ($maskGroup) {
	case "Marker":
		$maskResult = ( `selectType -q -handle` + `selectType -q -ikHandle` );

		for ($selName in $gSelMarkerFilterTypeList) {
			$maskResult += `selectType -q -queryByName $selName`;
		}
		break;

	case "Joint":
		$maskResult = `selectType -q -joint`;

		for ($selName in $gSelJointFilterTypeList)
		{
			$maskResult += `selectType -q -queryByName $selName`;
		}
		break;

	case "Curve":
		$maskResult = `selectType -q -nurbsCurve`;

		for ($selName in $gSelCurveFilterTypeList) {
			$maskResult += `selectType -q -queryByName $selName`;
		}

		if (`isTrue MayaCreatorExists` && (`licenseCheck -mode "edit" -typ "particlePaint"`)) {
			$maskResult += `selectType -q -stroke`;
		}
		if( `isTrue "SurfaceUIExists"` ) {
			$maskResult += `selectType -q -cos`;
		}
		break;

	case "Surface":
		$maskResult = ( `selectType -q -polymesh` + `selectType -q -plane`);

		for ($selName in $gSelSurfaceFilterTypeList) {
			$maskResult += `selectType -q -queryByName $selName`;
		}

		if ( `isTrue "SurfaceUIExists"` ) {
			$maskResult += `selectType -q -nurbsSurface`;
		}
		if (`isTrue "SubdivUIExists"`) {
			$maskResult += `selectType -q -subdiv`;
		}
		break;

	case "Deformer":
		$maskResult = ( `selectType -q -lattice` +
			`selectType -q -cluster` +
			`selectType -q -sculpt`  +
			`selectType -q -nonlinear` );

		for ($selName in $gSelDeformerFilterTypeList) {
			$maskResult += `selectType -q -queryByName $selName`;
		}
		break;

	case "Dynamic":
		int $isFluids = fluidEditLicenseFound();
		int $isNCloth = nClothEditLicenseFound();
		int $isComplete = `licenseCheck -m edit -type complete`;

		if( $isFluids || $isComplete || $isNCloth ) {

			if( $isFluids || $isNCloth ) {
				$maskResult = ( `selectType -q -particleShape` +
				`selectType -q -emitter` +
				`selectType -q -field` +
				`selectType -q -fluid` +
				`selectType -q -nCloth` +
				`selectType -q -nRigid` +
				`selectType -q -dynamicConstraint` +
				`selectType -q -hairSystem` +
				`selectType -q -follicle` +
				`selectType -q -spring` +
				`selectType -q -rigidBody` +
				`selectType -q -rigidConstraint` );
			} else if( $isComplete ) {
				$maskResult = ( `selectType -q -particleShape` +
				`selectType -q -emitter` +
				`selectType -q -field` +
				`selectType -q -spring` +
				`selectType -q -rigidBody` +
				`selectType -q -rigidConstraint` );
			}

			for ($selName in $gSelOtherFilterTypeList)
			{
				$maskResult += `selectType -q -queryByName $selName`;
			}
		}
		else {
			$maskResult = 1;
		}
			break;

	case "Rendering":
		$maskResult = ( `selectType -q -light` +
						`selectType -q -camera` +
						`selectType -q -texture` );

		for ($selName in $gSelRenderingFilterTypeList)
		{
			$maskResult += `selectType -q -queryByName $selName`;
		}
		break;

	case "Other":
		$maskResult = ( `selectType -q -ikEndEffector` +
			`selectType -q -locator` +
			`selectType -q -dimension` );

		for ($selName in $gSelOtherFilterTypeList) {
			$maskResult += `selectType -q -queryByName $selName`;
		}
		break;

	default:
		$maskResult = 1;
		break;
	}

	if ( $maskResult > 0) {
		selectType -byName $selTypeName 1;
	}
}

global proc updateObjectSelectionMasks( )
//
// Handles updating of ALL object selection icons
// in the toolbar.
{
	// Update the selection mask icons on the toolbar-
	// if any item in the mask is picked, change the
	// icon to signify that something in that mask is
	// selected - if nothing is picked, turn it
	// off.  If all items are picked, then turn
	// the icon on, and make sure the correct icon
	// is displayed.

	global string $gSelMarkerFilterTypeList[];
	global string $gSelJointFilterTypeList[];
	global string $gSelCurveFilterTypeList[];
	global string $gSelSurfaceFilterTypeList[];
	global string $gSelDeformerFilterTypeList[];
	global string $gSelDynamicFilterTypeList[];
	global string $gSelRenderingFilterTypeList[];
	global string $gSelOtherFilterTypeList[];

	// Markers
	//
	int $fullMaskCount = 2;
	int $maskResult = ( `selectType -q -handle` +
						`selectType -q -ikHandle` );

	string $selName;
	for ($selName in $gSelMarkerFilterTypeList)
	{
		$maskResult += `selectType -q -queryByName $selName`;
		$fullMaskCount++;
	}

	if ( $maskResult == 0 ) {
		// they're all off - turn off the icon, and
		// set the correct icon
		//
		iconTextCheckBox -e -v 0 objSelHandleBtn;
		iconTextCheckBox -e -i1 "pickHandlesObj.png" objSelHandleBtn;
	}
	else if ( $maskResult == $fullMaskCount ) {
		// they're all on - turn the icon on, and
		// set the correct icon
		//
		iconTextCheckBox -e -v 1 objSelHandleBtn;
		iconTextCheckBox -e -i1 "pickHandlesObj.png" objSelHandleBtn;
	}
	else {
		// something is on - make sure the icon is
		// on, and set the correct icon
		//
		iconTextCheckBox -e -v 1 objSelHandleBtn;
		iconTextCheckBox -e -i1 "pickHandlesObjPartial.png" objSelHandleBtn;
	}

	// Joint
	//
	$fullMaskCount = 1;
	$maskResult = `selectType -q -joint`;

	for ($selName in $gSelJointFilterTypeList)
	{
		$maskResult += `selectType -q -queryByName $selName`;
		$fullMaskCount++;
	}

	if( 0 == $maskResult ) {
		// they're all off - turn off the icon, and
		// set the correct icon
		//
		iconTextCheckBox -e -v 0 objSelJointBtn;
		iconTextCheckBox -e -i1 "pickJointObj.png" objSelJointBtn;
	}
	else if( $fullMaskCount == $maskResult ) {
		// they're all on - turn the icon on, and
		// set the correct icon
		//
		iconTextCheckBox -e -v 1 objSelJointBtn;
		iconTextCheckBox -e -i1 "pickJointObj.png" objSelJointBtn;
	}
	else {
		// something is on - make sure the icon is
		// on, and set the correct icon
		//
		iconTextCheckBox -e -v 1 objSelJointBtn;
		iconTextCheckBox -e -i1 "pickJointObjPartial.png" objSelJointBtn;
	}

	// Curves
	//
	$fullMaskCount = 1;
	$maskResult = `selectType -q -nurbsCurve`;

	for ($selName in $gSelCurveFilterTypeList)
	{
		$maskResult += `selectType -q -queryByName $selName`;
		$fullMaskCount++;
	}

	if (`isTrue MayaCreatorExists` && (`licenseCheck -mode "edit" -typ "particlePaint"`)) {
		$maskResult += `selectType -q -stroke`;
		$fullMaskCount ++;
	}
	if( `isTrue "SurfaceUIExists"` ) {
		$maskResult += `selectType -q -cos`;
		$fullMaskCount ++;
	}

	if( 0 == $maskResult ) {
		// they're all off - turn off the icon, and
		// set the correct icon
		//
		iconTextCheckBox -e -v 0 objSelCurveBtn;
		iconTextCheckBox -e -i1 "pickCurveObj.png" objSelCurveBtn;
	}
	else if( $fullMaskCount == $maskResult ) {
		// they're all on - turn the icon on, and
		// set the correct icon
		//
		iconTextCheckBox -e -v 1 objSelCurveBtn;
		iconTextCheckBox -e -i1 "pickCurveObj.png" objSelCurveBtn;
	}
	else {
		// something is on - make sure the icon is
		// on, and set the correct icon
		//
		iconTextCheckBox -e -v 1 objSelCurveBtn;
		iconTextCheckBox -e -i1 "pickCurveObjPartial.png" objSelCurveBtn;
	}

	// Surfaces
	//
	$maskResult = ( `selectType -q -polymesh` +
					`selectType -q -plane`);
	$fullMaskCount = 2;

	for ($selName in $gSelSurfaceFilterTypeList)
	{
		$maskResult += `selectType -q -queryByName $selName`;
		$fullMaskCount++;
	}

	if ( `isTrue "SurfaceUIExists"` ) {
		$maskResult += `selectType -q -nurbsSurface`;
		$fullMaskCount++;
	}
	if (`isTrue "SubdivUIExists"`) {
		$maskResult += `selectType -q -subdiv`;
		$fullMaskCount++;
	}

	if ( $maskResult == 0 ) {
		// they're all off - turn off the icon, and
		// set the correct icon
		//
		iconTextCheckBox -e -v 0 objSelSurfaceBtn;
		iconTextCheckBox -e -i1 "pickGeometryObj.png" objSelSurfaceBtn;
	}
	else if ( $maskResult == $fullMaskCount ) {
		// they're all on - turn the icon on, and
		// set the correct icon
		//
		iconTextCheckBox -e -v 1 objSelSurfaceBtn;
		iconTextCheckBox -e -i1 "pickGeometryObj.png" objSelSurfaceBtn;
	}
	else {
		// something is on - make sure the icon is
		// on, and set the correct icon
		//
		iconTextCheckBox -e -v 1 objSelSurfaceBtn;
		iconTextCheckBox -e -i1 "pickGeometryObjPartial.png" objSelSurfaceBtn;
	}

	// Deformations
	//
	$maskResult = ( `selectType -q -lattice` +
					`selectType -q -cluster` +
					`selectType -q -sculpt`  +
					`selectType -q -nonlinear` );

	$fullMaskCount = 4;

	for ($selName in $gSelDeformerFilterTypeList)
	{
		$maskResult += `selectType -q -queryByName $selName`;
		$fullMaskCount++;
	}

	if( $maskResult == 0 ) {
		// they're all off - turn off the icon, and
		// set the correct icon
		//
		iconTextCheckBox -e -v 0 objSelDeformBtn;
		iconTextCheckBox -e -i1 "pickDeformerObj.png" objSelDeformBtn;
	}
	else if ( $maskResult == $fullMaskCount ) {
		// they're all on - turn the icon on, and
		// set the correct icon
		//
		iconTextCheckBox -e -v 1 objSelDeformBtn;
		iconTextCheckBox -e -i1 "pickDeformerObj.png" objSelDeformBtn;
	}
	else {
		// something is on - make sure the icon is
		// on, and set the correct icon
		//
		iconTextCheckBox -e -v 1 objSelDeformBtn;
		iconTextCheckBox -e -i1 "pickDeformerObjPartial.png" objSelDeformBtn;
	}

	// Dynamics
	//
	// If the user is licensed to use dynamics, set the icons
	// accordingly, otherwise turn them off.
	//
	int $isFluids = fluidEditLicenseFound();
	int $isNCloth = nClothEditLicenseFound();
	int $isComplete = `licenseCheck -m edit -type complete`;
	$fullMaskCount = 0;

	if( $isFluids || $isComplete || $isNCloth ) {

		if( $isFluids || $isNCloth ) {
			$maskResult = ( `selectType -q -particleShape` +
			`selectType -q -emitter` +
			`selectType -q -field` +
			`selectType -q -fluid` +
			`selectType -q -nCloth` +
			`selectType -q -nRigid` +
			`selectType -q -dynamicConstraint` +
			`selectType -q -hairSystem` +
			`selectType -q -follicle` +
			`selectType -q -spring` +
			`selectType -q -rigidBody` +
			`selectType -q -rigidConstraint` );
			$fullMaskCount += 12;
		} else if( $isComplete ) {
			$maskResult = ( `selectType -q -particleShape` +
			`selectType -q -emitter` +
			`selectType -q -field` +
			`selectType -q -spring` +
			`selectType -q -rigidBody` +
			`selectType -q -rigidConstraint` );
			$fullMaskCount += 6;
		}

		for ($selName in $gSelOtherFilterTypeList)
		{
			$maskResult += `selectType -q -queryByName $selName`;
			$fullMaskCount++;
		}

		// they're all off - turn off the icon, and
		// set the correct icon
		//
		if( $maskResult == 0 ) {
			iconTextCheckBox -e -v 0 objSelDynamicBtn;
			iconTextCheckBox -e -i1 "pickDynamicsObj.png" objSelDynamicBtn;
		}
		// they're all on - turn the icon on, and
		// set the correct icon
		//
		else if( $maskResult == $fullMaskCount ) {
			iconTextCheckBox -e -v 1 objSelDynamicBtn;
			iconTextCheckBox -e -i1 "pickDynamicsObj.png" objSelDynamicBtn;
		}
		// something is on - make sure the icon is
		// on, and set the correct icon
		//
		else {
			iconTextCheckBox -e -v 1 objSelDynamicBtn;
			iconTextCheckBox -e -i1 "pickDynamicsObjPartial.png" objSelDynamicBtn;

		}
	}
	else
	{
		iconTextCheckBox -e -v 0 objSelDynamicBtn;
		iconTextCheckBox -e -i1 "pickDynamicsObj.png" objSelDynamicBtn;
	}

	// Rendering
	//
	$fullMaskCount = 3;
	$maskResult = ( `selectType -q -light` +
					`selectType -q -camera` +
					`selectType -q -texture` );

	for ($selName in $gSelRenderingFilterTypeList)
	{
		$maskResult += `selectType -q -queryByName $selName`;
		$fullMaskCount++;
	}

	if( $maskResult == 0 ) {
		// they're all off - turn off the icon, and
		// set the correct icon
		//
		iconTextCheckBox -e -v 0 objSelRenderBtn;
		iconTextCheckBox -e -i1 "pickRenderingObj.png" objSelRenderBtn;
	}
	else if ( $maskResult == $fullMaskCount ) {
		// they're all on - turn the icon on, and
		// set the correct icon
		//
		iconTextCheckBox -e -v 1 objSelRenderBtn;
		iconTextCheckBox -e -i1 "pickRenderingObj.png" objSelRenderBtn;
	}
	else {
		// something is on - make sure the icon is
		// on, and set the correct icon
		//
		iconTextCheckBox -e -v 1 objSelRenderBtn;
		iconTextCheckBox -e -i1 "pickRenderingObjPartial.png" objSelRenderBtn;
	}

	// Other
	//
	$fullMaskCount = 3;
	$maskResult = ( `selectType -q -ikEndEffector` +
					`selectType -q -locator` +
					`selectType -q -dimension` );

	for ($selName in $gSelOtherFilterTypeList)
	{
		$maskResult += `selectType -q -queryByName $selName`;
		$fullMaskCount++;
	}

	if ( $maskResult == 0 ) {
		// they're all off - turn off the icon, and
		// set the correct icon
		//
		iconTextCheckBox -e -v 0 objSelMiscBtn;
		iconTextCheckBox -e -i1 "pickOtherObj.png" objSelMiscBtn;
	}
	else if ( $maskResult == $fullMaskCount ) {
		// they're all on - turn the icon on, and
		// set the correct icon
		//
		iconTextCheckBox -e -v 1 objSelMiscBtn;
		iconTextCheckBox -e -i1 "pickOtherObj.png" objSelMiscBtn;
	}
	else {
		// something is on - make sure the icon is
		// on, and set the correct icon
		//
		iconTextCheckBox -e -v 1 objSelMiscBtn;
		iconTextCheckBox -e -i1 "pickOtherObjPartial.png" objSelMiscBtn;
	}
	string $selectionMode = `getSelectMode`;
	textField -e -tx $selectionMode maskField;
}


global proc updateComponentSelectionMasks( )
//
// Handles updating of ALL component selection icons
// in the toolbar.
{
	// Update the selection mask icons - if any
	// item in the mask is picked, change the icon
	// to signify that something in that mask is
	// selected - if nothing is picked, turn it
	// off.  If all items are picked, then turn
	// the icon on, and make sure the correct icon
	// is displayed.

	// Points
	//
	int $maskResult = ( `selectType -q -cv` +
						`selectType -q -polymeshVertex` +
						`selectType -q -latticePoint` +
						`selectType -q -particle`);

	int $fullMaskCount = 4;

	if( `isTrue "SubdivUIExists"` ) {
		$maskResult += `selectType -q -subdivMeshPoint`;
		$fullMaskCount++;
	}

	if ( $maskResult == 0 ) {
		// they're all off - turn off the icon, and
		// set the correct icon
		//
		iconTextCheckBox -e -v 0 compSelPointBtn;
		iconTextCheckBox -e -i1 "pickPointComp2.png" compSelPointBtn;
	}
	else if ( $maskResult == $fullMaskCount ) {
		// they're all on - turn the icon on, and
		// set the correct icon
		//
		iconTextCheckBox -e -v 1 compSelPointBtn;
		iconTextCheckBox -e -i1 "pickPointComp2.png" compSelPointBtn;
	}
	else {
		// something is on - make sure the icon is
		// on, and set the correct icon
		//
		iconTextCheckBox -e -v 1 compSelPointBtn;
		iconTextCheckBox -e -i1 "pickPointComp2Partial.png" compSelPointBtn;
	}

	// Parm Points
	//
	$fullMaskCount = 5;
	$maskResult = ( `selectType -q -editPoint` +
						`selectType -q -curveParameterPoint` +
						`selectType -q -surfaceParameterPoint` +
						`selectType -q -puv` +
						`selectType -q -surfaceUV`);

	if( `isTrue "SubdivUIExists"` ) {
		$maskResult += `selectType -q -smu`;
		$fullMaskCount++;
	}

	if( $maskResult == 0 ) {
			// they're all off - turn off the icon, and
			// set the correct icon
			//
			iconTextCheckBox -e -v 0 compSelParmPointBtn;
			iconTextCheckBox -e -i1 "pickPointComp.png" compSelParmPointBtn;
	}
	else if ( $maskResult == $fullMaskCount ) {
			// they're all on - turn the icon on, and
			// set the correct icon
			//
			iconTextCheckBox -e -v 1 compSelParmPointBtn;
			iconTextCheckBox -e -i1 "pickPointComp.png" compSelParmPointBtn;
	}
	else {
			// something is on - make sure the icon is
			// on, and set the correct icon
			//
			iconTextCheckBox -e -v 1 compSelParmPointBtn;
			iconTextCheckBox -e -i1 "pickPointCompPartial.png" compSelParmPointBtn;
	}

	// Lines
	//
	$maskResult = ( `selectType -q -polymeshEdge` +
					`selectType -q -springComponent`);

	$fullMaskCount = 2;
	if ( `isTrue "SurfaceUIExists"` ) {
		$maskResult += `selectType -q -surfaceEdge`;
		$maskResult += `selectType -q -isoparm`;
		$fullMaskCount+=2;
	}
	if( `isTrue "SubdivUIExists"` ) {
		$maskResult += `selectType -q -subdivMeshEdge`;
		$fullMaskCount++;
	}

	if ( $maskResult == 0 ) {
		// they're all off - turn off the icon, and
		// set the correct icon
		//
		iconTextCheckBox -e -v 0 compSelLineBtn;
		iconTextCheckBox -e -i1 "pickLineComp.png" compSelLineBtn;
	}
	else if ( $maskResult == $fullMaskCount ) {
		// they're all on - turn the icon on, and
		// set the correct icon
		//
		iconTextCheckBox -e -v 1 compSelLineBtn;
		iconTextCheckBox -e -i1 "pickLineComp.png" compSelLineBtn;
	}
	else {
		// something is on - make sure the icon is
		// on, and set the correct icon
		//
		iconTextCheckBox -e -v 1 compSelLineBtn;
		iconTextCheckBox -e -i1 "pickLineCompPartial.png" compSelLineBtn;
	}

	// Faces
	//
	$maskResult = `selectType -q -facet` + `selectType -q -surfaceFace`;
	$fullMaskCount = 2;

	if( `isTrue "SubdivUIExists"` ) {
		$maskResult += `selectType -q -subdivMeshFace`;
		$fullMaskCount++;
	}

	if ( $maskResult == 0 ) {
		iconTextCheckBox -e -v 0 compSelFaceBtn;
		iconTextCheckBox -e -i1 "pickFacetComp.png" compSelFaceBtn;
	}
	else if ( $maskResult == $fullMaskCount ) {
		iconTextCheckBox -e -v 1 compSelFaceBtn;
		iconTextCheckBox -e -i1 "pickFacetComp.png" compSelFaceBtn;
	}
	else {
		iconTextCheckBox -e -v 1 compSelFaceBtn;
		iconTextCheckBox -e -i1 "pickFacetCompPartial.png" compSelFaceBtn;
	}


	// Hulls
	//
	iconTextCheckBox -e -v `selectType -q -hull` compSelHullBtn;


	// Pivots
	//
	$maskResult = ( `selectType -q -rotatePivot` +
					`selectType -q -scalePivot` +
					`selectType -q -jointPivot` );

	switch( $maskResult ) {
		case 0:
			// they're all off - turn off the icon, and
			// set the correct icon
			//
			iconTextCheckBox -e -v 0 compSelPivotBtn;
			iconTextCheckBox -e -i1 "pickPivotComp.png" compSelPivotBtn;
			break;
		case 3:
			// they're all on - turn the icon on, and
			// set the correct icon
			//
			iconTextCheckBox -e -v 1 compSelPivotBtn;
			iconTextCheckBox -e -i1 "pickPivotComp.png" compSelPivotBtn;
			break;
		default:
			// something is on - make sure the icon is
			// on, and set the correct icon
			//
			iconTextCheckBox -e -v 1 compSelPivotBtn;
			iconTextCheckBox -e -i1 "pickPivotCompPartial.png" compSelPivotBtn;
			break;
	}


	// Markers
	//
	iconTextCheckBox -e -v `selectType -q -selectHandle` compSelHandleBtn;


	// Other
	//
	$maskResult = ( `selectType -q -imagePlane` +
					`selectType -q -localRotationAxis` );

	switch( $maskResult ) {
		case 0:
			// they're all off - turn off the icon, and
			// set the correct icon
			//
			iconTextCheckBox -e -v 0 compSelMiscBtn;
			iconTextCheckBox -e -i1 "pickOtherComp.png" compSelMiscBtn;
			break;
		case 2:
			// they're all on - turn the icon on, and
			// set the correct icon
			//
			iconTextCheckBox -e -v 1 compSelMiscBtn;
			iconTextCheckBox -e -i1 "pickOtherComp.png" compSelMiscBtn;
			break;
		default:
			// something is on - make sure the icon is
			// on, and set the correct icon
			//
			iconTextCheckBox -e -v 1 compSelMiscBtn;
			iconTextCheckBox -e -i1 "pickOtherCompPartial.png" compSelMiscBtn;
			break;
	}
	string $selectionMode = `getSelectMode`;
	textField -e -tx $selectionMode maskField;
}

global proc updateSnapMasks ()
{
	iconTextCheckBox -e -v `snapMode -q -curve` snapCurveButton;
	iconTextCheckBox -e -v `snapMode -q -point` snapPointButton;
	iconTextCheckBox -e -v `snapMode -q -grid` snapGridButton;
	iconTextCheckBox -e -v `snapMode -q -viewPlane` snapViewPlaneButton;
	iconTextCheckBox -e -v `snapMode -q -meshCenter` meshCenterSnapButton;
}

global proc updateConstructionHistory()
{
	int $val = `constructionHistory -q -toggle`;
	iconTextCheckBox -e -v $val constructionHistoryButton;
	if( $val ) {
		iconTextCheckBox -e
			-i1 "constructionHistory.png"
			constructionHistoryButton;
	}
	else {
		iconTextCheckBox -e
			-i1 "constructionHistory.png"
		   constructionHistoryButton;
	}

}

global proc createMaskPopup( string $selectionGrp )
//
// Creates popup menus on each of the icons in the
// toolbar, so that users can specify portions of
// the mask to turn on by selecting the item in
// the popup menu.  Deletes all items in the popup
// menu whenever the procedure is called, to make
// sure that the popups stay in sync with the
// current selection mask setting.
//
{
	int $completeLicense = `licenseCheck -mode "edit" -typ "complete"`;

	global string $gSelMarkerMenuLabelList[];
	global string $gSelMarkerFilterTypeList[];
	global string $gSelJointMenuLabelList[];
	global string $gSelJointFilterTypeList[];
	global string $gSelCurveMenuLabelList[];
	global string $gSelCurveFilterTypeList[];
	global string $gSelSurfaceMenuLabelList[];
	global string $gSelSurfaceFilterTypeList[];
	global string $gSelDeformerMenuLabelList[];
	global string $gSelDeformerFilterTypeList[];
	global string $gSelDynamicMenuLabelList[];
	global string $gSelDynamicFilterTypeList[];
	global string $gSelRenderingMenuLabelList[];
	global string $gSelRenderingFilterTypeList[];
	global string $gSelOtherMenuLabelList[];
	global string $gSelOtherFilterTypeList[];

	int $index;

	switch( $selectionGrp ) {
		//
		// Objects
		//
		case "objMarker":
			setParent -menu ( $selectionGrp + "Popup" );

			// Delete all items in the menu, and
			// recreate them to keep the menu in sync
			// with the current selection settings
			//
			popupMenu -e -dai ( $selectionGrp + "Popup" );

			menuItem -label (uiRes("m_statusLine.kSelHandle"))
				-cb `selectType -q -handle`
				-c "selectType -handle #1";
			menuItem -ltVersion "2015" -label (uiRes("m_statusLine.kIKHandle"))
				-cb `selectType -q -ikHandle`
				-c "selectType -ikHandle #1";

			for( $index = 0;$index < size($gSelMarkerFilterTypeList); ++$index)
			{
				string $checkBoxCmdStr = "selectType -q -queryByName " + $gSelMarkerFilterTypeList[$index];
				string $itemSelectCmdStr = "selectType -byName " + $gSelMarkerFilterTypeList[$index] + " #1";
				menuItem -label  $gSelMarkerMenuLabelList[$index]
				-cb `evalEcho $checkBoxCmdStr`
				-c $itemSelectCmdStr;
			}
			break;

		case "objJoint":
			setParent -menu ( $selectionGrp + "Popup" );

			// Delete all items in the menu, and
			// recreate them to keep the menu in sync
			// with the current selection settings
			//
			popupMenu -e -dai ( $selectionGrp + "Popup" );

			menuItem -label (uiRes("m_statusLine.kSkeletonJoints"))
				-cb `selectType -q -joint`
				-c "selectType -joint #1";

			for( $index = 0;$index < size($gSelJointFilterTypeList); ++$index)
			{
				string $checkBoxCmdStr = "selectType -q -queryByName " + $gSelJointFilterTypeList[$index];
				string $itemSelectCmdStr = "selectType -byName " + $gSelJointFilterTypeList[$index] + " #1";
				menuItem -label  $gSelJointMenuLabelList[$index]
				-cb `evalEcho $checkBoxCmdStr`
				-c $itemSelectCmdStr;
			}
			break;

		case "objCurve":
			setParent -menu ( $selectionGrp + "Popup" );

			// Delete all items in the menu, and
			// recreate them to keep the menu in sync
			// with the current selection settings
			//
			popupMenu -e -dai ( $selectionGrp + "Popup" );

			menuItem -label (uiRes("m_statusLine.kNURBSCurves"))
				-cb `selectType -q -nurbsCurve`
				-c "selectType -nurbsCurve #1";
			if( `isTrue "SurfaceUIExists"` ) {
				menuItem -label (uiRes("m_statusLine.kCurvesOnSurface"))
					-cb `selectType -q -cos`
					-c "selectType -cos #1";
			}
			if (`isTrue MayaCreatorExists` && (`licenseCheck -mode "edit"   -typ "complete"`)) {
				menuItem -label (uiRes("m_statusLine.kPaintEffectsStrokes"))   // For Paint Effects
					-cb `selectType -q -stroke`  // For Paint Effects
					-c "selectType -stroke #1";  // For Paint Effects
			}
			for( $index = 0;$index < size($gSelCurveFilterTypeList); ++$index)
			{
				string $checkBoxCmdStr = "selectType -q -queryByName " + $gSelCurveFilterTypeList[$index];
				string $itemSelectCmdStr = "selectType -byName " + $gSelCurveFilterTypeList[$index] + " #1";
				menuItem -label  $gSelCurveMenuLabelList[$index]
				-cb `evalEcho $checkBoxCmdStr`
				-c $itemSelectCmdStr;
			}
			break;

		case "objSurface":
			setParent -menu ( $selectionGrp + "Popup" );

			// Delete all items in the menu, and
			// recreate them to keep the menu in sync
			// with the current selection settings
			//
			popupMenu -e -dai ( $selectionGrp + "Popup" );

			if( `isTrue "SurfaceUIExists"` ) {
				menuItem -label (uiRes("m_statusLine.kNURBSSurfaces"))
					-cb `selectType -q -nurbsSurface`
					-c "selectType -nurbsSurface #1";
			}
			menuItem -label (uiRes("m_statusLine.kPolySurfaces"))
				-cb `selectType -q -polymesh`
				-c "selectType -polymesh #1";
			if( `isTrue "SubdivUIExists"` ) {
				menuItem -label (uiRes("m_statusLine.kSubdivSurfaces"))
					-cb `selectType -q -subdiv`
					-c "selectType -subdiv #1";
			}
			menuItem -label (uiRes("m_statusLine.kPlanes"))
				-cb `selectType -q -plane`
				-c "selectType -plane #1";

			for( $index = 0;$index < size($gSelSurfaceFilterTypeList); ++$index)
			{
				string $checkBoxCmdStr = "selectType -q -queryByName " + $gSelSurfaceFilterTypeList[$index];
				string $itemSelectCmdStr = "selectType -byName " + $gSelSurfaceFilterTypeList[$index] + " #1";
				menuItem -label  $gSelSurfaceMenuLabelList[$index]
				-cb `evalEcho $checkBoxCmdStr`
				-c $itemSelectCmdStr;
			}
			break;

		case "objDeformer":
			setParent -menu ( $selectionGrp + "Popup" );

			// Delete all items in the menu, and
			// recreate them to keep the menu in sync
			// with the current selection settings
			//
			popupMenu -e -dai ( $selectionGrp + "Popup" );

			menuItem -label (uiRes("m_statusLine.kLattices"))
				-cb `selectType -q -lattice`
				-c "selectType -lattice #1";
			if ($completeLicense) {
				menuItem -label (uiRes("m_statusLine.kClusters"))
					-cb `selectType -q -cluster`
					-c "selectType -cluster #1";
			}
			menuItem -label (uiRes("m_statusLine.kNonlinears"))
				-cb `selectType -q -nonlinear`
				-c "selectType -nonlinear #1";
			if ($completeLicense) {
				menuItem -label (uiRes("m_statusLine.kSculpts"))
					-cb `selectType -q -sculpt`
					-c "selectType -sculpt #1";
			}

			for( $index = 0;$index < size($gSelDeformerFilterTypeList); ++$index)
			{
				string $checkBoxCmdStr = "selectType -q -queryByName " + $gSelDeformerFilterTypeList[$index];
				string $itemSelectCmdStr = "selectType -byName " + $gSelDeformerFilterTypeList[$index] + " #1";
				menuItem -label  $gSelDeformerMenuLabelList[$index]
				-cb `evalEcho $checkBoxCmdStr`
				-c $itemSelectCmdStr;
			}
			break;

		case "objDynamic":
			setParent -menu ( $selectionGrp + "Popup" );

			// Delete all items in the menu, and
			// recreate them to keep the menu in sync
			// with the current selection settings
			//
			popupMenu -e -dai ( $selectionGrp + "Popup" );

			if( `licenseCheck -m edit -type complete` == 1 )
			{
				menuItem -label (uiRes("m_statusLine.kParticles"))
					-cb `selectType -q -particleShape`
					-c "selectType -particleShape #1";
				menuItem -label (uiRes("m_statusLine.kEmitters"))
					-cb `selectType -q -emitter`
					-c "selectType -emitter #1";
				menuItem -label (uiRes("m_statusLine.kFields"))
					-cb `selectType -q -field`
					-c "selectType -field #1";
				menuItem -label (uiRes("m_statusLine.kSprings"))
					-cb `selectType -q -spring`
					-c "selectType -spring #1";
				menuItem -label (uiRes("m_statusLine.kRigidBodies"))
					-cb `selectType -q -rigidBody`
					-c "selectType -rigidBody #1";
				menuItem -label (uiRes("m_statusLine.kRigidConstraints"))
					-cb `selectType -q -rigidConstraint`
					-c "selectType -rigidConstraint #1";
			}
			if( fluidEditLicenseFound() )
			{
				menuItem -label (uiRes("m_statusLine.kFluids"))
					-cb `selectType -q -fluid`
					-c "selectType -fluid #1";
			}
			if( fluidEditLicenseFound() )
			{
				menuItem -label (uiRes("m_statusLine.kHairs"))
					-cb `selectType -q -hairSystem`
					-c "selectType -hairSystem #1";
				menuItem -label (uiRes("m_statusLine.kFollicles"))
					-cb `selectType -q -follicle`
					-c "selectType -follicle #1";
			}
			if( nClothEditLicenseFound() )
			{
				menuItem -label (uiRes("m_statusLine.kNCloths"))
					-cb `selectType -q -nCloth`
					-c "selectType -nCloth #1";
				menuItem -label (uiRes("m_statusLine.kNRigids"))
					-cb `selectType -q -nRigid`
					-c "selectType -nRigid #1";
				menuItem -label (uiRes("m_statusLine.kDynamicConstraints"))
					-cb `selectType -q -dynamicConstraint`
					-c "selectType -dynamicConstraint #1";
			}

			for( $index = 0;$index < size($gSelDynamicFilterTypeList); ++$index)
			{
				string $checkBoxCmdStr = "selectType -q -queryByName " + $gSelDynamicFilterTypeList[$index];
				string $itemSelectCmdStr = "selectType -byName " + $gSelDynamicFilterTypeList[$index] + " #1";
				menuItem -label  $gSelDynamicMenuLabelList[$index]
				-cb `evalEcho $checkBoxCmdStr`
				-c $itemSelectCmdStr;
			}
			break;

		case "objRendering":
			setParent -menu ( $selectionGrp + "Popup" );

			// Delete all items in the menu, and
			// recreate them to keep the menu in sync
			// with the current selection settings
			//
			popupMenu -e -dai ( $selectionGrp + "Popup" );

			menuItem -label (uiRes("m_statusLine.kLights"))
				-cb `selectType -q -light`
				-c "selectType -light #1";
			menuItem -label (uiRes("m_statusLine.kCameras"))
				-cb `selectType -q -camera`
				-c "selectType -camera #1";
			menuItem -label (uiRes("m_statusLine.kTextures"))
				-cb `selectType -q -texture`
				-c "selectType -texture #1";

			for( $index = 0;$index < size($gSelRenderingFilterTypeList); ++$index)
			{
				string $checkBoxCmdStr = "selectType -q -queryByName " + $gSelRenderingFilterTypeList[$index];
				string $itemSelectCmdStr = "selectType -byName " + $gSelRenderingFilterTypeList[$index] + " #1";
				menuItem -label  $gSelRenderingMenuLabelList[$index]
				-cb `evalEcho $checkBoxCmdStr`
				-c $itemSelectCmdStr;
			}
			break;

		case "objOther":
			setParent -menu ( $selectionGrp + "Popup" );

			// Delete all items in the menu, and
			// recreate them to keep the menu in sync
			// with the current selection settings
			//
			popupMenu -e -dai ( $selectionGrp + "Popup" );

			menuItem -label (uiRes("m_statusLine.kEndEffectors"))
				-cb `selectType -q -ikEndEffector`
				-c "selectType -ikEndEffector #1";
			menuItem -label (uiRes("m_statusLine.kLocators"))
				-cb `selectType -q -locator`
				-c "selectType -locator #1";
			menuItem -label (uiRes("m_statusLine.kDimensions"))
				-cb `selectType -q -dimension`
				-c "selectType -dimension #1";

			for( $index = 0;$index < size($gSelOtherFilterTypeList); ++$index)
			{
				string $checkBoxCmdStr = "selectType -q -queryByName " + $gSelOtherFilterTypeList[$index];
				string $itemSelectCmdStr = "selectType -byName " + $gSelOtherFilterTypeList[$index] + " #1";
				menuItem -label  $gSelOtherMenuLabelList[$index]
				-cb `evalEcho $checkBoxCmdStr`
				-c $itemSelectCmdStr;
			}
			break;

		//
		// Components
		//
		case "compPoint":
			setParent -menu ( $selectionGrp + "Popup" );

			// Delete all items in the menu, and
			// recreate them to keep the menu in sync
			// with the current selection settings
			//
			popupMenu -e -dai ( $selectionGrp + "Popup" );

			menuItem -label (uiRes("m_statusLine.kNURBSCVs"))
				-cb `selectType -q -cv`
				-c "selectType -cv #1";
			menuItem -label (uiRes("m_statusLine.kPolyVerts"))
				-cb `selectType -q -polymeshVertex`
				-c "selectType -polymeshVertex #1";
			if( `isTrue "SubdivUIExists"` ) {
				menuItem -label (uiRes("m_statusLine.kSubdivVerts"))
					-cb `selectType -q -subdivMeshPoint`
					-c "selectType -subdivMeshPoint #1";
			}
			menuItem -label (uiRes("m_statusLine.kLatticePoints"))
				-cb `selectType -q -latticePoint`
				-c "selectType -latticePoint #1";
			if( `licenseCheck -m edit -type complete` == 1 )
			{
				menuItem -label (uiRes("m_statusLine.kCompParticles"))
					-cb `selectType -q -particle`
					-c "selectType -particle #1";
			}
			break;

		case "compParmPoint":
			setParent -menu ( $selectionGrp + "Popup" );

			// Delete all items in the menu, and
			// recreate them to keep the menu in sync
			// with the current selection settings
			//
			popupMenu -e -dai ( $selectionGrp + "Popup" );

			menuItem -label (uiRes("m_statusLine.kNURBSEditPoints"))
				-cb `selectType -q -editPoint`
				-c "selectType -editPoint #1";
			menuItem -label (uiRes("m_statusLine.kNURBSCurvePoints"))
				-cb `selectType -q -cpp`
				-c "selectType -cpp #1";
			menuItem -label (uiRes("m_statusLine.kNURBSSurfacePoints"))
				-cb `selectType -q -spp`
				-c "selectType -spp #1";
			menuItem -label (uiRes("m_statusLine.kPolyUVs"))
				-cb `selectType -q -puv`
				-c "selectType -puv #1";
			menuItem -label (uiRes("m_statusLine.kNURBSUVs"))
				-cb `selectType -q -surfaceUV`
				-c "selectType -surfaceUV #1";
			if( `isTrue "SubdivUIExists"` ) {
				menuItem -label (uiRes("m_statusLine.kSubdivUVs"))
					-cb `selectType -q -subdivMeshUV`
					-c "selectType -subdivMeshUV #1";
			}
			break;

		case "compLine":
			setParent -menu ( $selectionGrp + "Popup" );

			// Delete all items in the menu, and
			// recreate them to keep the menu in sync
			// with the current selection settings
			//
			popupMenu -e -dai ( $selectionGrp + "Popup" );

			if( `isTrue "SurfaceUIExists"` ) {
				menuItem -label (uiRes("m_statusLine.kNURBSIsoparms"))
					-cb `selectType -q -isoparm`
					-c "selectType -isoparm #1";
				menuItem -label (uiRes("m_statusLine.kNURBSTrimEdges"))
					-cb `selectType -q -surfaceEdge`
					-c "selectType -surfaceEdge #1";
			}
			menuItem -label (uiRes("m_statusLine.kPolyEdges"))
				-cb `selectType -q -polymeshEdge`
				-c "selectType -polymeshEdge #1";
			if( `isTrue "SubdivUIExists"` ) {
				menuItem -label (uiRes("m_statusLine.kSubdivEdges"))
					-cb `selectType -q -subdivMeshEdge`
					-c "selectType -subdivMeshEdge #1";
			}
			if( `licenseCheck -m edit -type complete` == 1 )
			{
				menuItem -label (uiRes("m_statusLine.kCompSprings"))
					-cb `selectType -q -springComponent`
					-c "selectType -springComponent #1";
			}
			break;

		case "compFacet":
			setParent -menu ( $selectionGrp + "Popup" );

			// Delete all items in the menu, and
			// recreate them to keep the menu in sync
			// with the current selection settings
			//
			popupMenu -e -dai ( $selectionGrp + "Popup" );

			if( `isTrue "SurfaceUIExists"` ) {
				menuItem -label (uiRes("m_statusLine.kNURBSPatches"))
					-cb `selectType -q -surfaceFace`
					-c "selectType -surfaceFace #1";
			}
			menuItem -label (uiRes("m_statusLine.kPolyFaces"))
				-cb `selectType -q -facet`
				-c "selectType -facet #1";
			if( `isTrue "SubdivUIExists"` ) {
				menuItem -label (uiRes("m_statusLine.kSubdivFaces"))
					-cb `selectType -q -subdivMeshFace`
					-c "selectType -subdivMeshFace #1";
			}
			break;

		case "compHull":
			setParent -menu ( $selectionGrp + "Popup" );

			// Delete all items in the menu, and
			// recreate them to keep the menu in sync
			// with the current selection settings
			//
			popupMenu -e -dai ( $selectionGrp + "Popup" );

			menuItem -label (uiRes("m_statusLine.kNURBSHulls"))
				-cb `selectType -q -hull`
				-c "selectType -hull #1";
			break;

		case "compPivot":
			setParent -menu ( $selectionGrp + "Popup" );

			// Delete all items in the menu, and
			// recreate them to keep the menu in sync
			// with the current selection settings
			//
			popupMenu -e -dai ( $selectionGrp + "Popup" );

			menuItem -label (uiRes("m_statusLine.kRotatePivots"))
				-cb `selectType -q -rotatePivot`
				-c "selectType -rotatePivot #1";
			menuItem -label (uiRes("m_statusLine.kScalePivots"))
				-cb `selectType -q -scalePivot`
				-c "selectType -scalePivot #1";
			menuItem -label (uiRes("m_statusLine.kJointPivots"))
				-cb `selectType -q -jointPivot`
				-c "selectType -jointPivot #1";
			break;

		case "compMarker":
			setParent -menu ( $selectionGrp + "Popup" );

			// Delete all items in the menu, and
			// recreate them to keep the menu in sync
			// with the current selection settings
			//
			popupMenu -e -dai ( $selectionGrp + "Popup" );

			menuItem -label (uiRes("m_statusLine.kSelHandles"))
				-cb `selectType -q -selectHandle`
				-c "selectType -selectHandle #1";

			break;

		case "compOther":
			setParent -menu ( $selectionGrp + "Popup" );

			// Delete all items in the menu, and
			// recreate them to keep the menu in sync
			// with the current selection settings
			//
			popupMenu -e -dai ( $selectionGrp + "Popup" );

			menuItem -label (uiRes("m_statusLine.kLocalRotAxes"))
				-cb `selectType -q -localRotationAxis`
				-c "selectType -localRotationAxis #1";
			menuItem -label (uiRes("m_statusLine.kImagePlanes"))
				-cb `selectType -q -imagePlane`
				-c "selectType -imagePlane #1";

			menuItem -label (uiRes("m_statusLine.kMultiComps"))
				-cb `selectType -q -meshComponents`
				-c "selectType -meshComponents #1";

			break;
	}
}



global proc workingMode( string $menuSet )
//
// Changes the current Maya mode in terms of active menu set.
//
{
    if ( `menuSet -q -exists $menuSet` ) {

		if( `licenseCheck -m edit -type complete` == 0 )
		{
			if( $menuSet == "dynamicsMenuSet" )
			{
				warning (uiRes("m_statusLine.kDynamicsNotLicensed"));
				//
				// Since the default mode is "Animation" (see the switch statement
				// below), we will set the mode to be that if the user chose Dynamics
				// but is not licensed for it.
				//
				$menuSet = "animationMenuSet";
			}
		}

		// Set Maya's new 'working mode' to $mode,
		// so that ModelEdMenu can check to see if
		// it should rebuild the main menu next time
		// it's popped up.
		//
		global string $gMayaMode;
		$gMayaMode = $menuSet;
		//
		// Set selection priorities to match the mode
		// the user is working in.
		//
		// selPriority $mode;
		//
		// Destroy the popup called $controlName + "MainPop"
		// in order to get them to recreate themselves.
		//
		string $modelPanels[] = `getPanel -type modelPanel`;

		for( $item in $modelPanels )
		{
			if (`popupMenu -exists ( $item + "MainPop" )`) {
				popupMenu -e -dai ( $item + "MainPop" );
			}
		}

		setMenuMode $menuSet;
		syncHotBox $menuSet;
	}else if ($menuSet == (uiRes("m_initMainMenuBar.kCustomizeMenuSetsItem"))) {

		// this is only the case if the customize... was selected, so show the menu set editor
		menuSetEditor();
	}
}

global proc updateMenuMode()
{
	global string $gMenuModeButton;
	string $menuSetLabel = `optionMenu -q -v $gMenuModeButton`;
	string $menuSet = `findMenuSetFromLabel $menuSetLabel`;
	if (size($menuSet) == 0) {
		// customize was selected
		$menuSet = (uiRes("m_initMainMenuBar.kCustomizeMenuSetsItem"));
	}
	workingMode($menuSet);
}

global proc statusLineSetMakeLive()
{
	if( size(`ls -live`) ) {
		makeLive -n;
	} else {
		MakeLive;
	}
}

global proc statusLineBuildMakeLiveMenu(string $menu)
{
	global string $makeLiveLastSurfaceNameFields[];
	menu -e -dai $menu;

	string $liveSurfaces[];
	string $curLiveList[] = `ls -live -long`;
	for( $thisNameField in $makeLiveLastSurfaceNameFields ) {
		string $thisLiveSurface = `nameField -q -object $thisNameField`;
		if( $thisLiveSurface != "" &&
			!stringArrayContains($thisLiveSurface, $liveSurfaces) &&
			!stringArrayContains($thisLiveSurface, $curLiveList)) {
			appendStringArray( $liveSurfaces, { $thisLiveSurface }, 1 );
		}
	}

	if( size($curLiveList) > 0 ) {
		string $thisTransform[] = `listTransforms $curLiveList[0]`;
		menuItem -p $menu -label $thisTransform[0] -en false;
	}

	for( $thisLiveSurface in $liveSurfaces ) {
		string $liveTransform[] = `listTransforms $thisLiveSurface`;
		menuItem -p $menu -label $liveTransform[0] -c ("makeLive " + $thisLiveSurface);
	}
}

global proc statusLineUpdateMakeLive()
{
	global string $makeLiveButton, $makeLiveTextField, $makeLiveSurfaceNameField, $makeLiveLastSurfaceNameFields[];
	global float $defaultTextBGC[];
	string $liveList[] = `ls -live`;

	string $lastLiveSurface = `nameField -q -object $makeLiveSurfaceNameField`;
	string $lastListedLiveSurface = `nameField -q -object $makeLiveLastSurfaceNameFields[0]`;
	if( $lastLiveSurface != "" && $lastLiveSurface != $lastListedLiveSurface ) {
		int $lastIdx = size( $makeLiveLastSurfaceNameFields ) - 1;

		// If the name is already in the list, move it to the top of the list.
		// Otherwise, grab the oldest name field in the list, put it on the top, then reset it.
		for( $idx = 0; $idx < size($makeLiveLastSurfaceNameFields); $idx++ ) {
			string $thisLiveSurface = `nameField -q -object $makeLiveLastSurfaceNameFields[$idx]`;
			if( $thisLiveSurface == $lastLiveSurface ) {
				$lastIdx = $idx;
				break;
			}
		}

		string $lastNameField  = $makeLiveLastSurfaceNameFields[$lastIdx];
		stringArrayRemoveAtIndex($lastIdx, $makeLiveLastSurfaceNameFields );
		stringArrayInsertAtIndex(0, $makeLiveLastSurfaceNameFields, $lastNameField );
		nameField -e -object $lastLiveSurface $makeLiveLastSurfaceNameFields[0];
	}

	if(size($liveList) > 0) {
		string $liveTransform[] = listTransforms($liveList[0]);
		nameField -e -object $liveList[0] $makeLiveSurfaceNameField;
		string $liveMsg = (uiRes("m_statusLine.kIsLive"));
		string $liveMsgFormatted = `format -stringArg $liveTransform[0] $liveMsg`;
		inViewMessage -smg $liveMsgFormatted -fade -pos topCenter;
		iconTextButton -e -fla 0 -bgc 0.32 0.52 0.65 $makeLiveButton; // use our unified Maya highligh color #5285A6 
		textField -e -backgroundColor 0.32 0.52 0.65 -tx $liveTransform[0] $makeLiveTextField; // use our unified Maya highligh color #5285A6 
	} else {
		nameField -e -object "" $makeLiveSurfaceNameField;
		string $liveMsg = (uiRes("m_statusLine.kMakeLiveIsDisabled"));
		inViewMessage -smg $liveMsg -fade -pos topCenter;
		iconTextButton -e -fla 1 -nbg 1 $makeLiveButton;
		textField -e
			-bgc $defaultTextBGC[0] $defaultTextBGC[1] $defaultTextBGC[2]
			-tx (uiRes("m_statusLine.kNoLiveObject"))
			$makeLiveTextField;
	}
}

global proc statusLineUpdateInputField()
//
//	Description:
//		This procedure updates the value of the input fields on the
//		Status Line.
//
//		When the input fields are in rename mode then get the name of
//		the lead object in the selection list and display it in the
//		field.
//
//		When the input fields are in any other mode then clear the
//		field values.
//
{
	global string $gTextualInputField;
	global string $gNumericalInputXField;
	global string $gNumericalInputYField;
	global string $gNumericalInputZField;

	//	Determine the mode of the field. Only way to do this is
	//	to figure out what image is currently applied to the field
	//	label.
	//
	string $image = `iconTextButton -query -image1 statusFieldButton`;
	string $fieldValue = "";

	if ("quickRename.png" == $image) {

		//	Update the field with the name of the lead object in the selection.
		//
		string $selectionArray[], $tokenBuffer[], $selectedObject;
		int    $numberOfSelectedObjects, $tokenCount;

		//	Determine the lead object in the selection.
		//
		$selectionArray = `ls -selection -tail 1`;
		$numberOfSelectedObjects = size($selectionArray);
		if (0 < $numberOfSelectedObjects) {
			$selectedObject = $selectionArray[$numberOfSelectedObjects - 1];

			//	It is possible that the full path to an object may be
			//	returned even when querying the selection by short names.
			//	This will happen if the more than one object has the
			//	same name. The full path won't fit in the rename field
			//	so strip off the path and display only the short name.
			//	To do this tokenize the object name by the | character.
			//	The short name will be the last item in the array
			//	returned by the tokenize command.
			//
			$tokenCount = `tokenize $selectedObject "|" $tokenBuffer`;
			$fieldValue = $tokenBuffer[$tokenCount - 1];

		} else {
			//
			//	Nothing selected. Clear the field.
			//
			$fieldValue = "";
		}

	} else {
		//
		//	For all the other field modes clear the text.
		//
		$fieldValue = "";
	}

	//	Update the field.
	//
	if ("quickRename.png" == $image || "quickSelect.png" == $image) {
		textField -edit -text $fieldValue $gTextualInputField;
	} else {
		textField -edit -text $fieldValue $gNumericalInputXField;
		textField -edit -text $fieldValue $gNumericalInputYField;
		textField -edit -text $fieldValue $gNumericalInputZField;
	}
}

global proc quickRename()
//
//	Description:
//		Called from the quick rename field to allow easy renaming of
//		the selected objects for users who don't want to have to open
//		the Channel Box or Attribute Editor.
//
{
	global string $gTextualInputField;

	string $newName;
	int    $renameResult;

	//	Get the name in the text field.
	//
	$newName = `textField -query -text $gTextualInputField`;

	//	The result will contain the number of renamed objects,
	//	which may be zero if all the objects in the selection
	//	list are read-only (examples of read-only objects are
	//	default and referenced objects).
	//
	$renameResult = renameSelectionList($newName);

	if (-1 == $renameResult) {
		//
		//	The selection list is empty. Not serious, just print
		//	a warning.
		//
		warning (uiRes("m_statusLine.kNoObjectsToRename"));

	} else if (-2 == $renameResult) {
		//
		//	An invalid name error. Print an error message.
		//	Don't send focus back to the panels. Keep it in the field
		//	so the user can correct the error in the field.
		//
		string $errMsg = (uiRes("m_statusLine.kNameInvalid"));
		error (`format -s $newName $errMsg`);
	}

    statusLineUpdateInputField();
}

global proc quickWildcardSelect()
//
// Called from the quick select field to allow easy wildcard
// selection with feedback for users who don't want to have
// to open the outliner for simple selections.
//
{
	global string $gTextualInputField;

	//	Get the text in the select field.
	//
	string $text = `textField -query -text $gTextualInputField`;

	//	Are there any wildcard characters in the text?
	//	Wildcard characters are * and ? (are there others?).
	//
	int $wildcards = false;
	if (`gmatch $text "*[*?]*"`) {
		$wildcards = true;
	}

	string $cmd;

	//	If there are no wildcards then do a test to see if the
	//	name specified in the field uniquely specifies a single
	//	object in the scene. This can be determined by using
	//	the "ls" command.
	//
	if (!$wildcards) {
		string $object, $objectArray[] = `ls $text`;
		if (1 < size($objectArray)) {
			//
			//	There is more than one object with the name specified.
			//	Be sure to select them all.
			//
			$cmd = "select";
			for ($object in $objectArray) {
				$cmd += (" " + $object);
			}

		} else {
			//
			//	No wildcards and just one object with the specified
			//	name.
			//
			$cmd = ("select \"" + $text + "\"");
		}

	} else {
		$cmd = ("select \"" + $text + "\"");
	}

	// If something was actually selected then give some feedback
	// and clean up.  Otherwise the offending text is left in the
	// field and focus remains in the field for another try.
	//    
	if (!catch(eval($cmd))) {

		//	Give some feedback that something was selected. Query
		//	what's on the selection list and for each item append
		//	it to a result string that will be echoed to the user.
		//
		string $lsList = "";
		string $lsArray[] = `ls -sl`;
		for ($i = 0; $i < size($lsArray); $i++) {
			$lsList = $lsList+" "+$lsArray[$i];
		}

		string $msg = (uiRes("m_statusLine.kResult")) ;
		print `format -stringArg $lsList $msg` ;

		// Clear the field and throw the focus back to the panels
		//
		statusLineUpdateInputField();
		setFocus `paneLayout -query -pane1 viewPanes`;
	}
    else {
        setFocus $gTextualInputField;
    }
}

global proc setQuickFieldMode (string $mode)
{
	global string $gTextualInputField;
	global string $gNumericalInputXField;
	global string $gNumericalInputYField;
	global string $gNumericalInputZField;
	global string $gStatusLine;
	setParent $gStatusLine;

	switch ($mode) {
		case "Select":
			iconTextButton -e -i1 "quickSelect.png" statusFieldButton;
			menuItem -edit -radioButton true numericalPopupSelect;
			textField -e 
				-annotation (uiRes("m_statusLine.kSelectWildAnnot")) 
                -enterCommand "quickWildcardSelect" 
                -alwaysInvokeEnterCommandOnReturn true
				$gTextualInputField;
			break;

		case "Rename":
			iconTextButton -e -i1 "quickRename.png" statusFieldButton;
			menuItem -edit -radioButton true numericalPopupRename;
			textField -edit
				-annotation (uiRes("m_statusLine.kRenameAnnot"))
                -enterCommand "quickRename"
                -alwaysInvokeEnterCommandOnReturn true
				$gTextualInputField;
			break;

		case "Abs":
			string $absAnnot = (uiRes("m_statusLine.kAbsAnnot"));

			iconTextButton -e -i1 "absolute.png" statusFieldButton;
			menuItem -edit -radioButton true numericalPopupAbs;
			textField
			        -edit
				-annotation $absAnnot
				-enterCommand "numericalInputChangeCommand abs"
				-alwaysInvokeEnterCommandOnReturn true
				$gNumericalInputXField;
			textField
			        -edit
				-annotation $absAnnot
				-enterCommand "numericalInputChangeCommand abs"
				-alwaysInvokeEnterCommandOnReturn true
				$gNumericalInputYField;
			textField
			        -edit
				-annotation $absAnnot
				-enterCommand "numericalInputChangeCommand abs"
				-alwaysInvokeEnterCommandOnReturn true
				$gNumericalInputZField;
			break;

		case "Rel":
			string $relAnnot = (uiRes("m_statusLine.kRelAnnot")) ;

			iconTextButton -e -i1 "relative.png"
				statusFieldButton;
			menuItem -edit -radioButton true numericalPopupRel;
			textField
			        -edit
				-annotation $relAnnot
				-enterCommand "numericalInputChangeCommand rel"
				-alwaysInvokeEnterCommandOnReturn true
				$gNumericalInputXField;
			textField
			        -edit
				-annotation $relAnnot
				-enterCommand "numericalInputChangeCommand rel"
				-alwaysInvokeEnterCommandOnReturn true
				$gNumericalInputYField;
			textField
			        -edit
				-annotation $relAnnot
				-enterCommand "numericalInputChangeCommand rel"
				-alwaysInvokeEnterCommandOnReturn true
				$gNumericalInputZField;
			break;
	}

	// Show/hide the correct fields/labels according to mode
	//
	if($mode == "Select" || $mode == "Rename"){
		text -edit -manage false numericalInputXLabel;
		textField -edit -manage false $gNumericalInputXField;
		text -edit -manage false numericalInputYLabel;
		textField -edit -manage false $gNumericalInputYField;
		text -edit -manage false numericalInputZLabel;
		textField -edit -manage false $gNumericalInputZField;

		textField -edit -manage true $gTextualInputField;

	} else {

		textField -edit -manage false $gTextualInputField;

		text -edit -manage true numericalInputXLabel;
		textField -edit -manage true $gNumericalInputXField;
		text -edit -manage true numericalInputYLabel;
		textField -edit -manage true $gNumericalInputYField;
		text -edit -manage true numericalInputZLabel;
		textField -edit -manage true $gNumericalInputZField;

	}

	// Save mode
	optionVar -stringValue "quickFieldMode" $mode;

	//	When the mode changes update the field.
	//
	statusLineUpdateInputField();
}

global proc updateStatusLineRendererSpecificUI()
{
	//
	// Description:
	//	This procedure is called when the current renderer changes.
	//	This procedure updates status line UI which behaves differently
	//	depending on the current renderer.
	//

	global string $gStatusLine;
    string $currentRendererName = currentRenderer();
    if (!`renderer -exists $currentRendererName`)
    {
        // The renderer plugin might not have finished loading yet.
        // Don't update the following UI yet.
        //
        return;
    }
    string $renUIName = `renderer -query -rendererUIName $currentRendererName`;


	if (!`layout -exists $gStatusLine`) return;

	setParent $gStatusLine;

	// Change the tool tip associated with the render icon button
	// on status line in the main window.
	//
	string $renderFmt = (uiRes("m_statusLine.kRenderCurrFrame"));
	iconTextButton
		-edit
		-annotation `format -stringArg $renUIName $renderFmt`
		renderButton;

	// Change the tool tip associated with the render globals icon button
	// on status line in the main window.
	//
	$renderFmt = (uiRes("m_statusLine.kDisplayRenderSettings"));
	iconTextButton
		-edit
		-annotation `format -s $renUIName $renderFmt`
		renderGlobalsButton;

	// Enable/disable the IPR button if it is supported/not supported by the
	// current renderer.
	//
    if (`renderer -query -iprRenderProcedure $currentRendererName` != "")
	{
		$renderFmt = (uiRes("m_statusLine.kRenderCurrIPR"));
		iconTextButton
			-edit
			-enable true
			-annotation `format -s $renUIName $renderFmt`
			iprRenderButton;
	}
	else
	{
		iconTextButton
			-edit
			-enable false
			-annotation ("")
			iprRenderButton;
	}

	setParent ..;
}

// Register the procedure responsible for updating all renderer
// related UI created in the status line.
//
registerUpdateRendererUIProc("updateStatusLineRendererSpecificUI");

//global proc string statusLine ()
{
	global string $gStatusLine;
	global string $gStatusLineForm;
	global string $gMenuModeButton;
	global string $gTextualInputField;
	global string $gNumericalInputXField;
	global string $gNumericalInputYField;
	global string $gNumericalInputZField;

	//	New for 4.0 are buttons on the far right of the Status Line that
	//	control the visibility of the Attribute Editor, Tool Settings, and
	//	Channel Box / Layer Editor.
	//
	//	To do this insert a form layout. The existing $gStatusLineForm will
	//	be parented to it as well as the form that contains the new buttons.
	//
	$statusLine = `formLayout -parent $gStatusLineForm`;
	$gStatusLine = `flowLayout -cs 1`;

		// Create the Menubar set switching popup
		// TODO: go through and add the menu modes to the popup, requires that
		//       all menuSets have been created first
		// NOTE: since statusLine.mel is executed before initMainMenuBar.mel, and
		//		 iMMB.mel contains the definitions for the dynamic menu sets, we
		//		 will actually populate $gMenuModeButton inside initMainMenuBar.mel
		// NOTE: somehow, we still have to calculate the height for the menu

		int $iconHeight = 22;		// And icon width, Real size = 20x20, but with padding for down/hover = 22x22
		int $thinIconWidth = 9;
		int $controlSpacing = 5;	// Real spacing is 7px, but flowLayout has a column spacing of 1
		int $iconSpacing = 1;

		formLayout -height $iconHeight optionMenuForm;
			$gMenuModeButton =
				`optionMenu
					-annotation (uiRes("m_statusLine.kSelectMenusAnnot"))
					-width 100
					-changeCommand updateMenuMode
					-alwaysCallChangeCommand
					menuMode`;
			setParent ..;
		formLayout -e 
			-af $gMenuModeButton top    1	// To bump (down) the menu mode button
			-af $gMenuModeButton left   0	// so that it centers (vert) with the
			-af $gMenuModeButton right  0	// buttons on the StatusLine.
			-af $gMenuModeButton bottom 0
			optionMenuForm;

		// If the user has either of these turned off then dim the
		// menu item.
		if( `licenseCheck -m edit -type complete` == 1 )
		{
			if (!`isTrue "DynamicsExists"`)
				menuItem -e -en 0 dynamicsMode;
		}

		if (!`isTrue "RenderingExists"`)
			menuItem -e -en 0 renderingMode;

		setParent -menu ..;

		// Create the expand/collapse button separators
		//
		if (!`optionVar -exists "showStatusFiles"`) {
			optionVar -intValue "showStatusFiles" 1;
		}
		separator -h $iconHeight -w $controlSpacing -style "none";
		iconTextButton -vis true -h $iconHeight -w $thinIconWidth
			-annotation (uiRes("m_statusLine.kShowHideFileIconsAnnot"))
			-i1 openBar.png
			-c ("toggleFileIcons(-1)")
			fileCollapse;
		separator -h $iconHeight -w $controlSpacing -style "none";

		// Create the New/Open/Save buttons
		iconTextButton -image1 "fileNew.png"
			-width $iconHeight -height $iconHeight
			-command ("NewScene")
			-annotation (uiRes("m_statusLine.kNewSceneAnnot"))
			newSceneButton;

		iconTextButton -image1 "fileOpen.png"
			-width $iconHeight -height $iconHeight
			-command ("OpenScene")
			-annotation (uiRes("m_statusLine.kOpenSceneAnnot"))
			openSceneButton;

		// Attach a recent files menu to open scene button
		popupMenu -parent openSceneButton OpenSceneButtonRecentFileItems;
			menu -edit -postMenuCommand "buildRecentFileMenu OpenSceneButtonRecentFileItems" OpenSceneButtonRecentFileItems;
		setParent -menu ..;

		iconTextButton -image1 "fileSave.png"
			-width $iconHeight -height $iconHeight
			-command ("SaveScene")
			-annotation (uiRes("m_statusLine.kSaveSceneAnnot"))
			saveSceneButton;

		iconTextButton -image1 "undo_s.png"
			-width $iconHeight -height $iconHeight
			-command ("Undo")
			-annotation (uiRes("m_statusLine.kUndoAnnot"))
			undoButton;

		iconTextButton -image1 "redo_s.png"
			-width $iconHeight -height $iconHeight
			-command ("Redo")
			-annotation (uiRes("m_statusLine.kRedoAnnot"))
			redoButton;

		// Create the expand/collapse button separators
		//
		// Default this one off since it is infrequently used
		if (!`optionVar -exists "showStatusSelectionSet"`) {
			optionVar -intValue "showStatusSelectionSet" 0;
		}
		separator -h $iconHeight -w $controlSpacing -style "none";
		iconTextButton -vis true -h $iconHeight -w $thinIconWidth
			-annotation (uiRes("m_statusLine.kShowHideSelectionSetAnnot"))
			-i1 openBar.png  -c ("toggleSelectionSetIcons(-1)")
			selectionSetCollapse;
		separator -h $iconHeight -w $controlSpacing -style "none";

		// 	Create the selection mask setting widget, that
		//	allows user to set masks at a high level, or
		//	define their own
		//
		formLayout presetForm;
			iconTextStaticLabel
				-w $thinIconWidth -h $iconHeight
				-annotation (uiRes("m_statusLine.kSetMask1Annot"))
				-i1 "popupMenuIcon.png"
				maskMenuIcon;
			textField
				-annotation (uiRes("m_statusLine.kSetMask2Annot"))
				-ed false
				-text (uiRes("m_statusLine.kSelectionTextRoot"))
				-width 94
				-height $iconHeight
				-drawInactiveFrame true
				maskField;
		setParent ..;

		//	Layout the above form
		//
		formLayout -e
			-af maskMenuIcon left 0
			-ac maskField left 0 maskMenuIcon
			presetForm;

		//  Attach a popup menu that controls the
		//  contents of the textField, and sets the
		//  selection masks
		//
		string $menu = `popupMenu -b 1 -p presetForm`;
			menu -e -pmc ( "buildMaskSettingMenu " + $menu ) $menu;
		setParent -menu ..;

		// Create the expand/collapse button separators
		//
		if (!`optionVar -exists "showStatusSelectMode"`) {
			optionVar -intValue "showStatusSelectMode" 1;
		}
		separator -h $iconHeight -w $controlSpacing -style "none";
		iconTextButton -vis true -h $iconHeight -w $thinIconWidth
			-annotation (uiRes("m_statusLine.kShowHideSelModeAnnot"))
			-i1 openBar.png  -c ("toggleSelectModeIcons(-1)")
			selectModeCollapse;
		separator -h $iconHeight -w $controlSpacing -style "none";

		// Create the icons to specify the selection mode
		//
		int $isHierarchy = `selectMode -q -hierarchical`;
		int $isObject    = `selectMode -q -object`;
		int $isComponent = `selectMode -q -component`;
		int $isPreset	 = `selectMode -q -preset`;

		formLayout -manage 1 masksForm;
			iconTextCheckBox -i1 "pickHierarchy.png"
				-w $iconHeight -h $iconHeight
				-v ( $isHierarchy || $isPreset )
				-cc "changeSelectMode -hierarchical"
				-annotation (uiRes("m_statusLine.kSelectHierarchyAnnot"))
				selectBtnHierComb;
			iconTextCheckBox -i1 "pickObjByType.png"
				-w $iconHeight -h $iconHeight
				-v $isObject
				-cc "changeSelectMode -object"
				-annotation (uiRes("m_statusLine.kSelectObjectAnnot"))
				selectBtnObject;
			iconTextCheckBox -i1 "pickCompByType.png"
				-w $iconHeight -h $iconHeight
				-v $isComponent
				-cc "changeSelectMode -component"
				-annotation (uiRes("m_statusLine.kSelectComponentAnnot"))
				selectBtnComponent;
		setParent ..;

		// Layout the icons, by attaching them to themselves
		// and the formLayout holding the icons
		//
		formLayout -e
			-af selectBtnComponent right $iconSpacing
			-ac selectBtnObject right $iconSpacing selectBtnComponent
			-ac selectBtnHierComb right $iconSpacing selectBtnObject
	      masksForm;

		// Create the expand/collapse button separators
		//
		if (!`optionVar -exists "showStatusSelectMasks"`) {
			optionVar -intValue "showStatusSelectMasks" 0;
		}
		separator -h $iconHeight -w $controlSpacing -style "none";
		iconTextButton -vis true -h $iconHeight -w $thinIconWidth
			-annotation (uiRes("m_statusLine.kShowHideSelMaskAnnot"))
			-i1 openBar.png  -c ("toggleSelectMaskIcons(-1)")
			selectMasksCollapse;
		separator -h $iconHeight -w $controlSpacing -style "none";

		formLayout selectMaskForm;

		//	Create the label that says the user is in a combo
		//	mode
		text -label (uiRes("m_statusLine.kComboSelection"))  -manage $isPreset comboSelectText;

		// Create the icons to specify the hierarchy mode pick mask
		//
		formLayout -manage $isHierarchy hierarchyIcons;

			formLayout hierPickMenuLayout;
				iconTextStaticLabel
					-w $thinIconWidth -h $iconHeight
					-annotation (uiRes("m_statusLine.kHierMaskAnnot"))
					-i1 "popupMenuIcon.png"
					hierPickMenuIcon;
			setParent ..;

			iconTextCheckBox -i1 "selectObj.png" -v 1
				-w $iconHeight -h $iconHeight
				-cc "setHierSelectMode -root"
				-annotation (uiRes("m_statusLine.kHierRootAnnot"))
				hierRootButton;
			iconTextCheckBox -i1 "selectComp.png" -v 0
				-w $iconHeight -h $iconHeight
				-cc "setHierSelectMode -leaf"
				-annotation (uiRes("m_statusLine.kHierLeafAnnot"))
				hierLeafButton;
			iconTextCheckBox -i1 "pickTemplate.png" -v 0
				-w $iconHeight -h $iconHeight
				-cc "setHierSelectMode -template"
				-annotation (uiRes("m_statusLine.kHierTemplateAnnot"))
				hierTemplateButton;
		setParent ..;

		// Layout the icons, by attaching them to themselves
		// and the formLayout holding the icons
		//
		formLayout -e
			-af hierPickMenuLayout left 0
			-ac hierRootButton left 3 hierPickMenuLayout
			-ac hierLeafButton left $iconSpacing hierRootButton
			-ac hierTemplateButton left $iconSpacing hierLeafButton
			hierarchyIcons;

		// Attach a menu to the hierPickMenuLayout
		//
		popupMenu -b 1 -p hierPickMenuLayout;
			menuItem -label (uiRes("m_statusLine.kRoot"))
				-c "selectMode -root"
				rootPickMenuItem;
			menuItem -label (uiRes("m_statusLine.kLeaf"))
				-c "selectMode -leaf"
				leafPickMenuItem;
			menuItem -label (uiRes("m_statusLine.kTemplate"))
				-c "selectMode -template"
				templatePickMenuItem;
		setParent -menu ..;

		// Create the icons to specify the object mode pick mask
		// in a coarser manner than the pick mask menus.
		//
		formLayout -manage $isObject objectMaskIcons;

			formLayout objPickMenuLayout;
				iconTextStaticLabel
					-w $thinIconWidth -h $iconHeight
					-annotation (uiRes("m_statusLine.kSetObjMaskAnnot"))
					-i1 "popupMenuIcon.png"
					objPickMenuIcon;
			setParent ..;

			iconTextCheckBox -i1 "pickHandlesObj.png" -v 1
				-w $iconHeight -h $iconHeight
				-annotation (uiRes("m_statusLine.kHandleObjAnnot"))
				-cc "setObjectPickMask \"Marker\" #1" objSelHandleBtn;
			iconTextCheckBox -i1 "pickJointObj.png" -v 1
				-w $iconHeight -h $iconHeight
				-annotation (uiRes("m_statusLine.kJointAnnot"))
				-cc "setObjectPickMask \"Joint\" #1" objSelJointBtn;
			iconTextCheckBox -i1 "pickCurveObj.png" -v 1
				-w $iconHeight -h $iconHeight
				-annotation (uiRes("m_statusLine.kCurveAnnot"))
				-cc "setObjectPickMask \"Curve\" #1" objSelCurveBtn;
			iconTextCheckBox -i1 "pickGeometryObj.png" -v 1
				-w $iconHeight -h $iconHeight
				-annotation (uiRes("m_statusLine.kSurfaceAnnot"))
				-cc "setObjectPickMask \"Surface\" #1" objSelSurfaceBtn;
			iconTextCheckBox -i1 "pickDeformerObj.png" -v 1
				-w $iconHeight -h $iconHeight
				-annotation (uiRes("m_statusLine.kDeformAnnot"))
				-cc "setObjectPickMask \"Deformer\" #1" objSelDeformBtn;
			iconTextCheckBox -i1 "pickDynamicsObj.png" -v 1
				-w $iconHeight -h $iconHeight
				-annotation (uiRes("m_statusLine.kDynamicAnnot"))
				-cc "setObjectPickMask \"Dynamic\" #1" objSelDynamicBtn;
			iconTextCheckBox -i1 "pickRenderingObj.png" -v 1
				-w $iconHeight -h $iconHeight
				-annotation (uiRes("m_statusLine.kRenderAnnot"))
				-cc "setObjectPickMask \"Rendering\" #1" objSelRenderBtn;
			iconTextCheckBox -i1 "pickOtherObj.png" -v 1
				-w $iconHeight -h $iconHeight
				-annotation (uiRes("m_statusLine.kMiscObjAnnot"))
				-cc "setObjectPickMask \"Other\" #1" objSelMiscBtn;
		setParent ..;

		popupMenu -b 3 -p objSelHandleBtn
			-pmc "createMaskPopup \"objMarker\""
			objMarkerPopup;
		popupMenu -b 3 -p objSelJointBtn
			-pmc "createMaskPopup \"objJoint\""
			objJointPopup;
		popupMenu -b 3 -p objSelCurveBtn
			-pmc "createMaskPopup \"objCurve\""
			objCurvePopup;
		popupMenu -b 3 -p objSelSurfaceBtn
			-pmc "createMaskPopup \"objSurface\""
			objSurfacePopup;
		popupMenu -b 3 -p objSelDeformBtn
			-pmc "createMaskPopup \"objDeformer\""
			objDeformerPopup;
		popupMenu -b 3 -p objSelDynamicBtn
			-pmc "createMaskPopup \"objDynamic\""
			objDynamicPopup;
		popupMenu -b 3 -p objSelRenderBtn
			-pmc "createMaskPopup \"objRendering\""
			objRenderingPopup;
		popupMenu -b 3 -p objSelMiscBtn
			-pmc "createMaskPopup \"objOther\""
			objOtherPopup;

		// Layout the icons, by attaching them to themselves
		// and the formLayout holding the icons
		//
		formLayout -e

			-af objSelMiscBtn     right  0
			-ac objSelRenderBtn   right  $iconSpacing objSelMiscBtn
			-ac objSelDynamicBtn  right  $iconSpacing objSelRenderBtn
			-ac objSelDeformBtn   right  $iconSpacing objSelDynamicBtn
			-ac objSelSurfaceBtn  right  $iconSpacing objSelDeformBtn
			-ac objSelCurveBtn    right  $iconSpacing objSelSurfaceBtn
			-ac objSelJointBtn    right  $iconSpacing objSelCurveBtn
			-ac objSelHandleBtn   right  $iconSpacing objSelJointBtn
			-ac objPickMenuLayout right  3 objSelHandleBtn

			objectMaskIcons;

		// Create the icons to specify the component mode pick mask
		// in a coarser manner than the pick mask menus.
		//
		formLayout -manage $isComponent componentMaskIcons;

			formLayout compPickMenuLayout;
				iconTextStaticLabel
					-w $thinIconWidth -h $iconHeight
					-annotation (uiRes("m_statusLine.kCompSelMaskAnnot"))
					-i1 "popupMenuIcon.png"
					compPickMenuIcon;
			setParent ..;

			iconTextCheckBox -i1 "pickPointComp2.png" -v 0
				-w $iconHeight -h $iconHeight
				-annotation (uiRes("m_statusLine.kPointAnnot"))
				-cc "setComponentPickMask \"Point\" #1" compSelPointBtn;
			iconTextCheckBox -i1 "pickPointComp.png" -v 0
				-w $iconHeight -h $iconHeight
				-annotation (uiRes("m_statusLine.kParmPointAnnot"))
				-cc "setComponentPickMask \"ParmPoint\" #1" compSelParmPointBtn;
			iconTextCheckBox -i1 "pickLineComp.png" -v 0
				-w $iconHeight -h $iconHeight
				-annotation (uiRes("m_statusLine.kLineAnnot"))
				-cc "setComponentPickMask \"Line\" #1" compSelLineBtn;
			iconTextCheckBox -i1 "pickFacetComp.png" -v 0
				-w $iconHeight -h $iconHeight
				-annotation (uiRes("m_statusLine.kFaceAnnot"))
				-cc "setComponentPickMask \"Facet\" #1" compSelFaceBtn;
			iconTextCheckBox -i1 "pickHullComp.png" -v 0
				-w $iconHeight -h $iconHeight
				-annotation (uiRes("m_statusLine.kHullAnnot"))
				-cc "setComponentPickMask \"Hull\" #1" compSelHullBtn;
			iconTextCheckBox -i1 "pickPivotComp.png" -v 0
				-w $iconHeight -h $iconHeight
				-annotation (uiRes("m_statusLine.kPivotAnnot"))
				-cc "setComponentPickMask \"Pivot\" #1" compSelPivotBtn;
			iconTextCheckBox -i1 "pickHandlesComp.png" -v 0
				-w $iconHeight -h $iconHeight
				-annotation (uiRes("m_statusLine.kHandleCompAnnot"))
				-cc "setComponentPickMask \"Marker\" #1" compSelHandleBtn;
			iconTextCheckBox -i1 "pickOtherComp.png" -v 0
				-w $iconHeight -h $iconHeight
				-annotation (uiRes("m_statusLine.kMiscCompAnnot"))
				-cc "setComponentPickMask \"Other\" #1" compSelMiscBtn;
		setParent ..;

		popupMenu -b 3 -p compSelPointBtn
			-pmc "createMaskPopup \"compPoint\""
			compPointPopup;
		popupMenu -b 3 -p compSelParmPointBtn
			-pmc "createMaskPopup \"compParmPoint\""
			compParmPointPopup;
		popupMenu -b 3 -p compSelLineBtn
			-pmc "createMaskPopup \"compLine\""
			compLinePopup;
		popupMenu -b 3 -p compSelFaceBtn
			-pmc "createMaskPopup \"compFacet\""
			compFacetPopup;
		popupMenu -b 3 -p compSelHullBtn
			-pmc "createMaskPopup \"compHull\""
			compHullPopup;
		popupMenu -b 3 -p compSelPivotBtn
			-pmc "createMaskPopup \"compPivot\""
			compPivotPopup;
		popupMenu -b 3 -p compSelHandleBtn
			-pmc "createMaskPopup \"compMarker\""
			compMarkerPopup;
		popupMenu -b 3 -p compSelMiscBtn
			-pmc "createMaskPopup \"compOther\""
			compOtherPopup;

		// Layout the icons, by attaching them to themselves
		// and the formLayout holding the icons
		//
		formLayout -e

			-af compSelMiscBtn      right 0
			-ac compSelHandleBtn    right $iconSpacing compSelMiscBtn
			-ac compSelPivotBtn     right $iconSpacing compSelHandleBtn
			-ac compSelHullBtn      right $iconSpacing compSelPivotBtn
			-ac compSelFaceBtn      right $iconSpacing compSelHullBtn
			-ac compSelLineBtn      right $iconSpacing compSelFaceBtn
			-ac compSelParmPointBtn right $iconSpacing compSelLineBtn
			-ac compSelPointBtn     right $iconSpacing compSelParmPointBtn
			-ac compPickMenuLayout  right 3 compSelPointBtn

			componentMaskIcons;

		setParent ..;

		formLayout -edit

			-af comboSelectText top 0
			-af comboSelectText left 0
			-af comboSelectText bottom 0
			-an comboSelectText right

			-af hierarchyIcons top 0
			-af hierarchyIcons left 0
			-af hierarchyIcons bottom 0
			-an hierarchyIcons right

			-af objectMaskIcons top 0
			-af objectMaskIcons left 0
			-af objectMaskIcons bottom 0
			-an objectMaskIcons right

			-af componentMaskIcons top 0
			-af componentMaskIcons left 0
			-af componentMaskIcons bottom 0
			-an componentMaskIcons right

			selectMaskForm;

		// Lock selection button icon
		//
		iconTextCheckBox -v 0
			-enable true
			-i1 "lock.png"
			-w $iconHeight -h $iconHeight
			-annotation (uiRes("m_statusLine.kLockUnlockAnnot"))
			-cc "updateLockSelectionIcon"
			lockSelectionIcon;

		iconTextCheckBox -v 0
			-enable true
			-i1 "highlightSelect.png"
			-w $iconHeight -h $iconHeight
			-cc "toggleHighlightSelectIcon"
			highlightSelectIcon;

		// Create the expand/collapse button separators
		//
		if (!`optionVar -exists "showStatusSnap"`) {
			optionVar -intValue "showStatusSnap" 1;
		}
		separator -h $iconHeight -w $controlSpacing -style "none";
		iconTextButton -vis true -h $iconHeight -w $thinIconWidth
			-annotation (uiRes("m_statusLine.kShowHideSnapAnnot"))
			-i1 openBar.png  -c ("toggleSnapIcons(-1)")
			snapCollapse;
		separator -h $iconHeight -w $controlSpacing -style "none";

		// Create the icons to specify the snapping
		//
		formLayout -vis 1 snapIcons;
			iconTextCheckBox
				-i1 "snapCurve.png"
				-w $iconHeight -h $iconHeight
				-v 0
				-cc "snapMode -curve #1"
				-annotation (uiRes("m_statusLine.kSnapCurveAnnot"))
				snapCurveButton;
			iconTextCheckBox
				-i1 "snapPoint.png"
				-w $iconHeight -h $iconHeight
				-v 0
				-cc "snapMode -point #1"
				-annotation (uiRes("m_statusLine.kSnapPointAnnot"))
				snapPointButton;
			iconTextCheckBox
				-i1 "snapGrid.png"
				-w $iconHeight -h $iconHeight
				-v 0
				-cc "snapMode -grid #1"
				-annotation (uiRes("m_statusLine.kSnapGridAnnot"))
				snapGridButton;
			iconTextCheckBox
				-i1 "snapPlane.png"
				-w $iconHeight -h $iconHeight
				-v 0
				-cc "snapMode -viewPlane #1"
				-annotation (uiRes("m_statusLine.kSnapeViewPlaneAnnot"))
				snapViewPlaneButton;
			iconTextCheckBox
				-i1 "snapMeshCenter.png"
				-w $iconHeight -h $iconHeight
				-v 0
				-cc "snapMode -meshCenter #1"
				-annotation (uiRes("m_statusLine.kSnapeMeshCenterAnnot"))
				meshCenterSnapButton;
			//
			//	Create a "make live" button
			//
			global float $defaultTextBGC[];
			global string $makeLiveButton, $makeLiveTextField, $makeLiveSurfaceNameField, $makeLiveLastSurfaceNameFields[];
			$makeLiveButton = `iconTextButton
				-version "2014"
				-image1 "makeLiveIcon.png"
				-width $iconHeight -height $iconHeight
				-annotation (uiRes("m_statusLine.kMakeLiveAnnot"))
				-command "statusLineSetMakeLive"
				-flat 1 
				-nbg 1
				makeLiveButton`;

			string $makeLivePopMenu = `popupMenu -b 3 -p $makeLiveButton`;
				menu -e -pmc ("statusLineBuildMakeLiveMenu " + $makeLivePopMenu) $makeLivePopMenu;

			$makeLiveTextField = `textField 
				-ed false 
				-width 100
				-height $iconHeight
				-tx (uiRes("m_statusLine.kNoLiveObject"))
				-annotation (uiRes("m_statusLine.kMakeLiveObjectTextAnnot"))
				-drawInactiveFrame true
				makeLiveObjectText`;

			string $makeLivePopMenuTxtField = `popupMenu -b 3 -p $makeLiveTextField`;
				menu -e -pmc ("statusLineBuildMakeLiveMenu " + $makeLivePopMenuTxtField) $makeLivePopMenuTxtField;

			$makeLiveSurfaceNameField = `nameField -visible false -width 1 -nameChangeCommand ("statusLineUpdateMakeLive")`;
			// For tracking the last 5 live surfaces used.
			for($idx = 0; $idx < 5; $idx++) {
				$makeLiveLastSurfaceNameFields[$idx] = `nameField -visible false -width 1`;
			}

			$defaultTextBGC = `textField -q -bgc $makeLiveTextField`;
			scriptJob -parent $makeLiveTextField
				-event "LiveListChanged" ("statusLineUpdateMakeLive");

		setParent ..;

		// Layout the icons, by attaching them to themselves
		// and the formLayout holding the icons
		//
		formLayout -e
//			-af snapButton7          right 0
			-af makeLiveObjectText   right 0
			-ac makeLiveButton       right $iconSpacing makeLiveObjectText
			-ac snapViewPlaneButton  right $iconSpacing makeLiveButton
			-ac meshCenterSnapButton right $iconSpacing snapViewPlaneButton
//			-ac snapButton5          right $iconSpacing snapViewPlaneButton
//			-ac snapGridButton       right $iconSpacing snapButton5
//			-ac snapButton2          right $iconSpacing snapViewPlaneButton
			-ac snapPointButton      right $iconSpacing meshCenterSnapButton
			-ac snapCurveButton      right $iconSpacing snapPointButton
			-ac snapGridButton       right $iconSpacing snapCurveButton

			snapIcons;

		// Create the expand/collapse button separators
		//
		if (!`optionVar -exists "showStatusHistory"`) {
			optionVar -intValue "showStatusHistory" 0;
		}
		separator -h $iconHeight -w $controlSpacing -style "none";
		iconTextButton -vis true -h $iconHeight -w $thinIconWidth
			-annotation (uiRes("m_statusLine.kShowHideHistoryAnnot"))
			-i1 openBar.png  -c ("toggleHistoryIcons(-1)")
			historyCollapse;

		separator -h $iconHeight -w $controlSpacing -style "none";
		// Create the history button and popup
		//
		formLayout historyLayout;

			//	Place both of the symbol buttons in a form layout so that
			//	the popup menu can be attached to the form instead of the
			//	button.  This will prevent the button from looking like it's
			//	still pressed after the popup menu is accessed.
			//
			string $historyForm = `formLayout`;
			iconTextButton
				-w $iconHeight -h $iconHeight
				-annotation (uiRes("m_statusLine.kSelectedInputAnnot"))
				-i1 "historyPulldownIcon.png" historyIcon;
			setParent ..;
			string $futureForm = `formLayout`;
			iconTextButton
				-w $iconHeight -h $iconHeight
				-annotation (uiRes("m_statusLine.kSelectedOutputAnnot"))
				-i1 "futurePulldownIcon.png" futureIcon;
			setParent ..;
			iconTextCheckBox 
				-i1 "constructionHistory.png"
				 -v 0
				-w $iconHeight -h $iconHeight
				-annotation (uiRes("m_statusLine.kConstructToggleAnnot"))
				-cc "constructionHistory -toggle #1"
				constructionHistoryButton;
			updateConstructionHistory;
		setParent ..;

		formLayout -e
			-af $historyForm left 0
			-af $historyForm top 0
			-af $historyForm bottom 0

			-ac $futureForm left $iconSpacing $historyForm
			-af $futureForm top 0
			-af $futureForm bottom 0

			-ac constructionHistoryButton left $iconSpacing $futureForm
			-af constructionHistoryButton top 0

			historyLayout;

		popupMenu -b 1 -p $historyForm -pmc "createHistoryPopup"
			-aob true  historyPopup;
		popupMenu -b 1 -p $futureForm -pmc "createFuturePopup"
			-aob true futurePopup;


		// Create the expand/collapse button separators
		//
		if (!`optionVar -exists "showStatusRender"`) {
			optionVar -intValue "showStatusRender" 1;
		}
		separator -h $iconHeight -w $controlSpacing -style "none";
		iconTextButton -vis true -h $iconHeight -w $thinIconWidth
			-annotation (uiRes("m_statusLine.kShowHidRenderIconsAnnot"))
			-i1 openBar.png  -c ("toggleRenderIcons(-1)")
			renderCollapse;
		separator -h $iconHeight -w $controlSpacing -style "none";

		//
		// Create the rendering icons
		//
		iconTextButton
			-image1 "rvOpenWindow.png"
			-width $iconHeight -height $iconHeight
			-command ("RenderViewWindow")
			-annotation (uiRes("m_statusLine.kOpenRenderView"))
			renderViewButton;

		iconTextButton
			-image1 "rvRender.png"
			-width $iconHeight -height $iconHeight
			-command ("RenderIntoNewWindow")
			-annotation (uiRes("m_statusLine.kRenderCurrentAnnot"))
			renderButton;

		iconTextButton
			-image1 "rvIprRender.png"
			-width $iconHeight -height $iconHeight
			-command ("IPRRenderIntoNewWindow")
			-annotation (uiRes("m_statusLine.kIPRCurrentAnnot"))
			iprRenderButton;

		iconTextButton
			-image1 "rvRenderGlobals.png"
			-width $iconHeight -height $iconHeight
			-command ("unifiedRenderGlobalsWindow")
			-annotation (uiRes("m_statusLine.kRenderSettingsAnnot"))
			renderGlobalsButton;

		string $command = "HypershadeWindow";
		string $annotation = getRunTimeCommandAnnotation($command);
		iconTextButton
			-image1 "hypershadeIcon.png"
			-width $iconHeight -height $iconHeight
			-command $command
			-annotation $annotation
			-version 2016
			-ltVersion 2016
			hypershadeButton;


		// Create the expand/collapse button separators
		//
		if (!`optionVar -exists "showStatusInputField"`) {
			optionVar -intValue "showStatusInputField" 0;
		}
		separator -h $iconHeight -w $controlSpacing -style "none";
		iconTextButton -vis true -h $iconHeight -w $thinIconWidth
			-annotation (uiRes("m_statusLine.kShowHideSelectFieldAnnot"))
			-i1 openBar.png  -c ("toggleInputField(-1)")
			inputFieldCollapse;
		separator -h $iconHeight -w $controlSpacing -style "none";

		//
		// Create the selection fields
		//
		iconTextButton -w 34 -h $iconHeight
			-annotation (uiRes("m_statusLine.kStatusLineInputOptionAnnot"))
			statusFieldButton;

		// Fields for select/rename
		//
		$gTextualInputField = `textField -w 166 statusLineTextualInputField`;

		// Fields for absolute/relative transform
		text -h $iconHeight -align "right" -manage false -label (uiRes("m_statusLine.kNumericalInputX")) numericalInputXLabel;
		$gNumericalInputXField = `textField -w 40 -h $iconHeight -manage false numericalInputXField`;
		text -h $iconHeight -align "right" -manage false -label (uiRes("m_statusLine.kNumericalInputY")) numericalInputYLabel;
		$gNumericalInputYField = `textField -w 40 -h $iconHeight -manage false numericalInputYField`;
		text -h $iconHeight -align "right" -manage false -label (uiRes("m_statusLine.kNumericalInputZ")) numericalInputZLabel;
		$gNumericalInputZField = `textField -w 40  -h $iconHeight -manage false numericalInputZField`;

		//	Attach script jobs to the input field to catch object rename
		//	and selection change events.
		//
		scriptJob -parent $gTextualInputField
			-event "SelectionChanged" ("statusLineUpdateInputField");
		scriptJob -parent $gTextualInputField
			-event "NameChanged" ("statusLineUpdateInputField");

		string $numericAbs  = (uiRes("m_statusLine.kNumericAbs"));
		string $numericRel  = (uiRes("m_statusLine.kNumericRel"));
		string $quickRename = (uiRes("m_statusLine.kQuickRename"));
		string $quickSelect = (uiRes("m_statusLine.kQuickSelection"));

		// Put a menu on the button to change modes
		$menu = `popupMenu -b 1 -p statusFieldButton`;
			radioMenuItemCollection;
			menuItem -label $numericAbs  -radioButton false -c "setQuickFieldMode Abs"		numericalPopupAbs;
			menuItem -label $numericRel  -radioButton false -c "setQuickFieldMode Rel"		numericalPopupRel;
			menuItem -label $quickRename -radioButton false -c "setQuickFieldMode Rename"	numericalPopupRename;
			menuItem -label $quickSelect -radioButton false -c "setQuickFieldMode Select"	numericalPopupSelect;
		setParent -menu ..;

		// Create the quick field option var and set the mode
		if (!`optionVar -exists "quickFieldMode"`) {
			setQuickFieldMode Abs;
		} else {
			setQuickFieldMode `optionVar -query "quickFieldMode"`;
		}

		// Set up the overall formLayout that controls the
		// layout of the various parts of the infoBar
		//
		int $margin = 1;

		//	Fix up the spacing before the Menu Mode option menu. Borders around
		//	option menus are different across platforms. Add a couple pixels
		//	to NT to make the Status Line align better with the Shelf below it.
		//
		int $menuModeSpace = 0;
		if (`about -nt`) {
			$menuModeSpace = 2;
		}

		//	Create the visibility buttons for the Attribute Editor,
		//	Tool Settings, and Channel Box / Layer Editor.
		//
		setParent $statusLine;
		$buttonForm = `formLayout`;

		//	Now the buttons.
		//
		global string $gModelingToolkitButton;
		global string $gAttributeEditorButton;
		global string $gToolSettingsButton;
		global string $gChannelsOrChannelsLayersButton;
		global string $gLayerEditorButton;

		$gModelingToolkitButton = `iconTextCheckBox -image1 "modelToolkit.png"
			-version 2014
			-enable false
			-width $iconHeight -height $iconHeight
			-annotation (uiRes("m_statusLine.kModelToolkit"))
			-changeCommand ("ToggleModelingToolkit") modelingToolkitButton`;

		$gAttributeEditorButton = `iconTextCheckBox -image1 "attributes.png"
			-width $iconHeight -height $iconHeight
			-annotation (uiRes("m_statusLine.kAttrEd"))
			-changeCommand ("ToggleAttributeEditor") attributeEditorButton`;

		$gToolSettingsButton = `iconTextCheckBox -image1 "toolSettings.png"
			-width $iconHeight -height $iconHeight
			-annotation (uiRes("m_statusLine.kTool"))
			-changeCommand ("ToggleToolSettings") toolSettingsButton`;

		if(`optionVar -q channelsLayersSeparate`) {
			$gChannelsOrChannelsLayersButton = `iconTextCheckBox -image1 "channelBox.png"
				-width $iconHeight -height $iconHeight
				-annotation (uiRes("m_statusLine.kChannelBox"))
				-changeCommand ("ToggleChannelBox") channelBoxButton`;
		} else {
			$gChannelsOrChannelsLayersButton = `iconTextCheckBox -image1 "channelLayers.png"
				-width $iconHeight -height $iconHeight
				-annotation (uiRes("m_statusLine.kChannelsLayers"))
				-changeCommand ("ToggleChannelsLayers") channelLayerBoxButton`;
		}

		$gLayerEditorButton = `iconTextCheckBox -image1 "layerEditor.png"
				-width $iconHeight -height $iconHeight
				-annotation (uiRes("m_statusLine.kLayers"))
				-changeCommand ("ToggleLayerBar") layerEditorButton`;

		if(!`optionVar -q channelsLayersSeparate`) {
			iconTextCheckBox -e -visible false $gLayerEditorButton;
		}

		//	Set up the attachments.
		//
		formLayout -edit
			-attachForm    $gModelingToolkitButton        top    $margin
			-attachForm    $gModelingToolkitButton        left   0
			-attachNone    $gModelingToolkitButton        bottom
			-attachNone    $gModelingToolkitButton        right

			-attachForm    $gAttributeEditorButton        top    $margin
			-attachControl $gAttributeEditorButton		  left   $iconSpacing $gModelingToolkitButton
			-attachNone    $gAttributeEditorButton        bottom
			-attachNone    $gAttributeEditorButton        right

			-attachForm    $gToolSettingsButton           top    $margin
			-attachControl $gToolSettingsButton           left   $iconSpacing $gAttributeEditorButton
			-attachNone    $gToolSettingsButton           bottom
			-attachNone    $gToolSettingsButton           right

			-attachForm    $gChannelsOrChannelsLayersButton  top    $margin
			-attachControl $gChannelsOrChannelsLayersButton  left   $iconSpacing $gToolSettingsButton
			-attachNone    $gChannelsOrChannelsLayersButton  bottom
			-attachNone    $gChannelsOrChannelsLayersButton  right

			-attachForm    $gLayerEditorButton  top    $margin
			-attachControl $gLayerEditorButton  left   $iconSpacing $gChannelsOrChannelsLayersButton
			-attachNone    $gLayerEditorButton  bottom
			-attachNone    $gLayerEditorButton  right
			$buttonForm;

		//	Attachemnts for the Status Line and the new visibility buttons.
		//
		//	Note that the layout is set up this way so that the buttons
		//	will always be visible even if the main Maya window is not
		//	wide enough to show all the original Status Line controls.
		//
		formLayout -edit
			-attachForm    $gStatusLine  top    0
			-attachForm    $gStatusLine  left   0
			-attachForm    $gStatusLine  bottom 0
			-attachControl $gStatusLine  right  0 $buttonForm

			-attachForm    $buttonForm   top    0
			-attachNone    $buttonForm   left
			-attachForm    $buttonForm   bottom 0
			-attachForm    $buttonForm   right  0
			$statusLine;

	toggleFileIcons(`optionVar -q showStatusFiles`);
	toggleSelectionSetIcons(`optionVar -q showStatusSelectionSet`);
	toggleSelectModeIcons(`optionVar -q showStatusSelectMode`);
	toggleSelectMaskIcons(`optionVar -q showStatusSelectMasks`);
	toggleSnapIcons(`optionVar -q showStatusSnap`);
	toggleHistoryIcons(`optionVar -q showStatusHistory`);
	toggleRenderIcons(`optionVar -q showStatusRender`);
	toggleInputField(`optionVar -q showStatusInputField`);

	// Add popupMenus to the infoBar layout
	//
	ObjectMaskPopup objPickMenuLayout;
	ComponentMaskPopup compPickMenuLayout;

	// Setup conditions to run when the selection mask
	// changes, to keep the icons on the toolbar in sync
	// with the current selection mask settings.
	//
	scriptJob -permanent -parent $gStatusLine -event "SelectModeChanged"
		updateSelectionModeIcons;
	scriptJob -permanent -parent $gStatusLine -event "SelectTypeChanged"
		updateObjectSelectionMasks;
	scriptJob -permanent -parent $gStatusLine -event "SelectTypeChanged"
		updateComponentSelectionMasks;
	scriptJob -permanent -parent $gStatusLine -event "snapModeChanged"
		updateSnapMasks;
	scriptJob -permanent -parent $gStatusLine -event "constructionHistoryChanged"
		updateConstructionHistory;
	scriptJob -permanent -parent $gStatusLine -event "SelectPreferenceChanged"
		"iconTextCheckBox -e -v `selectPref -q -xformNoSelect` lockSelectionIcon";
	scriptJob -permanent -parent $gStatusLine -event "SelectPreferenceChanged"
		"updateHighlightSelectIcon";

	// Run the above events now, to ensure that the icons
	// are in sync upon Maya's startup
	//
	updateObjectSelectionMasks;
	updateComponentSelectionMasks;
	updateSnapMasks;
	updateHighlightSelectIcon;

	// Set the select state of the editor toggle
	// buttons based on current visibility
	//
	updateEditorToggleCheckboxes();

	//	Attach Status line to parent.
	//
	formLayout -edit
		-attachForm $statusLine "top"    0
		-attachForm $statusLine "left"   0
		-attachForm $statusLine "bottom" 0
		-attachForm $statusLine "right"  0
		$gStatusLineForm;

	setUIComponentStateCallback(
		"Status Line", "statusLineVisibilityStateChange");

	updateStatusLineRendererSpecificUI();
}

global proc int statusLineVisibilityStateChange(
	int    $newState,
	string $layout)
//
//	Description:
//		This procedure is called whenever the visibility state of the
//		Status Line is changed.
//
//	Arguments:
//		newState - The new visibile state of the Status Line.
//
//		layout - The parent layout for the Status Line.
//
//	Returns:
//		true - If the change of state is to be allowed.
//
//		false - If the state change is rejected.
//
{
	int $result = true;

	//	Defer these commands because this proc is called when the visibility
	//	state is about to change. This proc must return true to accept
	//	the state change. After this proc returns then restore the
	//	panel focus and update the pref menu.
	//
	evalDeferred("restoreLastPanelWithFocus(); updatePrefsMenu();");

	return $result;
}

global proc toggleChannelsLayersButtons()
//
//	Description:
//		This procedure is called whenever the user toggles the
//		preference of whether the Channel Box and Layer Editor
//		are to be displayed as one dock widget or two.
//
//		Switches between one or two editor toggle buttons on
//		the status line (either one for Channel Box / Layer
//		Editor, or two for Channel Box and Layer Editor).
//
{
	global string $gChannelsOrChannelsLayersButton;
	global string $gLayerEditorButton;

	if(`optionVar -q channelsLayersSeparate`) {
		iconTextCheckBox -e
				-image1 "channelBox.png"
				-annotation (uiRes("m_statusLine.kChannelBox"))
				-changeCommand ("ToggleChannelBox")
				$gChannelsOrChannelsLayersButton;
		iconTextCheckBox -e -visible true $gLayerEditorButton;
	} else {
		iconTextCheckBox -e
				-image1 "channelLayers.png"
				-annotation (uiRes("m_statusLine.kChannelsLayers"))
				-changeCommand ("ToggleChannelsLayers")
				$gChannelsOrChannelsLayersButton;
		iconTextCheckBox -e -visible false $gLayerEditorButton;
	}
}
