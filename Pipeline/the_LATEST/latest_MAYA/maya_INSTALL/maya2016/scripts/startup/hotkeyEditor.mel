// Copyright (C) 1997-2014 Autodesk, Inc., and/or its licensors.
// All rights reserved.
//
// The coded instructions, statements, computer programs, and/or related
// material (collectively the "Data") in these files contain unpublished
// information proprietary to Autodesk, Inc. ("Autodesk") and/or its licensors,
// which is protected by U.S. and Canadian federal copyright law and by
// international treaties.
//
// The Data is provided for use exclusively by You. You have the right to use,
// modify, and incorporate this Data into other products for purposes authorized 
// by the Autodesk software license agreement, without fee.
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND. AUTODESK
// DOES NOT MAKE AND HEREBY DISCLAIMS ANY EXPRESS OR IMPLIED WARRANTIES
// INCLUDING, BUT NOT LIMITED TO, THE WARRANTIES OF NON-INFRINGEMENT,
// MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE, OR ARISING FROM A COURSE 
// OF DEALING, USAGE, OR TRADE PRACTICE. IN NO EVENT WILL AUTODESK AND/OR ITS
// LICENSORS BE LIABLE FOR ANY LOST REVENUES, DATA, OR PROFITS, OR SPECIAL,
// DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES, EVEN IF AUTODESK AND/OR ITS
// LICENSORS HAS BEEN ADVISED OF THE POSSIBILITY OR PROBABILITY OF SUCH DAMAGES.

//
//  Description:
//	This contains procedures necessary for
//	the Hotkey/NameCommand editor.
//

/*
//
//	These are the local and global procedures defined in this file.  As well
//	as the unique names of the UI objects created.
//
// ----------------------------------------------------------------------
//

//	Local procedures.
//
string constructHotkeyCommand(string $key, int $ctrl,
	int $alt, int $press, string $command)

int isValidKey(string $name)
int isValidName(string $name)
int isUniqueName(string $name)
int isValidCategory(string $name)
int isExistingCategory(string $name)
string getCurrentCategory()
string getCurrentRunTimeCommand()
int getNameCommand(string $nameCommand)
string [] getAllHotkeys(string $command)

updateCommandInfo()
updateCommandButtons()
updateRemoveHotkeyButton()
updateCurrentHotkeys()
enableNewHotkeyArea(int $enable);
setQueryHotkeyText(string $label)
int updateQueryHotkeyText()
updateCommandTextScrollList(string $command)
updateCategoryPopupMenu()
updateKeyPopupMenu()

removeHotkey(string $hotkey)
deleteRunTimeCommand(string $command)

createCommandListArea()
createCommandInfoArea()
createCurrentHotkeyArea()
createNewHotkeyArea()
createButtonsArea()

resetCreateOrEditMode()

//	Global procedures.
//
string[] getAllValidKeys()
string getHotkeyCommand(string $key, int $ctrl,
	int $alt, int $press)
string getRunTimeCommandFromNameCommand(string $nameCommand)

hotkeyEditorCategoryTextScrollListSelect()
hotkeyEditorCommandTextScrollListSelect()

hotkeyEditorHotkeyKeyFieldChange()
hotkeyEditorHotkeyCtrlCheckBoxChange()
hotkeyEditorHotkeyAltCheckBoxChange()
hotkeyEditorHotkeyPressRadioButtonChange()
hotkeyEditorHotkeyReleaseRadioButtonChange()
hotkeyEditorHotkeyTextScrollListSelect()

hotkeyEditorKeyPopupMenuSelect(string $key)
hotkeyEditorCategoryPopupMenuSelect(string $category)

hotkeyEditorCreateCommand()
hotkeyEditorEditCommand()
hotkeyEditorDeleteCommand()
hotkeyEditorAcceptCommand()
hotkeyEditorCancelCommand()
hotkeyEditorSearchForRunTimeCommand()

hotkeyEditorAssignHotkey()
hotkeyEditorQueryHotkey()
hotkeyEditorFindHotkey()
hotkeyEditorRemoveHotkey()
hotkeyEditorRestoreDefaultHotkeys()
hotkeyEditorListAllHotkeys()

hotkeyEditorSave()
hotkeyEditorClose()

hotkeyEditor()

//	Interface for Marking Menu Editor - These procedures
//	should not be called from anywhere else.
//
string hotkeyEditor_generatePressAnnotationForMM(string)
string hotkeyEditor_generateReleaseAnnotationForMM(string)
int hotkeyEditor_createMarkingMenu(string, string, string) 
hotkeyEditor_deleteMarkingMenu(string)
int hotkeyEditor_renameMarkingMenu(string, string, string, string)
int hotkeyEditor_doesMarkingMenuExist(string)

global int $gHotkeyEditorInCreateMode;
global int $gHotkeyEditorInEditMode;

//	Names of UI objects.
//
HotkeyEditor

HotkeyEditorCategoryTextScrollList
HotkeyEditorCommandTextScrollList

HotkeyEditorNameField
HotkeyEditorDescriptionField
HotkeyEditorCategoryField
HotkeyEditorCategoryPopupMenuButton
HotkeyEditorCategoryPopupMenu
HotkeyEditorLanguageRadioGrp
HotkeyEditorCommandField

HotkeyEditorCreateCommandButton
HotkeyEditorEditCommandButton
HotkeyEditorDeleteCommandButton
HotkeyEditorAcceptCommandButton
HotkeyEditorCancelCommandButton
HotkeyEditorSearchButton

HotkeyEditorHotkeyTextScrollList
HotkeyEditorRemoveHotkeyButton
HotkeyEditorRestoreDefaultHotkeysButton
HotkeyEditorListAllHotkeysButton

HotkeyEditorKeyLabel
HotkeyEditorKeyField
HotkeyEditorKeyPopupMenuButton
HotkeyEditorKeyPopupMenu
HotkeyEditorModifierLabel
HotkeyEditorCtrlCheckBox
HotkeyEditorAltCheckBox
HotkeyEditorDirectionLabel
HotkeyEditorPressRadioButton
HotkeyEditorReleaseRadioButton
HotkeyEditorRepeatableLabel
HotkeyEditorRepeatableCheckBox
HotkeyEditorDragPressLabel
HotkeyEditorDragPressCheckBox
HotkeyEditorAssignHotkeyButton
HotkeyEditorQueryHotkeyButton
HotkeyEditorFindHotkeyButton
HotkeyEditorQueryResultText

HotkeyEditorSaveButton
HotkeyEditorCloseButton
*/


proc string constructHotkeyCommand(
	string $key,
	int    $ctrl,
	int    $alt,
	int	    $cmd,
	int    $press,
	int    $repeat,
	int	   $dragPress,
	string $command)
//
//	Description:
//		Construct and return a string containing a valid hotkey command
//		that can be passed to the eval() funtion.
//
//	Arguments:
//		key		- The key string.
//		ctrl	- True if Ctrl modifer is required, false otherwise.
//		alt		- True if Alt modifer is required, false otherwise.
//		press	- True for key press, false for key release.
//		repeat	- True if the hotkey is repeatable, false otherwise.
//		dragPress - True if the hotkey can be used during manip drag.
//		command	- The command string to execute.
//
{
	//	Must surround the key string in double quote characters.
	//
	string $result = ("hotkey -k \"");

	//	Must preceed back slashes and double quote characters with
	//	a backslash.
	//
	if ("\\" == $key || "\"" == $key) $key = "\\" + $key;
	
	$result += ($key + "\" ");

	if ($ctrl) $result += "-ctl ";
	if ($alt) $result += "-alt ";
	if ($cmd) $result += "-cmd ";

	if ($press) $result += "-name \"";
	else $result += "-releaseName \"";

	$result += ($command + "\" ");

	if ($press) $result += "-pressCommandRepeat ";
	else $result += "-releaseCommandRepeat ";

	$result += $repeat;
	
	if ( $dragPress ) $result += " -dragPress true";
	
	return $result;
}

proc int keyNeedsShift(string $key)
//
//	Description:
//		Return true if the given key code uses the shift modifier.
//		
{
	// Shift is obviously needed for any uppercase letter and for bunch of characters that are typed using shift
	return `gmatch $key "[A-Z~!@#$%^&*()_+{}|:<>?\"]"`;
}

proc int isValidKey(string $name)
//
//	Description:
//		Return true if the given string corresponds to a valid key
//		that a hotkey can be assigned to.
//
//		See the getAllValidKeys() procedure for a list of all the
//		valid keys.  For example, "a", "Page_Down", and "\\" are all
//		valid keys.  However, "Foo", " ", and "f1" (must be uppercase) 
//		are not.
//		
{
	int $result = false;
	string $keys[] = getAllValidKeys();
	
	for ($key in $keys) {
		if ($name == $key) {
			$result = true;
			break;
		}
	}

	return $result;
}

proc int isValidName(string $name)
//
//	Description:
//		Determine if the given string is potentially a valid name.
//		Note that this procedure does not test to see if the name is
//		unique, it just tests the string characters.
//
//		Check to ensure that the string does not begin with a number
//		and is followed only by alphanumeric characters or underscores.
//
{
	int $result = false;

	if ("" != $name) {
		//
		//	Begins with letter or underscore, followed by
		//	letters, digits, or underscores.
		//
		string $regExpr = "([a-zA-Z_]+)([[a-zA-Z0-9_])*";
		string $temp = match($regExpr, $name);
		if ($temp == $name) {
			$result = true;
		}
	}

	return $result;
}

proc int isUniqueName(string $name)
//
//	Description:
//		Determine if the given string is a unique name.
//
//		Compare it with existing commands, scripts, and procedures.
//
{	
	int $result = false;

	if ("Unknown" == `whatIs $name`) {
		$result = true;
	}

	return $result;
}

proc int isValidCategory(string $category)
//
//	Description:
//		Determine if the given string is potentially a valid category.
//
//		Check to ensure that the string does not begin with a number
//		and is followed only by alphanumeric characters, underscores,
//		or spaces.
//
{
	int $result = false;

	if ("" != $category) {
		//
		//	Begins with letter or underscore, followed by
		//	letters, digits, spaces, or underscores.
		//
		string $regExpr = "([a-zA-Z_]+)([[a-zA-Z0-9_ ])*";
		string $temp = match($regExpr, $category);
		if ($temp == $category) {
			$result = true;
		}
	}

	return $result;
}

proc int isExistingCategory(string $name)
//
//	Description:
//		Determine if the given category already exists.
//
{
	int $result = false;

	string $categories[] = `textScrollList -query -allItems 
		HotkeyEditorCategoryTextScrollList`;

	int $index, $numberOfCategories = size($categories);

	for ($index = 0; $index < $numberOfCategories; $index++) {
		if ($name == $categories[$index]) {
			$result = true;
			break;
		}
	}	

	return $result;
}

proc string getNameErrorMessage(string $name)
//
//	Description:
//		Construct an appropriate error message for the given name.
//
//		The error message will take into consideration whether
//		the name already refers to a command, script or procedure.
//
//		An empty string is returned if the name is unique.
//
{
	string $result = "";

	string $whatIsResult = `whatIs $name`;
	string $buffer[];
	int $tokenCount = `tokenize $whatIsResult $buffer`;

	string $message;
	switch ($tokenCount) {
		case 1:
			if ("Unknown" == $buffer[0]) {
				$result = "";

			} else if ("Command" == $buffer[0]) {
				$message = (uiRes("m_hotkeyEditor.kNameExist"));
				$result = `format -s $name $message`;
			} else {
				$message = (uiRes("m_hotkeyEditor.kNameNotUnique"));
				$result = `format -s $name $message`;
			}
			break;

		case 4:
			$message = (uiRes("m_hotkeyEditor.kNameAlreadyExist"));
			$result = `format -s $name -s $buffer[3] $message`;
			break;

		case 5:
			$message = (uiRes("m_hotkeyEditor.kMELExist"));
			$result = `format -s $name -s $buffer[4] $message`;
			break;

		default:
			$message = (uiRes("m_hotkeyEditor.kNameIsNotUnique"));
			$result = `format -s $name $message`;
			break;
	}

	return $result;
}

proc string getCurrentCategory()
//
//	Description:
//		Determine the current category of commands being displayed in the
//		Hotkey Editor.
//
{
	string $result = "", $category[];

	$category = `textScrollList -query -selectItem HotkeyEditorCategoryTextScrollList`;

	if (size($category) > 0 && "Uncategorized" != $category[0]) {
		$result = $category[0];
	}

	return $result;
}

proc string getCurrentRunTimeCommand()
//
//	Description:
//		Determine the runTimeCommand currently selected by the user.
//
//	Returns:
//		A string containing the name of the current selected 
//		runTimeCommand.  If no command is selected then an empty 
//		string is returned.
//
{
	string $result = "", $command[];

	$command = `textScrollList -query -selectItem HotkeyEditorCommandTextScrollList`;

	if (size($command) > 0) {
		$result = $command[0];
	}

	return $result;
}

proc int getNameCommand(string $nameCommand)
//
//	Description:
//		Determine if a nameCommand with the given name exists.
//
//	Arguments:
//		nameCommand	- The $nameCommand.
//
//	Returns:
//		If the nameCommand exists then a 1 based index is returned.
//		This index can then be used for querying with the 'assignCommand'
//		command.
//
//		If the nameCommand does not exist then 0 is returned.
//
{
	int $result = 0, $index;
	int $numberOfNameCommands = `assignCommand -query -numElements`;

	for ($index = 1; $index <= $numberOfNameCommands; $index++) {
		if ($nameCommand == `assignCommand -query -name $index`) {
			$result = $index;
			break;
		}
	}

	return $result;
}

proc string [] getAllHotkeys(string $command)
//
//	Description:
//		Determine all the hotkeys that will invoke the specified
//		runTimeCommand.
//
//	Returns:
//		A string array containing all the hotkeys attahed to the
//		specified command.  Each string element in the array will
//		full describe the hotkey, for example: "Ctrl b", or "Alt Space",
//		or "N Release".
//
{
	string $result[], $keyInfo[], $hotkey, $cmd;
	int $resultIndex = 0, $index, $numberOfNameCommands;
	int $hotkeyInfoIndex, $numberOfHotkeys;

	if ("" != $command) {
		$numberOfNameCommands = `assignCommand -query -numElements`;
		for ($index = 1; $index <= $numberOfNameCommands; $index++) {
			$cmd = `assignCommand -query -command $index`;
			//
			//	Is this nameCommand pointing to the target runTimeCommand?
			//
			if ($cmd == $command) {
				//
				//	For this nameCommand determine all the hotkeys
				//	that point to it.
				//
				$keyInfo = AWAppendStringsToStringArray(
					`assignCommand -query -keyArray $index`, $keyInfo);

				//	Don't stop searching.  There may be other nameCommand
				//	objects that point to the specified runTimeCommand.
			}
		}
	}

	//	The keyInfo array should now contain all the hotkeys that
	//	point to the target runTimeCommand.
	//
	$hotkeyInfoIndex = 0;
	$numberOfHotkeys = size($keyInfo) / 5;
	for ($index = 0; $index < $numberOfHotkeys; $index++) {
		$hotkey = "";
		if ("1" == $keyInfo[$hotkeyInfoIndex + 2]) {
			if (`about -mac`) {
				$hotkey += ((uiRes("m_hotkeyEditor.kControl")) + "+" );
			}
			else {
				$hotkey += ((uiRes("m_hotkeyEditor.kCtrl")) + "+" );
			}
		}
		if ("1" == $keyInfo[$hotkeyInfoIndex + 1]) {
			if (`about -mac`) {
				$hotkey += ((uiRes("m_hotkeyEditor.kOption")) + "+" );
			}
			else {
				$hotkey += ((uiRes("m_hotkeyEditor.kAlt")) + "+" );
			}
		}

		if ("1" == $keyInfo[$hotkeyInfoIndex + 4]) {
			$hotkey += ((uiRes("m_hotkeyEditor.kCommand")) + "+" );
		}

		if (" " == $keyInfo[$hotkeyInfoIndex]) {
			if (`about -mac`) {
				$hotkey += ("space");
			}
			else {
				$hotkey += ("Space");
			}
		} else {
			$hotkey += $keyInfo[$hotkeyInfoIndex];
		}

		if ("1" == $keyInfo[$hotkeyInfoIndex + 3]) {
			$hotkey += ( " " + (uiRes("m_hotkeyEditor.kRelease")) );
		}

// Command keys needs to be taken care of. So an extra field in the array. - Vidya.

		$hotkeyInfoIndex += 5;

		$result[$resultIndex++] = $hotkey;
	}

	return $result;
}

proc updateCommandInfo()
//
//	Description:
//		Update the UI that displays information on the current
//		selected runTimeCommand.
//
//		This procedure should be called whenever the current selected
//		runTimeCommand is changed.
//
{
	global int $gHotkeyEditorInCreateMode;
	global int $gHotkeyEditorInEditMode;

	string $name, $description, $category;
	int $nameEditable = false, $descriptionEditable = false;
	int $categoryEditable = false;
	string $command, $focus;
	int $commandEditable = false;
	int $commandLanguageEditable = false;
	int $commandLanguageRadioIndex = 1;

	//	Get the current selected runTimeCommand and category.
	//
	$name = getCurrentRunTimeCommand();
	$category = getCurrentCategory();

	if ("" != $name) {
		//
		//	Get the runTimeCommand's description and command.
		//
		$description = `runTimeCommand -query -annotation $name`;
		$command = `runTimeCommand -query -command $name`;
		$commandLanguageRadioIndex = `runTimeCommand -query -commandLanguage $name` == "python" ? 2 : 1;
	}

	if ($gHotkeyEditorInCreateMode) {
		//
		//	In Create mode, ie. the user pressed the "Create" button.
		//
		//	In this mode clear out the name, description, and command
		//	fields so the user can type in new values.
		//
		//	Don't clear out the category field, it's most likely the
		//	user will want to add the command to the current category.
		//
		$name = "";
		$description = "";
		$command = "";
		$commandLanguageRadioIndex = 1;

		//	Be sure to enable all the fields for editing.
		//
		$nameEditable = true;
		$descriptionEditable = true;
		$categoryEditable = true;
		$commandEditable = true;
		$commandLanguageEditable = true;

		//	Send keyboard focus to the name field.
		//
		$focus = "HotkeyEditorNameField";
		
	} else if ($gHotkeyEditorInEditMode) {
		//
		//	In Edit mode, ie. the user pressed the "Edit" button.
		//
		//	Don't clear out any of the fields, but do make them all
		//	editable.
		//
		$nameEditable = true;
		$descriptionEditable = true;
		$categoryEditable = true;
		$commandEditable = true;
		$commandLanguageEditable = true;		

		//	Send keyboard focus to the name field.
		//
		$focus = "HotkeyEditorNameField";

	} else {
		//
		//	No mode.
		//
	}

	//	Update the controls.
	//
	textField -edit -text $name -editable $nameEditable
		HotkeyEditorNameField;
	textField -edit -text $description -insertionPosition 1
		-editable $descriptionEditable
		HotkeyEditorDescriptionField;
	textField -edit -text $category
		-editable $categoryEditable
		HotkeyEditorCategoryField;
	iconTextButton -edit
		-enable $categoryEditable
		HotkeyEditorCategoryPopupMenuButton;
	scrollField -edit -text $command -insertionPosition 1 
		-editable $commandEditable
		HotkeyEditorCommandField;
    radioButtonGrp -edit -select $commandLanguageRadioIndex 
        -enable $commandLanguageEditable HotkeyEditorLanguageRadioGrp;

	if(`about -mac`){
	  scrollField -edit -editable $commandEditable HotkeyEditorCommandField;
	}



	//	Set keyboard focus.
	//
	if ("" != $focus) {
		setFocus $focus;
	}
}

proc updateCommandButtons()
//
//	Description:
//		Update the command buttons.
//
//		This procedure should be called whenever the current selected
//		runTimeCommand is changed, or when the mode of the command 
//		area changes.
//
{
	global int $gHotkeyEditorInCreateMode;
	global int $gHotkeyEditorInEditMode;

	int $enableCreate = false, $enableEdit = false;
	int $enableDelete = false, $enableSearch = false;
	int $enableAccept = false, $enableCancel = false;

	string $key = `textField -query -text HotkeyEditorKeyField`;
	string $command = getCurrentRunTimeCommand();
	string $hotkeys[];

	//	Should the Create Command button be enabled?
	//
	//	It should always be enabled except for when the user presses
	//	it or the Edit Command button.  When that happens the button
	//	should be disabled until the user presses either the 
	//	Accept or Cancel button.
	//
	if (!$gHotkeyEditorInCreateMode && !$gHotkeyEditorInEditMode) {
		$enableCreate = true;
	}

	//	Should the Edit Command button be enabled?
	//
	//	It should be enabled if the selected command is not a default
	//	one and if the user has not already pressed the Edit or Create
	//	Command button.
	//
	if (!$gHotkeyEditorInCreateMode && !$gHotkeyEditorInEditMode &&
		"" != $command && !`runTimeCommand -query -default $command`) {
		$enableEdit = true;
	}

	//	Should the Delete command button be enabled?
	//
	//	It should be enabled if the selected command is not a default
	//	one and if the user has not already pressed the Edit or Create
	//	Command button.
	//
	if (!$gHotkeyEditorInCreateMode && !$gHotkeyEditorInEditMode &&
		"" != $command && !`runTimeCommand -query -default $command`) {
		$enableDelete = true;
	}

	//	Should the Accept Command button be enabled?
	//
	//	If the editor is in Create or Edit command mode then yes it should.
	//
	if ($gHotkeyEditorInCreateMode || $gHotkeyEditorInEditMode) {
		$enableAccept = true;
	}

	//	Should the Cancel Command button be enabled?
	//
	//	If the editor is in Create or Edit command mode then yes it should.
	//
	if ($gHotkeyEditorInCreateMode || $gHotkeyEditorInEditMode) {
		$enableCancel = true;
	}

	//	Should the Search button be enabled?
	//
	//	It should always be enabled except for when the user presses
	//	it or the Edit Command button.  
	//
	if (!$gHotkeyEditorInCreateMode && !$gHotkeyEditorInEditMode) {
		$enableSearch = true;
	}

	button -edit -enable $enableCreate HotkeyEditorCreateCommandButton;
	button -edit -enable $enableEdit HotkeyEditorEditCommandButton;
	button -edit -enable $enableDelete HotkeyEditorDeleteCommandButton;
	button -edit -enable $enableAccept HotkeyEditorAcceptCommandButton;
	button -edit -enable $enableCancel HotkeyEditorCancelCommandButton;
	button -edit -enable $enableSearch HotkeyEditorSearchButton;
}

proc updateRemoveHotkeyButton()
//
//	Description:
//		Update the remove hotkey button.
//
//		This procedure should be called whenever the current hotkey
//		selection changes.
//
{
	int $enableRemove = false;

	//	Should the Remove Hotkey button be enabled?
	//
	//	If there is a Hotkey selected in the Current Hotkeys list then
	//	yes it should.
	//
	$hotkeys = `textScrollList -query -selectItem 
		HotkeyEditorHotkeyTextScrollList`;
	
	if (size($hotkeys) > 0) {
		$enableRemove = true;
	}

	button -edit -enable $enableRemove HotkeyEditorRemoveHotkeyButton;
}

proc updateCurrentHotkeys()
//
//	Description:
//		Update the area that informs the user what hotkeys are currently
//		assigned to the selected runTimeCommand.
//
{
	string $runTimeCommand = getCurrentRunTimeCommand();
	string $hotkey, $hotkeys[];
	textScrollList -edit -removeAll HotkeyEditorHotkeyTextScrollList;

	//	Search through all nameCommands for the ones that point
	//	to the runTimeCommand argument.
	//
	$hotkeys = getAllHotkeys($runTimeCommand);

	for ($hotkey in $hotkeys) {
		textScrollList -edit -append $hotkey HotkeyEditorHotkeyTextScrollList;
	}
	
	updateRemoveHotkeyButton();
}

proc enableNewHotkeyArea(int $enable)
//
//	Description:
//		Update the enable state of the new hotkey assignment UI.
//
{
	text -edit -enable $enable HotkeyEditorKeyLabel;
	textField -edit -enable $enable HotkeyEditorKeyField;
	iconTextButton -edit -enable $enable HotkeyEditorKeyPopupMenuButton;
	text -edit -enable $enable HotkeyEditorModifierLabel;
	checkBox -edit -enable $enable HotkeyEditorCtrlCheckBox;
	checkBox -edit -enable $enable HotkeyEditorAltCheckBox;
	if(`about -macOS`){
		checkBox -edit -enable $enable HotkeyEditorCmdCheckBox;
	}
	text -edit -enable $enable HotkeyEditorDirectionLabel;
	radioButton -edit -enable $enable HotkeyEditorPressRadioButton;
	radioButton -edit -enable $enable HotkeyEditorReleaseRadioButton;
	text -edit -enable $enable HotkeyEditorRepeatableLabel;
	checkBox -edit -enable $enable HotkeyEditorRepeatableCheckBox;
	text -edit -enable $enable HotkeyEditorDragPressLabel;
	checkBox -edit -enable $enable HotkeyEditorDragPressCheckBox;
	button -edit -enable $enable HotkeyEditorAssignHotkeyButton;
	button -edit -enable $enable HotkeyEditorQueryHotkeyButton;
	button -edit -enable $enable HotkeyEditorFindHotkeyButton;
}

proc setQueryHotkeyText(string $label)
//
//	Description:
//		Set the query text message.
//
{
	text -edit -label $label HotkeyEditorQueryResultText;
}

proc int updateQueryHotkeyText()
//
//	Description:
//		Update the text that displays the current hotkey mapping.
//
//	Returns:
//		True if the query was successful, false otherwise.  A
//		query may be unsuccessful if the user enters an invalid
//		value in the key field.
//
{
	int $result = false, $cmd=0;

	string $modifierKey = "";
	string $releaseKey = "";
	string $assigned; 
	string $label;
	string $labelMsg;
	string $category;
	
	string $key = `textField -query -text HotkeyEditorKeyField`;
	int $ctrl = `checkBox -query -value HotkeyEditorCtrlCheckBox`;
	int $alt = `checkBox -query -value HotkeyEditorAltCheckBox`;
	int $press = `radioButton -query -select HotkeyEditorPressRadioButton`;
	if(`about -macOS`){
		$cmd = `checkBox -query -value HotkeyEditorCmdCheckBox`;
	}

	if ("" == $key || !isValidKey($key)) {
		$result = false;

	} else {
		$result = true;

		if ($ctrl) {
			if (`about -mac`) {
				$modifierKey += (uiRes("m_hotkeyEditor.kControlKey"));
			}
			else {
				$modifierKey += (uiRes("m_hotkeyEditor.kCtrlKey"));
			}
		}
		if ($alt) {
			if (`about -mac`) {
				$modifierKey += (uiRes("m_hotkeyEditor.kOptionKey"));
			}
			else {
				$modifierKey += (uiRes("m_hotkeyEditor.kAltKey"));
			}
		}
		if($cmd){
			$modifierKey += (uiRes("m_hotkeyEditor.kCommandKey"));
		}

		if (!$press) {
			$releaseKey += (uiRes("m_hotkeyEditor.kReleaseKey"));
		}

		string $command = getHotkeyCommand($key, $ctrl, $alt, $cmd, $press);
		if ("" == $command) {
			$assigned = (uiRes("m_hotkeyEditor.kNothing"));

			$label = (uiRes("m_hotkeyEditor.kQueryMsg4"));
			$labelMsg = `format -s $modifierKey -s $key -s $releaseKey -s $assigned $label`;
		} else {
			$assigned = $command;

			$category = `runTimeCommand -query -category $command`;

			$label = (uiRes("m_hotkeyEditor.kQueryMsg5"));
			$labelMsg = `format -s $modifierKey -s $key -s $releaseKey -s $assigned -s $category $label`;
		}
		setQueryHotkeyText($labelMsg);
	}

	return $result;
}

proc updateCommandTextScrollList(string $command)
//
//	Description:
//		Fill in the command list with all the commands that belong to
//		the current selected category.
//
//		If a command argument is passed in then make sure that command 
//		is selected and visible in the list.
//
{
	string $list = "HotkeyEditorCommandTextScrollList";

	string $selectedCategory[], $category, $runTimeCommands[];
	string $commandList[], $sortedCommandList[];

	int $index, $numberOfItems, $numberOfCommands, $showItem;

	waitCursor -state on;

	$numberOfCommands = 0;
	$selectedCategory = `textScrollList -query -selectItem HotkeyEditorCategoryTextScrollList`;

	if (1 == size($selectedCategory)) {
		if ("Uncategorized" == $selectedCategory[0]) {
			$selectedCategory[0] = "";			
		}

		if (0 < `textScrollList -query -numberOfItems $list`) {
			textScrollList -edit -removeAll $list;
		}

		//	Lets present this list in alphabetical order to make it easier to read.

		$runTimeCommands = `runTimeCommand -query -commandArray`;
		for ($index = 0; $index < size($runTimeCommands); $index++) {
			$category = `runTimeCommand -query -category $runTimeCommands[$index]`;
			if ($selectedCategory[0] == $category) {
				$commandList[ $numberOfCommands ] = $runTimeCommands[$index];
				$numberOfCommands += 1;
				// Was: textScrollList -edit -append $runTimeCommands[$index] $list;
			}
		}
	}

	$sortedCommandList = sort( $commandList );
	for ($index = 0; $index < $numberOfCommands; $index++) {
		textScrollList -edit -append $sortedCommandList[$index] $list;
	}
	
	if ("" == $command) {
		//
		//	Select the first command.
		//
		if (0 < `textScrollList -query -numberOfItems $list`) {
			textScrollList -edit -selectIndexedItem 1 $list;
		}

	} else {
		//
		//	Select the specified command.
		//
		textScrollList -edit -selectItem $command $list;
	}

	updateCurrentHotkeys();
	updateCommandInfo();
	updateCommandButtons();

	waitCursor -state off;
}

proc updateCategoryPopupMenu()
//
//	Description:
//		Fill in the category popup menu with all the categories.
//
{
	string $categories[] = `textScrollList -query -allItems 
		HotkeyEditorCategoryTextScrollList`;

	int $index, $numberOfCategories = size($categories);

	popupMenu -edit -deleteAllItems HotkeyEditorCategoryPopupMenu;

	setParent -menu HotkeyEditorCategoryPopupMenu;

	for ($index = 0; $index < $numberOfCategories; $index++) {
		menuItem -label $categories[$index]
			-enableCommandRepeat false
			-command ("hotkeyEditorCategoryPopupMenuSelect \"" +
				$categories[$index] + "\"");
	}
}

proc updateKeyPopupMenu()
//
//	Description:
//		Fill in the key popup menu with all the special keys.
//
{
	string $keys[];
	int $index, $numberOfKeys;
	string $keys1[] = {"Up", "Down", "Left", "Right", 
			"Page_Up", "Page_Down", "Home","End",
			"Return", "Space",
			"F1", "F2", "F3", "F4", "F5", "F6", "F7", "F8", 
			"F9", "F10", "F11", "F12" };

	string $keys2[] = {"Up", "Down", "Left", "Right", 
			"Page_Up", "Page_Down", "Home", "End", "Insert",
			"Return", "Space",
			"F1", "F2", "F3", "F4", "F5", "F6", "F7", "F8", 
			"F9", "F10", "F11", "F12" };
	if (`about -mac`)
	{
		$numberOfKeys = size($keys1);
		for($index = 0; $index < $numberOfKeys; $index++)
		{
			$keys[$index] = $keys1[$index];
		}
	}
	else
	{
		$numberOfKeys = size($keys2);
		for($index = 0; $index < $numberOfKeys; $index++)
		{
			$keys[$index] = $keys2[$index];
		}
	}

	 $numberOfKeys = size($keys);

	popupMenu -edit -deleteAllItems HotkeyEditorKeyPopupMenu;

	setParent -menu HotkeyEditorKeyPopupMenu;

	for ($index = 0; $index < $numberOfKeys; $index++) {
		menuItem -label $keys[$index] -enableCommandRepeat false
			-command ("hotkeyEditorKeyPopupMenuSelect " + $keys[$index]);

		//	Throw in some separator items.
		//
		if (`about -mac`)
		{
			if ("Right" == $keys[$index] || "Home" == $keys[$index] ||
				"Space" == $keys[$index]) 
			{
				menuItem -divider true;
			}
		}
		else
		{
			if ("Right" == $keys[$index] || "Insert" == $keys[$index] ||
				"Space" == $keys[$index]) 
			{
				menuItem -divider true;
			}
		}
	}
}

proc removeHotkey(string $hotkey)
//
//	Description:
//		Remove a hotkey assignment.
//
//	Notes:
//		This procedure may be called as a result of deleting a runTimeCommand
//		that is attached to a custom Marking Menu (via the Marking Menu 
//		Editor).  The Hotkey Editor may or may not exist in this case.
//		Therefore DO NOT attempt to update any Hotkey Editor UI within this
//		function.  It is the responsibility of the calling function to
//		handle any required updating.
//		
{
	//	Convert the hotkey string into its parameter elements.
	//
	//	A hotkey string may look something like the following:
	//
	//	a
	//	Ctrl+z
	//	Alt+N Release
	//	Ctrl+Alt+b
	//	Ctrl+Alt+b Release
	// In case of MAC
	//	a
	//	Ctrl+z
	//
	//	From this string determine the 3 integer values that will
	//	reflect the Ctrl and Alt modifier state and the key 
	//	direction (ie. press or release).  We also want a string
	//	that contains only the key value.
	//
	//	First, break down the string into tokens.  Tokens are
	//	separated by white space.
	//
	string $token[], $plusString;
	
	string $ctrlKey    = (uiRes("m_hotkeyEditor.kCtrl"));
	string $altKey     = (uiRes("m_hotkeyEditor.kAlt"));
	string $controlKey = (uiRes("m_hotkeyEditor.kControl"));
	string $optionKey  = (uiRes("m_hotkeyEditor.kOption"));
    string $pressKey   = (uiRes("m_hotkeyEditor.kPress"));	
	string $releaseKey = (uiRes("m_hotkeyEditor.kRelease"));
	string $commandKey = (uiRes("m_hotkeyEditor.kCommand"));	
	
	int $numberOfTokens, $lastNumber, $lastButNum ;
	if(size($hotkey) > 1){
		$lastNumber = size($hotkey);
		$lastButNum = size($hotkey)-1;
		$plusString = `substring $hotkey $lastButNum $lastNumber`;
	}

	if($plusString == "++" ){
		$numberOfTokens = `tokenize $hotkey " +" $token`;
		$token[$numberOfTokens++] = "+";
	}else{
		if($hotkey == "+"){
			$numberOfTokens = 1;
			$token[0] = $hotkey;
		}else{
			$numberOfTokens = `tokenize $hotkey " +" $token`;
		}
	}
	
	string $key;
	int $ctrl = 0, $alt = 0, $press = 1, $cmd = 0;

	if (`about -mac`)
	{
		if (1 == $numberOfTokens) {
			//
			//	Only one token.  String contains the key only.
			//	Both modifiers are off and the key direction is 
			//	press.
			//
			$key = $token[0];

		} else if (2 == $numberOfTokens) {
			//
			//	Two tokens.  String is either a key release or
			//	a key with a single modifier.
			//
			if ($releaseKey == $token[1]) {
				//
				//	Key release.
				//
				$key = $token[0];
				$press = 0;

			} else {
				//
				//	Key and single modifier.
				//
				$key = $token[1];
				if ($controlKey == $token[0]) $ctrl = 1;
				else if($optionKey == $token[0]) $alt = 1;
				else $cmd = 1;
			}

		} else if (3 == $numberOfTokens) {
			//
			//	Three tokens.  String is either a key release with
			//	a single modifier or a key with both modifiers.
			//
			if ($releaseKey == $token[2]) {
				//
				//	Key release with single modifier.
				//
				$key = $token[1];
				$press = 0;
				if ($controlKey == $token[0]) $ctrl = 1;
				else if($optionKey == $token[0]) $alt = 1;
				else $cmd = 1;

			} else {
				//
				//	Key press with both modifiers.
				//
				$key = $token[2];
				if((($controlKey == $token[0]) && ($optionKey == $token[1])) || (($controlKey == $token[1]) && ($optionKey == $token[0]))){
					$ctrl = 1;
					$alt = 1;
				}else if ((($controlKey == $token[0]) && ($commandKey == $token[1])) || (($controlKey == $token[1]) && ($commandKey == $token[0])) ){
					$ctrl = 1;
					$cmd = 1;
				}else{
					$alt = 1;
					$cmd = 1;
				}
			}

		} else if (4 == $numberOfTokens){
			if ($releaseKey == $token[3]) {
				//
				//	Key release with single modifier.
				//
				$key = $token[2];
				$press = 0;
				if((($controlKey == $token[0]) && ($optionKey == $token[1])) || (($controlKey == $token[1]) && ($optionKey == $token[0]))){
					$ctrl = 1;
					$alt = 1;
				}else if ((($controlKey == $token[0]) && ($commandKey == $token[1])) || (($controlKey == $token[1]) && ($commandKey == $token[0])) ){
					$ctrl = 1;
					$cmd = 1;
				}else{
					$alt = 1;
					$cmd = 1;
				}

			} else {
				//
				//	Key press with both modifiers.
				//
				$key = $token[3];
				if((($controlKey == $token[0]) && ($optionKey == $token[1]) && ($commandKey != $token[2])) || 
					(($controlKey == $token[1]) && ($optionKey == $token[0]) && ($commandKey != $token[2])) ||
					(($controlKey == $token[1]) && ($optionKey == $token[2]) && ($commandKey != $token[0])) || 
					(($controlKey == $token[2]) && ($optionKey == $token[1]) && ($commandKey != $token[0])) ){
					$ctrl = 1;
					$alt = 1;
				}else if ( (($controlKey == $token[0]) && ($commandKey == $token[1]) && ($optionKey != $token[2])) || 
							(($controlKey == $token[1]) && ($commandKey == $token[0]) && ($optionKey != $token[2])) ||
							(($controlKey == $token[1]) && ($commandKey == $token[2]) && ($optionKey != $token[0])) || 
							(($controlKey == $token[2]) && ($commandKey == $token[1]) && ($optionKey != $token[0])) ){
					$ctrl = 1;
					$cmd = 1;
				}else if ( (($optionKey == $token[0]) && ($commandKey == $token[1]) && ($controlKey != $token[2])) || 
							(($optionKey == $token[1]) && ($commandKey == $token[0]) && ($controlKey!= $token[2])) ||
							(($optionKey == $token[1]) && ($commandKey == $token[2]) && ($controlKey != $token[0])) || 
							(($optionKey == $token[2]) && ($commandKey == $token[1]) && ($controlKey != $token[0])) ) {
					$alt = 1;
					$cmd = 1;
				}else{
					$alt = 1;
					$cmd = 1;
					$ctrl = 1;
				}
			}
		}else{
			//
			//	All four tokens.  String is key release with both
			//	modifiers.
			//
			$ctrl = 1;
			$alt = 1;
			$cmd = 1;
			$key = $token[3];
			$press = 0;
		}
	}
	else{
		if (1 == $numberOfTokens) {
			//
			//	Only one token.  String contains the key only.
			//	Both modifiers are off and the key direction is 
			//	press.
			//
			$key = $token[0];

		} else if (2 == $numberOfTokens) {
			//
			//	Two tokens.  String is either a key release or
			//	a key with a single modifier.
			//
			if ($releaseKey == $token[1]) {
				//
				//	Key release.
				//
				$key = $token[0];
				$press = 0;

			} else {
				//
				//	Key and single modifier.
				//
				$key = $token[1];
				if ($ctrlKey == $token[0]) $ctrl = 1;
				else $alt = 1;
			}

		} else if (3 == $numberOfTokens) {
			//
			//	Three tokens.  String is either a key release with
			//	a single modifier or a key with both modifiers.
			//
			if ($releaseKey == $token[2]) {
				//
				//	Key release with single modifier.
				//
				$key = $token[1];
				$press = 0;
				if ($ctrlKey == $token[0]) $ctrl = 1;
				else $alt = 1;

			} else {
				//
				//	Key press with both modifiers.
				//
				$key = $token[2];
				$ctrl = 1;
				$alt = 1;
			}

		} else {
			//
			//	All four tokens.  String is key release with both
			//	modifiers.
			//
			$ctrl = 1;
			$alt = 1;
			$key = $token[2];
			$press = 0;
		}
	}

	//	To remove a hotkey assignment simply set the hotkey command flag
	//	-name or -releaseName to an empty string.
	//
	string $hotkeyCmd;
	$hotkeyCmd = constructHotkeyCommand($key, $ctrl, $alt, $cmd, $press, false, false, "");
	eval ($hotkeyCmd);
}

proc deleteRunTimeCommand(string $command)
//
//	Description:
//		Delete the given runTimeCommand.  Also cleanup, remove, and/or
//		delete any nameCommands and hotkeys that use this runTimeCommand.
//
//	Notes:
//		This procedure may be called as a result of deleting a runTimeCommand
//		that is attached to a custom Marking Menu (via the Marking Menu 
//		Editor).  The Hotkey Editor may or may not exist in this case.
//		Therefore DO NOT attempt to update any Hotkey Editor UI within this
//		function.  It is the responsibility of the calling function to
//		handle any required updating.
//		
{
	if (`runTimeCommand -exists $command` &&
		!`runTimeCommand -query -default $command`) {

		int $mustUpdateCurrentHotkeys = false;

		//
		//	Determine all the hotkeys pointing to this command.
		//
		string $hotkeys[] = getAllHotkeys($command);

		if (size($hotkeys) > 0) {
			for ($hotkey in $hotkeys) {
				removeHotkey($hotkey);
			}
		}

		//	Determine the nameCommand associated with this command.
		//
		string $nameCommand = $command + "NameCommand";
		int $numberOfNameCommands = `assignCommand -query -numElements`;
		for ($index = 1; $index <= $numberOfNameCommands; $index++) {
			if ($nameCommand == `assignCommand -query -name $index`) {
				assignCommand -edit -delete $index;
				break;
			}
		}

		//	Now delete the command.
		//
		runTimeCommand -edit -delete $command;
	}
}

proc updateNameCommandAfterRunTimeCommandNameChange( string $oldRunTimeCommand, string $newRunTimeCommand )
{
//
//	Description:
//		Update any nameCommands that are using a renamed runTimeCommand to use the new one
//
    int $numCommand = `assignCommand -q -numElements`;
    
    for( $index=1 ; $index <= $numCommand; $index ++)
    {    
        if( $oldRunTimeCommand == `assignCommand -query -command $index` ) {           
            assignCommand -edit -command $newRunTimeCommand -index $index;
		}
    }    
}

proc createCommandListArea(string $parent)
//
//	Description:
//		Create the UI for the category list and command list.
//
{
	setParent $parent;

	//	Category list.
	//
	string $categoryFrame = `frameLayout -label (uiRes("m_hotkeyEditor.kCategories"))
		-borderVisible false`;
	string $categoryForm = `formLayout`;
	string $categoryList = `textScrollList 
		-selectCommand ("hotkeyEditorCategoryTextScrollListSelect")
		HotkeyEditorCategoryTextScrollList`;
	setParent ..;
	setParent ..;

	//	Command list.
	//
	string $commandFrame = `frameLayout -label (uiRes("m_hotkeyEditor.kCommands"))
		-borderVisible false`;
	string $commandForm = `formLayout`;
	string $commandList = `textScrollList 
		-selectCommand ("hotkeyEditorCommandTextScrollListSelect")
		HotkeyEditorCommandTextScrollList`;
	setParent ..;
	setParent ..;

	//	Get all the categories.
	//
	string $categories[] = sort( `runTimeCommand -query -categoryArray` );
	int $index, $numberOfCategories = size($categories);

	int $foundUserCategory = false;

	for ($index = 0; $index < $numberOfCategories; $index++) {
		textScrollList -edit -append $categories[$index] $categoryList;
		if ("User" == $categories[$index]) {
			$foundUserCategory = true;
		}
	}

	//	Create a default User category.
	//
	if (!$foundUserCategory) {
		textScrollList -edit -append "User" $categoryList;
	}

	//	Are there any runTimeCommands that don't have a category specified?
	//
	//	Eventually, there shouldn't be but until they all get one list them
	//	in the "Uncategorized" category.
	//
	string $runTimeCommands[] = `runTimeCommand -query -commandArray`;
	for ($index = 0; $index < size($runTimeCommands); $index++) {
		if ("" == `runTimeCommand -query -category $runTimeCommands[$index]`) {
			textScrollList -edit -append "Uncategorized" $categoryList;
			break;
		}
	}

	if (0 < `textScrollList -query -numberOfItems $categoryList`) {
		textScrollList -edit -selectIndexedItem 1 $categoryList;
	}

	formLayout -edit
		-attachForm     $categoryList "top"    0
		-attachForm     $categoryList "left"   0
		-attachForm     $categoryList "bottom" 0
		-attachForm     $categoryList "right"  0
		$categoryForm;

	formLayout -edit
		-attachForm     $commandList "top"    0
		-attachForm     $commandList "left"   0
		-attachForm     $commandList "bottom" 0
		-attachForm     $commandList "right"  0
		$commandForm;

	formLayout -edit
		-attachForm     $categoryFrame "top"    0
		-attachForm     $categoryFrame "left"   0
		-attachForm     $categoryFrame "bottom" 0
		-attachPosition $categoryFrame "right"  0 30
		-attachForm     $commandFrame  "top"    0 
		-attachControl  $commandFrame  "left"   5 $categoryFrame
		-attachForm     $commandFrame  "bottom" 0
		-attachForm     $commandFrame  "right"  0
		$parent;
}

proc createCommandInfoArea(string $parent)
//
//	Description:
//		Create the UI for listing all the information pertaining to
//		the current runTimeCommand.
//
{
	setParent $parent;

	//	All the buttons.
	//
	string $buttonForm = `columnLayout -adjustableColumn true`;
	string $createButton = `button -label (uiRes("m_hotkeyEditor.kNew"))
		-recomputeSize false -width 100
		-command ("hotkeyEditorCreateCommand")
		HotkeyEditorCreateCommandButton`;
	string $editButton = `button -label (uiRes("m_hotkeyEditor.kEdit"))
		-command ("hotkeyEditorEditCommand")
		HotkeyEditorEditCommandButton`;
	string $deleteButton = `button -label (uiRes("m_hotkeyEditor.kDelete"))
		-command ("hotkeyEditorDeleteCommand")
		HotkeyEditorDeleteCommandButton`;
	separator -style "none" -height 10;
	string $acceptButton = `button -label (uiRes("m_hotkeyEditor.kAccept"))
		-command ("hotkeyEditorAcceptCommand")
		HotkeyEditorAcceptCommandButton`;
	string $cancelButton = `button -label (uiRes("m_hotkeyEditor.kCancel"))
		-command ("hotkeyEditorCancelCommand")
		HotkeyEditorCancelCommandButton`;
	separator -style "none" -height 10;
	string $searchButton = `button -label (uiRes("m_hotkeyEditor.kSearch"))
		-command ("hotkeyEditorSearchForRunTimeCommand")
		HotkeyEditorSearchButton`;
	string $helpButton = `button -label (uiRes("m_hotkeyEditor.kHelp"))
		-command ("showHelp HotkeyEditor")
		HotkeyEditorHelpButton`;

	//	The labels and fields.
	//
	setParent $parent;
	string $info = `columnLayout -adjustableColumn true`;
	rowLayout
		-numberOfColumns 2
		-adjustableColumn 2
		-columnAlign 1 "right"
		-columnWidth 1 80 
		-columnWidth 2 300
		-columnAttach 1 "both" 5
		-columnAttach 2 "both" 0;
	text -label (uiRes("m_hotkeyEditor.kName"));
	textField -editable false HotkeyEditorNameField;
	setParent ..;

	rowLayout
		-numberOfColumns 2
		-adjustableColumn 2
		-columnAlign 1 "right"
		-columnWidth 1 80 
		-columnWidth 2 300
		-columnAttach 1 "both" 5
		-columnAttach 2 "both" 0;
	text -label (uiRes("m_hotkeyEditor.kDescription"));
	textField -editable false HotkeyEditorDescriptionField;
	setParent ..;

	rowLayout
		-numberOfColumns 3
		-columnAlign 1 "right"
		-columnWidth 1 80 
		-columnWidth 2 200
		-columnAttach 1 "both" 5
		-columnAttach 2 "both" 0;
	text -label (uiRes("m_hotkeyEditor.kCategory")); 
	textField -editable false HotkeyEditorCategoryField;
	iconTextButton -image1 "popupMenuIcon.png" -height 26 -width 18
		HotkeyEditorCategoryPopupMenuButton;
	popupMenu -button 1 HotkeyEditorCategoryPopupMenu;
	setParent ..;

	rowLayout
		-numberOfColumns 2
		-adjustableColumn 2
		-columnAlign 1 "right"
		-columnWidth 1 80 
		-columnWidth 2 300
		-columnAttach 1 "both" 5
		-columnAttach 2 "both" 0;
	text -label (uiRes("m_hotkeyEditor.kLanguageInfo"));	
	radioButtonGrp -numberOfRadioButtons 2 -enable false
	    -label "" -labelArray2 "MEL" "Python"
		HotkeyEditorLanguageRadioGrp;
	setParent ..;
	rowLayout
		-numberOfColumns 2
		-adjustableColumn 2
		-columnAlign 1 "right"
		-columnWidth 1 80 
		-columnWidth 2 300
		-columnAttach 1 "both" 5
		-columnAttach 2 "both" 0;
	text -label (uiRes("m_hotkeyEditor.kCommandInfo"));
	scrollField -height 160 -editable false 
		HotkeyEditorCommandField;
	setParent ..;

	formLayout -edit
		-numberOfDivisions 100
		-attachForm     $info       "top"    0
		-attachForm     $info       "left"   0
		-attachForm     $info       "bottom" 0
		-attachControl  $info       "right"  5 $buttonForm
		-attachForm     $buttonForm "top"    0
		-attachNone     $buttonForm "left"
		-attachForm     $buttonForm "bottom" 0
		-attachForm     $buttonForm "right"  0
		$parent;
}

proc createCurrentHotkeyArea(string $parent)
//
//	Description:
//		Create the UI for listing the hotkeys assigned to the
//		current command.
//
{
	setParent $parent;

	string $hotkeyFrame = `frameLayout -label (uiRes("m_hotkeyEditor.kCurrentHotkeys"))
		-borderVisible false`;
	string $hotkeyForm = `formLayout`;

	string $list = `textScrollList -numberOfRows 3
		-selectCommand ("hotkeyEditorHotkeyTextScrollListSelect")
		HotkeyEditorHotkeyTextScrollList`;

	// set the textScrollList height so that, the scroll bar 
	// shows the scrollBox when there are enough contents to scroll
	//
	if(`about -mac`) {
		textScrollList -e -h 100 HotkeyEditorHotkeyTextScrollList;
	}

	string $removeButton = `button -label (uiRes("m_hotkeyEditor.kRemove"))
		-command ("hotkeyEditorRemoveHotkey")
		HotkeyEditorRemoveHotkeyButton`;

	string $restoreButton = `button -label (uiRes("m_hotkeyEditor.kRestoreDefaults"))
		-command ("hotkeyEditorRestoreDefaultHotkeys")
		HotkeyEditorRestoreDefaultHotkeysButton`;

	string $listAllButton = `button -label (uiRes("m_hotkeyEditor.kListAll"))
		-command ("hotkeyEditorListAllHotkeys")
		HotkeyEditorListAllHotkeysButton`;

	formLayout -edit
		-attachForm     $list          "top"    0
		-attachForm     $list          "left"   0
		-attachNone     $list          "bottom"
		-attachForm     $list          "right"  0

		-attachControl  $removeButton  "top"    5 $list
		-attachForm     $removeButton  "left"   5
		-attachNone     $removeButton  "bottom"
		-attachForm     $removeButton  "right"  5

		-attachControl  $listAllButton "top"    5 $removeButton
		-attachForm     $listAllButton "left"   5
		-attachNone     $listAllButton "bottom"
		-attachPosition $listAllButton "right"  2 50

		-attachControl  $restoreButton "top"    5 $removeButton
		-attachPosition $restoreButton "left"   2 50
		-attachNone     $restoreButton "bottom"
		-attachForm     $restoreButton "right"  5

		$hotkeyForm;

	formLayout -edit
		-attachForm    $hotkeyFrame  "top"    0
		-attachForm    $hotkeyFrame  "left"   0
		-attachForm    $hotkeyFrame  "bottom" 0
		-attachForm    $hotkeyFrame  "right"  0
		$parent;
}

proc createNewHotkeyArea(string $parent)
//
//	Description:
//		Create the UI for assigning new hotkeys.
//
{
	setParent $parent;

	frameLayout -label (uiRes("m_hotkeyEditor.kAssignNewHotkey"))
		-marginWidth 5 
		-marginHeight 5;

	columnLayout -adjustableColumn true;

	//	Key field and popup menu.
	//
	rowColumnLayout -numberOfColumns 3 
		-columnWidth 1 70
		-columnWidth 2 80
		-columnWidth 3 80
		-columnAlign 1 "right"
		-columnAlign 2 "left"
		-columnAlign 3 "left"
		-columnAttach 3 "left" 0;

	text -label (uiRes("m_hotkeyEditor.kKey")) HotkeyEditorKeyLabel; 
	textField -changeCommand ("hotkeyEditorHotkeyKeyFieldChange")
		HotkeyEditorKeyField;
	iconTextButton -image1 "popupMenuIcon.png" -height 26 -width 18
		HotkeyEditorKeyPopupMenuButton;
	popupMenu -button 1 HotkeyEditorKeyPopupMenu;
	
	//	Modifier check boxes.
	//
	text -label (uiRes("m_hotkeyEditor.kModifier")) HotkeyEditorModifierLabel;
	if (`about -macOS`) {
		checkBox -label (uiRes("m_hotkeyEditor.kControl")) -changeCommand ("hotkeyEditorHotkeyCtrlCheckBoxChange") 
			HotkeyEditorCtrlCheckBox;
	}
	else {
		checkBox -label (uiRes("m_hotkeyEditor.kCtrl")) -changeCommand ("hotkeyEditorHotkeyCtrlCheckBoxChange") 
			HotkeyEditorCtrlCheckBox;
	}
	if(`about -macOS`){
		checkBox -label (uiRes("m_hotkeyEditor.kOption")) -changeCommand ("hotkeyEditorHotkeyAltCheckBoxChange") 
		HotkeyEditorAltCheckBox;
	}else{
		checkBox -label (uiRes("m_hotkeyEditor.kAlt")) -changeCommand ("hotkeyEditorHotkeyAltCheckBoxChange") 
		HotkeyEditorAltCheckBox;
	}
	if(`about -macOS`) {
		text -label "";
		checkBox -label (uiRes("m_hotkeyEditor.kCommand")) -changeCommand ("hotkeyEditorHotkeyCmdCheckBoxChange") 
			HotkeyEditorCmdCheckBox;
		text -label "";
	}

	//	Key press vs. release radio buttons.
	//
	text -label (uiRes("m_hotkeyEditor.kDirection")) HotkeyEditorDirectionLabel;
	radioCollection;
	radioButton -label (uiRes("m_hotkeyEditor.kPress")) -select
		-changeCommand ("hotkeyEditorHotkeyPressRadioButtonChange") 
		HotkeyEditorPressRadioButton;
	radioButton -label (uiRes("m_hotkeyEditor.kRelease"))
		-changeCommand ("hotkeyEditorHotkeyReleaseRadioButtonChange")
		HotkeyEditorReleaseRadioButton;

	setParent ..;

	separator -height 5 -style "none";

	//	Repeatable check box.
	//
	rowColumnLayout -numberOfColumns 2 
		-columnWidth 1 15
		-columnWidth 2 200
		-columnAlign 1 "right"
		-columnAlign 2 "left";
	text -label " " HotkeyEditorRepeatableLabel;
	checkBox -label (uiRes("m_hotkeyEditor.kAddRecentCommandList")) 
		HotkeyEditorRepeatableCheckBox;
	text -label " " HotkeyEditorDragPressLabel;
	checkBox -label (uiRes("m_hotkeyEditor.kValidDuringManipulatorDrag")) 
		HotkeyEditorDragPressCheckBox;
	setParent ..;


	//	Text for query results.
	//
	text -align "left" -recomputeSize false -label "" -height 47 -wordWrap true
		HotkeyEditorQueryResultText;

	//	The buttons.
	//
	string $buttons = `formLayout`;
	string $assign = `button -label (uiRes("m_hotkeyEditor.kAssign"))
		-command ("hotkeyEditorAssignHotkey")
		HotkeyEditorAssignHotkeyButton`;
	string $query = `button -label (uiRes("m_hotkeyEditor.kQuery"))
		-command ("hotkeyEditorQueryHotkey")
		HotkeyEditorQueryHotkeyButton`;
	string $find = `button -label (uiRes("m_hotkeyEditor.kFind"))
		-command ("hotkeyEditorFindHotkey")
		HotkeyEditorFindHotkeyButton`;
	setParent ..;

	formLayout -edit
		-numberOfDivisions 100
		-attachForm     $assign "top"    0
		-attachForm     $assign "left"   0
		-attachForm     $assign "bottom" 0
		-attachPosition $assign "right"  2 33
		-attachForm     $query  "top"    0
		-attachPosition $query  "left"   2 33
		-attachForm     $query  "bottom" 0
		-attachPosition $query  "right"  2 66
		-attachForm     $find   "top"    0
		-attachPosition $find   "left"   2 66
		-attachForm     $find   "bottom" 0
		-attachForm     $find   "right"  0
		$buttons;
}

proc createButtonsArea(string $parent)
//
//	Description:
//		Create the buttons for the window.
//
{
	setParent $parent;

	string $saveButton = `button -label (uiRes("m_hotkeyEditor.kSave")) 
		-command ("hotkeyEditorSave")
		HotkeyEditorSaveButton`;
	string $closeButton = `button -label (uiRes("m_hotkeyEditor.kClose"))
		-command ("hotkeyEditorClose")
		HotkeyEditorCloseButton`;

	formLayout -edit
		-numberOfDivisions 100
		-attachForm     $saveButton  "top"    0
		-attachForm     $saveButton  "left"   0
		-attachForm     $saveButton  "bottom" 0
		-attachPosition $saveButton  "right"  2 50
		-attachForm     $closeButton "top"    0
		-attachPosition $closeButton "left"   2 50
		-attachForm     $closeButton "bottom" 0
		-attachForm     $closeButton "right"  0
		$parent;
}

proc resetCreateOrEditMode()
//
//	Description:
//		Reset the edit mode.
//
{
	global int $gHotkeyEditorInCreateMode;
	global int $gHotkeyEditorInEditMode;

	$gHotkeyEditorInCreateMode = false;
	$gHotkeyEditorInEditMode = false;

	updateCommandInfo();
	updateCommandButtons();
	enableNewHotkeyArea(true);
}

global proc string[] getAllValidKeys()
//
//	Description:
//		Return a string array containing all the valid keys
//		that a hotkey may be assigned to.
//
{
	int $index, $numberOfKeys;
	string $hotkeys[];
	string $hotkeys1[] = {
		"a", "b", "c", "d", "e", "f", "g", "h", "i", "j",
		"k", "l", "m", "n", "o", "p", "q", "r", "s", "t",
		"u", "v", "w", "x", "y", "z",

		"A", "B", "C", "D", "E", "F", "G", "H", "I", "J",
		"K", "L", "M", "N", "O", "P", "Q", "R", "S", "T",
		"U", "V", "W", "X", "Y", "Z",
		
		"0", "1", "2", "3", "4", "5", "6", "7", "8", "9",
		")", "!", "@", "#", "$", "%", "^", "&", "*", "(",
		
		"F1", "F2", "F3", "F4", "F5", "F6", "F7", "F8", 
		"F9", "F10", "F11", "F12",
		
		"`", "-", "=", "[", "]", "\\", ";", "'", ",", ".", "/",
		"~", "_", "+", "{", "}", "|", ":", "\"", "<", ">", "?",

		"Up", "Down", "Left", "Right",

		"Page_Up", "Page_Down", "Home", "End",
		"Return", "Space"
	};
	string $hotkeys2[] = {
		"a", "b", "c", "d", "e", "f", "g", "h", "i", "j",
		"k", "l", "m", "n", "o", "p", "q", "r", "s", "t",
		"u", "v", "w", "x", "y", "z",

		"A", "B", "C", "D", "E", "F", "G", "H", "I", "J",
		"K", "L", "M", "N", "O", "P", "Q", "R", "S", "T",
		"U", "V", "W", "X", "Y", "Z",
		
		"0", "1", "2", "3", "4", "5", "6", "7", "8", "9",
		")", "!", "@", "#", "$", "%", "^", "&", "*", "(",
		
		"F1", "F2", "F3", "F4", "F5", "F6", "F7", "F8", 
		"F9", "F10", "F11", "F12",
		
		"`", "-", "=", "[", "]", "\\", ";", "'", ",", ".", "/",
		"~", "_", "+", "{", "}", "|", ":", "\"", "<", ">", "?",

		"Up", "Down", "Left", "Right",

		"Page_Up", "Page_Down", "Home", "End", "Insert",
		"Return", "Space"
	};
	if (`about -mac`)
	{
		 $numberOfKeys = size($hotkeys1);
		for($index = 0; $index < $numberOfKeys; $index++)
		{
			$hotkeys[$index] = $hotkeys1[$index];
		}
	}
	else
	{
		
		$numberOfKeys = size($hotkeys2);
		for($index = 0; $index < $numberOfKeys; $index++)
		{
			$hotkeys[$index] = $hotkeys2[$index];
		}
	}
	
	return $hotkeys;
}

global proc string getHotkeyCommandNew (
	string $key,
	int    $ctrl,
	int    $alt,
	int    $command,
	int    $press)
//
//	Description:
//		Return the command that will be executed if the specified hotkey
//		is invoked.
//
//	Arguments:
//		key		- The key.
//		ctrl	- State of the Ctrl modifier.
//		alt		- State of the Alt modifier.
//		press	- Key direction.  Specify true for key press, false for 
//				  key release.
//
//	Returns:
//		A string containing the command that will be executed.  An empty
//		string is returned if no command is attached to the hotkey.
//
//	Examples:
//		//	Determine the press command attached to the hotkey Ctrl a.
//		//
//		string $press = getHotkeyCommand("a", true, false, true);
//
//		//	Determine the release command attached to the hotkey Alt Z.
//		//
//		string $release = getHotkeyCommand("Z", false, true, false);
//
{
	string $result = "";
	string $nameCommand = "";

	string $hotkeyQueryCommand = "hotkey -query ";
	if ($ctrl) $hotkeyQueryCommand += "-ctl ";
	if ($alt) $hotkeyQueryCommand += "-alt ";
	if($command) $hotkeyQueryCommand += "-cmd ";
	if ($press) $hotkeyQueryCommand += "-name ";
	else $hotkeyQueryCommand += "-releaseName ";

	if ("\"" == $key || "\\" == $key) {
		//
		//	Need to preceed double quote and backslash characters
		//	with a backslash.
		//
		$hotkeyQueryCommand += ("\"\\" + $key + "\"");

	} else if ("-" == $key) {
		//
		//	Can't pass a dash as a string argument to a command
		//	because it gets interpreted as the beginning of another
		//	flag.  Use the word "Dash" instead.
		//
		$hotkeyQueryCommand += ("Dash");

	} else {
		//
		//	Surround the string argument with quotes so that 
		//	non-alphabetic characters get treated as strings
		//	properly.
		//
		$hotkeyQueryCommand += ("\"" + $key + "\"");
	}
	$nameCommand = eval($hotkeyQueryCommand);

	if ("" != $nameCommand) {
		//
		//	Get the runTimeCommand this nameCommand points to.
		//
		string $runTimeCommand = getRunTimeCommandFromNameCommand($nameCommand);
		if ("" != $runTimeCommand) {
			$result = $runTimeCommand;
			
		} else {
			//
			//	This is a name command that hasn't been converted to use
			//	a runTimeCommand yet.
			//
			$result = $nameCommand;
		}
	}
	
	return $result;
}

global proc string getHotkeyCommand(
	string $key,
	int    $ctrl,
	int    $alt,
	int	   $cmd,
	int    $press)
{
	if(`about -mac`){
		return  (getHotkeyCommandNew ($key, $ctrl, $alt,  $cmd, $press));
	}

	return  (getHotkeyCommandNew ($key, $ctrl, $alt,  false, $press));
}

global proc string getRunTimeCommandFromNameCommand(string $nameCommand)
//
//	Description:
//		Return the runTimeCommand that is invoked by the specified 
//		nameCommand.
//
{
	string $result = "";
	int $index, $numberOfNameCommands;

	$numberOfNameCommands = `assignCommand -query -numElements`;
	for ($index = 1; $index <= $numberOfNameCommands; $index++) {
		if ($nameCommand == `assignCommand -query -name $index`) {
			$result = `assignCommand -query -command $index`;
			break;
		}
	}
	
	if (!`runTimeCommand -exists $result`) $result = "";
	
	return $result;
}

global proc hotkeyEditorCategoryTextScrollListSelect()
//
//	Description:
//		This procedure is called whenever the user selects a category
//		in the list.
//
{
	resetCreateOrEditMode();
	updateCommandTextScrollList("");
}

global proc hotkeyEditorCommandTextScrollListSelect()
//
//	Description:
//		This procedure is called whenever the user selects a command
//		in the list.
//
{
	resetCreateOrEditMode();
	updateCurrentHotkeys();
	updateCommandButtons();
	updateCommandInfo();
}

global proc hotkeyEditorHotkeyKeyFieldChange()
//
//	Description:
//		This procedure is called whenever the user changes the value
//		in the key field.
//
{
	if (!updateQueryHotkeyText()) {
		setQueryHotkeyText("");
	}
}

global proc hotkeyEditorHotkeyCtrlCheckBoxChange()
//
//	Description:
//		This procedure is called whenever the user turns on or
//		off the Ctrl check box.
//
{
	if (!updateQueryHotkeyText()) {
		setQueryHotkeyText("");
	}
}

global proc hotkeyEditorHotkeyAltCheckBoxChange()
//
//	Description:
//		This procedure is called whenever the user turns on or
//		off the Alt check box.
//
{
	if (!updateQueryHotkeyText()) {
		setQueryHotkeyText("");
	}
}

global proc hotkeyEditorHotkeyCmdCheckBoxChange()
//
//	Description:
//		This procedure is called whenever the user turns on or
//		off the Alt check box.
//
{
	if (!updateQueryHotkeyText()) {
		setQueryHotkeyText("");
	}
}


global proc hotkeyEditorHotkeyPressRadioButtonChange()
//
//	Description:
//		This procedure is called whenever the user turns on or
//		off the Press radio button.
//
{
	if (!updateQueryHotkeyText()) {
		setQueryHotkeyText("");
	}
}

global proc hotkeyEditorHotkeyReleaseRadioButtonChange()
//
//	Description:
//		This procedure is called whenever the user turns on or
//		off the Release radio button.
//
{
	if (!updateQueryHotkeyText()) {
		setQueryHotkeyText("");
	}
}

global proc hotkeyEditorHotkeyTextScrollListSelect()
//
//	Description:
//		This procedure is called whenever the user selects a hotkey
//		in the list.
//
{
	resetCreateOrEditMode();
	updateRemoveHotkeyButton();
}

global proc hotkeyEditorCategoryPopupMenuSelect(string $category)
//
//	Description:
//		This procedure is called whenever the user selects a category
//		from the popup menu.
//
{
	textField -edit -text $category HotkeyEditorCategoryField;
}

global proc hotkeyEditorKeyPopupMenuSelect(string $key)
//
//	Description:
//		This procedure is called whenever the user selects a key
//		from the popup menu.
//
{
	textField -edit -text $key HotkeyEditorKeyField;
	hotkeyEditorQueryHotkey();
}
 
global proc hotkeyEditorCreateCommand()
//
//	Description:
//		This procedure is called whenever the user presses the
//		Create command button.
//
{
	global int $gHotkeyEditorInCreateMode;

	$gHotkeyEditorInCreateMode = true;

	updateCommandInfo();
	updateCommandButtons();
	enableNewHotkeyArea(false);
}

global proc hotkeyEditorEditCommand()
//
//	Description:
//		This procedure is called whenever the user presses the
//		Edit command button.
//
{
	global int $gHotkeyEditorInEditMode;

	$gHotkeyEditorInEditMode = true;

	updateCommandInfo();
	updateCommandButtons();
	enableNewHotkeyArea(false);
}

global proc hotkeyEditorDeleteCommand()
//
//	Description:
//		This procedure is called whenever the user presses the
//		Delete command button.
//
{
	string $command = getCurrentRunTimeCommand();
	string $list = "HotkeyEditorCommandTextScrollList";

	//
	//	Remove the item from the list.
	//
	if ("" != $command) {

		//	Confirm that the user really wants to delete the command.
		//
		//	Fixes bug #126567.
		//
		string $delete = (uiRes("m_hotkeyEditor.kDeleteDialog"));
		string $cancel = (uiRes("m_hotkeyEditor.kCancelDialog"));
		string $display = (uiRes("m_hotkeyEditor.kConfirmDelete"));
		string $message = `format -s $command $display`;
		$confirmResponse = `confirmDialog -button $delete -button $cancel
			-defaultButton $delete -cancelButton $cancel
			-message $message`;

		//
		//	*** Return statement ***
		//
		if ($delete != $confirmResponse) return;

		deleteRunTimeCommand($command);
		textScrollList -edit -removeItem $command $list;

		//	Select the first command in the list.
		//
		int $numberOfItems = `textScrollList -query -numberOfItems $list`;
		if ($numberOfItems > 0) {
			textScrollList -edit -selectIndexedItem 1 $list;
			textScrollList -edit -showIndexedItem 1 $list;
		}

		updateCommandInfo();
		updateCommandButtons();
		updateCurrentHotkeys();
	}
}

global proc hotkeyEditorAcceptCommand()
//
//	Description:
//		This procedure is called whenever the user presses the
//		Accept command button.
//
{
	global int $gHotkeyEditorInCreateMode;
	global int $gHotkeyEditorInEditMode;

	string $oldName, $name, $description, $command, $list;
	string $oldCategory, $category;
	string $commandLanguage;
	string $runTimeCommand, $errorMessage;
	int $numberOfItems, $numberOfLines, $showItem;

	$oldName = getCurrentRunTimeCommand();
	$oldCategory = getCurrentCategory();
	$name = `textField -query -text HotkeyEditorNameField`;
	$description = `textField -query -text HotkeyEditorDescriptionField`;
	if (2 == `radioButtonGrp -query -select HotkeyEditorLanguageRadioGrp`) {
		$commandLanguage = "python";
	} 
    else 
    {
		$commandLanguage = "mel";
	}

	$command = `scrollField -query -text HotkeyEditorCommandField`;
	$category = `textField -query -text HotkeyEditorCategoryField`;
	$runTimeCommand = ("runTimeCommand " + $name);
	$list = "HotkeyEditorCommandTextScrollList";

	//	Fix for bug #132763. Allowing the user to have a run time command execute
	//	itself will result in an infinite loop when the command is called.
	//
	if ($name == $command) {
		string $close = (uiRes("m_hotkeyEditor.kCloseAccept"));
		confirmDialog -button $close -defaultButton $close -cancelButton $close
			-message (uiRes("m_hotkeyEditor.kAcceptMsg"));
		return;
	}

	if ($gHotkeyEditorInEditMode) {
		
		//	Is the category name valid?
		//
		if ($category != $oldCategory && !isValidCategory($category)) {
			$errorMessage = (uiRes("m_hotkeyEditor.kErrMsg"));
		}

		if ("" == $errorMessage && $name != $oldName) {
			//
			//	We can't really rename commands so we have to create a new
			//	command with the given name and then delete the old one.
			//
			if ("" != $name && isValidName($name) && isUniqueName($name)) {

				eval ($runTimeCommand);
				runTimeCommand -edit -delete $oldName;
				
				//	Determine the old item's position in the list.
				//
				string $items[] = `textScrollList -query -allItems $list`;
				int $index, $count = size($items);
				for ($index = 0; $index < $count; $index++) {
					if ($oldName == $items[$index]) {
						break;
					}
				}

				if ($category == $oldCategory) {

					//	Add our new item after the old item.
					//
					textScrollList -edit -appendPosition ($index + 1) $name $list;

					//	Remove the old item from the list.
					//
					textScrollList -edit -removeItem $oldName $list;
				}

			} else if (!isValidName($name)) {
				//
				//	Not a valid name.
				//
				$errorMessage = (uiRes("m_hotkeyEditor.kAlphabetErr"));

			} else if (!isUniqueName($name)) {
				$errorMessage = getNameErrorMessage($name);
			}
			
			// Update all nameCommands using old name to the new one
			if ("" == $errorMessage) {
				updateNameCommandAfterRunTimeCommandNameChange( $oldName, $name );
			}
		}

		if ("" == $errorMessage) {
			runTimeCommand -edit 
				-command $command
				-annotation $description
				-category $category
				-commandLanguage $commandLanguage
				$name;
		}

	} else {
		//
		//	Validate the field values.
		//
		if ("" != $name && isValidName($name) && isUniqueName($name) 
			&& isValidCategory($category)) {

			eval ($runTimeCommand);

			runTimeCommand -edit
				-command $command 
				-annotation $description 
				-category $category
				-commandLanguage $commandLanguage
				$name;

			if ($category == $oldCategory) {
				
				//	Add our item to the list.
				//
				textScrollList -edit -append $name -selectItem $name $list;

				//	Make our newly added item visible within the list.
				//
				$numberOfItems = `textScrollList -query -numberOfItems $list`;
				$numberOfLines = `textScrollList -query -numberOfRows $list`;
				$showItem = $numberOfItems - $numberOfLines + 1;
				if ($showItem < 1) $showItem = 1;
				textScrollList -edit -showIndexedItem $showItem $list;
			}

		} else if (!isValidName($name)) {
			//
			//	Not a valid name.
			//
			$errorMessage = (uiRes("m_hotkeyEditor.kNameNotValid"));

		} else if (!isUniqueName($name)) {
			$errorMessage = getNameErrorMessage($name);

		} else if (!isValidCategory($category)) {
			$errorMessage = (uiRes("m_hotkeyEditor.kSelectMsg"));
		}
	} 

	if ("" == $errorMessage) {
		$gHotkeyEditorInCreateMode = false;
		$gHotkeyEditorInEditMode = false;

		$list = "HotkeyEditorCategoryTextScrollList";

		if (!isExistingCategory($category)) {
			//
			//	Add the category to the list.
			//
			textScrollList -edit -append $category -selectItem $category $list;
		}

		if ($category != $oldCategory) {
			//
			//	Select the new category.
			//
			textScrollList -edit -selectItem $category $list;
			
			//	Now update the command list.
			//
			updateCommandTextScrollList($name);
		}

		updateCommandInfo();
		updateCommandButtons();
		updateCurrentHotkeys();
		enableNewHotkeyArea(true);

	} else {
		string $close = (uiRes("m_hotkeyEditor.kCloseMsg"));
		confirmDialog -button $close -message $errorMessage
			-defaultButton $close -cancelButton $close;
	}
}

global proc hotkeyEditorCancelCommand()
//
//	Description:
//		This procedure is called whenever the user presses the
//		Cancel command button.
//
{
	resetCreateOrEditMode();
}

global proc hotkeyEditorSearchForRunTimeCommand()
//
//	Description:
//		This procedure is called whenever the user presses the
//		Search button.
//
{
	searchForRunTimeCommandWindow;
}

global proc hotkeyEditorAssignHotkey()
//
//	Description:
//		This procedure is called whenever the user presses the
//		Assign hotkey button.
//
{
	int		$cmd = 0;

	string $key = `textField -query -text HotkeyEditorKeyField`;
	int $ctrl = `checkBox -query -value HotkeyEditorCtrlCheckBox`;
	int $alt = `checkBox -query -value HotkeyEditorAltCheckBox`;
	int $press = `radioButton -query -select HotkeyEditorPressRadioButton`;
	int $repeat = `checkBox -query -value HotkeyEditorRepeatableCheckBox`;
	int $dragPress = `checkBox -query -value HotkeyEditorDragPressCheckBox`;

	if(`about -macOS`){
		$cmd = `checkBox -query -value HotkeyEditorCmdCheckBox`;
	}
	string $runTimeCommand, $nameCommandName;
	int $nameCommandIndex;
	int $setUpReleaseHotkey = false;

	if ("" == $key || !isValidKey($key)) {
		$label = (uiRes("m_hotkeyEditor.kLabel"));
		text -edit -label $label HotkeyEditorQueryResultText;

	} else {
		string $existingCommand = getHotkeyCommand($key, $ctrl, $alt, $cmd, $press);
		string $confirmResponse;

		$runTimeCommand = getCurrentRunTimeCommand();
		if($runTimeCommand == $existingCommand) {
			// already done
			string $ok = (uiRes("m_hotkeyEditor.kOkButton"));
			string $message = (uiRes("m_hotkeyEditor.kNothingToDoMsg"));
			string $displayMsg = `format -s $runTimeCommand $message`;
			confirmDialog -button $ok -defaultButton $ok -cancelButton $ok -message $displayMsg;
			return;
		}

		if ("" != $existingCommand) {

			string $assign = (uiRes("m_hotkeyEditor.kAssignBtn"));
			string $cancel = (uiRes("m_hotkeyEditor.kCancelBtn"));
			string $message = (uiRes("m_hotkeyEditor.kAssignMsg"));
			string $displayMsg = `format -s $existingCommand $message`;
			
			$confirmResponse = `confirmDialog -button $assign -button $cancel	
				-defaultButton $assign -cancelButton $cancel
				-message $displayMsg`;

			//
			//	*** Return statement ***
			//
			if ($assign != $confirmResponse) return;
		}

		//	Check for dangling release hotkeys that could cause trouble for
		//	the user.  Bug #88549 and #137784.
		//
		//	If the user assigns a press hotkey then check to see if there
		//	was a release command attached to the same hotkey.  The user
		//	would not expect that their new command be executed on press
		//	and their old release command be executed on release.
		//
		if ($press) {
			//
			//	Check if there is a release command attached to the hotkey
			//	as well.
			//
			$releaseCommand = getHotkeyCommand($key, $ctrl, $alt, $cmd, 0);

			if ("" != $releaseCommand) {
				string $ok = (uiRes("m_hotkeyEditor.kOk"));
				string $message = (uiRes("m_hotkeyEditor.kReleaseMsg"));
				string $displayMsg = `format -s $releaseCommand $message`;
				 
				confirmDialog -button $ok -defaultButton $ok -cancelButton $ok 
					-message $displayMsg;
				$removeReleaseHotkeyCmd = constructHotkeyCommand(
					$key, $ctrl, $alt, $cmd, 0, 0, 0, "");
				eval ($removeReleaseHotkeyCmd);
			}
		}

		$nameCommandName = $runTimeCommand + "NameCommand";
		$nameCommandIndex = getNameCommand($nameCommandName);

		//	Have we created a nameCommand object for this runTimeCommand
		//	yet?  If we have it will be have the same name as the runTimeCommand
		//	with "NameCommand" appended to it.  For example, a runTimeCommand
		//	called "Example" will have a nameCommand object called 
		//	"ExampleNameCommand".
		//
		//	Note that a runTimeCommand may have other default nameCommand
		//	objects pointing to it (ie. set up in nameCommandSetup.mel).
		//	We don't want to apply the hotkey to one of these.
		//

		if (0 == $nameCommandIndex) {
			//
			//	Create a new nameCommand object.
			//
			//	Note that nameCommand command requires the annotation flag to
			//	be set.  Simply set it to the name of the command so that it's
			//	unique.
			//
			string $nameCommandCmd = "nameCommand -ann \"" + $nameCommandName 
				+ "\" -command (\"" + $runTimeCommand + "\") " 
				+ $nameCommandName;
			eval ($nameCommandCmd);
			$nameCommandIndex = getNameCommand($nameCommandName);
		}

		//	Are we trying to attach the hotkey to a user Marking Menu?
		//
		//	We can determine this by querying the Category flag of the
		//	runTimeCommand.  All runTimeCommands that post custom
		//	Marking Menus will have the category set to 
		//	"User Marking Menus".
		//
		if ("User Marking Menus" 
			== `runTimeCommand -query -category $runTimeCommand`) {

			//
			//	Why do we need to know if the runTimeCommand is for
			//	showing a user marking menu?  Because we must
			//	ensure that the command that actually shows the
			//	marking menu includes the hotkey modifiers.
			//
			//	The problem is that the user creates their marking
			//	menu in the Marking Menu Editor.  At that time we
			//	have no idea what hotkey and modifiers the user is
			//	going to attach.
			//	
			//	But now we know their hotkey assignment and simply
			//	need to update the command accordingly.
			//
			string $modifiers, $command, $newCommand;
			string $buffer[], $tokens[];
			int $index, $tokenCount;
			
			$command = `runTimeCommand -query -command $runTimeCommand`;

			//	Determine if the command is for popping up the marking
			//	menu or for popping it down.
			//
			//	We don't have to modify the pop down command, only
			//	the popup command.
			//
			//	The pop up command is assumed to consist of three lines
			//	separated by new lines, eg "\n".
			//
			$tokenCount = `tokenize $command "\n" $buffer`;
			if (3 == $tokenCount) {
				//
				//	This is the marking menu pop up command.
				//

				//	Start constructing the new command that will include
				//	the appropriate hotkey modifiers.
				//
				//	Add the first line of the command.
				//
				$newCommand = $buffer[0] + "\n";

				//	Tokenize the second line so we can find the 
				//	-ctl, -alt, -shift and -cmd flags and set their correct
				//	values.
				//
				$tokenCount = `tokenize $buffer[1] " " $tokens`;

				int $altFound = false, $shiftFound = false, $cmdFound = false;

				for ($index = 0; $index < $tokenCount; $index++) {

					if ("-ctl" == $tokens[$index]) {
						$newCommand += $tokens[$index] + " ";
						if ($ctrl) {
							$newCommand += "true ";
						} else {
							$newCommand += "false ";
						}
						$index++;

					} else if ("-alt" == $tokens[$index]) {
						$newCommand += $tokens[$index] + " ";
						if ($alt) {
							$newCommand += "true ";
						} else {
							$newCommand += "false ";
						}
						$altFound = true;
						$index++;

					}else if ("-cmd" == $tokens[$index]) {
						$newCommand += $tokens[$index] + " ";
						if ($cmd) {
							$newCommand += "true ";
						} else {
							$newCommand += "false ";
						}
						$cmdFound = true;
						$index++;

					} else if ("-sh" == $tokens[$index]) {
						$newCommand += $tokens[$index] + " ";
						if (1 == size($key) && keyNeedsShift($key)) {
							$newCommand += "true ";
						} else {
							$newCommand += "false ";
						}
						$shiftFound = true;
						$index++;

					} else if ("-allowOptionBoxes" == $tokens[$index]) {
						//
						//	The Marking Menu editor didn't use to set the
						//	-alt or -sh flags.  If we've detected the 
						//	-allowOptionBoxes flag and the -alt or -sh flags
						//	haven't been found then insert them as well as
						//	their values.
						//
						//	Then include the -allowOptionBoxes flag.
						//
						if (!$altFound && !$cmdFound) {
							$newCommand += "-alt ";
							if ($alt) {
								$newCommand += "true ";
							} else {
								$newCommand += "false ";
							}
						}
						if (!$shiftFound) {
							$newCommand += "-sh ";
							if (1 == size($key) && keyNeedsShift($key)) {
								$newCommand += "true ";
							} else {
								$newCommand += "false ";
							}
						}
						$newCommand += $tokens[$index] + " ";

					} else {
						//
						//	Include all the other parts of the command.
						//
						$newCommand += $tokens[$index] + " ";
					}
				}
				
				//	Don't forget to add the last line of the original
				//	command.
				//
				$newCommand += "\n" + $buffer[2] + "\n";

				//	Attach the new command to the runTimeCommand.
				//
				runTimeCommand -edit -command $newCommand $runTimeCommand;

				//	Update the command info area to reflect the change in
				//	the runTimeCommand's command.
				//
				updateCommandInfo();
			}

			if ($press) {
				//
				//	It would be nice to automatically attach the release
				//	hotkey for the user's marking menu.
				//
				
				string $yes = (uiRes("m_hotkeyEditor.kYes"));
				string $no  = (uiRes("m_hotkeyEditor.kNo"));
				string $message = (uiRes("m_hotkeyEditor.kReleaseAttachMsg"));
				$confirmResponse = `confirmDialog -button $yes -button $no	
					-defaultButton $yes -cancelButton $no
					-message $message`;

				if ($yes == $confirmResponse) $setUpReleaseHotkey = true;
			}
		}

		string $hotkeyCmd = constructHotkeyCommand(
			$key, $ctrl, $alt, $cmd, $press, $repeat, $dragPress, $nameCommandName);
		eval ($hotkeyCmd);

		updateCurrentHotkeys();
		updateQueryHotkeyText();

		//	Now reset the "Assign Hotkey" field and checkboxes.
		//
		//	Fixes bug #126569.
		//
		textField -edit -text "" HotkeyEditorKeyField;
		checkBox -edit -value false HotkeyEditorCtrlCheckBox;
		checkBox -edit -value false HotkeyEditorAltCheckBox;
	if(`about -macOS`){
			checkBox -edit -value false HotkeyEditorCmdCheckBox;
	}
		radioButton -edit -select HotkeyEditorPressRadioButton;
	}

	if ($setUpReleaseHotkey) {
		//
		//	The user has requested that we also attach the release hotkey
		//	for the marking menu.
		//
		//	Construct the name of the release runTimeCommand.  To do this,
		//	take the press runTimeCommand, strip off "_Press" and add
		//	"_Release".  These are the suffixes added 
		//	in hotkeyEditor_createMarkingMenu().
		//
		string $releaseName = substring($runTimeCommand, 1, (size($runTimeCommand) - 6));
		$runTimeCommand = $releaseName + "_Release";
		$nameCommandName = $runTimeCommand + "NameCommand";
		$nameCommandIndex = getNameCommand($nameCommandName);

		if (0 == $nameCommandIndex) {
			//
			//	Create a new nameCommand object.
			//
			//	Note that nameCommand command requires the annotation flag to
			//	be set.  Simply set it to the name of the command so that it's
			//	unique.
			//
			string $nameCommandCmd = "nameCommand -ann \"" + $nameCommandName 
				+ "\" -command (\"" + $runTimeCommand + "\") " 
				+ $nameCommandName;
			eval ($nameCommandCmd);
			$nameCommandIndex = getNameCommand($nameCommandName);
		}

		string $hotkeyCmd = constructHotkeyCommand(
			$key, $ctrl, $alt, $cmd, false, $repeat, $dragPress, $nameCommandName);
		eval ($hotkeyCmd);
	}
}

global proc hotkeyEditorQueryHotkey()
//
//	Description:
//		This procedure is called whenever the user presses the
//		Query hotkey button.
//
{
	if (!updateQueryHotkeyText()) {
		text -edit 
			-label (uiRes("m_hotkeyEditor.kQueryLabel"))
			HotkeyEditorQueryResultText;
	}
}

global proc hotkeyEditorFindHotkey()
//
//	Description:
//		This procedure is called whenever the user presses the
//		Find hotkey button.
//
//		The purpose of this procedure is to locate and select 
//		in the category/command scroll lists the command assigned 
//		to the current hotkey.
//
{
	int		$cmd = 0;
	string $modifierKey  ="";
	string $releaseKey   ="";
	 
	string $key = `textField -query -text HotkeyEditorKeyField`;
	int $ctrl = `checkBox -query -value HotkeyEditorCtrlCheckBox`;
	int $alt = `checkBox -query -value HotkeyEditorAltCheckBox`;
	int $press = `radioButton -query -select HotkeyEditorPressRadioButton`;

	if(`about -macOS`){
		$cmd = `checkBox -query -value HotkeyEditorCmdCheckBox`;
	}
	if ("" == $key || !isValidKey($key)) {
		//
		//	Won't be able to find command attached to invalid key.
		//
		text -edit 
			-label (uiRes("m_hotkeyEditor.kFindLabel"))
			HotkeyEditorQueryResultText;

	} else {
		string $command = getHotkeyCommand($key, $ctrl, $alt, $cmd, $press);

		if ("" == $command) {
			//
			//	No command assigned.
			//
			
			string $newCtrlKey    = (uiRes("m_hotkeyEditor.kCtrlKey"));
			string $newAltKey     = (uiRes("m_hotkeyEditor.kAltKey"));
			string $newControlKey = (uiRes("m_hotkeyEditor.kControlKey"));
			string $newOptionKey  = (uiRes("m_hotkeyEditor.kOptionKey"));
			string $newCommandKey = (uiRes("m_hotkeyEditor.kCommandKey"));
			string $newCmdKey     = (uiRes("m_hotkeyEditor.kCmdKey"));
			string $newReleaseKey = (uiRes("m_hotkeyEditor.kReleaseKey"));			
			if ($ctrl) {
				if(`about -macOS`)
					$modifierKey += $newControlKey;
				else
					$modifierKey += $newCtrlKey;
				
			}
			if ($alt) {
				if(`about -macOS`)
					$modifierKey += $newOptionKey;
				else
					$modifierKey += $newAltKey;
			}
			if($cmd){
				if(`about -macOS`)
					$modifierKey += $newCommandKey;
				else
					$modifierKey += $newCmdKey;
			}
		

			if (!$press) {
				$releaseKey += $newReleaseKey;
			}
			string $label = (uiRes("m_hotkeyEditor.kFindMsg"));
			string $findMsg = `format -s $modifierKey -s $key -s $releaseKey $label`;
			text -edit -label $findMsg HotkeyEditorQueryResultText;

		} else {
			//
			//	Select the corresponding category and command in the
			//	scroll lists.
			//
			string $category = `runTimeCommand -query -category $command`;
			textScrollList -edit -selectItem $category 
				HotkeyEditorCategoryTextScrollList;
			updateCommandTextScrollList($command);
		}
	}
}

global proc hotkeyEditorRemoveHotkey()
//
//	Description:
//		This procedure is called whenever the user presses the
//		Remove hotkey button.
//
{
	//	Get the selected hotkey item in the scroll list.
	//
	string $hotkey[] = `textScrollList -query 
		-selectItem HotkeyEditorHotkeyTextScrollList`;

	removeHotkey($hotkey[0]);

	updateCurrentHotkeys();
}

global proc hotkeyEditorRestoreDefaultHotkeys()
//
//	Description:
//		This procedure is called whenever the user presses the
//		Restore Defaults button.
//
//		Post a dialog confirming the user wants to restore the
//		default hotkeys and thus losing all their custom hotkey
//		assignments.
//
//		Then restore the default hotkeys.
//
{
	string $message, $response;

	string $yes    = (uiRes("m_hotkeyEditor.kDefaultYes"));
	string $cancel = (uiRes("m_hotkeyEditor.kDefaultCancel"));
	$message = (uiRes("m_hotkeyEditor.kMessage"));

	$response = `confirmDialog -button $yes -button $cancel
		-defaultButton $yes -cancelButton $cancel -message $message`;

	if ($response == $yes) {
		hotkey -factorySettings;
		updateCurrentHotkeys();
	}
}

global proc hotkeyEditorListAllHotkeys()
//
//	Description:
//		This procedure is called whenever the user presses the
//		List All hotkeys button.
//
{
	listHotkeysWindow;
}

global proc hotkeyEditorSave()
//
//	Description:
//		This procedure is called whenever the user presses the
//		Save button.
//
{
	string $ok = (uiRes("m_hotkeyEditor.kWarningOk"));
	confirmDialog -title (uiRes("m_hotkeyEditor.kWarning"))
		-button $ok
		-defaultButton $ok
		-message (uiRes("m_hotkeyEditor.kHotkeyWarning"));
	savePrefs -hotkeys;
}

global proc hotkeyEditorClose()
//
//	Description:
//		This procedure is called whenever the user presses the
//		Close button.
//
{
	evalDeferred ("deleteUI -window HotkeyEditor");
}

//	------------------------------------------------------------------
//
//	BEGIN: interface to the Marking Menu Editor, and related routines.
//
//	These procedures should only be called by the Marking Menu Editor. 
//
proc string hotkeyEditor_generatePressAnnotationForMM(string $annotation)
{
	string $pressAnnot = (uiRes("m_hotkeyEditor.kPressAnnot"));
	string $annotMsg =`format -s $annotation $pressAnnot`;
	return ($annotMsg);
}

proc string hotkeyEditor_generateReleaseAnnotationForMM(string $annotation)
{
	string $releaseAnnot = (uiRes("m_hotkeyEditor.kReleaseAnnot"));
	string $annotMsg =`format -s $annotation $releaseAnnot`;
	return ($annotMsg);
}

global proc int hotkeyEditor_createMarkingMenu(
	string $markingMenuName,
	string $pressCommandString,
	string $releaseCommandString) 
//
//	Description:
//		Create the runTimeCommands for a marking menu.
//
//		Returns false upon failure.
//
{
	//	Has a marking menu with the given marking menu name already 
	//	been created?
	//
	if (hotkeyEditor_doesMarkingMenuExist($markingMenuName)) {
		string $markingMenuWarning = (uiRes("m_hotkeyEditor.kMarkingMenuWarn"));
		warning $markingMenuWarning;
		return false;
	}

	//	Create a couple of runTimeCommands.  One for the press command and
	//	one for the release command.
	//
	//	Is the given marking menu name valid?  Ie. no spaces, punctuation, etc.?
	//
	string $popUpCommandName = $markingMenuName + "_Press";
	string $popDownCommandName = $markingMenuName + "_Release";

	string $pressAnnotation = hotkeyEditor_generatePressAnnotationForMM($markingMenuName);
	string $releaseAnnotation = hotkeyEditor_generateReleaseAnnotationForMM($markingMenuName);

	string $runTimeCommand;

	$runTimeCommand = ("runTimeCommand " + $popUpCommandName);
	eval ($runTimeCommand);

	runTimeCommand -edit
		-command    $pressCommandString
		-category   "Other items.User Marking Menus"
		-annotation $pressAnnotation
		$popUpCommandName;

	$runTimeCommand = ("runTimeCommand " + $popDownCommandName);
	eval ($runTimeCommand);

	runTimeCommand -edit
		-command    $releaseCommandString
		-category   "Other items.User Marking Menus"
		-annotation $releaseAnnotation
		$popDownCommandName;

	if (`window -exists HotkeyEditor`) {
		string $ok = (uiRes("m_hotkeyEditor.kWarningCreateMenuOK"));
		confirmDialog -title (uiRes("m_hotkeyEditor.kWarningCreateMenu"))
			-button $ok
			-defaultButton $ok
			-message (uiRes("m_hotkeyEditor.kWarningCreateMenuMsg"));
	}
	return true;
}

global proc hotkeyEditor_deleteMarkingMenu(string $markingMenuName)
//
//	Description:
//		Delete the runTimeCommands for a marking menu.
//
{
	string $popUpCommandName = $markingMenuName + "_Press";
	string $popDownCommandName = $markingMenuName + "_Release";

	deleteRunTimeCommand($popUpCommandName);
	deleteRunTimeCommand($popDownCommandName);

	if (`window -exists HotkeyEditor`) {
		string $ok = (uiRes("m_hotkeyEditor.kWarningDelMenuOK"));
		confirmDialog -title (uiRes("m_hotkeyEditor.kWarningDelMenu"))
			-button $ok
			-defaultButton $ok
			-message (uiRes("m_hotkeyEditor.kWarningDelMenuMsg"));
	}
}

global proc int hotkeyEditor_renameMarkingMenu(
	string $oldMarkingMenuName,
	string $newMarkingMenuName,
	string $newPressCommandString,
	string $newReleaseCommandString)
//
//	Description:
//		Rename the runTimeCommands associated with a marking menu.
//
{
	int $result = false;

	//	Not much to do if the name marking menu name hasn't changed.
	//
	if ($oldMarkingMenuName == $newMarkingMenuName) return true;

	//	Simply create new runTimeCommands based on the new name.
	//
	$result = hotkeyEditor_createMarkingMenu(
		$newMarkingMenuName,
		$newPressCommandString,
		$newReleaseCommandString);

	//	If successful in creating the new commands then delete the old
	//	commands.
	//
	if ($result) {
		string $oldPopUpCommandName = $oldMarkingMenuName + "_Press";
		string $oldPopDownCommandName = $oldMarkingMenuName + "_Release";

		deleteRunTimeCommand($oldPopUpCommandName);
		deleteRunTimeCommand($oldPopDownCommandName);

		if (`window -exists HotkeyEditor`) {
			string $ok = (uiRes("m_hotkeyEditor.kWarningRenameMenuOK"));
			confirmDialog -title (uiRes("m_hotkeyEditor.kWarningRenameMenu"))
				-button $ok
				-defaultButton $ok
				-message (uiRes("m_hotkeyEditor.kWarningRenameMenuMsg"));
		}
	}
	return $result;
}

global proc int hotkeyEditor_doesMarkingMenuExist(string $markingMenuName)
//
//	Description:
//		Return true if a marking menu with the given name already
//		exists.
//
{
	int $result = true;

	string $popUpCommandName = $markingMenuName + "_Press";
	string $popDownCommandName = $markingMenuName + "_Release";
	
	if (!`runTimeCommand -exists $popUpCommandName` &&
		!`runTimeCommand -exists $popDownCommandName`) {
		$result = false;
	}

	return $result;
}
//
//	END: interface to the Marking Menu Editor, and related routines
//
//	---------------------------------------------------------------

global proc hotkeyEditor()
//
//	Description:
//		Create the Hotkey Editor.
//
{
	//	If the window already exists then just show it and return.
	//
	if (`window -exists HotkeyEditor`) {
		showWindow HotkeyEditor;
		return;
	}

	//	Otherwise, build the window.
	//
	window -title (uiRes("m_hotkeyEditor.kHotkeyEditor")) -height 700 -width 700 HotkeyEditor;
	
	string $form = `formLayout`;

	string $commandListArea = `formLayout`;
	setParent ..;
	string $commandInfoArea = `formLayout`;
	setParent ..;
	string $hotkeyArea = `formLayout`;
	setParent ..;
	string $buttonsArea = `formLayout`;
	setParent ..;

	setParent $hotkeyArea;
	string $currentHotkeyArea = `formLayout`;
	setParent ..;
	string $newHotkeyArea = `formLayout`;
	setParent ..;

	createCommandListArea($commandListArea);
	createCommandInfoArea($commandInfoArea);
	createCurrentHotkeyArea($currentHotkeyArea);
	createNewHotkeyArea($newHotkeyArea);
	createButtonsArea($buttonsArea);

	formLayout -edit
		-attachForm    $currentHotkeyArea "top"    0
		-attachForm    $currentHotkeyArea "left"   0
		-attachNone    $currentHotkeyArea "bottom"
		-attachForm    $currentHotkeyArea "right"  0
		-attachControl $newHotkeyArea     "top"    20 $currentHotkeyArea
		-attachForm    $newHotkeyArea     "left"   0
		-attachNone    $newHotkeyArea     "bottom"
		-attachForm    $newHotkeyArea     "right"  0
		$hotkeyArea;

	formLayout -edit
		-attachForm    $commandListArea   "top"    5
		-attachForm    $commandListArea   "left"   5
		-attachControl $commandListArea   "bottom" 15 $commandInfoArea
		-attachControl $commandListArea   "right"  5 $hotkeyArea
		-attachForm    $hotkeyArea        "top"    5
		-attachNone    $hotkeyArea        "left"
		-attachControl $hotkeyArea        "bottom" 15 $commandInfoArea
		-attachForm    $hotkeyArea        "right"  5
		-attachNone    $commandInfoArea   "top"
		-attachForm    $commandInfoArea   "left"   5
		-attachControl $commandInfoArea   "bottom" 5 $buttonsArea
		-attachForm    $commandInfoArea   "right"  5
		-attachNone    $buttonsArea       "top"
		-attachForm    $buttonsArea       "left"   5
		-attachForm    $buttonsArea       "bottom" 5
		-attachForm    $buttonsArea       "right"  5
		$form;

	resetCreateOrEditMode();
	updateCommandTextScrollList("");
	updateCategoryPopupMenu();
	updateKeyPopupMenu();

	showWindow HotkeyEditor;
}
