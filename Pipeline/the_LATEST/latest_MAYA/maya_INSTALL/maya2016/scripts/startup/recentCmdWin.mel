// Copyright (C) 1997-2014 Autodesk, Inc., and/or its licensors.
// All rights reserved.
//
// The coded instructions, statements, computer programs, and/or related
// material (collectively the "Data") in these files contain unpublished
// information proprietary to Autodesk, Inc. ("Autodesk") and/or its licensors,
// which is protected by U.S. and Canadian federal copyright law and by
// international treaties.
//
// The Data is provided for use exclusively by You. You have the right to use,
// modify, and incorporate this Data into other products for purposes authorized 
// by the Autodesk software license agreement, without fee.
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND. AUTODESK
// DOES NOT MAKE AND HEREBY DISCLAIMS ANY EXPRESS OR IMPLIED WARRANTIES
// INCLUDING, BUT NOT LIMITED TO, THE WARRANTIES OF NON-INFRINGEMENT,
// MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE, OR ARISING FROM A COURSE 
// OF DEALING, USAGE, OR TRADE PRACTICE. IN NO EVENT WILL AUTODESK AND/OR ITS
// LICENSORS BE LIABLE FOR ANY LOST REVENUES, DATA, OR PROFITS, OR SPECIAL,
// DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES, EVEN IF AUTODESK AND/OR ITS
// LICENSORS HAS BEEN ADVISED OF THE POSSIBILITY OR PROBABILITY OF SUCH DAMAGES.

//
//
// Creation Date:  4 July 1997
//
//
//  Procedure Name:
//      recentCmdWin
//

global proc updateRecentCmdWin()
{
	global string $recentCmdWinName;
	global string $recentCmdScrollList;
	string $recentCmdList[] = `repeatLast -q -cnl`;
	string $recentCmdStringList[] = `repeatLast -q -commandList`;	
	int $i, $scrollIdx;
	string $cmd, $cmdName;
	global int   $accumOffset[];

	// Make sure the window exists
	//
	if (!`window -exists $recentCmdWinName`) {
		return;
	}
	
	// Remove all items from the list.
	textScrollList -e -ra $recentCmdScrollList;

	// Fill the list with the recent commands.
	$i = 1;
	$scrollIdx = 1;
	$optionBoxCnt = 0;
	for ($cmdName in $recentCmdList) {
		if ($cmdName == "Parent") {
			// parent constraint and parent menu items have the same name,
			// so use their runtime command instead
			//
			$cmdName = $recentCmdStringList[$i-1];
		}
		
		if ($cmdName != "") {
			$cmdName = makeStringSingleLine( $cmdName );
			textScrollList -e -a $cmdName $recentCmdScrollList;
			$accumOffset[$scrollIdx] = $optionBoxCnt;
			++$scrollIdx;
		} else {
			$optionBoxCnt++;
		}
		++$i;
	}
}
 

global proc doRecentCmd()
{
	global string $recentCmdScrollList;
	global int $accumOffset[];
	int $selected[];
	int $index;

	// Get the selected item in the scrolling list
	$selected = `textScrollList -q -sii $recentCmdScrollList`;

	// Adjust the index to include option box entries
	// which do not appear in the scrolling list but
	// do exist in the repeatLast list.
	$index = $selected[0] + $accumOffset[$selected[0]];

	// Now do it.	
	repeatLast -i $index;
}


global proc recentCmdWin()
{
	global string $recentCmdWinName = "recentCommandWindow";
	global string $recentCmdScrollList;
	string $tsl;
	string $cancelBtn;

	if (!`window -exists $recentCmdWinName`) {
		
		window -title (uiRes("m_recentCmdWin.kRecentCommands"))
			-iconName (uiRes("m_recentCmdWin.kRecent"))
			-wh 225 300 $recentCmdWinName;
	
		formLayout windowLyt;
				$recentCmdScrollList = `textScrollList -nr 16 
						-allowMultiSelection false
						-font "boldLabelFont"
						-selectCommand "doRecentCmd()" tsl`;
				$closeBtn = `button -label (uiRes("m_recentCmdWin.kClose")) closeBtn`;
		    setParent ..;

		// Arrange controls in the form
		formLayout -e	-af $closeBtn left 0
						-af $closeBtn right 0
						-af $closeBtn bottom 0
						windowLyt;

		formLayout -e   -af $recentCmdScrollList top 0 
						-af $recentCmdScrollList left 0 
                        -af $recentCmdScrollList right 0 
						-ac $recentCmdScrollList bottom 0 $closeBtn
						windowLyt;

		// For now deleteUI instead of making the window go invisible.
		// This is to get around a bug where the scriptJob lingers on close.
		button -edit -command "deleteUI recentCommandWindow" $closeBtn;

		// Install the script job. Replace any previous script jobs associated
		// with this window.
		scriptJob -p $recentCmdWinName -replacePrevious -e "RecentCommandChanged" ( "updateRecentCmdWin" );

	}
	showWindow $recentCmdWinName;
	updateRecentCmdWin();
}

