// Copyright (C) 1997-2014 Autodesk, Inc., and/or its licensors.
// All rights reserved.
//
// The coded instructions, statements, computer programs, and/or related
// material (collectively the "Data") in these files contain unpublished
// information proprietary to Autodesk, Inc. ("Autodesk") and/or its licensors,
// which is protected by U.S. and Canadian federal copyright law and by
// international treaties.
//
// The Data is provided for use exclusively by You. You have the right to use,
// modify, and incorporate this Data into other products for purposes authorized 
// by the Autodesk software license agreement, without fee.
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND. AUTODESK
// DOES NOT MAKE AND HEREBY DISCLAIMS ANY EXPRESS OR IMPLIED WARRANTIES
// INCLUDING, BUT NOT LIMITED TO, THE WARRANTIES OF NON-INFRINGEMENT,
// MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE, OR ARISING FROM A COURSE 
// OF DEALING, USAGE, OR TRADE PRACTICE. IN NO EVENT WILL AUTODESK AND/OR ITS
// LICENSORS BE LIABLE FOR ANY LOST REVENUES, DATA, OR PROFITS, OR SPECIAL,
// DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES, EVEN IF AUTODESK AND/OR ITS
// LICENSORS HAS BEEN ADVISED OF THE POSSIBILITY OR PROBABILITY OF SUCH DAMAGES.

//
//
//  Creation Date:  Aug 15 1996
//
//  Description:
//      This procedure creates the main menu bar with the various
//	menu tabs: Modeling, Animation, Rigging, Dynamics, Rendering
//
//  NOTE:  If you add menus to any of the categories, remember to update the
//  dimension of the corresponding array (ie: $gAnimationMenus, $gModelingMenus).
//  If you don't, the script won't fail, but providing explicit array sizes ensures
//  that excess memory is not needlessly allocated for the arrays.
//	NOTE: modify to build common menus dynamically, then
//	add the Motif accelerators to the hotkey file.
proc reOrderMenuSets()
//
//Description: Re-arrange imported menu sets list to the new arrangement
//
{
	string $menuSets[] = `menuSet -q -ams`;
	string $userMenuSets[];
	int $count = 0;

	// retrieve all custom user menu sets
	for ($menuSet in $menuSets) {
		if (	$menuSet != "commonMenuSet" 
			&&	$menuSet != "animationMenuSet"
			&&  $menuSet != "dynamicsMenuSet"
			&&	$menuSet != "renderingMenuSet"
			&&	$menuSet != "modelingMenuSet"
			&&	$menuSet != "riggingMenuSet"
			)
		{
			$userMenuSets[$count] = $menuSet;
			$count ++;
		}
	}

	// re-arrange the user menu sets first
	// bring the last menuset in the list to the top first
	//
	if($count > 0) {
		$count --;
		for( ;$count >= 0; $count-- ) {
			menuSet -moveMenuSet $userMenuSets[$count] 0;
		}
	}

	// followed by the default menu set
	//
	menuSet -moveMenuSet renderingMenuSet 0;
	menuSet -moveMenuSet dynamicsMenuSet 0;
	menuSet -moveMenuSet animationMenuSet 0;
	menuSet -moveMenuSet riggingMenuSet 0;
	menuSet -moveMenuSet modelingMenuSet 0;
	menuSet -moveMenuSet commonMenuSet 0;
}

proc int menuSetContainsExistingMenus(string $menuSet) 
//
// Description: returns whether the specified menu set contains any valid existing menus.
// 
{
	// check whether any menu exists
	string $menus[] = `menuSet -q -menuArray $menuSet`;
	string $menu;
	for ($menu in $menus) {
		if (`menu -q -exists $menu`) {
			return true;
		}
	}
	return false;
}

global proc updateDropDownMenu(string $dropDown, int $isOptionMenuGrp) 
//
// Description: updates the drop down menu with the current order of menuSets.
//	This function also happens to be called from the preferences window.
//
{	
	int $exists;
	if ($isOptionMenuGrp) {
		$exists = `optionMenuGrp -q -exists $dropDown`;
	}else {
		$exists = `optionMenu -q -exists $dropDown`;
	}
	
	if ($exists) {
		
		int $selectSet = -1;
		string $menuSets[] = `menuSet -ams`;
		string $curLabels[];
		if ($isOptionMenuGrp) {
			$curLabels = `optionMenuGrp -q -itemListLong $dropDown`;
		}else {
			$curLabels = `optionMenu -q -itemListLong $dropDown`;
		}

		int $i = 0, $j = 0;

		// go through each menuSet in the given array, and remove the ones which
		//	have no valid menus;
		string $newLabels[];
		int $newIndex = 0;
		for ($i = 0; $i < size($menuSets); $i++) {	

			// skip if we are on the common menu set (never show in drop down)
			if ($menuSets[$i] == "commonMenuSet") {
				continue;
			}

			// check whether any menu exists
			if (menuSetContainsExistingMenus($menuSets[$i])) {
				$newLabels[$newIndex++] = `menuSet -q -l $menuSets[$i]`;
			}
		}

		if (size($newLabels) > size($curLabels)) {
			// the new set has more than the current set

			// rename all in current set
			for ($i = 0; $i < size($curLabels); $i++) {
				menuItem -e -l $newLabels[$i] $curLabels[$i];
			}
			// add the remaining in the new set
			for (;$i < size($newLabels); $i++) {
				if ($isOptionMenuGrp) {
					menuItem -parent ($dropDown + "|OptionMenu") -l $newLabels[$i] -enableCommandRepeat false;
				}else {
					menuItem -parent $dropDown -l $newLabels[$i] -enableCommandRepeat false;
				}				
			}
		}else {
			// the new set has equal or less number than the current set

			// rename all for new set
			for ($i = 0; $i < size($newLabels); $i++) {
				menuItem -e -l $newLabels[$i] $curLabels[$i];
			}
			// remove all remaining sets
			for (;$i < size($curLabels); $i++) {
				deleteUI $curLabels[$i];
			}
		}
		
		// find the index to select to	
		if (`menuSet -q -numberOfMenuSets` > 0) {
			string $curSet = `menuSet -q -label`;
			for ($i = 0; $i < size($newLabels); $i++) {
				// check if we reselect current

				if ($curSet == $newLabels[$i]) {
					$selectSet = $i+1;
					// select			
					if ($isOptionMenuGrp) {
						optionMenuGrp -e -sl $selectSet $dropDown;
					}else {
						optionMenu -e -sl $selectSet $dropDown;
					}
					break;
				}
			}


			// if $selectSet is -1, then the menuSet has been removed, so we select the first item
			if ($selectSet < 0 && size($menuSets) > 0) {
				setMenuMode $menuSets[0];
			}
		}
		
		// Add menu item that will show the menuSetEditor
		string $customize = (uiRes("m_initMainMenuBar.kCustomizeMenuSetsItem"));
		if ($isOptionMenuGrp) {
			menuItem -parent ($dropDown + "|OptionMenu") -label $customize;
		}else {
			menuItem -parent $dropDown -label $customize;
		}
	}
}

proc changeMenusVisibility(string $menus[], int $visible)
//
// This function takes an array of menu object names, and set their visibility to that 
// value specified.
//
{
	int $i;
    int $menuSize = size($menus);

	for ($i = 0; $i < $menuSize; $i++) {		
		if (`menu -q -exists $menus[$i]`) {
			menu -e -vis $visible $menus[$i];
		}
	}
}

// TODO: change menuset visibility, so we don't have to change all everytime that 
//       the mode is changed.  Requires that the menu has been created.  This proc
//		 will make the current set invisible and make the new specified set visible.
proc changeMenuSetVisibility(string $newSet)
// 
// This function takes in a new menu set object name, whose menus are to be shown and the
// menus of the previous menu set to be hidden.
//
{
	global string $gMainHelpMenu; 
	global string $gMainWindow;
	global string $gPreviousMenuMode;

	int $i = 0;
	int $offset = 0;
	string $buffer[];

	string $menuSets[] = `menuSet -q -allMenuSets`;	

	// Hide the current menu set menus
	changeMenusVisibility(`menuSet -q -menuArray` , 0);

	// Move the common menus to the front
	string $common[] = `menuSet -q -menuArray commonMenuSet`;
	for ($i = (size($common)-1); $i >= 0; $i--) {	
		int $c = `tokenize $common[$i] "|" $buffer`;
		window -edit -menuIndex $buffer[$c - 1] 0 $gMainWindow;		
	}		
	$offset = size($common);

	// Handle newSet
	// default to first menuSet if we can not find the given state 
	// or if we are just showing the common (we should show the other sets if we are on common)
	if ($newSet == "commonMenuSet") {

		int $i = 0, $j = 0;
		int $foundValidMenu = false;
		if (`menuSet -q -exists $gPreviousMenuMode`) {
			// ensure that the previous mode has valid menus
			$foundValidMenu = `menuSetContainsExistingMenus($gPreviousMenuMode)`;
			if ($foundValidMenu) {
				$newSet = $gPreviousMenuMode;
			}
		}
		
		if(!$foundValidMenu){
			// otherwise find the next valid one
			for ($i = 0; $i < size($menuSets); ++$i) {
				$foundValidMenu = `menuSetContainsExistingMenus($menuSets[$i])`;
				if ($foundValidMenu) {
					$newSet = $menuSets[$i];					
				}
			}
		}
		
		if(!$foundValidMenu){
			$newSet = "";
		}
	}

	// now, show the common menu set menus (they were only moved to the front before)
	changeMenusVisibility($common, 1);

	if ($newSet != "") {
		// set the new default menu set
		menuSet -currentMenuSet $newSet;
		string $newMenuList[] = `menuSet -q -menuArray $newSet`;    	
		
		// move the visible menus after the common
		for ($i = (size($newMenuList)-1); $i >= 0; $i--) {		
			int $c = `tokenize $newMenuList[$i] "|" $buffer`;
			window -edit -menuIndex $buffer[$c - 1] $offset $gMainWindow;
		}	
		
		// show the new menu set menus	
		changeMenusVisibility($newMenuList, 1);   					
	}

	// set the state to hide next time this function is called
	$gPreviousMenuMode = $newSet;
}

global proc updateMenuModeUI()
//
//  Description:
//	This procedure responds to the "MenuModeChanged" event and
//	updates the visibility of the corresponding menus in the
//	menu bar of the main Maya window.
//
//	This procedure also determines what menu modes are valid,
//	and if an invalid menu mode was set to the "setMenuMode"
//	command, then this procedure will set it back to "Modeling"
//	by default ("Polygons" by default if it uses legacy menu set).
//
{	
	global string $gMayaMode;
	global string $gMenuModeButton;	
	string $newSet = `setMenuMode`;

	// return if no sets available
	if (`menuSet -q -numberOfMenuSets` > 0) {
		if (!`menuSet -q -exists $newSet`) {

			// if there is no menu mode set, then this is being called on new file,
			// so we will default to the saved menu set
			if(`optionVar -exists currentMenuBarTab`) {
				string $prevMenuModeSet = `optionVar -query currentMenuBarTab`;
				
				if ((`menuSet -q -exists $prevMenuModeSet`) && 
					($prevMenuModeSet != "commonMenuSet") &&			
					(`menuSetContainsExistingMenus($prevMenuModeSet)`)) {
					
					// set the previous set iff the menu set exists, it is not the common set,
					// and it contains at least one valid menu			
					$newSet = $prevMenuModeSet;
				}

			}
			
			// if we don't have a valid menu set, then default to the modeling set
			if (!`menuSet -q -exists $newSet`) {
				$newSet = "modelingMenuSet";
			}
		}

		// show the new menu set
		changeMenuSetVisibility($newSet);

		optionVar -sv currentMenuBarTab $newSet;
		optionVar -sv mayaMode $gMayaMode;
		$gMayaMode = $newSet; 		
	}

	// update the drop down menu
	global string $gMenuModeButton;	
	updateDropDownMenu($gMenuModeButton, false);	
	
	// if the prefs are visible, then update that drop down as well
	global string $gModeOptionsMenu;
	if ( (size($gModeOptionsMenu) > 0) && (`optionMenuGrp -q -exists $gModeOptionsMenu`) ) {
		updateDropDownMenu($gModeOptionsMenu, true);	
	}
}


global proc buildDefaultMenuSets(string $menuSet) 
//
// Description: these are the default menuSets, if you are going to change
//	the default set, please remember to change these as well.
//
{	
	// build each menuSet

	//
	// Common 
	//
	if ("commonMenuSet" == $menuSet || "" == $menuSet) {
		global string $gMainFileMenu	= "mainFileMenu";
		global string $gMainEditMenu	= "mainEditMenu";
		global string $gMainModifyMenu	= "mainModifyMenu";
		global string $gMainDisplayMenu	= "mainDisplayMenu";
		global string $gMainWindowMenu	= "mainWindowMenu";
		global string $gMainCreateMenu	= "mainCreateMenu";
		global string $gMainSelectMenu	= "mainSelectMenu";

		menuSet -label (uiRes("m_initMainMenuBar.kCommon")) -permanent true commonMenuSet;

		string $commMenus[] = { $gMainFileMenu
							  , $gMainEditMenu
							  , $gMainCreateMenu
							  , $gMainSelectMenu
							  , $gMainModifyMenu
							  , $gMainDisplayMenu
							  , $gMainWindowMenu
						};
		menuSet -menuArray $commMenus commonMenuSet;
	}

	//
	// Modeling 
	//
	// new Modeling menuset which should contain legacy Polygons and surfaces menuset.
	if ("modelingMenuSet" == $menuSet || "" == $menuSet) {
		global string $gMainMeshMenu;
		global string $gMainEditMeshMenu;
		global string $gMainMeshToolsMenu;
		global string $gMainMeshDisplayMenu;
		global string $gMainCurvesMenu;
		global string $gMainSurfacesMenu;
		global string $gMainDeformMenu;
		global string $gMainUVMenu;
		global string $gMainGenerateMenu;

		menuSet -label (uiRes("m_initMainMenuBar.kNewModelingMenu")) modelingMenuSet;
		string $modelMenus[] = { $gMainMeshMenu
							   , $gMainEditMeshMenu
							   , $gMainMeshToolsMenu
							   , $gMainMeshDisplayMenu
							   , $gMainCurvesMenu
							   , $gMainSurfacesMenu
							   , $gMainDeformMenu
							   , $gMainUVMenu
							   , $gMainGenerateMenu
							};

		menuSet -menuArray $modelMenus modelingMenuSet;
	}

	//
	// Rigging 
	//
	if ("riggingMenuSet" == $menuSet || "" == $menuSet) {	
		global string $gRigSkeletonsMenu;
		global string $gRigSkinningMenu;
		global string $gRigDeformationsMenu;
		global string $gRigConstraintsMenu;
		global string $gRigControlMenu;

		menuSet -label (uiRes("m_initMainMenuBar.kRigging")) riggingMenuSet;
		string $riggingMenus[] = { $gRigSkeletonsMenu
								 , $gRigSkinningMenu
								 , $gRigDeformationsMenu
								 , $gRigConstraintsMenu
								 , $gRigControlMenu 
								};			
		menuSet -menuArray $riggingMenus riggingMenuSet;
	}

	//
	// Animation 
	//
	if ("animationMenuSet" == $menuSet || "" == $menuSet) {
		global string $gMainKeysMenu;
		global string $gMainConstraintsMenu;
		global string $gMainVisualizeMenu;
		global string $gMainDeformationMenu;
		global string $gMainPlaybackMenu;

		menuSet -label (uiRes("m_initMainMenuBar.kAnimation")) animationMenuSet;
		string $animMenus[] = { $gMainKeysMenu
							  , $gMainPlaybackMenu
							  , $gMainVisualizeMenu
							  , $gMainDeformationMenu
							  , $gMainConstraintsMenu
							};
		menuSet -menuArray $animMenus animationMenuSet;
	}

	//
	// Dynamics 
	//
	if( `licenseCheck -m edit -type complete` == 1 ) {
	    if	(	(`optionVar -q loadDynamics` || !`optionVar -ex loadDynamics`)
			&&	(nClothEditLicenseFound())
			&&	(`optionVar -q loadNCloth` || !`optionVar -ex loadNCloth`)
			)
		{
			if ("dynamicsMenuSet" == $menuSet || "" == $menuSet) {
				global string $gMainParticlesMenu;
				global string $gMainFluidsMenu;
				global string $gMainNClothMenu;
				global string $gMainHairMenu;
				global string $gMainNConstraintMenu;
				global string $gMainNCacheMenu;
				global string $gMainFieldsSolverMenu;
				global string $gMainDynEffectsMenu;
						
				menuSet -label (uiRes("m_initMainMenuBar.kFX")) dynamicsMenuSet;
				string $dynMenus[] = { $gMainParticlesMenu
									 , $gMainFluidsMenu
									 , $gMainNClothMenu
									 , $gMainHairMenu
									 , $gMainNConstraintMenu
									 , $gMainNCacheMenu
									 , $gMainFieldsSolverMenu
									 , $gMainDynEffectsMenu
									};

				menuSet -menuArray $dynMenus dynamicsMenuSet;
			}
		}
	}

	//
	// Rendering 
	//
	if (`optionVar -q loadRendering` || !`optionVar -ex loadRendering`) {
		if ("renderingMenuSet" == $menuSet || "" == $menuSet) {	
			global string $gMainShadingMenu;
			global string $gMainRenTexturingMenu;
			global string $gMainRenderMenu;
			global string $gMainCartoonMenu;
			global string $gMainStereoMenu;

			menuSet -label (uiRes("m_initMainMenuBar.kRendering")) renderingMenuSet;	
			string $rendMenus[] = { $gMainShadingMenu
								  , $gMainRenTexturingMenu
								  , $gMainRenderMenu
								  , $gMainCartoonMenu
								  , $gMainStereoMenu
								};
			menuSet -menuArray $rendMenus renderingMenuSet;
		}
	}
}

// Description:
//   This proc is provided so that users can choose to immediately build the main menus 
//	 that we now defer building for desktop heap memory reasons (as of Maya2009)
//	 (see bug 305296). It is not called by Maya on startup.  
//
global proc buildDeferredMenus()
{
	// File Menu
	buildFileMenu();

	// Edit Menu
	global string $gMainEditMenu;
	string $editMenu = "MayaWindow|" + $gMainEditMenu;

	buildEditMenu( $editMenu );

	// Window Menu
	global string $gMainWindowMenu;

	buildViewMenu ( $gMainWindowMenu );

	// Help Menu
	buildHelpMenu();
}

// Description:
//		Remove any menu sets that are deprecated 
//		
proc removeDeprecatedMenuSets()
{
	string $menuSets[] = `menuSet -q -allMenuSets`;

	// nCloth menu set was removed as of Maya 2009 
	if (stringArrayContains("nClothMenuSet", $menuSets))
	{
		menuSet -removeMenuSet nClothMenuSet;
	}

	if ( getApplicationVersionAsFloat() > 2015 )
	{
		// Following menu sets were removed as of Maya 2016
		if (stringArrayContains("polygonsMenuSet", $menuSets))
		{
			menuSet -removeMenuSet polygonsMenuSet;
		}
		if (stringArrayContains("surfacesMenuSet", $menuSets))
		{
			menuSet -removeMenuSet surfacesMenuSet;
		}
		if (stringArrayContains("nDynamicsMenuSet", $menuSets))
		{
			menuSet -removeMenuSet nDynamicsMenuSet;
		}
	}
}

//global proc initMainMenuBar ( string $menuBarParent )
//
//  Note: see notes below regarding any changes to the default menu sets.
//
{
	global string $gMenuModeButton;		// the drop down box
	global string $gMainWindow;

	global string $gNewModelingMenus[]; // This is the new modeling menus which should contains legacy polygons and surfaces menus.
	global string $gAnimationMenus[];
	global string $gDynamicsMenus[];
	global string $gRenderingMenus[];
	global string $gRiggingMenus[];

	// temp vars
	string $menu;
	int $menuIndex;

	///////////////////////////////////////////////////////////////////
	//
	//	NOTE:  if you add/remove menus from
	//		the menus below, please change the appropriate changes in 
	//		buildDefaultMenuSets().  This is due to the fact that 
	//		menuSets should take only short object names.
	//
	///////////////////////////////////////////////////////////////////

	
	// These globals are used to name the main menus so that
	// users can add things to the end of the menus without
	// hardcoding the name.
	//
	global string $gMainFileMenu		= "mainFileMenu";
	global string $gMainEditMenu		= "mainEditMenu";
	global string $gMainModifyMenu		= "mainModifyMenu";
	global string $gMainDisplayMenu   	= "mainDisplayMenu";
	global string $gMainWindowMenu		= "mainWindowMenu";
	global string $gMainOptionsMenu  	= "mainOptionsMenu";
	global string $gMainCreateMenu		= "mainCreateMenu"; 
	global string $gMainSelectMenu		= "mainSelectMenu";

    //////////////////////////////////////////////////
    //
    //	Build the COMMON menu panes
    //
    //////////////////////////////////////////////////

	setParent $gMainWindow;

	if (`isTrue "BaseMayaExists"`) { 
		if (`exists FileMenu`) { 
			eval "source FileMenu";
		}
		if (`exists EditMenu`) { 
			eval "source EditMenu";
		}

	// The Create menu 
		menu -label (uiRes("m_initMainMenuBar.kCreate")) -aob true -to true
			-familyImage "menuIconEdit.png"
			$gMainCreateMenu; 
		menu -e -pmc ( "ModCreateMenu " + $gMainCreateMenu ) $gMainCreateMenu;
		setParent -m ..;

		// Select menu
		$menu = `menu -label (uiRes("m_initMainMenuBar.kSelect")) -aob true -to true
				-familyImage "menuIconSelect.png"
				$gMainSelectMenu`; 
		menu -e -pmc ( "buildSelectMenu " + $menu ) $menu;
		setParent -m ..;

		// Modify menu
		$menu = `menu -label (uiRes("m_initMainMenuBar.kModify")) -aob true -to true
				-familyImage "menuIconModify.png"
				$gMainModifyMenu`; 
		menu -e -pmc ( "ModObjectsMenu " + $menu ) $menu;
		setParent -m ..;

		if (`exists DisplayMenu`) { 
			eval "source DisplayMenu";
		}
		if (`exists ViewMenu`) { 
			eval "source ViewMenu";
		}

		if (`exists HotboxMenus`) { 
			eval "source HotboxMenus";
		}
	
		// Register some default Marking Menus with the Marking Menu Editor.
		//
		{
			if (!`exists registerMenuWithMenuEditor` || !`exists isMenuRegisteredWithMenuEditor`) {
				eval "source menuEditorSetup";
			}
			if (`exists registerMenuWithMenuEditor` && `exists isMenuRegisteredWithMenuEditor`) {
				string $markingMenuAnnotation = "PA_Style_LMB";
				if (!isMenuRegisteredWithMenuEditor($markingMenuAnnotation))
					registerMenuWithMenuEditor(("menu_" + $markingMenuAnnotation),$markingMenuAnnotation);

				$markingMenuAnnotation = "PA_Style_MMB";
				if (!isMenuRegisteredWithMenuEditor($markingMenuAnnotation))
					registerMenuWithMenuEditor(("menu_" + $markingMenuAnnotation),$markingMenuAnnotation);

				$markingMenuAnnotation = "PA_Style_RMB";
				if (!isMenuRegisteredWithMenuEditor($markingMenuAnnotation))
					registerMenuWithMenuEditor(("menu_" + $markingMenuAnnotation),$markingMenuAnnotation);
			}
			else {
				warning (uiRes("m_initMainMenuBar.kCannotRegisterMenus"));
			}
		}
	}

	//////////////////////////////////////////////////
	//
	//	Build the New Modeling menus
	//
	//////////////////////////////////////////////////

	// These globals are used to name the main menus so that
	// users can add things to the end of the menus without
	// hardcoding the name.
	//
	global string $gMainMeshMenu			= "mainMeshMenu";
	global string $gMainEditMeshMenu		= "mainEditMeshMenu";
	global string $gMainMeshToolsMenu		= "mainMeshToolsMenu";
	global string $gMainMeshDisplayMenu 	= "mainMeshDisplayMenu";
	global string $gMainCurvesMenu			= "mainCurvesMenu";
	global string $gMainSurfacesMenu		= "mainSurfacesMenu";
	global string $gMainDeformMenu			= "mainDeformMenu";
	global string $gMainUVMenu				= "mainUVMenu";
	global string $gMainGenerateMenu		= "mainGenerateMenu";

	setParent $gMainWindow;
	$menuIndex = 0;

	$gNewModelingMenus[$menuIndex] = 
		`menu -label (uiRes("m_initMainMenuBar.kModelingMesh")) -aob true -to true
			  -familyImage "menuIconPolygons.png"
			  -postMenuCommandOnce true
			  $gMainMeshMenu`; 
		menu -e -pmc ( "PolygonsMeshMenu " + $gNewModelingMenus[$menuIndex] ) $gNewModelingMenus[$menuIndex]; // We can still reuse the old menu script for this one since it's restructured in Maya 2015.
		$menuIndex++;
	setParent -m ..;

	$gNewModelingMenus[$menuIndex] = 
		`menu -label (uiRes("m_initMainMenuBar.kModelingEditMesh")) -aob true -to true
			  -familyImage "menuIconPolygons.png"
			  $gMainEditMeshMenu`; 
		menu -e -pmc ( "PolygonsBuildMenu " + $gNewModelingMenus[$menuIndex] ) $gNewModelingMenus[$menuIndex]; // We can still reuse the old menu script for this one since it's restructured in Maya 2015.
		$menuIndex++;
	setParent -m ..;
    
	$gNewModelingMenus[$menuIndex] = 
		`menu -label (uiRes("m_initMainMenuBar.kModelingMeshTools")) -aob true -to true
			  -familyImage "menuIconPolygons.png"
			  $gMainMeshToolsMenu`; 
		menu -e -pmc ( "PolygonsBuildToolsMenu " + $gNewModelingMenus[$menuIndex] ) $gNewModelingMenus[$menuIndex]; // We can still reuse the old menu script for this one since it's restructured in Maya 2015.
		$menuIndex++;
	setParent -m ..;

	$gNewModelingMenus[$menuIndex] = 
		`menu -label (uiRes("m_initMainMenuBar.kModelingMeshDisplay")) -aob true -to true
			  -familyImage "menuIconPolygons.png"
			  $gMainMeshDisplayMenu`; 
		menu -e -pmc ( "ModelingMeshDisplayMenu " + $gNewModelingMenus[$menuIndex] ) $gNewModelingMenus[$menuIndex];
		$menuIndex++;
	setParent -m ..;

	$gNewModelingMenus[$menuIndex] = 
		`menu -label (uiRes("m_initMainMenuBar.kModelingCurves")) -aob true -to true
		 	  -postMenuCommandOnce false
			  -familyImage "menuIconEditCurves.png" // Is it approperiate here?
			  $gMainCurvesMenu`; 
		menu -e -pmc ( "ModelingCurvesMenu " + $gNewModelingMenus[$menuIndex] ) $gNewModelingMenus[$menuIndex];
		$menuIndex++;
	setParent -m ..;

	$gNewModelingMenus[$menuIndex] = 
		`menu -label (uiRes("m_initMainMenuBar.kModelingSurfaces")) -aob true -to true
 			  -postMenuCommandOnce false
			  -familyImage "menuIconSurfaces.png"
			  $gMainSurfacesMenu`;
		menu -e -pmc ( "ModelingSurfacesMenu " + $gNewModelingMenus[$menuIndex] ) $gNewModelingMenus[$menuIndex];
		$menuIndex++;
	setParent -m ..;

	$gNewModelingMenus[$menuIndex] = 
		`menu -label (uiRes("m_initMainMenuBar.kModelingDeform")) -aob true -to true
 			  -postMenuCommandOnce false
			  -familyImage "menuIconDeformations.png"
			  $gMainDeformMenu`;
		// This menu set is exactly a copy of Deform menu set in Rigging.
		menu -e -pmc ( "ChaDeformationsMenu " + $gNewModelingMenus[$menuIndex] ) $gNewModelingMenus[$menuIndex];
		$menuIndex++;
	setParent -m ..;

	$gNewModelingMenus[$menuIndex] = 
		`menu -label (uiRes("m_initMainMenuBar.kModelingUV")) -aob true -to true
 			  -postMenuCommandOnce false
			  -familyImage "menuIconPolygons.png"
			  $gMainUVMenu`;
		menu -e -pmc ( "ModelingUVMenu " + $gNewModelingMenus[$menuIndex] ) $gNewModelingMenus[$menuIndex];
		$menuIndex++;
	setParent -m ..;

// Generate menu is only about XGen and PaintEffects.
	$gNewModelingMenus[$menuIndex] = 
		`menu -label (uiRes("m_initMainMenuBar.kModelingGenerate")) -aob true -to true
 			  -postMenuCommandOnce false
			  -familyImage "menuIconDeformations.png"
			  $gMainGenerateMenu`;
		menu -e -pmc ( "ModelingGenerateMenu " + $gNewModelingMenus[$menuIndex] ) $gNewModelingMenus[$menuIndex];
		$menuIndex++;
	setParent -m ..;

	//////////////////////////////////////////////////
	//
	//	Build the ANIMATION menus 
	//
	//////////////////////////////////////////////////

	// These globals are used to name the main menus so that
	// users can add things to the end of the menus without
	// hardcoding the name.
	//
	global string $gMainKeysMenu			= "mainKeysMenu";
	global string $gMainConstraintsMenu		= "mainConstraintsMenu";
	global string $gMainVisualizeMenu		= "mainVisualizeMenu";
	global string $gMainDeformationMenu		= "mainDeformationMenu";
	global string $gMainPlaybackMenu		= "mainPlaybackMenu";

	setParent $gMainWindow;
	$menuIndex = 0;

	$gAnimationMenus[$menuIndex] = 
	`menu -label (uiRes("m_initMainMenuBar.kKey")) -to true -aob true 
		-postMenuCommandOnce true
		-familyImage "menuIconKeys.png"
		$gMainKeysMenu`; 
	menu -e -pmc ( "AniKeyMenu " + $gAnimationMenus[$menuIndex] ) 
		$gAnimationMenus[$menuIndex];
	$menuIndex++;
	setParent -m ..;

	$gAnimationMenus[$menuIndex] = 
	`menu -label (uiRes("m_initMainMenuBar.kPlayback")) -to true -aob true 
		-postMenuCommandOnce true
		$gMainPlaybackMenu`; 
	menu -e -pmc ( "AniPlaybackMenu " + $gAnimationMenus[$menuIndex] ) 
		$gAnimationMenus[$menuIndex];
	$menuIndex++;
	setParent -m ..;

	$gAnimationMenus[$menuIndex] = 
	`menu -label (uiRes("m_initMainMenuBar.kVisualize")) -to true -aob true 
		-postMenuCommandOnce true
		$gMainVisualizeMenu`; 
	menu -e -pmc ( "AniVisualizeMenu " + $gAnimationMenus[$menuIndex] ) 
		$gAnimationMenus[$menuIndex];
	$menuIndex++;
	setParent -m ..;

	$gAnimationMenus[$menuIndex] = 
	`menu -label (uiRes("m_initMainMenuBar.kAniDeform")) -to true -aob true 
		-postMenuCommandOnce true
		$gMainDeformationMenu`; 
	menu -e -pmc ( "AniDeformationsMenu " + $gAnimationMenus[$menuIndex] ) 
		$gAnimationMenus[$menuIndex];
	$menuIndex++;
	setParent -m ..;

	$gAnimationMenus[$menuIndex] = 
	`menu -label (uiRes("m_initMainMenuBar.kAnimConstrain")) -to true -aob true 
		-postMenuCommandOnce true
		-familyImage "menuIconConstraints.png"
		$gMainConstraintsMenu`; 
	menu -e -pmc ( "AniConstraintsMenu " + $gAnimationMenus[$menuIndex] ) 
		$gAnimationMenus[$menuIndex];
	$menuIndex++;
	setParent -m ..;

    //////////////////////////////////////////////////
    //
    //	Build the DYNAMICS menus 
    //
    //////////////////////////////////////////////////
	
	// These globals are used to name the main menus so that
	// users can add things to the end of the menus without
	// hardcoding the name.
	//
	global string $gMainParticlesMenu	 = "mainParticlesMenu";
	global string $gMainFluidsMenu		 = "mainFluidsMenu";
	global string $gMainNClothMenu		 = "mainNClothMenu";
	global string $gMainHairMenu		 = "mainHairMenu";
	global string $gMainNConstraintMenu	 = "mainNConstraintMenu";
	global string $gMainNCacheMenu		 = "mainNCacheMenu";
	global string $gMainFieldsSolverMenu = "mainFieldsSolverMenu";
	global string $gMainDynEffectsMenu	 = "mainDynEffectsMenu";
	if( `licenseCheck -m edit -type complete` == 1 )
	{
		// combining the license check of Dyn & nDyn menu set into a big if-statement
		if	(	(`optionVar -q loadDynamics` || !`optionVar -ex loadDynamics` )
			&&	(`optionVar -q loadNCloth` || !`optionVar -ex loadNCloth`)
			&&	(nClothEditLicenseFound())
			) 
		{
			setParent $gMainWindow;
			$menuIndex = 0;

			// Particles Menu
			$gDynamicsMenus[$menuIndex] = 
				`menu -label (uiRes("m_initMainMenuBar.kParticles")) -aob true -to true
				-postMenuCommandOnce true
				-familyImage "menuIconParticles.png"
				$gMainParticlesMenu`; 
				menu -e -pmc ( "DynParticlesMenu " + $gDynamicsMenus[$menuIndex] ) 
					$gDynamicsMenus[$menuIndex];
				$menuIndex++;

			int $dynamicsIsLicensed = `licenseCheck -mode "edit" -type "fx"`;
			if (!$dynamicsIsLicensed)
			{
				menu -e -enable false $gMainParticlesMenu;
			}
			setParent -m ..;

			// Fluids Menu
			int $fluidsIsLicensed = fluidEditLicenseFound();
			if ( $fluidsIsLicensed ) {
			$gDynamicsMenus[$menuIndex] =
				`menu -label (uiRes("m_initMainMenuBar.kFluid")) -aob true -to true
				-postMenuCommandOnce true
				-familyImage "menuIconFluids.png"
				$gMainFluidsMenu`;
				menu -e -pmc ( "DynFluidsMenu " + $gDynamicsMenus[$menuIndex] )
					$gDynamicsMenus[$menuIndex];
				setParent -m ..;
			} else {
				$gDynamicsMenus[$menuIndex] = "none";
			}
			$menuIndex++;

			// nCloth
			$gDynamicsMenus[$menuIndex] = 
				`menu -label (uiRes("m_initMainMenuBar.kCloth")) -aob true -to true
				-postMenuCommandOnce true
				-familyImage "menuIconFields.png"
				$gMainNClothMenu`; 
				menu -e -pmc ( "DynClothMenu " + $gDynamicsMenus[$menuIndex] ) 
					$gDynamicsMenus[$menuIndex];
				$menuIndex++;
			setParent -m ..;

			// nHair
			int $hairIsLicensed = fluidEditLicenseFound();
			if ( $hairIsLicensed ) {
				$gDynamicsMenus[$menuIndex] =
				`menu -label (uiRes("m_initMainMenuBar.kNhair")) -aob true -to true
				-postMenuCommandOnce true
				-familyImage "menuIconHair.png"
				$gMainHairMenu`;
				menu -e -pmc ( "DynCreateHairMenu " + $gDynamicsMenus[$menuIndex] )
					$gDynamicsMenus[$menuIndex];
				setParent -m ..;
			} else {
				$gDynamicsMenus[$menuIndex] = "none";
			}
			$menuIndex++;

			// nConstraints
			$gDynamicsMenus[$menuIndex] = 
				`menu -label (uiRes("m_initMainMenuBar.kNConstraint")) -aob true -to true 
				-postMenuCommandOnce true
					-familyImage "menuIconNCloth.png"
					$gMainNConstraintMenu`; 
				menu -e -pmc ( "NucleusConstraintMenu " + $gDynamicsMenus[$menuIndex] ) 
					$gDynamicsMenus[$menuIndex];
				$menuIndex++;
			setParent -m ..;
	
			// Cache
			$gDynamicsMenus[$menuIndex] = 
				`menu -label (uiRes("m_initMainMenuBar.kNCache")) -aob true -to true 
				-postMenuCommandOnce true
					-familyImage "menuIconNCloth.png"
					$gMainNCacheMenu`; 
				menu -e -pmc ( "NucleusCacheMenu " + $gDynamicsMenus[$menuIndex] ) 
					$gDynamicsMenus[$menuIndex];
				$menuIndex++;
			setParent -m ..;

			// Fields/Solvers
			$gDynamicsMenus[$menuIndex] = 
				`menu -label (uiRes("m_initMainMenuBar.kFieldsSolver")) -aob true -to true 
				-postMenuCommandOnce true
				-familyImage "menuIconNCloth.png"
				$gMainFieldsSolverMenu`;
				menu -e -pmc ( "DynFieldsSolverMenu " + $gDynamicsMenus[$menuIndex] ) 
					$gDynamicsMenus[$menuIndex];
				$menuIndex++;
			setParent -m ..;

			// Effects
			$gDynamicsMenus[$menuIndex] = 
	            `menu -label (uiRes("m_initMainMenuBar.kEffects")) -aob true -to true
			    -postMenuCommandOnce true
				-familyImage "menuIconBodies.png"
				$gMainDynEffectsMenu`;
			    menu -e -pmc ( "DynEffectsMenu " + $gDynamicsMenus[$menuIndex] ) 
	                $gDynamicsMenus[$menuIndex];
	            $menuIndex++;
	        setParent -m ..;
	    }
	}

    //////////////////////////////////////////////////
    //
    //	Build the RENDERING menus 
    //
    //////////////////////////////////////////////////

	// These globals are used to name the main menus so that
	// users can add things to the end of the menus without
	// hardcoding the name.
	//
	global string $gMainShadingMenu 		= "mainShadingMenu";
	global string $gMainRenTexturingMenu 	= "mainRenTexturingMenu";
	global string $gMainRenderMenu			= "mainRenderMenu";
	global string $gMainCartoonMenu 		= "mainCartoonMenu";
	global string $gMainStereoMenu 			= "mainStereoMenu";

	// The light menu was removed for Maya 3.0
	// Setting this global to the shading menu to not break
	// customer scripts
	//
	global string $gMainLightingMenu	= "mainShadingMenu";

    if (`optionVar -q loadRendering` || !`optionVar -ex loadRendering`)
    {
        setParent $gMainWindow;
        $menuIndex = 0;
		
		string $MainShadingFunc 	= "RenShadersMenu ";
		string $MainTexturingFunc 	= "RenTexturingMenu ";
		string $MainRenderFunc 		= "RenRenderMenu ";
		string $MainCartoonFunc 	= "buildCartoonMenu ";
		string $MainStereoFunc 		= "RenStereoMenu ";

        $gRenderingMenus[$menuIndex] = 
            `menu -label (uiRes("m_initMainMenuBar.kLightingShading")) -aob true -to true 
		    -postMenuCommandOnce true
			-familyImage "menuIconShading.png"
			$gMainShadingMenu`;
		    menu -e -pmc ( $MainShadingFunc + $gRenderingMenus[$menuIndex] ) 
                $gRenderingMenus[$menuIndex];
            $menuIndex++;
        setParent -m ..;

		$gRenderingMenus[$menuIndex] = 
            `menu -label (uiRes("m_initMainMenuBar.kTexturing")) -aob true -to true 
		    -postMenuCommandOnce true
			-familyImage "menuIconTexturing.png"
			$gMainRenTexturingMenu`;
		    menu -e -pmc ( $MainTexturingFunc + $gRenderingMenus[$menuIndex] ) 
	            $gRenderingMenus[$menuIndex];
            $menuIndex++;
        setParent -m ..;			

		$gRenderingMenus[$menuIndex] = 
			`menu 
				-label (uiRes("m_initMainMenuBar.kRender"))
				-aob true -to true -pmo true
				-familyImage "menuIconRender.png"
				$gMainRenderMenu`; 
			menu -e -pmo 0 -pmc ( $MainRenderFunc + $gRenderingMenus[$menuIndex] ) 
				$gRenderingMenus[$menuIndex];
			$menuIndex++;
		setParent -m ..;

		if (`isTrue MayaCreatorExists`) { 
			// Maya TOON menu
			$gRenderingMenus[$menuIndex] = 
				`menu -label (uiRes("m_initMainMenuBar.kToon")) -aob true -to true -pmo true
					-familyImage "menuIconCartoon.png"
					$gMainCartoonMenu`; 
				menu -e -pmo 0 -pmc ( $MainCartoonFunc + $gRenderingMenus[$menuIndex] ) 
					$gRenderingMenus[$menuIndex];
				$menuIndex++;
			setParent -m ..;
		}	

		$gRenderingMenus[$menuIndex] = 
			`menu -label (uiRes("m_initMainMenuBar.kStereo")) -aob true -to true -pmo true
				-familyImage "menuIconRender.png"
				$gMainStereoMenu`; 
			menu -e -pmo 1 -pmc ( $MainStereoFunc  + $gRenderingMenus[$menuIndex] ) 
				$gRenderingMenus[$menuIndex];
			$menuIndex++;
		setParent -m ..;
    }

	//////////////////////////////////////////////////
	//
	//	Build the RIGGING menus 
	//
	//////////////////////////////////////////////////
	
	// These globals are used to name the main menus so that
	// users can add things to the end of the menus without
	// hardcoding the name.
	//
	global string $gRigSkeletonsMenu	= "mainRigSkeletonsMenu";
	global string $gRigSkinningMenu	 	= "mainRigSkinningMenu";
	global string $gRigDeformationsMenu = "mainRigDeformationsMenu";
	global string $gRigControlMenu		= "mainRigControlMenu";
	global string $gRigConstraintsMenu	= "mainRigConstraintsMenu";

	setParent $gMainWindow;
	$menuIndex = 0;

	$gRiggingMenus[$menuIndex] = 
		`menu -label (uiRes("m_initMainMenuBar.kRigSkeleton")) -to true -aob true
			-postMenuCommandOnce false
			-familyImage "menuIconSkeletons.png"
			$gRigSkeletonsMenu`;
		menu -e -pmc ( "ChaSkeletonsMenu " + $gRiggingMenus[$menuIndex] ) 
			$gRiggingMenus[$menuIndex];
		$menuIndex++;
	setParent -m ..;

	$gRiggingMenus[$menuIndex] = 
		`menu -label (uiRes("m_initMainMenuBar.kRigSkin")) -to true -aob true
			-postMenuCommandOnce true
			-familyImage "menuIconSkinning.png"
			$gRigSkinningMenu`; 
	menu -e -pmc ( "ChaSkinningMenu " + $gRiggingMenus[$menuIndex] ) 
		$gRiggingMenus[$menuIndex];
	$menuIndex++;
	setParent -m ..;

	$gRiggingMenus[$menuIndex] = 
		`menu -label (uiRes("m_initMainMenuBar.kRigDeform")) -to true -aob true
 			-postMenuCommandOnce true
			-familyImage "menuIconDeformations.png"
			$gRigDeformationsMenu`;
		menu -e -pmc ( "ChaDeformationsMenu " + $gRiggingMenus[$menuIndex] ) 
			$gRiggingMenus[$menuIndex];
		$menuIndex++;
	setParent -m ..;
	
	$gRiggingMenus[$menuIndex] = 
		`menu -label (uiRes("m_initMainMenuBar.kRigConstrain")) -to true -aob true 
			-postMenuCommandOnce true
			-familyImage "menuIconConstraints.png"
			$gRigConstraintsMenu`; 
		menu -e -pmc ( "AniConstraintsMenu " + $gRiggingMenus[$menuIndex] ) 
			$gRiggingMenus[$menuIndex];
		$menuIndex++;
	setParent -m ..;

	$gRiggingMenus[$menuIndex] = 
		`menu -label (uiRes("m_initMainMenuBar.kControl")) -to true -aob true 
			-postMenuCommandOnce true
			// TODO: -familyImage ""
			$gRigControlMenu`; 
		menu -e -pmc ( "ChaControlsMenu " + $gRiggingMenus[$menuIndex] ) 
			$gRiggingMenus[$menuIndex];
		$menuIndex++;
	setParent -m ..;


	//////////////////////////////////////////////////////////////////
	//
	// Note: Maya Unlimited Plug-In Menus are built in their UI init
    //       sections. (ie cloth,live)
	//
	//////////////////////////////////////////////////////////////////

	// Hide all the menus initially
	changeMenusVisibility(`window -q -menuArray $gMainWindow`, false);

    //////////////////////////////////////////////////
    //
    //	Build the help and auxiliary menus 
    //
    //////////////////////////////////////////////////

	if (`exists AuxiliaryMenus`) { 
		eval "source AuxiliaryMenus";
	} 
	if (`exists AuxiliaryGraphicsMenus.mel`) { 
		eval "source AuxiliaryGraphicsMenus";
	} 


		//
		// -=[ Cache menu ]=-
		//
		// Geometry Cache menu is moved under Cache menu. 
		// Note: Since Maya 2016, rename "Pipeline Cache" menu to "Cache".
		if (!`menu -q -exists mainPipelineCacheMenu`) {
			menu -label (uiRes("m_initMainMenuBar.kMainCache")) 
				 -tearOff true 
				 -parent $gMainWindow 
				 mainPipelineCacheMenu;
		}
		string $geometryCacheMenu = "geometryCacheMenu";
		setParent -menu mainPipelineCacheMenu;
		string $menu =`menuItem -label (uiRes("m_initMainMenuBar.kGeometryCache")) 
					-tearOff true 
					-subMenu true
					-postMenuCommandOnce true
					-familyImage "menuIconKeys.png"
					$geometryCacheMenu`;
				menuItem -e -pmc ( "AniGeoCacheMenu " + $menu ) 
					$menu;
		setParent -m ..;

	if (`exists HelpMenu`) { 
		eval "source HelpMenu";
	}

	//////////////////////////////////////////////////////////////////
	//
	//	Build the default menuSets. NOTE:  if you add/remove menus from
	//		the menus above, please change the appropriate changes in 
	//		buildDefaultMenuSets().  This is due to the fact that 
	//		menuSets should take only short object names.
	//
	//	ALSO: changes to any default menusets should yield a bump in the revision
	//		number in TmenuSetPreferenceCmd::fPreferencesVersion.  This is to allow 
    //		users to be notified of changes to the default sets.
	//
	//////////////////////////////////////////////////////////////////	

	// TODO: load default always and just overwrite? any possibility of things
	//		going wrong this way?
	if (`menuSetPref -q -exists`) {		
		string $okButton = (uiRes("m_initMainMenuBar.kOKMS"));
		string $backButton = (uiRes("m_initMainMenuBar.kBackMS"));
		string $updateButton = (uiRes("m_initMainMenuBar.kUpdateMS"));
		string $skipButton = (uiRes("m_initMainMenuBar.kSkipMS"));
		string $dialogTitle = (uiRes("m_initMainMenuBar.kTitleMS"));
		string $dialogReprompt = (uiRes("m_initMainMenuBar.kRepromptMS"));
		int $dialogResolved = 0;
		float $mayaMenuSetPrefsVer = `menuSetPref -q -version`;

		string $loadInfo[] = `menuSetPref -loadAll`;
			float $loadedMenuSetPrefsVer = float($loadInfo[0]);
			string $errStr = $loadInfo[1];			

		if (equivalentTol($loadedMenuSetPrefsVer, $mayaMenuSetPrefsVer, 0.0001)) {
			// if we have the same version number, and an error is 
			// encountered, then we need to build the default sets
			// again.
			//
			// Only occurs if there was a failure in reading the file,
			// or parsing the version header.
			if (size($errStr) > 0) {
				buildDefaultMenuSets("");
			}			
		}else {

			if ($loadedMenuSetPrefsVer > $mayaMenuSetPrefsVer) {
				// if the user has a more recent set of menu set preferences
				// than the version of maya they are running, then we need
				// to save a backup and load default sets then notify the user.
                menuSetPref -saveBackup;
                buildDefaultMenuSets("");
				// menuSetPrefs -removeAll;

				// notify user
				confirmDialog -title $dialogTitle
					-message $errStr
					-button $okButton
					-defaultButton $okButton;

			}else {

				// if the user has an older version of menu set preferences than
				// the program, we need to prompt the user to update their 
				// preferences.
				while ($dialogResolved < 1) {
					string $result = `confirmDialog  
						-title $dialogTitle
						-message $errStr
						-button $updateButton -button $skipButton
						-defaultButton $updateButton -cancelButton $skipButton
						-dismissString $skipButton`;

					// we load the file as is then save again to update prefs
					if ($result == $updateButton) {				
						menuSetPref -force -loadAll;
						removeDeprecatedMenuSets();
						buildDefaultMenuSets "";
						reOrderMenuSets;
						menuSetPref -saveAll;
						$dialogResolved = 1;

					// we load the set, and save again (overwriting the old header)
					}else if ($result == $skipButton) {
						$result = `confirmDialog
							-title $dialogTitle
							-message $dialogReprompt
							-button $okButton -button $backButton
							-defaultButton $okButton -cancelButton $okButton
							-dismissString $okButton`;

						if ($result == $okButton) {
							menuSetPref -force -loadAll;
							menuSetPref -saveAll;
							$dialogResolved = 1;
						}
					}
				}
			}
		}
	}else {		
		buildDefaultMenuSets("");
	}

	// Get the current menu mode from the preferences.
	// If the one in the preferences isn't recognized, then
	// default to Polygons.
	//
	string $menuSets[] = `menuSet -allMenuSets`;
	string $menuModeSet = "modelingMenuSet";
	if(`optionVar -exists currentMenuBarTab`) {
		string $prevMenuModeSet = `optionVar -query currentMenuBarTab`;
		if ((`menuSet -q -exists $prevMenuModeSet`) && 
			($prevMenuModeSet != "commonMenuSet") &&			
			(`menuSetContainsExistingMenus($prevMenuModeSet)`)) {
			
				// set the previous set iff the menu set exists, it is not the common set,
				// and it contains at least one valid menu			
				$menuModeSet = $prevMenuModeSet;
		}
	}
	if (!`menuSet -q -exists $menuModeSet`) {
		$menuModeSet = $menuSets[0];
	}
	setMenuMode $menuModeSet;	
	updateMenuModeUI;
	optionVar -sv currentMenuBarTab $menuModeSet;

	// When the menu mode changes, make sure that the menus are updated.
	//
	scriptJob -permanent -event "MenuModeChanged" "updateMenuModeUI";
}
