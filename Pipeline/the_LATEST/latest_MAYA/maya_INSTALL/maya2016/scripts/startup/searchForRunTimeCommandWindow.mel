// Copyright (C) 1997-2014 Autodesk, Inc., and/or its licensors.
// All rights reserved.
//
// The coded instructions, statements, computer programs, and/or related
// material (collectively the "Data") in these files contain unpublished
// information proprietary to Autodesk, Inc. ("Autodesk") and/or its licensors,
// which is protected by U.S. and Canadian federal copyright law and by
// international treaties.
//
// The Data is provided for use exclusively by You. You have the right to use,
// modify, and incorporate this Data into other products for purposes authorized 
// by the Autodesk software license agreement, without fee.
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND. AUTODESK
// DOES NOT MAKE AND HEREBY DISCLAIMS ANY EXPRESS OR IMPLIED WARRANTIES
// INCLUDING, BUT NOT LIMITED TO, THE WARRANTIES OF NON-INFRINGEMENT,
// MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE, OR ARISING FROM A COURSE 
// OF DEALING, USAGE, OR TRADE PRACTICE. IN NO EVENT WILL AUTODESK AND/OR ITS
// LICENSORS BE LIABLE FOR ANY LOST REVENUES, DATA, OR PROFITS, OR SPECIAL,
// DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES, EVEN IF AUTODESK AND/OR ITS
// LICENSORS HAS BEEN ADVISED OF THE POSSIBILITY OR PROBABILITY OF SUCH DAMAGES.

//
//
//  Creation Date:  20 December 1999
//
//  Description:
//      This script implements the "Search for a Command" window.
//
//		The window is accessed from the Hotkey Editor window and its
//		main purpose is to allow users a simple searching of the commands
//		available for attaching to hotkeys.
//

/*
//
//	These are the local and global procedures defined in this file.  As well
//	as the unique names of the UI objects created.
//
// ----------------------------------------------------------------------
//
spacing(string $str, string $longest)

searchForRunTimeCommandWindowSearch()
searchForRunTimeCommandWindowPrintHelp()
searchForRunTimeCommandWindowClose()
searchForRunTimeCommandWindow()

SearchForRunTimeCommandWindow
SearchForRunTimeCommandWindowSearchFieldGrp
SearchForRunTimeCommandWindowSearchResultField
*/

proc string spacing(string $str, string $longest)
//
//	Description:
//		Return a string containing the number of spaces required to
//		make the passed in string argument the same length as the
//		passed in "longest" string.
//
//	Example:
//		
//		if  $str is                    "Hello"
//		and $longest is                "A longer string"
//
//		then the return string will be "          ".
//							
{
	string $result = "";
	string $spaces = "                                                  ";
	
	$numberOfSpacesNeeded = size($longest) - size($str);

	if (0 < $numberOfSpacesNeeded) {
		if ($numberOfSpacesNeeded > size($spaces)) {
			$numberOfSpacesNeeded = size($spaces);
		}
		$result = `substring $spaces 1 $numberOfSpacesNeeded`;
	}
	
	return $result;
}

global proc searchForRunTimeCommandWindowSearch()
//
//	Description:
//		This function is called when the user changes the text in the
//		search field.
//
{
	string $result = "", $command, $match[];
	string $longestNameMatch, $longestCategoryMatch;
	int $matchIndex = 0, $numberOfMatches;
	
	string $searchFor = `textFieldGrp -query -text 
		SearchForRunTimeCommandWindowSearchFieldGrp`;
	string $category; 
	string $nameHeader = (uiRes("m_searchForRunTimeCommandWindow.kCommandName"));
	string $categoryHeader = (uiRes("m_searchForRunTimeCommandWindow.kCategory"));
	string $commandHeader = (uiRes("m_searchForRunTimeCommandWindow.kCommand"));
	string $spaceAfterName = "    ", $spaceAfterCategory = "    ";
	
	if ("" == $searchFor) {
		//
		//	Check for empty search string.
		//
		searchForRunTimeCommandWindowPrintHelp();

	} else {
		//
		//	Look for matches on the command's name and the actual command.
		//
		string $runTimeCommands[] = `runTimeCommand -query -commandArray`;
		for ($runTimeCommand in $runTimeCommands) {
			$command = `runTimeCommand -query -command $runTimeCommand`;
			if (gmatch($runTimeCommand, $searchFor) ||
				gmatch($command, $searchFor)) {
				$match[$matchIndex++] = $runTimeCommand;
			}
		}

		$numberOfMatches = size($match);
		
		if (0 < $numberOfMatches) {
			//
			//	Matches found.
			//
			
			//	Look for the longest command name and category name so we can 
			//	line up the results.
			//
			$longestNameMatch = $nameHeader;
			for ($matchIndex = 0; $matchIndex < $numberOfMatches; $matchIndex++) {
				if (size($match[$matchIndex]) > size($longestNameMatch)) {
					$longestNameMatch = $match[$matchIndex];
				}
			}
			$longestCategoryMatch = $categoryHeader;
			for ($matchIndex = 0; $matchIndex < $numberOfMatches; $matchIndex++) {
				$category = `runTimeCommand -query -category $match[$matchIndex]`;
				if (size($category) > size($longestCategoryMatch)) {
					$longestCategoryMatch = $category;
				}
			}

			//	Print out a header for the results.
			//
			$result = $nameHeader + spacing($nameHeader, $longestNameMatch) 
				+ $spaceAfterName + $categoryHeader
				+ spacing($categoryHeader, $longestCategoryMatch)
				+ $spaceAfterCategory + $commandHeader + "\n"
				+ "-----------------------------------"
				+ "-----------------------------------\n";
			
			//	For each match print out the command name, category of the
			//	command and the actual command.
			//
			for ($matchIndex = 0; $matchIndex < $numberOfMatches; $matchIndex++) {
				$result += $match[$matchIndex];

				$category = `runTimeCommand -query -category $match[$matchIndex]`;
				$result += spacing($match[$matchIndex], $longestNameMatch)
					+ $spaceAfterName + $category
					+ spacing($category, $longestCategoryMatch)
					+ $spaceAfterCategory
					+ `runTimeCommand -query -command $match[$matchIndex]` + "\n";
			}

		} else {
			//
			//	No matches found.
			//
			string $message = (uiRes("m_searchForRunTimeCommandWindow.kMessage"));
			$result = `format -s $searchFor $message`;
			
			//	Does the search string have any *'s in it?  If not then
			//	suggest that the user should add one.
			//
			if (gmatch($searchFor, "*[**]*")) {
			} else {
				string $newMsg = (uiRes("m_searchForRunTimeCommandWindow.kNewMsg"));
				$result = `format -s $searchFor -s $searchFor $newMsg`;
			}
		}
		scrollField -edit -text $result -insertionPosition 1
			SearchForRunTimeCommandWindowSearchResultField;
	}
}

global proc searchForRunTimeCommandWindowPrintHelp()
//
//	Description:
//		Print out a help message for the user.  Describe what is
//		expected in the search field and give some examples.
//
{
	string $help = (uiRes("m_searchForRunTimeCommandWindow.kHelpText"));
	scrollField -edit -text $help -insertionPosition 1
		SearchForRunTimeCommandWindowSearchResultField;
	textFieldButtonGrp -edit -text "" SearchForRunTimeCommandWindowSearchFieldGrp;
}

global proc searchForRunTimeCommandWindowClose()
//
//	Description:
//		This function is called when the user presses the close button.
//
{
	//	Delete the window.
	//
	deleteUI -window SearchForRunTimeCommandWindow;
}

global proc searchForRunTimeCommandWindow()
//
//	Description:
//		Create a window for searching the runTimeCommands.
//
{
	//	If the window already exists then just show it and return.
	//
	if (`window -exists SearchForRunTimeCommandWindow`) {
		showWindow SearchForRunTimeCommandWindow;
		return;
	}

	//	Otherwise, build the window.
	//
	window -title (uiRes("m_searchForRunTimeCommandWindow.kTitle"))
		-iconName (uiRes("m_searchForRunTimeCommandWindow.kIconName"))
		SearchForRunTimeCommandWindow;

	string $form = `formLayout`;
	
	string $description = (uiRes("m_searchForRunTimeCommandWindow.kSearchAnnot"));

	string $searchFor = `textFieldButtonGrp -label (uiRes("m_searchForRunTimeCommandWindow.kSearchFor"))
		-buttonLabel (uiRes("m_searchForRunTimeCommandWindow.kHelp"))
		-buttonCommand ("searchForRunTimeCommandWindowPrintHelp")
		-adjustableColumn2 2 
		-changeCommand ("searchForRunTimeCommandWindowSearch")
		-annotation $description
		SearchForRunTimeCommandWindowSearchFieldGrp`;

	string $results = `scrollField -editable false -height 250
		SearchForRunTimeCommandWindowSearchResultField`;
	
	string $close = `button -label (uiRes("m_searchForRunTimeCommandWindow.kClose"))
		-command ("searchForRunTimeCommandWindowClose")`;
	
	formLayout -edit
		-attachForm    $searchFor "top"    5
		-attachForm    $searchFor "left"   5
		-attachNone    $searchFor "bottom"
		-attachForm    $searchFor "right"  5
		-attachControl $results   "top"    5 $searchFor
		-attachForm    $results   "left"   5
		-attachControl $results   "bottom" 5 $close
		-attachForm    $results   "right"  5
		-attachNone    $close     "top"
		-attachForm    $close     "left"   5
		-attachForm    $close     "bottom" 5
		-attachForm    $close     "right"  5
		$form;
	
	showWindow SearchForRunTimeCommandWindow;
}
