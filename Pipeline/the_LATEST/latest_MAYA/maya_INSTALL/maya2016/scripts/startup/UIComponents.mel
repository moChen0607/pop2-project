// Copyright (C) 1997-2014 Autodesk, Inc., and/or its licensors.
// All rights reserved.
//
// The coded instructions, statements, computer programs, and/or related
// material (collectively the "Data") in these files contain unpublished
// information proprietary to Autodesk, Inc. ("Autodesk") and/or its licensors,
// which is protected by U.S. and Canadian federal copyright law and by
// international treaties.
//
// The Data is provided for use exclusively by You. You have the right to use,
// modify, and incorporate this Data into other products for purposes authorized 
// by the Autodesk software license agreement, without fee.
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND. AUTODESK
// DOES NOT MAKE AND HEREBY DISCLAIMS ANY EXPRESS OR IMPLIED WARRANTIES
// INCLUDING, BUT NOT LIMITED TO, THE WARRANTIES OF NON-INFRINGEMENT,
// MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE, OR ARISING FROM A COURSE 
// OF DEALING, USAGE, OR TRADE PRACTICE. IN NO EVENT WILL AUTODESK AND/OR ITS
// LICENSORS BE LIABLE FOR ANY LOST REVENUES, DATA, OR PROFITS, OR SPECIAL,
// DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES, EVEN IF AUTODESK AND/OR ITS
// LICENSORS HAS BEEN ADVISED OF THE POSSIBILITY OR PROBABILITY OF SUCH DAMAGES.

//
//
//  Creation Date:  22 Aug 2000
//

// New functions added to support Toolbars and Dock Widgets

global proc string createUIComponentToolBar(string $name, string $label, string $parent, string $area, string $allowedAreas[])
{
	global string $gUIComponentToolBarArray[];
	global int $kNameIndex;
	global int $kControlIndex;
	
	// create toolbar
	string $createCmd = ("toolBar -content \"") + $parent 
							+ ("\" -label \"") + $label 
							+ ("\" -area ") + $area;
	
	string $a;
	for($a in $allowedAreas) {
		$createCmd += (" -allowedArea ");
		$createCmd += $a;
	}
	
	string $toolbar = `eval($createCmd)`;

	// add entry to array
	int $count = size($gUIComponentToolBarArray);
	$gUIComponentToolBarArray[$count + $kNameIndex] = $name;
	$gUIComponentToolBarArray[$count + $kControlIndex] = $toolbar;

	return $parent;
}


global proc string getUIComponentToolBar(string $name, int $reportError)
//
//	Description:
//		Return the tool bar corresponding to the given component name.
//
//		May return an empty string if the argument name does not refer
//		to a valid tool bar. In this case this procedure will
//		generate an error.
//
//	Arguments:
//		name - The component name.
//
//	Returns:
//		The name of the component tool bar.
//
{
	global string $gUIComponentToolBarArray[];

	global int    $kNameIndex;
	global int    $kControlIndex;
	global int    $kToolBarElementSize;

	string $component = "";
	int    $index, $count;
	
	if ("" == $name) {
		error -showLineNumber true (uiRes("m_UIComponents.kArgError"));
		return $component;
	}

	//	Search the tool bar array.
	//
	$count = size($gUIComponentToolBarArray);
	for ($index = 0; $index < $count; $index += $kToolBarElementSize) {
		if ($name == $gUIComponentToolBarArray[$index + $kNameIndex]) {
			$component = $gUIComponentToolBarArray[$index + $kControlIndex];
			break;
		}
	}

	if ("" == $component && $reportError) {
		string $error = uiRes("m_UIComponents.kComponentError");
		error -showLineNumber true (`format -s $name $error`);
	}

	return $component;
}

global proc string createUIComponentDockControl(string $name, string $label, string $parent, string $area, string $allowedAreas[])
{
	global string $gUIComponentDockControlArray[];
	global int $kNameIndex;
	global int $kControlIndex;
	
	// create toolbar
	string $createCmd = ("dockControl -content \"") + $parent 
							+ ("\" -label \"") + $label 
							+ ("\" -area ") + $area
							+ (" -visible false");
	
	string $a;
	for($a in $allowedAreas) {
		$createCmd += " -allowedArea ";
		$createCmd += $a;
	}
	
	string $dockControl = `eval($createCmd)`;

	// add entry to array
	int $count = size($gUIComponentDockControlArray);
	$gUIComponentDockControlArray[$count + $kNameIndex] = $name;
	$gUIComponentDockControlArray[$count + $kControlIndex] = $dockControl;

	return $parent;
}

global proc string getUIComponentDockControl(string $name, int $reportError)
//
//	Description:
//		Return the dock control corresponding to the given component name.
//
//		May return an empty string if the argument name does not refer
//		to a valid dock control. In this case this procedure will
//		generate an error.
//
//	Arguments:
//		name - The component name.
//
//	Returns:
//		The name of the component dock control.
//
{
	global string $gUIComponentDockControlArray[];

	global int    $kNameIndex;
	global int    $kControlIndex;
	global int    $kDockControlElementSize;

	string $component = "";
	int    $index, $count;
	
	if ("" == $name) {
		error -showLineNumber true (uiRes("m_UIComponents.kArgError"));
		return $component;
	}

	//	Search the tool bar array.
	//
	$count = size($gUIComponentDockControlArray);
	for ($index = 0; $index < $count; $index += $kDockControlElementSize) {
		if ($name == $gUIComponentDockControlArray[$index + $kNameIndex]) {
			$component = $gUIComponentDockControlArray[$index + $kControlIndex];
			break;
		}
	}

	if ("" == $component && $reportError) {
		string $error = uiRes("m_UIComponents.kComponentError");
		error -showLineNumber true (`format -s $name $error`);
	}

	return $component;
}

//  Description:
//      This script provides support for UI components. A UI component is a
//		group of controls appearing in a window which may be hidden or
//		shown. The main purpose for this is the main application window that
//		has various tool bars and user interface elements that the user may
//		show or hide depending on their preference. Note however that this
//		functionality is structured such that UI components may be placed
//		in any window.
//
//		There 2 types of UI Components, horizontal and vertical.
//
//		Each horizontal UI Component can be hidden and shown individually.
//		When visible, a horizontal UI Component has a close box along its
//		left edge.
//
//		Vertical UI Components may appear along the left or right edge of
//		the window. Only one vertical UI Component may be visible on a 
//		particular side. Each vertical UI Component has a close box along its
//		top edge.
//
//		You have access to the close button control for each component. You
//		may want to attach a popup menu to each close box for quick access
//		to the visibility of all the components.
//
//		Consider the following ASCII art diagram. There are 3 horizontal
//		components, 2 at the top of the window and 1 along the bottom. There
//		are also 3 vertical components, 1 on the left and 2 on the right.
//		All components below are currently visible. Note that you can only
//		see one of the two right vertical components at any given time.
//
//		The X's indicate the close boxes for hiding the components.
//
//		+--------------------------------------------------+
//		|X                                                 |
//		+--------------------------------------------------+
//
//		+--------------------------------------------------+
//		|X                                                 |
//		+--------------------------------------------------+
//
//		+----+  +-------------------------------+  +-------+
//		|X   |  |                               |  |      X|
//		|    |  |                               |  |       |
//		|    |  |                               |  |       |
//		|    |  |                               |  |       |
//		|    |  |                               |  |       |
//		|    |  |                               |  |       |
//		|    |  |                               |  |       |
//		|    |  |          Work Area            |  |       |
//		|    |  |          eg. Panels           |  |       |
//		|    |  |                               |  |       |
//		|    |  |                               |  |       |
//		|    |  |                               |  |       |
//		|    |  |                               |  |       |
//		|    |  |                               |  |       |
//		|    |  |                               |  |       |
//		|    |  |                               |  |       |
//		|    |  |                               |  |       |
//		+----+  +-------------------------------+  +-------+
//
//		+--------------------------------------------------+
//		|X                                                 |
//		+--------------------------------------------------+
//
//		To take advantage of UI Components you must structure the layout
//		of your window in a specific way. This is best described by way
//		of a complete example found in the script UICompenentsExample.mel.
//
//
//----------------------------------------------------------------------
//
//	Public interface.
//
//
// global proc createUIComponentBar(
// 	string $name, 
// 	string $position)
// 
// global proc removeUIComponentBar(string $name)
// 
// global proc string createUIComponent(
// 	string $barName, 
// 	string $name, 
// 	string $parent)
// 
// global proc string getUIComponent(string $name)
// 
// global proc setUIComponentStateCallback(
// 	string $componentName,
// 	string $callback)
// 
// global proc setUIComponentWorkArea(
// 	string $name,
// 	string $workArea)
// 
// global proc int toggleUIComponentVisibility(string $name)
// 
// global proc int isUIComponentVisible(string $name)
// 
// global proc string getUIComponentCloseButton(string $name)
//
// global proc int UIComponentExists(string $name)
// 
// global proc printUIComponentBarInfo()
// 
//----------------------------------------------------------------------
//
//	Global variables. Not intended to be accessed outside of this file.
//

//	Contains the name of the component bar, the layout control, the
//	number of components associated with the bar, and the work area layout.
//
// global string $gUIComponentBarArray[];
 
//	Contains the component name and layout control.
//
// global string $gUIComponentBarComponentArray[];
 
//	Indecies and constants that help provide pseudo-structures in MEL.
//
//	Component UI information is stored in one dimensional string arrays.
//	The indecies are used to access individual values within the array.
//
// global int $kNameIndex;
// global int $kParentIndex;
// global int $kComponentCountIndex;
// global int $kCallbackIndex;
// global int $kLayoutIndex;
// global int $kPositionIndex;
// global int $kCurrentIndex;
 
//	Size of the elements in the information arrays.
//
// global int $kComponentBarElementSize;
// global int $kComponentElementSize;

//----------------------------------------------------------------------
//
//	Local procedures. Even though some of these procedures may be 
//	declared global they are still intended to be used within this
//	file only.
//

// proc string getUIComponentBarFromComponent(string $name)
// 
// proc string [] getUIComponentArray(string $name)
// 
// proc string getCallback(string $componentName)
// 
// proc string getWorkArea(string $name)
// 
// proc string getUIComponentBarPosition(string $name)
// 
// proc setCurrentUIComponent(string $componentBar, string $component)
// 
// proc string getCurrentUIComponent(string $componentBar)
// 
// proc string getUIComponentContentLayout(string $componentLayout)
// 
// global proc showCurrentComponent(string $componentBarName)
// 

proc string getUIComponentBarFromComponent(string $name)
//
//	Description:
//		Return the name of the component bar that contains the specified
//		component.
//
//		May return an empty string if the argument component name does not 
//		refer to a valid component. In this case this procedure will
//		generate an error.
//
//	Arguments:
//		name - The component name.
//
//	Returns:
//		The name of component bar that contains the argument component.
//
{
	global string $gUIComponentBarArray[];
	global string $gUIComponentBarComponentArray[];

	global int    $kNameIndex;
	global int    $kComponentCountIndex;
	global int    $kComponentBarElementSize;
	global int    $kComponentElementSize;

	string $component, $componentBar = "";
	int    $index, $count, $componentIndex = -1;
	int    $numberOfComponents, $componentSum;

	if ("" == $name) {
		error -showLineNumber true (uiRes("m_UIComponents.kArgError"));
		return $componentBar;
	}

	//	Search the component array...
	//
	$count = size($gUIComponentBarComponentArray);
	for ($index = 0; $index < $count; $index += $kComponentElementSize) {
		if ($name == $gUIComponentBarComponentArray[$index + $kNameIndex]) {
			$componentIndex = $index / $kComponentElementSize;
			break;
		}
	}

	if ($componentIndex >= 0) {

		//	Search the component bar array.
		//
		$componentSum = 0;
		$count = size($gUIComponentBarArray);

		//	For each component bar test the number of components it has.
		//
		for ($index = 0; $index < $count; $index += $kComponentBarElementSize) {

			//	Test if the component bar has 0 components.
			//
			$numberOfComponents = $gUIComponentBarArray[$index + $kComponentCountIndex];
			if (0 < $numberOfComponents) {

				//	Keep a running sum of the total number of components
				//	in order to compare with the component index determined
				//	above.
				//
				$componentSum += $numberOfComponents;

				if ($componentIndex < $componentSum) {
					//
					//	Retrieve the component bar name.
					//
					$componentBar = $gUIComponentBarArray[$index + $kNameIndex];
					break;
				}
			}
		}

	} else {
		string $error = (uiRes("m_UIComponents.kComponentError"));
		error -showLineNumber true (`format -s $name $error`);
	}

	return $componentBar;
}

proc string [] getUIComponentArray(string $name)
//
//	Description:
//		Return an array containing the names of all the components
//		contained in the specified component bar.
//
//		May return an empty string array if the argument component bar
//		name does not refer to a valid component bar. In this case this 
//		procedure will generate an error.
//
//	Arguments:
//		name - The component bar name.
//
//	Returns:
//		A string array containing all the names of all the components
//		contained in the specified component bar.
//
{
	global string $gUIComponentBarArray[];
	global string $gUIComponentBarComponentArray[];

	global int    $kNameIndex;
	global int    $kComponentCountIndex;
	global int    $kComponentBarElementSize;
	global int    $kComponentElementSize;
	
	string $componentArray[];
	int    $index, $count, $componentIndex, $componentCount = -1;
	int    $end, $start;

	if ("" == $name) {
		error -showLineNumber true (uiRes("m_UIComponents.kArgError"));
		return $componentArray;
	}

	//	Search the component bar array.
	//
	//	Note that this array records the number of components in each bar.
	//	By summing the component counts we can determine the start and
	//	end indecies of the corresponding components in the component
	//	array.
	//
	$start = 0;
	$count = size($gUIComponentBarArray);
	for ($index = 0; $index < $count; $index += $kComponentBarElementSize) {
		if ($name == $gUIComponentBarArray[$index + $kNameIndex]) {
			$componentCount = $gUIComponentBarArray[$index + $kComponentCountIndex];
			break;
		}
		$start += $gUIComponentBarArray[$index + $kComponentCountIndex];
	}

	if ($componentCount >= 0) {
		$end = $start + $componentCount;
		$componentIndex = 0;
		for ($index = $start; $index < $end; $index ++) {
			$componentArray[$componentIndex++]
				= $gUIComponentBarComponentArray[$index * $kComponentElementSize];
		}

	} else {
		string $error = uiRes("m_UIComponents.kComponentWarn");
		error -showLineNumber true (`format -s $name $error`);
	}

	return $componentArray;
}

proc string getCallback(string $componentName)
//
//	Description:
//		Return the callback for a component.
//
//	Arguments:
//		componentName - The UI component name.
//
//	Returns:
//		The name of the callback. May be an empty string.
//
{
	global string $gUIComponentBarComponentArray[];

	global int    $kNameIndex;
	global int    $kCallbackIndex;
	global int    $kComponentElementSize;

	string $callback = "";
	int    $index, $count;
	
	if ("" == $componentName) {
		error -showLineNumber true (uiRes("m_UIComponents.kArgEmptyError"));
		return $callback;
	}

	//	Search the component array.
	//
	$count = size($gUIComponentBarComponentArray);
	for ($index = 0; $index < $count; $index += $kComponentElementSize) {
		if ($componentName == $gUIComponentBarComponentArray[$index + $kNameIndex]) {
			$callback = $gUIComponentBarComponentArray[$index + $kCallbackIndex];
			break;
		}
	}

	return $callback;
}

proc string getWorkArea(string $name)
//
//	Description:
//		Return the name of the work area layout associated with the given
//		component bar name.
//
//	Arguments:
//		name - The UI component bar name.
//
//	Returns:
//		The name of the work area layout.
//
{
	global string $gUIComponentBarArray[];

	global int    $kNameIndex;
	global int    $kLayoutIndex;
	global int    $kComponentBarElementSize;

	string $workArea = "";
	int    $index, $count;
	
	if ("" == $name) {
		error -showLineNumber true (uiRes("m_UIComponents.kArgEmptyError"));
		return $workArea;
	}

	//	Search the component bar array.
	//
	$count = size($gUIComponentBarArray);
	for ($index = 0; $index < $count; $index += $kComponentBarElementSize) {
		if ($name == $gUIComponentBarArray[$index + $kNameIndex]) {
			$workArea = $gUIComponentBarArray[$index + $kLayoutIndex];
			break;
		}
	}

	return $workArea;
}

proc string getUIComponentBarPosition(string $name)
//
//	Description:
//		Return the position of the component bar.
//
//	Arguments:
//		name - The UI component bar name.
//
//	Returns:
//		The position of the component bar.
//
{
	global string $gUIComponentBarArray[];

	global int    $kNameIndex;
	global int    $kPositionIndex;
	global int    $kComponentBarElementSize;

	string $position = "";
	int    $index, $count;
	
	if ("" == $name) {
		error -showLineNumber true (uiRes("m_UIComponents.kArgEmptyError"));
		return $position;
	}

	//	Search the component bar array.
	//
	$count = size($gUIComponentBarArray);
	for ($index = 0; $index < $count; $index += $kComponentBarElementSize) {
		if ($name == $gUIComponentBarArray[$index + $kNameIndex]) {
			$position = $gUIComponentBarArray[$index + $kPositionIndex];
			break;
		}
	}

	return $position;
}

proc setCurrentUIComponent(
	string $componentBar,
	string $component)
//
//	Description:
//		Set the current component for a UI component bar.
//
//	Arguments:
//		componentBar - The component bar name.
//
//		name - The component name.
//
{
	global string $gUIComponentBarArray[];

	global int    $kNameIndex;
	global int    $kCurrentIndex;
	global int    $kComponentBarElementSize;

	int    $index, $count, $componentBarIndex = -1;

	if ("" == $componentBar) {
		error -showLineNumber true (uiRes("m_UIComponents.kArgError"));
		return;
	}

	//	Search the component bar array.
	//
	$count = size($gUIComponentBarArray);
	for ($index = 0; $index < $count; $index += $kComponentBarElementSize) {
		if ($componentBar == $gUIComponentBarArray[$index + $kNameIndex]) {
			$componentBarIndex = $index;
			break;
		}
	}

	if ($componentBarIndex >= 0) {
		$gUIComponentBarArray[$componentBarIndex + $kCurrentIndex] = $component;

	} else {
		//	Component bar not found. Return.
		//
		string $error = uiRes("m_UIComponents.kComponentWarn");
		error -showLineNumber true (`format -s $componentBar $error`);
		return;
	}
}

proc string getCurrentUIComponent(string $name)
//
//	Description:
//		Return the name of the current component for a UI component bar.
//
//	Arguments:
//		$name - The component bar name.
//
//	Returns:
//		The name of the current UI component.
//
{
	global string $gUIComponentBarArray[];

	global int    $kNameIndex;
	global int    $kCurrentIndex;
	global int    $kComponentBarElementSize;

	string $current = "";
	int    $index, $count, $componentBarIndex = -1;

	if ("" == $name) {
		error -showLineNumber true (uiRes("m_UIComponents.kArgError"));
		return $current;
	}

	//	Search the component bar array.
	//
	$count = size($gUIComponentBarArray);
	for ($index = 0; $index < $count; $index += $kComponentBarElementSize) {
		if ($name == $gUIComponentBarArray[$index + $kNameIndex]) {
			$current = $gUIComponentBarArray[$index + $kCurrentIndex];
			break;
		}
	}

	return $current;
}

proc string getUIComponentContentLayout(string $componentLayout)
//
//	Description:
//		Return the parent layout for component content.
//
//	Arguments:
//		componentLayout - The layout containing the component.
//
{
	string $contentLayout, $childArray[];

	$childArray = `layout -query -childArray $componentLayout`;
	$contentLayout = $childArray[1];

	return ($componentLayout + "|" + $contentLayout);
}

global proc showCurrentComponent(string $componentBarName)
//
//	Description:
//		This procedure is called whenever a side component bar is opened.
//
//		Determine the component that should be shown (ie. that last one
//		that was shown before the component was hidden) and make it
//		visible again.
//
//	Arguments:
//		componentBarName - The name of the component bar.
//
{
	string $currentComponentName = getCurrentUIComponent($componentBarName);

	toggleUIComponentVisibility($currentComponentName);
}

global proc createUIComponentBar(
	string $name, 
	string $position)
//
//	Description:
//		Create a UI component bar.
//
//		A UI component bar consists of buttons that correspond to UI 
//		components created with the createUIComponent() procedure.
//
//		Whenever a UI component is hidden (or collapsed) a button appears
//		on the component bar that will show the component when pressed.
//
//	Arguments:
//		name     - The component bar name
//
//		position - The position of the bar. Valid values are "top",
//		           "left", "bottom", and "right".
//
{
	global string $gUIComponentBarArray[];
	global int    $kNameIndex;
	global int    $kComponentCountIndex;
	global int    $kLayoutIndex;
	global int    $kPositionIndex;
	global int    $kCurrentIndex;
	global int    $kComponentBarElementSize;

	string $componentBarLayout, $openButton, $image;
	int    $count, $index;

	if ("" == $name) {
		error -showLineNumber true (uiRes("m_UIComponents.kArgError"));
		return;
	}

	//	Check if a component bar with the argument name already exists.
	//
	$count = size($gUIComponentBarArray);
	for ($index = 0; $index < $count; $index += $kComponentBarElementSize) {
		if ($name == $gUIComponentBarArray[$index + $kNameIndex]) {
			string $uniqueName = (uiRes("m_UIComponents.kArgumentUniqueError"));
			error -showLineNumber true (`format -s $name $uniqueName`);
			return;
		}
	}

	//	Validate the position argument.
	//
	if ("top" != $position && "bottom" != $position
		&& "left" != $position && "right" != $position) {
		string $invalidArgument = (uiRes("m_UIComponents.kInvalidArgument"));
		error -showLineNumber true (`format -s $position $invalidArgument`);
		return;
	}

	$gUIComponentBarArray[$count + $kNameIndex]           = $name;
	$gUIComponentBarArray[$count + $kComponentCountIndex] = 0;
	$gUIComponentBarArray[$count + $kLayoutIndex]         = "";
	$gUIComponentBarArray[$count + $kPositionIndex]       = $position;
	$gUIComponentBarArray[$count + $kCurrentIndex]        = "";
}

global proc removeUIComponentBar(string $name)
//
//	Description:
//		Remove all references to a UI component bar and its components.
//
//		Note that this procedure doesn't actually delete any controls or
//		layouts.
//
//	Arguments:
//		name - The component bar name.
//
{
	global string $gUIComponentBarArray[];
	global string $gUIComponentBarComponentArray[];

	global int    $kNameIndex;
	global int    $kParentIndex;
	global int    $kCallbackIndex;
	global int    $kComponentCountIndex;
	global int    $kLayoutIndex;
	global int    $kPositionIndex;
	global int    $kCurrentIndex;

	global int    $kComponentBarElementSize;
	global int    $kComponentElementSize;

	string $newComponentBarArray[], $newComponentArray[];
	int    $index, $newIndex, $start, $end, $count, $componentCount = -1;

	if ("" == $name) {
		error -showLineNumber true (uiRes("m_UIComponents.kArgError"));
		return;
	}

	//	Remove the components.
	//
	$start = 0;
	$count = size($gUIComponentBarArray);
	for ($index = 0; $index < $count; $index += $kComponentBarElementSize) {
		if ($name == $gUIComponentBarArray[$index + $kNameIndex]) {
			$componentCount = $gUIComponentBarArray[$index + $kComponentCountIndex];
			break;
		}
		$start += $gUIComponentBarArray[$index + $kComponentCountIndex];
	}

	if ($componentCount >= 0) {
		$end = $start + $componentCount;

		$newIndex = 0;
		$count = size($gUIComponentBarComponentArray);
		for ($index = 0; $index < $count; $index += $kComponentElementSize) {
			if ($index < ($start * $kComponentElementSize) 
				|| $index > ($end * $kComponentElementSize + 1)) {
				$newComponentArray[$newIndex + $kNameIndex] 
					= $gUIComponentBarComponentArray[$index + $kNameIndex];
				$newComponentArray[$newIndex + $kParentIndex] 
					= $gUIComponentBarComponentArray[$index + $kParentIndex];
				$newComponentArray[$newIndex + $kCallbackIndex] 
					= $gUIComponentBarComponentArray[$index + $kCallbackIndex];
				$newIndex += $kComponentElementSize;
			}
		}

		clear($gUIComponentBarComponentArray);
		$gUIComponentBarComponentArray = $newComponentArray;

	} else {
		string $warn = (uiRes("m_UIComponents.kComponentWarn"));
		warning -showLineNumber true (`format -s $name $warn`);
	}

	//	Remove the component bar.
	//
	$newIndex = 0;
	$count = size($gUIComponentBarArray);
	for ($index = 0; $index < $count; $index += $kComponentBarElementSize) {
		if ($name != $gUIComponentBarArray[$index + $kNameIndex]) {
			$newComponentBarArray[$newIndex + $kNameIndex]
				= $gUIComponentBarArray[$index + $kNameIndex];
			$newComponentBarArray[$newIndex + $kComponentCountIndex]
				= $gUIComponentBarArray[$index + $kComponentCountIndex];
			$newComponentBarArray[$newIndex + $kLayoutIndex]
				= $gUIComponentBarArray[$index + $kLayoutIndex];
			$newComponentBarArray[$newIndex + $kPositionIndex]
				= $gUIComponentBarArray[$index + $kPositionIndex];
			$newComponentBarArray[$newIndex + $kCurrentIndex]
				= $gUIComponentBarArray[$index + $kCurrentIndex];
			$newIndex += $kComponentBarElementSize;
		}
	}

	clear($gUIComponentBarArray);
	$gUIComponentBarArray = $newComponentBarArray;
}

global proc string createUIComponent(
	string $barName, 
	string $name, 
	string $parent)
//
//	Description:
//		Create a UI component.
//
//		A UI component consists of a control layout containing a button
//		for hiding (or collapsing) the entire component.
//
//		Whenever a UI component is hidden (or collapsed) a button appears
//		on the component bar that will show the component when pressed.
//
//	Arguments:
//		barName - The component bar name.
//
//		name - The component name.
//
//		parent - The parent layout for the UI component. Assumed to
//		         be a form layout.
//
//	Returns:
//		The name of the form layout for you to use as the parent of your
//		specific component UI.
//
{
	global string $gUIComponentBarArray[];
	global string $gUIComponentBarComponentArray[];

	global int    $kNameIndex;
	global int    $kParentIndex;
	global int    $kCallbackIndex;
	global int    $kComponentCountIndex;
	global int    $kPositionIndex;
	global int    $kCurrentIndex;
	global int    $kCloseButtonIndex;
	global int    $kComponentBarElementSize;

	string $result = "", $image, $layout, $layoutArray[];
	string $componentBar, $buttonArray[];
	string $hideButton, $showButton, $previousShowButton, $position;
	string $component, $componentArray[];

	int    $index, $count, $componentCount, $buttonCount;
	int    $componentBarIndex = -1;

	if ("" == $barName) {
		error -showLineNumber true (uiRes("m_UIComponents.kArgError"));
		return $result;
	}

	if ("" == $name) {
		error -showLineNumber true (uiRes("m_UIComponents.kArgError"));
		return $result;
	}

	string $requiredType = "formLayout";
	if ($requiredType != `objectTypeUI $parent`) {
		string $type = (uiRes("m_UIComponents.kArgumentError"));
		error -showLineNumber true (`format -s $requiredType $type`);
		return $result;
	}

 	//	Search the component bar array.
	//
	$count = size($gUIComponentBarArray);
	for ($index = 0; $index < $count; $index += $kComponentBarElementSize) {
		if ($barName == $gUIComponentBarArray[$index + $kNameIndex]) {
			$componentBarIndex = $index;
			break;
		}
	}

	//	Component bar not found. Return empty string.
	//
	if ($componentBarIndex < 0 ) {
		string $error = uiRes("m_UIComponents.kComponentWarn");
		error -showLineNumber true (`format -s $barName $error`);
		return $result;
	}

	//	Increment the number of components that the component bar
	//	now contains.
	//
	$componentCount = $gUIComponentBarArray[$componentBarIndex + $kComponentCountIndex];
	$componentCount ++;
	$gUIComponentBarArray[$componentBarIndex + $kComponentCountIndex] = $componentCount;

	$layout = `formLayout -parent $parent -manage false`;

	$position = $gUIComponentBarArray[$componentBarIndex + $kPositionIndex];

	string $hideAnnot = (uiRes("m_UIComponents.kHideAnnot"));
	string $displayName = localizedUIComponentLabel($name);
	
	if ("top" == $position || "bottom" == $position) {

		// ------------------------------------------------------------
		//
		//	 Vertical component bar.
		//
		// ------------------------------------------------------------

		//	Create the hide button.
		//
		string $hideAnnot1 = `format -s $displayName $hideAnnot`;
		$hideButton = `iconTextButton
			-image1 "verticalCloseBar.xpm" 
			-width  9
			-height 16
			-annotation ($hideAnnot1)
			-command ("toggleUIComponentVisibility \"" + $name + "\"")`;

		//	Create a layout for the specific UI to be added to the 
		//	component.
		//
		$result = `formLayout`;

		formLayout -edit
			-attachForm    $hideButton   "top"    0
			-attachForm    $hideButton   "left"   0
			-attachNone    $hideButton   "bottom"
			-attachNone    $hideButton   "right"

			-attachForm    $result       "top"    0
			-attachControl $result       "left"   0 $hideButton
			-attachForm    $result       "bottom" 0
			-attachForm    $result       "right"  0
			$layout;

	} else {

		// ------------------------------------------------------------
		//
		//	Horizontal component bar.
		//
		// ------------------------------------------------------------

		//	Create the hide button.
		//
		string $hideAnnot2 = `format -s $displayName $hideAnnot`;
		$hideButton = `iconTextButton
			-image1 "horizontalCloseBar.xpm" 
			-width  16
			-height 9
			-annotation ($hideAnnot2)
			-command ("toggleUIComponentVisibility \"" + $name + "\"")`;

		//	Create a layout for the specific UI to be added to the 
		//	component.
		//
		$result = `formLayout`;

		if ("left" == $position) {
			formLayout -edit
				-attachForm    $hideButton   "top"    0
				-attachForm    $hideButton   "left"   0
				-attachNone    $hideButton   "bottom"
				-attachNone    $hideButton   "right"
				$layout;

		} else {
				if(`about -mac`)
				{
					// force the iconTextButton for a left attachment with the formLayout
					formLayout -edit
					-attachForm    $hideButton   "top"    	0
					-attachForm    $hideButton   "left" 	2
					-attachNone    $hideButton   "bottom"
					-attachForm    $hideButton   "right"  	0
					$layout;
				}
				else
				{
					formLayout -edit
						-attachForm    $hideButton   "top"    0
						-attachNone    $hideButton   "left"
						-attachNone    $hideButton   "bottom"
						-attachForm    $hideButton   "right"  0
						$layout;
				}
		}

		formLayout -edit
			-attachControl $result       "top"    0 $hideButton
			-attachForm    $result       "left"   0
			-attachForm    $result       "bottom" 0
			-attachForm    $result       "right"  0
			$layout;

		if (1 == $componentCount) {
			//
			//	Make the first component the current one.
			//
			$gUIComponentBarArray[$componentBarIndex + $kCurrentIndex] = $name;

		} else {
			formLayout -edit -manage false $layout;
		}
	}

	formLayout -edit
		-attachForm    $layout       "top"    0
		-attachForm    $layout       "left"   0
		-attachForm    $layout       "bottom" 0
		-attachForm    $layout       "right"  0
		$parent;

	//	Add the new component to the component array.
	//
	$count = size($gUIComponentBarComponentArray);
	$gUIComponentBarComponentArray[$count + $kNameIndex] = $name;
	$gUIComponentBarComponentArray[$count + $kParentIndex] = $layout;
	$gUIComponentBarComponentArray[$count + $kCloseButtonIndex] = $hideButton;
	$gUIComponentBarComponentArray[$count + $kCallbackIndex] = "";

	return $result;
}

global proc string getUIComponent(string $name)
//
//	Description:
//		Return the layout corresponding to the given component name.
//
//		May return an empty string if the argument name does not refer
//		to a valid component. In this case this procedure will
//		generate an error.
//
//	Arguments:
//		name - The component name.
//
//	Returns:
//		The name of the component layout.
//
{
	global string $gUIComponentBarComponentArray[];

	global int    $kNameIndex;
	global int    $kParentIndex;
	global int    $kComponentElementSize;

	string $component = "";
	int    $index, $count;
	
	if ("" == $name) {
		error -showLineNumber true (uiRes("m_UIComponents.kArgError"));
		return $component;
	}

	//	Search the component array.
	//
	$count = size($gUIComponentBarComponentArray);
	for ($index = 0; $index < $count; $index += $kComponentElementSize) {
		if ($name == $gUIComponentBarComponentArray[$index + $kNameIndex]) {
			$component = $gUIComponentBarComponentArray[$index + $kParentIndex];
			break;
		}
	}

	if ("" == $component) {
		string $error = uiRes("m_UIComponents.kComponentError");
		error -showLineNumber true (`format -s $name $error`);
	}

	return $component;
}

global proc setUIComponentStateCallback(
	string $componentName,
	string $callback)
//
//	Description:
//		Specify the callback procedure for a component. This procedure will 
//		be called whenever the corresponding component is hidden or about
//		to be shown.
//
//		The callback procedure must have the following form:
//
//			global proc int procedureName(int $newState, string $layout) { ... }
//
//			Where the paramenters are:
//
//				newState - The new visible state of the component.
//
//				layout - The parent layout for the component content.
//
//			And the return value is:
//
//				true - If you want to allow the new state to take affect.
//
//				false - If you want to reject the new state.
//
//	Arguments:
//		componentName - The component bar name.
//
//		workArea - The layout corresponding to the work area.
//
{
	global string $gUIComponentToolBarArray[];
	global string $gUIComponentDockControlArray[];
	global string $gUIComponentBarComponentArray[];

	global int    $kNameIndex;
	global int    $kCallbackIndex;
	global int    $kComponentElementSize;

	int    $index, $count, $componentIndex = -1;

	if ("" == $componentName) {
		error -showLineNumber true (uiRes("m_UIComponents.kArgError"));
		return;
	}

	// Try tool bar first, don't report error
	$component = getUIComponentToolBar($componentName, false);
	if(size($component)) {
		string $cmd = $callback + "(`toolBar -q -visible " + $component + "`, \"\")";
		toolBar -e -visibleChangeCommand $cmd $component;
		return;
	}
	
	// Try dock control now, don't report error
	$component = getUIComponentDockControl($componentName, false);
	if(size($component)) {
		string $cmd = $callback + "(`dockControl -q -visible " + $component + "`, \"\")";
		dockControl -e -visibleChangeCommand $cmd $component;
		return;
	}
	
	//	Search the component array.
	//
	$count = size($gUIComponentBarComponentArray);
	for ($index = 0; $index < $count; $index += $kComponentElementSize) {
		if ($componentName == $gUIComponentBarComponentArray[$index + $kNameIndex]) {
			$componentIndex = $index;
			break;
		}
	}
		
	if ($componentIndex >= 0) {
		$gUIComponentBarComponentArray[$componentIndex + $kCallbackIndex] = $callback;

	} else {
		//	Component not found. Return.
		//
		string $error = uiRes("m_UIComponents.kComponentError");
		error -showLineNumber true (`format -s $componentName $error`);
		return;
	}
}

global proc setUIComponentWorkArea(
	string $name,
	string $workArea)
//
//	Description:
//		Specify the work area layout corresponding to a UI component bar layout.
//
//		To use UI components you must set up your window layout in a very 
//		specific way, ie. using form layouts. The work area refers to that
//		part of your window layout that is not allowed to be hidden.
//
//	Arguments:
//		name - The component bar name.
//
//		workArea - The layout corresponding to the work area.
//
{
	global string $gUIComponentBarArray[];

	global int    $kNameIndex;
	global int    $kLayoutIndex;
	global int    $kComponentBarElementSize;

	int    $index, $count, $componentBarIndex = -1;

	if ("" == $name) {
		error -showLineNumber true (uiRes("m_UIComponents.kArgError"));
		return;
	}

	//	Search the component bar array.
	//
	$count = size($gUIComponentBarArray);
	for ($index = 0; $index < $count; $index += $kComponentBarElementSize) {
		if ($name == $gUIComponentBarArray[$index + $kNameIndex]) {
			$componentBarIndex = $index;
			break;
		}
	}

	if ($componentBarIndex >= 0) {
		$gUIComponentBarArray[$componentBarIndex + $kLayoutIndex] = $workArea;

	} else {
		//	Component bar not found. Return.
		//
		string $error = uiRes("m_UIComponents.kComponentWarn");
		error -showLineNumber true (`format -s $name $error`);
		return;
	}
}

global proc setUIComponentVisibility(string $name, int $visible)
{
	int $isVisible = isUIComponentVisible($name);
	
	if ($visible != $isVisible)
	{
		toggleUIComponentVisibility($name);
	}
	
	return;
}

global proc int toggleUIComponentVisibility(string $name)
//
//	Description:
//		Toggle the visibility of the specified UI component.
//
//	Arguments:
//		name - The UI component name.
//
//	Returns:
//		True if the UI component is visible as a result of calling
//		this procedure. False otherwise.
//
{
	global string $gUIComponentToolBarArray[];
	global string $gUIComponentDockControlArray[];
	global string $gUIComponentBarArray[];

	string $component, $c, $componentArray[], $componentBar, $position;
	string $workArea = "", $children[], $callback, $contentLayout;
	int    $visible = false, $count, $numberOfVisibleComponents = 0;
	int    $proceed = true;

	if ("" == $name) {
		error -showLineNumber true (uiRes("m_UIComponents.kArgError"));
		return $visible;
	}

	// Try tool bar first, don't report error
	$component = getUIComponentToolBar($name, false);
	if(size($component)) {
		if(isUIComponentVisible($name)) {
			//
			// Hide
			//
			toolBar -edit -visible false $component;
			$visible = false;
		} else {
			//
			// Show
			//
			toolBar -edit -visible true $component;
			$visible = true;
		}
		
		return $visible;
	}
	
	// If we are trying to toggle a Channel Box/Layer Editor-related dock
	// widget that should not be accessed due to the current preference,
	// switch the preference and then toggle the intended dock widget.
	//
	if($name == "Channel Box / Layer Editor" && `optionVar -query channelsLayersSeparate`) {
		channelsLayersPrefChange(false);
		$visible = toggleUIComponentVisibility($name);
		return $visible;
	} else if(($name == "Channel Box" || $name == "Layer Editor") && !`optionVar -query channelsLayersSeparate`) {
		channelsLayersPrefChange(true);
		$visible = toggleUIComponentVisibility($name);
		return $visible;
	} else {	
		// Try dock control now, don't report error
		$component = getUIComponentDockControl($name, false);
		if(size($component)) {
			if(isUIComponentVisible($name)) {
				//
				// Hide
				//
				dockControl -edit -visible false $component;
				$visible = false;
			} else {
				//
				// Show
				//
				//
				// The "Channel Box / Layer Editor" dock widget should never 
				// coexist with the "Channel Box" and/or "Layer Editor" dock
				// widgets at the same time. If that is about to happen then
				// we should hide the offending editors before showing the 
				// new one.
				//
				string $conflictingEditors[] = {"Channel Box / Layer Editor",
				                                "Channel Box",
				                                "Layer Editor"};
				$conflictingEditors = stringArrayRemove({$name},
				                                        $conflictingEditors);

				for ($ed in $conflictingEditors) {
					// hide $ed if it is visible
					if (isUIComponentVisible($ed)) {
						string $edUI = getUIComponentDockControl($ed, false);
						if (size($edUI)) {
							if (startsWith($name, $ed) || startsWith($ed, $name)
								|| endsWith($name, $ed) || endsWith($ed, $name))
							{
								dockControl -edit -visible false $edUI;
							}
						}
					}
				}

				dockControl -edit -visible true $component;
				$visible = true;
			}

			return $visible;
		}
	}
	// Use old-style component
	$component = getUIComponent($name);
	$componentBar = getUIComponentBarFromComponent($name);
	$position = getUIComponentBarPosition($componentBar);

	//	If the work area layout is specified then unmanage it to improve draw
	//	performance. On linux you may see "jumping" of controls as a component is
	//	hidden or shown due to Motif's geometry negotiation. You are unlikely to 
	//	see this behaviour on NT but executing this code anyway is harmless.
	//
	$workArea = getWorkArea($componentBar);
	if ("" != $workArea) {
		layout -edit -manage false $workArea;
	}

	if (isUIComponentVisible($name)) {
		//
		//	Hide.
		//
		$callback = getCallback($name);
		if ("" != $callback) {
			$contentLayout = getUIComponentContentLayout($component);
			$proceed = eval ($callback + " false " + $contentLayout);
		} else {
			$proceed = true;
		}

		if ($proceed) {
			layout -edit -manage false $component;
			$visible = false;
		} else {
			$visible = true;
		}

	} else {
		//
		//	Show.
		//
		$callback = getCallback($name);
		if ("" != $callback) {
			$contentLayout = getUIComponentContentLayout($component);
			$proceed = eval ($callback + " true " + $contentLayout);
		} else {
			$proceed = true;
		}

		if (("left" == $position || "right" == $position) && $proceed) {
			$c = getCurrentUIComponent($componentBar);
			if ("" != $c && isUIComponentVisible($c)) {
				$callback = getCallback($c);
				$c = getUIComponent($c);
				layout -edit -manage false $c;

				if ("" != $callback) {
					$contentLayout = getUIComponentContentLayout($c);
					eval ($callback + " false " + $contentLayout);
				}
			}
		}

		if ($proceed) {
			layout -edit -manage true $component;
			setCurrentUIComponent($componentBar, $name);
			$visible = true;
		} else {
			$visible = false;
		}
	}

	//	If the work area was unmanaged above then re-manage it now.
	//
	if ("" != $workArea) {
		layout -edit -manage true $workArea;
	}

	return $visible;
}

global proc int isUIComponentVisible(string $name)
//
//	Description:
//		Return true if the specified UI component is visible.
//
//	Arguments:
//		name - The UI component name.
//
//	Returns:
//		True if the UI component is visible, false otherwise.
//
{
	int    $visible = false;

	if ("" == $name) {
		error -showLineNumber true (uiRes("m_UIComponents.kArgError"));
		return $visible;
	}

	// Try tool bar first, don't report error
	$component = getUIComponentToolBar($name, false);
	if(size($component) > 0) {
		$visible = `toolBar -q -visible $component`;
		return $visible;
	}
	
	// Try dock control now, don't report error
	$component = getUIComponentDockControl($name, false);
	if(size($component) > 0) {
		$visible = `dockControl -q -visible $component`;
		return $visible;
	}
	
	// Use old-style component
	$component = getUIComponent($name);
	
	$visible = `layout -query -manage $component`;

	return $visible;
}

global proc string getUIComponentCloseButton(string $name)
//
//	Description:
//		Return the close button corresponding to the given component name.
//
//		May return an empty string if the argument name does not refer
//		to a valid component. In this case this procedure will
//		generate an error.
//
//	Arguments:
//		name - The component name.
//
//	Returns:
//		The name of the close button.
//
{
	global string $gUIComponentBarComponentArray[];

	global int    $kNameIndex;
	global int    $kCloseButtonIndex;
	global int    $kComponentElementSize;

	string $closeButton = "";
	int    $index, $count;
	
	if ("" == $name) {
		error -showLineNumber true (uiRes("m_UIComponents.kArgError"));
		return $closeButton;
	}

	//	Search the component array.
	//
	$count = size($gUIComponentBarComponentArray);
	for ($index = 0; $index < $count; $index += $kComponentElementSize) {
		if ($name == $gUIComponentBarComponentArray[$index + $kNameIndex]) {
			$closeButton = $gUIComponentBarComponentArray[$index + $kCloseButtonIndex];
			break;
		}
	}

	if ("" == $closeButton) {
		string $error = uiRes("m_UIComponents.kComponentError");
		error -showLineNumber true (`format -s $name $error`);
	}

	return $closeButton;
}

global proc int UIComponentExists(string $name)
//
//	Description:
//		Return true if the specified component exists.
//
//	Arguments:
//		name - The component name.
//
//	Returns:
//		True if the component exists, false otherwise.
//
{
	global string $gUIComponentToolBarArray[];
	global string $gUIComponentDockControlArray[];
	global string $gUIComponentBarComponentArray[];

	global int    $kNameIndex;
	global int    $kToolBarElementSize;
	global int    $kDockControlElementSize;
	global int    $kComponentElementSize;

	int    $index, $count;
	
	if ("" == $name) {
		error -showLineNumber true (uiRes("m_UIComponents.kArgError"));
		return false;
	}

	// Search the toolbar array.
	//
	$count = size($gUIComponentToolBarArray);
	for ($index = 0; $index < $count; $index += $kToolBarElementSize) {
		if ($name == $gUIComponentToolBarArray[$index + $kNameIndex]) {
			return true;
		}
	}
	
	// Search the dock control array.
	//
	$count = size($gUIComponentDockControlArray);
	for ($index = 0; $index < $count; $index += $kDockControlElementSize) {
		if ($name == $gUIComponentDockControlArray[$index + $kNameIndex]) {
			return true;
		}
	}
	
	//	Search the old-style component array.
	//
	$count = size($gUIComponentBarComponentArray);
	for ($index = 0; $index < $count; $index += $kComponentElementSize) {
		if ($name == $gUIComponentBarComponentArray[$index + $kNameIndex]) {
			return true;
		}
	}

	// If we got here, component was no found
	return false;
}

//	Note that the following script block is not a procedure and will be
//	executed when this script file is sourced.
//
{
	//	Define the array indecies.
	//
	global int    $kNameIndex                = 0;
	global int    $kControlIndex             = 1;
	global int    $kComponentCountIndex      = 2;
	global int    $kCallbackIndex			 = 2;
	global int    $kLayoutIndex              = 3;
	global int    $kCloseButtonIndex         = 3;
	global int    $kParentIndex              = 1;
	global int    $kPositionIndex            = 4;
	global int    $kCurrentIndex             = 5;

	//	Define the array element sizes.
	//
	global int    $kToolBarElementSize       = 2; // tool bars
	global int    $kDockControlElementSize   = 2; // dock controls 
	global int    $kComponentBarElementSize  = 6; // old-style component bars
	global int    $kComponentElementSize     = 4; // old-style components

	//	Preference variable defining the global visibility of
	//	component bars.
	//
	if (!`optionVar -exists globalVisibilityOfComponentBars`) {
		//
		//	Create preference along with default value because it
		//	doesn't exist yet.
		//
		optionVar -intValue globalVisibilityOfComponentBars true;
	}
}

global proc printUIComponentBarInfo()
//
//	Description:
//		Helpful debugging procedure. Print out the contents of the component
//		arrays.
//
{
	global string $gUIComponentBarArray[];
	global string $gUIComponentBarComponentArray[];

	global int    $kNameIndex;
	global int    $kParentIndex;
	global int    $kCallbackIndex;
	global int    $kComponentCountIndex;
	global int    $kLayoutIndex;
	global int    $kPositionIndex;
	global int    $kCurrentIndex;
	global int    $kCloseButtonIndex;

	global int    $kComponentBarElementSize;
	global int    $kComponentElementSize;

	int $index, $count;

	$count = size($gUIComponentBarArray);
	print  ("DEBUG: Number of component bars = " + $count / $kComponentBarElementSize + "\n");
	for ($index = 0; $index < $count; $index += $kComponentBarElementSize) {
		print  ("DEBUG: Name:       " + $gUIComponentBarArray[$index + $kNameIndex] + "\n");
		print  ("DEBUG: Components: " + $gUIComponentBarArray[$index + $kComponentCountIndex] + "\n");
		print  ("DEBUG: Work Area:  " + $gUIComponentBarArray[$index + $kLayoutIndex] + "\n");
		print  ("DEBUG: Position:   " + $gUIComponentBarArray[$index + $kPositionIndex] + "\n");
		print  ("DEBUG: Current:    " + $gUIComponentBarArray[$index + $kCurrentIndex] + "\n\n");
	}

	$count = size($gUIComponentBarComponentArray);
	print  ("DEBUG: Number of components = " + $count / $kComponentElementSize + "\n");
	for ($index = 0; $index < $count; $index += $kComponentElementSize) {
		print  ("DEBUG: " + $gUIComponentBarComponentArray[$index + $kNameIndex] + "\t\t"
			+ $gUIComponentBarComponentArray[$index + $kCallbackIndex] + "\t\t("
			+ $gUIComponentBarComponentArray[$index + $kParentIndex] + "\t\t("
			+ $gUIComponentBarComponentArray[$index + $kCloseButtonIndex] + ")\n");

	}
}

global proc updateEditorToggleCheckboxes()
{
	global string $gAttributeEditorButton;
	global string $gToolSettingsButton;
	global string $gChannelsOrChannelsLayersButton;
	global string $gLayerEditorButton;
	global int    $gAEDeferredUpdate;
	
	if(`iconTextCheckBox -exists $gAttributeEditorButton`) {
		int $atEdVisible = `isUIComponentVisible("Attribute Editor")`;
		iconTextCheckBox -e -value $atEdVisible $gAttributeEditorButton;
		if( $atEdVisible && $gAEDeferredUpdate ){
			// Update the Attribute Editor with the deferred node
			// See bug #346864 and note in autoUpdateAttrEd (in showEditor.mel)
			// See bug #384393 AE doesn't refresh object name properly
			//
			string $selectedNode ="";
			string $nodes[] = `selectedNodes`;
			int $count = size($nodes);
			if($count > 0){
				$selectedNode = $nodes[$count -1];
			}
			updateAE( $selectedNode );
			$gAEDeferredUpdate = false;
		}
		iconTextCheckBox -e -value `isUIComponentVisible("Tool Settings")` $gToolSettingsButton;
		
		if(`optionVar -q channelsLayersSeparate`) {
			iconTextCheckBox -e -value `isUIComponentVisible("Channel Box")` $gChannelsOrChannelsLayersButton;
			iconTextCheckBox -e -value `isUIComponentVisible("Layer Editor")` $gLayerEditorButton;
		} else {
			iconTextCheckBox -e -value `isUIComponentVisible("Channel Box / Layer Editor")` $gChannelsOrChannelsLayersButton;
		}
	}
}
