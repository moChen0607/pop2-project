// Copyright (C) 1997-2014 Autodesk, Inc., and/or its licensors.
// All rights reserved.
//
// The coded instructions, statements, computer programs, and/or related
// material (collectively the "Data") in these files contain unpublished
// information proprietary to Autodesk, Inc. ("Autodesk") and/or its licensors,
// which is protected by U.S. and Canadian federal copyright law and by
// international treaties.
//
// The Data is provided for use exclusively by You. You have the right to use,
// modify, and incorporate this Data into other products for purposes authorized 
// by the Autodesk software license agreement, without fee.
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND. AUTODESK
// DOES NOT MAKE AND HEREBY DISCLAIMS ANY EXPRESS OR IMPLIED WARRANTIES
// INCLUDING, BUT NOT LIMITED TO, THE WARRANTIES OF NON-INFRINGEMENT,
// MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE, OR ARISING FROM A COURSE 
// OF DEALING, USAGE, OR TRADE PRACTICE. IN NO EVENT WILL AUTODESK AND/OR ITS
// LICENSORS BE LIABLE FOR ANY LOST REVENUES, DATA, OR PROFITS, OR SPECIAL,
// DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES, EVEN IF AUTODESK AND/OR ITS
// LICENSORS HAS BEEN ADVISED OF THE POSSIBILITY OR PROBABILITY OF SUCH DAMAGES.

//
//  Procedure Name:
//      getValuesForCommand
//
//  Description:
//		If nothing is entered in a textField on the statusLine, then the 
//		field should be ignored. Given the values of each field, this
//		function generates a string with a flag that will cause the move,
//		scale or rotate commands to ignore the appropriate values, followed
//		by the values. This string can be appended to the end of the 
//		respective command.
//
//  Return Value:
//      string = A string that can be appended to a move, scale or rotate command
//	         to cause it to ignore blank values for $x, $y, or $z, followed
//	         by the values.
//
proc string getValuesForCommand(string $x, string $y, string $z, int $movePivot, string $curTool, string $mode)
{
	// Generate the flag to ignore blank values. Blank values should
	// not be included.
	string $result = "";

	if (!$movePivot)
	{
		if($x != "")
		{
		$result += "-x " + $x + " ";
		}
		if($y != "")
		{
		$result += "-y " + $y + " ";
		}
		if($z != "")
		{
		$result += "-z " + $z + " ";
		}
	}
	else
	{
		float $pivotLocation[];
		if ($curTool == "Rotate")
		{
			$pivotLocation = `manipRotateContext -q -editPivotPosition Rotate`;
		}
		else if ($curTool == "Scale")
		{
			$pivotLocation = `manipScaleContext -q -editPivotPosition Scale`;
		}
		else
		{
			$pivotLocation = `manipMoveContext -q -editPivotPosition Move`;
		}

		if($x != "")
		{
			$result += "-x " + $x + " ";
		}
		else if ($mode == "rel")
		{
			$result += "-x 0 ";
		}
		else
		{
			$result += "-x " + $pivotLocation[0] + " ";
		}

		if($y != "")
		{
			$result += "-y " + $y + " ";
		}
		else if ($mode == "rel")
		{
			$result += "-y 0 ";
		}
		else
		{
			$result += "-y " + $pivotLocation[1] + " ";
		}

		if($z != "")
		{
			$result += "-z " + $z + " ";
		}
		else if ($mode == "rel")
		{
			$result += "-z 0 ";
		}
		else
		{
			$result += "-z " + $pivotLocation[2] + " ";
		}
	}

	return $result;
}

//
//  Procedure Name:
//      getPivotsString
//
//  Description:
//		returns a string with the scalePivot and rotatePivot calls for current selection
//
//  Return Value:
//      string with correct rotate and scale pivot object tags
//
proc string getPivotsString(){
	
	string $ret = "";
	string $sel[] = `ls -sl -o`;
	
	int $length = size($sel);
	int $i = 0;
	for ($i = 0; $i < $length; $i++){
		$ret += $sel[$i] + ".scalePivot " + $sel[$i] + ".rotatePivot ";
	}
	
	return $ret;
}


proc int localContextTransform(string $mode, string $x, string $y, string $z)
{
	// Create input string using "." to ignore an empty field
	//
	string $input = "";
	if ($mode == "rel"){
		$input += "-r ";
	}else{
		$input += "-a ";
	}
	
	//use quiet mode
	$input += "-q ";
	
	//Pass in values
	$input += ($x == "") ? ". " : $x + " ";
	$input += ($y == "") ? ". " : $y + " ";
	$input += ($z == "") ? "." : $z;

	return `numericalInput($input)`;
}


global proc superContextTransform(string $mode, string $curTool, string $x, string $y, string $z)
{
	int $pivotMove = `manipMoveContext -q -editPivotMode Move`;
		
	if($curTool == "Rotate"){
		$pivotMove = `manipRotateContext -q -editPivotMode Rotate`;
	} else if ($curTool == "Scale"){
		$pivotMove = `manipScaleContext -q -editPivotMode Scale`;
	}
	
	string $validObjs[] = `filterExpand -sm 12 -sm 9 -sm 10`;
	
	if (!(size($validObjs) > 0)){
		$pivotMove = 0;
	}
	
	// $cmd is generated by the code that follows and is later evaluated.
	string $cmd = "";

	if($curTool == "Rotate" && $pivotMove == 0)
	{
		$cmd = "rotate ";
	}
	else if($curTool == "Scale" && $pivotMove == 0)
	{
		$cmd = "scale ";
	}
	else if($curTool == "Move" || $pivotMove == 1)
	{
		$cmd = "move ";
	}

	// Use relative or absolute?
	if($mode == "rel")
	{
		$cmd += "-r ";
	}
	else if ($mode == "abs" && $curTool == "Move")
	{
		$cmd += "-rotatePivotRelative ";
	}
	
	//Get the reflection options
	if(`symmetricModelling -q -symmetry`){
		$cmd += "-rfl ";
		if(`symmetricModelling -q -axis` == "x"){
			$cmd += "-rax ";
		}else if(`symmetricModelling -q -axis` == "y"){
			$cmd += "-ray ";
		}else if(`symmetricModelling -q -axis` == "z"){
			$cmd += "-raz ";
		}
		
		if (`symmetricModelling -q -about` == "origin"){
			$cmd += "-rao ";
		} else if (`symmetricModelling -q -about` == "boundingBox"){
			$cmd += "-rab ";
		}
		
		$cmd += "-rft ";
		
		$cmd += `symmetricModelling -q -tolerance`;
	}	


	$cmd += getValuesForCommand($x,$y,$z, $pivotMove, $curTool, $mode);

	if ($pivotMove){
		$cmd += getPivotsString();		
	}
	
	catch(`eval($cmd)`);

}

global proc setTransformCoordMT(string $x, string $y, string $z)
{
	global string $gtransformCoordMT[];
	$gtransformCoordMT[0] = $x;
	$gtransformCoordMT[1] = $y;
	$gtransformCoordMT[2] = $z;
}

//
//  Procedure Name:
//      numericalInputChangeCommand
//
//  Description:
//		Handles a change in the numerical input fields.  The values are
//		applied and keyboard focus is returned to the main view panes.
//
//  Input Arguments:
//      $mode = abs or rel
//
//  Return Value:
//      None
//
global proc numericalInputChangeCommand(string $mode)
{

	global string $gNumericalInputXField;
	global string $gNumericalInputYField;
	global string $gNumericalInputZField;
	
	// Append the values of the text fields.
	string $x = `textField -query -text $gNumericalInputXField`;
	string $y = `textField -query -text $gNumericalInputYField`;
	string $z = `textField -query -text $gNumericalInputZField`;

	//MT does not have access to the above text fields from drInit.mel
	//A global string array can then store the values of the text fields and then can be accessed from dR_numericalInputChangeCommand from drInit.mel
	//Also handles empty inputs in the text field to keep consistant with Maya's transformation feature (when MT is off)
	setTransformCoordMT($x, $y, $z);
	
	// Select an operation based on the currently selected tool. The default
	// behaviour is to move.
	string $curContext = `currentCtx`;
	if (`superCtx -exists $curContext`)
		$curTool = `superCtx -q $curContext`;
	else
		$curTool = $curContext;
	
	
	// Transform object according to the current tool context.  If the object is to be translated, rotated, or scaled,
	// We use logic defined in superContextTransform.  Otherwise, we call localContextTransform which attempts
	// to use the 'scmh' command to transform an object in a panel context (ie. Grapher Editor key or UV Texture editor UV).
	// If scmh fails, we default to translate.
	
	if ($curTool == "Move" || $curTool == "Rotate" || $curTool == "Scale"){
		superContextTransform($mode, $curTool,$x, $y, $z);
	}
	else if( !(localContextTransform($mode, $x, $y, $z))){
		superContextTransform($mode, "Move", $x, $y, $z);
	}
	
	//	Clear the input field.
	//
	statusLineUpdateInputField();
}

