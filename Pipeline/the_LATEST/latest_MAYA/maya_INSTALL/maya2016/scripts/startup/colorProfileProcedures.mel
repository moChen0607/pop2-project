// Copyright (C) 1997-2014 Autodesk, Inc., and/or its licensors.
// All rights reserved.
//
// The coded instructions, statements, computer programs, and/or related
// material (collectively the "Data") in these files contain unpublished
// information proprietary to Autodesk, Inc. ("Autodesk") and/or its licensors,
// which is protected by U.S. and Canadian federal copyright law and by
// international treaties.
//
// The Data is provided for use exclusively by You. You have the right to use,
// modify, and incorporate this Data into other products for purposes authorized 
// by the Autodesk software license agreement, without fee.
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND. AUTODESK
// DOES NOT MAKE AND HEREBY DISCLAIMS ANY EXPRESS OR IMPLIED WARRANTIES
// INCLUDING, BUT NOT LIMITED TO, THE WARRANTIES OF NON-INFRINGEMENT,
// MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE, OR ARISING FROM A COURSE 
// OF DEALING, USAGE, OR TRADE PRACTICE. IN NO EVENT WILL AUTODESK AND/OR ITS
// LICENSORS BE LIABLE FOR ANY LOST REVENUES, DATA, OR PROFITS, OR SPECIAL,
// DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES, EVEN IF AUTODESK AND/OR ITS
// LICENSORS HAS BEEN ADVISED OF THE POSSIBILITY OR PROBABILITY OF SUCH DAMAGES.

//  Creation Date:  Mar 16, 2009
//
//  Description:
//  Some utility functions for adding color profile entries to various AETemplates.


// define the names of the built-in color profiles in one place
proc colorProfileMenuItemNames(){
    string $placeholder;
    $placeholder = (uiRes("m_colorProfileProcedures.kColorProfileUseRender"));
    $placeholder = (uiRes("m_colorProfileProcedures.kColorProfileDefault"));
    $placeholder = (uiRes("m_colorProfileProcedures.kColorProfileDefaultInput"));
    $placeholder = (uiRes("m_colorProfileProcedures.kColorProfileDefaultOutput"));
    $placeholder = (uiRes("m_colorProfileProcedures.kColorProfileSRGB"));
    $placeholder = (uiRes("m_colorProfileProcedures.kColorProfileHDTV"));
    $placeholder = (uiRes("m_colorProfileProcedures.kColorProfileSRGBg"));
    $placeholder = (uiRes("m_colorProfileProcedures.kColorProfileRec709"));
    $placeholder = (uiRes("m_colorProfileProcedures.kColorProfileNTSC"));
    $placeholder = (uiRes("m_colorProfileProcedures.kColorProfileSharpRGB"));
    $placeholder = (uiRes("m_colorProfileProcedures.kColorProfileLineRGB"));
    $placeholder = (uiRes("m_colorProfileProcedures.kColorProfileBoxRGB"));
    $placeholder = (uiRes("m_colorProfileProcedures.kColorProfileCIEXYZ"));
    $placeholder = (uiRes("m_colorProfileProcedures.kColorProfileCIELab"));
    $placeholder = (uiRes("m_colorProfileProcedures.kColorProfileCIELuv"));
    $placeholder = (uiRes("m_colorProfileProcedures.kColorProfileSimpleCMY"));
    $placeholder = (uiRes("m_colorProfileProcedures.kColorProfileSimpleCMYK"));
}

global proc string[] colorProfileBuiltInRenderProfileSettingsMenuItemList(){
    string $menuItems[];
    int $current = 0;
    
	$menuItems[$current++] = uiRes("m_colorProfileProcedures.kColorProfileSRGB");
	$menuItems[$current++] = uiRes("m_colorProfileProcedures.kColorProfileNTSC");
	$menuItems[$current++] = uiRes("m_colorProfileProcedures.kColorProfileBoxRGB");
	$menuItems[$current++] = uiRes("m_colorProfileProcedures.kColorProfileLineRGB");
    $menuItems[$current++] = uiRes("m_colorProfileProcedures.kColorProfileSharpRGB");
    
    return $menuItems;
}

global proc string[] colorProfileBuiltInInputProfileSettingsMenuItemList(){
    string $menuItems[];
    int $current = 0;
    
	$menuItems[$current++] = uiRes("m_colorProfileProcedures.kColorProfileSRGB");
	$menuItems[$current++] = uiRes("m_colorProfileProcedures.kColorProfileSRGBg");
	$menuItems[$current++] = uiRes("m_colorProfileProcedures.kColorProfileHDTV");
    $menuItems[$current++] = uiRes("m_colorProfileProcedures.kColorProfileRec709");

    return $menuItems;
}

global proc string[] colorProfileBuiltInOutputProfileSettingsMenuItemList(){
    string $menuItems[];
    int $current = 0;
    
	$menuItems[$current++] = uiRes("m_colorProfileProcedures.kColorProfileSRGB");
	$menuItems[$current++] = uiRes("m_colorProfileProcedures.kColorProfileSRGBg");
	$menuItems[$current++] = uiRes("m_colorProfileProcedures.kColorProfileHDTV");
    $menuItems[$current++] = uiRes("m_colorProfileProcedures.kColorProfileRec709");
	$menuItems[$current++] = uiRes("m_colorProfileProcedures.kColorProfileCIEXYZ");
    
    return $menuItems;
}

global proc string[] colorProfileBuiltInRenderMenuItemList(){
    string $menuItems[];
    int $current = 0;
    
    $menuItems[$current++] = uiRes("m_colorProfileProcedures.kColorProfileDefault");
	$menuItems[$current++] = uiRes("m_colorProfileProcedures.kColorProfileSRGB");
	$menuItems[$current++] = uiRes("m_colorProfileProcedures.kColorProfileNTSC");
	$menuItems[$current++] = uiRes("m_colorProfileProcedures.kColorProfileBoxRGB");
	$menuItems[$current++] = uiRes("m_colorProfileProcedures.kColorProfileLineRGB");
	$menuItems[$current++] = uiRes("m_colorProfileProcedures.kColorProfileSharpRGB");
    
    return $menuItems;
}

global proc string[] colorProfileBuiltInInputMenuItemList(){
    string $menuItems[];
    int $current = 0;
    
    $menuItems[$current++] = uiRes("m_colorProfileProcedures.kColorProfileDefaultInput");
	$menuItems[$current++] = uiRes("m_colorProfileProcedures.kColorProfileSRGB");
	$menuItems[$current++] = uiRes("m_colorProfileProcedures.kColorProfileSRGBg");
	$menuItems[$current++] = uiRes("m_colorProfileProcedures.kColorProfileHDTV");
	$menuItems[$current++] = uiRes("m_colorProfileProcedures.kColorProfileRec709");
    
    return $menuItems;
}

global proc string[] colorProfileBuiltInOutputMenuItemList(){
    string $menuItems[];
    int $current = 0;
    
    $menuItems[$current++] = uiRes("m_colorProfileProcedures.kColorProfileDefaultOutput");
	$menuItems[$current++] = uiRes("m_colorProfileProcedures.kColorProfileSRGB");
	$menuItems[$current++] = uiRes("m_colorProfileProcedures.kColorProfileSRGBg");
	$menuItems[$current++] = uiRes("m_colorProfileProcedures.kColorProfileHDTV");
	$menuItems[$current++] = uiRes("m_colorProfileProcedures.kColorProfileRec709");
	$menuItems[$current++] = uiRes("m_colorProfileProcedures.kColorProfileCIEXYZ");
    
    return $menuItems;
}

// the first item in the list can differ depending on whether it is in an AE attached
// to a node, or whether it is in the render settings window
global proc int colorProfileNodeMenuItemStringToInt(string $colorProfileString){
    if ($colorProfileString == uiRes("m_colorProfileProcedures.kColorProfileDefault"))
        return 0;
    else if ($colorProfileString == uiRes("m_colorProfileProcedures.kColorProfileDefaultInput"))
        return 0;
    else if ($colorProfileString == uiRes("m_colorProfileProcedures.kColorProfileDefaultOutput"))
        return 0;
    else
        return colorProfileSettingsMenuItemStringToInt($colorProfileString);
}

global proc int colorProfileSettingsMenuItemStringToInt(string $colorProfileString){
    if ($colorProfileString == uiRes("m_colorProfileProcedures.kColorProfileUseRender"))
        return 0;
    // 1 is intentionally skipped since it is a user-defined type
    else if ($colorProfileString == uiRes("m_colorProfileProcedures.kColorProfileSRGB"))
        return 2;
    else if ($colorProfileString == uiRes("m_colorProfileProcedures.kColorProfileSRGBg"))
        return 3;
    else if ($colorProfileString == uiRes("m_colorProfileProcedures.kColorProfileHDTV"))
        return 4;
    else if ($colorProfileString == uiRes("m_colorProfileProcedures.kColorProfileRec709"))
        return 5;
    else if ($colorProfileString == uiRes("m_colorProfileProcedures.kColorProfileNTSC"))
        return 6;
    else if ($colorProfileString == uiRes("m_colorProfileProcedures.kColorProfileBoxRGB"))
        return 7;
    else if ($colorProfileString == uiRes("m_colorProfileProcedures.kColorProfileLineRGB"))
        return 8;
    else if ($colorProfileString == uiRes("m_colorProfileProcedures.kColorProfileSharpRGB"))
        return 9;
    else if ($colorProfileString == uiRes("m_colorProfileProcedures.kColorProfileCIEXYZ"))
        return 10;
    else if ($colorProfileString == uiRes("m_colorProfileProcedures.kColorProfileCIELab"))
        return 11;
    else if ($colorProfileString == uiRes("m_colorProfileProcedures.kColorProfileCIELuv"))
        return 12;
    else if ($colorProfileString == uiRes("m_colorProfileProcedures.kColorProfileSimpleCMY"))
        return 13;
    else if ($colorProfileString == uiRes("m_colorProfileProcedures.kColorProfileSimpleCMYK"))
        return 14;
    else
        return -1; // string was not found - other functions depend on this
}

// the first item in the list can differ depending on whether it is in an AE attached
// to a node, or whether it is in the render settings window
global proc string colorProfileNodeMenuItemIntToString(int $colorProfileType, string $colorProfileNodeType){
    if (($colorProfileType == 0) && ($colorProfileNodeType == ""))
        return uiRes("m_colorProfileProcedures.kColorProfileDefault");
    if (($colorProfileType == 0) && ($colorProfileNodeType == "input"))
        return uiRes("m_colorProfileProcedures.kColorProfileDefaultInput");
    if (($colorProfileType == 0) && ($colorProfileNodeType == "output"))
        return uiRes("m_colorProfileProcedures.kColorProfileDefaultOutput");
    else
        return colorProfileSettingsMenuItemIntToString($colorProfileType);
}

global proc string colorProfileSettingsMenuItemIntToString(int $colorProfileType){
    switch ($colorProfileType){
    case 0:
        return uiRes("m_colorProfileProcedures.kColorProfileUseRender");
    case 2:
        return uiRes("m_colorProfileProcedures.kColorProfileSRGB");
    case 3:
        return uiRes("m_colorProfileProcedures.kColorProfileSRGBg");
    case 4:
        return uiRes("m_colorProfileProcedures.kColorProfileHDTV");
    case 5:
        return uiRes("m_colorProfileProcedures.kColorProfileRec709");
    case 6:
        return uiRes("m_colorProfileProcedures.kColorProfileNTSC");
    case 7:
        return uiRes("m_colorProfileProcedures.kColorProfileBoxRGB");
    case 8:
        return uiRes("m_colorProfileProcedures.kColorProfileLineRGB");
    case 9:
        return uiRes("m_colorProfileProcedures.kColorProfileSharpRGB");
    case 10:
        return uiRes("m_colorProfileProcedures.kColorProfileCIEXYZ");
    case 11:
        return uiRes("m_colorProfileProcedures.kColorProfileCIELab");
    case 12:
        return uiRes("m_colorProfileProcedures.kColorProfileCIELuv");
    case 13:
        return uiRes("m_colorProfileProcedures.kColorProfileSimpleCMY");
    case 14:
        return uiRes("m_colorProfileProcedures.kColorProfileSimpleCMYK");
    default:
        return "";
    }
}

// Callback used to set the attribute "colorProfileType"
// This procedure takes care of breaking and creating connections as necessary.
global proc setColorProfileTypeAttrCB(string $menu, string $colorProfileTypeAttr)
{
	// get the node name
    string $buffer[];
    tokenize($colorProfileTypeAttr, ".|", $buffer);
    string $nodeName = $buffer[0];

    string $selectedItemValue = `optionMenu -query -value $menu`;
    int $selectedItemProfileType = colorProfileNodeMenuItemStringToInt($selectedItemValue);
	if ($selectedItemProfileType != -1){
		// changing to a built-in type
		// if we're currently connected to a color profile node, break the connection before setting the value
		string $connectedNodeNames[] = `listConnections -type colorProfile $nodeName`;
		string $connectedNodeName = $connectedNodeNames[0];
		if (size($connectedNodeName)){
			// delete the connection
			string $cmd = "disconnectAttr " + $connectedNodeName + ".colorProfileType" + " " + $colorProfileTypeAttr;
			evalEcho($cmd);
		}
        string $cmd = "setAttr " + $colorProfileTypeAttr + " " + $selectedItemProfileType;
		evalEcho($cmd);
	}
	else {
		// changing to an existing color profile node
		// create a connection to the new node
		if (size($selectedItemValue)){
            // create a new connection
            $cmd = "connectAttr -f " + $selectedItemValue + ".colorProfileType" + " " + $colorProfileTypeAttr;
		}
	}
}

// Procedure to update the contents of the option menu containing the color profile built-ins, and
// the color profile nodes which are part of the scene.
global proc updateColorProfileMenu(string $menu, string $colorProfileTypeAttr)
{   
	// get the node name
    string $buffer[];
    tokenize($colorProfileTypeAttr,".|",$buffer);
    
    if(`attributeExists $buffer[1] $buffer[0]` == 0)
        return;
    string $nodeName = $buffer[0];
	
	// is this attribute connected to a color profile node?
	string $connectedNodeNames[] = `listConnections -type colorProfile $nodeName`;
	string $connectedNodeName = $connectedNodeNames[0];
	int $connected = 0;
	int $colorProfileType = 0;
	if (size($connectedNodeName)){
		// we are connected to a color profile
	    $connected = 1;
	}
	else{
		// we are not connected to a color profile
		// get the attribute value
		$colorProfileType = `getAttr $colorProfileTypeAttr`;
	}

    setParent -m $menu;
    string $menuItems[] = `optionMenu -q -ils $menu`;
    int $existingNumberOfMenuItems = size($menuItems);
    // if there are any menu items, then there must be a list of the built-ins
    // only add the built-ins if this is the first time the menu is being created
    string $builtInColorProfiles[];
    string $colorProfileNodeType = colorProfileEnabledNodeType($nodeName);
    if ($colorProfileNodeType == "input"){
        $builtInColorProfiles = colorProfileBuiltInInputMenuItemList();
    }
    else if ($colorProfileNodeType == "output"){
        $builtInColorProfiles = colorProfileBuiltInOutputMenuItemList();
    }
    else{
        $builtInColorProfiles = colorProfileBuiltInRenderMenuItemList();
    }
    if ($existingNumberOfMenuItems == 0) {
        // add the built-in color profiles
        for ($i = 0; $i < size($builtInColorProfiles); $i++){
            menuItem -label $builtInColorProfiles[$i];
        }
    }
    
    // delete any remaining menu items since we can only add the menuItem divider in create mode
    for ($i = size($builtInColorProfiles); $i < $existingNumberOfMenuItems; $i++){
      deleteUI -mi $menuItems[$i];
    }
    
    // add the existing color profiles
    string $colorProfileNodes[] = `ls -type "colorProfile"`;
    // add the separator (only if there are colorProfile nodes in the scene)
    if (size($colorProfileNodes)){
      menuItem -divider true;
    }
    for ($name in $colorProfileNodes){
        menuItem -label $name;
    }

    setParent -m ..;
    	
	// make sure the correct item is selected
	if (!$connected){
      string $colorProfileTypeName = colorProfileNodeMenuItemIntToString($colorProfileType, $colorProfileNodeType);
		optionMenu -edit -value $colorProfileTypeName $menu;
	}
	else{
		optionMenu -edit -value $connectedNodeName $menu;
	}
	//set the width for optionMenu 
	global int $kSingleWidgetWidthIndex;
	int $optionMenuWidth = 3 * $kSingleWidgetWidthIndex;
	optionMenu -e -width $optionMenuWidth $menu;
}

// Callback to create a new color profile, and connect it to the current node.
// Handles breaking the existing connection if there is one.
global proc createColorProfileCB(string $colorProfileTypeAttr){
    // get the nodeName
    string $buffer[];
    tokenize($colorProfileTypeAttr,".|",$buffer);
    string $nodeName = $buffer[0];
	
	// break the connection if one exists
	string $connectedNodeNames[] = `listConnections -type colorProfile $nodeName`;
	string $connectedNodeName = $connectedNodeNames[0];
	if (size($connectedNodeName)){
		// delete the connection
		string $cmd = "disconnectAttr " + $connectedNodeName + ".colorProfileType" + " " + $colorProfileTypeAttr;
		evalEcho($cmd);
	}	
	// create a new color profile node
	string $cmd = "shadingNode -asUtility colorProfile";
	string $newNode = evalEcho($cmd);
	// connect it
	$cmd = "connectAttr " + $newNode + ".colorProfileType " + $nodeName + ".colorProfile";
	evalEcho($cmd);
}

global proc AEcolorProfileNew(string $colorProfileTypeAttr)
{
	rowLayout -nc 3 colorProfileRowLayout;

		text -l (uiRes("m_colorProfileProcedures.kColorProfileLabel")) colorProfileMenuText;
		string $menu = `optionMenu -l "" colorProfileMenu`;

		// update optionMenu
		updateColorProfileMenu($menu, $colorProfileTypeAttr);
		// set up the call back
		optionMenu -e -cc ("setColorProfileTypeAttrCB " + $menu + " " + $colorProfileTypeAttr) $menu;
        setParent -m ..;
		
		// add the create button
        symbolButton -image "colorProfile.png"
			-ann (uiRes("m_colorProfileProcedures.kCreateNewColorProfile"))
			-c ("createColorProfileCB " + $colorProfileTypeAttr) createNewColorProfileButton;
            	
	setParent ..;
}

global proc AEcolorProfileReplace(string $colorProfileTypeAttr)
{
    string $parent = `setParent -q`;
    string $menu = $parent + "|colorProfileRowLayout|colorProfileMenu";
    optionMenu -e -cc ("setColorProfileTypeAttrCB " + $menu + " " + $colorProfileTypeAttr) $menu;

    // update the optionMenu
    updateColorProfileMenu($menu, $colorProfileTypeAttr);
	// update the create button
    string $button = $parent + "|colorProfileRowLayout|createNewColorProfileButton";
    symbolButton -e -c ("createColorProfileCB " + $colorProfileTypeAttr) $button;
}

global proc applyColorProfileToSelection(string $colorProfileNode){
    // apply the given color profile to each selected item which supports color profiles


    // verify that the node name passed in is a color profile node
    string $apiType = `nodeType -api $colorProfileNode`;
    if ($apiType != "kColorProfile"){
        string $notColorProfileError = `format -s $colorProfileNode (uiRes("m_colorProfileProcedures.kNotColorProfileError"))`;
        error $notColorProfileError;
    }

    string $selection[] = `ls -sl -l`; // get current selection

    string $currentNode;
    for ($currentNode in $selection){
        // verify that this node accepts a color profile connection
        if (!`attributeExists "colorProfile" $currentNode`){
            continue; // this node doesn't support color profile connections
        }
        // connect to the given node
        $cmd = "connectAttr -force " + $colorProfileNode + ".colorProfileType " + $currentNode + ".colorProfile";
        evalEcho($cmd);
    }
}

// returns the type of the color profile node from either input, output, or render
global proc string colorProfileEnabledNodeType(string $node){
    string $objectType = `nodeType -api $node`;
    // right now mental ray output passes are the only color profile enabled nodes
    // with a kPluginDependNode type
    if (($objectType == "kRenderPass") || ($objectType == "kPluginDependNode")
        || ($objectType == "kRenderTarget"))
        return "output";
    if (($objectType == "kFileTexture") || ($objectType == "kMentalRayTexture"))
        return "input";
    return "render";
}

