// Copyright (C) 1997-2014 Autodesk, Inc., and/or its licensors.
// All rights reserved.
//
// The coded instructions, statements, computer programs, and/or related
// material (collectively the "Data") in these files contain unpublished
// information proprietary to Autodesk, Inc. ("Autodesk") and/or its licensors,
// which is protected by U.S. and Canadian federal copyright law and by
// international treaties.
//
// The Data is provided for use exclusively by You. You have the right to use,
// modify, and incorporate this Data into other products for purposes authorized 
// by the Autodesk software license agreement, without fee.
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND. AUTODESK
// DOES NOT MAKE AND HEREBY DISCLAIMS ANY EXPRESS OR IMPLIED WARRANTIES
// INCLUDING, BUT NOT LIMITED TO, THE WARRANTIES OF NON-INFRINGEMENT,
// MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE, OR ARISING FROM A COURSE 
// OF DEALING, USAGE, OR TRADE PRACTICE. IN NO EVENT WILL AUTODESK AND/OR ITS
// LICENSORS BE LIABLE FOR ANY LOST REVENUES, DATA, OR PROFITS, OR SPECIAL,
// DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES, EVEN IF AUTODESK AND/OR ITS
// LICENSORS HAS BEEN ADVISED OF THE POSSIBILITY OR PROBABILITY OF SUCH DAMAGES.

//
//
//  Creation Date:  July 17, 1998
//
//  Description:
//      This is the action for snap point to point. It takes any point 
//		selection (curve point, surface point, edit point, poly
//		vertex, etc.) and moves the first object by the distance between
//		the two points.
//
//  Input Arguments:
//      None.
//
//  Return Value:
//      None.
//


proc string getObjectToMoveName( string $object )
//
//	Description:
//		Returns the transform name of the object with no components in the 
//		string e.g. curve1.u[0.5] will return curve1
//
{
	string $name;

	// get the string before any "." or "->" - this could be a shape name
	//
	string $buffer[];
	int $numTokens = `tokenize $object ".->" $buffer`;
	if ( $numTokens >= 1 ) $name = $buffer[0];

	return $name;
}

global proc snapPointToPointGiven( string $objectList[], int $moveParent )
{
	// $moveParent = 0: move the object defined by the first 3 points
	// $moveParent = 1: move the parent of the object
	// $moveParent = 2: move the grandparent of the object
	// $moveParent = 3: move the great-grandparent of the object

	// make sure there are 2 objects in the list
	//
	int $total = size($objectList);
	if ( $total == 0 )
	{
		error (uiRes("m_snapPointToPointGiven.kInvalidSelection"));
		return;
	}
	else if ( $total == 1 )
	{
		error (uiRes("m_snapPointToPointGiven.kIncompleteSelection"));
		return;
	}
	else if ( $total > 2 )
	{
		warning (uiRes("m_snapPointToPointGiven.kTooManySelected"));
	}

	string $obj1 = $objectList[$total-2];
	string $obj2 = $objectList[$total-1];

	// get the name of the object to move (with no component part)
	//
	string $objectToMove = getObjectToMoveName( $obj1 );
	string $tmp = getObjectToMoveName( $obj2 );
	if ( $objectToMove == $tmp )
	{
		error (uiRes("m_snapPointToPointGiven.kErrorSameObject"));
		return;
	}

	// If user wants to move a group, eg. he selects points on a
	// face of a cube and wants the entire cube (group) to move
	// $moveParent = 1: move the parent of the object
	// $moveParent = 2: move the grandparent of the object
	// $moveParent = 3: move the great-grandparent of the object
	//
	if( $moveParent > 0 ) {
		string $parent[];
		string $obj = $objectToMove;
		for( $i = 0; $i < $moveParent; $i ++ ) {
			$parent = `listRelatives -parent $obj`;
			if( size($parent[0]) > 0 ) {
				$obj = $parent[0];
			}
		}
		if( size($obj) > 0 ) {
			$objectToMove = $obj;
		}
	}

	// get the world space position of each selected point object
	//
	float $pos1[] = `pointPosition $obj1`;
	float $pos2[] = `pointPosition $obj2`;

	// calculate the translation amount
	//
	float $distance[];
	$distance[0] = $pos2[0] - $pos1[0];
	$distance[1] = $pos2[1] - $pos1[1];
	$distance[2] = $pos2[2] - $pos1[2];

 	// move the first object by that amount
	//
	evalEcho("move -r " + $distance[0] + " " + $distance[1] + " " + $distance[2] + " " + $objectToMove);
}

