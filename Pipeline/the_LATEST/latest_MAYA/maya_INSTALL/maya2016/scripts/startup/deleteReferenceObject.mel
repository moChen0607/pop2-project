// Copyright (C) 1997-2014 Autodesk, Inc., and/or its licensors.
// All rights reserved.
//
// The coded instructions, statements, computer programs, and/or related
// material (collectively the "Data") in these files contain unpublished
// information proprietary to Autodesk, Inc. ("Autodesk") and/or its licensors,
// which is protected by U.S. and Canadian federal copyright law and by
// international treaties.
//
// The Data is provided for use exclusively by You. You have the right to use,
// modify, and incorporate this Data into other products for purposes authorized 
// by the Autodesk software license agreement, without fee.
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND. AUTODESK
// DOES NOT MAKE AND HEREBY DISCLAIMS ANY EXPRESS OR IMPLIED WARRANTIES
// INCLUDING, BUT NOT LIMITED TO, THE WARRANTIES OF NON-INFRINGEMENT,
// MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE, OR ARISING FROM A COURSE 
// OF DEALING, USAGE, OR TRADE PRACTICE. IN NO EVENT WILL AUTODESK AND/OR ITS
// LICENSORS BE LIABLE FOR ANY LOST REVENUES, DATA, OR PROFITS, OR SPECIAL,
// DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES, EVEN IF AUTODESK AND/OR ITS
// LICENSORS HAS BEEN ADVISED OF THE POSSIBILITY OR PROBABILITY OF SUCH DAMAGES.

global proc deleteReferenceObject()
//
// Description
//		Looks at the selection list for the first piece of
//		geometry and then proceeeds to:
//				delete the referenceObject for each
//				surface under the selectedObject.
//
{
	// Get the relevant selected objects (transforms or geometryShapes)
	string $selectedObjects[] = `ls -sl -type transform -type geometryShape`;

	if (size($selectedObjects) >= 1) {

		// Get the geometryShapeNodes for the first selected object.
		string $originalShapeNodes[] = 
			`ls -sl -dagObjects -type geometryShape $selectedObjects[0]`;
		
		if (size($originalShapeNodes) >= 1) {
			// There is at least one geometryShape node so proceed

			// Iterate through all the shape nodes
			for ($shapeNode in $originalShapeNodes) {
	
				// If referenceObject attribute is connected, find out the
				// node it is connected to and delete it.
				string $connectedNode[] = 
					`listConnections -shapes true ($shapeNode + ".referenceObject")`;

				if (size($connectedNode) == 1) {
					int $interHist = `getAttr ($connectedNode[0] +
										".intermediateObject")`;
					//
					// If the reference object is an intermediate object
					// (ie, the undeformed original shape), then just
					// break the connection.
					// Otherwise, delete the reference shape.
					//
					
					// We used to try to optimize by not making a reference object
					// but connecting to an undeformed upstream node.  If we load
					// an old file (2.0) that has such a connection and the user
					// tries to "delete reference object" we will warn the user
					// and break the connection.
					//
					if ($interHist) {
						string $warningMsg = ("Reference object " + $connectedNode[0] + " is an intermediate object.  This object will no longer be a reference object for " + $shapeNode + " but it will not be deleted.");
						warning($warningMsg);
						disconnectAttr ($connectedNode[0] + ".message")
							($shapeNode + ".referenceObject");

					} else {
						delete $connectedNode[0];
					}
				}
			}
		}
	}
}
