// Copyright (C) 1997-2014 Autodesk, Inc., and/or its licensors.
// All rights reserved.
//
// The coded instructions, statements, computer programs, and/or related
// material (collectively the "Data") in these files contain unpublished
// information proprietary to Autodesk, Inc. ("Autodesk") and/or its licensors,
// which is protected by U.S. and Canadian federal copyright law and by
// international treaties.
//
// The Data is provided for use exclusively by You. You have the right to use,
// modify, and incorporate this Data into other products for purposes authorized 
// by the Autodesk software license agreement, without fee.
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND. AUTODESK
// DOES NOT MAKE AND HEREBY DISCLAIMS ANY EXPRESS OR IMPLIED WARRANTIES
// INCLUDING, BUT NOT LIMITED TO, THE WARRANTIES OF NON-INFRINGEMENT,
// MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE, OR ARISING FROM A COURSE 
// OF DEALING, USAGE, OR TRADE PRACTICE. IN NO EVENT WILL AUTODESK AND/OR ITS
// LICENSORS BE LIABLE FOR ANY LOST REVENUES, DATA, OR PROFITS, OR SPECIAL,
// DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES, EVEN IF AUTODESK AND/OR ITS
// LICENSORS HAS BEEN ADVISED OF THE POSSIBILITY OR PROBABILITY OF SUCH DAMAGES.

//
//
//
//  Creation Date:  26 June 1997
//
//  Description:
//      This procedure figures out which selection mode the program is in.
//
//  Input Arguments:
//		None.
//
//  Return Value:
//		A string containing the name of the selection mode
//
//
// ***********************************************************************
//
// Warning:
//     Be sure that any changes made in this file are also reflected in
//     setSelectMode.mel
//
// ***********************************************************************

global string $gAllObjects[] = {
	"joint", "light", "camera", "lattice", "cluster", "sculpt", "nonlinear",
	"nurbsCurve","nurbsSurface", "curveOnSurface", "polymesh", "subdiv",
	"plane", "particleShape", "emitter", "field", "fluid", 
	"hairSystem", "follicle",
	"nCloth", "nRigid", "dynamicConstraint",
	"spring", "rigidBody", "rigidConstraint", "xyz", "orientationLocator",
	"dimension", "texture", "locator",
	"handle", "ikHandle" ,"motionTrailPoint", "motionTrailTangent"};

global string $gAllComponents[] = {
	"controlVertex", "hull", "editPoint",//  "pv", "pe", "pfe", "pf",
	// "puv", "spv", "spe", "spf", "vertex", "edge", "facet", 
	"subdivMeshPoint", "subdivMeshEdge", "subdivMeshFace", "subdivMeshUV",
	"curveParameterPoint", "curveKnot",
	"surfaceParameterPoint", "surfaceKnot", "surfaceRange", "surfaceEdge", 
	"surfaceFace", "isoparm", "latticePoint", "imagePlane",
	"pr", "springComponent", "jp", "iee", "sp", "rp", "sh" 
	//, "lra", "ac", "ak", "ait", "aot"
	};

global string $gAnimationSelectionMasksOn[] = {"joint", "handle", "ikHandle", "motionTrailPoint", "motionTrailTangent"};

global string $gNURBSelectionMasksObjects[] = {
			"nurbsCurve",
			"nurbsSurface",
			"curveOnSurface",
			"plane",
			"curve"};

global string $gNURBSelectionMasksComponents[] = {
			"curveParameterPoint",
			"surfaceEdge",
			"isoparm",
			"editPoint",
			"controlVertex",
			"hull",
			"surfaceFace"};

global string $gDeformersSelectionMasksObjects[] = {"lattice", 
			"cluster", 
			"sculpt",
			"nonlinear", 													
			"nurbsCurve"};

global string $gDeformersSelectionMasksComponents[] = {"latticePoint"};

global string $gRenderingSelectionMasksObjects[] = {
			"light",
			"camera",
			"plane"};

global string $gRenderingSelectionMasksComponents[] = {"imagePlane"};

proc int arrayFind(string $str, string $look[])
// Search the array for the given string.  
// Return true if found.
{
	int $i;

	for ($i = 0; $i < size($look); $i++) {
		if ($look[$i] == $str) {
			return true;
		}
	} 
	return false;
}

proc string[] pruneArray(string $main[], string $toremove[])
// Remove the elements of $toremove that occur in $main and return the result
{
	string $result[];
	int $resultSize = 0;

	int $i;

	for ($i = 0; $i < size($main); $i++) {
		int $temp = arrayFind($main[$i], $toremove);
		if (!$temp) {
//			print("Not found " + $main[$i] +"\n");
			$result[$resultSize++] = $main[$i];
		}
	}

	return $result;
}

proc int allMasksOff(string $masks[]) 
// Check to see if all of the specified selection masks are off.
// Return true if they are.
{
	int $i;

	int $result = false;
	string $cmd;

//	print ("In allMasksOff size is " + size($masks) + "\n");

	for ($i = 0; $i < size($masks) && !$result; $i++) {
		$cmd = "selectType -q -" + $masks[$i] + ";";
		$result = eval($cmd);
//		if ($result) {
//			warning ("Flag " + $masks[$i] + " is on.");
//		}
	}

	return !$result;
}

proc int allMasksOn(string $masks[]) 
// Check to see if all of the specified selection masks are on.
// Return true if they are.
{
	int $i;

	int $result = true;
	string $cmd;

//	print "In allMasksOn\n";

	for ($i = 0; $i < size($masks) && $result; $i++) {
		$cmd = "selectType -q -" + $masks[$i];
		$result = eval($cmd);
//		if (!$result) {
//			warning ("Flag " + $masks[$i] + " is off.");
//		}
	}

	return $result;
}

proc int onlyObjectsOn(string $masks[])
// Verify that only the specified object selection masks are on.
{
	int $i;
	global string $gAllObjects[];

	string $newMaskList[] = pruneArray($gAllObjects, $masks);

//	print ("$newMaskList is of size " + size($newMaskList) + "\n");

	int $result = (allMasksOn($masks) &&
				  allMasksOff($newMaskList));

	return $result;
}

proc int onlyComponentsOn(string $masks[])
// Verify that only the specified component selection masks are on.
{
	int $i;
	global string $gAllComponents[];

	string $newMaskList[] = pruneArray($gAllComponents, $masks);

	int $result = (allMasksOn($masks) &&
				  allMasksOff($newMaskList));

	return $result;
}

global proc string getSelectMode() {
//
//	Return the string that represents 
//  the current high level selection mask
//
	string $selectionModeName;
	global string $gAllObjects[];
	global string $gAnimationSelectionMasksOn[];
	global string $gNURBSelectionMasksObjects[];
	global string $gNURBSelectionMasksComponents[];
	global string $gDeformersSelectionMasksObjects[];
	global string $gDeformersSelectionMasksComponents[];
	global string $gRenderingSelectionMasksObjects[];
	global string $gRenderingSelectionMasksComponents[];
	if (`selectMode -q -root` ||
		`selectMode -q -leaf` ||
		`selectMode -q -template`)
	{
		$selectionModeName = (uiRes("m_getSelectMode.kHierarchy"));
	}
	else if (`selectMode -q -object`) {
		if (!`selectPref -q -ignoreSelectionPriority` &&
			`selectPriority -q -handle` == 5 &&
			`selectPriority -q -ikHandle` == 5 &&
			`selectPriority -q -joint` == 4 &&
			onlyObjectsOn($gAnimationSelectionMasksOn))
		{
			$selectionModeName = (uiRes("m_getSelectMode.kAnimation"));
		}
		else if (allMasksOn($gAllObjects) &&
			`selectPref -q -ignoreSelectionPriority`)
		{
			$selectionModeName = (uiRes("m_getSelectMode.kAllObjects"));	
		}
		else {
			$selectionModeName = (uiRes("m_getSelectMode.kObjects"));	
		}
	} else if (`selectMode -q -component`) {
		if (`selectPref -q -ignoreSelectionPriority` &&
			`selectType -q -polymesh` &&
			`selectType -q -subdiv` &&
			`selectType -q -plane` &&
			allMasksOff($gNURBSelectionMasksComponents) &&
			(`selectType -q -vertex` ||
			`selectType -q -edge` ||
			`selectType -q -facet` ||
			`selectType -q -subdivMeshPoint` ||
			`selectType -q -subdivMeshEdge` ||
			`selectType -q -subdivMeshFace` ||
			`selectType -q -subdivMeshUV`))
		{
			$selectionModeName = (uiRes("m_getSelectMode.kPolygons"));	
		}
		else {
			$selectionModeName = (uiRes("m_getSelectMode.kComponents"));	
		}
	} else if (`selectMode -q -preset`) {
		if (!`selectPref -q -ignoreSelectionPriority` &&
			!`selectPref -q -allowHiliteSelection` &&
			`selectPriority -q -isoparm` == 2 &&
			onlyObjectsOn($gNURBSelectionMasksObjects) &&
			onlyComponentsOn($gNURBSelectionMasksComponents) )
		{
			$selectionModeName = (uiRes("m_getSelectMode.kNURBS"));
		}
		else if (!`selectPref -q -ignoreSelectionPriority` &&
			!`selectPref -q -allowHiliteSelection` &&
			`selectPriority -q -sculpt` == 5 &&
			`selectPriority -q -nonlinear` == 5 &&		
			`selectPriority -q -lattice` ==  5 &&
			`selectPriority -q -cluster` ==  5 &&
			`selectPriority -q -locator` ==  5 &&
			onlyObjectsOn($gDeformersSelectionMasksObjects) &&
			onlyComponentsOn($gDeformersSelectionMasksComponents) )
		{
			$selectionModeName = (uiRes("m_getSelectMode.kDeform"));
		}
		else if (`selectPref -q -allowHiliteSelection` &&
			`selectType -q -particleShape` &&
			`selectType -q -emitter` &&
			`selectType -q -field` &&
			`selectType -q -fluid` &&
			`selectType -q -hairSystem` &&
			`selectType -q -follicle` &&
			`selectType -q -nCloth` &&
			`selectType -q -nRigid` &&
			`selectType -q -dynamicConstraint` &&
			`selectType -q -collisionModel` &&
			`selectType -q -spring` &&
			`selectType -q -rigidBody` &&
			`selectType -q -rigidConstraint` &&
			`selectType -q -particle` &&
			`selectType -q -springComponent` )
		{
			$selectionModeName = (uiRes("m_getSelectMode.kDynamics"));
		}
		else if (!`selectPref -q -allowHiliteSelection` &&
			onlyObjectsOn($gRenderingSelectionMasksObjects) &&
			onlyComponentsOn($gRenderingSelectionMasksComponents) )
		{
			$selectionModeName = (uiRes("m_getSelectMode.kRendering"));
		}
		else {
			$selectionModeName = (uiRes("m_getSelectMode.kMixed"));
		}
	}

	return $selectionModeName;
}
