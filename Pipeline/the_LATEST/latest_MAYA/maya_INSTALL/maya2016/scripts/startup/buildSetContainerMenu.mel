// Copyright (C) 1997-2014 Autodesk, Inc., and/or its licensors.
// All rights reserved.
//
// The coded instructions, statements, computer programs, and/or related
// material (collectively the "Data") in these files contain unpublished
// information proprietary to Autodesk, Inc. ("Autodesk") and/or its licensors,
// which is protected by U.S. and Canadian federal copyright law and by
// international treaties.
//
// The Data is provided for use exclusively by You. You have the right to use,
// modify, and incorporate this Data into other products for purposes authorized 
// by the Autodesk software license agreement, without fee.
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND. AUTODESK
// DOES NOT MAKE AND HEREBY DISCLAIMS ANY EXPRESS OR IMPLIED WARRANTIES
// INCLUDING, BUT NOT LIMITED TO, THE WARRANTIES OF NON-INFRINGEMENT,
// MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE, OR ARISING FROM A COURSE 
// OF DEALING, USAGE, OR TRADE PRACTICE. IN NO EVENT WILL AUTODESK AND/OR ITS
// LICENSORS BE LIABLE FOR ANY LOST REVENUES, DATA, OR PROFITS, OR SPECIAL,
// DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES, EVEN IF AUTODESK AND/OR ITS
// LICENSORS HAS BEEN ADVISED OF THE POSSIBILITY OR PROBABILITY OF SUCH DAMAGES.


//
//  Procedure Name:
//      buildSetContainerMenu
//
//  Description:
//      build the menu used for quickly selecting the current container
//
//  Input Arguments:
//      Name of the parent menu
//
//  Return Value:
//      None.
//
proc int
createContainerMenuItem(string $container,
						string $currentContainer,
						int $submenu)
{
	int $containerRadioOn = false;
	$radioState = ( $container == $currentContainer );
	if ( $radioState ) {
		$containerRadioOn = true;
	}
	$cmd = ( "container -e -c 1 \"" + $container + "\"" );
	string $format = (uiRes("m_buildSetContainerMenu.kSetCurrContAnnotFormat"));
	$annotation = `format -stringArg $container $format`;
	
	string $chmem[] = `container -q -nl $container`;
	string $subcontainers[] = `ls -type container $chmem`;
	int $submenu = (size($subcontainers) > 0);
	menuItem -label $container -command $cmd -annotation $annotation  -subMenu $submenu
		-radioButton $radioState;		
	if ($submenu) {
		menuItem -label $container -command $cmd -annotation $annotation
			-radioButton $radioState;
		menuItem -divider true;		
		for ($sub in $subcontainers) {
			if (createContainerMenuItem($sub,
										$currentContainer,1)) {
				$containerRadioOn = true;
			}
		}
		setParent -m ..;
	}
	return $containerRadioOn;
}

global proc buildSetContainerMenu( string $menu ) 
{
	string $oldParent = `setParent -m -query`;
	menu -edit -dai $menu;
	setParent -m $menu;
	int $containerRadioOn = false;

	// Get the list of top-level containers
	//
	string $containers[] = `ls -type container`;
	string $topLevelContainers[];
	for ($obj in $containers) {
		string $parent[] = `container -q -parentContainer $obj`;
		if (size($parent) == 0) {
			$topLevelContainers[size($topLevelContainers)] = $obj;
		}
	}
	
	string $currentContainer = `container -q -c`;

	// Put in the "None" menu item
	//
	radioMenuItemCollection;
	int $radioState; 
	$radioState = ( size( $currentContainer ) == 0 );
	menuItem -label (uiRes("m_buildSetContainerMenu.kNone")) -command "ClearCurrentContainer" 
		-annotation (getRunTimeCommandAnnotation("ClearCurrentContainer"))
		-radioButton $radioState;

	// Put in another divider, but only if there are containers
	// to list in the top-level container section of the menu
	//
	if ( size( $topLevelContainers ) > 0 ) {
		menuItem -divider true;
	}

	// Put in the radio buttons for all of the top-level containers
	// in the scene
	//
	string $cmd, $annotation;
	for ( $container in $topLevelContainers ) {
		if (createContainerMenuItem($container,
									$currentContainer, 0)) {
			$containerRadioOn = true;
		}
	}
	setParent -m $oldParent;
}
