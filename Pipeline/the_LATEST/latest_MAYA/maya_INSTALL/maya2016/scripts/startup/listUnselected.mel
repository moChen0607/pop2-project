// Copyright (C) 1997-2014 Autodesk, Inc., and/or its licensors.
// All rights reserved.
//
// The coded instructions, statements, computer programs, and/or related
// material (collectively the "Data") in these files contain unpublished
// information proprietary to Autodesk, Inc. ("Autodesk") and/or its licensors,
// which is protected by U.S. and Canadian federal copyright law and by
// international treaties.
//
// The Data is provided for use exclusively by You. You have the right to use,
// modify, and incorporate this Data into other products for purposes authorized 
// by the Autodesk software license agreement, without fee.
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND. AUTODESK
// DOES NOT MAKE AND HEREBY DISCLAIMS ANY EXPRESS OR IMPLIED WARRANTIES
// INCLUDING, BUT NOT LIMITED TO, THE WARRANTIES OF NON-INFRINGEMENT,
// MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE, OR ARISING FROM A COURSE 
// OF DEALING, USAGE, OR TRADE PRACTICE. IN NO EVENT WILL AUTODESK AND/OR ITS
// LICENSORS BE LIABLE FOR ANY LOST REVENUES, DATA, OR PROFITS, OR SPECIAL,
// DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES, EVEN IF AUTODESK AND/OR ITS
// LICENSORS HAS BEEN ADVISED OF THE POSSIBILITY OR PROBABILITY OF SUCH DAMAGES.

//
// Creation Date:  November 22, 1997
//
//<doc>
//<name listUnselected>
//
//<synopsis>
//	string[] listUnselected()
//
//<description>
//		Lists the top transform for all DAG objects that are visible and not selected.
//
//<flags>
//		None.
//
//<returns>
//      string[]: Array of transform nodes names.
//
//<examples>
//      sphere; cone; group; select -d;
//      listUnselected;
//      // Result: nurbsSphere1 group1 //
//
//</doc>
//
global proc string[] listUnselected ()
{
	string $selected[] = `ls -sl -type dagNode`;
	int    $selectedCount = size($selected);
	string $assemblies[]  = `ls -as -v`;

	if ($selectedCount == 0) {
		return $assemblies;
	} else {
		string	$item;
		string	$result[];
		string  $selectedAbove[];
	
		//	Expand selected to include objects above the selected items
		//
		string  $selectedAbove[] = $selected;
		$parents = `listRelatives -p -pa $selected`;
		while (size($parents) > 0) {
			for ($item in $parents) {
				$selectedAbove[size($selectedAbove)] = $item;
			}
			$parents = `listRelatives -p -pa $parents`;
		}
		$selected = sort($selected);
		$selectedAbove = sort($selectedAbove);
		int $selectedCount = size($selected);
		int $selectedAboveCount = size($selectedAbove);

		//	Process assemblies
		//
		int		$i, $j, $cmp;
		string	$leftOvers[];
		int		$leftOverCount;
		int		$assemblyCount = size($assemblies);

		do {
			$assemblies = sort($assemblies);

			//	Step 1: process objects not on selectedAbove list
			//
			$i = 0; $j = 0;
			while ($i < $assemblyCount && $j < $selectedAboveCount) {
				$cmp = strcmp($assemblies[$i], $selectedAbove[$j]);
				if ($cmp < 0) {
					$result[size($result)] = $assemblies[$i];
					++$i;
				} else if ($cmp > 0) {
					++$j;
				} else {
					$leftOvers[size($leftOvers)] = $assemblies[$i];
					++$i; ++$j;
				}
			}
			while ($i < $assemblyCount) {
				$result[size($result)] = $assemblies[$i];
				++$i;
			}

			//	Step 2: weed out active leftovers
			//
			$i = 0; $j = 0;
			clear($assemblies);
			$leftOverCount = size($leftOvers);
			while ($i < $leftOverCount && $j < $selectedCount) {
				$cmp = strcmp($leftOvers[$i], $selected[$j]);
				if ($cmp < 0) {
					$assemblies[size($assemblies)] = $leftOvers[$i];
					++$i;
				} else if ($cmp > 0) {
					++$j;
				} else {
					++$i; ++$j;
				}
			}
			while ($i < $leftOverCount) {
				$assemblies[size($assemblies)] = $leftOvers[$i];
				++$i;
			}
			clear($leftOvers);

			//	Process children of leftovers recursively...
			//
			$assemblies = `listRelatives -c -pa $assemblies`;
			$assemblyCount = size($assemblies);
		} while ($assemblyCount > 0);
		return $result;
	}
}
