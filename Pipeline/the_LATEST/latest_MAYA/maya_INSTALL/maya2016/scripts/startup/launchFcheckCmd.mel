// Copyright (C) 1997-2014 Autodesk, Inc., and/or its licensors.
// All rights reserved.
//
// The coded instructions, statements, computer programs, and/or related
// material (collectively the "Data") in these files contain unpublished
// information proprietary to Autodesk, Inc. ("Autodesk") and/or its licensors,
// which is protected by U.S. and Canadian federal copyright law and by
// international treaties.
//
// The Data is provided for use exclusively by You. You have the right to use,
// modify, and incorporate this Data into other products for purposes authorized 
// by the Autodesk software license agreement, without fee.
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND. AUTODESK
// DOES NOT MAKE AND HEREBY DISCLAIMS ANY EXPRESS OR IMPLIED WARRANTIES
// INCLUDING, BUT NOT LIMITED TO, THE WARRANTIES OF NON-INFRINGEMENT,
// MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE, OR ARISING FROM A COURSE 
// OF DEALING, USAGE, OR TRADE PRACTICE. IN NO EVENT WILL AUTODESK AND/OR ITS
// LICENSORS BE LIABLE FOR ANY LOST REVENUES, DATA, OR PROFITS, OR SPECIAL,
// DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES, EVEN IF AUTODESK AND/OR ITS
// LICENSORS HAS BEEN ADVISED OF THE POSSIBILITY OR PROBABILITY OF SUCH DAMAGES.



global proc launchFcheckCmd( string $fileName, int $sequence )
//Description
// This procedure starts fcheck to view an image or a sequence
// $fileName is the absolute path to an image
// $sequence = 0 is an image
// $sequence = 1 is a sequence
{
	
	//initialize variables in case this is a sequence
	//these 3 are required by fcheck
	int $startFrame, $endFrame, $by;
	int $isWin = `about -win`; // $isWin = 1 in Windows (both in Win32 and Win64 systems)
	string $searchCmd;//command generated to search for files in a sequence
	int $numFileNameComponents;//number of pieces to the file name (2 or 3)
	int $numericComponent;//piece of the file name being accessed
	string $fileNameBuffer[];//break the file name into pieces
	string $filePathBuffer[];//break the file path into pieces
	string $fcheckCmd = "fcheck ";//command to launch fcheck
	string $filePath = "";//path to file
	string $prevts = ""; //string to hold the previous value of $ts
	string $pureNumber; //just the number part of the filename
	string $pureName; //just the name part of the filename without numbers
	int $flagFirstPart=0; // 1 if first part of file name contains a number.
	int $flagSecondPart=0; // 1 if second part of file name contains a number.			
	if ($isWin != 1){
		$filePath = "/";
	}
	
    // On Mac running Fcheck from command line expects first 2 parameters to
    // to be the executable name and name inside bundle, we launch this as system cmd now
    if (`about -mac` == 1) {
        // add in 2nd parameter to align the other args
        $fcheckCmd  += "Fcheck ";
    }

	//determine if this is meant to be a sequence
	if ($sequence == 1){
		//fcheck on mac doesn't like the @ in the file name so we store a copy of the original fileName
		string $fileNameMac = $fileName;
		//determine range
		//break the fileName into pieces to find the numeric component
		//first by slashes and then by periods
		$numFilePathComponents = `tokenize $fileName "//" $filePathBuffer`;
		$numFileNameComponents = `tokenize $filePathBuffer[$numFilePathComponents-1] "." $fileNameBuffer`;
		
		if ($numFileNameComponents > 3){
			warning (uiRes("m_launchFcheckCmd.kLaunchFcheckCmdProblemWithPath"));
		}
		
		int $i = 0;
		$numericComponent = -1;
		int $fileNumberTest[];//convert the string to an int and see if it is still a number
		string $numbers;
		for ($fileNameComponent in $fileNameBuffer){

			// A preliminary check to see if the string is a number or not.
			$numbers = `match "[0-9]+" $fileNameComponent`;

			if ($numbers == $fileNameComponent){  // Will be true only for a number.
				$fileNumberTest[$i] = $fileNameComponent;
			}
			//making an assumption that the number component of the file name is not 0
			if ($fileNumberTest[$i] != 0){
				$numericComponent = $i;
			}
			$i++;
		}
		
		//make sure we found the numeric component
		
		// first part of the if condition checks for a file of format filename#.ext
		// second part of the if condition checks for a file of format filename.#
		if (($numericComponent == -1) || ($numFileNameComponents ==2 && $numericComponent ==1))
		{ 
			if ($numFileNameComponents == 2)
			{
				string $filePureName; //To hold the pure file name independent of extension.
				$filePureName = $fileNameBuffer[0];
				int $lenPure = size ($filePureName);

				if ($numericComponent == -1) // first part contains some number
				{
					$prevts = findNumberPart($filePureName);
					$pureNumber = $prevts;
					$flagFirstPart = 1;
					//find the pure name part
					int $nts = size ($pureNumber);
					int $pureNameLen = $lenPure - $nts;
					$pureName = substring ($filePureName,1,$pureNameLen);
				
				}
				else // the second part contains the number
				{
					$prevts = $fileNameBuffer[1];
					string $numbers = `match "[0-9]+" $prevts`;

					//if the second part also doesn't contain any number
					//
					if( $numbers != $prevts )
					{
						error (uiRes("m_launchFcheckCmd.kUnknownFileNamingConvention"));
					}
					else
					{
						$pureNumber = $prevts;
						$flagSecondPart = 1;
						$pureName = $fileNameBuffer[0];
					}
				}
				$numericComponent = 0; 
			} 
			else 
			{
				int $compare = `strcmp $fileNameBuffer[1] $fileNameBuffer[2]`;
				if ($compare == -1)
				{
					$numericComponent = 1;
				}
				else
				{
					$numericComponent = 2;
				}
			}
		}
		
		//reassemble the filePath
		int $assembleFilePathCounter = 0;
		for (;$assembleFilePathCounter < ($numFilePathComponents-1);$assembleFilePathCounter++){
			$filePath = ($filePath + $filePathBuffer[$assembleFilePathCounter] + "/");
		}
				
		//reassemble fileName with @ to replace the numericComponent
		//fcheck requires this to load a sequence, only WIL - not mac
		int $paddingSize;
		if ($numFileNameComponents == 3)
		{
		$fileName = ($filePath + $fileNameBuffer[0] + ".");
			$paddingSize = `size $fileNameBuffer[$numericComponent]`;
		}
		else if ($numFileNameComponents == 2)
		{
			$fileName = ($filePath + $pureName);
			$paddingSize = size ($pureNumber);
		}
		string $paddingWildcard;
		int $k;
		for ($k = 0; $k < $paddingSize; $k++){
			$paddingWildcard += "@";
		}

		if ($numericComponent == 2)
		{
			$fileName = ($fileName + $fileNameBuffer[1]);
		} 
		else if ($numericComponent == 1)
		{
			$fileName = ($fileName + $paddingWildcard);
		} 
		else if ($numericComponent == 0) //true for filename#.ext and file.# where $numFileComponents=2
		{
			if ($flagFirstPart == 1)
			{
				$fileName = ($fileName + $paddingWildcard + "." + $fileNameBuffer[1]) ;
			}
			else if($flagSecondPart == 1)
			{
				$fileName = ($fileName + "." + $paddingWildcard);
			}
		}
		if ($numFileNameComponents == 3){
			if ($numericComponent == 2){
				$fileName = ($fileName + "." + $paddingWildcard);
			} else {
				$fileName = ($fileName + "." + $fileNameBuffer[2]);
			}
		}
		
		//now get the frame range to the end
		//first do a substitution to find all images in the sequence
		//string $fileNameForRange = `substitute "@" $fileName "*"`;
		string $fileNameForRange = `substitute $paddingWildcard $fileName "*"`;

		//reassemble the path to search for the sequence
		string $pathBuffer[];
		int $numPath = `tokenize $fileNameForRange "//" $pathBuffer`;
		$filePath = "";
		if ($isWin != 1){
			//os other than nt starts the path to a file with a /
			$filePath = "/";
		}
		int $j;
		for ($j = 0; $j < ($numPath - 1) ; $j++){
			if ($isWin){
				//nt requires \ in the path
				$filePath = ($filePath + $pathBuffer[$j] + "\\");
			} else {
				//unix prefers /
				$filePath = ($filePath + $pathBuffer[$j] + "/");
			}
		}
		
		//set the file to search for
		string $file;//file to search for to determine how many images are in the sequence
		
		$file = ($file + $pathBuffer[$numPath-1]);

		string $strTemp, $searchBuffer[], $strBuffer1[];
		int $nTemp, $nEndFrameInitialized = 0;
		
		// get the file list in $filepath with $file as filter
		$searchBuffer = `getFileList -folder $filePath -filespec $file`;
		
		for ($strTemp in $searchBuffer)
		{
			tokenize $strTemp "." $strBuffer1;
			if (size ($strBuffer1) == $numFileNameComponents)
			{
				if ($numFileNameComponents == 3)
				{
				$nTemp = $strBuffer1[$numericComponent];
				}
				else if ($numFileNameComponents == 2)
				{
					//$nTemp should contain the number part of filename.
					if ($flagFirstPart == 1)
					{
						string $pureStrTemp = $strBuffer1[$numericComponent];
						$nTemp = findNumberPart($pureStrTemp);
					}
					else if ($flagSecondPart == 1)
					{
						$nTemp = $strBuffer1[1];
					}
					
				}
				if ($nTemp > $endFrame || $nEndFrameInitialized == 0)
				{
					$endFrame = $nTemp;
					$nEndFrameInitialized = 1;
				}
			}
		}
		
		//startFrame is the frame the user selected
		if ($numFileNameComponents == 3)
		{
		$startFrame = $fileNameBuffer[$numericComponent];
		}
		else if ($numFileNameComponents == 2)
		{
			$startFrame = $pureNumber;
		}
		//assume by value of 1
		$by = 1;

		//determine time units as this is likely the speed that the user
		//will want fcheck to playback at
		string $time;
        $time = `currentUnit -query -time`;
		if ($time != "ntsc" && $time != "pal"){
			$time = "film";
		}
		
		//assemble fcheck command for the sequence
		$fcheckCmd += ("-n " + $startFrame + " ");
		$fcheckCmd += ($endFrame + " " + $by + " -r " + $time + " ");
		if (`about -mac`){
			$fcheckCmd += ("\"" + $fileNameMac + "\"");
		} else {
			$fcheckCmd += ("\"" + $fileName + "\"");
		}

	}
	
	if ($sequence == 0){
		//start fcheck for a single image
		
		$fcheckCmd += "\"" + $fileName + "\"";
		
	}

	//launch fcheck
	evalEcho ($fcheckCmd);
	
}

global proc string findNumberPart(string $str)
{
	int $lenstr = size ($str);
	int $ind;
	string $its="";
	string $previts;
	string $ichar;
	for ($ind = $lenstr; $ind > 0; --$ind)
	{
		$ichar = `substring $str $ind $ind`;
		$its = $ichar + $its;

		string $numbers = `match "[0-9]+" $its`;
		if( $numbers != $its ) {
			break;
		}

        $previts = $its ;
	}
	return $previts;
}

