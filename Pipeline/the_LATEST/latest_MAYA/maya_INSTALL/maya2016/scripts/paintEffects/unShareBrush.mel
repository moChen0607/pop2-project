// Copyright (C) 1997-2014 Autodesk, Inc., and/or its licensors.
// All rights reserved.
//
// The coded instructions, statements, computer programs, and/or related
// material (collectively the "Data") in these files contain unpublished
// information proprietary to Autodesk, Inc. ("Autodesk") and/or its licensors,
// which is protected by U.S. and Canadian federal copyright law and by
// international treaties.
//
// The Data is provided for use exclusively by You. You have the right to use,
// modify, and incorporate this Data into other products for purposes authorized 
// by the Autodesk software license agreement, without fee.
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND. AUTODESK
// DOES NOT MAKE AND HEREBY DISCLAIMS ANY EXPRESS OR IMPLIED WARRANTIES
// INCLUDING, BUT NOT LIMITED TO, THE WARRANTIES OF NON-INFRINGEMENT,
// MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE, OR ARISING FROM A COURSE 
// OF DEALING, USAGE, OR TRADE PRACTICE. IN NO EVENT WILL AUTODESK AND/OR ITS
// LICENSORS BE LIABLE FOR ANY LOST REVENUES, DATA, OR PROFITS, OR SPECIAL,
// DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES, EVEN IF AUTODESK AND/OR ITS
// LICENSORS HAS BEEN ADVISED OF THE POSSIBILITY OR PROBABILITY OF SUCH DAMAGES.

//
//
//  Description:
//		This script is executed when a new scene file is created.  It will create
//		panels if required or use existing panels.
//
//  Creation Date: Dec 1998
//
global proc string unShareBrush( )
{
	// No arguments. Takes selection list and makes all strokes
	// which share the same brush use different brushes.
	// Returns the name of the last brush made.

	string $nodes[] = `getStrokes 2`;
	string $node;
	string $brushes[];
	int    $bIdx = 0;

	if (size( $nodes ) == 0) {
		// No strokes were found, quit.
		warning((uiRes("m_unShareBrush.kNoStrokes")));
		return "";
	}
	if (size( $nodes ) == 1) {
		// Only one stroke was found, quit.
		warning((uiRes("m_unShareBrush.kOnlyOneStroke")));
		return "";
	}
	for ($node in $nodes) {
		string $attr = $node + ".brush";
		string $result = `connectionInfo -sfd $attr`;
		string $buffer[];
		int $num = `tokenize $result "." $buffer`;
		$brushes[ $bIdx ] = $buffer[0];
		++$bIdx;
	}

	// Loop over the nodes in the strokes brushes list and any that have duplicates, create a new brush, and attach.
	$i = 0;
	string $createdBrush = "";
	while ($i < $bIdx) {
		// Get the current brush.
		string $target = $brushes[$i];
		int $j = $i + 1;
		// Now look through the rest of the brushes looking for a brush of the same name.
		while ($j < $bIdx) {
			if ($brushes[$j] == $target) {
				// We found a duplicate. Duplicate the $target brush and reconnect the appropriate node.
				string $newBrush[] = `duplicate -ic $target`;
				string $attrDst = $nodes[ $j ] + ".brush";
				string $attrSrc = $newBrush[0] + ".outBrush";
				connectAttr -f $attrSrc $attrDst;
				$j = $bIdx; // break out of this inner loop
			}
			$j = $j + 1;
		}
		$i = $i + 1;
	}
	
	return $createdBrush;
}
