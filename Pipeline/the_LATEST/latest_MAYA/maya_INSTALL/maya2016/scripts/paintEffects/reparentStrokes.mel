// Copyright (C) 1997-2014 Autodesk, Inc., and/or its licensors.
// All rights reserved.
//
// The coded instructions, statements, computer programs, and/or related
// material (collectively the "Data") in these files contain unpublished
// information proprietary to Autodesk, Inc. ("Autodesk") and/or its licensors,
// which is protected by U.S. and Canadian federal copyright law and by
// international treaties.
//
// The Data is provided for use exclusively by You. You have the right to use,
// modify, and incorporate this Data into other products for purposes authorized 
// by the Autodesk software license agreement, without fee.
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND. AUTODESK
// DOES NOT MAKE AND HEREBY DISCLAIMS ANY EXPRESS OR IMPLIED WARRANTIES
// INCLUDING, BUT NOT LIMITED TO, THE WARRANTIES OF NON-INFRINGEMENT,
// MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE, OR ARISING FROM A COURSE 
// OF DEALING, USAGE, OR TRADE PRACTICE. IN NO EVENT WILL AUTODESK AND/OR ITS
// LICENSORS BE LIABLE FOR ANY LOST REVENUES, DATA, OR PROFITS, OR SPECIAL,
// DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES, EVEN IF AUTODESK AND/OR ITS
// LICENSORS HAS BEEN ADVISED OF THE POSSIBILITY OR PROBABILITY OF SUCH DAMAGES.

//
//<doc>
//<name reparentStrokes>
//
//<synopsis>
//		reparentStrokes
//
//<returns>
//		None	
//
//<description>
//	This transfers all strokes on the first selected object to the second selected object. There should be exactly two objects selected and
//	both objects should be the same type: either nurbsSurface or mesh. One should first select the target and then the destination object, but if
//	only one object has strokes on it then the order does not matter.  The toplogy need not match between the objects, but the uvs should match
//	if one wishes the strokes to transfer to matching positions. 
//
//<flags>
//	None
//<examples>
//  reparentStrokes
//</doc>


global proc reparentStrokes()
{
	
	string $mSel[] = `ls -dag -sl -type mesh`;
	string $nSel[] = `ls -dag -sl -type nurbsSurface`;
	int $isPoly = false;
	string $source, $target;
	string $con,$type,$inCon;
	if( size($mSel) == 2 && size($nSel) == 0 ){
		$isPoly = true;
		$source = $mSel[0];
		$target = $mSel[1];
		$con = ".worldMesh[0]";
		$type = "curveFromMesh";
		$inCon = ".inputMesh";
	} else if( size($mSel) == 0 && size($nSel) == 2 ){
		$source = $nSel[0];
		$target = $nSel[1];
		$con = ".worldSpace[0]";
		$type = "curveFromSurface";
		$inCon = ".inputSurface";
	} else {
		error( (uiRes("m_reparentStrokes.kReparentSelection")) );
	}

	string $crvs[];
	$crvs= `listConnections -type $type ($source + $con)`;
	if( size($crvs) == 0 ){
		$crvs = `listConnections -type $type ($target + $con)`;
		if( size($crvs) == 0 ){
			error(  (uiRes("m_reparentStrokes.kReparentNoStrokes")));
			return;
		} else {
			string $tmp = $target;
			$target = $source;
			$source = $tmp;
		}
	}
	string $crv;

	for( $crv in $crvs ){
		connectAttr -f ($target+$con) ($crv + $inCon);
		if( $isPoly ){
			string $strokes[] = `listConnections -type stroke ($crv + ".outputCurve")`;
			if( size( $strokes ) > 0 ){
				connectAttr -f ($target + ".uvSet[0].uvSetName")  ($strokes[0] + ".uvSetName[0]");
			}
		}
	}
	
	
}
