// Copyright (C) 1997-2014 Autodesk, Inc., and/or its licensors.
// All rights reserved.
//
// The coded instructions, statements, computer programs, and/or related
// material (collectively the "Data") in these files contain unpublished
// information proprietary to Autodesk, Inc. ("Autodesk") and/or its licensors,
// which is protected by U.S. and Canadian federal copyright law and by
// international treaties.
//
// The Data is provided for use exclusively by You. You have the right to use,
// modify, and incorporate this Data into other products for purposes authorized 
// by the Autodesk software license agreement, without fee.
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND. AUTODESK
// DOES NOT MAKE AND HEREBY DISCLAIMS ANY EXPRESS OR IMPLIED WARRANTIES
// INCLUDING, BUT NOT LIMITED TO, THE WARRANTIES OF NON-INFRINGEMENT,
// MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE, OR ARISING FROM A COURSE 
// OF DEALING, USAGE, OR TRADE PRACTICE. IN NO EVENT WILL AUTODESK AND/OR ITS
// LICENSORS BE LIABLE FOR ANY LOST REVENUES, DATA, OR PROFITS, OR SPECIAL,
// DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES, EVEN IF AUTODESK AND/OR ITS
// LICENSORS HAS BEEN ADVISED OF THE POSSIBILITY OR PROBABILITY OF SUCH DAMAGES.

//
// makeTubeOn
//
// This function turns tubes on for the current template brush,
// and sets the tube generation parameters such that there is 
// little change in appearance. A single tube is created that
// exactly follows the brush path and has the same width as
// the brush.
//<doc>
//<name makeTubeOn>
//
//<synopsis>
//	makeTubeOn ()
//
//<returns>
//  None.
//
//<description>
// This function turns tubes on for the current template brush,
// and sets the tube generation parameters such that there is 
// little change in appearance. A single tube is created that
// exactly follows the brush path and has the same width as
// the brush.
//
//<flags>
//	None.
//<examples>
//  makeTubeOn;
//
//</doc>

global proc
makeTubeOn()
{
	string $brush = getDefaultBrush();
	setAttr ($brush + ".tubes") 1;	
	setAttr ($brush + ".startTubes") 1;	
	setAttr ($brush + ".tubesPerStep") 0;	
	setAttr ($brush + ".segments") 500;	
	setAttr ($brush + ".elevationMin") 0;	
	setAttr ($brush + ".elevationMax") 0;	
	setAttr ($brush + ".azimuthMin") 0;	
	setAttr ($brush + ".azimuthMax") 0;	
	setAttr ($brush + ".tubeCompletion") 0;	
	setAttr ($brush + ".branches") 0;	
	setAttr ($brush + ".twigs") 0;	
	setAttr ($brush + ".leaves") 0;	
	setAttr ($brush + ".flowers") 0;	
	setAttr ($brush + ".pathFollow") 1.0;	
	setAttr ($brush + ".pathAttract") 0.0;	
	setAttr ($brush + ".random") 0.0;	
	setAttr ($brush + ".gravity") 0.0;	
	setAttr ($brush + ".lengthFlex") 1.0;	
	if( getAttr( $brush + ".mapMethod" ) > 1 )
	{
		float $uRep = getAttr( $brush + ".repeatU" );
		setAttr  ($brush + ".repeatU") ($uRep * 100);
	}
	float $colr[] = getAttr( $brush + ".color1" );
	setAttr  ($brush + ".color2") $colr[0] $colr[1] $colr[2];
	$colr = getAttr( $brush + ".incandescence1" );
	setAttr  ($brush + ".incandescence2") $colr[0] $colr[1] $colr[2];
	$colr = getAttr( $brush + ".transparency1" );
	setAttr  ($brush + ".transparency2") $colr[0] $colr[1] $colr[2];

	float $flatness = getAttr( $brush + ".flatness1" );
	setAttr  ($brush + ".flatness2") $flatness;
	float $wid = getAttr( $brush + ".brushWidth" );
	setAttr  ($brush + ".tubeWidth1") $wid;
	setAttr  ($brush + ".tubeWidth2") $wid;
}

