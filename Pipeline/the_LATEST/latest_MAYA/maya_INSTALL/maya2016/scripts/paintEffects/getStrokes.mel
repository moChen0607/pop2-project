// Copyright (C) 1997-2014 Autodesk, Inc., and/or its licensors.
// All rights reserved.
//
// The coded instructions, statements, computer programs, and/or related
// material (collectively the "Data") in these files contain unpublished
// information proprietary to Autodesk, Inc. ("Autodesk") and/or its licensors,
// which is protected by U.S. and Canadian federal copyright law and by
// international treaties.
//
// The Data is provided for use exclusively by You. You have the right to use,
// modify, and incorporate this Data into other products for purposes authorized 
// by the Autodesk software license agreement, without fee.
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND. AUTODESK
// DOES NOT MAKE AND HEREBY DISCLAIMS ANY EXPRESS OR IMPLIED WARRANTIES
// INCLUDING, BUT NOT LIMITED TO, THE WARRANTIES OF NON-INFRINGEMENT,
// MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE, OR ARISING FROM A COURSE 
// OF DEALING, USAGE, OR TRADE PRACTICE. IN NO EVENT WILL AUTODESK AND/OR ITS
// LICENSORS BE LIABLE FOR ANY LOST REVENUES, DATA, OR PROFITS, OR SPECIAL,
// DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES, EVEN IF AUTODESK AND/OR ITS
// LICENSORS HAS BEEN ADVISED OF THE POSSIBILITY OR PROBABILITY OF SUCH DAMAGES.

//
//
//  Creation Date: Jan 99
//
//
//  Description:
//      This finds all strokes in the selection list.
//      If the integer input argument is:
//        0 - only return strokes which are picked directly
//        1 - return strokes which are picked directly, or
//            indirectly though their curves
//        2 - return strokes which are picked directly,
//            indirectly though their curves, or indirectly
//            through surfaces with COS's.
//
//  Returns:
//        $string[] - a list of all strokes selected.
//        If a stroke is selected more than once it will
//        only appear once in the list.
//

proc int addFromCurves( string $node, string $strokes[], int $sIdx )
{
	// Check a curve, and get all related strokes.
	string $nstrokes[] = `listConnections -t stroke ($node + ".ws[0]")`;
	string $nstroke;
	for( $nstroke in $nstrokes ) {
		if (nodeType( $nstroke ) == "transform") {
			string $moreChildren[] = `listRelatives -c -s -f $nstroke`;
			string $anotherChild;
			for ( $anotherChild in $moreChildren ) {
				if ( nodeType( $anotherChild ) == "stroke") {
					$strokes[$sIdx] = $anotherChild;
					++$sIdx;
				}
			}
		}
		else {
			if (nodeType( $nstroke ) == "stroke") {
				$strokes[$sIdx] = $nstroke;
				++$sIdx;
			}
		}
	}
	string $cos[] = `listConnections -t curveFromSurfaceCoS ($node + ".ws[0]")`;
	string $cs;
	for( $cs in $cos ) {
		$nstrokes = `listConnections -t stroke ($cs + ".oc")`;
		for( $nstroke in $nstrokes ) {
			if (nodeType( $nstroke ) == "transform") {
				string $moreChildren[] = `listRelatives -c -s -f $nstroke`;
				string $anotherChild;
				for ( $anotherChild in $moreChildren ) {
					if ( nodeType( $anotherChild ) == "stroke") {
						$strokes[$sIdx] = $anotherChild;
						++$sIdx;
					}
				}
			}
			else {
				if (nodeType( $nstroke ) == "stroke") {
					$strokes[$sIdx] = $nstroke;
					++$sIdx;
				}
			}
		}
	}
	return( $sIdx );
}

global proc string[] getStrokes( int $filter )
{
	string $selectionList[] = `ls -sl -l`;
	string $selection;
	string $strokes[];
	int    $sIdx = 0;
	string $children[];
	string $child;

	for ($selection in $selectionList) {
		clear( $children );
		if (`nodeType $selection` == "transform") {
			$children = `listRelatives -c -s -f $selection`;
		}
		else {
			$children[0] = $selection;
		}

		for ($child in $children) {
			if ($filter > 1) {
				// Check for a surfaces and get all COS's.
				if (`nodeType $child` == "nurbsSurface") {
					string $cos[] = `listRelatives $child`;
					string $cs;
					for ( $cs in $cos ) {
						if (`nodeType $cs` == "transform") {
							string $moreChildren[] = `listRelatives -c -s -f $child`;
							string $anotherChild;
							for ( $anotherChild in $moreChildren ) {
								if (`nodeType $anotherChild` == "nurbsCurve") {
									$sIdx = addFromCurves( $anotherChild, $strokes, $sIdx );
								}
							}
						}
						else {
							if (`nodeType $cs` == "nurbsCurve") {
								$sIdx = addFromCurves( $cs, $strokes, $sIdx );
							}
						}
					}
				}
			}
			if ($filter > 0) {
				if (`nodeType $child` == "nurbsCurve") {
					$sIdx = addFromCurves( $child, $strokes, $sIdx );
				}
			}
			if (`nodeType $child` == "stroke") {
				$strokes[$sIdx] = $child;
				++$sIdx;
			}
		}
	}

	string $returnStrokes[];
	int    $strokeSize = size( $strokes );
	if ( $strokeSize != 0) {
		// Now filter out any duplicates.
		string $sortedStrokes[] = `sort $strokes`;
		int $i;
		int $idx = 0;
		$returnStrokes[ $idx ] = $sortedStrokes[ 0 ];
		for ($i = 1; $i < $strokeSize; ++$i) {
			if ($sortedStrokes[ $i ] != $returnStrokes[ $idx ]) {
				// It is a unique entry.
				++$idx;
				$returnStrokes[ $idx ] = $sortedStrokes[ $i ];
			}
		}
		if ( $returnStrokes[0] != $strokes[0] ) {
			// We have changed the lead stroke.
			for ($i = 1; $i < $strokeSize; ++$i) {
				// Find the lead stroke in the unique array.
				if ( $returnStrokes[ $i ] == $strokes[0] ) {
					// Found it.
					$strokes[0]          = $returnStrokes[ 0 ];
					$returnStrokes[ 0 ]  = $returnStrokes[ $i ];
					$returnStrokes[ $i ] = $strokes[0];
					$strokes[0]          = $returnStrokes[ 0 ];
					break;
				}
			}
		}
		int $lastStroke = $strokeSize - 1;
		if ( $returnStrokes[$idx] != $strokes[$lastStroke] ) {
			// We have changed the last selected stroke.
			for ($i = 0; $i < $lastStroke; ++$i) {
				// Find the lead stroke in the unique array.
				if ( $returnStrokes[ $i ] == $strokes[$lastStroke] ) {
					// Found it.
					$strokes[$lastStroke] = $returnStrokes[ $idx ];
					$returnStrokes[ $idx ]  = $returnStrokes[ $i ];
					$returnStrokes[ $i ] = $strokes[$lastStroke];
					break;
				}
			}
		}
	}

	return ( $returnStrokes );
}

// New functions used in UV Linking of PFX strokes

global proc string pfxGetUVNameOfStroke(string $strokeObj, string $polyShapeObj)
{
	string $relatedItem;
	string $allAttr[] = `listAttr -m -st "uvSetName" $strokeObj`;

	for( $nCount = 0; $nCount < size($allAttr); $nCount++ )
	{
		string $strName = $strokeObj + "." + $allAttr[$nCount];
		string $allPolyUVAttr[] = `listAttr -m -st "uvSetName" $polyShapeObj`;

		for( $i =0; $i < size($allPolyUVAttr); $i++ )
		{
			string $polyUVAttr = $polyShapeObj +"."+$allPolyUVAttr[$i] ;

			if(`isConnected $polyUVAttr $strName`)
			{
				$relatedItem = $polyUVAttr;
				return $relatedItem;
			}
		}
	}
	return $relatedItem;
}


global proc string[] pfxGetUVAttachedStrokes(string $polyObj)
{
	string $uvSetList[] = `listAttr -m -st uvSet $polyObj`;

	int $sizeOfList = size($uvSetList);

	string $allUVStrokes[];
	int $index = 0;

	for($k = 0; $k < $sizeOfList; $k++)
	{
		string $uvAttr = $polyObj + "." + $uvSetList[$k] + ".uvSetName";
		string $attachedObjects[] = `listConnections -sh 1 $uvAttr`;

		for($l = 0; $l < size($attachedObjects); $l++)
		{
			if(size($attachedObjects[$l]) && (`nodeType $attachedObjects[$l]` == "stroke")) // if it is a stroke
			{
				$allUVStrokes[$index] = $attachedObjects[$l];
				$index ++;
			}
		}
	}
	return $allUVStrokes;
}

proc string[] pfxGetAllAttachedStrokes(string $polyObj)
{
	string $allStrokes[];

	string $strokes[] = `ls -type stroke`;
	int $index = 0;

	for($k = 0; $k < size($strokes); $k++)
	{
		string $singleStroke = $strokes[$k];

		string $strokeAttr = $singleStroke + ".pathCurve";
		string $comm[] = `listConnections $strokeAttr`;

		for($i = 0; $i < size($comm); $i++)
		{
			// Check if it is curveFromMeshCoM obj
			if(`nodeType $comm[$i]` == "curveFromMeshCoM")
			{
				string $shapes[] = `listConnections -sh 1 ($comm[$i] + ".inputMesh")`;

				if($shapes[0] == $polyObj)
				{
					$allStrokes[$index] = $singleStroke;
					$index ++;
				}
			}
		}
	}
	return $allStrokes;
}

// This function first checks if the strokes attached to Poly
// has its uvSetName connected to poly's or not.
// If there is no connection, then a default connection is
// made. This situation occurs when a UVSet is deleted from
// the relationship Editor.

global proc string[] updateStrokePolyConnections(string $polyObj, string $strokeObj)
{
	string $allUVStrokes[] = pfxGetUVAttachedStrokes($polyObj);

	if(size($allUVStrokes))
		return $allUVStrokes;

	string $allStrokes[] = pfxGetAllAttachedStrokes($polyObj);

	// Make default connection with all the strokes
	int $nCount;
	string $polyObjAttr = $polyObj + ".uvSet[0].uvSetName";

	for($nCount=0; $nCount < size($allStrokes); $nCount++)
	{
		string $uvAttrStr = $allStrokes[$nCount] + ".pathCurve";
		string $uvsList[] = `listConnections $uvAttrStr`;

		string $strokeUVAttr;
		$uvAttrStr = $allStrokes[$nCount] + ".uvSetName";

		for($j = 0; $j < size($uvsList); $j ++)
		{
			$strokeUVAttr = ($uvAttrStr + "[" + $j + "]");
			string $attrExists[] = `listConnections $strokeUVAttr`;

			if(!size($attrExists)) // no connection, make one
			{
				connectAttr $polyObjAttr $strokeUVAttr;
				break;
			}
		}

	}
	return $allStrokes;
}

global proc string getStrokeUVFromPoly(string $polyObj)
{
	string $uvSetList[] = `listAttr -m -st uvSet $polyObj`;
	int $sizeOfList = size($uvSetList);

	if($sizeOfList == 1) // if there is only one UVSet, return it.
	{
		string $currentUVSet[] = `polyUVSet -q -currentUVSet $polyObj`;
		return $currentUVSet[0];
	}

	for($k = 0; $k < $sizeOfList; $k++)
	{
		string $uvAttr = $polyObj + "." + $uvSetList[$k] + ".uvSetName";

		string $attachedObjects[] = `listConnections -sh 1 $uvAttr`;

		for($l = 0; $l < size($attachedObjects); $l++)
		{
			if(size($attachedObjects[$l]) && (`nodeType $attachedObjects[$l]` == "stroke")) // if it is a stroke
			{
				string $curSet = `getAttr $uvAttr`;
				return $curSet; // also $k is the index of UVSet
			}
		}
	}

	string $currentUVSet[] = `polyUVSet -q -currentUVSet $polyObj`;
	return $currentUVSet[0];
}


global proc int getMapIdFromUVSetName(string $polyObj, string $uvSetName)
{

	int $indices[] = `polyUVSet -q -allUVSetsIndices $polyObj`;

	for( $i in $indices )
	{

		string $name = `getAttr ($polyObj + ".uvSet["+$i+"].uvSetName")`;
		if($uvSetName == $name)
		{
			return $i;
		}

	}
	
	return -1;

}
