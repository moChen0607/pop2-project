// Copyright (C) 1997-2014 Autodesk, Inc., and/or its licensors.
// All rights reserved.
//
// The coded instructions, statements, computer programs, and/or related
// material (collectively the "Data") in these files contain unpublished
// information proprietary to Autodesk, Inc. ("Autodesk") and/or its licensors,
// which is protected by U.S. and Canadian federal copyright law and by
// international treaties.
//
// The Data is provided for use exclusively by You. You have the right to use,
// modify, and incorporate this Data into other products for purposes authorized 
// by the Autodesk software license agreement, without fee.
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND. AUTODESK
// DOES NOT MAKE AND HEREBY DISCLAIMS ANY EXPRESS OR IMPLIED WARRANTIES
// INCLUDING, BUT NOT LIMITED TO, THE WARRANTIES OF NON-INFRINGEMENT,
// MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE, OR ARISING FROM A COURSE 
// OF DEALING, USAGE, OR TRADE PRACTICE. IN NO EVENT WILL AUTODESK AND/OR ITS
// LICENSORS BE LIABLE FOR ANY LOST REVENUES, DATA, OR PROFITS, OR SPECIAL,
// DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES, EVEN IF AUTODESK AND/OR ITS
// LICENSORS HAS BEEN ADVISED OF THE POSSIBILITY OR PROBABILITY OF SUCH DAMAGES.

global int    $gUseBlendBrush = 0;
global int	  $gIsPost5Preset = true;
global int	  $gIsPost7Preset = true;
global int	  $gIsPreCurlPreset = false;
global int	  $gHasADefinedTextureFlowValueFalse = false;


global proc setBrushRampAttrToSingle( string $node, string $at, float $val )
{
	setAttr (($node + "." + $at + "[0]." + $at + "_Position"), 0.0 );
	setAttr (($node + "." + $at + "[0]." + $at + "_FloatValue"), $val );
	setAttr (($node + "." + $at + "[0]." + $at + "_Interp"), 1 );
}

global proc
setPost7BrushDefaults( string $brush )
{
	string $b = ($brush + ".");

	setAttr ($b+"occlusionWidthScale") false;
	setAttr ($b+"edgeClip") false;
	setAttr ($b+"edgeClipDepth") 0.1;
	setAttr ($b+"distanceScaling") 0.0;
	setAttr ($b+"minPixelWidth") 0.0;
	setAttr ($b+"maxPixelWidth") 1000.0;
	setAttr ($b+"lightingBasedWidth") 0.0;
	setAttr ($b+"leafLocation") 0;
	setAttr ($b+"flowerLocation") 0;
}

global proc
setPreCurlBrushDefaults( string $brush )
{
	global int $gHasADefinedTextureFlowValueFalse;
	
	string $b = ($brush + ".");
	setBrushRampAttrToSingle( $brush, "leafCurl", 0.5 );
	setBrushRampAttrToSingle( $brush, "petalCurl", 0.5 );
	if ($gHasADefinedTextureFlowValueFalse)
		setAttr ($b+"textureFlow") false;
	else
		setAttr ($b+"textureFlow") true;

	setPost7BrushDefaults( $brush );
}

global proc
setPost5BrushDefaults( string $brush )
{
	string $b = ($brush + ".");
	setAttr ($b+"thornSpecular") 0.4;
	setAttr ($b+"thornBaseColorR") 0.5;
	setAttr ($b+"thornBaseColorG") 0.5;
	setAttr ($b+"thornBaseColorB") 0.5;
	setAttr ($b+"thornTipColorR") 0.5;
	setAttr ($b+"thornTipColorG") 0.5;
	setAttr ($b+"thornTipColorB") 0.5;
	setAttr ($b+"branchReflectivity") 0.0;
	setAttr ($b+"leafReflectivity") 0.0;
	setAttr ($b+"flowerReflectivity") 0.0;
	setAttr ($b+"mapDisplacement") false;
	setAttr ($b+"displacementScale") 1.0;
	setAttr ($b+"displacementOffset") 0.0;
	setAttr ($b+"bumpIntensity") 1.0;
	setAttr ($b+"bumpBlur") 0.5;
	setAttr ($b+"luminanceIsDisplacement") true;
	setAttr ($b+"twigStiffness") 0.5;
	setAttr ($b+"leafBend") 0.0;
	setAttr ($b+"leafTwirl") 0.0;
	setAttr ($b+"leafStiffness") 0.5;
	float $spec = `getAttr ($b + "specular")`;
	setAttr ($b+"leafSpecular") $spec;
	setAttr ($b+"petalBend") 0.0;
	setAttr ($b+"petalTwirl") 0.0;
	setAttr ($b+"flowerStiffness") 0.5;
	setAttr ($b+"flowerSpecular") $spec;
	setAttr ($b+"bend") 0.0;
	setAttr ($b+"bendBias") 0.0;	
	setAttr ($b+"forwardTwist") false;	
	setAttr ($b+"leafForwardTwist") false;	
	setAttr ($b+"petalForwardTwist") false;	
	setAttr ($b+"endCaps") false;	
	setAttr ($b+"hardEdges") false;	
	setAttr ($b+"branchAfterTwigs") false;	
	setBrushRampAttrToSingle( $brush, "reflectionRolloff", 1.0 );
	setBrushRampAttrToSingle( $brush, "widthScale", 1.0 );
	setBrushRampAttrToSingle( $brush, "leafWidthScale", 1.0 );
	setBrushRampAttrToSingle( $brush, "petalWidthScale", 1.0 );
	setBrushRampAttrToSingle( $brush, "twigLengthScale", 1.0 );
	setAttr ($b + "environment[0].environment_Position") 0.2;
	setAttr ($b + "environment[0].environment_Interp") 1;
	setAttr ($b + "environment[0].environment_ColorR") 0;
	setAttr ($b + "environment[0].environment_ColorG") 0;
	setAttr ($b + "environment[0].environment_ColorB") 0.15;

	setAttr ($b + "environment[1].environment_Position") 0.5;
	setAttr ($b + "environment[1].environment_Interp") 1;
	setAttr ($b + "environment[1].environment_ColorR") 0.48;
	setAttr ($b + "environment[1].environment_ColorG") 0.55;
	setAttr ($b + "environment[1].environment_ColorB") 0.7;

	setAttr ($b + "environment[2].environment_Position") 1.0 ;
	setAttr ($b + "environment[2].environment_Interp") 1 ;
	setAttr ($b + "environment[2].environment_ColorR") 0.0 ;
	setAttr ($b + "environment[2].environment_ColorG") 0.1 ;
	setAttr ($b + "environment[2].environment_ColorB") 0.45 ;
	setPreCurlBrushDefaults( $brush );

}

global proc
brushPresetApply()
{
	global string $gPresetBlenderBrush;
	global int    $gUseBlendBrush;
	global float  $gPresetBrushShadeBlend;
	global float  $gPresetBrushShapeBlend;
	global int	  $gIsPost5Preset;
	global int	  $gIsPost7Preset;
	global int	  $gIsPreCurlPreset;
	global string $gPresetTargetBrush;

	global string $gCreatorWireCtx;
	if ( $gCreatorWireCtx == "" ) 
	{
		warning ( (uiRes("m_brushPresetSetup.kPaintEffectsNotLoaded")));
		return;
	}

	if( !$gIsPost7Preset ){
		if( !$gIsPost5Preset ){
			setPost5BrushDefaults( $gPresetTargetBrush );
		} else if( $gIsPreCurlPreset ){
			setPreCurlBrushDefaults( $gPresetTargetBrush );
		}  else {
			setPost7BrushDefaults( $gPresetTargetBrush );
		}
	}

	if( $gUseBlendBrush )
	{
		string $defBrush = getDefaultBrush();
		blendBrushAttributes(  $gPresetBlenderBrush, $defBrush, $defBrush,
							$gPresetBrushShadeBlend, $gPresetBrushShapeBlend );
	}

	string	$visiblePanels[] = `getPanel -vis`;
	string	$panel;

	for ($panel in $visiblePanels)
	{
		if ($panel == "dynPaintScriptedPanel" )
		{
			int $canvasMode;
			$canvasMode = `dynPaintEditor -q -canvasMode "dynPaintScriptedPanelEd"`;

			if($canvasMode)
			{
				int $isTubeDirectionForced;
				float $minElevation;
				string $brush;

				$brush = getDefaultBrush();

				$isTubeDirectionForced = `getAttr strokeGlobals.forceTubeDirAlongPath`;
				$minElevation = `getAttr ($brush + ".elevationMin")`;

				if($isTubeDirectionForced && ($minElevation > 0.5))
				{
				    setAttr ($brush + ".tubeDirection") 1;
				}
			}
			break;
		}
	}

  	// If we are in the 3d Paint Context, set the proper flag.
  	string $currContext = `currentCtx`;
  	string $currentTool = `contextInfo -c $currContext`; 
      if ( $currentTool == "art3dPaint" ) {
        // Set the paint effects brush mode.
		// Bug #182484

        art3dPaintCtx -e -brushtype "effectsBrush" $currContext;
  		art3dPaintEffectsBrushCallback( "art3dPaintCtx" );
  	}
}

global proc
bPsetNewNodeName( string $nodeName )
{
	global string $gPresetNewNode;

	$gPresetNewNode = $nodeName;
}

// Return the name of the new node.
global proc string
bPNewNodeName( )
{
	global string $gPresetNewNode;
	return $gPresetNewNode;
}

global proc
bPsetName( string $attr, string $val ) 
{
	global string $gPresetTargetBrush;

	string $atName = $gPresetTargetBrush + "." + $attr;
	setAttr -type "string" $atName $val;

}

global proc
bPsetNotes( string $attr, string $val ) 
{
	global string $gPresetTargetBrush;

	string $atName = $gPresetTargetBrush + "." + $attr;
	if(!objExists( $atName ) ){
		if( catch(`addAttr -dt "string" -ln "notes" -sn "nts"  $gPresetTargetBrush` )) {
			string $fmt = (uiRes("m_brushPresetSetup.kCouldNotCreateDynAttr"));
			error( `format -s $atName $fmt` );
		}
	}		
	setAttr -type "string" $atName $val;
}

global proc
bPset( string $attr, float $val ) 
{
	global string $gPresetTargetBrush;
	global int	  $gIsPost5Preset;
	global int	  $gIsPost7Preset;
	global int	  $gIsPreCurlPreset;
	global int	  $gHasADefinedTextureFlowValueFalse;

	// We use one of the newly added attributes to flag
	// that this is a post maya 5.0 preset.
	if( $attr == "edgeClip" ){
		$gIsPost7Preset = true;
	} else  if( $attr == "bend" ){
		$gIsPost5Preset = true;
	} else if( $attr == "leafCurl" || $attr == "petalCurl" ){
		//  initial version of curl did not use ramps and
		//  thus would get direct calls rather than array indexed calls
		$gIsPreCurlPreset = true;
		return; // the attribute type is now a multi so we don't want to set it
	} else if ( $attr == "textureFlow" ){
		//Check if textureFlow 
		if ($val == 0) 
			$gHasADefinedTextureFlowValueFalse = true;
	}
	string $atName = $gPresetTargetBrush + "." + $attr;
	setAttr $atName $val;


}

global proc
bPsetConnect( string $source, string $dest )
{
	global string $gPresetTargetBrush;
	global string $gPresetNewNode;

	string $atName = $gPresetTargetBrush + "." + $dest;
	string $sName = $gPresetNewNode + "." + $source;
	connectAttr -f $sName $atName ;
}

proc int isAdynPaintPanel()
{
    string $currentPanel = `getPanel -withFocus`;
    return ( `scriptedPanel -ex $currentPanel` &&
    		 `scriptedPanel -q -type $currentPanel` == "dynPaintScriptedPanelType");
}

global proc
clearBrushMultiAttributes( string $brush){
	// clear multi attributes.. namely ramp attributes
	// This code is cloned from startAttrPreset.mel.. we may wish
	// to directly specify ramp attrs by name instead of deleting all multi attrs
	string $multies[] = `attributeInfo -m 1 -and -w 1 -and -h 0 $brush`;
	string $mult;
	for ($mult in $multies ){
		string $nodeName = $brush +"."+$mult;
		if( objExists( $nodeName ) ){
			int $i, $size;
			string $entries[] = `listAttr -m -st $mult $brush`;
			$size = size( $entries );
			// do this in reverse order because the widget wants to
			// reconnect to the lowest index when its attr is deleted out
			// from under it, so we don't want it to keep reconnecting all the time
			for( $i = $size -1; $i >= 0; $i-- ){
				string $multiName = $brush + "." + $entries[$i];
				int $doDelete = 1;

				// Commented following out..we delete even if connected
				/*
				string $atrs[] = `listAttr -s $multiName`;
				if( size( $atrs ) > 0 ){
					for ($atr in $atrs) 
					{
						string $attrName = $brush + "." + $atr;
						if( !objExists( $attrName )
						|| `connectionInfo -id $attrName`
						|| `connectionInfo -is $attrName`
		 				|| `connectionInfo -il $attrName`){
						// only delete if no children are connected or
						// locked
							$doDelete = 0;
							break;
						}
					}
				} else {
					$doDelete = 0;
				}
				*/

				if( $doDelete ){
					removeMultiInstance $multiName;	
				} 
			}
		}
	}
}

global proc
brushPresetSetup()
{
	global string $gPresetTargetBrush;
	global string $gPresetBlenderBrush;
	global int    $gUseBlendBrush;
	global int    $gPresetBlending;
	global float  $gPresetBrushShadeBlend;
	global float  $gPresetBrushShapeBlend;
	global string $gCreatorWireCtx;
	global int	  $gIsPost5Preset;
	global int	  $gIsPost7Preset;
	global int	  $gIsPreCurlPreset;
	global int	  $gHasADefinedTextureFlowValueFalse;

	$gIsPost5Preset = false;
	$gIsPost7Preset = false;
	$gIsPreCurlPreset = false;
	$gHasADefinedTextureFlowValueFalse = false;
	if( $gPresetBlending && ($gPresetBrushShadeBlend < .999 || $gPresetBrushShapeBlend < .999) )
	{
		$gUseBlendBrush = 1;
		if( !objExists( $gPresetBlenderBrush ))
		{
			$gPresetBlenderBrush = `createNode "brush" -n $gPresetBlenderBrush`;
		}
		$gPresetTargetBrush = $gPresetBlenderBrush;
	}
	else
	{
		$gUseBlendBrush = 0;
		$gPresetTargetBrush = getDefaultBrush();

		// clear ramp attributes
		clearBrushMultiAttributes( $gPresetTargetBrush );

		// remove existing notes
		string $atName = $gPresetTargetBrush + ".notes";
		if(objExists( $gPresetTargetBrush + ".notes" ) ){
			if( catch(`deleteAttr -at "notes" $gPresetTargetBrush`) ) {
				string $fmt = (uiRes("m_brushPresetSetup.kCouldNotDeleteDynAttrNotes"));
				error( `format -s $gPresetTargetBrush $fmt` );
			}
		}		

		// Go through all attributes on the default brush and break any connections so that we
		// can do the setAttrs properly.
		string $atrs[] = `listAttr -k -w -s -m $gPresetTargetBrush`;
		string $atr;
		for ($atr in $atrs) 
		{
			string $obj = ($gPresetTargetBrush +"." + $atr);
			if( objExists( $obj ) ){
				if ( `connectionInfo -isDestination $obj` ) {
					// It is a destination of a connection.
					// Get all nodes connected to this brush attr "$gPresetTargetBrush.atr"
					string $connections[] = `listConnections $obj`;
					string $connection;
	
					// For every node connected to this attribute.
					for ($connection in $connections) {
						if (`nodeType $connection` != "time") { // Do not attempt to break the time node connection.
							disconnectAttr `connectionInfo -sfd $obj` $obj;
						}
					}
				}
			}
		}
	}
	
	// select the Paint Effects tool
	//
	if ($gCreatorWireCtx == "") {
		warning ( uiRes("m_brushPresetSetup.kPaintEffectsNotLoaded") );
	} else {
		string $currContext = `currentCtx`;
		string $currentTool = `contextInfo -c $currContext`;
		if ( ($currentTool != "art3dPaint") || isAdynPaintPanel() ) {
			if ( `licenseCheck -m "edit" -typ "particlePaint"`) {
				setToolTo $gCreatorWireCtx;
			}
		}
		else {
			if ( $currentTool == "art3dPaint") { 
				art3dPaintCtx -e -brushtype "effectsBrush" `currentCtx`;
				art3dPaintCtx -e -stampProfile "paintEffects" `currentCtx`;
			}
		}
	}
}
