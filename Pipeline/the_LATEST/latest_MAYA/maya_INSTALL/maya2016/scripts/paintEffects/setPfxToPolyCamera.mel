// Copyright (C) 1997-2014 Autodesk, Inc., and/or its licensors.
// All rights reserved.
//
// The coded instructions, statements, computer programs, and/or related
// material (collectively the "Data") in these files contain unpublished
// information proprietary to Autodesk, Inc. ("Autodesk") and/or its licensors,
// which is protected by U.S. and Canadian federal copyright law and by
// international treaties.
//
// The Data is provided for use exclusively by You. You have the right to use,
// modify, and incorporate this Data into other products for purposes authorized 
// by the Autodesk software license agreement, without fee.
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND. AUTODESK
// DOES NOT MAKE AND HEREBY DISCLAIMS ANY EXPRESS OR IMPLIED WARRANTIES
// INCLUDING, BUT NOT LIMITED TO, THE WARRANTIES OF NON-INFRINGEMENT,
// MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE, OR ARISING FROM A COURSE 
// OF DEALING, USAGE, OR TRADE PRACTICE. IN NO EVENT WILL AUTODESK AND/OR ITS
// LICENSORS BE LIABLE FOR ANY LOST REVENUES, DATA, OR PROFITS, OR SPECIAL,
// DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES, EVEN IF AUTODESK AND/OR ITS
// LICENSORS HAS BEEN ADVISED OF THE POSSIBILITY OR PROBABILITY OF SUCH DAMAGES.

//
//<doc>
//<name setPfxToPolyCamera>
//<owner "Internal">
//
//<synopsis>
//	setPfxToPolyCamera cameraName selectedPaintEffectsOnly 
//
//<returns>
//  None.
//
//<description>
//  Set the camera to use for paint effects or toon elements that are 
//  converted to poly. Some paint effects items adjust to the current viewpoint.
//  For example toon profile lines, or brushes with forwardTwist on. For
//  normal paint effects redraw and render paint effects knows the current view
//  being rendered, and thus has access to the current camera. However for paint effects
//  converted to poly( or nurbs ) the evaluation of the output mesh is done outside
//  the context of a render or draw, thus we need to explicitly connect a camera to
//  the paint effects node( stroke, pfxToon, or pfxHair nodes). This routine
//  allows one to set the camera after one has done paint effects or toon to polygons.
//  Technically this routine connects to or sets the cameraPoint attribute on the paint
//  effects node.
//
//<flags>
//	string cameraName: The name of the camera to set the paint effects elements for.
//	int selectedPaintEffectsOnly: If true then applied to all selected paint effects, otherwise 
//  to all paint effects that have been converted to polygons.
//
//<examples>
//  setPfxToPolyCamera persp1 true;
//  setPfxToPolyCamera top false;
//</doc>



proc int isViewDependantPfxToPoly( string $pfx )
{
	// first confirm that there is an output mesh connection
	string $cons[] = `listConnections -s false -type mesh $pfx`;
	if( size($cons) < 1 ){
		$cons = `listConnections -s false -type nurbsCurve $pfx`;
		if( size($cons) < 1 ){
			$cons = `listConnections -s false -type loft $pfx`;
			if( size($cons) < 1 ){
				return false;
			}
		}
	}
	string $nodeType = nodeType( $pfx );
	if( $nodeType == "pfxToon" ){
		int	$profile = getAttr( $pfx + ".profileLines" );
		if( $profile == 1 ){
			return true;
		}
		if( getAttr( $pfx + ".screenspaceWidth" ) ){
			return true;
		}
	}
	$cons = `listConnections -type brush ($pfx + ".brush")`;
	if( size($cons) > 0){
		string $brush = $cons[0];
		if( getAttr( $brush + ".screenspaceWidth" ) ){
			return true;
		}
		if( getAttr( $brush + ".forwardTwist" ) ){
			return true;
		}
		if( getAttr( $brush + ".tubes" ) ){
			if( getAttr( $brush + ".leaves" ) ){
				if( getAttr( $brush + ".leafForwardTwist" ) ){
					return true;
				}
			}
			if( getAttr( $brush + ".flowers" ) ){
				if( getAttr( $brush + ".petalForwardTwist" ) ){
					return true;
				}
			}
		}
	}
	return false;
}

global proc setPfxToPolyCamera( string $camera, int $selectedOnly )
{
	
	if( !objExists( $camera + ".orthographic" ) ){
		string $fmt = (uiRes("m_setPfxToPolyCamera.kNotACamera"));
		warning( `format -s $camera $fmt` );
		return;
	}

	string $pfxGeom[];
	if( $selectedOnly ) {
		$pfxGeom = `ls -sl -dag -type pfxGeometry`;
		string $objs[] = `ls -sl -dag -leaf -type mesh -type nurbsCurve`;
		string $obj;
		for( $obj in $objs ){
		// append pfx elements indirectly selected through pfx to poly or curve geometry
			string $cons[] = `listConnections -type pfxGeometry $obj`;
			if( size( $cons ) > 0 ){
				$pfxGeom[size($pfxGeom)] = $cons[0];
			}	
		}
		$objs = `ls -sl -dag -type nurbsSurface`;
		for( $obj in $objs ){
		// append pfx elements indirectly selected through pfx to nurbs geometry
			string $cons[] = `listConnections -type loft $obj`;
			if( size( $cons ) > 0 ){
				$cons = `listConnections -type pfxGeometry $cons[0]`;
				if( size( $cons ) > 0 ){
					$pfxGeom[size($pfxGeom)] = $cons[0];
				}
			}	
		}
		$pfxGeom = stringArrayRemoveDuplicates( $pfxGeom );
		if( size( $pfxGeom ) < 1 ){
			warning( (uiRes("m_setPfxToPolyCamera.kNoPfxGeomSelected")));
			return;
		}
	} else {
		$pfxGeom = `ls -dag -type pfxGeometry`;
		if( size( $pfxGeom ) < 1 ){
			warning( (uiRes("m_setPfxToPolyCamera.kNoPfxGeom")));
			return;
		}
	}
	string $pfx;
	string $cameraTranslate = "";
	if( getAttr( $camera + ".orthographic") ){
		float $orthoCenter[]  = getAttr( $camera + ".center" );	
		// set the camera point to a large value down the
		// ortho axis... not perfect but better than having
		// it at the origin	
		$orthoCenter[0] *= 1000.0;
		$orthoCenter[1] *= 1000.0;
		$orthoCenter[2] *= 1000.0;
		for( $pfx in $pfxGeom ){
			string $camAt = ($pfx + ".cameraPoint");
			string $oldCon = `connectionInfo -sfd $camAt`;	
			if( size( $oldCon ) > 0 ){
				disconnectAttr $oldCon $camAt;
			}
			setAttr $camAt $orthoCenter[0] $orthoCenter[1] $orthoCenter[2];
		}
		return;
	} else {	
		// for persp cameras we connect the camera translate to the stroke
		string $transStr = $camera + ".translate";
		if(`objExists $transStr`) {
			$cameraTranslate = $transStr;
		} else {
			return;
		}
	}
	
	for( $pfx in $pfxGeom ){
		string $cp = $pfx + ".cameraPoint";
		string $cons[] = `listConnections $cp`;
		if( $selectedOnly || size($cons) > 0 || isViewDependantPfxToPoly( $pfx ) ){
			if( !`isConnected $cameraTranslate $cp` ){
				connectAttr -f $cameraTranslate $cp;
			}
		}
	}
}
