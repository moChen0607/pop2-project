// Copyright (C) 1997-2014 Autodesk, Inc., and/or its licensors.
// All rights reserved.
//
// The coded instructions, statements, computer programs, and/or related
// material (collectively the "Data") in these files contain unpublished
// information proprietary to Autodesk, Inc. ("Autodesk") and/or its licensors,
// which is protected by U.S. and Canadian federal copyright law and by
// international treaties.
//
// The Data is provided for use exclusively by You. You have the right to use,
// modify, and incorporate this Data into other products for purposes authorized 
// by the Autodesk software license agreement, without fee.
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND. AUTODESK
// DOES NOT MAKE AND HEREBY DISCLAIMS ANY EXPRESS OR IMPLIED WARRANTIES
// INCLUDING, BUT NOT LIMITED TO, THE WARRANTIES OF NON-INFRINGEMENT,
// MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE, OR ARISING FROM A COURSE 
// OF DEALING, USAGE, OR TRADE PRACTICE. IN NO EVENT WILL AUTODESK AND/OR ITS
// LICENSORS BE LIABLE FOR ANY LOST REVENUES, DATA, OR PROFITS, OR SPECIAL,
// DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES, EVEN IF AUTODESK AND/OR ITS
// LICENSORS HAS BEEN ADVISED OF THE POSSIBILITY OR PROBABILITY OF SUCH DAMAGES.

//
//
//  Creation Date: 2005 
//
//
//
//  Description:
//      This implements the assignToonShader proc
//
//
//  Input Arguments:
//      shaderName
//
//  Return Value:
//      None.
//

proc string getCurrentShader(string $nType)
{
	// look for the most recently created shader of this type
	// well, ok, any node type, but we're looking for shaders
	string $filter = `itemFilter  -bt $nType -classification "builtIn"`;
	string $shaders[] = `lsThroughFilter -na -so "byTime" -reverse 1 $filter`;
	delete $filter;
	if( size( $shaders ) > 0 ){
		return $shaders[0];
	}
	return "";
}
proc basicRampSetup( string $shader )
{
	setAttr ($shader + ".specularity") 0;
	setAttr ($shader + ".colorInput") 2;
	setAttr ($shader + ".diffuse") 0.5;
	setAttr ($shader + ".translucence") 0.25;
	setAttr ($shader + ".translucenceDepth") 1000;
	setAttr ($shader + ".color[0].color_Interp") 0;
	setAttr ($shader + ".color[1].color_Position") 0.5;
	setAttr ($shader + ".color[1].color_Color") -type double3 1 1 1;
	setAttr ($shader + ".color[1].color_Interp") 0;
	setAttr ($shader + ".outColor") -type double3 1 1 1 ;
	setAttr ($shader + ".reflectivity[0].reflectivity_FloatValue") 0;
}

global proc assignToonShader( string $shaderName )
{
	//TOON_TODO: ASSIGN AND CREATE SHADERS
	string $fmt = (uiRes("m_assignToonShader.kAssignShader"));
	print( `format -s $shaderName $fmt` );
	if( $shaderName == "solid" ){
		createAndAssignShader surfaceShader "";
		$shader = getCurrentShader( "surfaceShader" );
		if($shader != "" ){
			setAttr ($shader + ".outColor") -type double3 1 1 1 ;
			rename $shader ($shaderName + "Shader");
		}
	} else if( $shaderName == "lightAngle" ){
		createAndAssignShader rampShader "";
		$shader = getCurrentShader( "rampShader" );
		if($shader != "" ){
			basicRampSetup( $shader );
			setAttr ($shader + ".colorInput") 0;
			setAttr ($shader + ".diffuse") 0;
			setAttr ($shader + ".translucence") 1;
			rename $shader ($shaderName + "Shader");
		}
	} else if( $shaderName == "shadedBrightness" ){
		createAndAssignShader rampShader "";
		$shader = getCurrentShader( "rampShader" );
		if($shader != "" ){
			basicRampSetup( $shader );
			setAttr ($shader + ".diffuse") 1;
			setAttr ($shader + ".translucence") 0;
			rename $shader ($shaderName + "Shader");
		}
	} else if( $shaderName == "threeToneBrightness" ){
		createAndAssignShader rampShader "";
		$shader = getCurrentShader( "rampShader" );
		if($shader != "" ){
			basicRampSetup( $shader );
			setAttr ($shader + ".diffuse") 1;
			setAttr ($shader + ".translucence") 0;

			setAttr ($shader + ".color[0].color_Color") -type double3 0.63 0.0736653 0.02331 ;
			setAttr ($shader + ".color[1].color_Color") -type double3 1 0.341086 0.311 ;

			setAttr ($shader + ".color[2].color_Interp") 0;
			setAttr ($shader + ".color[2].color_Color") -type double3 1 0.817299 0.684 ;
			setAttr ($shader + ".color[2].color_Position") 0.77;

			setAttr ($shader + ".specularColor[0].specularColor_Interp") 0;
			setAttr ($shader + ".specularColor[0].specularColor_Color") -type double3 0 0 0 ;
			setAttr ($shader + ".specularColor[1].specularColor_Color") -type double3 1 1 1 ;
			setAttr ($shader + ".specularColor[1].specularColor_Position") 0.96;
			setAttr ($shader + ".specularColor[1].specularColor_Interp") 0;
			setAttr ($shader + ".eccentricity") 0.5;

			rename $shader ($shaderName + "Shader");
		}
	} else if( $shaderName == "darkProfile" ){
		createAndAssignShader rampShader "";
		$shader = getCurrentShader( "rampShader" );
		if($shader != "" ){
			basicRampSetup( $shader );
			setAttr ($shader + ".color[0].color_Color") -type double3 0.8 0.8 0.8;
			setAttr ($shader + ".incandescence[0].incandescence_Interp") 0;
			setAttr ($shader + ".incandescence[0].incandescence_Color") -type double3 -0.6 -0.6 -0.6;
			setAttr ($shader + ".incandescence[1].incandescence_Interp") 0;
			setAttr ($shader + ".incandescence[1].incandescence_Position") 0.35;
			setAttr ($shader + ".incandescence[1].incandescence_Color") -type double3 0 0 0;
			rename $shader ($shaderName + "Shader");
		}
	} else if( $shaderName == "rimLight" ){
		createAndAssignShader rampShader "";
		$shader = getCurrentShader( "rampShader" );
		if($shader != "" ){
			basicRampSetup( $shader );
			setAttr ($shader + ".color[1].color_Color") -type double3 0.6 0.6 0.6;
			setAttr ($shader + ".color[0].color_Color") -type double3 0.2 0.2 0.2;
			setAttr ($shader + ".incandescence[0].incandescence_Color") -type double3 1 1 1;
			setAttr ($shader + ".incandescence[1].incandescence_Position") 0.35;
			setAttr ($shader + ".incandescence[1].incandescence_Color") -type double3 0 0 0;
			rename $shader ($shaderName + "Shader");
		}
	} else if( $shaderName == "circleHighlight" ){
		createAndAssignShader rampShader "";
		$shader = getCurrentShader( "rampShader" );
		if($shader != "" ){
			basicRampSetup( $shader );
			setAttr ($shader + ".color[0].color_Color") -type double3 0.6 0.3 0.3;
			setAttr ($shader + ".color[1].color_Color") -type double3 0.9 0.4 0.3;
			setAttr ($shader + ".color[1].color_Position") 0.6;
			setAttr ($shader + ".specularity") 1;
			setAttr ($shader + ".eccentricity") 0.5;
			setAttr ($shader + ".specularColor[0].specularColor_Interp") 0;
			setAttr ($shader + ".specularColor[0].specularColor_Color") -type double3 0 0 0;
			setAttr ($shader + ".specularColor[1].specularColor_Interp") 0;
			setAttr ($shader + ".specularColor[1].specularColor_Position") 0.93;
			setAttr ($shader + ".specularColor[1].specularColor_Color") -type double3 1 1 1;
			rename $shader ($shaderName + "Shader");
		}
	} else {
		string $warn = (uiRes("m_assignToonShader.kUnknownShader"));
		warning( `format -s $shaderName $warn` );
	}
}

