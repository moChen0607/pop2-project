// Copyright (C) 1997-2014 Autodesk, Inc., and/or its licensors.
// All rights reserved.
//
// The coded instructions, statements, computer programs, and/or related
// material (collectively the "Data") in these files contain unpublished
// information proprietary to Autodesk, Inc. ("Autodesk") and/or its licensors,
// which is protected by U.S. and Canadian federal copyright law and by
// international treaties.
//
// The Data is provided for use exclusively by You. You have the right to use,
// modify, and incorporate this Data into other products for purposes authorized 
// by the Autodesk software license agreement, without fee.
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND. AUTODESK
// DOES NOT MAKE AND HEREBY DISCLAIMS ANY EXPRESS OR IMPLIED WARRANTIES
// INCLUDING, BUT NOT LIMITED TO, THE WARRANTIES OF NON-INFRINGEMENT,
// MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE, OR ARISING FROM A COURSE 
// OF DEALING, USAGE, OR TRADE PRACTICE. IN NO EVENT WILL AUTODESK AND/OR ITS
// LICENSORS BE LIABLE FOR ANY LOST REVENUES, DATA, OR PROFITS, OR SPECIAL,
// DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES, EVEN IF AUTODESK AND/OR ITS
// LICENSORS HAS BEEN ADVISED OF THE POSSIBILITY OR PROBABILITY OF SUCH DAMAGES.

//
//
//  Creation Date: 99 
//
//
//  Description:
//		This command makes selected brushstrokes seamlessly
// 		loop brush turbulence and flowing gap animation
//


global proc loopBrushAnim( int $loopFrames, int $turbMult, int $flowMult )
{
	string $brushes[];
	string $timeUnit;
	int	   $i, $fps, $textured, $turbType;
	float $gapSpace, $gapSize, $repeatU, $flowSpeed, $turbSpeed;

	$timeUnit = `currentUnit -q -time`;	
	if( $timeUnit == "game" )
	{
		$fps = 15;
	}
	else if( $timeUnit == "film" )
	{
		$fps = 24;
	}
	else if( $timeUnit == "pal" )
	{
		$fps = 25;
	}
	else if( $timeUnit == "ntsc" )
	{
		$fps = 30;
	}
	else if( $timeUnit == "show" )
	{
		$fps = 48;
	}
	else if( $timeUnit == "palf" )
	{
		$fps = 50;
	}
	else if( $timeUnit == "ntscf" )
	{
		$fps = 60;
	}
	else
	{
		$fps = 1;
	}

	$turbSpeed = (float)($turbMult * 2.0 * $fps) / (float)$loopFrames;
	$brushes = getSelectedBrushes();
	for( $i = 0; $i < size( $brushes ); $i++ )
	{
		setAttr ($brushes[$i] + ".turbulenceSpeed") $turbSpeed;
		$gapSpace = `getAttr ($brushes[$i] + ".gapSpacing")`;
		$textured = ( `getAttr ($brushes[$i] + ".mapColor")`
		  			|| `getAttr ($brushes[$i] + ".mapOpacity")` );
		$gapSize = `getAttr ($brushes[$i] + ".gapSize")`;
		$repeatU = `getAttr ($brushes[$i] + ".repeatU")`;
		if( $textured && $repeatU != 0 )
		{
			if( $gapSize == 0 )
			{
				// no gaps, so base loop on texture coords
				$gapSpace = 1.0/$repeatU;
			}
			else
			{
				$tR = 1.0/$gapSize;
				if( $repeatU < $tR )
				{
					// texture repeat must be zero or the minimum gap size
					$repeatU = $tR;
				}
				else
				{
					// snap texture scale to the nearest multiple of the gap
					$repeatU = $tR * (float)((int)(0.5 + $repeatU/$tR));
				}
				setAttr ($brushes[$i] + ".repeatU") $repeatU;
			}
		}
		$flowSpeed = (float)$flowMult * (float)$fps * $gapSpace/(float)$loopFrames;
		setAttr ( $brushes[$i] + ".flowSpeed" ) $flowSpeed;
		setAttr ( $brushes[$i] + ".strokeTime" ) 0;
		setAttr ( $brushes[$i] + ".timeClip" ) 0;
		$turbType = `getAttr ($brushes[$i] + ".turbulenceType")`;
		if( $turbType == 6 && `getAttr ($brushes[$i] + ".branches")` )
		{
			warning( (uiRes("m_loopBrushAnim.kTreeIncorrectLoop")));
		}
		
	}
}

