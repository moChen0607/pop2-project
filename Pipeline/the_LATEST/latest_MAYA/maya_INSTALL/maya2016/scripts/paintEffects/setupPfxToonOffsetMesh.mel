// Copyright (C) 1997-2014 Autodesk, Inc., and/or its licensors.
// All rights reserved.
//
// The coded instructions, statements, computer programs, and/or related
// material (collectively the "Data") in these files contain unpublished
// information proprietary to Autodesk, Inc. ("Autodesk") and/or its licensors,
// which is protected by U.S. and Canadian federal copyright law and by
// international treaties.
//
// The Data is provided for use exclusively by You. You have the right to use,
// modify, and incorporate this Data into other products for purposes authorized 
// by the Autodesk software license agreement, without fee.
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND. AUTODESK
// DOES NOT MAKE AND HEREBY DISCLAIMS ANY EXPRESS OR IMPLIED WARRANTIES
// INCLUDING, BUT NOT LIMITED TO, THE WARRANTIES OF NON-INFRINGEMENT,
// MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE, OR ARISING FROM A COURSE 
// OF DEALING, USAGE, OR TRADE PRACTICE. IN NO EVENT WILL AUTODESK AND/OR ITS
// LICENSORS BE LIABLE FOR ANY LOST REVENUES, DATA, OR PROFITS, OR SPECIAL,
// DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES, EVEN IF AUTODESK AND/OR ITS
// LICENSORS HAS BEEN ADVISED OF THE POSSIBILITY OR PROBABILITY OF SUCH DAMAGES.

//
//
//  Creation Date:  2005
//
// Description: create toon offset mesh objects and connect them 
//	

proc string getObjShader( string $obj ){
	return "";
}

global proc setupPfxToonOffsetMesh( string $pfxToon)
{
	string $nType = nodeType($pfxToon);
	string $tform = $pfxToon;
	string $warningStr = (uiRes("m_setupPfxToonOffsetMesh.kNotPfxToon"));
	if($nType == "transform"){
		string $leaf[] = `ls -leaf -dag $pfxToon`;
		$pfxToon = $leaf[0];
		if( nodeType( $pfxToon ) != "pfxToon" ){
			warning( `format -s $pfxToon $warningStr` );
			return;
		}
	} else if( $nType == "pfxToon" ){
		string $tforms[] = listTransforms( $pfxToon );
		$tform = $tforms[0];
	} else {
		warning( `format -s $pfxToon $warningStr` );
		return;
	}

	string $cons[] = `listAttr -m ($pfxToon + ".inputSurface")`;
	if( size( $cons ) < 1 ){
		return;
	}
	string $sel[] = `ls -sl`;
	int $selChanged = false;
	string $profileMeshGroup = ($tform + "ProfileMeshes");
	if( !objExists( $profileMeshGroup ) ){
		$profileMeshGroup = `group -em -name $profileMeshGroup`;
		$selChanged = true;
	}
	string $material = ($tform + "ProfileShader");
	string $sg = ($material + "SG");
	int $createShader = true;
	if( objExists( $sg ) ){
		$createShader = false;
	}

	string $con;	
	for( $con in $cons ){
		string $buffer[];
		int $numTokens = `tokenize $con "[]" $buffer`;
		if( $numTokens == 3 ){
			if( $buffer[2] == ".surface" ){ // ignore matrix connections
				int $index = (int)$buffer[1];
				string $outputConnection = 
					($pfxToon + ".outProfileMesh["+$index+"]");
				string $outCons[] = `listConnections $outputConnection`;
				if( size($outCons) > 0 ){
/*
					if( $createShader ){
						string $mat	= getObjShader( $outCon[0] );
						if( objExists( $mat ) ){
							$createShader = false;
							$material = $mat;
						}
					}
*/
				} else {
					$selChanged = true;
					if( $createShader ){
						$material = `shadingNode -asShader -name $material "surfaceShader"`;
						// create shading group
						$sg = `sets -renderable true 
								-noSurfaceShader true -empty -name ($material + "SG")`;
						defaultNavigation
							-connectToExisting
							-source $material
							-destination $sg;
						connectAttr ($pfxToon + ".outColor") ($material + ".outColor");
						$createShader = false;
					}
					string $mesh = `createNode "mesh"`;
					setAttr ($mesh +".overrideEnabled") 1;
					setAttr ($mesh +".overrideDisplayType") 2;
					setAttr ($mesh +".doubleSided") 0;
					setAttr ($mesh +".castsShadows") 0;
					setAttr ($mesh +".receiveShadows") 0;

					if( attributeExists( "miFinalGatherCast", $mesh ) ){
						// these do not exist if mental ray is not loaded
						setAttr ($mesh +".miFinalGatherCast") 0;
						setAttr ($mesh +".miFinalGatherReceive") 0;
					}
					setAttr ($mesh +".opposite") 1;

					string $tforms[] = `listTransforms $mesh`;
					string $meshDag = $tforms[0];
					connectAttr $outputConnection ($mesh + ".inMesh");
					// select -r $mesh;
					hyperShade -assign $sg;
					parent -relative $meshDag $profileMeshGroup;

				}
			}
		}
	}
	if( $selChanged ){
		select -r $sel;
	}
}
