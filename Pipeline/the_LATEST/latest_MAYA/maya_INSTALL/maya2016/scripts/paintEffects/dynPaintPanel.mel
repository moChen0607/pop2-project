// Copyright (C) 1997-2014 Autodesk, Inc., and/or its licensors.
// All rights reserved.
//
// The coded instructions, statements, computer programs, and/or related
// material (collectively the "Data") in these files contain unpublished
// information proprietary to Autodesk, Inc. ("Autodesk") and/or its licensors,
// which is protected by U.S. and Canadian federal copyright law and by
// international treaties.
//
// The Data is provided for use exclusively by You. You have the right to use,
// modify, and incorporate this Data into other products for purposes authorized 
// by the Autodesk software license agreement, without fee.
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND. AUTODESK
// DOES NOT MAKE AND HEREBY DISCLAIMS ANY EXPRESS OR IMPLIED WARRANTIES
// INCLUDING, BUT NOT LIMITED TO, THE WARRANTIES OF NON-INFRINGEMENT,
// MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE, OR ARISING FROM A COURSE 
// OF DEALING, USAGE, OR TRADE PRACTICE. IN NO EVENT WILL AUTODESK AND/OR ITS
// LICENSORS BE LIABLE FOR ANY LOST REVENUES, DATA, OR PROFITS, OR SPECIAL,
// DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES, EVEN IF AUTODESK AND/OR ITS
// LICENSORS HAS BEEN ADVISED OF THE POSSIBILITY OR PROBABILITY OF SUCH DAMAGES.

//
// Create a scripted panel for the DynPaint editor
//

global string $dpToolbar;
global int $gDynPaintEdCreatedFirstTime = 0;

global proc buildDynPaintContextHelpItems(string $nameRoot, string $menuParent)
//
//  Description:
//		Build context sensitive menu items
//		
//  Input Arguments:
//		$nameRoot - name to use as the root of all item names
//		$menuParent - the name of the parent of this menu
//
//  Return Value:
//      None
//
{
	menuItem -label (uiRes("m_dynPaintPanel.kHelpOnPaintEffects"))
		-enableCommandRepeat false
		-command "showHelp PaintEffects";
	menuItem -label (uiRes("m_dynPaintPanel.kHelpOnPaintEffectsPanel"))
		-enableCommandRepeat false
		-command "showHelp PaintEffectsPanel";
}

global proc dynPaintPanel( string $panelName )
{
	// Do nothing, but required to be called to load the other methods. APP 16dec98
} 

global proc setDynPaintToolbar( int $state )
{
	global string $dpToolbar;

	flowLayout
	-edit
	-manage		$state
	$dpToolbar;
}

global proc dynPaintCreateCallback(string $panelName) {
 //
 //  Description:
 //      Create any editors unparented here and do
 //      any other initialization required.
	dynPaintEditor -unParent  ($panelName+"Ed");

}


global proc dynPaintInitCallback(string $panelName)
//
//  Description:
//		Called on file -new/open.
//
//		Take this opportunity to update the state of the panel UI etc.
//
{
	//	Update the state of the horizontal and vertical wrap toggle buttons
	//	on the tool bar.  The easiest way to do this is to just set the 
	//	attribute to its current value.  This will cause all UI tied to this
	//	attribute via the 'connectControl' command to be updated to the 
	//	appropriate value (ie. if the Stroke Globals window and/or Channel
	//	Box is also visible then the appropriate controls will be updated
	//	accordingly.
	//
	//	Bug #115364 - bwk 14jul99.
	//
	setAttr "strokeGlobals.wrapH" `getAttr "strokeGlobals.wrapH"`;
	setAttr "strokeGlobals.wrapV" `getAttr "strokeGlobals.wrapV"`;
	// Do the rest of them too. Bug 119534 - APP 09mar00
	setAttr "strokeGlobals.canvasScale"      `getAttr "strokeGlobals.canvasScale"`;
	setAttr "strokeGlobals.useCanvasLight"   `getAttr "strokeGlobals.useCanvasLight"`;
	setAttr "strokeGlobals.forceTubeDirAlongPath"   `getAttr "strokeGlobals.forceTubeDirAlongPath"`;
	setAttr "strokeGlobals.lightDirectionX" `getAttr "strokeGlobals.lightDirectionX"`;
	setAttr "strokeGlobals.lightDirectionY" `getAttr "strokeGlobals.lightDirectionY"`;
	setAttr "strokeGlobals.lightDirectionZ" `getAttr "strokeGlobals.lightDirectionZ"`;
	setAttr "strokeGlobals.sceneScale"       `getAttr "strokeGlobals.sceneScale"`;
	setAttr "strokeGlobals.sceneWrapH"       `getAttr "strokeGlobals.sceneWrapH"`;
	setAttr "strokeGlobals.sceneWrapV"       `getAttr "strokeGlobals.sceneWrapV"`;
	setAttr "strokeGlobals.forceRealLights"  `getAttr "strokeGlobals.forceRealLights"`;
	setAttr "strokeGlobals.forceDepth"       `getAttr "strokeGlobals.forceDepth"`;
}


global proc dynPaintAddCallback(string $panelName) {
 //
 //  Description:  Create UI and parent any editors.
 //
	global int $gDynPaintEdCreatedFirstTime;

	global string $gDynPaintEditorName;
	global string $dpToolbar;

	string $mbarName = `panel -q -control $panelName`;
	string $editorName = ($panelName+"Ed");
	$gDynPaintEditorName = $editorName;
	int    $menusOkayInPanels = `optionVar -q allowMenusInPanels`;
	// This is the name of the brush shelf
	global string $gBrushShelfTopLevel = "";

 	if (`menuBarLayout -exists $mbarName`) {
 		dynPaintMenus($editorName, $mbarName);
		menuBarLayout -e -mbv $menusOkayInPanels $mbarName;
	}

	//	Add support for the Context Sensitive Help Menu.
	//
	addContextHelpProc  $panelName "buildDynPaintContextHelpItems";

	// Make the selection context
	global string $gSelect;  // Selection super context

	global string $gDynSelectTool;
	
	// For Complete and above only
	
	if (`isTrue "MayaCreatorExists"` && 
		(`licenseCheck -m "edit" -typ "particlePaint"`)) {
 		$gDynSelectTool = `dynSelectCtx -enb 0`;  // Disabled by default
		superCtx -edit -attach $gDynSelectTool $gSelect;  	
	}
	
	// Make the paint context

	// global string $gDynPaintTool;
	// $gDynPaintTool = `dynPaintCtx`;

	// Make the layouts
	
	string $viewForm = `formLayout`;
		string $toolbarForm = `formLayout "dynToolbar"`;
			string $toolbar = dynPaintToolbar( $editorName );
			formLayout
				-edit
				-attachForm	$toolbar	"left"		0
				-attachForm	$toolbar	"right"		0
				-attachForm	$toolbar	"top"		0
				-attachForm	$toolbar	"bottom"	0
				$toolbarForm;
	
	//	dynPaintEditor -e -parent $editorForm $toolbarForm;
	
		setParent $viewForm;	
		string $editorForm = `formLayout`;
			dynPaintEditor -e -parent $editorForm  $editorName;
			formLayout -e 
				-attachForm $editorName "top" 0
				-attachForm $editorName "left" 0 
				-attachForm $editorName "right" 0 
				-attachForm $editorName "bottom" 0 
				$editorForm;
		setParent ..;
	
		formLayout -e 
			-attachForm		$toolbarForm		"left"		0
			-attachForm		$toolbarForm		"right"		0
			-attachForm		$toolbarForm		"top"		0
			-attachNone		$toolbarForm		"bottom"
		
			-attachControl $editorForm "top" 0	$toolbarForm
			-attachForm $editorForm "left" 0 
			-attachForm $editorForm "right" 0 
			-attachForm $editorForm "bottom" 0 
			$viewForm;
	
	setParent ..;

	// Set the default clear colour
	if (`optionVar -exists dynPaintPanelClearColour` == 0) {
		// Create the option var.
		optionVar -floatValueAppend dynPaintPanelClearColour 0.0;
		optionVar -floatValueAppend dynPaintPanelClearColour 0.0;
		optionVar -floatValueAppend dynPaintPanelClearColour 0.0;
	}

    // set the script job to catch the "new scene" event 
    // 
    scriptJob
		-protected
		-parent $panelName
        -event "NewSceneOpened" ("dynPaintNewScenOpenedCB " + $editorName);

    // set the script job to catch the "quit" event 
    // 
    scriptJob
		-protected
		-parent $panelName
        -event "quitApplication" ("dynPaintPromptForFileSaving " + $editorName);


	if (`optionVar -q dynPaint23dToggle` == 2) {
		if ( $gDynPaintEdCreatedFirstTime == 0 ) {
			float $cc[] = `optionVar -q dynPaintPanelClearColour`;
			dynPaintEditor -e -cl $cc[0] $cc[1] $cc[2] $editorName;
		}
	}

	$gDynPaintEdCreatedFirstTime = 1;

	$dpToolbar = $toolbar;
	dynPaintEditor -e -pa 1 $editorName;

	string $currContext = `currentCtx`;
	string $currentTool = `contextInfo -c $currContext`;

	if($currentTool != "paintEffects")
	{
		creatorSetPaintEffectCtx_NamedCmd();
		resetBrush();
	}
}
	
	

global proc dynPaintRemoveCallback(string $panelName) {
 //
 //  Description:
 //             Unparent any editors and save state if required.
 //
        //  Scope the control names to this panel.
        //
        string $control = `scriptedPanel -q -control $panelName`;
        setParent $control;

//         $gDynPaintState[0] = `floatSliderGrp -q -v fsg1`;
//         $gDynPaintState[1] = `floatSliderGrp -q -v fsg2`;
//         $gDynPaintState[2] = `floatSliderGrp -q -v fsg3`;
//         $gDynPaintState[3] = `radioButtonGrp -q -sl rbg`;
//         $gDynPaintState[4] = `radioButtonGrp -q -sl rbg2`;
}


global proc dynPaintDeleteCallback(string $panelName) {
 //
 //  Description:
 //             Delete any editors and do any other cleanup required.

}

global proc string dynPaintSaveStateCallback(string $panelName) {
 //
 //  Description:
 //             Return a string that will restore the current state
 //             when it is executed.
        $indent = "\n\t\t\t";

        return (""
//                         $indent+"$gDynPaintState[0]="+$gDynPaintState[0]+";" +
//                         $indent+"$gDynPaintState[1]="+$gDynPaintState[1]+";" +
//                         $indent+"$gDynPaintState[2]="+$gDynPaintState[2]+";" +
//                         $indent+"$gDynPaintState[3]="+$gDynPaintState[3]+";" +
//                         $indent+"$gDynPaintState[4]="+$gDynPaintState[4]+";" +
//                         $indent+"setDynPaintPanelState $panelName;\n"
        );
}

global proc setDynPaintPanelState( string $whichPanel ) {
//
// Create a scripted panel for the DynPaint editor
//
}
