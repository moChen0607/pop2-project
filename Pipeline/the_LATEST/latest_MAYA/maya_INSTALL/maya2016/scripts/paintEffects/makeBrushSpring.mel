// Copyright (C) 1997-2014 Autodesk, Inc., and/or its licensors.
// All rights reserved.
//
// The coded instructions, statements, computer programs, and/or related
// material (collectively the "Data") in these files contain unpublished
// information proprietary to Autodesk, Inc. ("Autodesk") and/or its licensors,
// which is protected by U.S. and Canadian federal copyright law and by
// international treaties.
//
// The Data is provided for use exclusively by You. You have the right to use,
// modify, and incorporate this Data into other products for purposes authorized 
// by the Autodesk software license agreement, without fee.
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND. AUTODESK
// DOES NOT MAKE AND HEREBY DISCLAIMS ANY EXPRESS OR IMPLIED WARRANTIES
// INCLUDING, BUT NOT LIMITED TO, THE WARRANTIES OF NON-INFRINGEMENT,
// MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE, OR ARISING FROM A COURSE 
// OF DEALING, USAGE, OR TRADE PRACTICE. IN NO EVENT WILL AUTODESK AND/OR ITS
// LICENSORS BE LIABLE FOR ANY LOST REVENUES, DATA, OR PROFITS, OR SPECIAL,
// DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES, EVEN IF AUTODESK AND/OR ITS
// LICENSORS HAS BEEN ADVISED OF THE POSSIBILITY OR PROBABILITY OF SUCH DAMAGES.

//
//
//  Creation Date:  1998
//
global proc makeBrushSpring( 
float $defStiff, float $defDamp, float $defTravel, int $startFrame )
{
	int	   $i;
	string $brushes[];

	$brushes = getSelectedBrushes();
	int $numBrushes = size( $brushes );

	if( $numBrushes == 0 )
	{
		warning( uiRes("m_bakeBrushSpringAnim.kNoBrushSelected") );
		return;
	}

	for( $i = 0; $i < $numBrushes; $i++ )
	{
		string $brush = $brushes[$i];
		string $strokeCon[] = `listConnections ( $brush + ".outBrush")`;
		if( size( $strokeCon ) > 0 )
		{
			string $stroke = $strokeCon[0];
			
			if ( !objExists( $stroke + ".lastWX" ) )
			{
				addAttr -sn lwx -ln lastWX -dv 0 $stroke;
			}
			else
			{
				string $expNode[] = `listConnections ($stroke + ".lastWX")`;
				if( size( $expNode ) > 0 )
				{
					// This should be another spring expression Node 
					// We delete it to make way for the new one
					delete $expNode[0];
				}
			}

			if ( !objExists( $stroke + ".lastWY" ) )
			{
				addAttr -sn lwy -ln lastWY -dv 0 $stroke;
			}
			if ( !objExists( $stroke + ".lastWZ" ) )
			{
				addAttr -sn lwz -ln lastWZ -dv 0 $stroke;
			}
			if ( !objExists( $stroke + ".lastVX" ) )
			{
				addAttr -sn lvx -ln lastVX -dv 0 $stroke;
			}
			if ( !objExists( $stroke + ".lastVY" ) )
			{
				addAttr -sn lvy -ln lastVY -dv 0 $stroke;
			}
			if ( !objExists( $stroke + ".lastVZ" ) )
			{
				addAttr -sn lvz -ln lastVZ -dv 0 $stroke;
			}
			if ( !objExists( $brush + ".springStiffness" ) ) 
			{
				addAttr -sn sst -ln springStiffness -dv $defStiff -min 0 -max 1 $brush;
			}
			else
			{
				setAttr  ($brush + ".springStiffness") $defStiff;
			}
			if ( !objExists( $brush + ".springDamp" ) ) 
			{
				addAttr -sn sdp -ln springDamp -dv $defDamp -min 0 -max 1 $brush;
			}
			else
			{
				setAttr  ($brush + ".springDamp") $defDamp;
			}
			if ( !objExists( $brush + ".springTravel" ) ) 
			{
				addAttr -sn spt -ln springTravel -dv $defTravel -min 0 -max 100 $brush;
			}
			else
			{
				setAttr  ($brush + ".springTravel") $defTravel;
			}
			string $expStr = "";
			// find the vertex nearest the middle of the stroke 
			int $numStrokePoints = `getAttr -size ($stroke + ".outPoint")`;
			int $midVert = $numStrokePoints/2;
			string $strokePoint = ($stroke + ".outPoint[" + $midVert + "]");

			$expStr = $expStr + (
					"float $px = " + $strokePoint + ".outPointX;\n"
					+ "float $py = " + $strokePoint + ".outPointY;\n"
					+ "float $pz = " + $strokePoint + ".outPointZ;\n"
					+ "float $wx = " + $stroke + ".lastWX;\n"
					+ "float $wy = " + $stroke + ".lastWY;\n"
					+ "float $wz = " + $stroke + ".lastWZ;\n"
					+ "float $vx = " + $stroke + ".lastVX;\n"
					+ "float $vy = " + $stroke + ".lastVY;\n"
					+ "float $vz = " + $stroke + ".lastVZ;\n"
					+ "float $stiff = " + $brush + ".springStiffness;\n"
					+ "float $istiff = 1-$stiff;\n"
					+ "float $damp = 1 - " + $brush + ".springDamp;\n"
					+ "float $travel = " + $brush + ".springTravel;\n"
					+ "float $fx = 0; float $fy = 0; float $fz = 0;\n"
					+ "if( frame > " + ($startFrame + 1) + " ){\n"
					+ "	 $fx = " + $brush + ".uniformForceX * $istiff + $stiff * ($wx - $px) * $travel + $vx;\n"
					+ "	 $fy = " + $brush + ".uniformForceY * $istiff + $stiff * ($wy - $py) * $travel + $vy;\n"
					+ "	 $fz = " + $brush + ".uniformForceZ * $istiff + $stiff * ($wz - $pz) * $travel + $vz;\n"
					+ "  " + $stroke +".lastVX = $vx * $damp -$fx * $stiff;\n"
					+ "  " + $stroke +".lastVY = $vy * $damp -$fy * $stiff;\n"
					+ "  " + $stroke +".lastVZ = $vz * $damp -$fz * $stiff;\n"
					+ "}else{\n"
					+ "  " + $stroke +".lastVX = 0;\n"
					+ "  " + $stroke +".lastVY = 0;\n"
					+ "  " + $stroke +".lastVZ = 0;\n"
					+ "}\n"
					+ $brush + ".uniformForceX = $fx;\n"
					+ $brush + ".uniformForceY = $fy;\n"
					+ $brush + ".uniformForceZ = $fz;\n"
					+ $stroke +".lastWX = $px;\n"
					+ $stroke +".lastWY = $py;\n"
					+ $stroke +".lastWZ = $pz;\n" );
			expression -s $expStr;
		}
	}
	
}

