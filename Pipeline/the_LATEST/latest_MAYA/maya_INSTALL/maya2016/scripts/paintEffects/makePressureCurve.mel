// Copyright (C) 1997-2014 Autodesk, Inc., and/or its licensors.
// All rights reserved.
//
// The coded instructions, statements, computer programs, and/or related
// material (collectively the "Data") in these files contain unpublished
// information proprietary to Autodesk, Inc. ("Autodesk") and/or its licensors,
// which is protected by U.S. and Canadian federal copyright law and by
// international treaties.
//
// The Data is provided for use exclusively by You. You have the right to use,
// modify, and incorporate this Data into other products for purposes authorized 
// by the Autodesk software license agreement, without fee.
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND. AUTODESK
// DOES NOT MAKE AND HEREBY DISCLAIMS ANY EXPRESS OR IMPLIED WARRANTIES
// INCLUDING, BUT NOT LIMITED TO, THE WARRANTIES OF NON-INFRINGEMENT,
// MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE, OR ARISING FROM A COURSE 
// OF DEALING, USAGE, OR TRADE PRACTICE. IN NO EVENT WILL AUTODESK AND/OR ITS
// LICENSORS BE LIABLE FOR ANY LOST REVENUES, DATA, OR PROFITS, OR SPECIAL,
// DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES, EVEN IF AUTODESK AND/OR ITS
// LICENSORS HAS BEEN ADVISED OF THE POSSIBILITY OR PROBABILITY OF SUCH DAMAGES.

//
//
//  Creation Date:  1998
//


global proc makePressureCurve( int $numCvs, float $scaleVal )
{

	string $pickedStrokes[] = getStrokes( 0 );
	int $numPickedStrokes = size( $pickedStrokes );

	if( $numPickedStrokes <= 0 )
	{
		error ((uiRes("m_makePressureCurve.kNoStrokePicked")));
		return;
	}
	int $sIndex;
	for( $sIndex= 0; $sIndex < $numPickedStrokes; $sIndex++ )
	{
		$stroke = $pickedStrokes[$sIndex];
		int $numOutPoints = `getAttr -s ( $stroke + ".outPoint" )`;
		float $outPointsX[];
		float $outPointsY[];
		float $outPointsZ[];
		float $outNormalsX[];
		float $outNormalsY[];
		float $outNormalsZ[];
		int $i;
		int $useNormal = getAttr($stroke + ".useNormal");
		float $nx, $ny, $nz;
		if( $useNormal )
		{
			$nx = getAttr( $stroke + ".normalX" );
			$ny = getAttr( $stroke + ".normalY" );
			$nz = getAttr( $stroke + ".normalZ" );
		}
		for( $i = 0; $i < $numOutPoints; $i++ )
		{
			$outPointsX[$i] = getAttr( $stroke + ".outPoint["+$i+"].outPointX" );
			$outPointsY[$i] = getAttr( $stroke + ".outPoint["+$i+"].outPointY" );
			$outPointsZ[$i] = getAttr( $stroke + ".outPoint["+$i+"].outPointZ" );
			if( $useNormal )
			{
				$outNormalsX[$i] = $nx;
				$outNormalsY[$i] = $ny;
				$outNormalsZ[$i] = $nz;
			}
			else
			{
				$outNormalsX[$i] = getAttr( $stroke + ".outNormal["+$i+"].outNormalX" );
				$outNormalsY[$i] = getAttr( $stroke + ".outNormal["+$i+"].outNormalY" );
				$outNormalsZ[$i] = getAttr( $stroke + ".outNormal["+$i+"].outNormalZ" );
			}
		}

		float $pressure[] = `getAttr ($stroke +".pressure")`;
		int   $numPressurePoints = size( $pressure );

		if( $numOutPoints < 2 )
		{
			error ((uiRes("m_makePressureCurve.kStrokeNotEnoughPoints")));
			return;
		}
		string $expNode[] = `listConnections ($stroke + ".pressure[0]")`;
		if( size( $expNode ) > 0 )
		{
			// This should be another stroke pressure curve Node 
			// We delete it to make way for the new one
			// print ("found expNode " + $expNode[0]);
			string $expInputs[] = `listConnections $expNode[0]`;
			string $oldCurve = "";
			for( $i = 0; $i < size( $expInputs ); $i++ )
			{
				if( `nodeType $expInputs[$i]` == "pointOnCurveInfo" )
				{
			// print ("found pointOnCurve " + $expInputs[$i]);
					string $pocInputs[] =  `listConnections $expInputs[$i]`;
					int $ii;
					for( $ii = 0; $ii < size( $pocInputs ); $ii++ )
					{
						if( `nodeType $pocInputs[$ii]` == "transform" )
						{
							$oldCurve = $pocInputs[$ii];
							break;
						}
					}
					break;
				}
			}
			delete $expNode[0];
			if( $oldCurve != "" )
			{
				delete $oldCurve;
			}
		}
		if( $numCvs > $numOutPoints )
		{
			$numCvs = $numOutPoints;
		}
		if( $numPressurePoints < 2 )
		{
			if( $numCvs < 4 )
			{
				// linear interpolation, so we can do a one for
				// one match of pressure and cv
				$numPressurePoints = $numCvs;
			}
			else
			{
				// using a smooth curve, so three spans per curve cv
				$numPressurePoints = $numCvs * 3; 
			}
			// create points on the pressure array
			for( $i = 0; $i < $numPressurePoints; $i++ )
			{
				setAttr ($stroke + ".pressure["+$i+"]")  1.0;
				$pressure[$i] = 1.0;
			}
		}

		float $curvePointsX[];
		float $curvePointsY[];
		float $curvePointsZ[];
		// determine the initial position of the new curve
		// depending on the number of cVs defined, the pressure
		// values may change when we create this curve.
		for( $i = 0; $i < $numCvs; $i++ )
		{
			float $u = (float)$i/(float)($numCvs-1);
			int $si = $u * (float)($numOutPoints-1);
			int $pu = $u * (float)($numPressurePoints-1);
			// find the pressure value at this point on the curve	
			int	  $pindex = (int)$pu;
			float $blend = $pu - (float)$pindex;
			float $interp = $pressure[ $pindex ] * (1-$blend) 
									+ $pressure[$pindex+1] * $blend;
			$interp = $interp * $scaleVal;
			// the curve is offset from the stroke along the normal
			$curvePointsX[$i] = $outPointsX[$si] + $outNormalsX[$si] * $interp;
			$curvePointsY[$i] = $outPointsY[$si] + $outNormalsY[$si] * $interp;
			$curvePointsZ[$i] = $outPointsZ[$si] + $outNormalsZ[$si] * $interp;
		}

		// create the pressure control curve
		string $mc = ("curve -d 1 ");

		for( $i = 0; $i < $numCvs; $i++ )
		{
			$mc += ("-p " + $curvePointsX[$i] + " " 
					  	+ $curvePointsY[$i] + " "  
					  	+ $curvePointsZ[$i] + " ");
		}
		string $crv = `eval $mc`;

		// create a point on curve nodes on the pressure control curve 
		// (1 for each cv)
		float $min = getAttr( $crv + ".min" );
		float $max = getAttr( $crv + ".max" );
		float $urange = $max-$min;
		string $p_on_c[];
		for( $i = 0; $i < $numCvs; $i++ )
		{
			float $u = (float)$i/($numCvs-1);
			$u = $min + $urange * $u; 
			$p_on_c[$i] =  pointOnCurve( "-ch", 1, "-parameter", $u, $crv  );
		}
		// we use pressure min 3 to force updates, because 
		// pressure array connections do not seem to work

		// create an expression to update the pressure values
		// when the control curve is modified

		string $exp = (
			"float $pres[" + $numCvs + "];\n"
			+"float $dummy3[] = \`getAttr " + $stroke + ".outPoint[0]\`;");

		for( $i = 0; $i < $numCvs; $i++ )
		{
			float $u = (float)$i/(float)($numCvs-1);
			int $si = $u * (float)($numOutPoints-1);
			$exp += (
				"float $xoff =  getAttr (\""+$stroke+".outPoint["+$si+"].outPointX\") - "
							+$p_on_c[$i]+".px;\n"+
				"float $yoff =  getAttr (\""+$stroke+".outPoint["+$si+"].outPointY\") - "
							+$p_on_c[$i]+".py;\n"+
				"float $zoff =  getAttr (\""+$stroke+".outPoint["+$si+"].outPointZ\") - "
							+$p_on_c[$i]+".pz;\n"+
				"$pres["+$i+"] = sqrt( $xoff*$xoff + $yoff*$yoff + $zoff*$zoff)/"+$scaleVal+";\n");
		}
		$exp += (
			"float $pu = 0.0;\n"+
			"float $cu = 0.0;\n"+
			"int   $cindex = 0;\n"+
			"float $blend = 0.0;\n"+
			"float $pressure = 0.0;\n" );
		for( $i = 0; $i < $numPressurePoints; $i++ ) {
			$exp += (
					"$pu     = (float)"+$i+"/("+$numPressurePoints+"-1);\n"+
					"$cu     = $pu * ("+$numCvs+"-1);\n"+
					"$cindex = (int)$cu;\n"+
					"$blend  = $cu - $cindex;\n"+
					"$pressure = $pres[$cindex] * (1-$blend) + $pres[$cindex+1]*$blend;\n"+
					 $stroke+".pressure["+$i+"] = $pressure;\n" );
		}

		// print $exp;
		expression -s $exp;

	}
	
}
	
