// Copyright (C) 1997-2014 Autodesk, Inc., and/or its licensors.
// All rights reserved.
//
// The coded instructions, statements, computer programs, and/or related
// material (collectively the "Data") in these files contain unpublished
// information proprietary to Autodesk, Inc. ("Autodesk") and/or its licensors,
// which is protected by U.S. and Canadian federal copyright law and by
// international treaties.
//
// The Data is provided for use exclusively by You. You have the right to use,
// modify, and incorporate this Data into other products for purposes authorized 
// by the Autodesk software license agreement, without fee.
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND. AUTODESK
// DOES NOT MAKE AND HEREBY DISCLAIMS ANY EXPRESS OR IMPLIED WARRANTIES
// INCLUDING, BUT NOT LIMITED TO, THE WARRANTIES OF NON-INFRINGEMENT,
// MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE, OR ARISING FROM A COURSE 
// OF DEALING, USAGE, OR TRADE PRACTICE. IN NO EVENT WILL AUTODESK AND/OR ITS
// LICENSORS BE LIABLE FOR ANY LOST REVENUES, DATA, OR PROFITS, OR SPECIAL,
// DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES, EVEN IF AUTODESK AND/OR ITS
// LICENSORS HAS BEEN ADVISED OF THE POSSIBILITY OR PROBABILITY OF SUCH DAMAGES.


proc string loftPfxCurves( string $inputs[], int $hardEdge )
{
	string $loft = `createNode loft`;
	if( $hardEdge ){
		setAttr ($loft + ".degree") 1;
	}
/*
	setAttr ($loft + ".uniform") 1;
	setAttr ($loft + ".sectionSpans") 3;
*/
	int $numInputs = size( $inputs );
	if( $numInputs == 4  ){
		setAttr ($loft + ".close") 1;
	}
	int $i;
	for( $i=0; $i < $numInputs; $i++ ){
		connectAttr $inputs[$i] ($loft + ".inputCurve[" + $i+ "]");
	}
	string $surf = `createNode nurbsSurface`;
	connectAttr ($loft + ".outputSurface") ($surf + ".create");
	return $surf;
} 

proc string getStrokesBrush( string $stroke )
{
	string $attr = $stroke + ".brush";
	string $result = `connectionInfo -sfd $attr`;
	if( size($result) < 1 ){
		return("");
	}
	string $buffer[];
	int $num = `tokenize $result "." $buffer`;
	return( $buffer[0] );

}

global proc string[] createPfxOutCurves( string $stroke, int $createNurbs )
{
	float $flatThreshold = 0.8;
	string $groups[3] = {"","",""};

	int $flatMain = false;
	int $flatLeaf = false;
	int $flatFlower = false;
	int $hardEdges = false;
	setAttr -lock false ( $stroke + ".curveMode" );
	setAttr -lock false ( $stroke + ".leafCurveMode" );
	setAttr -lock false ( $stroke + ".flowerCurveMode" );

	string $brush = getStrokesBrush( $stroke );	
	int $tubes = false;
	if( size( $brush ) > 0 ){
		$tubes	   = getAttr( $brush + ".tubes" );
		if( $tubes ){
			string $branches   = getAttr( $brush + ".branches" );
			string $twigs   = getAttr( $brush + ".twigs" );
			if( $branches || $twigs ){
				setAttr ( $stroke  + ".curveAlign" ) true;
			}
		}
	}
	if( $createNurbs ){
		if( size( $brush ) > 0 ){
			int $btype = getAttr( $brush + ".brushType" );
			if( $btype == 5 ){ // mesh
				$hardEdges = getAttr( $brush + ".hardEdges" );
			}
			int $flatness1 = getAttr( $brush + ".flatness1" );
			if( $tubes ){
				if( $flatness1 > $flatThreshold ){
					int $flatness2 = getAttr( $brush + ".flatness2" );
					if( $flatness2 > $flatThreshold ){
						$flatMain = true;
					}
				}
				if( $flatThreshold < getAttr( $brush + ".leafFlatness" )){
					$flatLeaf = true;
				}
				if( $flatThreshold < getAttr( $brush + ".petalFlatness" )){
					$flatFlower = true;
				}
			} else {
				if( $flatness1 > $flatThreshold ){
					$flatMain = true;
				}
			}
		}
		if( $flatMain ){
			setAttr ( $stroke + ".curveMode" ) 1;
		} else {
			setAttr ( $stroke + ".curveMode" ) 2;
		}
		if( $flatLeaf ){
			setAttr ( $stroke + ".leafCurveMode" ) 1;
		} else {
			setAttr ( $stroke + ".leafCurveMode" ) 2;
		}	
		if( $flatFlower ){
			setAttr ( $stroke + ".flowerCurveMode" ) 1;
		} else {
			setAttr ( $stroke + ".flowerCurveMode" ) 2;
		}	
	} else {
		setAttr ( $stroke + ".curveMode" ) 0;
		setAttr ( $stroke + ".leafCurveMode" ) 0;
		setAttr ( $stroke + ".flowerCurveMode" ) 0;
	}
	setAttr -lock true ( $stroke + ".curveMode" );
	setAttr -lock true ( $stroke + ".leafCurveMode" );
	setAttr -lock true ( $stroke + ".flowerCurveMode" );
	
	int $numMain = getAttr( $stroke + ".outMainCurveCount" );
	int $numLeaf = getAttr( $stroke + ".outLeafCurveCount" );
	int $numFlower = getAttr( $stroke + ".outFlowerCurveCount" );


/*
	if( $curveMode == 1 ){
		$numMain *= 4;
		$numLeaf *= 2;
		$numFlower *= 2;
	}
*/
	string $nameBase;
	if( $createNurbs ){
		$nameBase = "Surfaces";
	} else {
		$nameBase = "Curves";
	}
	string $parentName = ($stroke + $nameBase);
	if( !objExists( $parentName ) ){
		$parentName = `group -em -name $parentName`;
	}
	string $groupName = ($stroke + "Main" + $nameBase);
	if( $numMain > 0 && !objExists( $groupName )) {
		$groupName = `group -em -name $groupName`;
		parent -relative $groupName $parentName;
	}
	$groups[0] = $groupName;
	string $base = ($stroke + ".outMainCurves");
	int $i, $bi;
	for( $i = 0; $i < $numMain; $i++ ){
		if( $createNurbs ){
			if( $flatMain ){
				$bi = $i * 2;
			} else {
				$bi = $i * 4;
			}
			string $attr[4];
			$attr[0] = ($base + "[" + $bi + "]");	
			if( !`connectionInfo -is $attr[0]` ){
				$attr[1] = ($base + "[" + ($bi+1) + "]");	
				if( !$flatMain ){
					$attr[2] = ($base + "[" + ($bi+2) + "]");	
					$attr[3] = ($base + "[" + ($bi+3) + "]");	
				}
				string $surf = loftPfxCurves( $attr, ($hardEdges || $flatMain) );
				$tforms = `listTransforms $surf`;
				parent -relative $tforms[0] $groupName; 
			}
		} else {
			string $attr = ($base + "[" + $i + "]");	
			if( !`connectionInfo -is $attr` ){
				$curve = `createNode nurbsCurve`;
				connectAttr $attr ($curve + ".create");
				$tforms = `listTransforms $curve`;
				parent -relative $tforms[0] $groupName; 
			}
		}
	}
	$groupName = ($stroke + "Leaf" + $nameBase);
	if( $numLeaf > 0 && !objExists( $groupName )) {
		$groupName = `group -em -name $groupName`;
		parent -relative $groupName $parentName;
	}
	$groups[1] = $groupName;
	$base = ($stroke + ".outLeafCurves");
	for( $i = 0; $i < $numLeaf; $i++ ){
		if( $createNurbs ){
			if( $flatLeaf ){
				$bi = $i * 2;
			} else {
				$bi = $i * 4;
			}
			string $attr[2];
			$attr[0] = ($base + "[" + $bi + "]");	
			if( !`connectionInfo -is $attr[0]` ){
				$attr[1] = ($base + "[" + ($bi+1) + "]");	
				if( !$flatLeaf ){
					$attr[2] = ($base + "[" + ($bi+2) + "]");	
					$attr[3] = ($base + "[" + ($bi+3) + "]");	
				}
				string $surf = loftPfxCurves( $attr,($hardEdges || $flatLeaf));
				$tforms = `listTransforms $surf`;
				parent -relative $tforms[0] $groupName; 
			}
		} else {
			string $attr = ($base + "[" + $i + "]");	
			if( !`connectionInfo -is $attr` ){
				$curve = `createNode nurbsCurve`;
				connectAttr $attr ($curve + ".create");
				$tforms = `listTransforms $curve`;
				parent -relative $tforms[0] $groupName; 
			}
		}
	}
	$groupName = ($stroke + "Flower" + $nameBase);
	if( $numFlower > 0 && !objExists( $groupName )) {
		$groupName = `group -em -name $groupName`;
		parent -relative $groupName $parentName;
	}
	$groups[2] = $groupName;
	$base = ($stroke + ".outFlowerCurves");
	for( $i = 0; $i < $numFlower; $i++ ){
		if( $createNurbs ){
			if( $flatFlower ){
				$bi = $i * 2;
			} else {
				$bi = $i * 4;
			}
			string $attr[2];
			$attr[0] = ($base + "[" + $bi + "]");	
			if( !`connectionInfo -is $attr[0]` ){
				$attr[1] = ($base + "[" + ($bi+1) + "]");	
				if( !$flatFlower ){
					$attr[2] = ($base + "[" + ($bi+2) + "]");	
					$attr[3] = ($base + "[" + ($bi+3) + "]");	
				}
				string $surf = loftPfxCurves($attr,($hardEdges || $flatFlower));
				$tforms = `listTransforms $surf`;
				parent -relative $tforms[0] $groupName; 
			}
		} else {
			string $attr = ($base + "[" + $i + "]");	
			if( !`connectionInfo -is $attr` ){
				$curve = `createNode nurbsCurve`;
				connectAttr $attr ($curve + ".create");
				$tforms = `listTransforms $curve`;
				parent -relative $tforms[0] $groupName; 
			}
		}
	}
	return( $groups );
}
