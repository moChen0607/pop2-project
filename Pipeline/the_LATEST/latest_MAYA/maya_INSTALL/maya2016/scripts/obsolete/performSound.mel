// Copyright (C) 1997-2014 Autodesk, Inc., and/or its licensors.
// All rights reserved.
//
// The coded instructions, statements, computer programs, and/or related
// material (collectively the "Data") in these files contain unpublished
// information proprietary to Autodesk, Inc. ("Autodesk") and/or its licensors,
// which is protected by U.S. and Canadian federal copyright law and by
// international treaties.
//
// The Data is provided for use exclusively by You. You have the right to use,
// modify, and incorporate this Data into other products for purposes authorized 
// by the Autodesk software license agreement, without fee.
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND. AUTODESK
// DOES NOT MAKE AND HEREBY DISCLAIMS ANY EXPRESS OR IMPLIED WARRANTIES
// INCLUDING, BUT NOT LIMITED TO, THE WARRANTIES OF NON-INFRINGEMENT,
// MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE, OR ARISING FROM A COURSE 
// OF DEALING, USAGE, OR TRADE PRACTICE. IN NO EVENT WILL AUTODESK AND/OR ITS
// LICENSORS BE LIABLE FOR ANY LOST REVENUES, DATA, OR PROFITS, OR SPECIAL,
// DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES, EVEN IF AUTODESK AND/OR ITS
// LICENSORS HAS BEEN ADVISED OF THE POSSIBILITY OR PROBABILITY OF SUCH DAMAGES.

//
//
//  Creation Date:  Dec. 17/96
//
//  Description:
//      Option box dialog for each of the sound entries in the Display->sound
//	sub-menu.
//
//  Input Arguments:
//      int showOptionBox		true - show the option box dialog
//								false - just execute the command
//
//		string node				name of audio node to edit
//
//  Return Value:
//      None.
//

proc
setOptionVars (int $forceFactorySettings, string $node)
{
	// Since this option box is not for creating new objects, but rather
	// editing an existing object, then we always want to set up the
	// option vars to have the current values of the sound node.
	// If $forceFactorySettings is true, we will reset the offset to 0.
	//
	optionVar -stringValue soundFileName `sound -query -file $node`;

	if ($forceFactorySettings)
	{
		optionVar -floatValue soundStartTime 0.0;
	}
	else
	{
		optionVar -floatValue soundStartTime `sound -query -offset $node`;
	}
}

proc
editSoundNode(string $node)
{
	sound -edit -offset `optionVar -query soundStartTime` $node;

	$filename = `optionVar -query soundFileName`;

	// Only display the sound if it's vaild.  Otherwise, we'd remove the currently
	// displayed sound when we selected an audio node with an invalid filename.
	//
	if( !catch( `sound -edit -file $filename $node` ) ) {
		setSoundDisplay($node, 1);
	} 
}


global proc
soundSetup (string $parent, int $forceFactorySettings, string $node)
{
	// Retrieve the option settings
	//
	setOptionVars ($forceFactorySettings, $node);

	setParent $parent;

	// Query the optionVar's and set the values into the controls

	textFieldGrp -edit -fileName `optionVar -query soundFileName` file;

	floatFieldGrp -edit -value1 `optionVar -query soundStartTime` offset;
}

global proc
soundCallback (string $parent, string $node)
{
    setParent $parent;

	// Set the optionVar's from the control values, and then perform the command

	optionVar -stringValue soundFileName `textFieldGrp -query -fileName file`;

	optionVar -floatValue soundStartTime `floatFieldGrp -query -value1 offset`;

	editSoundNode $node;

	if( `textFieldGrp -exists file`	) {
		textFieldGrp -edit -fileName `sound -query -file $node` file;
	}
}

global proc int
soundUpdateFilename(string $filename, string $fileType)
{
	textFieldGrp -edit -fileName $filename file;
	return 1;
}

proc string
soundTabPage (string $tabLayout)
{
	setParent $tabLayout;

	string $tabForm = `columnLayout -adjustableColumn true`;

	textFieldGrp -l "Sound file" file;
	button -l "Browse..."
		-c "fileBrowser \"soundUpdateFilename\" \"Accept\" \"\" 0" browser;

	floatFieldGrp -l "Start time" -numberOfFields 1 offset;

	return $tabForm;
}

proc
soundOptions (string $node)
{
	string $commandName = "sound";

	string $optionBoxTitle = ("\""+$node+"\" sound options");

	string $applyTitle = "Sound";

	// Build the option box "methods"
	//
	string $callback = ($commandName + "Callback");
	string $setup = ($commandName + "Setup");

	// Build the window, with a tab layout
	//
	setUITemplate -pushTemplate DefaultTemplate;
	string $widgetList[] = `getStandardWindow $optionBoxTitle 1 "noOptions"`;

	// Make the form invisible while we create the widgets in the window
	//
	formLayout -e -vis false $widgetList[1];

	// Attach each tab
	//
	string $tabPage = `soundTabPage $widgetList[2]`;

	tabLayout -edit
		-tabLabel $tabPage "Basic" 
		$widgetList[2];

	// Attach the standard buttons
	//
	string $buttonList[] = `addStandardButtons $commandName $applyTitle
									$widgetList[1] $widgetList[2] "noOptions"`;

	// attach commands to the standard buttons
	//
	button -edit -command ("deleteUI " + $widgetList[0]) $buttonList[3];
	button -edit -command ("deleteUI " + $widgetList[0]) $buttonList[2];
	button -edit -command ($setup + " " + $widgetList[0] + " true " + $node)
																$buttonList[1];
	button -edit -command ($callback + " " + $widgetList[0] + " " + $node)
																$buttonList[0];

	// Make the form layout visible so we can see what we built, and
	// reset the template
	//
	formLayout -e -vis true $widgetList[1];
	setUITemplate -popTemplate;

	// Fill out the help menu item
	//
	if( size( $widgetList ) > 3 ) {
		string $helpMenuText = `menuItem -q -l $widgetList[3]`;
		$helpMenuText = $helpMenuText + $commandName;
		menuItem -e -l $helpMenuText 
				 -c ("help -doc " + $commandName) $widgetList[3];
	}

	// Call the setup "method" to fill in the current settings
	//
	eval (($setup + " " + $widgetList[0] + " false " + $node));	
    showWindow $widgetList[0];
}

global proc
performSound (int $showOptionBox, string $node)
{
	if ($showOptionBox) {
		soundOptions($node);
	}
	else {
		// Retrieve the option settings
		//
		setOptionVars (false, $node);

		// Execute the command with the option settings
		//
		editSoundNode $node;
	}
}
