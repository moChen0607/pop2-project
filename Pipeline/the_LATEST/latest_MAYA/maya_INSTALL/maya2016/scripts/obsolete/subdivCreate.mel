// Copyright (C) 1997-2014 Autodesk, Inc., and/or its licensors.
// All rights reserved.
//
// The coded instructions, statements, computer programs, and/or related
// material (collectively the "Data") in these files contain unpublished
// information proprietary to Autodesk, Inc. ("Autodesk") and/or its licensors,
// which is protected by U.S. and Canadian federal copyright law and by
// international treaties.
//
// The Data is provided for use exclusively by You. You have the right to use,
// modify, and incorporate this Data into other products for purposes authorized 
// by the Autodesk software license agreement, without fee.
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND. AUTODESK
// DOES NOT MAKE AND HEREBY DISCLAIMS ANY EXPRESS OR IMPLIED WARRANTIES
// INCLUDING, BUT NOT LIMITED TO, THE WARRANTIES OF NON-INFRINGEMENT,
// MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE, OR ARISING FROM A COURSE 
// OF DEALING, USAGE, OR TRADE PRACTICE. IN NO EVENT WILL AUTODESK AND/OR ITS
// LICENSORS BE LIABLE FOR ANY LOST REVENUES, DATA, OR PROFITS, OR SPECIAL,
// DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES, EVEN IF AUTODESK AND/OR ITS
// LICENSORS HAS BEEN ADVISED OF THE POSSIBILITY OR PROBABILITY OF SUCH DAMAGES.

//
//
//  Creation Date:  February 4, 1999
//
//
//  Description:
//  Create a subdivision surface from a poly mesh or a NURBS surface
//
//
proc string doSubdivCreateFromNurbs( string $nurbs )
{
	string $converter = `createNode nurbsToSubdiv`;
	// ALWAYS connect to the world attribute
	eval("connectAttr -force " + $nurbs + ".ws "  + $converter + ".inputSurface");
	string $subdiv = `createNode subdiv`;
	eval("connectAttr -force " + $converter + ".outputSubd " + $subdiv + ".create");
	eval("setAttr " + $subdiv + ".dispGeometry true");
	eval("setAttr " + $subdiv + ".dispVertices false");
	eval("setAttr " + $subdiv + ".dispEdges false");
	eval("setAttr " + $subdiv + ".dispFaces false");
	eval("setAttr " + $subdiv + ".dispResolution 1");
	
	// hide the original nurbs 
	eval("hide " + $nurbs);

	// select the transform for the newly created subdiv surface
	string $parent[]= `listRelatives -parent $subdiv`;
	eval("select -replace " + $parent[0]);

	return $subdiv;
}

proc string doSubdivCreateFromPoly(string $poly)
{
	string $converter = `createNode polyToSubdiv`;
	// ALWAYS connect to the world attribute
	eval("connectAttr -force " + $poly + ".worldMesh "  + $converter + ".inMesh");
	string $subdiv = `createNode subdiv`;
	eval("connectAttr -force " + $converter + ".outSubdiv " + $subdiv + ".create");
	eval("setAttr " + $subdiv + ".dispGeometry true");
	eval("setAttr " + $subdiv + ".dispVertices false");
	eval("setAttr " + $subdiv + ".dispEdges false");
	eval("setAttr " + $subdiv + ".dispFaces false");
	eval("setAttr " + $subdiv + ".dispResolution 1");
	
	// hide the original poly mesh 
	eval("hide " + $poly);

	// select the transform for the newly created subdiv surface
	string $parent[]= `listRelatives -parent $subdiv`;
	eval("select -replace " + $parent[0]);

	return $subdiv;
}

global proc int subdivCreate() 
{

	// extract all poly meshes
	string $polyList[] = `filterExpand -expand true -selectionMask 12`; 
	int $polyLen = size($polyList);

	// extract all nurbs
	string $nurbsList[] = `filterExpand -expand true -selectionMask 10`; 
	int $nurbsLen = size($nurbsList);

	int $len = $polyLen + $nurbsLen;

	if ($len == 0) {
	  error ("Select a polygon or a NURBS surface " +
			 "from which you want to create a subdivision surface.");
	  return 0;
	}

	string $subdiv;

	// convert polys one at a time
	for($i = 0; $i < $polyLen; $i++) {
	  $subdiv = doSubdivCreateFromPoly($polyList[$i]);
	  print ("// Created subdiv surface " + $subdiv + "\n");
	}

	// convert nurbs one at a time
	for($i = 0; $i < $nurbsLen; $i++) {
	  $subdiv = doSubdivCreateFromNurbs($nurbsList[$i]);
	  print ("// Created subdiv surface " + $subdiv + "\n");
	}

	return 1;
}
