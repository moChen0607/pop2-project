/*********************************************************************NVMH3****

File:  $Id: //sw/devtools/FXComposer2/Alpha4+/SDK/MEDIA/CgFX1.4/uvDetective.cgfx#1 $

Copyright NVIDIA Corporation 2004-2005
TO THE MAXIMUM EXTENT PERMITTED BY APPLICABLE LAW, THIS SOFTWARE IS PROVIDED
*AS IS* AND NVIDIA AND ITS SUPPLIERS DISCLAIM ALL WARRANTIES, EITHER EXPRESS
OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS FOR A PARTICULAR PURPOSE.  IN NO EVENT SHALL NVIDIA OR ITS SUPPLIERS
BE LIABLE FOR ANY SPECIAL, INCIDENTAL, INDIRECT, OR CONSEQUENTIAL DAMAGES
WHATSOEVER (INCLUDING, WITHOUT LIMITATION, DAMAGES FOR LOSS OF BUSINESS PROFITS,
BUSINESS INTERRUPTION, LOSS OF BUSINESS INFORMATION, OR ANY OTHER PECUNIARY LOSS)
ARISING OUT OF THE USE OF OR INABILITY TO USE THIS SOFTWARE, EVEN IF NVIDIA HAS
BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGES.


Comments:
	Look for regions where desired texture reso is dominant.
	Set desired size in the "Reso" parameter
	In the "TexRez" techniques, areas of red and green mean that in those
		area a lower-res MIP level will be used. Blue areas can use maps of higher
		res than the selected reso. Note that you should size the object to
		the approxiamte size of the expected final view!

******************************************************************************/

// for generated MipTex - TEX_RESO should be 2^TEX_LEVELS
#define TEX_LEVELS 9
#define TEX_RESO 512

/************************************************************/
/*** TWEAKABLES *********************************************/
/************************************************************/

int Reso = 512;
static float TargetDeriv = 1.0f/((float)Reso);
static float HalfTD = (TargetDeriv*0.5);
static float TwoTD = (TargetDeriv*2.0);

static float Diagonal = sqrt(2.0*TargetDeriv*TargetDeriv);
static float HalfDiag = (Diagonal*0.5);
static float TwoDiag = (Diagonal*2.0);

float Scale : UNITSSCALE
<
    string UIWidget = "slider";
    float UIMin = 1;
    float UIMax = 64.0;
    float UIStep = 1;
    string UIName = "Scale for uvDerivs technique";
> = 64.0;

/************* UN-TWEAKABLES **************/

float4x4 WorldITXf : WorldInverseTranspose < string UIWidget="None"; >;
float4x4 WorldViewProjectionXf : WorldViewProjection < string UIWidget="None"; >;
float4x4 WorldXf : World < string UIWidget="None"; >;
float4x4 ViewIXf : ViewInverse < string UIWidget="None"; >;

float2 ScreenSize : VIEWPORTPIXELSIZE < string UIWidget="None"; >;

/***************************************************/
/********** SAMPLER ********************************/
/***************************************************/

texture ColorTex <
	string ResourceName = "default_color.dds";
	string ResourceType = "2D";
    string UIName = "Preview Texture";
>;

sampler2D ColorSampler = sampler_state {
	Texture = <ColorTex>;
  	MagFilter = Linear;
  	MinFilter = LinearMipmapLinear;
};

/************ Texture ***********/

float4 mip_colors(float2 Pos:POSITION,float2 dP:PSIZE) : COLOR
{
	float d = 1.0/((dP.x+dP.y)/2.0);
	float3 p = 0;
	if (d < 8) {
		p = 1;
	} else {
		float q = log(d)/log(2);
		q = floor(q+.5);
		if (fmod(q,3) == 0) { p.x = .5;}
		if (fmod(q,6) == 0) { p.x = 1;}
		if (fmod(q,2) == 0) { p.y = .5;}
		if (fmod(q,4) == 0) { p.y = 1;}
		q = q / TEX_LEVELS;
		p.z = q;
	}
	return float4(p,1);
}

texture MipTex  <
    string TextureType = "2D";
    string function = "mip_colors";
    string UIWidget = "None";
    int width = TEX_RESO;
    int height = TEX_RESO;
>;

sampler2D MipSamp = sampler_state 
{
    texture = <MipTex>;
    WrapS  = Repeat;        
    WrapT  = Repeat;
	MinFilter = LinearMipMapLinear;
	MagFilter = Linear;
};

/************* DATA STRUCTS **************/

/* data from application vertex buffer */
struct appdata {
    float3 Pos    : POSITION;
    float4 UV        : TEXCOORD0;
    float4 Normal    : NORMAL;		// use in seeTex
};

/* data passed from vertex shader to pixel shader */
struct vertexOutput {
    float4 HPosition    : POSITION;
    float2 UV    : TEXCOORD0;
    float3 WorldNormal    : TEXCOORD1;
    float3 WorldView    : TEXCOORD2;
};

/*********** vertex shader for all ******/

vertexOutput simpleVS(appdata IN) {
    vertexOutput OUT = (vertexOutput)0;
    float4 Po = float4(IN.Pos,1.0);
    OUT.HPosition = mul(WorldViewProjectionXf, Po);
    OUT.UV = IN.UV.xy;
    OUT.WorldNormal = mul(WorldITXf, IN.Normal).xyz;
    float3 Pw = mul(WorldXf, Po).xyz;
    float3 Ew = float3(ViewIXf[0].w, ViewIXf[1].w, ViewIXf[2].w);
    OUT.WorldView = Ew - Pw;
    return OUT;
}

/********* utility functions for pixel shaders ********/

float4 vecColor(float4 V) {
    float3 Nc = 0.5 * ((V.xyz) + ((1.0).xxx));
    return float4(Nc,1);
}

float4 vecColor(float3 V) {
    float3 Nc = 0.5 * ((V.xyz) + ((1.0).xxx));
    return float4(Nc,1);
}

float4 vecColorN(float4 V) {
    float3 Nc = 0.5 * (normalize(V.xyz) + ((1.0).xxx));
    return float4(Nc,1);
}

float4 vecColorN(float3 V) {
    float3 Nc = 0.5 * (normalize(V.xyz) + ((1.0).xxx));
    return float4(Nc,1);
}

/********* pixel shaders ********/

float4 uvcPS(vertexOutput IN) : COLOR { return float4(IN.UV,0,1); }

float4 uvDerivsPS(vertexOutput IN) : COLOR
{
    float2 dd = Scale * (abs(ddx(IN.UV)) + abs(ddy(IN.UV)));
    return float4(dd,0,1);
}


float4 dv_col(float2 d)
{
    float4 dd = float4(0,0,0,1);
    if (d.x > TwoTD) { dd.x = 1.0;}
    if (d.y > TwoTD) { dd.y = 1.0;}
    if (d.x < HalfTD) { dd.z = 1.0;}
    //if (d.y < HalfTD) { dd.z = 1.0;}
    return(dd);
}

float4 texSizeXPS(vertexOutput IN) : COLOR
{
    return dv_col(abs(ddx(IN.UV)));
}
float4 texSizeYPS(vertexOutput IN) : COLOR
{
    return dv_col(abs(ddy(IN.UV)));
}

float4 texSizeDPS_old(vertexOutput IN) : COLOR
{
	float2 dx = ddx(IN.UV);
	float2 dy = ddy(IN.UV);
	float2 du = float2(dx.x,dy.x);
	float2 dv = float2(dx.y,dy.y);
    float d = sqrt(dot(du,du) + dot(dv,dv));
    float4 yc = dv_col(abs(ddy(IN.UV)));
    float4 dd = float4(0,0,0,1);
    if (d > TwoDiag) { dd.x = 1.0;}
    if (d > TwoDiag) { dd.y = 1.0;}
    if (d < HalfDiag) { dd.z = 1.0;}
    //if (d.y < HalfDiag) { dd.z = 1.0;}
    return(dd);
}

float4 texSizeDPS(vertexOutput IN) : COLOR
{
	float2 dx = ddx(IN.UV);
	float2 dy = ddy(IN.UV);
    float d = sqrt(dot(dx,dx) + dot(dy,dy));
    float4 yc = dv_col(abs(ddy(IN.UV)));
    float4 dd = float4(0,0,0,1);
    if (d > TwoDiag) { dd.x = 1.0;}
    if (d > TwoDiag) { dd.y = 1.0;}
    if (d < HalfDiag) { dd.z = 1.0;}
    //if (d.y < HalfDiag) { dd.z = 1.0;}
    return(dd);
}

float4 mtPS(vertexOutput IN) : COLOR { return tex2D(MipSamp,IN.UV); }

float4 texturePreviewPS(vertexOutput IN) : COLOR {
    float3 Nn = normalize(IN.WorldNormal);
    float3 Vn = normalize(IN.WorldView);
	Nn = faceforward(Nn,-Vn,Nn);
	float lt = max(dot(Nn,Vn),0);
	lt = 0.25 + 0.75 * lt;
	return tex2D(ColorSampler,IN.UV) * lt;
}

/****************************************************************/
/****************************************************************/
/******* TECHNIQUES *********************************************/
/****************************************************************/
/****************************************************************/

#define TECH(name,vertShader,pixShader) technique name { pass p0 { \
		VertexProgram = compile vp30 vertShader (); \
		DepthTestEnable = true; DepthMask = true; CullFaceEnable = false; DepthFunc = LEqual; \
		FragmentProgram = compile fp30 pixShader (); } }

TECH(texRezDiagonal,simpleVS,texSizeDPS)
TECH(texRezX,simpleVS,texSizeXPS)
TECH(texRezY,simpleVS,texSizeYPS)
TECH(uvValues,simpleVS,uvcPS)
TECH(uvDerivs,simpleVS,uvDerivsPS)
TECH(mipTex,simpleVS,mtPS)
TECH(previewTex,simpleVS,texturePreviewPS)

/***************************** eof ***/
