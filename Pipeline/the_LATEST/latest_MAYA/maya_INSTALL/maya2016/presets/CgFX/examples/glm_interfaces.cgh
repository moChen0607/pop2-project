/*********************************************************************NVMH3****
Path:  $Id: //sw/devtools/FXComposer2/Alpha4+/SDK/MEDIA/CgFX1.4/glm_interfaces.cgh#1 $

Copyright NVIDIA Corporation 2005
TO THE MAXIMUM EXTENT PERMITTED BY APPLICABLE LAW, THIS SOFTWARE IS PROVIDED
*AS IS* AND NVIDIA AND ITS SUPPLIERS DISCLAIM ALL WARRANTIES, EITHER EXPRESS
OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS FOR A PARTICULAR PURPOSE.  IN NO EVENT SHALL NVIDIA OR ITS SUPPLIERS
BE LIABLE FOR ANY SPECIAL, INCIDENTAL, INDIRECT, OR CONSEQUENTIAL DAMAGES
WHATSOEVER (INCLUDING, WITHOUT LIMITATION, DAMAGES FOR LOSS OF BUSINESS PROFITS,
BUSINESS INTERRUPTION, LOSS OF BUSINESS INFORMATION, OR ANY OTHER PECUNIARY LOSS)
ARISING OUT OF THE USE OF OR INABILITY TO USE THIS SOFTWARE, EVEN IF NVIDIA HAS
BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGES.

Comments:
	* You can use this shader as a handy platform for further experimentation. For example,
		consider adding reflections, or normal mapping, or additional lamps. Change the BRDF
		to be metallic, or other more exotic materials.
	* Note the compile-time texture flag.

******************************************************************************/

#ifndef _GLM_INTERFACES_CGH_
#define _GLM_INTERFACES_CGH_

/////////////////////////////////////////////////////////////////////
// OUR SIMPLE LIGHTING INTERFACE AND RELATED STRUCTS ////////////////
/////////////////////////////////////////////////////////////////////

//
// Lighting calculations for any given lamp will return two components: the
//		diffuse spading, and the specular shading.
//
struct LightResult {
	float3 DiffContrib;
	float3 SpecContrib;
};

//
// While shading any point we want to know the color of the light
//	and the direction to the light. This may be constant for a distant
//	source or reclaculated per-pixel for a point source. Color may
//	be affected by textures etc -- e.g., for a spot light or slide projector
//
struct LightInfo {
	float3 Color;	// color of lamp
	float3 Ln;		// normalized light vector for the current shaded point
};

//
// While shading any point we want to know a few things about the surface
//	and the viewer. Wat is the orientation of the surface (normal), the direction
//	to the viewer's eye? How coarse or smooth is the surface? Two different surface
//	colors are provided, one for diffuse and one for specular. For pure metals,
//	these two colors will be the same (or the diffuse may be a lower value, or even zero).
//	Dieletric materials: plastics, flesh, etc -- typically have a white specular color.
//	Most real metals have a slight desatured diffuse tone, which can help create the
//	illusion of a little bit of dirtiness.
//
struct SurfaceInfo {
	float3 Nn;			// normalized surface normal vector
	float3 Vn;			// normalized view vector
	float SpecExpon;	// using lit() implies phong style: <12 = rough, >30 = smooth...
	float3 DiffColor;	// for pure metals, ONLY specular is visible - diffuse
	float3 SpecColor;	//   is black. Usually there's SOME dirt though...
};

//
// Combining the above info allows us to calculate a BRDF. We make our
//	BRDF to be ACCUMULATIVE so that it can be looped over multiple lights.
//
interface SimpleBRDF {
	LightResult brdf(SurfaceInfo S,LightInfo L,LightResult Prev);
};

/////////////////////////////////////////////////////////////////////
// OUR SIMPLE BRDF, BASED ON CG'S BUILT-IN lit() FUNCTION ///////////
/////////////////////////////////////////////////////////////////////

//
// Simple BRDF using the lit() built-in function
//	Isolating the BRDF as an interface makes the
//	overall effect easier to edit and change.
//

struct StandardSurface : SimpleBRDF {
	LightResult brdf(SurfaceInfo S,LightInfo L,LightResult Prev) {
		LightResult R = (LightResult)0;
		float3 Hn = normalize(S.Vn + L.Ln);
		float4 litV = lit(dot(L.Ln,S.Nn),dot(Hn,S.Nn),S.SpecExpon); // we use the built-in "lit()" function
		R.DiffContrib = Prev.DiffContrib + (litV.y * Kd * L.Color * S.DiffColor);
		R.SpecContrib = Prev.SpecContrib + (litV.z * L.Color * S.SpecColor);
		return R;
	}
}

// stdSurf : StandardSurface;

#endif /* ! _GLM_INTERFACES_CGH_ */

////////////////////////////////////
//////////////////////////// eof ///
////////////////////////////////////
