/*********************************************************************NVMH3****
Path:  NVSDK\Common\media\cgfx
File:  $Id: //sw/devtools/FXComposer2/Alpha4+/SDK/MEDIA/CgFX1.4/xfFiniteReflect.cgfx#1 $

Copyright NVIDIA Corporation 2002
TO THE MAXIMUM EXTENT PERMITTED BY APPLICABLE LAW, THIS SOFTWARE IS PROVIDED
*AS IS* AND NVIDIA AND ITS SUPPLIERS DISCLAIM ALL WARRANTIES, EITHER EXPRESS
OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS FOR A PARTICULAR PURPOSE.  IN NO EVENT SHALL NVIDIA OR ITS SUPPLIERS
BE LIABLE FOR ANY SPECIAL, INCIDENTAL, INDIRECT, OR CONSEQUENTIAL DAMAGES
WHATSOEVER (INCLUDING, WITHOUT LIMITATION, DAMAGES FOR LOSS OF BUSINESS PROFITS,
BUSINESS INTERRUPTION, LOSS OF BUSINESS INFORMATION, OR ANY OTHER PECUNIARY LOSS)
ARISING OUT OF THE USE OF OR INABILITY TO USE THIS SOFTWARE, EVEN IF NVIDIA HAS
BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGES.


Comments:
	Finite-distance reflection
	$Date: 2006/04/10 $

******************************************************************************/

// string Category = "Effects\\Cg\\BRDF";
// string keywords = "dx9,texture,anti-aliasing,derivatives,pointlight";
// string description = "Analytic Anti-aliasing - No Texture Map";

/************* UNTWEAKABLES **************/

float4x4 WorldITXf : WorldInverseTranspose;
float4x4 WorldViewProjXf : WorldViewProjection;
float4x4 WorldXf : World;
float4x4 ViewITXf : ViewInverseTranspose;
float4x4 ViewIXf : ViewInverse;
float4x4 WorldViewXf : WorldView;

/************* TWEAKABLES **************/

float3 SurfColor : Diffuse <
    string UIName = "Surface Color";
> = {1.0f, 0.4f, 0.0f};

float Kr <
    string UIWidget = "slider";
    float uimin = 0.0;
    float uimax = 2.0;
    float uistep = 0.01;
    string UIName = "specular";
> = 0.5;

float KrMin <
    string UIWidget = "slider";
    float uimin = 0.0;
    float uimax = 0.9;
    float uistep = 0.01;
    string UIName = "specular";
> = 0.05;

float FresExp : POWER <
    string UIWidget = "slider";
    float uimin = 1.0;
    float uimax = 6.0;
    float uistep = 0.1;
    string UIName = "specular";
> = 5.0;

float Bumpiness <
    string UIWidget = "slider";
    float uimin = 0.0;
    float uimax = 5.0;
    float uistep = 0.01;
    string UIName = "bumpy";
> = 1.0;

float4x4 UserXf;
float4x4 UserITXf;

//////////////////////

texture normalMap : Normal <
	string ResourceName = "Default_bump_normal.dds";
	string ResourceType = "2D";
>;

sampler2D NormalSampler = sampler_state {
	Texture = <normalMap>;
	MinFilter = LinearMipMapLinear;
	MagFilter = Linear;
};

/////

texture envMap : Environment <
	string ResourceName = "Default_reflection.dds";
	string ResourceType = "Cube";
>;

samplerCUBE EnvSampler = sampler_state {
	Texture = <envMap>;
	MinFilter = LinearMipMapLinear;
	MagFilter = Linear;
	WrapS = ClampToEdge;
	WrapT = ClampToEdge;
};

/************* DATA STRUCTS **************/

/* data from application vertex buffer */
struct appdata {
    float3 Position	: POSITION;
    float4 UV		: TEXCOORD0;
    float4 Normal	: NORMAL;
    float4 Tangent	: TEXCOORD1;
    float4 Binormal	: TEXCOORD2;
};

/* data passed from vertex shader to pixel shader */
struct vertexOutput {
    float4 HPosition	: POSITION;
    float4 TexCoord	: TEXCOORD0;
    float3 UserNormal	: TEXCOORD1;
    float3 WorldEyeVec	: TEXCOORD2;
    float3 UserTangent	: TEXCOORD3;
    float3 UserBinorm	: TEXCOORD4;
    float3 UserEyeVec	: TEXCOORD5;
    float3 UserPos	: TEXCOORD6;
};

/*********** vertex shader ******/

vertexOutput mainVS(appdata IN) {
    vertexOutput OUT;
    float4 Po = float4(IN.Position.xyz,1.0);
    float4 Pw = mul(WorldXf, Po);
    OUT.TexCoord = IN.UV;
    float3 WorldEyePos = ViewITXf[3].xyz;
    float4 UserEyePos = mul(UserXf,float4(WorldEyePos,1.0));
    float4 hpos = mul(WorldViewProjXf, Po);
    float4 Pu = mul(UserXf,Pw);
    float4 Nw = mul(WorldITXf, IN.Normal);
    float4 Tw = mul(WorldITXf, IN.Tangent);
    float4 Bw = mul(WorldITXf, IN.Binormal);
    OUT.UserEyeVec = (UserEyePos - Pu).xyz;
    OUT.WorldEyeVec = normalize(WorldEyePos - Pw.xyz);
    OUT.UserNormal = mul(UserITXf,Nw).xyz;
    OUT.UserTangent = mul(UserITXf,Tw).xyz;
    OUT.UserBinorm = mul(UserITXf,Bw).xyz;
    OUT.UserPos = mul(UserXf,Pw).xyz;
    OUT.HPosition = hpos;
    return OUT;
}

/********* pixel shader ********/

// PS with box-filtered step function
float4 mainPS(vertexOutput IN) : COLOR {
    float3 Vu = normalize(IN.UserEyeVec);
    float3 Nu = normalize(IN.UserNormal);
    float3 Tu = normalize(IN.UserTangent);
    float3 Bu = normalize(IN.UserBinorm);
    float3 bumps = Bumpiness * (tex2D(NormalSampler,IN.TexCoord.xy).xyz-(0.5).xxx);
    float3 Nb = Nu + (bumps.x * Tu + bumps.y * Bu);
    Nb = normalize(Nb);	// expressed in user-coord space
    float vdn = dot(Vu,Nu);
    float fres =  KrMin + (Kr-KrMin) * pow((1.0-abs(vdn)),FresExp);
    float3 reflVect = normalize(reflect(Vu,Nb));	// yes, normalize
    // we are using the coord sys of the refelction, so to simplify things we assume (radius == 1)
    float b = -2.0 * dot(reflVect,IN.UserPos);
    float c = dot(IN.UserPos,IN.UserPos) - 1.0;
    float discrim = b*b - 4.0*c;
    bool hasIntersects = false;
    float nearT = 0;
    float3 reflColor = float3(1,0,0);
    if (discrim > 0) {
	discrim = sqrt(discrim);
	nearT = -(discrim-b)/2.0;
	hasIntersects=true;
	if (nearT <= 0.0001) {
	    nearT = (discrim - b)/2.0;
	    hasIntersects = (nearT>0.0001);
	}
    }
    if (hasIntersects) {
		reflVect = -IN.UserPos + nearT*reflVect;
		reflColor = fres * texCUBE(EnvSampler,reflVect).xyz;
    }
    float3 result = SurfColor * reflColor;
    return float4(result.xyz,1.0);
}

// PS with box-filtered step function
float4 flipPS(vertexOutput IN) : COLOR {
    float3 Vu = normalize(IN.UserEyeVec);
    float3 Nu = normalize(IN.UserNormal);
    float3 Tu = normalize(IN.UserTangent);
    float3 Bu = normalize(IN.UserBinorm);
    float3 bumps = Bumpiness * (tex2D(NormalSampler,IN.TexCoord.xy).xyz-(0.5).xxx);
    float3 Nb = Nu + (bumps.x * Tu + bumps.y * Bu);
    Nb = normalize(Nb);	// expressed in user-coord space
    float vdn = dot(Vu,Nu);
    float fres =  KrMin + (Kr-KrMin) * pow((1.0-abs(vdn)),FresExp);
    float3 reflVect = normalize(reflect(Vu,Nb));	// yes, normalize
    // we are using the coord sys of the refelction, so to simplify things we assume (radius == 1)
    float b = -2.0 * dot(reflVect,IN.UserPos);
    float c = dot(IN.UserPos,IN.UserPos) - 1.0;
    float discrim = b*b - 4.0*c;
    bool hasIntersects = false;
    float nearT = 0;
    float3 reflColor = float3(1,0,0);
    if (discrim > 0) {
	discrim = sqrt(discrim);
	nearT = -(discrim-b)/2.0;
	hasIntersects=true;
	if (nearT <= 0.0001) {
	    nearT = (discrim - b)/2.0;
	    hasIntersects = (nearT>0.0001);
	}
    }
    if (hasIntersects) {
	reflVect = -IN.UserPos + nearT*reflVect;
	reflVect.y = -reflVect.y;
	reflColor = fres * texCUBE(EnvSampler,reflVect).xyz;
    }
    float3 result = SurfColor * reflColor;
    return float4(result.xyz,1.0);
}

/*************/

technique yFlip {
    pass p0 {		
		VertexProgram = compile arbvp1 mainVS();
		DepthTestEnable = true;
		DepthMask = true;
		CullFaceEnable = false;
		FragmentProgram = compile arbfp1 flipPS();
    }
}

technique user {
    pass p0 {		
		VertexProgram = compile arbvp1 mainVS();
		DepthTestEnable = true;
		DepthMask = true;
		CullFaceEnable = false;
		FragmentProgram = compile arbfp1 mainPS();
    }
}

/***************************** eof ***/
