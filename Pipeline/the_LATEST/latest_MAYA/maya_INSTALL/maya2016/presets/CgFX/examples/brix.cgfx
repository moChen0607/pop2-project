/*********************************************************************NVMH3****
File:  $Id: //sw/devtools/FXComposer2/Alpha4+/SDK/MEDIA/CgFX1.4/brix.cgfx#1 $

Copyright NVIDIA Corporation 2002-2004
TO THE MAXIMUM EXTENT PERMITTED BY APPLICABLE LAW, THIS SOFTWARE IS PROVIDED
*AS IS* AND NVIDIA AND ITS SUPPLIERS DISCLAIM ALL WARRANTIES, EITHER EXPRESS
OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS FOR A PARTICULAR PURPOSE.  IN NO EVENT SHALL NVIDIA OR ITS SUPPLIERS
BE LIABLE FOR ANY SPECIAL, INCIDENTAL, INDIRECT, OR CONSEQUENTIAL DAMAGES
WHATSOEVER (INCLUDING, WITHOUT LIMITATION, DAMAGES FOR LOSS OF BUSINESS PROFITS,
BUSINESS INTERRUPTION, LOSS OF BUSINESS INFORMATION, OR ANY OTHER PECUNIARY LOSS)
ARISING OUT OF THE USE OF OR INABILITY TO USE THIS SOFTWARE, EVEN IF NVIDIA HAS
BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGES.


Comments:
    Brick pattern with controls using texture-based patterning.
    $Date: 2006/04/10 $

******************************************************************************/

// use obj-space or UV mappings for brick layout
// #define MODEL_UVS

float Script : STANDARDSGLOBAL <
    string UIWidget = "none";
    string ScriptClass = "object";
    string ScriptOrder = "standard";
    string ScriptOutput = "color";
    string Script = "Technique=brix;";
> = 0.8;

/*** TWEAKABLES *********************************************/

float3 LightDir : DIRECTION <
	string UIName = "Light Direction";
	string Object = "DirectionalLight";
	string Space = "World";
> = {0.577, -0.577, 0.577};

float4 AmbiColor : AMBIENT <
    string UIName = "Ambient Light Color";
> = {0.17f, 0.17f, 0.17f, 1.0f};

float4 SurfColor1 <
    string UIName = "Brick 1";
	string UIWidget = "Color";
> = {0.9, 0.5, 0.0, 1.0f};

float4 SurfColor2 <
    string UIName = "Brick 2";
	string UIWidget = "Color";
> = {0.8, 0.48, 0.15, 1.0f};

float4 GroutColor <
    string UIName = "Grout";
	string UIWidget = "Color";
> = {0.8f, 0.75f, 0.75f, 1.0f};

float BrickWidth : UNITSSCALE <
    string UNITS = "inches";
    string UIWidget = "slider";
    float UIMin = 0.001;
    float UIMax = 1.0;
    float UIStep = 0.001;
    string UIName = "Width";
> = 0.4;

float BrickHeight : UNITSSCALE <
    string UNITS = "inches";
    string UIWidget = "slider";
    float UIMin = 0.001;
    float UIMax = 1.0;
    float UIStep = 0.001;
    string UIName = "Height";
> = 0.25;

float GBalance <
    string UIWidget = "slider";
    float UIMin = 0.01;
    float UIMax = 0.25;
    float UIStep = 0.01;
    string UIName = "grouting";
> = 0.1;

///////////////////////////////////////////
// Procedural Texture /////////////////////
///////////////////////////////////////////

#ifdef PROC_STRIPE
#define TEX_SIZE 256

texture stripeTex <
    string function = "MakeStripe";
    float2 Dimensions = { TEX_SIZE, TEX_SIZE };
    string UIWidget = "None";
>;

float4 MakeStripe(float2 Pos : POSITION,float ps : PSIZE) : COLOR
{
   float v = 0;
   float nx = Pos.x+ps;
   v = nx > Pos.y;
   return float4(v.xxx,1.0);
}
#else /* !PROC_STRIPE */

texture stripeTex <
	string ResourceName = "aa_stripe.dds";
	string ResourceType = "2D";
	string UIName = "Stripe";
>;

#endif /* !PROC_STRIPE */

sampler2D stripeSampler = sampler_state
{
    Texture = <stripeTex>;
	MinFilter = LinearMipMapLinear;
	MagFilter = Linear;
    WrapS = Repeat;
    WrapT = Clamp;
};

/************* UN-TWEAKABLES **************/

float4x4 WorldITXf : WORLDINVERSETRANSPOSE <string UIWidget="None";>;
float4x4 WvpXf : WORLDVIEWPROJECTION <string UIWidget="None";>;
float4x4 WorldXf : WORLD <string UIWidget="None";>;
float4x4 ViewInvXf : VIEWINVERSE <string UIWidget="None";>;

/************* DATA STRUCTS **************/

/* data from application vertex buffer */
struct appdata {
    float3 Position    : POSITION;
    float4 UV        : TEXCOORD0;
    float4 Normal    : NORMAL;
};

/* data passed from vertex shader to pixel shader */
struct vertexOutput {
    float4 HPosition    : POSITION;
    float4 TexCoord    : TEXCOORD0;
    float3 WorldNormal    : TEXCOORD1;
    float3 WorldEyeVec    : TEXCOORD2;
    float4 BrickUV    : TEXCOORD3;
    float4 DCol : COLOR0;
};

/*********** vertex shader ******/

vertexOutput mainVS(appdata IN) {
    vertexOutput OUT;
    float3 Nw = normalize(mul(WorldITXf,IN.Normal).xyz);
    OUT.WorldNormal = Nw;
    OUT.DCol = max(0,dot(Nw,-LightDir)) + AmbiColor;
    float4 Po = float4(IN.Position.xyz,1);
    float3 Pw = mul(WorldXf, Po).xyz;
    OUT.TexCoord = IN.UV;
    OUT.WorldEyeVec = normalize(float3(ViewInvXf[0].w,ViewInvXf[0].w,ViewInvXf[0].w) - Pw);
    float4 hpos = mul(WvpXf, Po);
#ifndef MODEL_UVS
    OUT.BrickUV = float4(Po.x/BrickWidth,Po.y/BrickHeight,Po.zw);
#else /* MODEL_UVS */
    OUT.BrickUV = float4(IN.UV.y/BrickWidth,IN.UV.x/BrickHeight,Po.zw);
#endif /* MODEL_UVS */
    OUT.HPosition = hpos;
    return OUT;
}

/******************** pixel shader *********************/

float4 brixPS(vertexOutput IN) : COLOR {

#ifdef MAYA_TEXCOORD_ORIENTATION_OPENGL
    float GBalanceCorr = 1.0f - GBalance;
#else     
    float GBalanceCorr = GBalance;
#endif
    
    float v = ((float4)tex2D(stripeSampler,float2(IN.BrickUV.x,0.5))).x;
    float4 dColor1 = lerp(SurfColor1,SurfColor2,v);
    v = ((float4)tex2D(stripeSampler,float2(IN.BrickUV.x*2,GBalanceCorr))).x;
    dColor1 = lerp(GroutColor,dColor1,v);
    v = ((float4)tex2D(stripeSampler,float2(IN.BrickUV.x+0.25,0.5))).x;
    float4 dColor2 = lerp(SurfColor1,SurfColor2,v);
    v = ((float4)tex2D(stripeSampler,float2((IN.BrickUV.x+0.25)*2,GBalanceCorr))).x;
    dColor2 = lerp(GroutColor,dColor2,v);
    v = ((float4)tex2D(stripeSampler,float2(IN.BrickUV.y,0.5))).x;
    float4 brix = lerp(dColor1,dColor2,v);
    v = ((float4)tex2D(stripeSampler,float2(IN.BrickUV.y*2,GBalanceCorr))).x;
    brix = lerp(GroutColor,brix,v);
	return IN.DCol * brix;
}

/*************/

technique brix <
	string Script = "Pass=p0;";
> {
    pass p0 <
	string Script = "Draw=geometry;";
> {        
        VertexProgram = compile arbvp1 mainVS();
		DepthTestEnable = true;
		DepthMask = true;
		CullFaceEnable = false;
		DepthFunc = LEqual;
        FragmentProgram = compile arbfp1 brixPS();
    }
}

/***************************** eof ***/
