string description = "Relief Mapping by Fabio Policarpo";

float tile
<
	string UIName = "Tile Factor";
	string UIWidget = "slider";
	float UIMin = 1.0;
	float UIStep = 1.0;
	float UIMax = 32.0;
> = 8;

float depth
<
	string UIName = "Depth Factor";
	string UIWidget = "slider";
	float UIMin = 0.0f;
	float UIStep = 0.01f;
	float UIMax = 0.25f;
> = 0.1;

float3 ambient
<
	string UIName = "Ambient";
	string UIWidget = "color";
> = {0.2,0.2,0.2};

float3 diffuse
<
	string UIName = "Diffuse";
	string UIWidget = "color";
> = {1,1,1};

float3 specular
<
	string UIName = "Specular";
	string UIWidget = "color";
> = {0.75,0.75,0.75};

float shine
<
    string UIName = "Shine";
	string UIWidget = "slider";
	float UIMin = 8.0f;
	float UIStep = 8;
	float UIMax = 256.0f;
> = 128.0;

float4 lightpos
<
	string UIName="Light Position";
    string Object = "PointLight";
    string Space = "World";
> = { -150.0, 200.0, -125.0, 1 };

float4x4 modelviewproj : WorldViewProjectionTranspose;
float4x4 modelview : WorldViewTranspose;
float4x4 modelinv : WorldInverseTranspose;
float4x4 view : ViewTranspose;

texture texmap : DIFFUSE
<
    string ResourceName = "rockwall.jpg";
    string ResourceType = "2D";
>;

texture reliefmap : NORMAL
<
    string ResourceName = "rockwall.tga";
    string ResourceType = "2D";
>;

sampler2D texmap_sampler = sampler_state
{
	Texture = <texmap>;
	MagFilter = Linear;
	MinFilter = LinearMipmapLinear;
};

sampler2D reliefmap_sampler = sampler_state
{
	Texture = <reliefmap>;
	MagFilter = Linear;
	MinFilter = LinearMipmapLinear;
};

struct a2v 
{
    float4 pos		: POSITION;
    float4 color	: COLOR0;
    float3 normal	: NORMAL;
    float2 txcoord	: TEXCOORD0;
    float3 tangent	: TANGENT0;
    float3 binormal	: BINORMAL0;
};

struct v2f
{
    float4 hpos		: POSITION;
	float4 color	: COLOR0;
    float2 txcoord	: TEXCOORD0;
    float3 vpos		: TEXCOORD1;
    float3 tangent	: TEXCOORD2;
    float3 binormal	: TEXCOORD3;
    float3 normal	: TEXCOORD4;
	float4 lightpos	: TEXCOORD5;
};

v2f view_space(a2v IN)
{
	v2f OUT;

	// vertex position in object space
	float4 pos=float4(IN.pos.x,IN.pos.y,IN.pos.z,1.0);

	// compute modelview rotation only part
	float3x3 modelviewrot;
	modelviewrot[0]=modelview[0].xyz;
	modelviewrot[1]=modelview[1].xyz;
	modelviewrot[2]=modelview[2].xyz;

	// vertex position in clip space
	OUT.hpos=mul(pos,modelviewproj);

	// vertex position in view space (with model transformations)
	OUT.vpos=mul(pos,modelview).xyz;

	// light position in view space
	float4 lp=float4(lightpos.x,lightpos.y,lightpos.z,1);
	OUT.lightpos=mul(lp,view);

	// tangent space vectors in view space (with model transformations)
	OUT.tangent=mul(IN.tangent,modelviewrot);
	OUT.binormal=mul(IN.binormal,modelviewrot);
	OUT.normal=mul(IN.normal,modelviewrot);
	
	// copy color and texture coordinates
	OUT.color=IN.color;
	OUT.txcoord=IN.txcoord.xy;

	return OUT;
}

float4 normal_map(
	v2f IN,
	uniform sampler2D texmap,
	uniform sampler2D reliefmap) : COLOR
{
	float2 uv=IN.txcoord*tile;
	float4 normal=tex2D(reliefmap,uv);
	normal.xyz-=0.5; 
	
	// transform normal to world space
	normal.xyz=normalize(normal.x*IN.tangent-normal.y*IN.binormal+normal.z*IN.normal);
	
	// color map
	float4 color=tex2D(texmap,uv);

	// view and light directions
	float3 v = normalize(IN.vpos);
	float3 l = normalize(IN.lightpos.xyz-IN.vpos);

	// compute diffuse and specular terms
	float att=saturate(dot(l,IN.normal.xyz));
	float diff=saturate(dot(l,normal.xyz));
	float spec=saturate(dot(normalize(l-v),normal.xyz));

	// compute final color
	float4 finalcolor;
	finalcolor.xyz=ambient*color.xyz+
		att*(color.xyz*diffuse.xyz*diff+specular.xyz*pow(spec,shine));
	finalcolor.w=1.0;

	return finalcolor;
}

float4 parallax_map(
	v2f IN,
	uniform sampler2D texmap,
	uniform sampler2D reliefmap) : COLOR
{
   	// view and light directions
	float3 v = normalize(IN.vpos);
	float3 l = normalize(IN.lightpos.xyz-IN.vpos);

	float2 uv = IN.txcoord*tile;

	// parallax code
	float3x3 tbn = float3x3(IN.tangent,IN.binormal,IN.normal);
	float height = tex2D(reliefmap,uv).w * 0.06 - 0.03;
	uv += height * mul(tbn,v);

	// normal map
	float4 normal=tex2D(reliefmap,uv);
	normal.xyz-=0.5; 
	
	// transform normal to world space
	normal.xyz=normalize(normal.x*IN.tangent-normal.y*IN.binormal+normal.z*IN.normal);

	// color map
	float4 color=tex2D(texmap,uv);

	// compute diffuse and specular terms
	float att=saturate(dot(l,IN.normal.xyz));
	float diff=saturate(dot(l,normal.xyz));
	float spec=saturate(dot(normalize(l-v),normal.xyz));

	// compute final color
	float4 finalcolor;
	finalcolor.xyz=ambient*color.xyz+
		att*(color.xyz*diffuse.xyz*diff+specular.xyz*pow(spec,shine));
	finalcolor.w=1.0;

	return finalcolor;
}

float ray_intersect_rm(			// use linear and binary search
      in sampler2D reliefmap,
      in float2 dp, 
      in float2 ds)
{
   const int linear_search_steps=15;
   
   // current size of search window
   float size=1.0/linear_search_steps;
   // current depth position
   float depth=0.0;

   // search front to back for first point inside object
   for( int i=0;i<linear_search_steps-1;i++ )
   {
		float4 t=tex2D(reliefmap,dp+ds*depth);

		if (depth<t.w)
			depth+=size;
   }
   
   const int binary_search_steps=5;

   // recurse around first point (depth) for closest match
   for( int i=0;i<binary_search_steps;i++ )
   {
		size*=0.5;
		float4 t=tex2D(reliefmap,dp+ds*depth);
		if (depth<t.w)
			depth+=2*size;
		depth-=size;
   }

   return depth;
}

float ray_intersect_rm_lin(			// only linear search for shadows
      in sampler2D reliefmap,
      in float2 dp, 
      in float2 ds)
{
   const int linear_search_steps=15;

   // current size of search window
   float size=1.0/linear_search_steps;
   // current depth position
   float depth=0.0;

   // search front to back for first point inside object
   for( int i=0;i<linear_search_steps-1;i++ )
   {
		float4 t=tex2D(reliefmap,dp+ds*depth);

		if (depth<t.w)
			depth+=size;
   }
   
   return depth;
}

float4 relief_map_shadows(
	v2f IN,
	uniform sampler2D texmap,
	uniform sampler2D reliefmap) : COLOR
{
	float4 t,c;
	float3 p,v,l,s;
	float2 dp,ds,uv;
	float d,a;

	// ray intersect in view direction
	p  = IN.vpos;
	v  = normalize(p);
	a  = dot(IN.normal,-v);
	s  = float3(dot(v,IN.tangent.xyz), dot(v,IN.binormal.xyz), a);
	s  *= depth/a;
	ds = s.xy;
	dp = IN.txcoord*tile;
	d  = ray_intersect_rm(reliefmap,dp,ds);

	// get rm and color texture points
	uv=dp+ds*d;
	t=tex2D(reliefmap,uv);
	c=tex2D(texmap,uv);

	// expand normal from normal map in local polygon space
	t.xyz-=0.5;
	t.xyz=normalize(t.x*IN.tangent.xyz-t.y*IN.binormal.xyz+t.z*IN.normal);

	// compute light direction
	p += v*d/(a*depth);
	l=normalize(p-IN.lightpos.xyz);

	// compute diffuse and specular terms
	float att=saturate(dot(-l,IN.normal));
	float diff=saturate(dot(-l,t.xyz));
	float spec=saturate(dot(normalize(-l-v),t.xyz));

	// ray intersect in light direction
	dp+= ds*d;
	a  = dot(IN.normal,-l);
	s  = float3(dot(l,IN.tangent.xyz),dot(l,IN.binormal.xyz),a);
	s *= depth/a;
	ds = s.xy;
	dp-= ds*d;
	float dl = ray_intersect_rm_lin(reliefmap,dp,s.xy);
	if (dl<d-0.05) // if pixel in shadow
	{
	  diff*=dot(ambient.xyz,float3(1.0,1.0,1.0))*0.333333;
	  spec=0;
	}

	// compute final color
	float4 finalcolor;
	finalcolor.xyz=ambient*c+att*(c*diffuse*diff+specular.xyz*pow(spec,shine));
	finalcolor.w=1.0;

	return finalcolor;
}

float4 relief_map(
	v2f IN,
	uniform sampler2D texmap,
	uniform sampler2D reliefmap) : COLOR
{
	float4 t,c;
	float3 p,v,l,s;
	float2 dp,ds,uv;
	float d,a;

	// ray intersect in view direction
	p  = IN.vpos;
	v  = normalize(p);
	a  = dot(IN.normal,-v);
	s  = float3(dot(v,IN.tangent.xyz), dot(v,IN.binormal.xyz), a);
	s  *= depth/a;
	ds = s.xy;
	dp = IN.txcoord*tile;
	d  = ray_intersect_rm(reliefmap,dp,ds);

	// get rm and color texture points
	uv=dp+ds*d;
	t=tex2D(reliefmap,uv);
	c=tex2D(texmap,uv);

	// expand normal from normal map in local polygon space
	t.xyz-=0.5;
	t.xyz=normalize(t.x*IN.tangent.xyz-t.y*IN.binormal.xyz+t.z*IN.normal);

	// compute light direction
	p += v*d/(a*depth);
	l=normalize(p-IN.lightpos.xyz);

	// compute diffuse and specular terms
	float att=saturate(dot(-l,IN.normal));
	float diff=saturate(dot(-l,t.xyz));
	float spec=saturate(dot(normalize(-l-v),t.xyz));

	// compute final color
	float4 finalcolor;
	finalcolor.xyz=ambient*c+att*(c*diffuse*diff+specular.xyz*pow(spec,shine));
	finalcolor.w=1.0;

	return finalcolor;
}

technique normal_mapping
{
    pass p0 
    {
		DepthFunc = LEqual;
		DepthTestEnable = true;
		VertexProgram = compile arbvp1 view_space();
		FragmentProgram  = compile arbfp1 normal_map(texmap_sampler,reliefmap_sampler);
    }
}

technique parallax_mapping
{
    pass p0 
    {
		DepthFunc = LEqual;
		DepthTestEnable = true;
		VertexProgram = compile arbvp1 view_space();
		FragmentProgram  = compile arbfp1 parallax_map(texmap_sampler,reliefmap_sampler);
    }
}

technique relief_mapping
{
    pass p0 
    {
		DepthFunc = LEqual;
		DepthTestEnable = true;
		VertexProgram = compile arbvp1 view_space();
		FragmentProgram  = compile arbfp1 relief_map(texmap_sampler,reliefmap_sampler);
    }
}

technique relief_mapping_shadows
{
    pass p0 
    {
		DepthFunc = LEqual;
		DepthTestEnable = true;
		VertexProgram = compile arbvp1 view_space();
		FragmentProgram  = compile arbfp1 relief_map_shadows(texmap_sampler,reliefmap_sampler);
    }
}

