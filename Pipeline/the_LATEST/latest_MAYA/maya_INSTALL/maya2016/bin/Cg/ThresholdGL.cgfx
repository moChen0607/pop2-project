//**************************************************************************/
// Copyright (c) 2012 Autodesk, Inc.
// All rights reserved.
// 
// These coded instructions, statements, and computer programs contain
// unpublished proprietary information written by Autodesk, Inc., and are
// protected by Federal copyright law. They may not be disclosed to third
// parties or copied or duplicated in any form, in whole or in part, without
// the prior written consent of Autodesk, Inc.
//**************************************************************************/

// World-view-projection transformation.
float4x4 gWVPXf : WorldViewProjection < string UIWidget = "None"; >;

float4 gUVTransform : RelativeViewportDimensions;

// The source texture
texture gSourceTex : SourceTexture
<
    string UIName = "Source Texture";
>;

// Sampler of source texture
sampler2D gSourceSamp = sampler_state
{
    Texture = <gSourceTex>;
};

float gBrightThreshold = 0.8f;

struct VS_INPUT
{
    float4 Pos: POSITION;
    float2 UV: TEXCOORD0;
};

struct VS_TO_PS
{
    float4 HPos: POSITION;
    float2 UV: TEXCOORD0;
};

// Vertex shader.
VS_TO_PS VS_Threshold(VS_INPUT In)
{
    VS_TO_PS Out;
    
    // Transform the position from object space to clip space for output.
    Out.HPos = mul(In.Pos, gWVPXf);
    
    // Pass the texture coordinates unchanged.
    Out.UV = In.UV;
    
    return Out;
}

// Pixel shader: Simple blending between 2 images
float4 PS_Threshold(VS_TO_PS In) : COLOR0
{
    float4 val = tex2D(gSourceSamp, In.UV * gUVTransform.zw + gUVTransform.xy);

	float4 brightnessFactor = float4(0.212671f, 0.715160f, 0.072169f, 1.0f);
	float brightness = dot(brightnessFactor.xyz, val.xyz);
	if( brightness > gBrightThreshold)
		return float4(val.xyz, 1.0f);
	else
		return float4(0.0f, 0.0f, 0.0f, 1.0f);
}


// The main technique.
technique Main
{
    pass p0
    {
        VertexShader = compile glslv VS_Threshold();
        PixelShader = compile glslf PS_Threshold();
    }
}
