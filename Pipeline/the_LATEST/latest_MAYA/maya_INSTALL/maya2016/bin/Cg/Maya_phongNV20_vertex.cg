#include "Maya_lightView_vertex.cg"

float scaleAndBias(in float value)
{
    return 0.5 * (value + 1.0);
}

struct vert2frag
{
    float4 position            : POSITION;
#ifdef IS_SPECULAR
#ifdef HAS_BUMP
    float3 scaleBiasHalfAngleXYZ : TEXCOORD0;
    float2 textureCoordUV       : TEXCOORD1;
    float3 halfAngle1XYZ        : TEXCOORD2;
    float3 halfAngle2XYZ        : TEXCOORD3;
#else
    float3 kExponentU           : TEXCOORD0;
    float3 halfAngleTangZYX     : TEXCOORD1;
    float3 normalXYZ            : TEXCOORD2;
    float3 kExponentV           : TEXCOORD3;
#endif
#else
    float3 tangentLightDir      : TEXCOORD0;
    float2 texcoord             : TEXCOORD1;
#endif
};

// define inputs from application
struct app2vert
{
    float4 position           : POSITION;
    float3 normal             : NORMAL;
    float3 tangent            : TEXCOORD0;
#ifdef HAS_BUMP
    float4 texcoord           : TEXCOORD1;
#endif
};

vert2frag main(app2vert IN, 
               uniform float4x4 modelViewProj : _GL_MVP,
#ifdef IS_SPECULAR
               uniform float4 cameraPosObj,
               uniform float normalizedK,
#endif
#ifdef HAS_BUMP
               uniform float4x4 textureProjMatrix,
#endif
               uniform float3 lightDirObj,
               uniform float4 lightPosObj)
{
    vert2frag OUT;

#ifdef IS_SPECULAR

    float3 lightDirTang;
    float3 eyeVectorTang;
    computeLightViewVectors(
        IN.position,
        IN.normal,
        IN.tangent,
        cameraPosObj,
#ifdef IS_DIRECTIONAL_LIGHT
        lightDirObj,
#else
        lightPosObj,
#endif
        lightDirTang,
        eyeVectorTang);


    lightDirTang = normalize(lightDirTang);
    eyeVectorTang = normalize(eyeVectorTang);
    float3 halfAngleTang = normalize(eyeVectorTang + lightDirTang);


    OUT.position = mul(modelViewProj, IN.position);
#ifdef HAS_BUMP
    OUT.scaleBiasHalfAngleXYZ = float3(scaleAndBias(halfAngleTang[0]),
                                       scaleAndBias(halfAngleTang[1]),
                                       scaleAndBias(halfAngleTang[2]));
    OUT.textureCoordUV = mul(textureProjMatrix, IN.texcoord);
    OUT.halfAngle1XYZ = halfAngleTang;
    OUT.halfAngle2XYZ = halfAngleTang;
#else
    OUT.kExponentU = float3(1.0, 0.0, 0.0);
    OUT.halfAngleTangZYX = halfAngleTang.zyx;
	// Normal part of the (H dot N) calculation. Note that in tangent space, a geometric
	// normal is always (0,0,1). Like the precedent line, this vector's components are inverted
	// to avoid potential imprecision coming from HILO Z calculation.
    OUT.normalXYZ = float3(1.0, 0.0, 0.0);
    OUT.kExponentV = float3(normalizedK, 0.0, 0.0);
#endif

#else

    float3 lightDirTang;
    computeLightVector(
        IN.position,
        IN.normal,
        IN.tangent,
#ifdef IS_DIRECTIONAL_LIGHT
        lightDirObj,
#else
        lightPosObj,
#endif
        lightDirTang);

    OUT.position = mul(modelViewProj, IN.position);
    OUT.tangentLightDir = lightDirTang;
#ifdef HAS_BUMP
    OUT.texcoord = mul(textureProjMatrix, IN.texcoord);
#endif
#endif


    return OUT;
}
