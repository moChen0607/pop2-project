//**************************************************************************/
// Copyright 2012 Autodesk, Inc.  
// All rights reserved.
// Use of this software is subject to the terms of the Autodesk license 
// agreement provided at the time of installation or download, or which 
// otherwise accompanies this software in either electronic or hard copy form.   
//**************************************************************************/
//
// Sample shader to that can be used for shadow casting
// 
struct vertexInS 
{ 
    float3 Pm : POSITION; 
}; 

//  Declarations 

struct vertOutS 
{ 
    float3 Pw : TEXCOORD1; 
    float4 Pc : POSITION; 
}; 

//  Globals 

uniform float4x4 World : world; 
uniform float4x4 ViewProj : viewprojection; 
uniform float DepthPriority : depthpriority; 
uniform float4x4 WorldViewProj : worldviewprojection; 

//  Fragments 

float3 iPw( float3 pm, float4x4 world ) 
{ 
    return mul( world, float4(pm, 1.0f) ).xyz; 
} 

float4 iPcPriority( float3 pm, float depthPriority, float4x4 worldViewProjectionC )
{ 
    float4 P = mul( worldViewProjectionC, float4(pm,1) ); 
    P.z -= P.w * 2.0f * depthPriority; 
    return P; 
} 

// Vertex Shader 
//
 vertOutS VS( vertexInS inputs ) 
{ 
    vertOutS vOut; 
    vOut.Pw = iPw( inputs.Pm, World ); 
    vOut.Pc = iPcPriority ( inputs.Pm, DepthPriority, WorldViewProj ); 

    return vOut; 
 } 

struct fragInS 
{ 
    float3 Pw : TEXCOORD1; 
}; 

// Pixel Shader 
//
float4 mayaCreateShadowMapPS( float3 Pw, float4x4 shadowViewProj )
{
	float4 Pndc = mul( shadowViewProj, float4(Pw,1.0f));
	float retZ = 0.5f + 0.5f * Pndc.z / Pndc.w;
	retZ += fwidth(retZ);
	return (retZ).xxxx;
}

float4 FS( fragInS inputs ) : COLOR0
{
	return mayaCreateShadowMapPS( inputs.Pw, ViewProj );
} 

/////////////////////// Techniques /////// 

technique main
{ 
    pass P0 
    { 
        VertexProgram = compile glslv VS(); 
        GeometryProgram = NULL; 
        FragmentProgram = compile glslf FS(); 
    } 
 }
 
