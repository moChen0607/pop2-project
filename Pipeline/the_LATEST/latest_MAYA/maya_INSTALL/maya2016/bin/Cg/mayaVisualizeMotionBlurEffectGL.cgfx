//**************************************************************************/
// Copyright (c) 2012 Autodesk, Inc.
// All rights reserved.
// 
// These coded instructions, statements, and computer programs contain
// unpublished proprietary information written by Autodesk, Inc., and are
// protected by Federal copyright law. They may not be disclosed to third
// parties or copied or duplicated in any form, in whole or in part, without
// the prior written consent of Autodesk, Inc.
//**************************************************************************/
//
// Compiled Fragment: mayaVisualizeMotionBlur
//

/////////////////////////////////////////////////////////////////////////
// mayaVisualizeMotionBlur_VS

struct vertexInS 
{ 
    float3 Pm : POSITION; 
    float2 U0 : TEXCOORD0; 
}; 
 
//  Declarations 
struct vertexOutS 
{ 
    float4 Pc : POSITION; 
    float3 U0 : TEXCOORD0; 
}; 
 

struct fragInS 
{ 
    float4 Pc : POSITION; 
    float3 U0 : TEXCOORD0; 
}; 
 

//  Globals 
uniform float DepthPriority : depthpriority; 
uniform float4x4 WorldViewProj : worldviewprojection; 

//  Fragments 
float4 iPcPriority( float3 pm, float depthPriority, float4x4 worldViewProjectionC )
{ 
    float4 P = mul( worldViewProjectionC, float4(pm,1) ); 
    P.z -= P.w * depthPriority; 
    return P; 
} 

float3 iU0( float2 uv )
{ 
    return float3(uv,0); 
} 

 // Vertex Shader 
 vertexOutS mayaVisualizeMotionBlur_VS( vertexInS inputs ) 
 { 

     // ShaderBody 
    vertexOutS s_fragInS8644; 
    s_fragInS8644.Pc = iPcPriority ( inputs.Pm, DepthPriority, WorldViewProj ); 
    s_fragInS8644.U0 = iU0( inputs.U0 ); 

    return s_fragInS8644; 
 } 

//////////////////////////////////////////////////////////////////////////////////// 
// mayaVisualizeMotionBlur


//  Globals 
texture2D currentScene; 
sampler2D currentSceneSampler = sampler_state
{ 
    Texture = <currentScene>; 
}; 
texture2D currentVelocity; 
sampler2D currentVelocitySampler = sampler_state
{ 
    Texture = <currentVelocity>; 
}; 
texture2D previousScene; 
sampler2D previousSceneSampler =  sampler_state
{ 
    Texture = <previousScene>; 
}; 
texture2D previousVelocity; 
sampler2D previousVelocitySampler =  sampler_state
{ 
    Texture = <previousVelocity>; 
}; 

uniform float	shutterOpenFraction = 1.000000; 
uniform float	zThreshold = 0.100000; 
uniform int		blurStepCount = 8; 
// these currenly unused by visualizer
uniform float	motionFadeAmt = 0.0; 
uniform float	motionFadeEmphasis = 0.0; 
uniform float4	motionFadeTint = (float4)1; 


//  Fragments 
float3 U0( float3 iUV0 )
{ 
    return iUV0; 
} 

float4 mayaVisualizeMotionBlur( float3 pixelUV, 
			sampler2D curSceneSamp, texture2D curScene, 
			sampler2D curVelocitySamp, texture2D curVel, 
			sampler2D prevSceneSamp, texture2D prevScene, 
			sampler2D prevVelocitySamp, texture2D prevVel, 
           float shutterOpen,  float zThreshold, int nBlurSteps ) 
    { 
	 float4 bg; 
	 float stepDir; 
     float4 V0 = tex2D( curVelocitySamp, pixelUV.xy ); 
	 float z0 = V0.z; 
	 float4 clr = (float4)0; 
	 if( nBlurSteps == 4 )
	 {
		// this code visualizes the velocity buffer...the scalar shutterOpen shd be large 20~30
		// for bright color
		float2 cvec = 0.5 + (22.0 * V0.xy);
		clr = float4( cvec.x, cvec.y, 0.5f * V0.w, 1 ); // just visualize v0.xy in color range

	 } else if( nBlurSteps == 8 ) { 
		// this code dims & greens the previous velocity & lerps it with the current velocity via the shutterOpen slider
		float2 cvec = 0.5 + (22.0 * V0.xy);
		float2 pvec = 0.5 + (22.0 * tex2D( prevVelocitySamp, pixelUV.xy ).xy);
		clr = lerp( float4(cvec.x, cvec.y, 0.5 * V0.w, 1), 
					float4( 0.5f,0.6f,0.5f,1.0f) * float4(pvec.x, pvec.y, 0.5 * V0.w, 1), 
					0.5f ); //shutterOpen/32.0 );    

	 } else if( nBlurSteps == 16 ) { 
		// this code dims & greens the current velocity & lerps it with the current scene via the shutterOpen slider
		float2 cvec = 0.5 + (22.0 * V0.xy);
		clr = lerp( tex2D( curSceneSamp, pixelUV.xy ), 
					float4( 0.4f,0.5f,0.6f,1.0f) * float4(cvec.x, cvec.y, 0.5f * V0.w, 1), 
					0.5f ); //shutterOpen/32.0 );  

	 } else  { 
		// this code dims & blues the previous scene & lerps it with the scene via the shutterOpen slider
		clr = lerp( tex2D( curSceneSamp, pixelUV.xy ),
					float4( 0.5f,0.5f,1.0f,1.0f) * tex2D( prevSceneSamp, pixelUV.xy ), 
					0.5f ); //shutterOpen/32.0 );  
	 }

    return saturate(clr);  
} 


// mayaQuadraticMotionBlur Pixel Shader 
float4 mayaVisualizeMotionBlur_PS( fragInS inputs ) : COLOR0
{ 
     // ShaderBody 
    float3 v_U08643 = U0( inputs.U0 ); 
    float4 v_mayaVisualizeMotionBlur8641 = mayaVisualizeMotionBlur( v_U08643, //
		currentSceneSampler, currentScene, currentVelocitySampler, currentVelocity, 
		previousSceneSampler, previousScene, previousVelocitySampler, previousVelocity, 
		shutterOpenFraction, zThreshold, blurStepCount ); 

    return v_mayaVisualizeMotionBlur8641; 
 } 


/////////////////////// Techniques /////// 
technique main
{ 
    pass P0 
    { 
        VertexProgram = compile glslv mayaVisualizeMotionBlur_VS(); 
        FragmentProgram = compile glslf mayaVisualizeMotionBlur_PS(); 
    } 
 } 
