//
// File: Maya_Blends.cgh
//
// Description:
//		Include file with functions for computing Maya blending functions.
//
//
 
// Possible blend modes
#define kBlendNone		0
#define kBlendOver		1
#define kBlendIn		2
#define kBlendOut		3
#define kBlendAdd		4
#define kBlendAverage	5
#define kBlendSubtract	6
#define kBlendMultiply	7
#define kBlendDivide	8
#define kBlendDifference 9
#define kBlendLighten	10
#define kBlendDarken	11
#define kBlendSaturate	12
#define kBlendDesaturate 13
#define kBlendIlluminate 14

// User defined blending. Capability to add.
#define kBlendUser		20
 
 
 
#if defined (COLOR_PER_VERTEX_OPERATOR_replace)
	#define CPV_BLEND kBlendNone
#elif defined (COLOR_PER_VERTEX_OPERATOR_add)	
	#define CPV_BLEND kBlendAdd
#elif defined (COLOR_PER_VERTEX_OPERATOR_subtract)  
	#define CPV_BLEND kBlendSubtract
#elif defined (COLOR_PER_VERTEX_OPERATOR_modulate)  
	#define CPV_BLEND kBlendMultiply  
#elif defined (COLOR_PER_VERTEX_OPERATOR_divide)    
	#define CPV_BLEND kBlendDivide
#elif defined (COLOR_PER_VERTEX_OPERATOR_average)   
	#define CPV_BLEND kBlendAverage
#elif defined (COLOR_PER_VERTEX_OPERATOR_modulate2x)	
	#define CPV_BLEND kBlendIlluminate	
#else
	#define CPV_BLEND kBlendNone
#endif
 
 
float MAYA_computeLuminance(float3 color)
{
	return (0.3 * color.r + 0.59 * color.g + 0.11 * color.b);	
}
 
//  Blending function for layered texture
//
void MAYA_computeLayeredBlend(inout float4 baseColor, float4 layerColor, int blendMode, int alphaAsLuminance)
{
	if (blendMode == kBlendNone)
	{
		// Just replace the base color with the new layer
		// 
		baseColor = layerColor;
	}
	else if (blendMode == kBlendOver)
	{
		// Add the alpha modulated difference
		// 
		baseColor.rgb += (layerColor.rgb - baseColor.rgb) * layerColor.a;
		baseColor.a += layerColor.a - (baseColor.a * layerColor.a);
	}
	else if (blendMode == kBlendIn)
	{
		// Alpha modulated
		//
		baseColor *= layerColor.a;
	}
	else if (blendMode == kBlendOut)
	{
		// Inverse Alpha modulated
		//	
		baseColor *= (1.0 - layerColor.a);
	}
	else if (blendMode == kBlendAdd)
	{
		// Alpha modulated addition
		//
		baseColor.rgb += layerColor.rgb * layerColor.a;
	}
	else if (blendMode == kBlendAverage)
	{
		// Average Note this is not alpha attentuated
		//
		baseColor = (layerColor + baseColor) * .5;
	}
	else if (blendMode == kBlendSubtract)
	{
		// Alpha modulated substraction
		//
		baseColor.rgb -= layerColor.rgb * layerColor.a;
	}
	else if (blendMode == kBlendMultiply)
	{
		baseColor.rgb *= layerColor.rgb * layerColor.a + (1.0 - layerColor.a);
	}
	else if (blendMode == kBlendDivide)
	{
		baseColor.rgb /= layerColor.rgb * layerColor.a + (1.0 - layerColor.a);
	}
	else if (blendMode == kBlendDifference)
	{
		baseColor.rgb = (abs(layerColor.rgb - baseColor.rgb)) * layerColor.a + baseColor.rgb * (1.0 - layerColor.a);
	}
	else if (blendMode == kBlendLighten)
	{

		baseColor.rgb = (max(layerColor.rgb, baseColor.rgb)) * layerColor.a + baseColor.rgb * (1.0 - layerColor.a);
	}
	else if (blendMode == kBlendDarken)
	{
		baseColor.rgb = (min(layerColor.rgb, baseColor.rgb)) * layerColor.a + baseColor.rgb * (1.0 - layerColor.a);
	}
	else if (blendMode == kBlendSaturate)
	{
		baseColor.rgb *= (1.0 + layerColor.rgb * layerColor.a);
	}
	else if (blendMode == kBlendDesaturate)
	{
		baseColor.rgb *= (1.0 - layerColor.rgb * layerColor.a);
	}
	else if (blendMode == kBlendIlluminate)
	{
		baseColor.rgb *= 2.0 * layerColor.rgb * layerColor.a + 1.0 - layerColor.a;
	}

	// Need to clamp color to 0 - 1 range or colors will show up incorrectly.
	baseColor.r = clamp(baseColor.r, 0.0, 1.0); 
	baseColor.g = clamp(baseColor.g, 0.0, 1.0);
	baseColor.b = clamp(baseColor.b, 0.0, 1.0);
	
	if (blendMode != kBlendUser)
	{
		// Alpha is luminance of color
		if (alphaAsLuminance == 1)
			baseColor.a = MAYA_computeLuminance(baseColor.rgb);	
	}

	// Clamp alpha to 0 - 1(layerColor.rgb - baseColor.rgb) * layerColor.a;
	baseColor.a = clamp(baseColor.a, 0.0, 1.0);
}
