//**************************************************************************/
// Copyright 2014 Autodesk, Inc.
// All rights reserved.
// Use of this software is subject to the terms of the Autodesk license
// agreement provided at the time of installation or download, or which
// otherwise accompanies this software in either electronic or hard copy form.
//**************************************************************************/
//
// Maya Blinn (ogsfx)
//

// Vertex input structure
attribute APP_DATA 
{ 
    vec3 Pm : POSITION; 
    vec3 Nm : NORMAL; 
}; 

// Vertex output structure
attribute VS_TO_PS 
{ 
    vec3 Nw : TEXCOORD0; 
    vec3 Pw : TEXCOORD1; 
    vec3 Vw : TEXCOORD2; 
}; 

// Vertex shader output structure.
attribute pixelOut 
{
    vec4 colorOut: COLOR0;
}

//  Globals 
uniform mat4 WorldIT : worldinversetranspose; 
uniform mat4 World : world; 
uniform vec3 cameraPosition : worldcameraposition; 
uniform float DepthPriority : depthpriority; 
uniform mat4 WorldViewProj : worldviewprojection; 


uniform float mayaNormalMultiplier = 1.000000; 
uniform float mayaDirectionalLight_lightOn = 1.000000; 
uniform float mayaDirectionalLight_intensity = 1.000000; 
uniform vec3 mayaDirectionalLight_color = { 1.000000, 1.000000, 1.000000 }; 
uniform float mayaDirectionalLight_emitsDiffuse = 1.000000; 
uniform float mayaDirectionalLight_emitsSpecular = 1.000000; 
uniform vec3 mayaDirectionalLight_direction = { 0.004568, -0.332722, -0.943014 }; 
uniform texture2D mayaShadowPCF1_shadowMap; 
uniform sampler2D mayaShadowPCF1_shadowSamp =  sampler_state
{ 
    Texture = <mayaShadowPCF1_shadowMap>; 
}; 
uniform float mayaShadowPCF1_shadowBias = 0.002200; 
uniform int mayaShadowPCF1_shadowMapSize = 512; 
uniform mat4 mayaShadowPCF1_shadowViewProj; 
uniform vec3 mayaShadowPCF1_shadowColor = { 0.000000, 0.000000, 0.000000 }; 
uniform bool mayaShadowPCF1_mayaGlobalShadowOn = 0; 
uniform bool mayaShadowPCF1_mayaShadowOn = 0; 

uniform float blinn1eccentricity = 0.300000; 
uniform float blinn1specularRollOff = 0.700000; 
uniform float blinn1translucence = 0.000000; 
uniform float blinn1translucenceDepth = 0.500000; 
uniform float blinn1translucenceFocus = 0.500000; 
uniform vec3 blinn1color = { 0.200000, 0.600000, 1.000000 }; 
uniform vec3 blinn1transparency = { 0.000000, 0.000000, 0.000000 }; 
uniform vec3 blinn1ambientColor = { 0.000000, 0.000000, 0.000000 }; 
uniform vec3 blinn1incandescence = { 0.000000, 0.000000, 0.000000 }; 
uniform float blinn1diffuse = 0.800000; 
uniform vec3 blinn1specularColor = { 1.000000, 1.000000, 1.000000 }; 
uniform float blinn1reflectivity = 0.500000; 
uniform vec3 blinn1reflectedColor = { 0.000000, 0.000000, 0.000000 }; 
uniform float blinn1glowIntensity = 0.000000; 
uniform bool blinn1hideSource = 0; 
uniform float blinn1matteOpacity = 1.000000; 
uniform int blinn1matteOpacityMode = 2; 
uniform float blinn1outAlphaPassThrough = 1.000000; 

uniform vec3 ambientShader_ambientIllum = { 0.000000, 0.000000, 0.000000 }; 
uniform float specularRollOff = 0.700000; 

uniform float extraOpacity = 1.000000; 


// Vertex Shader 
GLSLShader MainVertexShader
{
	//  Vertex shader fragments 
	//
	vec3 iNw( vec3 nm, mat4 worldITC )
	{ 
		 return mul( worldITC, vec4(nm,0) ).xyz; 
	} 

	vec3 iPw( vec3 pm, mat4 world ) 
	{ 
		return mul( world, vec4(pm, 1.0f) ).xyz; 
	} 

	vec3 iVw( vec3 Pm, vec3 Ew, mat4 world  )
	{ 
		vec4 Pw = mul( world, vec4(Pm,1) ); 
		return Ew - Pw.xyz; 
	} 

	vec4 iPcPriority( vec3 pm, float depthPriority, mat4 worldViewProjectionC )
	{ 
		vec4 P = mul( worldViewProjectionC, vec4(pm,1) ); 
		P.z -= P.w * 2.0f * depthPriority; 
		return P; 
	} 

	void main()
	{ 
		Nw = iNw( Nm, WorldIT ); 
		Pw = iPw( Pm, World ); 
		Vw = iVw( Pm, cameraPosition, World ); 
		gl_Position = iPcPriority ( Pm, DepthPriority, WorldViewProj ); 
	} 
}

// Pixel Shader
GLSLShader MainPixelShader
{
	//  Declarations 
	struct irradiance { 
		vec3 diffuseI; 
		vec3 specularI; 
		vec3 Ld; 
		vec3 Ls; 
	}; 

	struct mayaSurfaceShaderOutput {
		vec3 outColor;
		vec3 outTransparency;
		vec3 outGlowColor;
		vec3 outMatteOpacity;
		float outAlphaPassThrough;
	};

	//  Pixel Shader Fragments 
	vec3 iNw( vec3 iNw )
	{ 
		return normalize( iNw ); 
	} 

	float FacingFactor( float facing )
	{ 
		return facing; 
	} 


	vec3 mayaNormalFlip(vec3 Nw, bool backFacing, float normalMultiplier) 
	{ 
		return normalMultiplier * (backFacing ? -Nw : Nw); 
	} 


	vec3 mayaNwPassThrough(vec3 Nw) 
	{ 
		return Nw; 
	} 


	irradiance mayaDirectionalLight( float lightOn, float intensity, vec3 color, 
			   float emitDiff, float emitSpec, vec3 direction )
	{ 
		vec3 c = lightOn * intensity * color; 
		irradiance irrad; 
		irrad.diffuseI = emitDiff * c; 
		irrad.specularI = emitSpec * c;    
		irrad.Ls = irrad.Ld = normalize( -direction ); 
		return irrad; 
	} 


	vec3 iPw( vec3 ipw )
	{ 
		return ipw; 
	} 


	irradiance mayaShadowPCF1( irradiance irradIn, sampler2D shadowSamp, 
						vec3 Pw, float bias, int shadowMapSize, 
						mat4 shadowViewProj, vec3 shadowColor, bool globalShadowOn, bool shadowOn ) 
	{ 
	   if ( !( globalShadowOn && shadowOn ) ) return irradIn; 

	   vec3 avgXYZ = vec3(0.3333,0.3334,0.3333); 
	   float lightGain = 1.0f; // 1 is all light, 0 is all shadow 
	   vec4 Pndc = mul( shadowViewProj, vec4(Pw,1.0f) ); // Cg!  
	   Pndc.xyz /= Pndc.w; 

	   if ( Pndc.x > -1.0f && Pndc.x < 1.0f && Pndc.y  > -1.0f   
		 && Pndc.y <  1.0f && Pndc.z >  0.0f && Pndc.z <  1.0f ) 
	   { 
			vec2 uv = 0.5f * Pndc.xy + 0.5f; 
			float z = Pndc.z - bias / Pndc.w; 
			float val = z - texture2D(shadowSamp, uv ).x;  
			lightGain = (val >= 0.0f)? 0.0f : 1.0f;  
	   } 

	   float dIntens = saturate(dot(irradIn.diffuseI, avgXYZ)); 
	   irradIn.diffuseI = lerp( dIntens * shadowColor, irradIn.diffuseI, lightGain ); 
	   irradIn.specularI = irradIn.specularI * lightGain; 
	   return irradIn; 
	} 



	vec3 iVw( vec3 iVw )
	{ 
		return normalize( iVw ); 
	} 

	vec3 mayaHVector(vec3 L, vec3 V) 
	{ 
		return normalize(L + V); 
	} 

	vec4 mayaShaderGeom(vec3 N, vec3 L, vec3 V, vec3 H) 
	{ 
		float NL = saturate(dot(N, L)); 
		float NV = saturate(dot(N, V)); 
		float NH = saturate(dot(N, H)); 
		float VH = saturate(dot(V, H)); 
		return vec4(NL, NV, NH, VH); 
	} 


	vec3 mayaLambertDiffuse(vec4 NL_NV_NH_VH, vec3 diffuseI) 
	{ 
		return NL_NV_NH_VH.x * diffuseI; 
	} 

	vec3 mayaBlinnSpecular(
		vec3 specularI, 
		vec4 NL_NV_NH_VH, 
		float ecc, 
		float rolloff) 
	{ 
		float ecc2 = ecc * ecc - 1.0f; 
		float NH = NL_NV_NH_VH.z; 
		float d = (ecc2 + 1.0f) / (1.0f + ecc2 * NH * NH); 
		d *= d; 
		float NL = NL_NV_NH_VH.x; 
		float NV = NL_NV_NH_VH.y; 
		float VH = NL_NV_NH_VH.w; 
		NH *= 2.0f; 
		float g = 1.0f; 
		if (NV < NL) 
			g = (NV * NH < VH) ? NH / VH : 1.0f / NV; 
		else 
			g = (NL * NH < VH) ? (NL * NH) / (VH * NV) : 1.0f / NV; 
		float k = 1.0f - VH; 
		k = k * k * k; 
		float f = k + (1.0f - k) * rolloff; 
		return specularI * saturate(d * g * f); 
	} 

	float mayaTranslucence(
		vec4 NL_NV_NH_VH, 
		float translucence, 
		float depth, 
		float focus) 
	{ 
		float TRANSL_FADE = 0.15f; 
		float TRANSL_ANGLE_FAC = -11.5f; 
		float bright = 0.0f; 
		float cosMinAngle = TRANSL_ANGLE_FAC * depth; 

		if (translucence != 0.0f && NL_NV_NH_VH.x > cosMinAngle) {  
			if (focus == 0.0f) { 
				bright = translucence; 
			} else { 
				float VL = saturate(NL_NV_NH_VH.w * NL_NV_NH_VH.w);  
				bright =  translucence * pow(VL,  focus /(1.00001f - focus));  
			} 
			float fade = saturate(TRANSL_FADE - cosMinAngle); 
			if (NL_NV_NH_VH.x < (fade + cosMinAngle)) { 
				bright *= (NL_NV_NH_VH.x - cosMinAngle) / fade; 
			} 
		}  
		return bright;  
	} 


	vec3 ambientShader( vec3 color )
	{ 
		return color; 
	} 


	float mayaBlinnReflectionRolloff(
		vec4 NL_NV_NH_VH, 
		float reflectance, 
		float rolloff) 
	{ 
		float nv3 = 1.0f - NL_NV_NH_VH.y; 
		nv3 = nv3 * nv3 * nv3; 
		float r = saturate(reflectance); 
		r *= nv3 + (1.0f - nv3) * rolloff; 
		return r; 
	} 

	mayaSurfaceShaderOutput mayaADSRCombiner(
		vec3 diffuseIrradIn, 
		vec3 specularIrradIn, 
		float translucenceIn, 
		vec3 color, 
		vec3 transparency, 
		vec3 ambientColor, 
		vec3 ambientIn, 
		vec3 incandescence, 
		float diffuse, 
		vec3 specularColor, 
		float reflectivity, 
		vec3 reflectedColor, 
		float glowIntensity, 
		bool hideSource, 
		float matteOpacity, 
		int matteOpacityMode, 
		float outAlphaPassThrough) 
	{ 
		mayaSurfaceShaderOutput result; 
		result.outColor = (ambientColor+ambientIn) * color; 
		result.outColor += (diffuse + translucenceIn) * diffuseIrradIn * color; 
		result.outColor *= saturate(1.0f - transparency); 
		result.outColor += specularIrradIn * specularColor; 
		result.outColor += incandescence; 
		result.outColor += reflectivity * reflectedColor; 
		result.outTransparency = transparency; 
		result.outGlowColor = glowIntensity * result.outColor; 

		if (hideSource) { 
			result.outColor = vec3(0.0f, 0.0f, 0.0f); 
			result.outTransparency = vec3(1.0f, 1.0f, 1.0f); 
		} 

		if (matteOpacityMode == 0) { 
			result.outMatteOpacity = vec3(-1.0e+06f, -1.0e+06f, -1.0e+06f); 
		} else if (matteOpacityMode == 1) { 
			result.outMatteOpacity = vec3(matteOpacity, matteOpacity, matteOpacity); 
		} else { 
			result.outMatteOpacity = (1.0f - result.outTransparency) * matteOpacity; 
		} 
		result.outAlphaPassThrough = outAlphaPassThrough; 
		return result; 
	} 

	vec4 mayaSurfaceToFloat4(
		mayaSurfaceShaderOutput surface, 
		float extraOpacity) 
	{ 
		vec3 intenseVec = vec3(0.3333, 0.3333, 0.3333); 
		vec3 opacity = saturate(1.0f - surface.outTransparency); 
		float cutoutA = surface.outAlphaPassThrough * extraOpacity; 
		return vec4(cutoutA*surface.outColor, cutoutA*dot(opacity, intenseVec)); 
	} 

    void main()
	{ 
		mayaSurfaceShaderOutput PixelOutput; 

		vec3 v_Nw = iNw( Nw ); 
		bool v_mayaIsBackFacing = ! gl_FrontFacing; 
		vec3 v_mayaNormalFlip = mayaNormalFlip( v_Nw, v_mayaIsBackFacing, mayaNormalMultiplier ); 
		vec3 v_mayaNwPassThrough = mayaNwPassThrough( v_mayaNormalFlip ); 

		irradiance s_mayaIrradiance; 
		irradiance v_mayaDirectionalLight = mayaDirectionalLight( mayaDirectionalLight_lightOn, mayaDirectionalLight_intensity, mayaDirectionalLight_color, mayaDirectionalLight_emitsDiffuse, mayaDirectionalLight_emitsSpecular, mayaDirectionalLight_direction ); 

		vec3 v_Pw = iPw( Pw ); 

		s_mayaIrradiance = mayaShadowPCF1( v_mayaDirectionalLight, mayaShadowPCF1_shadowSamp, v_Pw, mayaShadowPCF1_shadowBias, mayaShadowPCF1_shadowMapSize, mayaShadowPCF1_shadowViewProj, mayaShadowPCF1_shadowColor, mayaShadowPCF1_mayaGlobalShadowOn, mayaShadowPCF1_mayaShadowOn ); 

		vec3 v_Vw = iVw( Vw ); 

		vec3 v_mayaHVector = mayaHVector( s_mayaIrradiance.Ls, v_Vw ); 

		vec4 v_mayaShaderGeom = mayaShaderGeom( v_mayaNwPassThrough, s_mayaIrradiance.Ld, v_Vw, v_mayaHVector ); 

		vec3 v_mayaLambertDiffuse = mayaLambertDiffuse( v_mayaShaderGeom, s_mayaIrradiance.diffuseI ); 
		vec3 v_mayaBlinnSpecular = mayaBlinnSpecular( s_mayaIrradiance.specularI, v_mayaShaderGeom, blinn1eccentricity, blinn1specularRollOff ); 
		float v_mayaTranslucence = mayaTranslucence( v_mayaShaderGeom, blinn1translucence, blinn1translucenceDepth, blinn1translucenceFocus ); 

		vec3 v_ambientShader = ambientShader( ambientShader_ambientIllum ); 

		float v_mayaBlinnReflectionRolloff = mayaBlinnReflectionRolloff( v_mayaShaderGeom, blinn1reflectivity, specularRollOff ); 

		PixelOutput = mayaADSRCombiner( v_mayaLambertDiffuse, v_mayaBlinnSpecular, v_mayaTranslucence, blinn1color, blinn1transparency, blinn1ambientColor, v_ambientShader, blinn1incandescence, blinn1diffuse, blinn1specularColor, v_mayaBlinnReflectionRolloff, blinn1reflectedColor, blinn1glowIntensity, blinn1hideSource, blinn1matteOpacity, blinn1matteOpacityMode, blinn1outAlphaPassThrough ); 
		vec4 v_mayaSurfaceToFloat = mayaSurfaceToFloat4( PixelOutput, extraOpacity ); 

		colorOut = v_mayaSurfaceToFloat; 
	} 
}


technique main
{ 
    pass P0 
    { 
        VertexShader (in APP_DATA, out VS_TO_PS) = MainVertexShader;
        PixelShader (in VS_TO_PS, out pixelOut) = MainPixelShader;
    } 
 } 
