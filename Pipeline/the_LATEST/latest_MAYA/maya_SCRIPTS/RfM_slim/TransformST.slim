# An extension of Pixar's ST node. As a multiple node it retains the
# use of the Manifold visualizer but with the benefits of accessing
# the transformed outputs of 's' and 't'.
# Malcolm A. Kesson
# Monday 25 Feb
slim 1 extensions cutter {
extensions fundza cutr {
	template multiple TransformST {
		    description "Outputs the transformed values of 's' and 't' "
	        previewinfo {
	            shadingrate 1
	            objectsize 1
	            objectshape Plane
	            frame 1
	            }
		    parameter float angle {
				label Angle
				subtype slider
				default 0
				range {0 360}
			    }
		    parameter float repeatS {
				label "S Repeats"
				subtype slider
				default 1
				range {-10 10 .001}
			    }
		    parameter float repeatT {
				label "T Repeats"
				subtype slider
				default 1
				range {-10 10 .001}
			    }
		    parameter float offsetS {
				label "S Offset"
				subtype slider
				default 0
				range {-10 10 .001}
			    }
		    parameter float offsetT {
				label "T Offset"
				subtype slider
				default 0
				range {-10 10 .001}
			    }
		    parameter float pivot_s {
				label "S Pivot"
				subtype slider
				default 0.5
				range {0 1}
			    }
		    parameter float pivot_t {
				label "T Pivot"
				subtype slider
				default 0.5
				range {0 1}
			    }
		    collection manifold result {
				access output
				display hidden
				parameter point Q {
				    access output
					}
				parameter vector dQu {
				    access output
					}
				parameter vector dQv {
				    access output
					}
			    }
			parameter float ss {
				label "s Out"
				access output
				display hidden
				}
			parameter float tt {
				label "t Out"
				access output
				display hidden
				}
		    RSLFunction {
			void cutrTransformST (
				  uniform float angle;
				  uniform float repeatS; 
				  uniform float repeatT;
				  uniform float offsetS; 
				  uniform float offsetT;
				  uniform float pivot_s;
				  uniform float pivot_t;
			  		output point Q;
			  		output vector dQu;
			  		output vector dQv;
				  output float ss;
				  output float tt;
				  )
			{
		    extern float s, t, du, dv;
		    setxcomp(Q, repeatS * s + offsetS);
		    setycomp(Q, repeatT * t + offsetT);
		    setzcomp(Q, 0);
		    if(angle != 0)
				Q = rotate(Q, radians(angle), 
						point(pivot_s, pivot_t, 0),
						point(pivot_s, pivot_t, 1)
						); 

		    dQu = vector Du(Q)*du;
		    dQv = vector Dv(Q)*dv;
			ss = Q[1];
			tt = Q[2];
			}
		}
	}
}}
