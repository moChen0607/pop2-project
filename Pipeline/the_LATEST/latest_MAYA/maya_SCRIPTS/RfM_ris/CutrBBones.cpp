/* 
 CutrBBones.cpp
 Generated by Cutter.
*/
#include <RixPattern.h> 
#include <RixShadingUtils.h>
#include <RixShading.h>
//#include <RixInterfaces.h>
#include <cstring>
//#include <cstdio>
//#include <sstream>
//#include <cmath>

class CutrBBones : public RixPattern {
public:

    CutrBBones();
    virtual ~CutrBBones() { }
    virtual int Init(RixContext &, char const *pluginpath);
    virtual RixSCParamInfo const *GetParamTable();
    virtual void Finalize(RixContext &) { }
    virtual int ComputeOutputParams(RixShadingContext const *ctx,
                                    RtInt *noutputs, 
                                    OutputSpec **outputs,
                                    RtConstPointer instanceData,
                                    RixSCParamInfo const *ignored);
	private:
		RixMessages *m_msg;
		RixShadeFunctions *m_shd;  // Shading functions in RixInterfaces.h
		RtColorRGB	m_rgb_input;
		RtFloat		m_s_cutoff;
	};

CutrBBones::CutrBBones():
	m_msg(NULL),
	m_shd(NULL),
	m_rgb_input(1,1,0),
	m_s_cutoff(0.35)
	{ }

int CutrBBones::Init(RixContext &ctx, char const *pluginpath) {
    m_msg = (RixMessages*)ctx.GetRixInterface(k_RixMessages);
    m_shd = (RixShadeFunctions*)ctx.GetRixInterface(k_RixShadeFunctions);

    // Uncomment the next three lines if a rib Option will be queried.
    //RixRenderState *rstate = (RixRenderState*)ctx.GetRixInterface(k_RixRenderState);
    //RixRenderState::Type optType;
    //RtInt optNumValues, err;
    // Example of using messaging,
    //    m_msg->Info("%f\n", a_float_value);
    return (!m_msg) ? 1 : 0;
    }

RixSCParamInfo const *CutrBBones::GetParamTable() {
    static RixSCParamInfo s_ptable[] = {
		// Output
		RixSCParamInfo("resultC", k_RixSCColor, k_RixSCOutput),
		// Inputs
		RixSCParamInfo("rgb_input", k_RixSCColor),
		RixSCParamInfo("s_cutoff", k_RixSCFloat),
		RixSCParamInfo() // end of table
        };
    return &s_ptable[0];
    }

enum paramIndex {
	k_resultC = 0,
	k_rgb_input,
	k_s_cutoff
    };
	
int CutrBBones::ComputeOutputParams(RixShadingContext const *ctx,
								RtInt *noutputs, 
								OutputSpec **outputs,
								RtConstPointer instanceData,
								RixSCParamInfo const *ignored) {

	// Uncomment the next three lines if a rib Attribute will be queried. Note
	// that Rib Options should be queried in the init() method - not here!
	//RixRenderState *rstate = (RixRenderState*)ctx->GetRixInterface(k_RixRenderState);
	//RixRenderState::Type attrType;
	//RtInt attrNumValues, err;

	// OUTPUTS BEGIN____________________________________
	// Allocate memory for the OutputSpec data structure.
	RixShadingContext::Allocator pool(ctx);
	OutputSpec *outSpec = pool.AllocForPattern<OutputSpec>(1);
	*outputs = outSpec;

	// Allocate memory for each output.
	RtColorRGB	*resultC = pool.AllocForPattern<RtColorRGB>(ctx->numPts);

	// Connect the output(s) to the OutputSpec.
	*noutputs = 1;
	outSpec[0].paramId = k_resultC;
	outSpec[0].detail = k_RixSCVarying;
	outSpec[0].value = resultC;

	// INPUTS BEGIN____________________________________
	bool varying = true;
	//bool uniform = false;
	// Declare a pointer for each input then obtain their values
	// using EvalParam().
	RtColorRGB	const *rgb_input;
	RtFloat		const *s_cutoff;
	ctx->EvalParam(k_rgb_input, -1, &rgb_input, &m_rgb_input, varying);
	ctx->EvalParam(k_s_cutoff, -1, &s_cutoff, &m_s_cutoff, varying);

	// Access the primitive variables that will be needed for the 
	// calculation of the output values. For example, 'st' texture
	// values.
	RtFloat2 const *st, st_default(0, 0);
	ctx->GetPrimVar("st", st_default, &st);	

	// Assign values to the output(s).
	for(int i = 0; i < ctx->numPts; i++) {
 		// For example, assign output based on the value of 's'
		if(st[i].x > s_cutoff[i]) {
			resultC[i].r = rgb_input[i].r;
			resultC[i].g = rgb_input[i].g;
			resultC[i].b = rgb_input[i].b;
			}
		else
			{
			resultC[i].r = 1.0;
			resultC[i].g = 1.0;
			resultC[i].b = 1.0;
			}
		}
	return 0;
	}
RIX_PATTERNCREATE {
	return new CutrBBones();
	}
RIX_PATTERNDESTROY {
	delete((CutrBBones*)pattern);
	}
