




<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>syncmeister.controller.pathfinder &mdash; Portal: Origins [Part 2] 1.0.0 documentation</title>
  

  
  

  

  
  
    

  

  
  
    <link rel="stylesheet" href="../../../_static/css/theme.css" type="text/css" />
  

  
    <link rel="stylesheet" href="../../../_static/style.css" type="text/css" />
  

  
    <link rel="top" title="Portal: Origins [Part 2] 1.0.0 documentation" href="../../../index.html"/>
        <link rel="up" title="Module code" href="../../index.html"/> 

  
  <script src="../../../_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="../../../index.html" class="icon icon-home"> Portal: Origins [Part 2]
          

          
          </a>

          
            
            
              <div class="version">
                1.0.0
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
                <ul>
<li class="toctree-l1"><a class="reference internal" href="../../../wip/index.html">Portal Origins Part 2</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../pickrunner/pickrunner.html">Pickrunner</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../abs2rel/abs2rel.html">Batch Absolute Files to Relative Paths</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../hdrprocess/hdrprocess.html">HDRi Batch Processor</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
        <a href="../../../index.html">Portal: Origins [Part 2]</a>
      </nav>


      
      <div class="wy-nav-content">
        <div class="rst-content">
          





<div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="../../../index.html">Docs</a> &raquo;</li>
      
          <li><a href="../../index.html">Module code</a> &raquo;</li>
      
    <li>syncmeister.controller.pathfinder</li>
      <li class="wy-breadcrumbs-aside">
        
          
        
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <h1>Source code for syncmeister.controller.pathfinder</h1><div class="highlight"><pre>
<span class="ch">#!/usr/bin/env python</span>
<span class="c1"># -*- coding: utf-8 -*-</span>

<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Takes a Maya .ma file as input and changes all absolute paths into relative</span>
<span class="sd">paths. Useful for quick batch-file processing and render-farm prep</span>

<span class="sd">This file is the underbelly of syncmeister&#39;s GUI and command-line modes</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="c1"># IMPORT STANDARD LIBRARIES</span>
<span class="kn">import</span> <span class="nn">os</span>
<span class="kn">import</span> <span class="nn">sys</span>
<span class="kn">import</span> <span class="nn">re</span>
<span class="kn">import</span> <span class="nn">collections</span>

<span class="c1"># IMPORT LOCAL LIBRARIES</span>
<span class="kn">import</span> <span class="nn">logger.common.loggingServices</span> <span class="kn">as</span> <span class="nn">loggingservices</span>
<span class="n">LOGGER</span> <span class="o">=</span> <span class="n">loggingservices</span><span class="o">.</span><span class="n">init_logger</span><span class="p">()</span>
<span class="kn">import</span> <span class="nn">fileio.controller.paths</span> <span class="kn">as</span> <span class="nn">paths</span>
<span class="kn">import</span> <span class="nn">network.controller.network</span> <span class="kn">as</span> <span class="nn">network</span>
<span class="kn">import</span> <span class="nn">engine</span>
<span class="kn">import</span> <span class="nn">syncmeister.model.operation</span> <span class="kn">as</span> <span class="nn">op</span>


<span class="c1"># :AUTHORNOTE: include in a logger traceback?</span>
<span class="c1"># Reference: https://stackoverflow.com/questions/6200270/decorator-to-print-function-call-details-parameters-names-and-effective-values</span>
<span class="c1">#</span>
<span class="k">def</span> <span class="nf">dump_args</span><span class="p">(</span><span class="n">func</span><span class="p">):</span>

        <span class="c1"># init triggers&quot;This decorator dumps out the arguments passed to a function before calling it&quot;</span>
    <span class="n">argnames</span> <span class="o">=</span> <span class="n">func</span><span class="o">.</span><span class="n">func_code</span><span class="o">.</span><span class="n">co_varnames</span><span class="p">[:</span><span class="n">func</span><span class="o">.</span><span class="n">func_code</span><span class="o">.</span><span class="n">co_argcount</span><span class="p">]</span>
    <span class="n">fname</span> <span class="o">=</span> <span class="n">func</span><span class="o">.</span><span class="n">func_name</span>
    <span class="k">def</span> <span class="nf">echo_func</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">print</span> <span class="n">fname</span><span class="p">,</span> <span class="s2">&quot;(&quot;</span><span class="p">,</span> <span class="s1">&#39;, &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span>
            <span class="s1">&#39;</span><span class="si">%s</span><span class="s1">=</span><span class="si">%r</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">entry</span>
            <span class="k">for</span> <span class="n">entry</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">argnames</span><span class="p">,</span>
                             <span class="n">args</span><span class="p">[:</span><span class="nb">len</span><span class="p">(</span><span class="n">argnames</span><span class="p">)])</span><span class="o">+</span>\
                             <span class="p">[(</span><span class="s2">&quot;args&quot;</span><span class="p">,</span><span class="nb">list</span><span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">argnames</span><span class="p">):]))]</span><span class="o">+</span>\
                             <span class="p">[(</span><span class="s2">&quot;kwargs&quot;</span><span class="p">,</span><span class="n">kwargs</span><span class="p">)])</span> <span class="o">+</span><span class="s2">&quot;)&quot;</span>
    <span class="k">return</span> <span class="n">echo_func</span>
<span class="c1"># end dump_args</span>


<span class="k">def</span> <span class="nf">default_condition_try_behavior</span><span class="p">(</span><span class="n">f</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This ensures, that if a key condition is retrieved that does not exist,</span>
<span class="sd">    that functions will fail gracefully with proper logger output. Also, if the</span>
<span class="sd">    output of a function is None, it will automatically reassign it to the</span>
<span class="sd">    operation class&#39;s PASS method</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">wrap</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="c1"># print &quot;Hello&quot;</span>
            <span class="n">output</span> <span class="o">=</span> <span class="n">f</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">output</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">op</span><span class="o">.</span><span class="n">StaticOperation</span><span class="o">.</span><span class="n">PASS</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">output</span>
        <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
            <span class="n">LOGGER</span><span class="o">.</span><span class="n">critical</span><span class="p">([</span><span class="s2">&quot;AIE9901&quot;</span><span class="p">,</span> <span class="s2">&quot;match_false&quot;</span><span class="p">],</span> <span class="p">{</span><span class="n">func</span><span class="p">:</span><span class="n">f</span><span class="p">})</span>
            <span class="n">LOGGER</span><span class="o">.</span><span class="n">getTraceback</span><span class="p">()</span>
    <span class="c1"># end wrap</span>
    <span class="k">return</span> <span class="n">wrap</span>
<span class="c1"># end default_condition_try_behavior</span>


<span class="k">class</span> <span class="nc">PathFinder</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    WIP class that will take the place of change_paths for syncmeister. When</span>
<span class="sd">    completed, it will copy locations that the user specifies, relative to a</span>
<span class="sd">    root folder path.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">filePath</span><span class="p">,</span> <span class="n">rootPath</span><span class="o">=</span><span class="n">op</span><span class="o">.</span><span class="n">StaticOperation</span><span class="o">.</span><span class="n">defaultRootDirText</span><span class="p">,</span>
                 <span class="n">checkExist</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">seek</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">recursiveSearchFiles</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span>
                 <span class="n">passUnknownPaths</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">autoResolveOSPaths</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span>
                 <span class="n">normalizePaths</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">addDependencyFiles</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Args:</span>
<span class="sd">            filePath (str): The full file path of the file to be queried</span>
<span class="sd">            rootPath (str): The root directory, from which relative paths will</span>
<span class="sd">                            be set</span>
<span class="sd">            checkExist (bool): Only allows the operation of a file if it exists</span>
<span class="sd">            seek (bool): When enabled, will find relative paths above the root</span>
<span class="sd">                         directory</span>
<span class="sd">            .. warning::</span>
<span class="sd">                This is NOT advised for programs that do not support ../ syntax</span>
<span class="sd">                for dependencies (ex: Maya can use ../ for references but not</span>
<span class="sd">                for textures)</span>

<span class="sd">            recursiveSearchFiles (bool): When enabled, will search referencial</span>
<span class="sd">                                         scene files for other dependencies,</span>
<span class="sd">                                         until the script runs out of new scene</span>
<span class="sd">                                         files to parse and search.</span>
<span class="sd">            passUnknownPaths (bool): If a path cannot be proven to be absolute</span>
<span class="sd">                                     or relative, the script will not attempt</span>
<span class="sd">                                     to &quot;find&quot; the file and simply pass it.</span>
<span class="sd">                                     Enable if script execution is slow</span>
<span class="sd">            autoResolveOSPaths (bool): Even if a path originates from another</span>
<span class="sd">                                       OS, presuming that the path is on an</span>
<span class="sd">                                       identical folder structure on a</span>
<span class="sd">                                       dual-boot network machine (our setup),</span>
<span class="sd">                                       the script will get process the path by</span>
<span class="sd">                                       removing the OS component and swapping</span>
<span class="sd">                                       it with the current OS.</span>

<span class="sd">            .. important::</span>
<span class="sd">                For the current project, it looks in the</span>
<span class="sd">                collaborative_space/project_name to perform this</span>

<span class="sd">            :AUTHORNOTE: Test this when you&#39;ve got the script working before</span>
<span class="sd">            creating a commit to the environment</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">PathFinder</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">__init__</span><span class="p">()</span>
        <span class="c1"># application-specific information</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sceneFileExtensions</span> <span class="o">=</span> <span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">maxParentCount</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">validConditionKeys</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;Expected Output&quot;</span><span class="p">,</span> <span class="s2">&quot;Exceptions&quot;</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">outputPaths</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">filePath</span> <span class="o">=</span> <span class="n">filePath</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">rootPath</span> <span class="o">=</span> <span class="n">rootPath</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">init_root_path</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">checkExist</span> <span class="o">=</span> <span class="n">checkExist</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">recursiveSearchFiles</span> <span class="o">=</span> <span class="n">recursiveSearchFiles</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">seek</span> <span class="o">=</span> <span class="n">seek</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">passUnknownPaths</span> <span class="o">=</span> <span class="n">passUnknownPaths</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">autoResolveOSPaths</span> <span class="o">=</span> <span class="n">autoResolveOSPaths</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">normalizePaths</span> <span class="o">=</span> <span class="n">normalizePaths</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">addDependencyFiles</span> <span class="o">=</span> <span class="n">addDependencyFiles</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">currentMatch</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">matchIsAbsolute</span> <span class="o">=</span> <span class="bp">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">matchIsRelative</span> <span class="o">=</span> <span class="bp">False</span>

        <span class="c1"># init manager which will decide how matches pass or fail</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">op</span> <span class="o">=</span> <span class="n">op</span><span class="o">.</span><span class="n">StaticOperation</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">init_match_conditions</span><span class="p">()</span>
    <span class="c1"># end __init__</span>

    <span class="k">def</span> <span class="nf">init_root_path</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">rootPath</span> <span class="o">==</span> <span class="n">op</span><span class="o">.</span><span class="n">StaticOperation</span><span class="o">.</span><span class="n">defaultRootDirText</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">rootPath</span> <span class="o">=</span> <span class="n">path</span><span class="o">.</span><span class="n">os_path_split_asunder</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">filePath</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">rootPath</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rootPath</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">maxParentCount</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">rootPath</span> <span class="o">=</span> <span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">sep</span><span class="p">)</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rootPath</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">sys</span><span class="o">.</span><span class="n">platform</span> <span class="o">==</span> <span class="s2">&quot;linux2&quot;</span> <span class="ow">and</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">rootPath</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s1">&#39;/&#39;</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">rootPath</span> <span class="o">=</span> <span class="s2">&quot;/&quot;</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">rootPath</span>
    <span class="c1"># end init_root_path</span>

    <span class="k">def</span> <span class="nf">init_match_conditions</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Creates the match conditions for the current class. In short, because</span>
<span class="sd">        of the flexibility of dictionaries to take function objects as arguments,</span>
<span class="sd">        the dictionary acts as a pseudo-checklist. But since the order of the</span>
<span class="sd">        checks matter, a collections.OrderedDict was used.</span>

<span class="sd">        I have two options for how I handle the output of these methods</span>
<span class="sd">        I could either have each of them pass if the ideal condition is met and</span>
<span class="sd">        fail if failure or I can create a wrapper method that handles individual,</span>
<span class="sd">        universal conditions like continue, pass, etc which are bound to operate</span>
<span class="sd">        the same, no matter which condition I use</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">conds</span> <span class="o">=</span> <span class="n">collections</span><span class="o">.</span><span class="n">OrderedDict</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">conds</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">match_is_empty</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;Expected Output&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">op</span><span class="o">.</span><span class="n">PASS</span><span class="p">,</span>
                                           <span class="s2">&quot;Exceptions&quot;</span><span class="p">:</span> <span class="p">{</span><span class="bp">None</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">op</span><span class="o">.</span><span class="n">CONTINUE</span><span class="p">}}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">conds</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">match_to_normalize</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;Expected Output&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">op</span><span class="o">.</span><span class="n">PASS</span><span class="p">,</span>
                                               <span class="s2">&quot;Exceptions&quot;</span><span class="p">:</span> <span class="p">{</span><span class="bp">None</span><span class="p">:</span> <span class="bp">None</span><span class="p">}}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">conds</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">match_is_in_root</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;Expected Output&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">op</span><span class="o">.</span><span class="n">PASS</span><span class="p">,</span>
                                             <span class="s2">&quot;Exceptions&quot;</span><span class="p">:</span> <span class="p">{</span><span class="bp">None</span><span class="p">:</span> <span class="bp">None</span><span class="p">}}</span>
        <span class="c1"># I must detect early if the match is from a different OS and change it</span>
        <span class="c1"># if it is.</span>
        <span class="c1"># :NOTE: This feature works only on assumption that the user is</span>
        <span class="c1"># working under the Montgomery Hall network machines.</span>
        <span class="c1">#</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">conds</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">match_differs_os</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;Expected Output&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">op</span><span class="o">.</span><span class="n">IS_ABSOLUTE</span><span class="p">,</span>
                                              <span class="s2">&quot;Exceptions&quot;</span><span class="p">:</span> <span class="p">{</span><span class="bp">None</span><span class="p">:</span> <span class="bp">None</span><span class="p">}}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">conds</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">match_is_absolute</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;Expected Output&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">op</span><span class="o">.</span><span class="n">IS_ABSOLUTE</span><span class="p">,</span>
                                              <span class="s2">&quot;Exceptions&quot;</span><span class="p">:</span> <span class="p">{</span><span class="bp">None</span><span class="p">:</span> <span class="bp">None</span><span class="p">}}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">conds</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">match_is_relative</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;Expected Output&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">op</span><span class="o">.</span><span class="n">IS_RELATIVE</span><span class="p">,</span>
                                              <span class="s2">&quot;Exceptions&quot;</span><span class="p">:</span> <span class="p">{</span><span class="bp">None</span><span class="p">:</span> <span class="bp">None</span><span class="p">}}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">conds</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">match_must_exist</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;Expected Output&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">op</span><span class="o">.</span><span class="n">PASS</span><span class="p">,</span>
                                              <span class="s2">&quot;Exceptions&quot;</span><span class="p">:</span> <span class="p">{</span><span class="bp">None</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">op</span><span class="o">.</span><span class="n">CONTINUE</span><span class="p">}}</span>
        <span class="c1"># The recursive op must instantiate another class of the same type</span>
        <span class="c1"># and then run the script again for more matches if it is a scene file</span>
        <span class="c1">#</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">conds</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">match_is_scene_file</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;Expected Output&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">op</span><span class="o">.</span><span class="n">RECURSIVE_SAME_CLASS</span><span class="p">,</span>
                                                <span class="s2">&quot;Exceptions&quot;</span><span class="p">:</span> <span class="p">{</span><span class="bp">None</span><span class="p">:</span> <span class="bp">None</span><span class="p">}}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">conds</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">match_unknown_path_status</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;Expected Output&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">op</span><span class="o">.</span><span class="n">PASS</span><span class="p">,</span>
                                                      <span class="s2">&quot;Exceptions&quot;</span><span class="p">:</span> <span class="p">{</span><span class="bp">None</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">op</span><span class="o">.</span><span class="n">CONTINUE</span><span class="p">}}</span>
    <span class="c1"># end init_match_conditions</span>

    <span class="k">def</span> <span class="nf">match_is_empty</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Tests if the match is empty or not and whether or not the match should</span>
<span class="sd">        be skipped over in the main execution of the current class</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">currentMatch</span> <span class="o">==</span> <span class="p">[]</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">currentMatch</span> <span class="o">==</span> <span class="p">{}</span> <span class="ow">or</span> \
                <span class="bp">self</span><span class="o">.</span><span class="n">currentMatch</span> <span class="ow">is</span> <span class="bp">None</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">currentMatch</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span> <span class="o">==</span> <span class="s2">&quot;&quot;</span> <span class="ow">or</span> \
                <span class="bp">self</span><span class="o">.</span><span class="n">currentMatch</span> <span class="o">==</span> <span class="s2">&quot;/&quot;</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">currentMatch</span> <span class="o">==</span> <span class="s2">&quot;//&quot;</span> <span class="ow">or</span> \
                <span class="bp">self</span><span class="o">.</span><span class="n">currentMatch</span> <span class="o">==</span> <span class="s2">&quot;</span><span class="se">\\</span><span class="s2">&quot;</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">currentMatch</span> <span class="o">==</span> <span class="s2">&quot;</span><span class="se">\\\\</span><span class="s2">&quot;</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">op</span><span class="o">.</span><span class="n">CONTINUE</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">op</span><span class="o">.</span><span class="n">PASS</span>
    <span class="c1"># end match_is_empty</span>

    <span class="k">def</span> <span class="nf">match_to_normalize</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Simply normalizes the case of the given match string</span>
<span class="sd">        if the user specifies to do so</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">normalizePaths</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">currentMatch</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">normcase</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">currentMatch</span><span class="p">)</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">op</span><span class="o">.</span><span class="n">PASS</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">op</span><span class="o">.</span><span class="n">PASS</span>
    <span class="c1"># end match_to_normalize</span>

    <span class="k">def</span> <span class="nf">match_is_in_root</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Checks that the current match is within the root dir. If it isn&#39;t and</span>
<span class="sd">        the user cares, then the current match should be skipped</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">seek</span> <span class="ow">and</span> \
                <span class="p">(</span><span class="n">paths</span><span class="o">.</span><span class="n">is_current_dir</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">currentMatch</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">maxParentCount</span><span class="p">)</span> <span class="ow">or</span> \
                <span class="n">paths</span><span class="o">.</span><span class="n">is_abs_path_in_current_dir</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rootPath</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">currentMatch</span><span class="p">)):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">op</span><span class="o">.</span><span class="n">CONTINUE</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">op</span><span class="o">.</span><span class="n">PASS</span>
    <span class="c1"># end match_is_in_root</span>

    <span class="k">def</span> <span class="nf">match_is_scene_file</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Checks if the current match is a valid scene file whose contents can be</span>
<span class="sd">        read recursively.</span>

<span class="sd">        If is a file and user wants a recursive search, the potential path</span>
<span class="sd">        is checked</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">addDependencyFiles</span> <span class="ow">and</span> \
                <span class="bp">self</span><span class="o">.</span><span class="n">currentMatch</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sceneFileExtensions</span><span class="p">)</span> <span class="ow">and</span> \
                <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isfile</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">currentMatch</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">op</span><span class="o">.</span><span class="n">RECURSIVE_SAME_CLASS</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">op</span><span class="o">.</span><span class="n">PASS</span>
    <span class="c1"># end match_is_scene_file</span>

    <span class="k">def</span> <span class="nf">match_differs_os</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compares the current string, assuming that it is actually a path (it</span>
<span class="sd">        doesn&#39;t check to know whether it is one for a fact before computing) to</span>
<span class="sd">        the current system. If the two do not match, it checks for advice about</span>
<span class="sd">        how to process the path from the user</span>

<span class="sd">        .. note::</span>
<span class="sd">            If the path doesn&#39;t start with a drive-letter, the output basically</span>
<span class="sd">            assumes that the path is linux-based</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">networkManager</span> <span class="o">=</span> <span class="n">network</span><span class="o">.</span><span class="n">NetworkManager</span><span class="p">()</span>
        <span class="n">pathOS</span> <span class="o">=</span> <span class="n">get_path_os</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">currentMatch</span><span class="p">)</span>

        <span class="n">sysOS</span> <span class="o">=</span> <span class="n">sys</span><span class="o">.</span><span class="n">platform</span>
        <span class="k">if</span> <span class="n">pathOS</span> <span class="o">==</span> <span class="n">sysOS</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">op</span><span class="o">.</span><span class="n">CONTINUE</span>
            <span class="c1"># elif (pathOS != sysOS and self.autoResolveOSPaths) and \</span>
            <span class="c1">#         not networkManager.is_remote():</span>
        <span class="k">elif</span> <span class="p">(</span><span class="n">pathOS</span> <span class="o">!=</span> <span class="n">sysOS</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">autoResolveOSPaths</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">op</span><span class="o">.</span><span class="n">SWITCH_OS</span>
        <span class="k">elif</span> <span class="p">(</span><span class="n">pathOS</span> <span class="o">!=</span> <span class="n">sysOS</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">autoResolveOSPaths</span><span class="p">)</span> <span class="ow">and</span> \
                <span class="n">networkManager</span><span class="o">.</span><span class="n">is_remote</span><span class="p">():</span>
            <span class="n">LOGGER</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;The following computer is not on Montgomery Hall&#39;s &quot;</span>
                        <span class="s2">&quot;network, cannot auto resolve path&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">op</span><span class="o">.</span><span class="n">CONTINUE</span>
    <span class="c1"># end match_differs_os</span>

    <span class="k">def</span> <span class="nf">match_is_absolute</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Method to determine if path can be proven as absolute by testing if it</span>
<span class="sd">        exists on the local machine</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isabs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">currentMatch</span><span class="p">)</span> \
                <span class="ow">and</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isdir</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">currentMatch</span><span class="p">)</span> <span class="ow">and</span> \
                <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isfile</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">currentMatch</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">op</span><span class="o">.</span><span class="n">CONTINUE</span>  <span class="c1"># doesn&#39;t exist - skip</span>
        <span class="k">elif</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isabs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">currentMatch</span><span class="p">)</span> \
                <span class="ow">and</span> <span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isfile</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">currentMatch</span><span class="p">)</span> \
                <span class="ow">or</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isdir</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">currentMatch</span><span class="p">)):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">matchIsAbsolute</span> <span class="o">=</span> <span class="bp">True</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">op</span><span class="o">.</span><span class="n">IS_ABSOLUTE</span>
    <span class="c1"># end match_is_absolute</span>

    <span class="k">def</span> <span class="nf">match_is_relative</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Method to determine if path can be proven as relative beyond doubt. It</span>
<span class="sd">        does this by normalizing the match to the root directory and, if some</span>
<span class="sd">        file/folder exists, then we can infer that the path is definitely meant</span>
<span class="sd">        to be relative.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># relative path processing starts with the simplest type</span>
        <span class="c1"># of relative path - a path with no relative prefix</span>
        <span class="c1"># attempt an aggressive merge of rootPath and the matched object</span>
        <span class="c1">#</span>
        <span class="n">resolvedPath</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">normpath</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rootPath</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">currentMatch</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isdir</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rootPath</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">currentMatch</span><span class="p">))</span> <span class="ow">or</span> \
           <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isfile</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rootPath</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">currentMatch</span><span class="p">)):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">op</span><span class="o">.</span><span class="n">IS_RELATIVE</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">op</span><span class="o">.</span><span class="n">PASS</span>
    <span class="c1"># end match_is_relative</span>

    <span class="c1"># def match_may_not_seek(self, match):</span>
    <span class="c1">#     &quot;&quot;&quot;</span>
    <span class="c1">#     If the user has specified that the match is not allowed to seek above the</span>
    <span class="c1">#     parent directory and the (presumably) relative path is above the parent</span>
    <span class="c1">#     directory, treat as a failed condition. But if seek is enabled and it is,</span>
    <span class="c1">#     send it through. Else If the path is within the parent path then it</span>
    <span class="c1">#     doesn&#39;t matter what seek is</span>
    <span class="c1">#     &quot;&quot;&quot;</span>
    <span class="c1">#     pass</span>
    <span class="c1"># # end match_may_not_seek</span>

    <span class="k">def</span> <span class="nf">match_must_exist</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Checks if the user cares if the file must be proven to exist.</span>

<span class="sd">        .. important::</span>
<span class="sd">            This method is going to be run AFTER our checks for proving if a</span>
<span class="sd">            file/folder is absolute or relative. That way, any file beyond that</span>
<span class="sd">            point must be resolved or it will be thrown away</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">checkExist</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">currentMatch</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">op</span><span class="o">.</span><span class="n">CONTINUE</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">checkExist</span> <span class="ow">and</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">currentMatch</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">op</span><span class="o">.</span><span class="n">PASS</span>
        <span class="k">elif</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">checkExist</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">op</span><span class="o">.</span><span class="n">PASS</span>
    <span class="c1"># end match_must_exist</span>

    <span class="k">def</span> <span class="nf">match_unknown_path_status</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Makes sure that if the user specifies to not process unknown paths that</span>
<span class="sd">        any and all unknown paths are not processed.</span>

<span class="sd">        .. important::</span>
<span class="sd">            The if self.passUnknownPaths condition ASSUMES that this method</span>
<span class="sd">            is being run at the very end of the script, after all other known</span>
<span class="sd">            methods of determining paths have been exhausted</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">passUnknownPaths</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">op</span><span class="o">.</span><span class="n">CONTINUE</span>  <span class="c1"># user wants to skip the path</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">op</span><span class="o">.</span><span class="n">PASS</span>

        <span class="c1"># if os.path.exists(self.currentMatch):</span>
        <span class="c1">#     if checkExist and not os.path.isdir(currentMatch):</span>
        <span class="c1">#         # print &quot;caught os.path.exists() exception&quot;</span>
        <span class="c1">#         return op.Operation.CONTINUE  # skip</span>

        <span class="c1">#     relativePath = os.path.relpath(self.currentMath, self.rootPath)</span>
        <span class="c1">#     self.currentMath = relativePath</span>

        <span class="c1">#     temp = &#39;[+] &quot;{p}&quot; relative path created from the &#39;\</span>
        <span class="c1">#            &#39;absolute path, &quot;{p1}&quot;&#39;.format(p=relativePath,</span>
        <span class="c1">#                                           p1=match)</span>
        <span class="c1">#     Logger().info(temp)</span>
    <span class="c1"># end match_unknown_path_status</span>

    <span class="nd">@default_condition_try_behavior</span>
    <span class="k">def</span> <span class="nf">eval_match_conditions</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">originalString</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Looks through the dictionary of match conditions and passes each</span>
<span class="sd">        function&#39;s output based on what each function returns</span>

<span class="sd">        .. authornote::</span>
<span class="sd">            Experimental. Don&#39;t use in production yet</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">originalString</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">originalString</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">currentMatch</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">originalString</span> <span class="o">=</span> <span class="n">originalString</span>

        <span class="k">for</span> <span class="n">condition</span><span class="p">,</span> <span class="n">item</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">conds</span><span class="o">.</span><span class="n">iteritems</span><span class="p">():</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">is_valid_keys</span><span class="p">(</span><span class="n">item</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
            <span class="k">if</span> <span class="n">condition</span><span class="p">()</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">op</span><span class="o">.</span><span class="n">CONTINUE</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="k">if</span> <span class="n">condition</span><span class="p">()</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">op</span><span class="o">.</span><span class="n">PASS</span><span class="p">:</span>
                <span class="k">pass</span>
            <span class="k">if</span> <span class="n">condition</span><span class="p">()</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">op</span><span class="o">.</span><span class="n">SWITCH_OS</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">currentMatch</span> <span class="o">=</span> <span class="n">change_path_to_current_os</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">currentMatch</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">condition</span><span class="p">()</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">op</span><span class="o">.</span><span class="n">IS_RELATIVE</span><span class="p">:</span>
                <span class="c1"># any file that is relative will be changed to absolute handled</span>
                <span class="c1">#</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">currentMatch</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rootDir</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">currentMatch</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">matchIsAbsolute</span> <span class="o">=</span> <span class="bp">True</span>  <span class="c1"># overwrite for later evaluation</span>
            <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isfile</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">currentMatch</span><span class="p">)</span> <span class="ow">or</span> \
                    <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isdir</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">currentMatch</span><span class="p">):</span>
                <span class="c1"># check if it is a scene file and if it is, do a recursion.</span>
                <span class="c1"># Else, return it</span>
                <span class="c1">#</span>
                <span class="k">if</span> <span class="n">condition</span><span class="p">()</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">op</span><span class="o">.</span><span class="n">RECURSIVE_SAME_CLASS</span> <span class="ow">and</span> \
                        <span class="bp">self</span><span class="o">.</span><span class="n">addDependencyFiles</span><span class="p">:</span>
                    <span class="c1"># do some recursion here and make a new class</span>
                    <span class="n">newClass</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__class__</span><span class="p">(</span><span class="n">filePath</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">currentMatch</span><span class="p">,</span>
                                              <span class="n">rootPath</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">rootPath</span><span class="p">,</span>
                                              <span class="n">checkExist</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">checkExist</span><span class="p">,</span>
                                              <span class="n">seek</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">seek</span><span class="p">,</span>
                                              <span class="n">recursiveSearchFiles</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">recursiveSearchFiles</span><span class="p">,</span>
                                              <span class="n">passUnknownPaths</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">passUnknownPaths</span><span class="p">,</span>
                                              <span class="n">autoResolveOSPaths</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">autoResolveOSPaths</span><span class="p">,</span>
                                              <span class="n">normalizePaths</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">normalizePaths</span><span class="p">,</span>
                                              <span class="n">addDependencyFiles</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">addDependencyFiles</span><span class="p">)</span>
                    <span class="n">matchOut</span> <span class="o">=</span> <span class="n">newClass</span><span class="o">.</span><span class="n">eval_match_conditions</span><span class="p">()</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">checkExist</span> <span class="ow">and</span> <span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isdir</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">currentMatch</span><span class="p">)</span> <span class="ow">or</span> \
                    <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isfile</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">currentMatch</span><span class="p">)):</span>
                <span class="k">return</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">originalString</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">currentMatch</span><span class="p">)</span>
            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">checkExist</span><span class="p">:</span>
                <span class="k">return</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">originalString</span><span class="p">,</span> <span class="bp">None</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">originalString</span><span class="p">,</span> <span class="bp">None</span><span class="p">)</span>

            <span class="c1"># set this condition last, in case all others fail</span>
            <span class="c1"># if condition() != item[&quot;Expected Output&quot;]:</span>
            <span class="c1">#     raise RuntimeError(&quot;Condition: {cond!r} went wrong. The &quot;</span>
            <span class="c1">#                        &quot;expected output, {out!r}  could be not &quot;</span>
            <span class="c1">#                        &quot;be obtained&quot;.format(cond=condition,</span>
            <span class="c1">#                                             out=item[&#39;Expected Output&#39;]))</span>
    <span class="c1"># end eval_match_conditions</span>

    <span class="k">def</span> <span class="nf">is_valid_keys</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">listH</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Syntax sugar to check to make sure that given list keys are valid for</span>
<span class="sd">        during evaluating match objects.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">tempConditionListKeys</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">validConditionKeys</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">it</span> <span class="ow">in</span> <span class="n">listH</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">it</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">tempConditionListKeys</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;Got bad key: {k!r} for &quot;</span>
                                   <span class="s2">&quot;match evaluation&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">k</span><span class="o">=</span><span class="n">it</span><span class="p">))</span>
        <span class="k">return</span> <span class="bp">True</span>
    <span class="c1"># end is_valid_keys</span>

    <span class="k">def</span> <span class="nf">get_relative_path</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">childPath</span><span class="p">,</span> <span class="n">parentPath</span><span class="p">,</span>
                          <span class="n">searchParentDirectories</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        NOTE: replace with os.path.relpath and simply remove (&quot;/&quot;, &quot;\\&quot; from</span>
<span class="sd">        the beginning of the string)</span>

<span class="sd">        .. Danger::</span>
<span class="sd">         Actually, didn&#39;t I already make this in the paths.py module?</span>

<span class="sd">        Args:</span>
<span class="sd">            childPath (str): The path that is suspected to be within the</span>
<span class="sd">                             parentPath</span>
<span class="sd">            parentPath (str): The suspected parent folder of childPath, which</span>
<span class="sd">                              shares a common root</span>
<span class="sd">            searchParentDirectories (bool): Searches up the parentPath for a</span>
<span class="sd">                                            relative path</span>

<span class="sd">		Returns:</span>
<span class="sd">            str: The relative path between childPath and parentPath</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">relPath</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">relpath</span><span class="p">(</span><span class="n">childPath</span><span class="p">,</span> <span class="n">parentPath</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">relPath</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s2">&quot;..&quot;</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">searchParentDirectories</span><span class="p">:</span>
            <span class="k">return</span>  <span class="c1"># returns None, because the operation is not allowed</span>

        <span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
            <span class="c1"># relpath occassionally prefixes paths with &#39;/&#39; in Linux, which</span>
            <span class="c1"># will break windows paths. Remove now</span>
            <span class="c1">#</span>
            <span class="k">if</span> <span class="n">relPath</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s1">&#39;/&#39;</span><span class="p">,</span> <span class="s1">&#39;</span><span class="se">\\</span><span class="s1">&#39;</span><span class="p">):</span>
                <span class="n">relPath</span> <span class="o">=</span> <span class="n">relPath</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">break</span>
        <span class="k">return</span> <span class="n">relPath</span>
    <span class="c1"># end get_relative_path</span>

    <span class="c1"># def change_path_to_current_os(self):</span>
    <span class="c1">#     &quot;&quot;&quot;</span>
    <span class="c1">#     .. note::</span>
    <span class="c1">#         Only works on the Montgomery Hall machines (assumes a specific</span>
    <span class="c1">#         folder structure)</span>
    <span class="c1">#     &quot;&quot;&quot;</span>
    <span class="c1">#     pathOS = get_path_os(self.currentMatch)</span>
    <span class="c1">#     sysOS = sys.platform</span>
    <span class="c1">#     re.</span>
    <span class="c1">#     if pathOS != &quot;linux2&quot; and sysOS == &quot;linux2&quot;:</span>
    <span class="c1">#         temp = paths.os_path_split_asunder(self.currentMatch,</span>
    <span class="c1">#                                            replaceSeparators=True)[4]</span>
    <span class="c1">#         self.currentMatch = os.path.join(consts.PROJECT_ROOT_LIN, temp)</span>
    <span class="c1">#         return self.currentMatch</span>
    <span class="c1">#     elif pathOS != &quot;win32&quot; and sysOS == &quot;win32&quot;:</span>
    <span class="c1">#         temp = paths.os_path_split_asunder(self.currentMatch,</span>
    <span class="c1">#                                            replaceSeparators=True)[3]</span>
    <span class="c1">#         self.currentMatch = os.path.join(consts.PROJECT_ROOT_WIN, temp)</span>
    <span class="c1">#         return self.currentMatch</span>
    <span class="c1">#     elif pathOS not in consts.SUPPORTED_OS_LIST:</span>
    <span class="c1">#         LOGGER.critical(&quot;The Path OS given is not supported by the current &quot;</span>
    <span class="c1">#                         &quot;environment. Please contact system admin&quot;)</span>
    <span class="c1">#         return None</span>
    <span class="c1">#     elif sysOS not in consts.SUPPORTED_OS_LIST:</span>
    <span class="c1">#         LOGGER.critical(&quot;The OS given is not supported by the current &quot;</span>
    <span class="c1">#                         &quot;environment. Please contact system admin&quot;)</span>
    <span class="c1">#         return None</span>
    <span class="c1"># # end change_path_to_current_os</span>

    <span class="k">def</span> <span class="nf">change_relative_to_absolute_path</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Convenience method for change a relative path into its absolute path</span>
<span class="sd">        using self.rootDir as its base</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">pass</span>
    <span class="c1"># end change_relative_to_absolute_path</span>

    <span class="k">def</span> <span class="nf">change_paths</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dictH</span><span class="p">,</span> <span class="n">contentLines</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Originally called set_abs_path_to_rel_path but renamed because the</span>
<span class="sd">        script now supports the processing of absolute paths and relative paths.</span>
<span class="sd">        In addition, the path the ability to change separators, attempt to find</span>
<span class="sd">        relative paths that are in parent directories, and more</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">dictH</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">condition</span><span class="p">,</span> <span class="n">output</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">conds</span><span class="o">.</span><span class="n">iteritems</span><span class="p">():</span>
                <span class="k">if</span> <span class="n">condition</span><span class="p">()</span> <span class="o">==</span> <span class="n">output</span><span class="p">:</span>
                    <span class="c1"># do something</span>
                    <span class="k">pass</span>

                <span class="n">temp</span> <span class="o">=</span> <span class="s1">&#39;[+] &quot;{p}&quot; relative path created from the &#39;</span>\
                       <span class="s1">&#39;absolute path, &quot;{p1}&quot;&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">p</span><span class="o">=</span><span class="n">matchNew</span><span class="p">,</span>
                                                      <span class="n">p1</span><span class="o">=</span><span class="n">match</span><span class="p">)</span>
                <span class="n">Logger</span><span class="p">()</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="n">temp</span><span class="p">)</span>
    <span class="c1"># end change_paths</span>
<span class="c1"># end PathFinder</span>


<span class="k">class</span> <span class="nc">PathFinderMaya</span><span class="p">(</span><span class="n">PathFinder</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">filePath</span><span class="p">,</span> <span class="n">rootPath</span><span class="o">=</span><span class="n">op</span><span class="o">.</span><span class="n">StaticOperation</span><span class="o">.</span><span class="n">defaultRootDirText</span><span class="p">,</span>
                 <span class="n">checkExist</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">seek</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">recursiveSearchFiles</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span>
                 <span class="n">passUnknownPaths</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">autoResolveOSPaths</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span>
                 <span class="n">normalizePaths</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Args:</span>
<span class="sd">            filePath (str): The full file path of the file to be queried</span>
<span class="sd">            rootPath (str): The root directory, from which relative paths will</span>
<span class="sd">                            be set</span>
<span class="sd">            checkExist (bool): Only allows the operation of a file if it exists</span>
<span class="sd">            seek (bool): When enabled, will find relative paths above the root</span>
<span class="sd">                         directory</span>
<span class="sd">            .. warning::</span>
<span class="sd">                This is NOT advised for programs that do not support ../ syntax</span>
<span class="sd">                for dependencies (ex: Maya can use ../ for references but not</span>
<span class="sd">                for textures)</span>

<span class="sd">            recursiveSearchFiles (bool): When enabled, will search referencial</span>
<span class="sd">                                         scene files for other dependencies,</span>
<span class="sd">                                         until the script runs out of new scene</span>
<span class="sd">                                         files to parse and search.</span>
<span class="sd">            passUnknownPaths (bool): If a path cannot be proven to be absolute</span>
<span class="sd">                                     or relative, the script will not attempt</span>
<span class="sd">                                     to &quot;find&quot; the file and simply pass it.</span>
<span class="sd">                                     Enable if script execution is slow</span>
<span class="sd">            autoResolveOSPaths (bool): Even if a path originates from another</span>
<span class="sd">                                       OS, presuming that the path is on an</span>
<span class="sd">                                       identical folder structure on a</span>
<span class="sd">                                       dual-boot network machine (our setup),</span>
<span class="sd">                                       the script will get process the path by</span>
<span class="sd">                                       removing the OS component and swapping</span>
<span class="sd">                                       it with the current OS.</span>

<span class="sd">            .. important::</span>
<span class="sd">                For the current project, it looks in the</span>
<span class="sd">                collaborative_space/project_name to perform this</span>

<span class="sd">            :AUTHORNOTE: Test this when you&#39;ve got the script working before</span>
<span class="sd">            creating a commit to the environment</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">PathFinderMaya</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">__init__</span><span class="p">(</span><span class="n">filePath</span><span class="p">,</span> <span class="n">rootPath</span><span class="p">)</span>
        <span class="c1"># configuration options (application-specific)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sceneFileExtensions</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;.ma&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">maxParentCount</span> <span class="o">=</span> <span class="mi">3</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">rootPath</span> <span class="o">=</span> <span class="n">rootPath</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">init_root_path</span><span class="p">()</span>
    <span class="c1"># end __init__</span>
<span class="c1"># end PathFinderMaya</span>


<span class="k">def</span> <span class="nf">get_path_os</span><span class="p">(</span><span class="n">path</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    OS-independent method to predict the system&#39;s path OS</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">pathSplit</span> <span class="o">=</span> <span class="n">paths</span><span class="o">.</span><span class="n">os_path_split_asunder</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">replaceSeparators</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">re</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="s1">&#39;^[a-zA-Z]:&#39;</span><span class="p">,</span> <span class="n">pathSplit</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="s2">&quot;win32&quot;</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="s2">&quot;linux2&quot;</span>
<span class="c1"># end get_path_os</span>


<span class="k">def</span> <span class="nf">find</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">listH</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">colour</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">listH</span><span class="p">):</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">j</span> <span class="o">=</span> <span class="n">colour</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
            <span class="k">continue</span>
        <span class="k">yield</span> <span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span>
<span class="c1"># end find</span>


<span class="k">def</span> <span class="nf">change_path_to_current_os</span><span class="p">(</span><span class="n">path</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    .. danger::</span>
<span class="sd">        This script is meant for use in Montgomery Hall&#39;s labs. Don&#39;t use</span>
<span class="sd">        outside of the SCAD environment</span>

<span class="sd">    This will convert absolute paths that are from a different OS to the OS</span>
<span class="sd">    that the user is currently using (so linux to windows and windows to linux)</span>

<span class="sd">    .. note::</span>
<span class="sd">        Right now, the function supports the conversion of the following:</span>
<span class="sd">            - The local machine&#39;s custom temporary drive</span>
<span class="sd">            - The student home space</span>
<span class="sd">            - the network drive</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">multiSep</span> <span class="o">=</span> <span class="s2">&quot;[&quot;</span> <span class="o">+</span> <span class="s2">&quot;|&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="s2">&quot;</span><span class="se">\\</span><span class="s2">&quot;</span><span class="p">,</span> <span class="s2">&quot;</span><span class="se">\\\\</span><span class="s2">&quot;</span><span class="p">,</span> <span class="s2">&quot;/&quot;</span><span class="p">,</span> <span class="s2">&quot;//&quot;</span><span class="p">])</span> <span class="o">+</span> <span class="s2">&quot;]&quot;</span>
    <span class="n">winTemp</span> <span class="o">=</span> <span class="s2">r&quot;D:{}&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">multiSep</span><span class="p">)</span>
    <span class="n">linuxTemp</span> <span class="o">=</span> <span class="s2">&quot;/Temp/&quot;</span>
    <span class="n">linNet</span> <span class="o">=</span> <span class="s2">r&quot;/home&quot;</span>
    <span class="c1"># I can&#39;t presume that the person messing with absolute/relative paths</span>
    <span class="c1"># is actually the current user so instead, I&#39;ll attempt to find a valid</span>
    <span class="c1"># name for a username</span>
    <span class="c1">#</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    try:</span>
<span class="sd">        linNet = [os.path.join(linNet, x) for x in os.listdir(linNet) \</span>
<span class="sd">                  if re.match(&quot;([a-zA-Z]{4,6}[0-9]{0,2})&quot;,</span>
<span class="sd">                              os.path.join(linNet, x)) is not None][0]</span>
<span class="sd">    except KeyError:</span>
<span class="sd">        # No valid username was found in the /home directory</span>
<span class="sd">        return None</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">linNet</span> <span class="o">=</span> <span class="s2">&quot;/home/ckenne24&quot;</span>
    <span class="n">linuxStuhome</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">linNet</span><span class="p">,</span> <span class="s2">&quot;mount&quot;</span><span class="p">,</span> <span class="s2">&quot;stuhome/&quot;</span><span class="p">)</span>
    <span class="n">linNet</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">linNet</span><span class="p">,</span> <span class="s2">&quot;mount&quot;</span><span class="p">,</span> <span class="s2">&quot;collaborative/&quot;</span><span class="p">)</span>
    <span class="n">winStuhome</span> <span class="o">=</span> <span class="s2">r&quot;H:{}&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">multiSep</span><span class="p">)</span>
    <span class="n">winNetwork</span> <span class="o">=</span> <span class="s2">r&quot;I:{}Savannah{}CollaborativeSpace{}&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">multiSep</span><span class="p">,</span>
                                                              <span class="n">multiSep</span><span class="p">,</span>
                                                              <span class="n">multiSep</span><span class="p">)</span>
    <span class="n">compileString</span> <span class="o">=</span> <span class="s2">&quot;&quot;&quot;</span>
<span class="s2">                    ^(?P&lt;linuxTemp&gt;{})?</span>
<span class="s2">                    (?P&lt;winTemp&gt;{})?</span>
<span class="s2">                    (?P&lt;linuxStuhome&gt;{})?</span>
<span class="s2">                    (?P&lt;winStuhome&gt;{})?</span>
<span class="s2">                    (?P&lt;linNet&gt;{})?</span>
<span class="s2">                    (?P&lt;winNetwork&gt;{})?</span>
<span class="s2">                    &quot;&quot;&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">linuxTemp</span><span class="p">,</span> <span class="n">winTemp</span><span class="p">,</span>
                               <span class="n">linuxStuhome</span><span class="p">,</span> <span class="n">winStuhome</span><span class="p">,</span>
                               <span class="n">linNet</span><span class="p">,</span> <span class="n">winNetwork</span><span class="p">)</span>
    <span class="n">matchSectionPairs</span> <span class="o">=</span> <span class="p">[[</span><span class="s2">&quot;linuxTemp&quot;</span><span class="p">,</span> <span class="s2">&quot;winTemp&quot;</span><span class="p">],</span>
                         <span class="p">[</span><span class="s2">&quot;linuxStuhome&quot;</span><span class="p">,</span> <span class="s2">&quot;winStuhome&quot;</span><span class="p">],</span>
                         <span class="p">[</span><span class="s2">&quot;linNet&quot;</span><span class="p">,</span> <span class="s2">&quot;winNetwork&quot;</span><span class="p">]]</span>
    <span class="n">matchInfo</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;linuxTemp&quot;</span><span class="p">:</span> <span class="n">linuxTemp</span><span class="p">,</span> <span class="s2">&quot;winTemp&quot;</span><span class="p">:</span> <span class="n">winTemp</span><span class="p">,</span>
                 <span class="s2">&quot;linuxStuhome&quot;</span><span class="p">:</span> <span class="n">linuxStuhome</span><span class="p">,</span> <span class="s2">&quot;winStuhome&quot;</span><span class="p">:</span> <span class="n">winStuhome</span><span class="p">,</span>
                 <span class="s2">&quot;linNet&quot;</span><span class="p">:</span> <span class="n">linNet</span><span class="p">,</span> <span class="s2">&quot;winNetwork&quot;</span><span class="p">:</span> <span class="n">winNetwork</span><span class="p">}</span>
    <span class="n">possibleMatchSections</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span> <span class="k">for</span> <span class="n">sublist</span> <span class="ow">in</span> <span class="n">matchSectionPairs</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">sublist</span><span class="p">]</span>
    <span class="n">reCompile</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="n">compileString</span><span class="p">,</span> <span class="n">re</span><span class="o">.</span><span class="n">VERBOSE</span><span class="p">)</span>
    <span class="n">reMatch</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">reCompile</span><span class="p">,</span> <span class="n">path</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">section</span> <span class="ow">in</span> <span class="n">possibleMatchSections</span><span class="p">:</span>
        <span class="n">matchReturn</span> <span class="o">=</span> <span class="n">reMatch</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="n">section</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">matchReturn</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span> <span class="ow">and</span> <span class="n">matchReturn</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span> <span class="o">!=</span> <span class="s2">&quot;&quot;</span><span class="p">:</span>
            <span class="n">foundIndex</span><span class="p">,</span> <span class="n">nestedIndex</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="n">find</span><span class="p">(</span><span class="n">section</span><span class="p">,</span> <span class="n">matchSectionPairs</span><span class="p">))</span>
            <span class="n">matchText</span> <span class="o">=</span> <span class="n">matchInfo</span><span class="p">[</span><span class="n">section</span><span class="p">]</span>
            <span class="n">nestedIndex</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">nestedIndex</span>  <span class="c1"># invert to find the section&#39;s pair</span>
            <span class="n">listBlock</span> <span class="o">=</span> <span class="n">matchSectionPairs</span><span class="p">[</span><span class="n">foundIndex</span><span class="p">][</span><span class="n">nestedIndex</span><span class="p">]</span>
            <span class="n">replaceText</span> <span class="o">=</span> <span class="n">matchInfo</span><span class="p">[</span><span class="n">listBlock</span><span class="p">]</span>
            <span class="n">replaceOutput</span> <span class="o">=</span> <span class="n">path</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">matchReturn</span><span class="p">,</span> <span class="n">replaceText</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">normpath</span><span class="p">(</span><span class="n">replaceOutput</span><span class="p">)</span>
    <span class="c1"># if the script got this far, then no match was found and replaced</span>
    <span class="c1"># just reset it to keep the script sane</span>
    <span class="c1">#</span>
    <span class="k">return</span> <span class="n">path</span>
<span class="c1"># end change_path_to_current_os</span>


<div class="viewcode-block" id="main"><a class="viewcode-back" href="../../../syncmeister/syncmeisterdocumentation.html#syncmeister.controller.pathfinder.main">[docs]</a><span class="k">def</span> <span class="nf">main</span><span class="p">():</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    quick test</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">path1</span> <span class="o">=</span> <span class="s2">&quot;/home/ckenne24/mount/stuhome/&quot;</span>
    <span class="n">path2</span> <span class="o">=</span> <span class="s2">&quot;/home/ckenne24/mount/collaborative/&quot;</span>
    <span class="n">path3</span> <span class="o">=</span> <span class="s2">&quot;Temp/&quot;</span>
    <span class="n">path4</span> <span class="o">=</span> <span class="s2">&quot;H:</span><span class="se">\\</span><span class="s2">&quot;</span>
    <span class="n">path5</span> <span class="o">=</span> <span class="s2">&quot;I:</span><span class="se">\\</span><span class="s2">Savannah</span><span class="se">\\</span><span class="s2">CollaborativeSpace</span><span class="se">\\</span><span class="s2">&quot;</span>
    <span class="n">path6</span> <span class="o">=</span> <span class="s2">&quot;D:</span><span class="se">\\</span><span class="s2">&quot;</span>
    <span class="n">path</span> <span class="o">=</span> <span class="p">[</span><span class="n">path1</span><span class="p">,</span> <span class="n">path2</span><span class="p">,</span> <span class="n">path3</span><span class="p">,</span> <span class="n">path4</span><span class="p">,</span> <span class="n">path5</span><span class="p">,</span> <span class="n">path6</span><span class="p">]</span>
    <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">path</span><span class="p">:</span>
        <span class="n">change_path_to_current_os</span><span class="p">(</span><span class="n">p</span><span class="p">)</span></div>
<span class="c1"># end main</span>

<span class="k">def</span> <span class="nf">copytree</span><span class="p">(</span><span class="n">src</span><span class="p">,</span> <span class="n">dest</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Mimics the functionality of shutil.copytree() without its recursivion</span>

<span class="sd">    directories are built using os.makedirs()</span>
<span class="sd">    file literals are copied with shutil.copy2()</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isdir</span><span class="p">(</span><span class="n">src</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isfile</span><span class="p">(</span><span class="n">src</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">IOError</span><span class="p">(</span><span class="s2">&quot;Invalid path: {} specified. &quot;</span>
                      <span class="s2">&quot;Not file or folder&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">src</span><span class="p">))</span>

    <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isdir</span><span class="p">(</span><span class="n">src</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isdir</span><span class="p">(</span><span class="n">dest</span><span class="p">):</span>
        <span class="n">mkdir_p</span><span class="p">(</span><span class="n">dest</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isfile</span><span class="p">(</span><span class="n">src</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isfile</span><span class="p">(</span><span class="n">dest</span><span class="p">):</span>
        <span class="nb">dir</span><span class="p">,</span> <span class="n">f</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">splitdrive</span><span class="p">(</span><span class="n">dest</span><span class="p">)</span>
        <span class="n">mkdir_p</span><span class="p">(</span><span class="nb">dir</span><span class="p">)</span>
        <span class="n">shutil</span><span class="o">.</span><span class="n">copy2</span><span class="p">(</span><span class="n">src</span><span class="p">,</span> <span class="n">dest</span><span class="p">)</span>
<span class="c1"># end copytree</span>


<span class="k">def</span> <span class="nf">test_syncmeister_0001</span><span class="p">():</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Quick test module</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">rootDir</span> <span class="o">=</span> <span class="s2">r&quot;/home/selecaotwo/Dropbox/Private/my_PROJECT/proj_POP2/Pipeline/the_LATEST/sys_PY/py_MODULES/syncmeister/test/src_location/created_project&quot;</span>
    <span class="n">filePath</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">rootDir</span><span class="p">,</span> <span class="s2">&quot;scenes/simple.ma&quot;</span><span class="p">)</span>

    <span class="c1"># rootDir = r&quot;/home/selecaotwo/Desktop&quot;</span>
    <span class="c1"># filePath = os.path.join(rootDir, &quot;simple.ma&quot;)</span>

    <span class="c1"># rootDir = r&quot;/media/TOSHIBA EXT/the_LATEST/sys_PY/py_MODULES/syncmeister/test/src_location/created_project&quot;</span>
    <span class="c1"># filePath = os.path.join(rootDir, &quot;scenes&quot;, &quot;simple.ma&quot;)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isdir</span><span class="p">(</span><span class="n">rootDir</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">IOError</span><span class="p">(</span><span class="s2">&quot;Path: {!r} does not exist!&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">rootDir</span><span class="p">))</span>
    <span class="k">elif</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isfile</span><span class="p">(</span><span class="n">filePath</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">IOError</span><span class="p">(</span><span class="s2">&quot;File: {!r} does not exist!&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">filePath</span><span class="p">))</span>

    <span class="n">LOGGER</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Using Maya file </span><span class="si">%s</span><span class="s2">...&quot;</span> <span class="o">%</span> <span class="n">filePath</span><span class="p">)</span>

    <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">filePath</span><span class="p">,</span> <span class="s2">&quot;r&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
        <span class="n">contents</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">readlines</span><span class="p">()</span>

    <span class="n">sysOS</span> <span class="o">=</span> <span class="n">sys</span><span class="o">.</span><span class="n">platform</span>
    <span class="n">pathFinder</span> <span class="o">=</span> <span class="n">PathFinderMaya</span><span class="p">(</span><span class="n">filePath</span><span class="p">,</span> <span class="n">rootDir</span><span class="p">)</span>
    <span class="n">quotedLines</span> <span class="o">=</span> <span class="n">engine</span><span class="o">.</span><span class="n">get_substring_from_quotes</span><span class="p">(</span><span class="n">contents</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">index</span><span class="p">,</span> <span class="n">match</span> <span class="ow">in</span> <span class="n">quotedLines</span><span class="o">.</span><span class="n">iteritems</span><span class="p">():</span>
        <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">match</span><span class="p">:</span>
            <span class="n">pathFinder</span><span class="o">.</span><span class="n">currentMatch</span> <span class="o">=</span> <span class="n">m</span>
            <span class="n">orig</span><span class="p">,</span> <span class="n">modified</span> <span class="o">=</span> <span class="n">pathFinder</span><span class="o">.</span><span class="n">eval_match_conditions</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">modified</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span> <span class="ow">and</span> <span class="n">orig</span> <span class="o">!=</span> <span class="n">modified</span><span class="p">:</span>
                <span class="c1"># do something</span>
                <span class="k">pass</span>
    <span class="c1">#     print contents[index]</span>
    <span class="c1">#     print line</span>
<span class="c1"># end test_syncmeister_0001</span>


<span class="k">if</span> <span class="n">__name__</span> <span class="o">==</span> <span class="s2">&quot;__main__&quot;</span><span class="p">:</span>
    <span class="n">test_syncmeister_0001</span><span class="p">()</span>
</pre></div>

           </div>
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2016, Colin Kennedy.

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'../../../',
            VERSION:'1.0.0',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true
        };
    </script>
      <script type="text/javascript" src="../../../_static/jquery.js"></script>
      <script type="text/javascript" src="../../../_static/underscore.js"></script>
      <script type="text/javascript" src="../../../_static/doctools.js"></script>

  

  
  
    <script type="text/javascript" src="../../../_static/js/theme.js"></script>
  

  
  
  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.StickyNav.enable();
      });
  </script>
   

</body>
</html>