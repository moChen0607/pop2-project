

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>fileio.controller.paths &mdash; Portal: Origins [Part 2] 1.0.0 documentation</title>
  

  
  

  

  
  
    

  

  
  
    <link rel="stylesheet" href="../../../_static/css/theme.css" type="text/css" />
  

  

  
    <link rel="top" title="Portal: Origins [Part 2] 1.0.0 documentation" href="../../../index.html"/>
        <link rel="up" title="Module code" href="../../index.html"/> 

  
  <script src="../../../_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="../../../index.html" class="icon icon-home"> Portal: Origins [Part 2]
          

          
          </a>

          
            
            
              <div class="version">
                1.0.0
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
                <ul>
<li class="toctree-l1"><a class="reference internal" href="../../../userguide.html">The Definitive User Guide</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../administration.html">Administrative Portal</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../changelog.html">Changelog</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
        <a href="../../../index.html">Portal: Origins [Part 2]</a>
      </nav>


      
      <div class="wy-nav-content">
        <div class="rst-content">
          





<div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="../../../index.html">Docs</a> &raquo;</li>
      
          <li><a href="../../index.html">Module code</a> &raquo;</li>
      
    <li>fileio.controller.paths</li>
      <li class="wy-breadcrumbs-aside">
        
          
        
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <h1>Source code for fileio.controller.paths</h1><div class="highlight"><pre>
<span class="ch">#!/usr/bin/env python</span>
<span class="c1"># -*- coding: utf-8 -*-</span>

<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Methods dealing specifically with path strings and folder/file structures</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="c1"># IMPORT STANDARD LIBRARIES</span>
<span class="kn">import</span> <span class="nn">os</span>
<span class="kn">import</span> <span class="nn">re</span>
<span class="kn">import</span> <span class="nn">ntpath</span>
<span class="kn">import</span> <span class="nn">errno</span>
<span class="kn">import</span> <span class="nn">stat</span>

<span class="c1"># IMPORT STANDARD LIBRARIES</span>
<span class="kn">import</span> <span class="nn">logger.common.loggingServices</span> <span class="kn">as</span> <span class="nn">loggingservices</span>
<span class="n">LOGGER</span> <span class="o">=</span> <span class="n">loggingservices</span><span class="o">.</span><span class="n">init_logger</span><span class="p">()</span>
<span class="kn">import</span> <span class="nn">filesequencer</span> <span class="kn">as</span> <span class="nn">fileSeq</span>


<div class="viewcode-block" id="path_leaf"><a class="viewcode-back" href="../../../fileio.html#fileio.controller.paths.path_leaf">[docs]</a><span class="k">def</span> <span class="nf">path_leaf</span><span class="p">(</span><span class="n">path</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    os.path.split()[-1] doesn&#39;t work in all cases (if you run the script in</span>
<span class="sd">    Linux and attempt to split a Windows-Style path). This function is a</span>
<span class="sd">    solution by Lauritz V. Thaulow</span>

<span class="sd">    .. Reference::</span>
<span class="sd">        https://stackoverflow.com/questions/8384737</span>

<span class="sd">    Args:</span>
<span class="sd">    path (str): The full path to get the filename from</span>

<span class="sd">    Returns:</span>
<span class="sd">        str: The filename at the end of the path</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">head</span><span class="p">,</span> <span class="n">tail</span> <span class="o">=</span> <span class="n">ntpath</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">path</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">tail</span> <span class="ow">or</span> <span class="n">ntpath</span><span class="o">.</span><span class="n">basename</span><span class="p">(</span><span class="n">head</span><span class="p">)</span></div>
<span class="c1"># end path_leaf</span>


<div class="viewcode-block" id="os_path_split_asunder"><a class="viewcode-back" href="../../../fileio.html#fileio.controller.paths.os_path_split_asunder">[docs]</a><span class="k">def</span> <span class="nf">os_path_split_asunder</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">debug</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    IMPORTANT: before running, you must use os.path.splitdrive(path)</span>
<span class="sd">    and separate the drive and path. Otherwise Windows paths will</span>
<span class="sd">    create errors. You&#39;ll have to manually add the drive letter back in</span>

<span class="sd">    This method is comparably safer for splitting and merging paths</span>
<span class="sd">    than other methods such as replace_sep_with_string</span>

<span class="sd">     &gt;&gt;&gt; path = r&#39;C:\some\path&#39;</span>
<span class="sd">     &gt;&gt;&gt; drive, path = os.splitdrive(path)</span>
<span class="sd">     &gt;&gt;&gt; splitPath = os_path_split_asunder(path)</span>
<span class="sd">     [&#39;some&#39;, &#39;path&#39;]</span>

<span class="sd">    Args:</span>
<span class="sd">        path (str): The string path to be processed</span>
<span class="sd">        debug (bool): Whether or not to send debug information to stdout</span>
<span class="sd">                      to catch in a logger</span>
<span class="sd">    Returns:</span>
<span class="sd">        list: A list which contains the entire path, separated by folders</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">parts</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
        <span class="n">newpath</span><span class="p">,</span> <span class="n">tail</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">path</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">debug</span><span class="p">:</span> <span class="k">print</span> <span class="nb">repr</span><span class="p">(</span><span class="n">path</span><span class="p">),</span> <span class="p">(</span><span class="n">newpath</span><span class="p">,</span> <span class="n">tail</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">newpath</span> <span class="o">==</span> <span class="n">path</span><span class="p">:</span>
            <span class="k">assert</span> <span class="ow">not</span> <span class="n">tail</span>
            <span class="k">if</span> <span class="n">path</span><span class="p">:</span> <span class="n">parts</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">path</span><span class="p">)</span>
            <span class="k">break</span>
        <span class="n">parts</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">tail</span><span class="p">)</span>
        <span class="n">path</span> <span class="o">=</span> <span class="n">newpath</span>
    <span class="n">parts</span><span class="o">.</span><span class="n">reverse</span><span class="p">()</span>
    <span class="n">parts</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">parts</span> <span class="k">if</span> <span class="n">x</span> <span class="o">!=</span> <span class="s1">&#39;&#39;</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">parts</span></div>
<span class="c1"># end os_path_split_asunder</span>


<div class="viewcode-block" id="walk_level"><a class="viewcode-back" href="../../../fileio.html#fileio.controller.paths.walk_level">[docs]</a><span class="k">def</span> <span class="nf">walk_level</span><span class="p">(</span><span class="n">someDir</span><span class="p">,</span> <span class="n">level</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">output</span><span class="o">=</span><span class="s2">&quot;files&quot;</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    walk_level will recursively traverse a given folder and output, files,</span>
<span class="sd">    folders, or both in the form of a list</span>

<span class="sd">    Args:</span>
<span class="sd">        someDir (str): The directory to walk into</span>
<span class="sd">        level (int): The number of folders down allowed</span>
<span class="sd">        output (str): Decide if you want files/folders/files+folders as return</span>

<span class="sd">    Returns:</span>
<span class="sd">        list of strs: A list of files/folders/files+folders</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">someDir</span> <span class="o">=</span> <span class="n">someDir</span><span class="o">.</span><span class="n">rstrip</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">sep</span><span class="p">)</span>
    <span class="k">assert</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isdir</span><span class="p">(</span><span class="n">someDir</span><span class="p">)</span>
    <span class="n">numSep</span> <span class="o">=</span> <span class="n">someDir</span><span class="o">.</span><span class="n">count</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">sep</span><span class="p">)</span>

    <span class="n">outputPossibilities</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;FILES&#39;</span><span class="p">,</span> <span class="s1">&#39;FOLDERS&#39;</span><span class="p">,</span> <span class="s1">&#39;FILES+FOLDERS&#39;</span><span class="p">]</span>
    <span class="n">output</span> <span class="o">=</span> <span class="n">output</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span>
    <span class="k">if</span> <span class="n">output</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">outputPossibilities</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s1">&#39;Option: &quot;{}&quot; did not receive proper args. &#39;</span>
                           <span class="s1">&#39;Possiblities are {}&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">output</span><span class="p">,</span>
                                                        <span class="n">outputPossibilities</span><span class="p">))</span>
    <span class="k">for</span> <span class="n">root</span><span class="p">,</span> <span class="n">dirs</span><span class="p">,</span> <span class="n">files</span> <span class="ow">in</span> <span class="n">os</span><span class="o">.</span><span class="n">walk</span><span class="p">(</span><span class="n">someDir</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">output</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span> <span class="o">==</span> <span class="s2">&quot;FILES&quot;</span><span class="p">:</span>
            <span class="k">for</span> <span class="nb">file</span> <span class="ow">in</span> <span class="n">files</span><span class="p">:</span>
                <span class="k">yield</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="nb">file</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">output</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span> <span class="o">==</span> <span class="s2">&quot;FILES+FOLDERS&quot;</span><span class="p">:</span>
            <span class="k">for</span> <span class="nb">dir</span> <span class="ow">in</span> <span class="n">dirs</span><span class="p">:</span>
                <span class="k">yield</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="nb">dir</span><span class="p">)</span>
            <span class="k">for</span> <span class="nb">file</span> <span class="ow">in</span> <span class="n">files</span><span class="p">:</span>
                <span class="k">yield</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="nb">file</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">output</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span> <span class="o">==</span> <span class="s1">&#39;FOLDERS&#39;</span><span class="p">:</span>
            <span class="k">for</span> <span class="nb">dir</span> <span class="ow">in</span> <span class="n">dirs</span><span class="p">:</span>
                <span class="k">yield</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="nb">dir</span><span class="p">)</span>
        <span class="n">numSepCurrent</span> <span class="o">=</span> <span class="n">root</span><span class="o">.</span><span class="n">count</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">sep</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">numSep</span> <span class="o">+</span> <span class="n">level</span> <span class="o">&lt;=</span> <span class="n">numSepCurrent</span><span class="p">:</span>
            <span class="k">del</span> <span class="n">dirs</span><span class="p">[:]</span></div>
<span class="c1"># end walklevel</span>


<div class="viewcode-block" id="mkdir_p"><a class="viewcode-back" href="../../../fileio.html#fileio.controller.paths.mkdir_p">[docs]</a><span class="k">def</span> <span class="nf">mkdir_p</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">existsOk</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Emulates the linux command mkdir -p, where the command makes a dir and</span>
<span class="sd">    all of its parent dirs if they do not exist</span>

<span class="sd">    Args:</span>
<span class="sd">        path (str): The path of folders that you wish to create</span>
<span class="sd">        existsOk (bool): Decides if the command should be permitted to run</span>
<span class="sd">                         if the dir already exists</span>

<span class="sd">    Returns:</span>
<span class="sd">        bool: True/False depending on whether or not path as properly created</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">os</span><span class="o">.</span><span class="n">makedirs</span><span class="p">(</span><span class="n">path</span><span class="p">)</span>
    <span class="k">except</span> <span class="ne">OSError</span> <span class="k">as</span> <span class="n">exc</span><span class="p">:</span>  <span class="c1"># Python &gt;2.5</span>
        <span class="k">if</span> <span class="n">existsOk</span> <span class="ow">and</span> <span class="n">exc</span><span class="o">.</span><span class="n">errno</span> <span class="o">==</span> <span class="n">errno</span><span class="o">.</span><span class="n">EEXIST</span> <span class="ow">and</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isdir</span><span class="p">(</span><span class="n">path</span><span class="p">):</span>
            <span class="k">pass</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span>

    <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isdir</span><span class="p">(</span><span class="n">path</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">True</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">False</span></div>
<span class="c1"># end mkdir_p</span>


<div class="viewcode-block" id="get_expanded_str_from_index"><a class="viewcode-back" href="../../../fileio.html#fileio.controller.paths.get_expanded_str_from_index">[docs]</a><span class="k">def</span> <span class="nf">get_expanded_str_from_index</span><span class="p">(</span><span class="n">inputH</span><span class="p">,</span> <span class="n">index</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns a given number from a parseable string</span>
<span class="sd">    as an expanded string with correct padding</span>

<span class="sd">    .. TODO::</span>
<span class="sd">     If time, go back and make this function more memory efficient</span>

<span class="sd">    Args:</span>
<span class="sd">        inputH (str): The full path to a file or filename</span>
<span class="sd">        index (int): The numbered frame to retrieve from the expanded string</span>

<span class="sd">    Returns:</span>
<span class="sd">        str: The expanded string without any expression or formatted text</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">matchTest</span> <span class="o">=</span> <span class="n">path_leaf</span><span class="p">(</span><span class="n">inputH</span><span class="p">)</span>
    <span class="n">expansionTest</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">fileSeq</span><span class="o">.</span><span class="n">expand_sequence</span><span class="p">(</span><span class="n">matchTest</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">expansionTest</span><span class="p">[</span><span class="n">index</span><span class="p">]</span></div>
<span class="c1"># end get_expanded_str_from_index</span>


<div class="viewcode-block" id="parse_sequence"><a class="viewcode-back" href="../../../fileio.html#fileio.controller.paths.parse_sequence">[docs]</a><span class="k">def</span> <span class="nf">parse_sequence</span><span class="p">(</span><span class="n">inputH</span><span class="p">,</span> <span class="n">rootPath</span><span class="p">,</span> <span class="n">checkExist</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Files files from a formatted string with expression (TCL %04d,</span>
<span class="sd">    Houdini-style $F4, Nuke&#39;s ####) are parsed into full file names and tested</span>
<span class="sd">    for existence</span>

<span class="sd">    Example input:</span>
<span class="sd">     &gt;&gt;&gt; someFile = &quot;some_file_$F2.tiff&quot;</span>
<span class="sd">     Generator Object containing...</span>
<span class="sd">     some_file_00.tiff some_file_01.tiff some_file_02.tiff some_file_03.tiff</span>
<span class="sd">     some_file_04.tiff some_file_05.tiff some_file_06.tiff some_file_07.tiff</span>
<span class="sd">     some_file_08.tiff some_file_09.tiff</span>

<span class="sd">    Args:</span>
<span class="sd">        inputH (str): The file/folder path to parse</span>
<span class="sd">        rootPath (str): Used for attempting to resolve relative paths and checking</span>
<span class="sd">                        File(s)/Folder(s) for existence</span>
<span class="sd">        checkExist (bool): True/False</span>

<span class="sd">    Yields:</span>
<span class="sd">        str: A generator containing all of the parsed strings found</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">matchTest</span> <span class="o">=</span> <span class="n">path_leaf</span><span class="p">(</span><span class="n">inputH</span><span class="p">)</span>
    <span class="n">expansionTest</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">fileSeq</span><span class="o">.</span><span class="n">expand_sequence</span><span class="p">(</span><span class="n">matchTest</span><span class="p">))</span>

    <span class="k">if</span> <span class="n">expansionTest</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
        <span class="n">matchTest</span> <span class="o">=</span> <span class="n">expansionTest</span>
        <span class="n">dirname</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">dirname</span><span class="p">(</span><span class="n">inputH</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">matchTest</span><span class="p">:</span>
            <span class="n">mTest</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">normpath</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">dirname</span><span class="p">,</span> <span class="n">m</span><span class="p">))</span>
            <span class="k">if</span> <span class="n">is_relative</span><span class="p">(</span><span class="n">mTest</span><span class="p">):</span>
                <span class="n">mTest</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">rootPath</span><span class="p">,</span> <span class="n">mTest</span><span class="p">)</span>
                <span class="n">mTest</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">normpath</span><span class="p">(</span><span class="n">mTest</span><span class="p">)</span>

            <span class="c1"># attempt hard join</span>
            <span class="k">if</span> <span class="n">checkExist</span> <span class="ow">and</span> <span class="p">(</span><span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isfile</span><span class="p">(</span><span class="n">mTest</span><span class="p">)</span> \
                    <span class="ow">or</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isdir</span><span class="p">(</span><span class="n">mTest</span><span class="p">)):</span>
                <span class="k">continue</span>  <span class="c1"># skip</span>
            <span class="k">elif</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isfile</span><span class="p">(</span><span class="n">mTest</span><span class="p">)</span> <span class="ow">or</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isdir</span><span class="p">(</span><span class="n">mTest</span><span class="p">):</span>
                <span class="n">LOGGER</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;[+] File/Folder: {f} found from, &quot;</span>
                <span class="s2">&quot;{f1}&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">f</span><span class="o">=</span><span class="n">mTest</span><span class="p">,</span> <span class="n">f1</span><span class="o">=</span><span class="n">inputH</span><span class="p">))</span>
            <span class="c1"># ::AUTHORNOTE:: add support for strings that aren&#39;t yet files/folders</span>
            <span class="c1"># for examples, strings that represents files that will be rendered</span>
            <span class="c1"># assume</span>
            <span class="k">yield</span> <span class="n">mTest</span></div>
<span class="c1"># end parse_seqence</span>


<div class="viewcode-block" id="is_parseable"><a class="viewcode-back" href="../../../fileio.html#fileio.controller.paths.is_parseable">[docs]</a><span class="k">def</span> <span class="nf">is_parseable</span><span class="p">(</span><span class="n">string</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Checks if a file/folder path has text in it that could be considered</span>
<span class="sd">    &quot;Able to be parsed&quot; or expanded into a sequence of files</span>

<span class="sd">    .. TODO::</span>
<span class="sd">     Replace this with a regex that detects if there is ####, $F4, or %04d</span>

<span class="sd">    Args:</span>
<span class="sd">        string (str): The string to check</span>

<span class="sd">    Returns:</span>
<span class="sd">        bool: True/False</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="s2">&quot;#&quot;</span> <span class="ow">in</span> <span class="n">string</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">True</span>
    <span class="k">elif</span> <span class="s2">&quot;%&quot;</span> <span class="ow">in</span> <span class="n">string</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">True</span>
    <span class="k">elif</span> <span class="s2">&quot;$&quot;</span> <span class="ow">in</span> <span class="n">string</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">True</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">False</span></div>
<span class="c1"># end is_parseable</span>


<div class="viewcode-block" id="replace_sep_with_string"><a class="viewcode-back" href="../../../fileio.html#fileio.controller.paths.replace_sep_with_string">[docs]</a><span class="k">def</span> <span class="nf">replace_sep_with_string</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">inputH</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Replaces the seperators in a string of text with inputH</span>

<span class="sd">    .. Note::</span>
<span class="sd">     DEPRECATED in-favor of os.path.normcase()/os.path.normpath()</span>

<span class="sd">    Args:</span>
<span class="sd">        path (str): The path to replace the separators</span>
<span class="sd">        inputH (str or anything): The object to replace separators with</span>

<span class="sd">    Returns:</span>
<span class="sd">        str: The original path, with eahc of its separators replaced</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">matchRe</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="s2">r&quot;//|/|</span><span class="se">\\</span><span class="s2">*?&quot;</span><span class="p">)</span>  <span class="c1"># get all types of separators</span>
    <span class="n">line</span> <span class="o">=</span> <span class="n">matchRe</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">inputH</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">line</span></div>
<span class="c1"># end replace_sep_with_string</span>


<div class="viewcode-block" id="search_parent_count"><a class="viewcode-back" href="../../../fileio.html#fileio.controller.paths.search_parent_count">[docs]</a><span class="k">def</span> <span class="nf">search_parent_count</span><span class="p">(</span><span class="n">string</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Looks at a relative path and determines how many parent folders back</span>
<span class="sd">    the path is refers to, if at all</span>

<span class="sd">    Example:</span>
<span class="sd">     &gt;&gt;&gt; search_parent_count(&quot;../../some/path/foo.bar&quot;)</span>
<span class="sd">     2</span>

<span class="sd">    Args:</span>
<span class="sd">        string (str): The (presumably relative path) string to check</span>

<span class="sd">    Returns:</span>
<span class="sd">        int: The number of parent folders to search back</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">reMatch</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="s1">r&#39;(?:\.\./)|(?:\.\.</span><span class="se">\\</span><span class="s1">)|(?:\./)|(?:\.</span><span class="se">\\</span><span class="s1">)&#39;</span><span class="p">)</span>
    <span class="n">match</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">findall</span><span class="p">(</span><span class="n">reMatch</span><span class="p">,</span> <span class="n">string</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">match</span> <span class="ow">is</span> <span class="bp">None</span> <span class="ow">or</span> <span class="n">match</span> <span class="o">==</span> <span class="p">[]:</span>
        <span class="k">return</span> <span class="bp">None</span>
    <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">match</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">{</span><span class="s1">&#39;match&#39;</span><span class="p">:</span> <span class="n">match</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
                <span class="s1">&#39;count&#39;</span><span class="p">:</span> <span class="nb">len</span><span class="p">(</span><span class="n">match</span><span class="p">),</span>
                <span class="s1">&#39;is_current_dir&#39;</span><span class="p">:</span> <span class="bp">True</span><span class="p">}</span>
    <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">match</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">{</span><span class="s1">&#39;match&#39;</span><span class="p">:</span> <span class="n">match</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
                <span class="s1">&#39;count&#39;</span><span class="p">:</span> <span class="nb">len</span><span class="p">(</span><span class="n">match</span><span class="p">),</span>
                <span class="s1">&#39;is_current_dir&#39;</span><span class="p">:</span> <span class="bp">False</span><span class="p">}</span></div>
<span class="c1"># end search_parent_count</span>


<div class="viewcode-block" id="is_current_dir"><a class="viewcode-back" href="../../../fileio.html#fileio.controller.paths.is_current_dir">[docs]</a><span class="k">def</span> <span class="nf">is_current_dir</span><span class="p">(</span><span class="n">string</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Checks if the path has a relative prefix that references</span>
<span class="sd">    the current directory</span>

<span class="sd">    Args:</span>
<span class="sd">        string (str): The filepath that may or may not prefix with ./|.\\</span>

<span class="sd">    Returns:</span>
<span class="sd">        bool: True/False</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">reMatch</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="s1">r&#39;(?:\./)|(?:\.</span><span class="se">\\</span><span class="s1">)&#39;</span><span class="p">)</span>
    <span class="n">match</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">findall</span><span class="p">(</span><span class="n">reMatch</span><span class="p">,</span> <span class="n">string</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">search_parent_count</span><span class="p">(</span><span class="n">string</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span> <span class="ow">and</span> \
       <span class="nb">len</span><span class="p">(</span><span class="n">search_parent_count</span><span class="p">(</span><span class="n">string</span><span class="p">)[</span><span class="s1">&#39;match&#39;</span><span class="p">])</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">False</span>  <span class="c1"># catch exceptions for ../, ..\, and ..\\</span>
    <span class="k">elif</span> <span class="n">match</span> <span class="ow">is</span> <span class="bp">None</span> <span class="ow">or</span> <span class="n">match</span> <span class="o">==</span> <span class="p">[]:</span>
        <span class="k">return</span> <span class="bp">False</span>  <span class="c1"># nothing found</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">True</span>  <span class="c1"># found ./, .\, or .\\</span></div>
<span class="c1"># end is_current_dir</span>


<div class="viewcode-block" id="is_relative"><a class="viewcode-back" href="../../../fileio.html#fileio.controller.paths.is_relative">[docs]</a><span class="k">def</span> <span class="nf">is_relative</span><span class="p">(</span><span class="n">string</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    OS-Naive method that checks if the current path has a relative prefix</span>

<span class="sd">    Args:</span>
<span class="sd">        string (str): The filepath to check for relative path markers</span>

<span class="sd">    Returns:</span>
<span class="sd">        bool: True/False</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">_</span><span class="p">,</span> <span class="n">winfilename</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">splitdrive</span><span class="p">(</span><span class="n">string</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">string</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s1">&#39;/&#39;</span><span class="p">)</span> <span class="ow">or</span> <span class="n">winfilename</span> <span class="o">!=</span> <span class="n">string</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">True</span>

    <span class="k">if</span> <span class="n">search_parent_count</span><span class="p">(</span><span class="n">string</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span> <span class="ow">or</span> <span class="n">is_current_dir</span><span class="p">(</span><span class="n">string</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">True</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">False</span></div>
<span class="c1"># end is_relative</span>


<div class="viewcode-block" id="get_size"><a class="viewcode-back" href="../../../fileio.html#fileio.controller.paths.get_size">[docs]</a><span class="k">def</span> <span class="nf">get_size</span><span class="p">(</span><span class="n">startPath</span><span class="o">=</span><span class="s1">&#39;.&#39;</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Gets size of a folder</span>

<span class="sd">    Args:</span>
<span class="sd">        startPath (str): The full path that is the base directory of get_size</span>

<span class="sd">    Returns:</span>
<span class="sd">        int: The total size, in bytes</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">totalSize</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">dirpath</span><span class="p">,</span> <span class="n">dirnames</span><span class="p">,</span> <span class="n">filenames</span> <span class="ow">in</span> <span class="n">os</span><span class="o">.</span><span class="n">walk</span><span class="p">(</span><span class="n">startPath</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">filenames</span><span class="p">:</span>
            <span class="n">fp</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">dirpath</span><span class="p">,</span> <span class="n">f</span><span class="p">)</span>
            <span class="n">totalSize</span> <span class="o">+=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">getsize</span><span class="p">(</span><span class="n">fp</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">totalSize</span></div>
<span class="c1"># end get_size</span>


<div class="viewcode-block" id="get_maya_files"><a class="viewcode-back" href="../../../fileio.html#fileio.controller.paths.get_maya_files">[docs]</a><span class="k">def</span> <span class="nf">get_maya_files</span><span class="p">(</span><span class="n">inputH</span><span class="p">,</span> <span class="n">level</span><span class="p">,</span> <span class="n">endswith</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Gets all files that match a certain extension from a list of files</span>
<span class="sd">    and folders. Supports recursion</span>

<span class="sd">    .. Note::</span>
<span class="sd">     Written with Maya files in mind but actually supports any file-type</span>

<span class="sd">    Args:</span>
<span class="sd">        inputH (str): an iterable which contains full paths to folders</span>
<span class="sd">        level (int): The number of subfolders allowed to search for maya files.</span>
<span class="sd">                     Set to a large number to mimic the behavior of a fully</span>
<span class="sd">                     recursive query (once it reaches the end it will terminate</span>
<span class="sd">                     on its own)</span>
<span class="sd">        endswith (str or tuple of strs): The file extension to search for.</span>
<span class="sd">                                         If you want to return all files, use *</span>

<span class="sd">    Yields:</span>
<span class="sd">        str: An iterable of full paths to files</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">for</span> <span class="n">entry</span> <span class="ow">in</span> <span class="n">inputH</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isdir</span><span class="p">(</span><span class="n">entry</span><span class="p">):</span>
            <span class="n">getListings</span> <span class="o">=</span> <span class="n">walk_level</span><span class="p">(</span><span class="n">entry</span><span class="p">,</span> <span class="n">level</span><span class="p">)</span>
            <span class="n">files</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">getListings</span><span class="p">)</span>
            <span class="n">files</span> <span class="o">=</span> <span class="p">[</span><span class="n">f</span> <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">files</span> <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isfile</span><span class="p">(</span><span class="n">f</span><span class="p">)]</span>
            <span class="n">files</span> <span class="o">=</span> <span class="p">[</span><span class="n">f</span> <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">files</span> <span class="k">if</span> <span class="n">f</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="n">endswith</span><span class="p">)]</span>
        <span class="k">elif</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isfile</span><span class="p">(</span><span class="n">entry</span><span class="p">):</span>
            <span class="n">files</span> <span class="o">=</span> <span class="p">[</span><span class="n">entry</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">temp</span> <span class="o">=</span> <span class="s1">&#39;[-] The following input, &quot;{f}&quot;, is not a valid &#39;</span>\
                   <span class="s1">&#39;file or folder&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">f</span><span class="o">=</span><span class="n">f</span><span class="p">)</span>
            <span class="n">LOGGER</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="n">temp</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">files</span><span class="p">:</span>
            <span class="k">yield</span> <span class="n">f</span></div>
<span class="c1"># end get_maya_files</span>


<span class="c1"># def ignore_paths(path):</span>
<span class="c1">#     &quot;&quot;&quot;</span>
<span class="c1">#     Designates which files to ignore in a struct-tree representing</span>
<span class="c1">#     file(s)/folder(s). For an example of how it&#39;s used, see: :ref:`syncmeister`</span>
<span class="c1">#     &quot;&quot;&quot;</span>
<span class="c1">#     def ignoref(p, files):</span>
<span class="c1">#         return (f for f in files if os.abspath(os.path.join(p, f)) == path)</span>
<span class="c1">#     return ignoref</span>
<span class="c1"># # end ignore_paths</span>

<div class="viewcode-block" id="get_common_parent_dir_pair"><a class="viewcode-back" href="../../../fileio.html#fileio.controller.paths.get_common_parent_dir_pair">[docs]</a><span class="k">def</span> <span class="nf">get_common_parent_dir_pair</span><span class="p">(</span><span class="n">path1</span><span class="p">,</span> <span class="n">path2</span><span class="p">,</span> <span class="n">mustExist</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">mustMatch</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compares two paths for a common prefix much like os.path.commonprefix() but</span>
<span class="sd">    has the additional functionality of checking if the results are not partial</span>
<span class="sd">    matches and whether or not the match exists as a file/folder</span>

<span class="sd">    Args:</span>
<span class="sd">        path1 (str): One of the paths to be compared</span>
<span class="sd">        path2 (str): Another path to be compared</span>
<span class="sd">        mustExist (bool): Requires that the prefix obtained must actually exist</span>

<span class="sd">    Returns:</span>
<span class="sd">        bool: True/False</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">path1</span><span class="p">)</span> <span class="o">&gt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">path2</span><span class="p">):</span>
        <span class="c1"># swap the strings if the user input them out of order</span>
        <span class="n">path1</span><span class="p">,</span> <span class="n">path2</span> <span class="o">=</span> <span class="n">path2</span><span class="p">,</span> <span class="n">path1</span>

    <span class="n">commonPrefix</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">commonprefix</span><span class="p">([</span><span class="n">path1</span><span class="p">,</span> <span class="n">path2</span><span class="p">])</span>
    <span class="k">if</span> <span class="n">commonPrefix</span> <span class="o">==</span> <span class="s2">&quot;&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">None</span>
    <span class="k">elif</span> <span class="n">commonPrefix</span> <span class="o">!=</span> <span class="s2">&quot;&quot;</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">mustMatch</span> <span class="ow">and</span> <span class="n">mustExist</span> \
                                              <span class="ow">and</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">commonPrefix</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">commonPrefix</span>
    <span class="k">elif</span> <span class="n">commonPrefix</span> <span class="o">!=</span> <span class="s2">&quot;&quot;</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">mustExist</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">mustMatch</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">commonPrefix</span>

    <span class="n">_</span><span class="p">,</span> <span class="n">commonPath</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">splitdrive</span><span class="p">(</span><span class="n">commonPrefix</span><span class="p">)</span>
    <span class="n">_</span><span class="p">,</span> <span class="n">path</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">splitdrive</span><span class="p">(</span><span class="n">path2</span><span class="p">)</span>  <span class="c1"># only one path is needed for testing</span>

    <span class="n">commonPathSplit</span> <span class="o">=</span> <span class="n">os_path_split_asunder</span><span class="p">(</span><span class="n">commonPath</span><span class="p">)</span>
    <span class="n">pathSplit</span> <span class="o">=</span> <span class="n">os_path_split_asunder</span><span class="p">(</span><span class="n">path</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">index</span><span class="p">,</span> <span class="n">folder</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">pathSplit</span><span class="p">):</span>
        <span class="c1"># this is a precaution to make sure partial commonprefixes</span>
        <span class="k">if</span> <span class="n">commonPathSplit</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">folder</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">commonPathSplit</span><span class="p">)</span>
    <span class="k">return</span> <span class="bp">None</span></div>
<span class="c1"># end get_common_parent_dir_pair</span>


<div class="viewcode-block" id="has_common_parent_dir"><a class="viewcode-back" href="../../../fileio.html#fileio.controller.paths.has_common_parent_dir">[docs]</a><span class="k">def</span> <span class="nf">has_common_parent_dir</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">comparisonPaths</span><span class="p">,</span>
                          <span class="n">mustExist</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">mustMatch</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    has_common_parent_dir is built for the purpose of determining if a given</span>
<span class="sd">    iterable (list or iterable) contains a string that is a parent directory.</span>
<span class="sd">    This function was made because os.path.commonprefix() frequently returns</span>
<span class="sd">    directories starting with &quot;/|\\|\\\\&quot; or a substring of files/folders that</span>
<span class="sd">    don&#39;t exist and there&#39;s no way to error check it.</span>

<span class="sd">    Example of why os.path.commonprefix sucks:</span>
<span class="sd">     &gt;&gt;&gt; path1 = &quot;some/directory/within/project.txt&quot;</span>
<span class="sd">     &gt;&gt;&gt; path2 = &quot;some/directory/withstanding/project.txt&quot;</span>
<span class="sd">     &gt;&gt;&gt; os.path.commonprefix([path1, path2])</span>
<span class="sd">     &quot;some/directory/with&quot;  # This is not necessarily a file or folder!</span>

<span class="sd">    .. TODO::</span>
<span class="sd">     It may be worth doing in the future to remake this as a wrapper function</span>
<span class="sd">     to os.path.commonprefix() and simply test if any folder starts with the</span>
<span class="sd">     substring match and, if that same matched folder is the [-1] index of the</span>
<span class="sd">     checked file(s)/folder(s) it could return True and still do the same thing</span>

<span class="sd">    Args:</span>
<span class="sd">        path (str): The path that supposedly is the root of all other paths listed</span>
<span class="sd">                    in comparisonPaths</span>
<span class="sd">        comparisonPaths (iterable of strs): An iterable of paths to check</span>
<span class="sd">                                            against path for a common parent</span>
<span class="sd">                                            directory</span>

<span class="sd">    Returns:</span>
<span class="sd">        bool: True/False</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">for</span> <span class="n">index</span><span class="p">,</span> <span class="n">item</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">comparisonPaths</span><span class="p">):</span>
        <span class="c1"># temp paths - remove the instance of path in list</span>
        <span class="k">if</span> <span class="n">path</span> <span class="o">!=</span> <span class="n">item</span><span class="p">:</span>
            <span class="n">hasCommonDir</span> <span class="o">=</span> <span class="n">get_common_parent_dir_pair</span><span class="p">(</span><span class="n">path</span><span class="p">,</span>
                                                      <span class="n">item</span><span class="p">,</span>
                                                      <span class="n">mustExist</span><span class="o">=</span><span class="n">mustExist</span><span class="p">,</span>
                                                      <span class="n">mustMatch</span><span class="o">=</span><span class="n">mustMatch</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">hasCommonDir</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
                <span class="k">break</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">False</span>

    <span class="k">return</span> <span class="bp">True</span></div>
<span class="c1"># end has_common_parent_dir</span>


<span class="k">if</span> <span class="n">__name__</span> <span class="o">==</span> <span class="s1">&#39;__main__&#39;</span><span class="p">:</span>
    <span class="k">print</span><span class="p">(</span><span class="n">__doc__</span><span class="p">)</span>
    <span class="c1"># import tempfile</span>
    <span class="c1"># fileH = tempfile.mkstemp()[1]</span>
    <span class="c1"># bytes = 10240</span>
    <span class="c1"># size = test_byte_file(fileH)</span>
    <span class="c1"># if size != bytes:</span>
    <span class="c1">#     sys.exit(&quot;It didn&#39;t work&quot;)</span>
    <span class="c1"># path1 = &quot;/home/selecaotwo/Desktop/destination_folder&quot;</span>
    <span class="c1"># path1 = &quot;C:/home/selecaotwo/Desktop/destination_folder&quot;</span>
    <span class="c1"># path2 = &quot;C:/home/selecaotwo/Desktop/src_folder&quot;</span>
    <span class="c1"># match = get_common_parent_dir_pair(path1, path2, mustExist=False)</span>
    <span class="c1"># print match</span>
</pre></div>

           </div>
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2016, Colin Kennedy.

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'../../../',
            VERSION:'1.0.0',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true
        };
    </script>
      <script type="text/javascript" src="../../../_static/jquery.js"></script>
      <script type="text/javascript" src="../../../_static/underscore.js"></script>
      <script type="text/javascript" src="../../../_static/doctools.js"></script>

  

  
  
    <script type="text/javascript" src="../../../_static/js/theme.js"></script>
  

  
  
  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.StickyNav.enable();
      });
  </script>
   

</body>
</html>